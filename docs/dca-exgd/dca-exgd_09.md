编排介绍

在本章中，我们将讨论可应用于容器环境的编排概念。我们将了解为什么需要编排来部署基于容器组件的应用程序在一组节点上。编排器为环境提供了新功能，但也引入了新的管理挑战。我们还将查看新的定义，以便我们可以在分布式编排环境中提供 Docker 引擎的功能。本章将介绍重要的概念，这些概念将帮助您了解 Swarm 和 Kubernetes 编排器。

我们将学习编排作为一个概念，并引入一些有趣的话题，如在分布式和动态环境中编排的重要性，以及它允许我们轻松地扩展和缩减以及更新应用程序组件。我们还将学习如何管理无状态和有状态组件，并在分布式部署中提供数据持久性。

在本章结束时，您将了解什么是编排器及其如何应用于基于容器的应用程序环境。

在本章中，我们将涵盖以下主题：

+   引入编排概念

+   学习容器编排

+   调度应用程序集群范围

+   管理数据和持久性

+   扩展和更新应用程序组件

本章不包括任何实验室，因为它是一个介绍性的章节，涉及理论和一般概念。

让我们从介绍编排作为管理分布式应用程序的关键概念开始。

# 第十章：引入编排概念

了解本章中的编排概念是关键的，以便我们可以更多地了解 Docker Swarm 或 Kubernetes。让我们想象一个交响乐团：有小提琴手、钢琴手、打击乐手等等；每位乐手都经过多年的学习成为专业音乐家。他们可以独奏完美，但当我们增加更多乐器时情况就变得困难。乐手们可以阅读乐谱，每个人都会演奏自己的部分。但即使是最优秀的音乐家在一起演奏时也需要有人引导。指挥是确保所有乐器协调运作的关键。 

当我们将应用程序分解为小块 - 微服务 - 需要编排。一个应用程序需要许多组件协同工作。记住，将单片应用程序分割成不同的功能也会创建新的开发工作流程。我们可以有不同的开发人员小组，专注于一个功能。每个应用程序组件都是一个原子组件。

部署一个应用程序需要同时执行和管理其所有组件。一个编排器将管理这些组件和应用程序的生命周期。

编排还将管理组件的依赖关系，或者至少提供一些工具来实现应用程序逻辑。

当应用程序的组件分布在一组计算节点中时，编排显得尤为重要。我们甚至可以将这些组件分布在不同的云提供商上，或者将本地和云基础设施混合使用。

时间同步在分布式环境中至关重要，特别是在我们使用**安全套接字层**/**传输层安全**（**SSL**/**TLS**）或其他基于证书的解决方案来保障连接安全时，这一点更为重要。

总结来说，我们可以说，编排提供了我们管理应用程序组件所需的工具，使其能够在分布式环境中无缝运行。

现在我们已经了解了协调器在分布式应用程序中的作用，接下来我们深入探讨容器环境。

# 学习容器编排

编排帮助我们管理运行多个组件的应用程序。在我们的案例中，这些组件或微服务将在容器中运行。因此，下面我们来总结一下容器环境中所需的特性：

+   **部署**：所有应用程序组件必须以协调的方式运行。协调器应帮助我们按需部署应用程序组件，并确保它们按正确的顺序运行。

+   **配置**：在分布式环境中管理配置并不容易。协调器应当管理此配置，并且该配置应在任何容器需要时都能访问。

+   **弹性**：如果某个应用程序组件失败，协调器应尽可能保持应用程序的健康。

+   **扩展**：微服务概念允许将应用程序组件复制，以提高应用程序性能（如果需要）。如果不再需要额外的计算资源，我们应该能够停用这些副本，以节省资源。

+   **节点分布**：为了确保高可用性，我们将提供一池协调的计算节点。这样，我们可以将所有应用程序组件分布在不同的节点上。如果其中一些节点宕机，协调器应确保这些节点上的组件能够自动在其他健康的节点上运行。

+   **网络**：由于我们在不同主机之间分发应用程序，协调器需要提供所需的应用程序组件交互。在这种情况下，网络非常关键。

+   **发布**：协调器还应确保与正在运行的应用程序组件进行交互，因为我们应用程序的目的是为客户提供服务。

+   **状态**：应用程序组件的状态很难管理。因此，编排无状态组件更容易。这就是为什么人们将容器视为临时工件的原因。我们了解到容器有它们自己的生命周期，它们并不真的是临时的。它们存在于主机上，直到有人删除它们，但编排应在允许的地方调度这些组件。这意味着容器的状态应该以协调的方式进行管理，并且组件应该在任何地方以相同的属性运行。当应用程序组件移动到另一个主机时，必须维护它们的状态。在大多数情况下，如果组件死亡，我们将运行一个新的、新鲜的容器，而不是尝试重新启动一个不健康的容器。

+   **存储**：如果某些应用程序组件需要存储，例如持久化数据，编排器应提供与主机可用存储提供者交互的接口。

正如你所看到的，编排帮助我们维护应用程序逻辑，但它并不能做到魔法。事实上，编排器并不了解你的应用程序逻辑。我们必须以某种配置形式提供这些逻辑。

在本章中，我们介绍了可以应用于众所周知的容器编排器的概念。Kubernetes 和 Swarm 是最常用的，尽管还有其他编排器。

编排不会直接运行容器。容器被打包到其他编排结构中。这些原子结构将根据某些属性或关键值在整个集群中进行调度，编排器应该决定最佳的启动这些原子组件的位置。所有编排器都需要类似数据库的组件来存储编排对象、它们的属性和状态。

在 Kubernetes 中，我们部署 Pod，这是一起运行的多个容器。在 Swarm 中，我们部署服务，这些服务基于任务 - 最终，这些任务都是容器。因此，我们从不启动容器。我们有其他部署单位。如果我们将容器原样部署到主机上，它将不会由编排器管理。

在 API 时代，编排器是通过其公开的 API 进行管理的。事实上，我们将使用 `kubectl` 和 `docker` 命令通过它们的 API 与编排过程进行交互。这对我们来说将是透明的。客户端应用程序将使用不同的参数和操作来执行工作。

编排器还基于微服务架构。它们有许多分布式组件。至少需要一个数据库，正如我们之前提到的，还需要一个 API 服务器和一个调度器来决定在哪里运行定义的应用程序工作负载。我们将考虑应用程序作为逻辑组件组，使用调度单元进行定义。

在下一节中，我们将讨论编排如何决定在整个集群环境中运行应用程序组件的位置。

# 在整个集群中调度应用程序

到目前为止，我们已经了解了协调器的期望功能以及使其正常工作的基本组件。我们提到了将应用程序组件分布到不同的主机上。为了能够分布应用程序组件，我们需要部署一个集群。集群是一个由多个节点协同工作的集合。将应用程序部署到主机上的过程应与将同一应用程序部署到集群上类似。协调器将管理整个工作流，这一过程对我们来说应是透明的。

协调器通常管理具有不同角色的节点。根据这些节点运行的进程类型，我们将定义管理节点和工作节点。每个协调器的实现可能会有不同的名称，但逻辑是一样的。管理节点执行协调控制平面，而工作节点执行应用程序部署。因此，工作节点是计算节点。

控制平面节点管理协调框架所需的所有操作。前面提到的数据库，用于存储所有对象定义和状态，将运行在这些节点上。调度器逻辑也将在这些节点上运行。根据使用的数据库类型，协调工作可能需要一些特殊节点。许多协调器依赖于键值数据库（通过 HTTP/HTTPS 协议访问的非常快速的数据库）。

在这些情况下，数据库使用 Raft 共识协议。这意味着在环境中的每个更改被存储到数据库之前，必须有一个定义的节点数量进行投票。只有当所有必要的投票正确收到后，数据库的值才会同步到其他节点。这确保了所有节点都有相同的信息，并且在部分节点宕机时，数据库仍然是安全的。这在这些环境中是一个非常重要的特性。这也是为什么 Swarm 和 Kubernetes 等要求特定数量的管理节点才能正常工作的原因。

所有被协调的对象都有标签。其中一些标签是由协调器自动添加的，例如设置集群节点架构。其他标签可以手动配置，以定义一些特殊的行为或特征，比如定义组件的应用层或层级。层级是管理集群对象交互的关键。

协调器还将管理所有节点资源（如 CPU、内存和可用端口等），并在部署之前检查是否有足够的资源来运行定义的工作负载。

编排器将在决定在哪个节点执行工作负载之前，审查所有节点资源、标签和其他应用要求。我们将能够设置一些亲和性和反亲和性功能，以指定一些特殊需求，当然，我们还可以使用标签帮助编排器为它们选择合适的位置。我们将使用这些标签将应用组件与更快速的节点、靠近某些必需组件的节点，或在集群中的每个节点上分布的节点关联起来。

请记住，应用组件可以在整个集群中部署。编排器应管理它们的网络交互并提供对这些部署的访问。

这些是编排的基本组件以及编排调度背后的逻辑。在下一节中，我们将简要了解数据和应用状态是如何管理的。请记住，本章仅是对一些编排概念的简要介绍，这些概念将由 Docker Swarm 和 Kubernetes 在其工作流中实现，具有不同的架构和更复杂的内容。

# 数据管理与持久化

在许多情况下，应用组件需要存储一些数据。在分布式环境中，这可能非常复杂。这就是为什么我们通常将容器视为短暂组件。无状态组件容易实现，但在有状态组件中，我们尝试将持久数据与容器的文件系统解耦。请记住，容器中的数据可能会丢失。事实上，编排系统并不关心数据，因此，如果一个容器崩溃，它只会运行一个新的容器。在这些情况下，我们需要将数据持久化到容器的环境之外。我们可以使用在第四章中学习到的关于卷对象的知识，*容器持久化与网络*，来实现这一点。我们定义了卷，以绕过容器的文件系统，从而提高性能并将数据存储在容器生命周期之外。

在分布式环境中，使用主机的本地存储会导致当应用组件从一个主机迁移到另一个主机时，出现不一致的状态。为避免这些情况，我们将使用主机的外部卷。事实上，我们将选择一种存储驱动程序，使我们能够在任何地方运行应用组件，同时保持它们所需的存储。所有编排器都可以根据需要向容器提供 NFS 存储，但在某些情况下，这还不够，需要使用专业驱动程序。云服务提供商和许多本地 **软件定义存储** (**SDS**) 厂商提供 REST API 接口。存储驱动程序使用这些定义来帮助编排器找到合适的节点，以运行我们的应用组件。

编排器并不知道我们的应用逻辑。实现应用逻辑的代码是我们的责任。举例来说，一些编排器不会管理组件之间的任何依赖关系。我们还需要实现组件健康检查、规则以及在任何依赖组件故障时需要遵循的程序。如果所需的组件无法访问，我们应该实现重试程序。

Docker Swarm 和 Kubernetes 提供对象来确保配置文件和密钥（身份验证文件或凭证）在集群范围内分发。如前所述，编排不会管理数据，仅会管理这些类型的配置对象。

在下一节中，我们将学习编排器如何允许我们实现复制组件，以及如何在这些环境中简化应用程序升级。

# 扩展和更新应用组件

编排器还提供了另一个很棒的功能。如果我的应用准备运行某些组件的多个实例，编排器将帮助我们轻松管理这种复制。之所以容易，是因为组件基于容器，因此如果我们需要运行某个组件的多个副本，可以请求编排器执行更多容器。事实上，这一功能至关重要，因为在编排中，我们定义了应用组件及其所需的健康副本数量。如果所有所需副本都存活，该应用组件将被视为健康的。如果某个副本死亡，编排器会启动一个新的副本，以确保完成所需数量。

副本管理是编排器提供的一个功能。如果应用性能受到影响且应用逻辑允许复制，我们可以扩展或缩减组件的副本或实例数量。

另一方面，我们了解到微服务应用模型更适合组件的生命周期。开发人员可以专注于每个组件，修复错误和升级也更加容易。每个组件都被视为独立的功能模块。这使得我们能够将每个模块与其他模块分开管理。我们可以升级某个组件而不影响其他组件。编排器也管理这些过程。我们设定新的定义或属性，例如为应用组件设置新的镜像或不同的端口，编排器会为我们部署这些更改。我们能够设置如何进行这一过程。例如，我们决定一次更新多少个实例，或者更新之间的间隔等有趣的设置。

我们将在每个编排器章节中深入探讨这些功能。我们将在第八章，*使用 Docker Swarm 进行编排*和第九章，*使用 Kubernetes 进行编排*中了解 Docker Swarm 和 Kubernetes。

# 总结

在这一短小的章节中，我们学习了一些重要概念，这些概念将帮助我们理解 Docker Swarm 和 Kubernetes。我们先回顾了一下编排的概念，然后再详细了解编排所提供的功能。得益于编排，我们能够在不同的节点上跨集群分布应用组件，以提供更好的性能和可用性。应用的稳定性也得到了提升，因为我们能够执行多个组件实例。如果某些实例崩溃，编排工具将会部署新的实例。我们还能够根据应用的需求，在环境中按需扩展或缩减组件。

编排使用新的集群对象。这些对象存储在分布式数据库中，以确保高可用性。组件的状态和其他编排数据也将存储在这个数据库中。应用组件的数据和必要的逻辑并不由编排工具管理。我们使用外部组件共享信息，编排工具与它们交互，以确保当组件在不同的主机上部署时所需的数据能够随时可用。

在下一章中，我们将深入了解 Docker Swarm，并学习 Docker 如何实现我们已经回顾过的编排功能。

# 问题

在这一章中，我们总体了解了编排。接下来，我们将通过一些问题复习本章中介绍的内容：

1.  以下哪个句子是正确的？

a) Kubernetes 和 Swarm 是运行分布式应用的编排工具。

b) 编排将应用逻辑复制为基于容器的对象。

c) 在分布式环境中无法管理应用数据。

d) 以上所有句子都是错误的。

1.  编排工具管理哪些内容？

a) 应用组件的数据。

b) 应用组件的逻辑。

c) 应用组件的弹性。

d) 以上选项都不正确。

1.  在分布式环境中部署多个组件的应用时，我们面临哪些挑战？

a) 应用组件的网络。

b) 应用组件逻辑。

c) 应用组件的弹性。

d) 以上选项都不正确。

1.  编排为应用部署提供了哪些功能？

a) 我们通过设置所需的副本数来部署应用组件，以确保其健康。

b) 应用组件可以根据环境的需求进行扩展或缩减，编排工具将启动所需的实例。

c) 应用组件一次性全部更新。

d) 以上选项都不正确。

1.  编排工具如何选择在哪个节点运行应用组件？

a) 具有足够资源的节点可以接收工作负载。

b) 我们可以为节点打标签，以便将某些组件固定在特定节点上。

c) 协调器将检查已定义的规则，以选择运行每个组件的位置

d) 所有前述句子都是正确的。

# 进一步阅读

+   Raft 一致性算法：[`raft.github.io/`](https://raft.github.io/)

+   Docker Swarm 特点：[`docs.docker.com/engine/swarm/`](https://docs.docker.com/engine/swarm/)

+   Kubernetes 简介及其特点：[`kubernetes.io/docs/concepts/overview/what-is-kubernetes/`](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)
