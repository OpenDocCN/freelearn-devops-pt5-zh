总结重要概念

在本章中，你将了解哪些主题对考试最为重要，并对通过**Docker 认证助理**（**DCA**）考试所需的知识有一个清晰的了解。

我们将回顾所有关于编排、镜像管理、Docker 平台组件的安装和配置、单节点和集群环境的网络实现、安全功能以及基于容器的应用数据管理策略的主题。这些概念已经在不同章节中涵盖。

本章我们将总结以下主题：

+   回顾编排概念

+   Docker 镜像概念的简要总结

+   Docker 架构、安装和配置主题的总结

+   网络主题的总结

+   理解安全概念和相关的 Docker 功能

+   快速总结 Docker 存储和卷

在本章结束时，你将为一些类似考试的问题做好准备，这些问题已经在下一章为你准备好。在查看一些样题之前，让我们先来讨论一下我们已经学习的编排概念。

# 第十九章：回顾编排概念

编排是 DCA 考试的重要主题，它占据了考试问题的 25%。在本书的第二部分，我们介绍了编排，并讲解了 Docker Swarm 和 Kubernetes。

编排概念已在第七章，*编排简介*，第八章，*使用 Docker Swarm 进行编排*，第九章，*使用 Kubernetes 进行编排*，第十章，*Docker 企业平台简介*，以及第十一章，*通用控制平面*中讲解。

这是 Docker Swarm 功能的简要总结。我们建议你阅读这个总结，以帮助你记住我们已经学习的概念：

+   在介绍编排之前，我们开始讨论多容器应用程序，因为它是容器编排的第一种方法。它们在本地运行，使用 Docker Compose（`docker-compose`工具）和应用程序组件，它们的交互通过`docker-compose.yml` YAML 文件来描述。多容器应用程序将所有组件一起运行在 Docker 主机上，但我们可以对其组件进行伸缩操作，以及与它们交互和查看它们的日志。

+   Docker Swarm 编排 Docker 服务，为其提供弹性、内部发现和负载均衡，在集群环境中运行。我们的应用工作负载将在集群中分布。

+   我们将在 Docker Swarm 中使用两种类型的节点角色——管理节点和工作节点，这些角色可以进行修改。

+   我们将部署多个管理节点和多个工作节点，以提供集群的高可用性以及部署在其上的工作负载。

+   其中一个管理节点也是集群的领导者，它会在一个内部数据库中更新所有集群资源的更改，并在管理节点之间进行同步。Docker Swarm 使用 Raft 算法来更新更改，因此在提交更改之前，需要管理节点之间达成共识。

+   Docker Swarm 拥有管理平面、控制平面和数据平面。管理平面和控制平面可以与数据平面隔离，并且开箱即用地进行加密。数据平面也可以加密，但不是默认加密（我们需要对每个自定义网络进行加密）。

+   Docker Swarm 会发放和维护一个内部**证书授权机构**（**CA**），并为所有集群组件管理证书。我们可以锁定这些信息以保证其安全。

+   为了维持集群健康，至少需要(*管理节点数 / 2 + 1*)个健康的管理节点。如果管理节点数量少于要求的数量，集群内无法进行任何更改，但应用程序工作负载将继续运行。如果服务失败，且集群不健康，则无法恢复。

+   Docker Swarm 使用 Raft 日志来维护节点之间的内部键值存储同步。因此，需要一个奇数数量的管理节点才能维持共识。这同样适用于 Kubernetes，但它使用`etcd`作为键值存储。

+   所有节点都可以运行应用程序工作负载，但我们可以根据需要更改此行为，例如在需要排空节点或禁止新工作负载时，而不会中断已经运行的工作负载。

+   集群工作负载被声明为服务，并要求有一定数量的实例或副本才能保持健康。这些资源是任务，它们将运行一个容器。

+   Docker Swarm 不管理容器；它仅管理服务。因此，我们是基于服务来部署应用程序的，而不是部署独立的容器。

+   服务默认会分配一个虚拟 IP 地址，这个地址在服务生命周期内不会改变。任务只会运行一个容器；它们没有关联的 IP 地址，并且始终保持原有名称。如果任务的容器死亡或需要进行一些更新，系统将创建一个新的任务，并保持原有名称。容器将获得新的 IP 地址，但内部负载均衡器会将其作为服务的后端端点关联。

+   我们可以根据需要随时扩展或缩减服务所需的任务数量。然而，在这种情况下，Docker 不会管理我们的应用程序行为。

+   任务会自动调度到健康节点上，前提是该节点有足够的资源来运行关联服务的任务，但我们可以强制将任务定位到特定的节点上。

+   Docker 提供了一些模板工具，帮助我们使用 Docker Swarm 变量来格式化、筛选和创建独特的资源。

+   Docker Swarm 中的网络使用桥接接口，正如我们在学习 Docker 容器时也了解到的那样。我们使用 VXLAN 技术部署覆盖网络，跨集群分布，以提供在不同主机上运行的容器之间的通信及其他网络功能。

+   Docker Swarm 提供了默认的路由网格策略，用于发布集群服务，以便用户和其他应用程序使用。默认情况下，服务的端口将在所有集群节点上发布，即使它们没有运行任何服务任务。内部路由将服务请求引导到适当的后端容器。我们可以使用常见的 Docker Swarm 命令选项更改这些行为。

+   正如我们在 Docker Engine 中学到的那样，服务默认并不会被发布供使用。我们需要手动发布服务端口和进程。

+   将应用程序发布到外部可以通过 Docker Swarm 的路由网格或 Docker Enterprise 中的 Interlock 来完成。Interlock 提供了一种集成的自动化反向代理解决方案，保护应用程序的后端。我们只需发布 `interlock-proxy` 组件，而 Docker Swarm 服务会内部接收请求。因此，服务不需要额外发布；只需配置一些标签，告知 Interlock 应用程序所需的转发。

+   我们可以根据需要创建任意数量的覆盖网络，它们将相互隔离，这一点与自定义桥接网络的工作原理类似。

+   编排引入了一些新概念，如秘密和配置，以提供分布式集群内存储的信息。Docker Swarm 会对秘密进行加密和保护，我们使用这些秘密配置密码、证书或令牌，通过内存文件系统进行管理。配置对象帮助我们在不同主机上运行的容器间分发配置，而无需手动在节点之间同步文件。

+   在 Docker Swarm 中，我们使用 Docker stacks 部署应用程序。这些资源允许我们部署跨集群分布的多服务应用程序。我们将在一个类似 `docker-compose` 的文件中定义所有所需的应用程序资源（服务、秘密、网络、配置、卷等），然后使用这些文件来部署完整的应用程序。所有应用组件的更改或更新都应该写入这些文件，因为它使我们能够将应用程序的部署管理为代码。

+   应用组件的更新通过滚动更新进行管理。我们可以手动或使用 Docker stacks 部署更改。在这两种情况下，我们都能平稳地部署更改，避免服务中断和对用户的影响。如果更新出现问题，我们可以轻松执行回滚，恢复到之前的服务配置。

+   我们还回顾了 Kubernetes 编排器，因为它被包含在 Docker Enterprise 中。这个编排器与 Docker Swarm 有许多不同之处，尽管两者最终都管理容器。我们学习了 Kubernetes 组件及其交互方式。

+   Docker Enterprise 为我们提供开箱即用的完整原生（非定制化）Kubernetes，包括默认使用 Calico 作为 **容器网络接口**（**CNI**）。所有工作节点（DTR 需要专用工作节点）可以设置为运行 Docker Swarm、Kubernetes 工作负载，甚至同时运行两种编排工作负载。

+   Pods 是 Kubernetes 中最小的调度单元，但它们不提供弹性。我们需要将它们集成到编排的模板化资源中，例如 ReplicaSets、DaemonSets 或部署。

+   Kubernetes 提供一个扁平化的网络。这意味着所有部署的 pods 都可以互相看到。服务之间的通信默认始终是允许的。为了确保安全，在这种情况下，我们需要部署 NetworkPolicy 资源，仅允许特定组件之间的通信。

尽管 Docker 堆栈和使用 `docker-compose` 的多容器应用程序使用相同类型的 YAML 文件，但有些键仅对其中一个有效。例如，像 `depends_on`、`build` 或 `volumes_from` 这样的键仅适用于 Docker Compose 多容器应用程序；因此，当我们尝试在 Docker 堆栈中使用它们时，会收到一条警告信息，提示此问题。

让我们回顾一下考试所需的主题。

## 考试所需的知识

考试将验证我们对以下主题的知识，除此之外还有其他内容：

+   完成 Swarm 模式集群的设置，包括管理节点和工作节点

+   描述并演示如何将运行单个容器的指令扩展为在 Swarm 中运行的服务

+   描述 Swarm 集群中法定人数的重要性

+   描述运行容器和运行服务之间的区别

+   解释 `docker inspect` 命令的输出

+   使用 `docker stack deploy` 将应用程序部署转换为堆栈文件，通过 YAML compose 文件

+   操作运行中的服务堆栈

+   描述并演示编排活动

+   增加副本数

+   添加网络和发布端口

+   挂载卷

+   描述并演示如何运行复制服务和全局服务

+   应用节点标签来展示任务的分配

+   描述并演示如何使用模板进行 `docker service create`

+   识别排查无法部署服务的步骤

+   描述 Docker 化应用如何与传统系统进行通信

+   描述如何将容器化的工作负载部署为 Kubernetes pod 和部署

+   描述如何使用 ConfigMap 和 secret 资源为 Kubernetes pods 提供配置。

这些主题摘自 Docker 官方学习指南，指南可以在 [`success.docker.com/certification`](https://success.docker.com/certification) 找到。

# Docker 镜像概念的简要总结

镜像是创建容器的基础，这个主题大约占 DCA 考试题目的 20%。我们在第二章《构建 Docker 镜像》中深入讨论了 Docker 镜像，但我们在第三章《运行 Docker 容器》、第六章《Docker 内容信任介绍》以及 *第十三章，使用 DTR 实现企业级注册中心* 中也有所提到。在本章中，我们将快速回顾在这些章节中看到的所有概念，以便做一个总结。

在进入所需知识部分之前，让我们回顾一下与 Docker 镜像相关的最重要的概念、特性和操作：

+   镜像基于写时复制文件系统策略。它们基于不同的重叠层，通过不同的联合文件系统和存储驱动程序应用。目前，容器最常用的文件系统驱动程序是 `overlay2`。Docker 引擎会为我们的系统选择最合适的图形驱动程序，尽管我们可以更改它。

+   容器只是运行在 Docker 主机上的隔离进程。我们使用镜像作为模板，提供根文件系统和元信息来控制进程的行为。

+   创建镜像有三种方法：

    +   **使用 Dockerfile**：此文件包含安装应用程序所需的所有步骤，以及如何启动它。我们还提供应该用于与容器进程通信的端口和协议。此方法是可重复的，并提供基础设施即代码（Infrastructure-as-Code）行为。

    +   **运行容器和提交**：在这种情况下，我们运行一个容器，并在容器内运行命令来安装和配置我们的应用程序。当所有的更改都在容器的文件系统中完成后，我们将这些更改提交，以制作镜像。此方法不可重复。我们通常在无法自动化应用程序安装的情况下使用这种工作流程，例如。

    +   **从零开始构建镜像**：在这种情况下，镜像是轻量级的，因为它们只包含一个空的根文件系统和应用程序二进制文件及依赖项。这个根文件系统不包含任何不必要的操作系统文件。我们通过 Dockerfile 的复制命令将二进制文件添加到其中。

+   多阶段构建也可以作为创建镜像的替代方法。在这种情况下，我们在同一个 Dockerfile 中声明不同的构建过程。我们为每个过程定义一个描述性名称，并定义一个工作流，将文件从不同的构建中复制过来。这使我们能够定义一个阶段，使用所需的编译器、头文件或库在应用程序开发镜像中编译应用程序，然后只将最终开发产品复制到另一个包含运行时环境的阶段。因此，运行时镜像比开发镜像小得多。

+   Dockerfile 通过执行容器来创建镜像。每个容器都会在其根文件系统中进行更改，这些更改会被提交（存储）以供后续容器使用，执行时会使用先前容器的层。

+   更小的镜像更安全，因为镜像中包含不必要的二进制文件、库和配置是有风险的。镜像应仅包含应用程序所需的内容。

+   构建更好的镜像时，有几个重要的实践需要遵循：

    +   切勿将调试工具或编译器添加到生产环境镜像中。

    +   声明镜像上所有需要的资源，例如暴露的端口、主要进程执行所需的用户以及将用作卷的目录。这些有助于其他用户轻松理解你的应用程序如何工作并如何使用。

    +   除非进程严格要求，否则不要在应用程序镜像中使用 root 用户。

    +   构建镜像时，每个容器只运行一个进程。每个容器运行多个进程时，维护和验证其健康状态会变得更加困难。

    +   我们总是需要在镜像间层的可移植性和镜像的大小之间做出选择。有些情况下，拥有较少的层会更好，而在其他时候，拥有更多的层则更好，因为其他镜像会重用它们。镜像层缓存对于加速镜像构建过程至关重要。

    +   始终在 Dockerfile 中添加健康检查，以帮助 Docker 引擎验证容器的健康状态。

+   Docker 提供了构建和分发 Docker 镜像所需的所有命令。我们还可以检查它们的内容或构建历史，以帮助我们调试它们的过程或创建新的镜像。

+   需要理解的是，悬挂镜像（来自先前构建的未引用层）会一直保留在 Docker 主机上，直到你删除它们。管理员应保持 Docker 平台的整洁，避免由于磁盘空间丢失导致主机性能下降。

+   在容器平台上，良好的镜像标签管理是基础。我们还可以在 Dockerfile 中使用标签，为 Docker 镜像添加元信息。你应该尽量通过标签唯一地标识镜像，但请记住，只有镜像的 ID 才能真正唯一地标识一个镜像。一个镜像可以有多个名称和标签，但只有一个 ID。

+   我们可以在 Dockerfile 中包含变量。这将帮助我们为不同的阶段构建具有特殊功能的镜像。我们可以将生产环境准备好的镜像交付到生产系统，同时在测试镜像中包含调试和监控工具。它们仍然会包含通用的应用程序二进制文件，但我们将使用调试版本来查看一些特定的问题。变量也可以作为 `docker build` 命令行的参数进行修改。

让我们了解一下考试所需的主题。

## 考试所需的镜像管理知识

考试将验证我们对以下主题的了解，除此之外还有其他内容：

+   描述 Dockerfile 的使用

+   描述选项，如 `add`、`copy`、`volumes`、`expose` 和 `entrypoint`

+   识别并显示 Dockerfile 的主要部分

+   描述和演示如何通过 Dockerfile 创建高效的镜像

+   描述和演示如何使用 CLI 命令管理镜像，例如`list`、`delete`、`prune`和`rmi`

+   描述和演示如何使用`filter`和`format`检查镜像并报告特定属性

+   描述和演示如何为镜像打标签

+   描述和演示如何应用文件来创建 Docker 镜像

+   描述和演示如何显示 Docker 镜像的各层

+   描述和演示如何将镜像修改为单层镜像

+   描述和演示注册表功能

+   部署注册表

+   登录到注册表

+   在注册表中使用搜索功能

+   将镜像推送到注册表

+   在注册表中签署镜像

+   从注册表中拉取和删除镜像

这些主题摘自 Docker 官方学习指南，可以在[`success.docker.com/certification`](https://success.docker.com/certification)找到。

# Docker 架构、安装和配置主题的总结

Docker 平台的安装和配置是每个 Docker 企业管理员的关键。这些主题占考试内容的 15%。它们已在多个章节中涵盖，涉及独立和集群环境。我们在第一章《Docker 与现代基础设施和应用》，第八章《使用 Docker Swarm 进行编排》，第十章《Docker 企业平台》，第十一章《通用控制平面》，以及第十三章《使用 DTR 实现企业级注册表》中学习了这些概念。

这是关于 Docker 平台安装和配置的特别特点和技巧的快速总结。我们建议你阅读此总结，以确保记住所学的概念：

+   **Docker 组件在独立和集群环境中的应用**：我们应该对 Docker 企业组件的分布和功能有较好的了解。

+   **不同平台上各组件的安装过程**：我们看到在 Docker 社区和 Docker 企业环境中，安装过程都很简单。回顾不同平台上的安装过程，并确保你对配置文件位置有清晰的了解。

+   你必须了解所有组件的要求，以及部署**容器即服务**（**CaaS**）企业级解决方案所需的步骤，确保核心组件的高可用性。

+   第一章，*使用 Docker 的现代基础设施与应用程序*，展示了许多 Docker 引擎的配置过程。默认情况下，Docker 会选择最佳的存储驱动程序来管理 Docker 层。记住，我们使用了 `overlay2`，因为如果我们的安装有不同的需求，应该可以更改它。

+   确保你清楚了解 `/var/lib/docker` 目录（或已配置目录）下的文件，以及 Docker 引擎备份中应存储的内容。你还了解了创建 **Universal Control Plane**（**UCP**）和 **Docker Trusted Registry**（**DTR**）备份的程序，以及在何种情况下需要进行恢复的步骤。

+   只有 Docker Enterprise 和 Kubernetes 提供基于角色的访问控制。我们在 第十一章，*Universal Control Plane* 和 第十三章，*使用 DTR 实现企业级镜像仓库* 中分别介绍了 Docker Enterprise 权限和 UCP 与 DTR 的基本配置。

+   回顾我们如何配置 TLS 通信以进行客户端认证，当我们不需要不同授权级别时。这部分内容在 第一章，*使用 Docker 的现代基础设施与应用程序* 中有详细介绍。

+   Cgroups 和内核命名空间提供容器隔离。这是确保进程拥有足够资源且不与同一主机上其他进程进行非授权通信的关键。

现在我们将回顾考试应了解的主题。

## 参加考试所需了解的 Docker 平台知识

考试将验证我们对以下主题的理解，及其他内容：

+   描述安装的规模要求

+   描述并演示如何设置仓库，选择存储驱动程序，并在多个平台上安装 Docker 引擎

+   描述并演示如何配置日志驱动程序（`splunk`、`journald` 等）

+   描述并演示如何设置 Swarm，配置管理节点，添加节点，并设置备份计划

+   描述并演示如何创建和管理用户与团队

+   描述并演示如何配置 Docker 守护进程在启动时自动启动

+   描述并演示如何使用基于证书的客户端-服务器认证，以确保 Docker 守护进程具有访问镜像仓库的权限

+   描述命名空间、cgroups 和证书配置的使用

+   描述并解读错误信息，以便在没有帮助的情况下排查安装问题

+   描述并演示如何在 **Amazon Web Services**（**AWS**）和本地环境中，以高可用性部署 Docker 引擎、UCP 和 DTR

+   描述并演示如何为 UCP 和 DTR 配置备份

这些主题摘自 Docker 官方的学习指南，可以在[`success.docker.com/certification`](https://success.docker.com/certification)找到。

# 网络主题总结

网络是微服务应用架构的核心组件之一。更快的网络促使了分布式架构的演变。通过现代基础设施，甚至在云或云混合架构上，也可以提供高可用性和弹性。容器像小型虚拟节点一样工作，并且它们获得虚拟接口。我们了解到，网络命名空间允许我们在同一主机上隔离进程，即使它们使用相同的桥接接口与实际网络进行通信，也可以从主机的网络命名空间中隔离开来。集群中的分布式网络也非常简单，因为 Docker Swarm 管理所有必要的内部基础设施和进程，以允许不同主机上的容器之间进行通信。Docker Swarm 中的覆盖网络跨集群分布，使用 VXLAN 封装流量，并且甚至可以进行加密。默认情况下，Docker Swarm 控制平面的组件通过**相互 TLS**（**MTLS**）通信进行保护，我们可以将应用数据与网络管理隔离开来。

所有这些主题都在多个章节中介绍了 Docker Engine、Docker Swarm 和 Kubernetes。我们在第四章中学习了*容器持久性与网络*，在第八章中学习了*使用 Docker Swarm 进行编排*，在第九章中学习了*使用 Kubernetes 进行编排*，在第十一章中学习了*通用控制平面*，以及在第十二章中学习了*在 Docker 企业版中发布应用程序*。

在第九章中，我们学习了 Kubernetes 如何实现集群范围的网络功能。我们还将这些功能与 Docker Swarm 实现进行并列比较，以便更好地了解如何使用两者，或者如何创建能够在它们任何一个上运行的容器工作负载。

我们还了解到，容器可以在内部暴露其应用程序进程。其他容器可以使用它们的服务，但我们需要发布它们的端口以供外部用户和应用程序访问。这一点非常重要，因为在 Docker Swarm 中，处于同一网络的容器之间会确保安全。它们是相互隔离的，因此我们只能发布前端应用程序的组件。

让我们总结一下网络相关的主题：

+   Docker 引擎的网络是基于桥接网络的，尽管我们可以使用 MacVLAN 接口（带有真实 IP 地址），基于主机的网络（使用其网络命名空间），甚至可以通过插件扩展默认行为。我们可以使用默认或自定义桥接网络。自定义网络还部署内部 DNS 设施，因此在这些网络上运行的容器可以通过它们的名称互相识别。在某些特殊情况下，部署不带网络功能的容器也是有用的。

+   Docker Swarm 中的网络配置很简单，因为 Docker 创建新的虚拟网络（覆盖网络），并部署 VXLAN 隧道来封装所有主机的流量。如果服务任务部署在同一个覆盖网络上，它们的容器可以互相看到。

+   Kubernetes 的网络模型更加简单。它基于一个扁平网络，服务和 Pod 默认情况下始终可达。为了使其工作，我们需要集成一个 CNI。每个 CNI 都有自己的扁平网络模型实现，而 Docker Enterprise 默认部署 Calico（[`www.projectcalico.org/`](https://www.projectcalico.org/)）。

+   扁平网络默认情况下不安全，因为应用程序组件没有被隔离。我们将使用网络策略来隔离应用程序，通过命名空间、标签等进行分组。NetworkPolicy 资源管理连接规则，允许或禁止特定 Pod 的连接及其流量。

+   Docker Swarm 节点默认使用加密的 TLS 通信（双向 TLS）。Docker 管理所有所需的证书。用户与集群的通信是不安全的，但我们也可以手动创建安全通信（在《第八章》中有一个完整的示例，解释所有必需的步骤，*使用 Docker Swarm 进行编排*），或者使用 UCP 集成的 **基于角色的访问控制**（**RBAC**）。UCP 提供用户包，包含创建安全 TLS 隧道所需的所有文件。

+   Kubernetes 还会加密其控制平面。Docker Enterprise 会为我们完成所有部署工作，在安装后会启动一个完全功能的 Kubernetes 集群。证书将用于在 Kubernetes 组件和用户之间默认部署 TLS 隧道。

+   本地自定义桥接和覆盖网络部署了内部 DNS。因此，容器和服务可以通过它们的名称进行发现。容器使用内部 DNS，外部解析将被转发到特定的外部 DNS。默认情况下，容器接收主机的 DNS 配置，但我们可以更改这种行为。

+   Kubernetes 也集成了内部 DNS。在这种情况下，`kube-dns` 组件将管理所有服务条目。

+   内部负载均衡也部署在覆盖网络中。请记住，服务可以是复制的或全局的。在这两种情况下，默认使用 `vip` 模式，服务将获得一个特殊入口网络中的 IP 地址。此 IP 地址已注册，内部负载均衡器将请求路由到所有可用服务的副本。我们可以使用 `dns-round-robin` 模式来避免这种行为。

+   Kubernetes 的内部负载均衡具有类似的行为。所有服务默认都会接收一个内部虚拟 IP 地址（ClusterIP）。Kubernetes 中的服务是 Pod 的逻辑组，服务的请求默认会转发到所有关联的 Pod。

+   如前所述，部署在容器中的应用程序默认不会发布其端口，除非我们声明这种行为。在 Docker 引擎上发布端口很简单，我们可以确保只有特定的 IP 地址会监听多网卡节点上发布的端口。桥接网络使用 NAT 来发布应用程序的端口。Docker 会创建所有所需的主机防火墙规则，以允许并路由这些流量。如果我们使用主机的网络，所有容器暴露的端口都会被发布，应用程序将直接可访问。

+   我们还了解到，Docker Swarm 中的服务默认会在所有节点上发布，即使它们没有运行任何服务任务。这个功能被称为路由网状（router mesh），应用程序端口将在所有集群的主机上可用。内部负载均衡也将通过入口覆盖网络应用，并且不同主机上的实例将是可达的。这可能存在安全隐患，因为所有应用程序端口都可以在所有主机上访问。

+   Kubernetes 的 `NodePort` 服务与 Docker Swarm 的路由网状行为相似。声明为 `NodePort` 的服务将在所有集群节点上发布其端口。然而，Kubernetes 也有 `LoadBalancer` 服务类型。这些服务将通过基础设施负载均衡器直接发布。此集成仅适用于某些云服务提供商。

+   UCP 提供了 Interlock 作为避免不安全的路由器网状发布的解决方案。我们已经了解了 Interlock 的组件和部署方式，以及如何使用该工具发布应用程序。Interlock 的端口必须被发布，但所有其他应用程序的服务可以通过 Interlock 访问。因此，我们不需要发布应用程序的端口。这提高了安全性，因为 Interlock 充当反向代理，提供 TLS 安全性、基于主机和内容的服务路由以及粘性会话等功能。Interlock 代理组件将使用服务标签进行更新；因此，只有具有特定标签的服务才会被发布。我们已经了解了这些必需的标签，并审查了一些示例用法。

+   Kubernetes 可以集成入口控制器，避免 `NodePort` 在集群范围内发布应用程序。入口控制器部署类似反向代理的功能，将请求路由到匹配特定头部或内容规则的适当服务。这提高了安全性，因为服务不应该被直接发布。我们只发布入口控制器（例如使用服务策略），而入口资源管理着必要的规则，用于访问这些服务，尽管它们没有对外发布。

如前所述，网络在集群环境中至关重要。让我们回顾一下通过考试所需的一些主题。

## 通过考试所需的 Docker 网络知识

考试将验证我们对以下主题的了解，等等：

+   描述容器网络模型及其如何与 Docker 引擎、网络和 IPAM 驱动程序交互

+   描述内建网络驱动程序的不同类型及其使用场景

+   描述 Docker 引擎、注册表和 UCP 控制器之间流动的流量类型

+   描述并演示如何创建一个 Docker 桥接网络供开发人员使用其容器

+   描述并演示如何发布端口，使应用程序可以对外访问

+   确定容器在外部可访问的 IP 和端口

+   比较和对比主机与入口发布模式

+   描述并演示如何配置 Docker 使用外部 DNS

+   描述并演示如何使用 Docker 对 HTTP/HTTPS 流量进行负载均衡，进而实现应用程序负载均衡（配置 Docker EE 的 L7 负载均衡）

+   理解并描述 Docker 引擎、注册表和 UCP 控制器之间流动的流量类型

+   描述并演示如何在 Docker 悬浮网络上部署服务

+   描述并演示如何通过排查容器和引擎日志来解决容器之间的连接问题

+   描述如何使用 ClusterIP 和 NodePort 服务将流量路由到 Kubernetes pod

+   描述 Kubernetes 容器网络模型

这些主题摘自 Docker 官方学习指南，您可以在 [`success.docker.com/certification`](https://success.docker.com/certification) 查找。

下一部分将通过介绍与 Docker 平台安全性相关的必备知识来帮助您。

# 理解安全性概念及相关的 Docker 特性

当你在生产环境中运行应用程序时，安全性至关重要。我们学习了 Docker 及其组件提供的许多安全功能。我们首先回顾了容器如何与其他主机进程隔离，并了解了如何确保 Docker 引擎的安全性。然后，我们继续学习 Docker Swarm，在该环境中必须对整个集群应用安全策略。用户的访问也必须得到管理，我们需要提供身份验证和授权机制。Docker 企业版提供了更高层次的安全性。它包括完整的 RBAC 环境，使我们能够管理细粒度的对象和集群资源权限。

所有这些主题都在多章节中涉及了 Docker 引擎、Docker Swarm、Kubernetes 和 Docker 企业平台。我们在第一章，*使用 Docker 进行现代基础设施与应用程序*，第二章，*构建 Docker 镜像*，第四章，*容器持久性与网络*，第六章，*Docker 内容信任简介*，第八章，*使用 Docker Swarm 进行编排*，第九章，*使用 Kubernetes 进行编排*，第十一章，*通用控制平面*，第十二章，*在 Docker 企业版中发布应用程序*，以及第十三章，*使用 DTR 实现企业级镜像仓库*。

我们必须记住，容器是通过镜像创建的，因此确保镜像的安全性也至关重要。遵循最佳实践是开发安全镜像的关键。Docker 企业版提供了几种策略来验证镜像的优先级、不可变性和内容安全性。

让我们回顾一下其中的一些安全主题：

+   Docker 是一个客户端-服务器应用程序。服务器将在本地（默认情况下）和远程可访问的套接字上发布其 API。我们可以通过限制对这些套接字的访问来限制 Docker 引擎的访问权限。在本地，只有具有文件系统权限的用户才能运行本地 Docker 引擎上的 Docker 命令。

+   Docker 引擎可以与操作系统提供的安全模块（如 SELinux 或 AppArmor）集成。Docker 提供了与容器配合使用的集成和默认配置文件。Docker 还与 Linux 内核集成，允许使用能力添加或移除特定的系统调用。还有一些更简单的安全建议，比如使用只读根文件系统和容器内的非 root 用户，这些也有助于我们提供安全的应用程序。

+   镜像应当安全，以便创建安全的容器。镜像应只包含我们的流程所需的二进制文件、库和配置。所有与应用程序无关的内容都应避免。Docker Enterprise 提供了镜像内容安全扫描器。它将相关内容的文件哈希与已知的公开漏洞和漏洞利用数据库（互联网**常见漏洞和暴露**（**CVE**））进行比对。我们了解了这个过程是如何工作的，以及如何集成标签提升（tag promotion），确保只有被授权的用户可以访问他们的镜像。这些都是 DTR 的一些功能。

+   我们还可以签署镜像。这个过程确保镜像内容的不可变性和所有权。如果我们将镜像构建集成到持续集成和持续部署中，我们可以确保镜像是通过适当的工作流创建的。我们还可以提高 CaaS 的安全性，仅允许基于由组织内特定团队或用户签署的镜像的容器运行。

+   我们了解了签署镜像所需遵循的所有自动化步骤以及集成到该过程中的所有密钥。镜像签名基于内容信任（Content Trust）逻辑，我们了解了它如何在 Docker 中集成，详细内容请参见第六章，*Docker 内容信任简介*。

+   我们提到了一些可以提高工作负载安全性的简单实践，例如运行只读根文件系统或为应用程序使用非根用户（或用户命名空间）。我们应该使用`docker image inspect`来查看镜像的规格，以便了解暴露的端口、应用程序的用户和将在容器内执行的命令。

+   如本章所述，Docker Engine 和 Docker Swarm 都没有任何 RBAC 集成。另一方面，Docker Enterprise 组件具有集成的基于角色的访问控制。UCP 根据角色、权限和集合提供不同的 Docker Swarm 资源访问权限。我们可以配置细粒度的访问控制，管理卷、密钥、配置、网络等资源，因此用户只能对其资源执行允许的操作。用户将通过提供的 Web UI 或 Docker 命令行连接到集群，使用他们的 Docker 客户端软件和 UCP 的捆绑包来执行、审查和修改资源。这个压缩文件包含用户证书和环境脚本，旨在帮助用户轻松连接到集群。

+   DTR 有其独立的 RBAC 环境，与 UCP 的 RBAC 环境隔离。DTR 是一个镜像仓库，因此它的 RBAC 环境专门用于管理对存储在 CaaS 中的镜像的访问。我们可以精细控制权限，允许一组用户使用或修改镜像，而其他镜像则在团队或整个组织内公开。

+   DTR 和 UCP 默认通过单点登录解决方案进行集成，尽管我们可以更改这种行为。我们还可以将它们集成到我们的组织用户管理解决方案中，如 Active Directory，或任何兼容的**轻量级目录访问协议**（**LDAP**）。

+   我们学习了如何部署 Docker Enterprise 组件，以及如何管理用户、角色以及不同级别的资源和镜像访问权限。它们将通过奇数数量的软件节点进行高可用部署，我们需要一个外部负载均衡器来提供用户的访问权限。我们可以集成公司的证书，但也可以使用自动生成的证书。在这种情况下，我们需要将 DTR 的 CA 集成到我们的组织服务器和客户端主机中。

+   虽然 Docker Swarm 需要 UCP 来集成用户管理，但 Kubernetes 实现了自己的 RBAC 系统。我们将能够使用令牌和证书进行身份验证和授权。Kubernetes RBAC 将适用于应用程序和用户，并与 Docker Enterprise 集成。

+   Docker Swarm 和 Kubernetes 提供了证书、密码、令牌等的安全存储。两者都提供了机密资源来管理任何需要保护的文件（或变量）。但是，虽然 Docker Swarm 中的机密是加密的，Kubernetes 中的机密默认情况下并未加密。在 Kubernetes 中，机密资源是使用 Base64 编码的，并且必须进行额外配置才能加密它们。

+   Kubernetes 在安全性方面有先进的功能，如 PodSecurityPolicy 资源，它允许我们强制对 Pods 进行安全设置，允许或禁止特定行为（如根进程和只读文件系统）。也可以实施访问控制器（UCP 的 Kubernetes 部署中已经预配置了一些）来强制执行 Pod 安全策略和其他安全功能，默认应用于我们 Kubernetes 集群中的任何工作负载。

+   我们将使用 RBAC 来管理 UCP 和 DTR 用户访问。首先，我们将确保只有授权的用户才能管理和使用集群资源以支持他们的应用程序。DTR 的 RBAC 将保护镜像，只允许授权的用户操作和更新其内容。

下一部分将重点介绍通过考试所需的知识。

## 考试所需的 Docker 安全知识

考试将验证我们对以下主题的知识，此外还包括其他内容：

+   描述安全管理和任务

+   描述签名镜像的过程

+   描述默认的引擎安全性

+   描述 Swarm 默认安全性

+   描述 MTLS

+   描述身份角色

+   比较和对比 UCP 的工作节点与管理节点

+   描述使用外部证书与 UCP 和 DTR 集成的过程

+   描述并演示镜像如何通过安全扫描

+   描述并演示如何启用 Docker 内容信任

+   描述并演示如何配置 UCP 中的 RBAC

+   描述并演示如何将 UCP 与 LDAP/AD 集成

+   描述并演示如何创建 UCP 客户端包

这些内容摘自 Docker 官方学习指南，网址为：[`success.docker.com/certification`](https://success.docker.com/certification)。

# 快速总结 Docker 存储和卷

使用 Docker 容器需要不同的存储解决方案，正如我们在本书中所学到的那样。镜像和容器是通过多层文件系统策略创建的。然而，我们还必须管理容器化应用的持久性。这种持久性可以与应用数据相关，但我们还必须能够管理集群范围内的配置和状态。

我们在第一章，*现代基础设施与 Docker 应用*，第二章，*构建 Docker 镜像*，第四章，*容器持久化与网络*，以及第十三章，*使用 DTR 实现企业级注册表*中学习了有关安全性的话题。

这是本书中关于容器内存储和卷管理的主题的快速总结。我们建议你通读这个总结，以确保记住学到的概念：

+   我们了解到，容器是基于不同的文件系统和解决方案的，具有一个共同特征——写时复制（copy-on-write）。这使我们能够创建多个不可变层来组织文件。每个层都是另一个层的基础，文件的修改将存储在最后一个被更改的层中。所有不可变层都被视为创建新容器的镜像。我们将为容器添加一个新的读写层。这些层依赖于主机存储。这种存储被称为图形存储，我们将根据主机操作系统使用不同的策略来管理它。Docker 会根据你的内核特性和安装的驱动程序选择最适合你主机的驱动程序。今天最流行且使用最广泛的驱动程序是 `overlay2`，它是许多 Linux 发行版的默认图形驱动程序。`docker info` 提供有关使用的驱动程序的信息。

+   我们还了解到，镜像会在本地存储以便快速使用。当这些镜像必须与集群节点共享时，事情会变得复杂，尽管我们可以导出和导入镜像层。我们将使用镜像注册表来存储镜像并与主机和用户共享其内容。我们学习了如何部署 Docker Registry（社区版）以及 DTR，后者在企业环境中被推荐使用。根据是否使用云环境或本地安装，我们可以为注册表卷使用不同的存储解决方案。正如我们在第十三章，*使用 DTR 实现企业级注册表*中回顾的那样，对基于大层的镜像存储来说，对象存储是非常好的解决方案，这也是创建镜像最常见的方式。

+   镜像可能会占用宿主机大量空间。我们应该注意这一点，并使用`docker system df`检查无用的容器和占用空间的镜像。我们应删除那些未被其他镜像作为层使用的悬空镜像。同时，我们还需要关注注册表中的空间。只保留必要的镜像，但记得验证哪些容器或应用程序会使用不同版本的旧镜像。我们在第二章，*构建 Docker 镜像*中学习了如何筛选这些信息。

+   存储卷与镜像和容器存储有所不同。它们用于绕过容器存储。这些存储帮助我们在需要大量磁盘 I/O 时提升性能，并且允许我们存储持久化数据。默认情况下，我们可以使用内存文件系统、主机的本地目录（绑定挂载）、NFS 和 Docker 卷进行存储。Docker 卷在容器执行期间创建，并与容器的生命周期相关联。

+   如前所述，Docker 默认提供了一些存储卷解决方案。我们可以通过插件和第三方集成扩展这些方案。使用 Docker Swarm 和 UCP 的分布式存储在我们需要为应用程序提供高可用性和弹性时至关重要。如果某个集群主机发生故障，默认情况下，另一个主机会接管其工作负载，但存储必须与此行为保持一致。

+   Kubernetes 对持久数据有不同的处理方式。我们讨论了卷和持久卷（`persistentVolumes`）。前者用于共享和管理与 Pod 容器相关的数据。另一方面，持久卷用于在集群范围内管理和持久化数据。存在不同的保留策略来管理它们的回收周期。持久卷声明（`persistentVolumeClaims`）用于通过标签和所需空间等参数将 Pod 与卷关联起来。因此，我们将不直接将持久卷附加到 Pod 上，而是在 Pod 的配置中使用 `persistentVolumeClaims` 作为卷。管理员应创建这些资源，但可以通过使用 `storageClass` 资源避免这种行为。他们只需通过使用标签、存储提供程序和其他高级配置来配置 `storageClass` 资源，从而允许对持久卷进行动态存储分配。

+   我们了解到 Docker 提供了 `Config` 和 `Secret` 对象来帮助我们管理集群节点中的信息。这些帮助我们配置应用程序，并确保应用程序的容器接收适当的配置、密码、证书等。Kubernetes 有自己的配置和机密资源。为了管理配置，我们将使用 ConfigMaps 来存储应用程序的配置文件并管理环境变量。Secret 资源用于存储受保护的数据，但在 Kubernetes 中默认并未加密。它们以 Base64 格式存储，并可用于存储密钥值对或文件。

存储数据和状态非常重要，并且是考试的一部分。让我们回顾一下你需要理解的概念，以便顺利通过考试。

## 考试所需的存储和卷知识。

考试将验证我们对以下主题的知识，其他内容也包括在内：

+   确定与不同操作系统一起使用的正确图形驱动程序。

+   描述并演示如何配置设备映射器。

+   比较并对比对象存储和块存储，并确定何时应使用它们。

+   描述应用程序如何由多个层组成，以及这些层在文件系统中的存储位置。

+   描述如何使用 Docker 中的卷进行持久化存储。

+   确定清理文件系统和 DTR 中未使用的镜像所需的步骤。

+   描述并演示如何在集群节点之间使用存储。

+   描述如何使用 `persistentVolume` 资源为 Kubernetes Pod 配置持久存储。

+   描述 Kubernetes 中容器存储接口驱动程序、`storageClass`、`persistentVolumeClaim` 和 `volume` 对象之间的关系。

在下一章中，我们将查看一些最后的注意事项和示例考试题，以帮助我们准备 DCA 考试。

# 总结。

本章是通过考试所需主题的总结。我们回顾了各个主题的分布及其在考试中的大致分值。这应该能帮助你了解哪些部分比其他部分更为重要。我们建议你在阅读下一章中的所有模拟考试问题之前，先复习这一章。

我们概述了编排中最重要的主题。我们还回顾了一些安装和配置 Docker Engine、Docker Swarm 和企业组件所需的技巧。我们总结了创建镜像过程中涉及的功能和流程。安全性始终是至关重要的，我们还回顾了不同 Docker 组件提供的功能，这些功能帮助我们在生产环境中提供 CaaS 平台。我们还回顾了容器网络和不同的容器存储实现，以及数据管理的相关内容。建议你复习这些总结中不清楚的章节，并通过本书中提供的实验来巩固你对所有考试主题的知识。

下一章提供了一些模拟考试问题，帮助你为考试做好准备。
