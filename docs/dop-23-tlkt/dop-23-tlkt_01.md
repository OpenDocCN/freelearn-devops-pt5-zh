# 我们是如何走到今天的？

很少有公司活在当下。我们大多数人仍然停留在过去，使用着过时的技术和过时的流程。如果我们停留在过去太久，可能会失去重新回到当下的机会。我们可能会进入一个平行时空，甚至不再存在。

每家公司都是一家软件公司。这一点适用于那些还未意识到这一点的公司。我们都在奔跑，并且不断加速。这是一场没有终点的比赛。没有赢家，只有那些跌倒后没有站起来的人。我们生活在一个变化速度不断加快的时代。公司一夜之间可能会被创造或摧毁。没有人是安全的。没有人可以安于现状。

技术变化如此之快，以至于很难（如果不是不可能）跟上。我们刚学习到一种新技术，它就已经过时，被其他东西取代了。以容器为例，Docker 只是几年前才出现，大家已经在各种场景中使用它。尽管它是一个非常年轻的产品，但它已经经历了多次变革。就在我们学会如何使用 `docker run` 时，我们被告知它已经过时，应该用 `docker-compose up` 来代替。于是我们开始将所有的 `docker run` 命令转换成 Compose 的 YAML 格式。等我们完成了转换，我们又得知容器不应该直接运行，而是应该使用容器调度器来替代。更复杂的是，我们还需要在 Mesos 和 Marathon、Docker Swarm 或 Kubernetes 之间做选择。

我们可以选择忽视这些趋势，但那样意味着我们会落后于竞争对手。没有什么选择，只有不断地努力保持竞争力。一旦我们放松警惕，停止学习和改进，竞争对手就会接管我们的业务。每个人都面临改进的压力，即使是高度监管的行业也是如此。只有当我们设法回到现在，创新才有可能。只有当我们掌握了别人今天所做的事情，才能向前推进并提出新的想法。今天，容器调度器已经是常态。它们不再是未来的东西，它们是现在的事物。尽管它们很可能在接下来的几个月和几年中发生巨大变化，但它们已经存在，并且将一直存在。理解容器调度器至关重要。在这些调度器中，Kubernetes 是最广泛使用的，并且拥有庞大的社区支持。

在我们深入了解 Kubernetes 之前，可能值得回顾一些历史，尝试理解我们当时试图解决的一些问题，以及我们面临的一些挑战。

# 从过去的一瞥

想象一个年轻男孩。他刚完成几个月的工作。他为自己取得的成就感到骄傲，但同时也担心它是否能正常运作。他还没有在“真实”的服务器上尝试过。这将是他第一次交付自己工作的成果。

他从抽屉里拿出一张软盘，插入电脑，复制之前编译的文件。他庆幸打孔卡片已经成为过去的事情。

他从桌子前站起来，走出办公室，朝着他的车走去。到达服务器所在的楼栋需要超过两个小时。他对于必须开车两个小时的前景感到不满，但没有更好的替代方案。他本可以让信使送去软盘，但那样没什么用，因为他想亲自安装软件。他必须亲自去那里，无法远程操作。

过了一会儿，他进入了存放服务器的房间，插入软盘，复制并安装软件。十五分钟后，他的脸上显现出压力的迹象。事情没有按预期的方式运行。出现了一个意外问题。他正在收集输出并写下笔记。他尽力保持冷静，收集尽可能多的信息。他担心又要长时间开车回到电脑前，可能还需要几天，甚至几周，才能弄清楚问题所在并解决它。他会回去并安装修复程序，也许第二次会成功，但更可能不会。

# 基础设施管理的简史

很久以前，在一个遥远的星系里……

我们会订购服务器，然后等上几个月直到它们到货。更糟糕的是，即便它们到了，我们还要等上几周，有时甚至几个月，才能把它们放到机架上并完成配置。大多数时候我们只是一直在等待。等待服务器，等待配置完成，等待获得部署批准，然后继续等待。只有耐心的人才能成为软件工程师。尽管如此，那也是打孔卡片和软盘之后的时代。我们有互联网或其他方式远程连接到机器。尽管如此，一切仍然需要大量等待。

鉴于要让服务器完全投入使用需要的时间，只有少数人能接触到这些服务器也就不足为奇了。如果有人做了不该做的事情，我们可能会面临长时间的宕机。此外，没有人知道那些服务器上运行的是什么。由于一切都靠人工操作，过了一段时间后，这些服务器就成了垃圾场。东西随着时间积累。无论多少精力投入到文档中，只要给足时间，服务器的状态总会与文档偏离。这就是手动配置和安装的本质。系统管理员成了神一样的人物。他是唯一一个知道一切的人，或者更可能，他假装自己知道。他是地下城的守护者，拥有通往王国的钥匙。每个人都可以被替代，只有他不行。

然后出现了配置管理工具。我们得到了 CFEngine。它基于承诺理论，能够将服务器调整到期望的状态，无论其实际状态如何。至少，这是理论。即使有缺点，CFEngine 也完成了其主要目标。它允许我们指定静态基础设施的状态，并有合理的保证能实现该状态。除了其主要目标，它还是服务器设置文档化的进步。与手动的花招式操作（通常导致文档与实际状态之间的显著差异）不同，CFEngine 允许我们拥有一个几乎完全与实际状态匹配的规范。它提供的另一个大优势是，可以为不同的环境提供或多或少相同的设置。专用于测试的服务器可以（几乎）与分配给生产环境的服务器相同。不幸的是，CFEngine 和类似工具的使用尚未得到广泛推广。我们不得不等待虚拟机的出现，直到自动化配置管理成为常态。然而，CFEngine 并非为虚拟机设计。它们是为静态的裸金属服务器而设计的。尽管如此，CFEngine 依然是对行业的巨大贡献，尽管它未能广泛采用。

在 CFEngine 之后，出现了 Chef、Puppet、Ansible、Salt 和其他类似工具。生活一度美好，直到虚拟机问世，或者更准确地说，直到虚拟机得到了广泛应用。我们很快会回到这些工具。现在，让我们转向下一个进化改进。

除了迫使我们保持耐心，物理服务器在资源利用方面也是一种巨大的浪费。它们有预定义的规格，由于等待时间相当长，我们通常会选择大规格的服务器。越大，越好。这意味着一个应用或服务通常所需的 CPU 和内存比服务器提供的要少。除非不在乎成本，否则这意味着我们会将多个应用部署到同一台服务器上。结果就是依赖关系的噩梦。我们必须在自由和标准化之间做出选择。

自由意味着不同的应用可以使用不同的运行时依赖。一项服务可能需要 JDK3，而另一项可能需要 JDK4。第三个可能是用 C 语言编译的。你大概明白接下来会发生什么了。我们在一台服务器上托管的应用越多，依赖关系就越复杂。通常，这些依赖会发生冲突，产生一些没人预料到的副作用。由于我们天生有将任何专长转化为独立部门的需求，负责基础设施的人迅速放弃了自由，转而选择可靠性。这就意味着“对我越简单，对你越可靠”。自由败北，标准化获胜。

标准化从系统架构师决定唯一正确的开发和部署方式开始。他们是一群很有趣的人。冒着把所有人都放在同一个框里并讽刺这一职业的风险，我会描述一个普通的系统架构师为一个（可能经验丰富的）程序员，他决定爬升自己公司的阶梯。说到阶梯，通常有两种。一种是管理阶梯，需要广泛掌握 Microsoft Word 和 Excel。精通所有 MS Office 工具是加分项。那些精通 MS Project 的人被认为是终极专家。哦，我忘了提到邮件技能。他们必须能够每天至少发送十五封邮件，询问状态报告。

大多数专家级程序员（老手）不会选择这条道路。许多人更愿意保持技术路线。这意味着接管系统架构师的角色。问题是，“技术路线”往往是一种欺骗。架构师仍然必须掌握所有管理技能（例如，Word、Excel 和邮件），并具备绘制图表的额外能力。这并不容易。一个系统架构师必须知道如何画矩形、圆形和三角形。他必须精通着色，并且能把它们连接起来。图形有虚线和实线。有些线条必须像箭头一样结束。选择箭头的方向本身就是一个挑战，因此线条通常会在两端都有箭头。

成为架构师的重要部分是，绘制图表和编写无数页 Word 文档非常耗时，以至于编程不再是他们的工作内容。他们停止了学习和探索，除了 Google 搜索和比较表格之外没有其他来源。最终的结果是，架构设计反映了架构师在跳到新职位之前所掌握的知识。

为什么我提到架构师？原因很简单。他们负责由系统管理员要求的标准化。他们会画出图表并选择开发人员使用的技术栈。不管那个栈是什么，都必须被视为“圣经”并严格遵守。系统管理员很高兴，因为有了标准和预定义的服务器设置方式。架构师们也很高兴，因为他们的图表有了实际用途。由于这些栈本应持续存在，开发人员也很兴奋，因为他们不需要学习任何新的东西。标准化扼杀了创新，但每个人都很开心。快乐是必须的，不是吗？如果 JDK2 运行得很好，为什么我们还需要 Java 6 呢？这一点已经通过无数图表得到了验证。

然后出现了虚拟机，打破了每个人的快乐。

**虚拟机**（**VM**）相比裸金属基础设施是一项巨大的进步。它们使我们能够更加精确地定义硬件需求。虚拟机可以快速创建和销毁。它们可以有不同的配置，一个可以运行 Java 应用程序，另一个可以专门用于 Ruby on Rails。我们可以在几分钟内获得它们，而不需要等待数月。然而，即使虚拟机带来的好处是显而易见的，直到多年后它们才被广泛采用。即使如此，虚拟机的采用仍然存在很多问题。公司常常将裸金属服务器上使用的相同做法转移到虚拟机上。这并不是说虚拟机的采用没有带来即时的价值。服务器的等待时间从几个月减少到了几周。如果没有行政任务、手动操作和操作瓶颈，它们本可以将等待时间缩短到几分钟。尽管如此，等待几周总比等待几个月好。另一个好处是，我们可以在不同的环境中拥有相同的服务器。公司开始复制虚拟机。虽然这比以前好多了，但它并没有解决缺乏文档和从零创建虚拟机的能力问题。尽管如此，多个相同的环境总比一个环境好，即使我们不知道里面到底有什么。

随着虚拟机（VM）的采用逐渐增多，配置管理工具的数量也在增加。我们有了 Chef、Puppet、Ansible、Salt 等工具。虽然其中一些工具可能在虚拟机出现之前就存在，但虚拟机使得它们变得流行。它们帮助推广了“基础设施即代码”（Infrastructure as Code）原则。然而，这些工具的设计原理与 CFEngine 相同。也就是说，它们是以静态基础设施为设计基础的。另一方面，虚拟机为动态基础设施开辟了新的天地，其中虚拟机被不断创建和销毁。可变性和不断的创建与销毁发生了冲突。可变基础设施非常适合静态基础设施，但它无法有效应对现代数据中心的动态特性所带来的挑战。可变性最终不得不让位于不可变性。

当不可变基础设施的理念开始获得关注时，人们开始将其与配置管理的概念结合起来。然而，当时可用的工具并不适合这个工作。它们（如 Chef、Puppet、Ansible 等）是以“在运行时将服务器配置到期望状态”的理念设计的。另一方面，不可变的过程假设（几乎）没有东西可以在运行时改变。工件应该作为不可变的镜像创建。在基础设施的情况下，这意味着虚拟机是从镜像创建的，而不是在运行时进行更改。如果需要升级，应该创建新的镜像，并用基于新镜像的虚拟机替换旧的虚拟机。这样的过程带来了速度和可靠性。在适当的测试到位的情况下，不可变的方式总是比可变的方式更可靠。

因此，我们获得了能够构建虚拟机镜像的工具。今天，它们由 Packer 主导。配置管理工具迅速加入了这一行列，供应商告诉我们，它们在配置镜像和运行时配置服务器时同样有效。然而，事实并非如此，因为这些工具背后的逻辑不同。它们的设计目的是将处于未知状态的服务器配置到期望的状态。它们假设我们无法确认当前状态是什么。另一方面，虚拟机镜像总是基于具有已知状态的镜像。例如，如果我们选择 Ubuntu 作为基础镜像，我们知道它内部包含什么。添加额外的包和配置非常简单。不需要像“如果这样，则那样，否则做其他事情”这样的复杂逻辑。当当前状态已知时，简单的 shell 脚本就能与任何配置管理工具相媲美。仅使用 Packer 创建虚拟机镜像是相当直接的。尽管如此，配置管理工具并没有完全失去价值。我们仍然可以使用它们来协调基于镜像创建虚拟机的过程，并且可能执行一些不能预先配置的运行时配置，对吧？

我们协调基础设施的方式也必须发生变化。需要更高水平的动态性和弹性。随着像**亚马逊云服务**（**AWS**）这样的云托管提供商的出现，这一点变得尤为明显，后来还有 Azure 和 GCE。他们向我们展示了什么是可能实现的。虽然一些公司接受了云服务，其他公司则采取了防守的态度。“我们可以建立一个内部云”，“AWS 太贵”，“我想做，但由于法律原因做不到”，“我们的市场不同”，这些都是人们在极力维护现状时常用的几种错误理由。并不是说这些陈述没有一点道理，而是说它们更多时候被用作借口，而非真正的原因。

尽管如此，云计算仍然成功地成为了工作方式，企业将其基础设施迁移到某个云服务提供商那里，或者至少开始考虑这一点。越来越多的公司正在放弃本地基础设施，我们可以放心地预测这一趋势将继续下去。然而，问题依然存在。我们如何管理云中的基础设施，充分利用其带来的所有好处？我们如何应对其高度动态的特性？答案以供应商特定工具（如 CloudFormation）或中立解决方案（如 Terraform）的形式出现。结合能够帮助我们创建镜像的工具，它们代表了新一代的配置管理。我们所谈论的是由不变性支撑的完全自动化。

我们生活在一个不再需要通过 SSH 连接到服务器的时代。

今天，现代基础设施是通过不变的镜像来创建的。任何升级都是通过构建新的镜像并进行滚动更新来逐一替换虚拟机。基础设施的依赖关系从不在运行时发生变化。像 Packer、Terraform、CloudFormation 等工具正是当今问题的答案。

不变性背后固有的一个好处是基础设施和部署之间的清晰划分。直到不久前，这两者融为一体，形成了一个不可分割的过程。随着基础设施成为一种服务，部署过程可以明确分开，从而让不同的团队、个人和专业人士能够各自掌控。

我们需要回顾一下过去，讨论一下部署历史。它们的变化是否和基础设施一样大？

# 部署过程的简短历史

在最初，没有包管理器。没有 JAR、WAR、RPM、DEB 和其他包格式。最多，我们可以将文件压缩成一个发布包。更常见的是，我们手动将文件从一个地方复制到另一个地方。当这种做法与旨在长期使用的裸金属服务器结合时，结果简直是生不如死。过了一段时间，没人知道服务器上安装了什么。不断的覆盖、重新配置、包安装以及可变类型的操作，导致了不稳定、不可靠且没有文档支持的软件运行在无数操作系统补丁之上。

配置管理工具（例如 CFEngine、Chef、Puppet 等）的出现有助于减少混乱。尽管如此，它们更多的是改进了操作系统的设置和维护，而不是新版本的部署。即使这些工具背后的公司很快意识到扩大其范围将带来经济利益，它们也从未被设计用于此目的。

即使有了配置管理工具，多个服务在同一台服务器上运行的问题依然存在。不同的服务可能有不同的需求，而这些需求有时会发生冲突。一方可能需要 JDK6，另一方需要 JDK7。第一个服务的新版本可能要求将 JDK 升级到新版本，但这可能会影响同一服务器上的其他服务。冲突和操作复杂性非常常见，以至于许多公司选择进行标准化。正如我们所讨论的，标准化是创新的杀手。我们标准化得越多，能够提出更好解决方案的空间就越小。即使这不是问题，标准化和明确的隔离意味着升级某个服务变得非常复杂。影响可能是不可预见的，而且一次性升级所有内容所需的工作量如此巨大，以至于许多人长时间（甚至永远）选择不升级。最终，许多公司被迫长时间使用旧的技术栈。

我们需要一种进程隔离的方式，而不需要为每个服务单独配置虚拟机。同时，我们必须想出一种不可变的方式来部署软件。可变性使我们无法实现可靠的环境。随着虚拟机的出现，不可变性变得可行。我们不再需要通过运行时更新来部署版本，而是可以创建新的虚拟机，不仅包括操作系统和补丁，还包括我们自己的软件。每次我们想发布新版本时，我们可以创建一个新的镜像，并实例化任意数量的虚拟机。我们可以进行不可变的滚动更新。尽管如此，实际上并没有多少公司在这样做。它太昂贵了，不仅在资源上，时间上也非常浪费。这个过程太长了。即使这不成问题，为每个服务配置一个单独的虚拟机会导致 CPU 和内存的浪费。

幸运的是，Linux 引入了命名空间（namespaces）、控制组（cgroups）以及其他被统称为容器的技术。它们轻量、快速且廉价。它们提供了进程隔离以及其他许多好处。不幸的是，它们并不容易使用。尽管容器技术已经存在了一段时间，只有少数几家公司具备利用它们的专业知识。我们不得不等到 Docker 的出现，才使容器变得易于使用，并使其对所有人都可及。

现在，容器是打包和部署服务的首选方式。它们是我们曾经迫切想实现的不可变性问题的答案。容器提供了必要的进程隔离、优化的资源利用率和其他一些好处。然而，我们也意识到我们需要更多。仅仅运行容器是不够的。我们需要能够扩展它们，让它们具备容错能力，提供集群之间透明的通信，还有很多其他需求。容器只是这幅拼图中的一个低级部分。真正的好处是通过位于容器之上的工具来获得的。这些工具今天被称为容器调度器。它们是我们的接口。我们不管理容器，是它们管理我们。

如果你还没有使用任何容器调度器，你可能会想知道它们是什么。

# 什么是容器调度器？

想象一下我还是个年轻的青少年。放学后，我们会去院子里踢足球。那是一个激动人心的场景。我们一群人随意地在院子里奔跑，完全没有组织。没有进攻，也没有防守。我们只会追着球跑。每个人都朝着球的方向跑，有人把球踢向左边，我们就朝那个方向跑，结果又因为有人把球踢了回来而开始向后跑。策略很简单。朝着球跑，能踢就踢，随便在哪踢，重复。这么多年过去了，我依然不明白有人是怎么进球的。那完全是随机的，适用于一群孩子。没有策略，没有计划，也没有意识到获胜需要协调。甚至守门员也总是出现在场地的随机位置。如果他在他守的门附近接到球，他会继续带着球跑。大部分进球都是踢向空门的。那是一种“每个人为自己”类型的野心。我们每个人都希望能进球，为自己争光。幸运的是，最主要的目标是玩得开心，所以团队的胜负并不那么重要。如果我们是一个“真正的”团队，我们就需要一个教练。我们需要有人告诉我们策略是什么，谁应该做什么，什么时候进攻，什么时候退守。我们需要有人来指挥我们。这个场地（集群）有着一个随机数量的人（服务），而他们有着共同的目标（获胜）。因为任何人都可以随时加入游戏，所以人数（服务）是不断变化的。

有人受伤并需要被替换，或者当没有替代者时，我们其余的人必须接管他的任务（自愈）。这些足球比赛可以很容易地转化为集群。就像我们需要有人告诉我们该做什么（教练），集群也需要某种东西来协调所有服务和资源。两者不仅需要做出事先决策，还需要不断观察比赛/集群，并根据内外部影响调整策略/调度。我们需要一个教练，而集群需要一个调度器。它们需要一个框架，来决定服务应该部署在哪里，并确保它保持期望的运行时规范。

集群调度器有许多目标。它确保资源得到高效利用并符合约束条件。它确保服务（几乎）始终运行。它提供容错和高可用性。它确保指定数量的副本被部署。这个列表可以持续一段时间，并且在不同的解决方案中有所不同。然而，不管集群调度器的具体责任列表如何，它们都可以通过主要目标进行概括。调度器确保服务或节点的期望状态（几乎）始终得到满足。与其使用命令式方法来实现目标，我们可以通过调度器采用声明式方法。我们可以告诉调度器期望的状态是什么，它将尽最大努力确保我们的期望（几乎）始终得到满足。例如，我们可以告诉调度器，我们的期望状态是让服务运行并具有五个副本，而不是执行五次部署过程，指望我们会有五个副本。

命令式和声明式方法之间的差异看起来可能很微妙，但实际上差异巨大。通过声明期望状态的方式，调度器可以监控集群，并在实际状态与期望状态不匹配时执行操作。与执行部署脚本相比，两者都会部署服务并产生相同的初始结果。然而，脚本并不会确保结果在一段时间后得到保持。如果一个小时后，某个副本失败了，我们的系统就会受到影响。传统上，我们通过警报和人工干预来解决这个问题。操作员会收到副本失败的通知，然后登录服务器并重启进程。如果整个服务器宕机，操作员可能会选择创建一个新的服务器，或者将失败的副本部署到其他服务器之一。但在此之前，他需要检查哪个服务器有足够的可用内存和 CPU。所有这些，甚至更多，都是由调度器在没有人工干预的情况下完成的。可以把调度器看作是持续监控系统并修复期望状态与实际状态之间差异的操作员。不同之处在于，调度器无比快速且精准。它们不会疲劳，不需要上厕所，也不需要工资。它们是机器，或者更准确地说，是在其上运行的软件。

这引出了容器调度器。它们与一般调度器有何不同呢？

容器调度器与一般调度器基于相同的原则。其显著区别在于它们使用容器作为部署单元。它们部署的是以容器镜像打包的服务。它们根据所需的内存和 CPU 规格尝试将服务放置在一起。它们确保所需数量的副本（几乎）始终运行。总的来说，它们的工作方式与其他调度器相同，但容器是最小且唯一的打包单元。这给它们带来了明显的优势。它们不关心容器内部的内容。从调度器的角度来看，所有容器都是一样的。

容器提供了其他部署机制无法提供的好处。作为容器部署的服务是隔离且不可变的。隔离提供了可靠性。隔离有助于网络和存储卷管理。它避免了冲突。它允许我们在任何地方部署任何东西，而不必担心这些东西是否会与同一服务器上运行的其他进程发生冲突。调度器结合容器和虚拟机提供了终极的集群管理理想状态。虽然未来这一点可能会发生变化，但目前为止，容器调度器是工程成就的巅峰。它们让我们能够结合开发者对快速和频繁部署的需求与系统管理员对稳定性和可复现性的目标。这就引出了 Kubernetes。

# 什么是 Kubernetes？

要理解 Kubernetes，重要的是要意识到直接运行容器对于大多数使用场景来说是一个糟糕的选择。容器是低级实体，需要一个框架来支撑它们。它们需要一些东西来提供我们期望从集群中部署的服务所需的所有附加功能。换句话说，容器很方便，但不应该直接运行。原因很简单，容器本身不提供容错能力。它们无法轻松地部署到集群中的最佳位置，并且，简而言之，不适合运维人员使用。这并不意味着容器本身没有用处。它们是有用的，但如果我们要充分发挥它们的真正潜力，它们还需要更多。如果我们需要在大规模操作容器，并且需要它们具备容错和自愈功能，以及我们期望现代集群所具备的其他功能，我们需要更多。我们至少需要一个调度器，可能还需要更多。

Kubernetes 最初由 Google 的一个团队开发，基于他们多年在大规模运行容器的经验。后来，它被捐赠给了 [**云原生计算基金会** (**CNCF**)](https://www.cncf.io/) ([`www.cncf.io/`](https://www.cncf.io/))。它是一个真正的开源项目，可能是历史上发展最快的项目之一。

Kubernetes 是一个容器调度器，功能远不止如此。我们可以使用它来部署我们的服务，进行无停机时间的发布更新，以及对这些服务进行扩展（或缩减）。它是可移植的，可以在公有云或私有云上运行，也可以在本地或混合环境中运行。从某种程度上说，Kubernetes 使得你的基础设施与供应商无关。我们可以将一个 Kubernetes 集群从一个托管供应商迁移到另一个供应商，而几乎不需要改变任何部署和管理流程。Kubernetes 可以轻松扩展，以满足几乎任何需求。我们可以选择使用哪些模块，还可以开发额外的功能并将其插入系统。

如果我们选择使用 Kubernetes，我们就决定放弃控制权。Kubernetes 将决定在哪里运行某些东西以及如何实现我们指定的状态。这种控制允许 Kubernetes 将服务的副本放置在最合适的服务器上，在需要时重启它们，进行复制，并对它们进行扩展。我们可以说，自愈能力是其设计初衷的一部分。另一方面，自适应功能也在逐步实现中。到目前为止，它仍处于初期阶段，但很快将成为系统的一个核心部分。

零停机部署、容错、高可用性、扩展、调度和自我修复，应该足以让你看到 Kubernetes 的价值。然而，这仅仅是它所提供的一部分功能。我们可以使用它为有状态应用程序挂载存储卷。它允许我们将机密信息存储为秘密。我们可以使用它验证服务的健康状况。它可以负载均衡请求并监控资源。它提供服务发现和便捷的日志访问，等等。Kubernetes 所能做的事情清单很长，而且在迅速增加。与 Docker 一起，它正逐渐成为一个涵盖整个软件开发和部署生命周期的平台。

Kubernetes 项目刚刚起步。它还处于初期阶段，我们可以期待很快会有大量改进和新功能推出。尽管如此，不要被“初期阶段”所迷惑。即使这个项目还年轻，它背后拥有世界上最大的社区之一，并且已被用于一些全球最大规模的集群。不要再等了，现在就采用它吧！
