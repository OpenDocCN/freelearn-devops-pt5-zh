- en: Running Docker Containers
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Docker 容器
- en: This chapter is dedicated to the Docker command line. We have run some containers
    in the previous chapters, but we did not go into detail regarding the arguments
    and options used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讲解 Docker 命令行。在之前的章节中，我们运行了一些容器，但并未详细讨论使用的参数和选项。
- en: In this chapter, we will talk about different Docker objects, such as images,
    containers, and volumes, and their associated actions. Not all objects will have
    the same features and, consequently, they will not have the same actions and arguments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论不同的 Docker 对象，如镜像、容器和数据卷，以及它们的相关操作。并非所有对象都具有相同的功能，因此它们的操作和参数也不同。
- en: Remember that image building is based on container execution. Each layer is
    the result of executing commands on a container that is automatically "committed"
    in a Docker node's filesystem. All these layers, when grouped together, constitute
    an image.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，镜像构建是基于容器执行的。每一层都是在容器上执行命令后自动“提交”到 Docker 节点文件系统中的结果。所有这些层合并在一起，构成一个镜像。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reviewing the Docker command line in depth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入审视 Docker 命令行
- en: Learning about Docker objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Docker 对象
- en: Running containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行容器
- en: Interacting with containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与容器的交互
- en: Limiting host resources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制主机资源
- en: Converting containers into images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器转换为镜像
- en: Formatting and filtering information
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化与筛选信息
- en: Managing devices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理设备
- en: Let's begin by looking at how to work with the Docker command line.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下如何使用 Docker 命令行。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will learn about Docker container concepts. We'll provide
    some labs at the end of this chapter that will help you understand and learn about
    the concepts covered. These labs can be run on your laptop or PC using the provided
    Vagrant standalone environment or any Docker host of your own that you've deployed.
    Additional information can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Docker 容器的概念。在本章结束时，我们将提供一些实验，帮助你理解并学习涵盖的概念。这些实验可以在你的笔记本电脑或 PC 上运行，使用提供的
    Vagrant 独立环境或你自己部署的任何 Docker 主机。更多信息可以在本书的 GitHub 仓库找到：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码如何实际运行：
- en: '"[https://bit.ly/32AEGHU](https://bit.ly/32AEGHU)"'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/32AEGHU](https://bit.ly/32AEGHU)"'
- en: Reviewing the Docker command line in depth
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入审视 Docker 命令行
- en: As we learned in the previous chapters, Docker is a client-server application.
    Previous versions of the software installed both components at the same time,
    but the newer versions allow us to just install the client for using remote servers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中学到的那样，Docker 是一个客户端-服务器应用程序。早期版本的 Docker 会同时安装这两个组件，但新版本允许我们只安装客户端来使用远程服务器。
- en: We learned about the various Docker daemon options and arguments in [Chapter
    1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures and Applications
    with Docker*. In this chapter, we are going to review the Docker client command
    line.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml)，*现代基础设施与 Docker 应用* 中了解了各种
    Docker 守护进程的选项和参数。在本章中，我们将回顾 Docker 客户端命令行。
- en: When we use the Docker command line on either Linux or Windows, we are always
    referencing the Docker client and, usually, the binary or executable program is
    `/usr/bin/docker` or `C:\ProgramData\Docker` on Linux and Windows, respectively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Linux 或 Windows 上使用 Docker 命令行时，我们总是指向 Docker 客户端，通常情况下，二进制文件或可执行程序分别位于
    Linux 和 Windows 上的 `/usr/bin/docker` 或 `C:\ProgramData\Docker`。
- en: Docker's command-line usage format is `docker [OPTIONS] COMMAND`. Various options
    are used to define the daemon we will connect to and how this communication will
    be created. Debugging and the level of logging are managed at this point too.
    Some of these options can be set using Docker client configuration in each user'
    s `config.json` file under their `home` directory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的命令行使用格式是 `docker [OPTIONS] COMMAND`。各种选项用于定义我们将连接的守护进程以及如何建立这次通信。调试和日志级别也在此时进行管理。这些选项中的一些可以通过
    Docker 客户端配置，在每个用户的 `config.json` 文件中设置，该文件位于用户的 `home` 目录下。
- en: The Docker client configuration file, `config.json`, will manage filtering options,
    which we will learn about at the end of this chapter. It also stores login access
    to registries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端配置文件 `config.json` 将管理过滤选项，我们将在本章末尾学习这些内容。它还存储对注册表的登录访问。
- en: 'Environment variables can also be used to configure Docker client behavior.
    Here is a list of the most frequently used ones:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量也可以用于配置 Docker 客户端的行为。以下是最常用的环境变量列表：
- en: '`DOCKER_CONFIG`: This will set the Docker client''s config file path.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_CONFIG`: 这将设置 Docker 客户端的配置文件路径。'
- en: '`DOCKER_CERT_PATH`: This sets the path for client-server certificates.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_CERT_PATH`: 这设置了客户端与服务器之间证书的路径。'
- en: '`DOCKER_HOST`: We can use remote Docker engines. By default, we will use the
    local Docker daemon.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_HOST`: 我们可以使用远程 Docker 引擎。默认情况下，我们将使用本地 Docker 守护进程。'
- en: '`DOCKER_TLS`: This option enables TLS communication (requires certificates
    to work).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_TLS`: 此选项启用 TLS 通信（需要证书才能正常工作）。'
- en: '`DOCKER_TLS_VERIFY`: This option will not validate remote daemon certificates.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_TLS_VERIFY`: 此选项将不验证远程守护进程证书。'
- en: '`DOCKER_CONTENT_TRUST`: We will use this option to use content trust features
    (image immutability and ownership).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_CONTENT_TRUST`: 我们将使用此选项来启用内容信任功能（镜像不可变性和所有权）。'
- en: Docker commands will always require a Docker daemon and they will be executed
    against **objects*****.*** These are internal resources managed by Docker, distributed
    on categories with different features and properties. We'll look at this in more
    detail in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 命令始终需要一个 Docker 守护进程，并且它们将针对**对象**执行。**这些是由 Docker 管理的内部资源，按类别分布，具有不同的功能和属性**。我们将在下一节中详细讨论这一点。
- en: All Docker objects have their own IDs. Names are tags associated with these
    IDs and therefore, in some cases, we will be able to have many names for an object.
    The object ID will uniquely identify each object and thus, Docker can show or
    manage information regarding that object without using its category. We recommend
    using categories that are always on the Docker command line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Docker 对象都有自己的 ID。名称是与这些 ID 关联的标签，因此，在某些情况下，我们可以为一个对象指定多个名称。对象 ID 将唯一标识每个对象，因此，Docker
    可以在不使用其类别的情况下显示或管理有关该对象的信息。我们建议在 Docker 命令行中始终使用类别。
- en: 'The following table shows the commands that will be common to all objects:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了所有对象共有的命令：
- en: '| `ls` or `list` | This will show a list of all objects in that category. The
    output may be different, depending on which objects are queried, but we will usually
    obtain object names and their IDs.We will use the `--all` or `-a` modifiers to
    show all the objects from a selected category because, in some cases, the output
    will only show a subset. For example, if we list container objects, by default,
    we will just get running containers. Dead (exited) containers will not be shown
    unless you use the `--all` command modifier. Filtering will allow us to retrieve
    only a subset of objects. We will use the `--filter` or `-f` arguments for this.
    Each object category will have its own keys for easy filtering. We will learn
    how to filter information later in this chapter.Formatting is also very important.
    We will use the `--format` option to format the output''s information. The usual
    formats are `table` and `json` for obtaining table-like information and JSON formats,
    respectively. We can customize and sort obtained information. All filters should
    be constructed using the Go templates format.Formatting output is an art! We will
    see many options later in this chapter. A good starting point will always be to
    use `--format=''{{json .}}''` to review which JSON keys can be used for formatting.
    We can avoid a full command''s output using `--quiet` or `-q`. This parameter
    will show only listed object IDs in that category. This is very useful for concatenating
    or piping output to other commands. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `ls` or `list` | 这将显示该类别中所有对象的列表。输出可能会有所不同，这取决于查询哪些对象，但通常会获得对象名称及其 ID。我们将使用
    `--all` 或 `-a` 修饰符来显示所选类别的所有对象，因为在某些情况下，输出可能仅显示子集。例如，如果我们列出容器对象，默认情况下，我们只会得到正在运行的容器。已停止（退出）的容器将不会显示，除非使用
    `--all` 命令修饰符。过滤功能允许我们仅检索对象的子集。我们将使用 `--filter` 或 `-f` 参数进行此操作。每个对象类别都将有自己的键，以便轻松过滤信息。稍后在本章节中，我们将学习如何过滤信息。格式化也非常重要。我们将使用
    `--format` 选项格式化输出的信息。通常的格式包括 `table` 和 `json`，分别用于获取类似表格的信息和 JSON 格式。我们可以定制和排序获得的信息。所有过滤器应使用
    Go 模板格式构建。格式化输出是一门艺术！稍后在本章节中，我们将看到许多选项。一个很好的起点始终是使用 `--format=''{{json .}}''`
    来查看可以用于格式化的 JSON 键。我们可以使用 `--quiet` 或 `-q` 避免完整命令的输出。此参数将仅显示该类别中列出的对象 ID。这对于将输出串联或管道化到其他命令非常有用。
    |'
- en: '| `rm` or `remove` | This action will remove defined objects. We can remove
    them using their IDs or their names. Once deleted, they cannot be recovered.To
    avoid confirmation of object deletion, we will use the `--force` argument. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `rm` or `remove` | 此操作将删除定义的对象。我们可以使用它们的 ID 或名称来删除它们。一旦删除，它们将无法恢复。为了避免确认对象删除，我们将使用
    `--force` 参数。 |'
- en: '| `create` | All objects can be created and removed, but each object will have
    its own arguments. Therefore, we will learn about each object''s arguments in
    different chapters. We will start with container arguments in the next section.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 所有对象都可以创建和删除，但每个对象都有自己的参数。因此，我们将在不同章节中学习每个对象的参数。我们将从下一部分开始介绍容器参数。
    |'
- en: '| `inspect` | To review object-defined properties, we will use the `inspect`
    action. By default, the object description will be shown in JSON format.We can
    also use `--format` to format its output. In this case, we can format the output
    of the object''s description. This is very useful for getting just a few required
    values, as shown in the following example:`**$ docker image inspect nginx:alpine
    --format "{{ json .Config.Cmd }}"**``**["nginx","-g","daemon off;"]**` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` | 要查看对象定义的属性，我们将使用 `inspect` 操作。默认情况下，对象描述将以 JSON 格式显示。我们还可以使用
    `--format` 格式化其输出。在这种情况下，我们可以格式化对象描述的输出。这对于仅获取所需的几个值非常有用，如下例所示：`**$ docker image
    inspect nginx:alpine --format "{{ json .Config.Cmd }}"**``**["nginx","-g","daemon
    off;"]**` |'
- en: The Docker client was programmed in Go and it contains many Go template formatting
    and filtering options.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端是用 Go 编写的，它包含许多 Go 模板格式化和过滤选项。
- en: Every time we use `docker ps`, we are actually executing `docker container ls`***.***
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用 `docker ps`，实际上都在执行 `docker container ls`***.***
- en: In the next section, we will introduce the different resources or objects we
    have available in Docker.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将介绍 Docker 中可用的不同资源或对象。
- en: Learning about Docker objects
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于 Docker 对象
- en: 'Let''s define the different categories of objects that are available for a
    standalone Docker daemon:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义独立 Docker 守护程序可用的不同对象类别：
- en: '**Images**: These are the basis for creating containers. In [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*, we learned the concept of multi-layered templates for
    providing a root filesystem for the container''s main process and all the meta-information
    required to execute it.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：这些是创建容器的基础。在[第2章](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml)《构建 Docker
    镜像》中，我们了解了多层模板的概念，这些模板为容器的主进程提供根文件系统，并包含执行它所需的所有元信息。'
- en: '**Containers**: As we learned in [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml),
    *Modern Infrastructures and Applications with Docker*, a container is a compound
    of isolated namespaces, resources, and files for a process (or multiple processes).
    This process will run inside a wrapped environment as if it was alone in its own
    system, sharing the host kernel and its resources.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：正如我们在[第1章](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml)《现代基础设施与 Docker
    应用》中所学，容器是为进程（或多个进程）隔离命名空间、资源和文件的组合。该进程将在一个封装环境中运行，仿佛它独自在自己的系统中运行，分享主机的内核及其资源。'
- en: '**Volumes**: Volumes are used to bypass copy-on-write containers'' filesystems.
    As a result, we will be able to store data out of containers, avoiding their life
    cycle. We will learn more about volumes in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：卷用于绕过写时复制容器的文件系统。因此，我们可以将数据存储在容器之外，避免其生命周期的影响。我们将在[第4章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)《容器持久性与网络》中深入了解卷。'
- en: '**Networks**: Containers run on their own network namespace, but they need
    to reach real infrastructure networks. They will use host physical interfaces
    in bridge mode, creating virtual interfaces for each container interface. We will
    learn more about this working model and many other options in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：容器在自己的网络命名空间中运行，但它们需要访问真实的基础设施网络。它们将使用主机的物理接口在桥接模式下运行，为每个容器接口创建虚拟接口。我们将在[第4章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)《容器持久性与网络》中进一步了解这种工作模式和许多其他选项，*容器持久性和网络*。'
- en: '**Plugins**: Docker plugins extend engine functionality using processes that
    will run alongside a Docker daemon. They will share information and configuration
    with the daemon to provide new features. There are three different kinds of plugins:
    authorization, volume, and network plugins. The Docker client command line provides
    the interface for installing and managing plugins. Their configurations will be
    deployed under the `/usr/lib/docker/plugins` or `/etc/docker/plugins` directories.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：Docker 插件通过与 Docker 守护进程并行运行的进程扩展引擎功能。它们将与守护进程共享信息和配置，以提供新特性。插件有三种不同类型：授权插件、卷插件和网络插件。Docker
    客户端命令行提供了安装和管理插件的接口。它们的配置将部署在 `/usr/lib/docker/plugins` 或 `/etc/docker/plugins`
    目录下。'
- en: 'These objects are available in a standalone Docker Daemon, but there are other
    objects when the host participates in a distributed Docker Swarm cluster. We will
    talk about these in the orchestration chapters, but we will provide a brief synopsis
    here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象在独立的 Docker 守护进程中可用，但当主机参与分布式 Docker Swarm 集群时，还有其他对象。我们将在编排章节中讨论这些内容，但在这里我们将简要概述一下：
- en: '**Swarm**: This object provides cluster properties. It allows us to create
    new clusters and join or leave previously created ones. It also maintains cluster
    security by managing certificate authority or locking access to cluster certificates.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swarm**：该对象提供集群属性。它允许我们创建新的集群并加入或离开已创建的集群。它还通过管理证书颁发机构或锁定对集群证书的访问来维护集群安全。'
- en: '**Nodes**: Nodes are hosts that are part of the cluster. We can update node
    roles within the cluster and remove them when needed. We can also modify which
    nodes will run the defined workloads.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：节点是集群中的主机。我们可以在集群中更新节点角色，并在需要时将其删除。我们还可以修改哪些节点将运行已定义的工作负载。'
- en: '**Services**:Docker Swarm will not manage containers. The minimum scheduling
    unit in Docker Swarm is the service. They will create tasks, and those will be
    represented by containers. In Docker Swarm, we deploy services by declaring their
    state and the number of tasks required to be healthy. We will be able to create
    services, update their properties (replicas, images used for containers, and so
    on), or remove them.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：Docker Swarm 不会管理容器。Docker Swarm 中的最小调度单元是服务。服务将创建任务，而任务将通过容器呈现。在 Docker
    Swarm 中，我们通过声明服务的状态和所需的健康任务数来部署服务。我们将能够创建服务、更新它们的属性（副本、用于容器的镜像等），或删除它们。'
- en: '**Stacks**: When we talk about deploying workloads on Swarm, we usually use
    stacks, which are multi-service applications. We will define all the components
    required by an application to run. These components will be services and all their
    volumes, networks, and so on, as well as their interactions.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈**：当我们谈论在 Swarm 上部署工作负载时，通常使用堆栈，它是多服务应用程序。我们将定义一个应用程序运行所需的所有组件。这些组件将包括服务及其所有的卷、网络等，以及它们之间的交互。'
- en: Swarm objects have all the actions described previously. However, we can also
    use the `update` action to set and change object properties. This action is only
    available using Docker Swarm.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 对象具有之前描述的所有操作。然而，我们还可以使用 `update` 操作来设置和更改对象属性。此操作仅在使用 Docker Swarm 时可用。
- en: In the next section, we will learn how to run containers securely using the
    command line described.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用描述的命令行安全地运行容器。
- en: Running containers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: Containers are just processes that run in an isolated manner on the Docker host.
    All the features or properties required for the process to run may be tweaked
    on container creation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 容器只是以隔离方式在 Docker 主机上运行的进程。运行该进程所需的所有功能或属性可以在容器创建时进行调整。
- en: Main container actions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要容器操作
- en: 'Containers can be created, executed, and stopped when required. The following
    table will introduce the main container actions for this workflow:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以在需要时创建、执行和停止。下表将介绍此工作流程的主要容器操作：
- en: '| `create` | Because containers are Docker objects, we can create them. When
    we create a container, we configure how this container will work, without starting
    it. This stage will prepare a container and we can review its static configuration
    using `inspect`. Any dynamic configuration will not be present because the container
    is not running yet. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 因为容器是 Docker 对象，所以我们可以创建它们。当我们创建一个容器时，我们配置该容器的工作方式，但不启动它。这个阶段将准备一个容器，我们可以使用
    `inspect` 查看其静态配置。任何动态配置都不会存在，因为容器尚未运行。 |'
- en: '| `start` | Once the container has been created, it can be started using `start`.
    This means that the container-defined process will be executed with the configured
    isolation (memory, CPU, networking, and so on) and the external resources that
    are required. Once the container is started, we will be able to list it or review
    its state. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `start` | 一旦容器被创建，就可以使用 `start` 启动它。这意味着容器定义的进程将以配置的隔离方式（内存、CPU、网络等）以及所需的外部资源执行。容器启动后，我们将能够列出它或查看其状态。
    |'
- en: '| `run` | This action will create and then start a container. This is how we
    usually launch a container. There are some command aliases for many objects and
    actions; for example, `docker run`. We recommend using full sentences, including
    the object in which you are executing the action. A Docker container started with
    either `docker container run` or `docker run` will run in the foreground. Your
    Terminal, by default, will be attached to the container''s output. To avoid this
    behavior, we must use `--detach` or `-d` to launch the container in the background,
    detached from the current Terminal. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 此操作将创建并启动一个容器。这是我们通常启动容器的方式。许多对象和操作有一些命令别名，例如 `docker run`。我们建议使用完整的句子，包括您正在执行操作的对象。无论是使用
    `docker container run` 还是 `docker run` 启动的 Docker 容器将会在前台运行。默认情况下，您的终端将连接到容器的输出。为了避免这种行为，我们必须使用
    `--detach` 或 `-d` 将容器启动在后台，与当前终端分离。 |'
- en: '| `pause/unpause` | We can freeze the container''s process using cgroups in
    Linux. The process will stay suspended until it is unfrozen. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `pause/unpause` | 我们可以使用 Linux 中的 cgroups 冻结容器的进程。该进程将保持暂停状态，直到被解冻。 |'
- en: '| `stop` | Stopping a container will follow the next workflow described. First,
    the main process will receive a `SIGTERM` signal. This will try to shut down and
    terminate the process normally. By default, the Docker daemon will wait 10 seconds
    before sending a second signal. Then, the daemon will send a `SIGKILL` signal
    to kill the process completely. Therefore, the daemon will first try to terminate
    the container''s main process gracefully and will kill it if it was not stopped.
    We can configure what signal to send to stop a container using `--stop-signal`.
    It defaults to `SIGTERM`, as mentioned previously.Also, we can change the number
    of seconds to wait (10 seconds by default) before sending the second `SIGKILL`
    signal using the `--time` argument. This can be configured on container creation
    or execution using `--stop-timeout` when it is already running. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | 停止容器将遵循以下工作流程。首先，主进程将收到 `SIGTERM` 信号。这将尝试正常关闭和终止进程。默认情况下，Docker
    守护程序将在发送第二个信号之前等待 10 秒。然后，守护程序将发送 `SIGKILL` 信号以完全终止进程。因此，守护程序首先尝试优雅地终止容器的主进程，如果未停止，则会强制终止。我们可以使用
    `--stop-signal` 配置要发送的停止容器的信号。默认为 `SIGTERM`，如前所述。此外，我们可以使用 `--time` 参数更改等待发送第二个
    `SIGKILL` 信号的秒数（默认为 10 秒）。当容器已经运行时，可以在创建或执行中使用 `--stop-timeout` 进行配置。 |'
- en: '| `kill` | As we mentioned earlier, when we run `docker container stop`, Docker
    daemon will first try to stop it gracefully. There are some cases where we want
    to kill the main process completely without waiting. In these cases, we can use
    `docker container kill` to stop the container immediately. A signal that''s been
    sent can be changed using `-s` and, by default, a `SIGKILL` signal will be sent.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `kill` | 正如我们先前提到的，当我们运行 `docker container stop` 时，Docker 守护程序将首先尝试优雅地停止它。有些情况下，我们希望立即完全杀死主进程。在这些情况下，我们可以使用
    `docker container kill` 立即停止容器。可以使用 `-s` 更改发送的信号，默认情况下将发送 `SIGKILL` 信号。 |'
- en: '| `restart` | The `restart` action will stop and start a container. This means
    that previously learned procedures will be taken and the Docker container''s `stop`
    and `start` operations will be executed. Therefore, the previously described arguments
    will also be valid. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `restart` | `restart` 操作将停止并重新启动容器。这意味着先前学习的程序将被执行，并且将执行 Docker 容器的 `stop`
    和 `start` 操作。因此，先前描述的参数也将有效。 |'
- en: '| `rm` | Containers are not ephemeral, as we have learned in previous chapters.
    They will remain in our system until someone deletes them. We will use `docker
    container rm`to remove them.Running containers cannot be removed unless we use
    the `--force/-f` argument. It is recommended to stop containers in production
    before deleting them to avoid removing an important one by mistake. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | 如我们在之前的章节中学到的，容器不是临时的。它们将保留在我们的系统中，直到有人删除它们。我们将使用 `docker container
    rm` 来删除它们。运行中的容器除非使用 `--force/-f` 参数，否则无法删除。建议在删除生产中的容器之前停止它们，以避免因错误而删除重要容器。 |'
- en: '| `prune` | This command will remove all stopped containers. They can be forced
    using `--force`, and we can limit containers to be removed using filters with
    the `--filter` argument. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `prune` | 此命令将删除所有已停止的容器。可以使用 `--force` 强制执行，可以使用 `--filter` 参数使用过滤器限制要删除的容器。
    |'
- en: '| `rename` | With this action, we change the container name. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `rename` | 使用此操作，我们更改容器名称。 |'
- en: '| `update` | Using the `update` action, we can change the container''s host
    resource limits and its restart policy. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 使用 `update` 操作，我们可以更改容器的主机资源限制和其重启策略。 |'
- en: Only containers using Hyper-V isolation can be paused on Windows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 Hyper-V 隔离的容器可以在 Windows 上暂停。
- en: By default, all containers will be executed using non-limited resources. They
    will not run isolated unless we limit their access to host resources. To limit
    the number of resources available for a container, we must specify its thresholds
    during creation. We will use the same arguments for `docker container create`
    or `docker container run`. We will review how to manage container resources in
    the *Limiting host resources* section of this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有容器将使用非限制资源执行。除非我们限制它们访问主机资源，否则它们不会运行隔离。要限制容器可用的资源数量，必须在创建时指定其阈值。我们将在本章节的
    *限制主机资源* 部分中使用相同的参数来管理容器资源。
- en: We can use the `--rm` option to remove a container after its execution. It will
    also remove all unnamed volumes created during its lifetime. These volumes are
    defined ephemerally to override copy-on-write filesystems. We must remove them
    manually or use the `-v` argument with the `docker container rm` action.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`--rm`选项在容器执行完毕后将其删除。它还会删除在容器生命周期内创建的所有未命名卷。这些卷是临时定义的，用于覆盖写时复制文件系统。我们必须手动删除它们，或者使用`docker
    container rm`命令配合`-v`参数来删除它们。
- en: Container network properties
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络属性
- en: 'Containers run in their own network namespace. They will get their own IP addresses
    and network resources. By default, a Docker daemon will use bridge networking,
    and containers will get their own name resolution configuration by copying the
    host values. We can change this behavior on container creation and execution.
    Let''s review some options we can use to configure networking within containers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在自己的网络命名空间中运行。它们将获得自己的IP地址和网络资源。默认情况下，Docker守护进程使用桥接网络，容器将通过复制主机值来获得自己的名称解析配置。我们可以在容器创建和执行时更改此行为。让我们回顾一下可以用于配置容器内部网络的选项：
- en: '| `--name` | We can provide a name for each container. If we do not specify
    any container name, a random one will be generated. This way, we can manage containers
    using this defined name. It will be used as a hostname by default. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `--name` | 我们可以为每个容器指定一个名称。如果不指定容器名称，系统将生成一个随机名称。这样，我们可以通过这个定义的名称来管理容器。默认情况下，它将作为主机名使用。
    |'
- en: '| `--add-host` | Using this parameter, we are allowed to add hosts and their
    IP addresses. We will use `host:ip` formatted entries. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `--add-host` | 使用此参数，我们可以添加主机及其IP地址。我们将使用`host:ip`格式的条目。 |'
- en: '| `--dns` | This option will allow us to avoid default DNS resolution. Every
    time a name cannot be resolved by the embedded DNS server, a query is forwarded
    to the defined external DNS servers (copied from hosts by default). |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `--dns` | 此选项将允许我们避免使用默认的DNS解析。每当嵌入式DNS服务器无法解析名称时，查询将被转发到定义的外部DNS服务器（默认从主机复制）。
    |'
- en: '| `--dns-option` | This will add container-related options to an embedded DNS
    server. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `--dns-option` | 此选项将把与容器相关的选项添加到嵌入式DNS服务器中。 |'
- en: 'Each bridge network will be provided with internal name resolution using the
    Docker-embedded DNS server, on `127.0.0.11`. There is only one exception: the
    default bridge interface. In this case, we will need to use `--link` to allow
    access to a deployed container from another one on a bridge interface according
    to its name.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个桥接网络将提供内部名称解析，使用Docker嵌入式DNS服务器，地址为`127.0.0.11`。唯一的例外是默认桥接接口。在这种情况下，我们需要使用`--link`来根据容器名称允许从另一个容器通过桥接接口访问已部署的容器。
- en: '| `--dns-search` | This option sets the search domain names for name resolutions.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `--dns-search` | 此选项设置名称解析的搜索域名。 |'
- en: '| `--domainname` | This option sets the domain name for the container. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `--domainname` | 此选项设置容器的域名。 |'
- en: '| `--ip`and`--ip6` | Sometimes, we need to specify a container IP address,
    either for IPv4 or IPv6\. We will just pass version 4 or version 6 addresses as
    arguments on container creation or execution. Internal IPAM will assign internal
    IP addresses from the bridged network interface range. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `--ip` 和 `--ip6` | 有时我们需要指定容器的IP地址，可以是IPv4或IPv6。我们将在创建或执行容器时传递版本4或版本6的地址作为参数。内部IPAM将从桥接网络接口范围分配内部IP地址。
    |'
- en: '| `--hostname` | We can set an internal container hostname. It defaults to
    the container ID. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `--hostname` | 我们可以设置容器的内部主机名，默认值为容器ID。 |'
- en: '| `--link` | We can add internal name resolution to other containers using
    `CONTAINER_NAME:DNS_ALIAS`. These added linked names will be accessible to other
    containers using their names or IP addresses (this is the default option). |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `--link` | 我们可以使用`CONTAINER_NAME:DNS_ALIAS`的形式添加到其他容器的内部名称解析。这些链接名称将可以被其他容器通过它们的名称或IP地址访问（这是默认选项）。
    |'
- en: '| `--mac-address` | This option allows us to set a container MAC address. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `--mac-address` | 此选项允许我们设置容器的MAC地址。 |'
- en: '| `--network` | We can choose what type of network connectivity we will provide
    to containers. By default, all the containers will run on the default bridged
    network. In this chapter, we will just use the default networking mode, but there
    are other options as well, which we will learn about in the following chapters.
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `--network` | 我们可以选择为容器提供何种类型的网络连接。默认情况下，所有容器将在默认的桥接网络上运行。在本章中，我们将只使用默认的网络模式，但也有其他选项，我们将在后续章节中学习这些选项。
    |'
- en: '| `--network-alias` | This option helps us specify an alias for the container
    on a network. We will have more name resolutions for a container IP. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `--network-alias` | 此选项帮助我们为容器指定网络别名。这样我们可以对容器的 IP 地址进行更多的名称解析。 |'
- en: 'We need to define a restart policy to manage the container''s life. We require
    containers to stop/die and start fast. Resilience is the new key to an application''s
    availability. We can manage this container''s behavior with the `--restart` parameter.
    There are four options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个重启策略来管理容器的生命周期。我们要求容器快速停止/死亡和重新启动。弹性是应用程序可用性的关键。我们可以使用 `--restart` 参数来管理容器的行为。共有四个选项：
- en: '`no`: This is the default option. The container will remain stopped if it died
    or it was stopped manually.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no`：这是默认选项。如果容器停止或被手动停止，容器将保持停止状态。'
- en: '`on-failure`: This option will restart the container only if it died because
    of the main process''s failure.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on-failure`：此选项仅当容器因主进程失败而停止时才会重新启动容器。'
- en: '`always`: We don''t care whether someone stopped the container or whether it
    died by itself. We require the container to be running; therefore, Docker daemon
    will always try to restart it.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：不管容器是被人为停止还是自我停止，我们都希望容器持续运行；因此，Docker 守护进程将始终尝试重新启动它。'
- en: '`unless-stopped`: This option will not restart the container if we have executed
    a Docker `stop` command.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unless-stopped`：如果我们执行了 Docker `stop` 命令，此选项将不会重新启动容器。'
- en: These options are very important as they manage what a Docker daemon has to
    do with the containers when the Daemon is restarted; for example, when we have
    to reboot the host.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项非常重要，因为它们管理 Docker 守护进程在重新启动时需要对容器执行的操作。例如，当我们需要重启主机时。
- en: Container behavior definition
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器行为定义
- en: 'The following table shows some options that can be used to overwrite image
    predefined values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了一些可用于覆盖镜像预定义值的选项：
- en: '| `--entrypoint` | We can overwrite a defined entry point on container creation
    or execution. Don''t rely on your security for this feature. Anyone can change
    your entry point for any other binary or script included in your image. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `--entrypoint` | 我们可以在创建或执行容器时覆盖定义的入口点。不要依赖于此功能的安全性，因为任何人都可以将你的入口点更改为镜像中包含的任何其他二进制文件或脚本。
    |'
- en: '| `--env` or `-e` or `--env-file` | We can overwrite variables defined within
    the base image or add new ones for new containers. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `--env` 或 `-e` 或 `--env-file` | 我们可以覆盖基础镜像中定义的变量，或为新容器添加新的变量。 |'
- en: '| `--expose` | We can expose new ports for containers. These ports will be
    internally available. They are not published. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `--expose` | 我们可以为容器暴露新的端口。这些端口将在内部可用，但不会被发布。 |'
- en: '| `--health-cmd,``--health-interval,``--health-retries,``--health-start-period,``--health-timeout`
    | All these options will overwrite health check base image values. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `--health-cmd,` `--health-interval,` `--health-retries,` `--health-start-period,`
    `--health-timeout` | 所有这些选项将覆盖镜像中定义的健康检查值。 |'
- en: '| `--no-healthcheck` | This option disables the image-defined health check.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `--no-healthcheck` | 此选项禁用镜像中定义的健康检查。 |'
- en: '| `--label` or `-l` or `--label-file` | This option allows labels to be added
    upon container creation or execution. These labels will help us filter or find
    information pertaining to processes. There are some labels that are automatically
    added by the Docker daemon or orchestrators to identify grouped objects. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `--label` 或 `-l` 或 `--label-file` | 此选项允许在创建或执行容器时添加标签。这些标签将帮助我们筛选或查找与进程相关的信息。Docker
    守护进程或编排器自动添加一些标签，用于标识分组对象。 |'
- en: '| `--user` or `-u` | This option overwrites the image-defined user. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `--user` 或 `-u` | 此选项覆盖镜像中定义的用户。 |'
- en: '| `--volume` or `-v` | This option uses a defined volume or host path mounted
    inside the container. This option is very important because ephemeral volumes
    (also referenced as unnamed volumes) that are used to bypass copy-on-write filesystems
    will be created under `/var/lib/docker/volumes` (or the equivalent path on MS
    Windows hosts). They are identified by a random ID. Volumes will not follow the
    container''s life cycle and must be removed manually unless we use the `-v` argument
    with the `docker container rm` action. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `--volume` 或 `-v` | 此选项使用定义的卷或主机路径，并将其挂载到容器内。此选项非常重要，因为用于绕过写时复制文件系统的临时卷（也称为未命名卷）将在
    `/var/lib/docker/volumes`（或 MS Windows 主机上的等效路径）下创建。它们通过随机 ID 进行标识。卷不会随容器的生命周期变化，除非我们在执行
    `docker container rm` 操作时使用 `-v` 参数，否则必须手动删除。 |'
- en: Arguments passed on container creation will be added to the image-defined entry
    point as arguments. Therefore, image-defined CMD values will be overwritten with
    arguments passed upon container execution. Other arguments such as `--user`, `--env`,
    `--entrypoint`, or `--health-cmd`, `--health-timeout`, and so on will overwrite
    image-defined values, modifying the image's process behavior. Notice that the
    argument syntax is related to the image's defined keys.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器创建时传递的参数将作为参数添加到镜像定义的入口点中。因此，镜像定义的 CMD 值将被容器执行时传递的参数所覆盖。其他参数，如 `--user`、`--env`、`--entrypoint`
    或 `--health-cmd`、`--health-timeout` 等，将覆盖镜像定义的值，从而修改镜像的进程行为。请注意，参数语法与镜像定义的键相关。
- en: Once a container has been created and executed, by default, the Terminal will
    be attached to its standard and error outputs. We will get all the main process
    errors and output. We can also launch containers interactively using the `--interactive`
    or `-i` options. We usually allocate a pseudo-Terminal using `--tty` or `-t` in
    order to have a fully functional Terminal attached to the main process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器被创建并执行，默认情况下，终端将连接到其标准输出和错误输出。我们将获得所有主要进程的错误和输出。我们还可以通过使用 `--interactive`
    或 `-i` 选项以交互方式启动容器。通常，我们会使用 `--tty` 或 `-t` 分配一个伪终端，以便将一个完全功能的终端附加到主进程上。
- en: Executing containers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行容器
- en: 'A simple example will help us understand this behavior. We will launch a small
    web server using an `nginx:alpine` image. In this case, we are using the official
    `nginx` image from the `docker.io` registry tagged `alpine`, which is the smallest
    one based on Alpine Linux:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子将帮助我们理解这种行为。我们将使用`nginx:alpine`镜像启动一个小型的 web 服务器。在这种情况下，我们使用的是来自 `docker.io`
    注册表的官方 `nginx` 镜像，标记为 `alpine`，它是基于 Alpine Linux 的最小镜像：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The output may vary if the image was already on your Docker host. All the object
    IDs will be different on your system as they are created automatically for you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果镜像已经存在于您的 Docker 主机上，输出可能会有所不同。所有对象 ID 在您的系统中将不同，因为它们会自动为您创建。
- en: We can exit from running the container's standard output by executing either
    the `exit` command or the *Ctrl + C* keyboard combination.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `exit` 命令或按下 *Ctrl + C* 键盘组合来退出正在运行的容器的标准输出。
- en: 'We are stuck on this Terminal because we started a container with Nginx as
    the main process. What happened? Well, we are attached to the container''s main
    process. If we issue a *Ctrl* + *C* sequence, since we are attached to that process,
    we will send an interruption to the container''s main process and `nginx` will
    die. However, if we open another Terminal and list the running containers, it
    will be listed as expected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被困在这个终端中，因为我们启动了一个以 Nginx 为主进程的容器。发生了什么呢？好吧，我们正在附着到容器的主进程上。如果我们按下 *Ctrl* +
    *C* 键组合，由于我们附着在该进程上，它会向容器的主进程发送中断信号，导致 `nginx` 进程结束。然而，如果我们打开另一个终端并列出正在运行的容器，它将按预期列出：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we have not set a name for our container, we get a random one; in this
    case, `gallant_lederberg`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为容器设置名称，它会随机生成一个名称；在此情况下是 `gallant_lederberg`。
- en: All names will be created using random combinations of names and adjectives.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有名称将通过随机组合的名称和形容词来创建。
- en: 'We can also inspect this running container to get its current IP address. To
    access its information, we can use either its ID or name. We will obtain all object
    information managed by the Docker daemon. We will now take a look at the `NetworkSettings`
    section from the `docker container inspect` command''s output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查这个正在运行的容器以获取其当前的 IP 地址。要访问其信息，我们可以使用其 ID 或名称。我们将获得所有由 Docker 守护进程管理的对象信息。接下来，我们将查看
    `docker container inspect` 命令输出中的 `NetworkSettings` 部分：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This output shows that the container was created and that it is running on
    our system with an IP of `172.17.0.2`. We have not exposed its service to the
    world, although we did notice its port and protocol (`80`/`tcp`) on the `docker
    container ls` output earlier. The people who created the `nginx:alpine` image
    declared this port to access the container''s main process. We are not going to
    continue reviewing the networking aspects of this container here as we have a
    complete chapter on networking, that is, [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*. Just be aware that we have a running `nginx`
    process in our system that is not accessible for users:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示容器已创建，并且正在我们的系统上运行，IP为`172.17.0.2`。我们没有将其服务暴露给外部世界，尽管我们在之前的`docker container
    ls`输出中注意到它的端口和协议（`80`/`tcp`）。创建`nginx:alpine`镜像的人声明了这个端口来访问容器的主进程。我们不会继续在这里审查容器的网络方面，因为我们有一个完整的网络章节，[第4章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)，*容器持久性与网络*。只需了解我们在系统中运行着一个`nginx`进程，但它对用户不可访问：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have not changed any of the parameters from the original image, so we are
    using image creator options and declared values. For example, `nginx` is running
    as root inside the container. Container port `80` is not accessible from outside
    the bridged network.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更改原始镜像中的任何参数，因此我们使用了镜像创建者的选项和声明的值。例如，`nginx`在容器内部以root身份运行。容器的端口`80`无法从桥接网络外部访问。
- en: 'We have already learned that there are some parameters that allow container
    interaction, so let''s start a simple `busybox` to access the previous container''s
    service:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学过一些允许容器交互的参数，因此让我们启动一个简单的`busybox`容器，访问之前容器的服务：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the running `nginx` container''s output, we will read a few lines. These
    are `nginx` logfile lines because the main `nginx` process is redirected to standard
    output. In fact, both error and access logs are redirected to the container''s
    output. If we go back to the first Terminal, this is what we get from running
    the `nginx` container''s standard output and error:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行的`nginx`容器的输出中，我们将读取几行内容。这些是`nginx`的日志行，因为主`nginx`进程被重定向到标准输出。实际上，错误日志和访问日志都被重定向到容器的输出。如果我们回到第一个终端，这就是我们从运行`nginx`容器的标准输出和错误中得到的内容：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the `busybox` container's IP (running from the second Terminal)
    is shown on `nginx` requests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`busybox`容器的IP（在第二个终端中运行）显示在`nginx`请求中。
- en: We have learned that running two containers together on the same network subnet
    will have unlimited access. This happens because we don't have any rules to disallow
    this interaction. Both containers use the default bridge network, which is why
    they run in the same network.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，在同一网络子网中运行两个容器会有无限制的访问权限。这是因为我们没有任何规则来禁止这种交互。两个容器都使用默认的桥接网络，因此它们运行在同一网络中。
- en: If we exit the `busybox` container using a simple `exit` command line on the
    container's shell, we will exit the main process (shell) and consequently, the
    container will die.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过在容器的shell中使用简单的`exit`命令退出`busybox`容器，我们将退出主进程（shell），因此容器会死亡。
- en: 'We can list non-running containers by using `--all` or `-a` because, by default,
    `docker container ls` will only show running containers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`--all`或`-a`来列出非运行中的容器，因为默认情况下，`docker container ls`只会显示正在运行的容器：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we can see that we can review running and stopped containers. We will
    stop the `gallant_lederberg` container (ID: `f84f6733537c`). Remember that executing
    `docker container stop` will first try to issue a graceful stop before killing
    the main process:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到可以查看运行和停止的容器。我们将停止`gallant_lederberg`容器（ID：`f84f6733537c`）。请记住，执行`docker
    container stop`时，会先尝试优雅地停止，然后才会杀死主进程：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The container is stopped immediately. Now, let''s run another container that
    is not so easy to stop. We can run a `busybox` image executing an infinite ping
    to `www.google.com`, for example, and review what happens when we try to stop
    it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 容器立即停止。现在，让我们运行另一个不容易停止的容器。我们可以运行一个执行无限ping命令到`www.google.com`的`busybox`镜像，并查看我们尝试停止它时会发生什么：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have changed the `busybox` image-defined CMD with the passed argument, `ping
    www.google.com`. As a result, we will get an infinite ping output. To stop this
    container and review how much time it takes to die, we can send a `stop` command
    from another Terminal:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过传递的参数`ping www.google.com`修改了`busybox`镜像定义的CMD。结果，我们将获得一个无限ping输出。为了停止这个容器并查看它需要多长时间才能停止，我们可以从另一个终端发送`stop`命令：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We added `time` before the Docker command to review how many seconds the container
    took to stop. As we expected, the ping had to be killed and, as a result, the
    `stop` command took more than the default 10 seconds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Docker 命令前添加了`time`来查看容器停止所需的时间。正如我们预期的那样，ping 进程需要被终止，因此`stop`命令的执行时间超过了默认的
    10 秒。
- en: We launched a named container using the `--name` argument. To ensure the uniqueness
    of containers, once a container is created with a name, it is not possible to
    create another one with the same name. When we get into the orchestration chapters
    of this book, we will learn how orchestrators manage the naming of containers.
    To deploy another ping container, in this case, we will need to remove the first
    ping container using `docker container rm ping`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`--name`参数启动了一个命名容器。为了确保容器名称的唯一性，一旦使用名称创建了容器，就无法创建另一个同名的容器。当我们进入本书的编排章节时，我们将学习如何使用编排工具管理容器名称。要部署另一个
    ping 容器，在这种情况下，我们需要先使用`docker container rm ping`删除第一个 ping 容器。
- en: 'We have seen how to launch a container using the `docker container run` command
    and how to stop it. Let''s now review container creation to understand the container''s
    life cycle:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使用`docker container run`命令启动容器以及如何停止容器。现在让我们回顾一下容器创建过程，以便理解容器的生命周期：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We obtained the container's identification, but it is not running. We can verify
    this situation by executing `docker container ls --filter name=webserver`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得了容器的标识符，但它并没有运行。我们可以通过执行`docker container ls --filter name=webserver`来验证这一点。
- en: 'If we filter using all containers, including those that are not running, we
    can see that the container was created:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们过滤所有容器，包括那些未运行的容器，我们可以看到容器已创建：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the container has been created, we can start it using `docker container
    start`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在容器已经创建完成，我们可以使用`docker container start`启动它：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The container was started, but we are not attached to its main process's input/output.
    Container creation is different from running a container. As we will learn, Docker
    Swarm services and Kubernetes pods will create container configurations and they
    will also start a defined number of replicas. This is different from starting
    a single container.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已启动，但我们没有附加到其主进程的输入/输出。容器的创建与容器的运行是不同的。正如我们将要学习的，Docker Swarm 服务和 Kubernetes
    Pod 会创建容器配置，并且还会启动一定数量的副本。这与启动单个容器不同。
- en: 'The `STATUS` column shows that the container is now running:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`STATUS` 列显示容器现在正在运行：'
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can add attachments to the container's input/output by adding the `--attach`
    argument to the `docker container run` action. This way, we will run the container
    interactively. Remember that your interaction with the container's main process
    will depend on the parameters that are passed when it was created. We can also
    use `--interactive` as the `start` parameter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`docker container run`命令添加`--attach`参数来附加容器的输入/输出。这样，我们将以交互模式运行容器。记住，您与容器主进程的交互将取决于创建容器时传递的参数。我们也可以将`--interactive`作为`start`参数。
- en: Container security options
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器安全选项
- en: 'There are a number of options for container creation and execution related
    to its security. Let''s review the most important ones with some examples:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多与容器安全相关的选项，用于容器的创建和执行。让我们通过一些示例来回顾最重要的几个选项：
- en: '| `--cap-add or --cap-drop` | Remember that not all system calls are available
    inside containers. We can add or drop default ones using this option. For example,
    if a container needs some special networking features for creating interfaces
    or allowing ports under 1024, we will add `NET_ADMIN` capability. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `--cap-add or --cap-drop` | 请记住，并非所有系统调用在容器内部都可用。我们可以使用此选项添加或删除默认的系统调用。例如，如果容器需要一些特殊的网络功能，比如创建接口或允许1024以下的端口，我们将添加`NET_ADMIN`能力。|'
- en: '| `--disable-content-trust` | We use this option to disable any content trust
    verification (check image origin or ownership, for example). This is not recommended
    in production environments. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `--disable-content-trust` | 我们使用此选项来禁用任何内容信任验证（例如检查镜像的来源或所有权）。在生产环境中不推荐使用此选项。|'
- en: '| `--isolation` | This option is only used on MS Windows containers. Allowed
    values are `process` or `hyper-v`. We will choose which isolation will be used
    in our container. Remember that they have different features, as we learned in
    [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `--isolation` | 此选项仅在 MS Windows 容器中使用。允许的值为 `process` 或 `hyper-v`。我们将选择容器中使用的隔离方式。记住，它们具有不同的特性，正如我们在[第
    1 章](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml)中学习的，*《使用 Docker 构建现代基础设施和应用程序》*。
    |'
- en: '| `--privileged` | Privileged containers will run with all capabilities and
    without any resource limitations. Be careful with these kinds of containers and
    always try to establish what capabilities are required by your application instead
    of using the privileged mode. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `--privileged` | 特权容器将以具有所有功能并且没有任何资源限制的方式运行。使用此类容器时要小心，并始终尝试确定应用程序所需的功能，而不是使用特权模式。
    |'
- en: '| `--read-only` | We can run containers using a read-only root filesystem.
    This is a very good practice in general but we must ensure that all the required
    container storage will use volumes. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `--read-only` | 我们可以使用只读根文件系统来运行容器。一般来说，这是一个非常好的实践，但我们必须确保所有必需的容器存储将使用卷。
    |'
- en: '| `--security-opt` | We will be able to change container options when changing
    default security behavior; for example, using a different seccomp profile or specifying
    that the container will run unconfined. Custom SELinux policies will also use
    this parameter to inform SELinux of non-default values. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `--security-opt` | 我们将能够在更改默认安全行为时更改容器选项；例如，使用不同的 seccomp 配置文件或指定容器将以未受限制的方式运行。自定义的
    SELinux 策略也将使用此参数来通知 SELinux 非默认值。 |'
- en: All the security options described here must be used with care. It is very important
    to understand what capabilities or requirements the applications have instead
    of using default or insecure configurations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在此描述的安全选项都必须谨慎使用。理解应用程序的功能或需求非常重要，而不是使用默认或不安全的配置。 |
- en: It is very important to understand that executing containers using privileged
    mode will bypass all resource restrictions. Be sure that the `--privileged` option
    is only used in specific situations where you really understand the implications
    of running a container with all capabilities and without any resource limits.
    Users allowed to execute privileged containers can run processes without CPU or
    memory limits and can modify important system files.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 理解执行特权模式容器将绕过所有资源限制非常重要。确保 `--privileged` 选项仅在您真正理解以所有功能和没有任何资源限制的方式运行容器的影响时使用。被允许执行特权容器的用户可以在没有
    CPU 或内存限制的情况下运行进程，并且可以修改重要的系统文件。 |
- en: Take your time to review the application requirements before executing the privileged
    containers. Only use them under very clear circumstances and watch out for any
    suspicious behavior on those containers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行特权容器之前，花时间审查应用程序要求。仅在非常明确的情况下使用它们，并且要注意这些容器的任何可疑行为。 |
- en: Executing containers in read-only mode is very useful. We can ensure that the
    applications will not change during their lifetime. Of course, using read-only
    mode depends on your application, but it is good to take some time to analyze
    the process and try to make it work with a read-only filesystem. We will separate
    writable directories into ephemeral volumes to store process data. This is a very
    good practice for improving security easily.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以只读模式执行容器非常有用。我们可以确保应用程序在其生命周期中不会发生变化。当然，使用只读模式取决于您的应用程序，但花点时间分析过程并尝试使其在只读文件系统中工作是很好的做法。我们将可写目录分离到临时卷中，以存储进程数据。这是提高安全性的一个非常好的做法。
    |
- en: Using host namespaces
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用主机命名空间 |
- en: 'The following options are not directly related to security, but they are very
    important. These are related to container isolation and must be managed with care
    because any misuse may cause significant security problems:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项与安全性没有直接关系，但非常重要。它们与容器隔离有关，必须小心管理，因为任何滥用都可能导致重大安全问题： |
- en: '| `--ipc``--pid``--uts` | We can share host namespaces if needed. For example,
    if we are executing a monitoring application inside a container and we need to
    be able to watch for host processes, we will include a host `pid` namespace using
    `--pid host`. Take care of these options as this container will be able to manage
    host processes if we also use extra capabilities or privileged mode. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `--ipc``--pid``--uts` | 如果需要，我们可以共享主机命名空间。例如，如果我们在容器内执行监控应用程序，并且需要能够监视主机进程，我们将使用
    `--pid host` 包含主机的 `pid` 命名空间。注意这些选项，因为如果我们还使用额外的能力或特权模式，容器将能够管理主机进程。 |'
- en: '| `--network` | We have mentioned this option before, but not in this context.
    We can use a host network. In this case, we will use the host''s network inside
    a container. Therefore, all host interfaces will be available inside the container.
    Other containers'' interfaces will also be included. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `--network` | 我们之前提到过这个选项，但在这个上下文中没有提到。我们可以使用主机网络。在这种情况下，我们将在容器内使用主机的网络。因此，所有主机接口都将在容器内可用。其他容器的接口也将被包括在内。
    |'
- en: '| `--userns` | In the first chapter, we talked about user namespaces inside
    containers. We learned about process isolation when we introduced the main container''s
    concepts. This option will allow us to implement an isolated user namespace inside
    a container. We must first prepare user mappings and then we will set which one
    to use on container creation or execution. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `--userns` | 在第一章中，我们讨论了容器内的用户命名空间。当我们介绍容器的主要概念时，我们了解了进程隔离。此选项将允许我们在容器内实现一个隔离的用户命名空间。我们必须首先准备用户映射，然后在创建或执行容器时设置使用哪个映射。
    |'
- en: 'We can easily verify some of the options mentioned in our Docker host. For
    example, we can run a container using the host network mode and retrieve the container''s
    interface:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Docker 主机上轻松验证一些提到的选项。例如，我们可以使用主机网络模式运行一个容器，并检索容器的接口：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can launch another container using the same image but with a host network:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用相同的镜像启动另一个容器，但使用主机网络：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All host interfaces are available inside this small busybox container. This
    is very useful for monitoring host resources. This can help us solve host network
    problems without installing any software, especially in a production environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主机接口都可以在这个小型 busybox 容器内使用。这对于监控主机资源非常有用。这可以帮助我们解决主机网络问题，而无需安装任何软件，尤其是在生产环境中。
- en: In the next section, we will learn how to interact with running containers,
    execute new processes inside them, and copy content to or from them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何与运行中的容器进行交互，在容器内执行新进程，以及将内容复制到容器或从容器复制。
- en: Interacting with containers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与容器交互
- en: 'We can interact with running or stopped containers. We need to interact with
    containers to run some processes within them, review some of their files, or retrieve
    the main process output. These are the main actions we will use to interact with
    containers:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与运行中的或已停止的容器进行交互。我们需要与容器交互，以在其中运行一些进程，查看其文件，或获取主进程的输出。这些是我们将用于与容器交互的主要操作：
- en: '| `attach` | Using `attach`, we will be able to connect to the main process''s
    `STDIN/STDOUT/STDERR`. In other terms, we will be attached to this process to
    interact with it. Be careful because sending a signal with your keyboard may interrupt
    the process and container''s life (we can omit this behavior using `--sig-proxy
    false`). We can only attach to running containers. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `attach` | 使用 `attach`，我们将能够连接到主进程的 `STDIN/STDOUT/STDERR`。换句话说，我们将附加到这个进程上与它交互。需要小心，因为用键盘发送信号可能会中断进程和容器的生命周期（我们可以通过
    `--sig-proxy false` 来省略这种行为）。我们只能附加到正在运行的容器上。 |'
- en: '| `cp` | This action will allow us to send /receive content to/from the container''s
    filesystem. It acts as a normal copy but we can maintain file ownership using
    `--archive`. We will just use the source path and destination and we will use
    the `<container>:</path_to_file>` notation to reference files inside containers.
    Containers can be stopped when we copy files to/from the Docker host. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `cp` | 这个操作将允许我们向容器的文件系统发送/接收内容。它的作用与正常的复制相同，但我们可以使用 `--archive` 来保持文件的所有权。我们只需使用源路径和目标路径，并使用
    `<container>:</path_to_file>` 符号来引用容器内的文件。在将文件复制到/从 Docker 主机时，容器可以是停止状态。 |'
- en: '| `exec` | Using `exec`, we will be able to execute a command inside the container''s
    isolation. This new command inherits all main process namespaces. As a result,
    the new command seems to be running inside the container because they share namespaces.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `exec` | 使用`exec`，我们能够在容器的隔离环境中执行命令。这个新命令会继承所有主进程的命名空间。因此，这个新命令似乎在容器内运行，因为它们共享命名空间。
    |'
- en: '| `logs` | We can review all the container''s output by accessing the container''s
    `STDERR` and `STDOUT`. Logging can be improved using logging drivers to extend
    its functionality; for example, sending these logs to an external host or logging
    backend. Logging is fundamental when we execute background containers or services.
    The only way to know what is happening inside a container is by supervising its
    log. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `logs` | 我们可以通过访问容器的`STDERR`和`STDOUT`来查看容器的所有输出。通过使用日志驱动程序可以改进日志记录功能，例如将这些日志发送到外部主机或日志后端。在执行后台容器或服务时，日志记录是非常重要的。了解容器内部发生了什么，唯一的方法就是监控其日志。
    |'
- en: Once attached to a container, we can detach using the *Ctrl* + *P* + *Q* keyboard
    sequence, but we can change this keyboard combination using the `--detach-keys`
    option while attaching, and when creating or starting a container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦附加到容器，我们可以使用 *Ctrl* + *P* + *Q* 键盘组合来分离，但我们可以在附加容器时使用`--detach-keys`选项来更改此键盘组合，或者在创建或启动容器时进行更改。
- en: 'We will now take a quick look at our running containers (if you do not have
    any, run one container, as described in the previous section):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将快速查看正在运行的容器（如果你没有任何容器，请按照上一节中的描述运行一个容器）：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we execute `ps -ef` inside the container using `docker exec`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`docker exec`在容器内执行`ps -ef`：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We executed the command inside the container's isolation using the main process
    declared user (`root`, in this example).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在容器的隔离环境内执行了该命令，使用的是主进程声明的用户（在本示例中为`root`）。
- en: 'If we want to execute an interactive command – a shell, for example – we can
    do so by specifying `--interactive` (or `-i`) and allocating a pseudo-tty using
    `--tty` (or `-t`). We can set environment variables for this new process with
    `--env` or change the execution user using `--user`. If we need to execute the
    new command with special privileges inside a container, we can also use `--privileged`.
    This can be very useful in debugging on test environments:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想执行交互式命令——例如一个 shell，可以通过指定`--interactive`（或`-i`）并使用`--tty`（或`-t`）分配伪终端来实现。我们可以使用`--env`为这个新进程设置环境变量，或者使用`--user`改变执行用户。如果我们需要在容器内以特殊权限执行新命令，还可以使用`--privileged`。这在测试环境中调试时非常有用：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can copy a file located in the host `/tmp` directory, for example, inside
    our container using `docker container cp`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker container cp`将主机`/tmp`目录中的文件复制到容器内：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we mentioned previously, logging is an important aspect of managing containers.
    We can use `docker container logs` on running or stopped containers. These are
    very useful options to improve the manner in which logs are shown:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，日志记录是管理容器的一个重要方面。我们可以在运行或停止的容器上使用`docker container logs`。这些是非常有用的选项，可以改进日志显示的方式：
- en: '| `--follow` or `-f` | With this option, we can obtain the online output of
    a running container. The output will be updated with every new entry. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `--follow` 或 `-f` | 使用此选项，我们可以获取正在运行的容器的实时输出。每次有新条目时，输出将被更新。 |'
- en: '| `--tail` | With this option, we can specify how many previous lines we want
    to show. By default, all the lines will be shown. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `--tail` | 使用此选项，我们可以指定要显示的前几行日志。默认情况下，将显示所有行。 |'
- en: '| `--since` or `--until` | Both of these options are very useful for showing
    logging only from or before a timestamp or relative period of time (30 minutes
    or 30 m, for example). |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `--since` 或 `--until` | 这两个选项对于仅显示某个时间戳或相对时间段（例如30分钟或30m）之前或之后的日志非常有用。 |'
- en: 'Now, let''s review some of the `docker container logs` arguments in the previously
    executed web server container. In the following example, we will retrieve all
    the lines from the `webserver` container''s output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下之前执行的 Web 服务器容器中的一些`docker container logs`参数。在以下示例中，我们将提取所有来自`webserver`容器输出的行：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the next section, we will review how to avoid host problems by limiting container
    access to host resources.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾如何通过限制容器访问主机资源来避免主机问题。
- en: Limiting host resources
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制主机资源
- en: 'We have seen some options for limiting the container''s resource consumption.
    We will be able to limit access to CPU, memory, and block devices. There are two
    types of limits when we focus on memory resources: soft and hard limits.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了一些限制容器资源消耗的选项。我们将能够限制对 CPU、内存和块设备的访问。当我们关注内存资源时，有两种类型的限制：软限制和硬限制。
- en: Soft limits will represent a reservation of resources. This means that a container
    could consume more memory than declared, but this value will be reserved.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 软限制将表示资源的预留。这意味着容器可以消耗超过声明值的内存，但该值将被预留。
- en: On the other hand, a hard limit will ensure that no more than the declared value
    will be consumed. In fact, the container will die if this limit is surpassed.
    An **out-of-memory** (also known as **OOM**) killer will kill the main process
    to prevent host problems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，硬限制将确保不会消耗超过声明值的资源。实际上，如果超过此限制，容器将被终止。如果超出内存限制，**内存不足**（也称为 **OOM**）杀手会终止主进程以防止主机出现问题。
- en: Remember that, by default, if you do not specify any limits, containers will
    be able to consume all your host resources.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下，如果没有指定任何限制，容器将能够消耗所有主机资源。
- en: 'There are many options available to ensure limited access to resources. We
    can modify default cgroups settings automatically with these parameters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可确保资源访问的限制。我们可以通过这些参数自动修改默认的 cgroups 设置：
- en: '| `--cpu-period`and`--cpu-quota` | CFS is the Linux kernel CPU scheduler and,
    with these parameters, we modify the scheduler period. Both must be configured
    in microseconds and will modify the CPU limits. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `--cpu-period` 和 `--cpu-quota` | CFS 是 Linux 内核的 CPU 调度程序，使用这些参数，我们可以修改调度程序的周期。两个参数都必须以微秒为单位配置，并将修改
    CPU 限制。 |'
- en: '| `--cpu-shares` | This parameter manages the weights for the container''s
    main process. By default, it will start with a value of 1024 and we can set the
    proportion of CPU cycles by increasing or decreasing this value. This is a soft
    limit, which means that the Docker daemon will not prevent container scheduling
    on Docker Swarm. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `--cpu-shares` | 此参数管理容器主进程的权重。默认情况下，它的值为 1024，我们可以通过增减该值来设置 CPU 周期的比例。这是一个软限制，这意味着
    Docker 守护进程不会阻止容器在 Docker Swarm 上的调度。 |'
- en: '| `--cpus`or `-c` | This option helps us set the amount of available CPU resources
    that will be provided to a container process. It is related to the number of CPUs
    available in the host. For example, in a host with three CPUs, using a value of
    `--cpus=1.5` will guarantee half of the CPU resources for this container. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `--cpus` 或 `-c` | 此选项帮助我们设置将提供给容器进程的可用 CPU 资源量。它与主机中可用的 CPU 数量相关。例如，在拥有三个
    CPU 的主机上，使用 `--cpus=1.5` 的值将为该容器保证一半的 CPU 资源。 |'
- en: '| `--cpuset-cpus` | This CPU setting is simpler than CPU shares or setting
    how many CPUs to use. We will just specify a comma-separated list of host CPUs
    where the container can run (we will start at 0 when writing a CPU range). |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `--cpuset-cpus` | 此 CPU 设置比 CPU 权重或设置使用多少 CPU 更简单。我们只需指定一个以逗号分隔的主机 CPU 列表，容器可以在这些
    CPU 上运行（我们在写 CPU 范围时从 0 开始）。 |'
- en: '| `--memory`or `-m` | This will set the maximum amount of memory available
    for a container''s process. This is a threshold and the Docker daemon will not
    allow the container to surpass this limit. Whenever this limit is surpassed, the
    kernel will kill the container''s main process. We will obtain an out-of-memory
    error. This procedure is known as `oom-killer`. We can disable `oom-killer` using
    `--oom-kill-disable`. This can be dangerous and you must be careful with this
    option as containers could take all the host memory resources. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `--memory` 或 `-m` | 这将设置容器进程可用的最大内存量。这是一个阈值，Docker 守护进程不会允许容器超过此限制。每当超过此限制时，内核将终止容器的主进程。我们将得到内存不足错误。这一过程被称为
    `oom-killer`。我们可以使用 `--oom-kill-disable` 禁用 `oom-killer`。这可能会很危险，使用此选项时必须小心，因为容器可能会消耗掉所有主机的内存资源。
    |'
- en: '| `--memory-reservation` | With this parameter, we will configure a reservation
    of memory for our processes. It should be set to a lower value than the previously
    mentioned `--memory` threshold value. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `--memory-reservation` | 使用此参数，我们将为进程配置内存预留。它应该设置为低于之前提到的 `--memory` 阈值。
    |'
- en: '| `--blkio-weight`and`--blkio-weight-device` | The first argument will manage
    how much total block direct I/O bandwidth will be available for a container, while
    the second one will manage how much bandwidth will be available for a specific
    block device. By default, all containers run with the same bandwidth. This value
    is 500, and we can increase or decrease this value so that it''s between 10 and
    1,000\. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `--blkio-weight` 和 `--blkio-weight-device` | 第一个参数将管理容器可以使用的总块直接 I/O 带宽，而第二个参数将管理特定块设备可用的带宽。默认情况下，所有容器使用相同的带宽，值为
    500，我们可以将其增加或减少，范围为 10 到 1000。 |'
- en: Many of the features we will use to isolate access to resources require that
    the host kernel supports Linux capabilities. We can review all disabled capabilities
    using `docker system info`, looking for any `WARNING` messages.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的许多功能都需要宿主机内核支持 Linux 能力。我们可以使用 `docker system info` 来查看所有被禁用的能力，并查找任何
    `WARNING` 消息。
- en: Whenever we need to update the container limits, we can use the `docker container
    update` action, which allows us to change memory, CPU, and block device usage
    limits on containers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要更新容器限制时，可以使用 `docker container update` 操作，它允许我们更改容器的内存、CPU 和块设备使用限制。
- en: There are a few actions that will help us in reviewing the container's resource
    usage.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些操作可以帮助我们审查容器的资源使用情况。
- en: 'We will use `docker container stats` to retrieve container usage metrics. By
    default, only CPU usage percentage, memory usage and its limit, network and block
    I/O, and the number of processes inside containers will be shown. We can format
    its output using the `--format` parameter, with common Go language format patterns.
    We will usually use a table format:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `docker container stats` 来获取容器的使用指标。默认情况下，仅显示 CPU 使用百分比、内存使用及其限制、网络和块
    I/O，以及容器内进程的数量。我们可以使用 `--format` 参数格式化输出，支持常见的 Go 语言格式模式。通常我们会使用表格格式：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can specify a container's name or ID to only show its statistics. It is important
    to know that `docker stats` is a stream-like command. This means that it will
    be continuously refreshing content with new data unless we use the `--no-stream`
    argument to obtain static output on a single page.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定容器的名称或 ID，只显示它的统计信息。需要注意的是，`docker stats` 是一个流式命令。这意味着除非我们使用 `--no-stream`
    参数来获取静态输出，否则它将不断刷新内容并显示新数据。
- en: Depending on the amount of data shown, sometimes, values are truncated. This
    can happen in many other objects' actions. To avoid the truncation of important
    data, we can use `--no-trunc` any time we need to retrieve all column data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据显示的数据量，有时，值会被截断。这在许多其他对象的操作中也可能发生。为了避免重要数据的截断，我们可以在需要获取所有列数据时使用 `--no-trunc`。
- en: 'On the other hand, `docker container top` will show us information in a top-like
    format regarding all the container''s internal processes. Using our web server
    from the previous examples, we can execute `docker container top webserver` to
    obtain the `nginx` main process and its child''s states:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`docker container top` 将以类似 top 的格式显示容器内部所有进程的信息。使用我们之前示例中的 Web 服务器，我们可以执行
    `docker container top webserver` 来获取 `nginx` 主进程及其子进程的状态：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can add swap access using `--memory-swap` and `--memory-swappiness` but this
    is not recommended. Swapping could decrease application performance and it really
    breaks the logic of distributed microservices. Orchestration will allow us to
    run different components on different nodes, depending on their requirements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `--memory-swap` 和 `--memory-swappiness` 来增加交换访问，但不推荐这么做。交换可能会降低应用程序性能，而且它会破坏分布式微服务的逻辑。调度将允许我们根据不同组件的需求在不同的节点上运行它们。
- en: In the next section, we will review actions related to images. With these, we
    will be able to create an image from a container, as we learned in *[Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    Building Docker Images*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将回顾与图像相关的操作。通过这些操作，我们将能够从容器创建图像，正如我们在 *[第二章](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml)，构建
    Docker 图像* 中所学到的那样。
- en: Converting containers into images
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器转换为图像
- en: 'We have learned about three different methods for building images, and all
    of them use containers in some shape or form. Let''s review the container actions
    that can be used to create images:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了三种不同的构建图像的方法，它们都以某种方式使用了容器。现在让我们回顾一下可以用来创建图像的容器操作：
- en: '| `commit` | `docker commit` will allow us to create an image from a container.
    We will add a container''s layer as a new image layer. As a result, we obtain
    a new image. We will set a new image name (although we learned that we can change
    image names whenever we need to) with its tag. The container will be paused during
    the commit to avoid file changes during its execution. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `commit` | `docker commit` 将允许我们从容器创建镜像。我们将一个容器的层添加为新的镜像层。结果，我们获得一个新的镜像。我们将设置一个新的镜像名称（尽管我们学会了可以根据需要随时更改镜像名称）以及其标签。在提交过程中，容器将被暂停，以避免其执行期间的文件更改。'
- en: '| `export` | This action will create a `.tar` file containing the container''s
    filesystem (including data from all of its layers). By default, this command will
    stream binary content to `STDOUT`, but we can use `--output` or `-o` to define
    a file for this content. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `export` | 此操作将创建一个包含容器文件系统（包括其所有层的数据）的`.tar`文件。默认情况下，此命令将二进制内容流式传输到`STDOUT`，但我们可以使用`--output`或`-o`来定义此内容的文件。'
- en: When we need to know about the changes we made to the original image layers,
    we can use `docker container diff`. This will show a list of all the files that
    have been modified or created on the container's layer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要了解我们对原始镜像层所做的更改时，我们可以使用`docker container diff`。这将显示修改或创建在容器层上的所有文件的列表。
- en: 'Using the container web server from the previous examples, we can observe all
    the changes that were made during its execution:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面示例中的容器 Web 服务器，我们可以观察到在其执行期间所做的所有更改：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This list shows added files, marked as `A`, as well as changed files and directories,
    marked with `C`. Notice that every time we add a file to a directory, the directory
    is also changed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示已添加的文件，标记为`A`，以及已更改的文件和目录，标记为`C`。请注意，每次向目录添加文件时，目录也会更改。
- en: We will usually deploy tens, hundreds, or even thousands of containers within
    Docker hosts. It is important to be able to retrieve information about them in
    order to manage their properties and states. In the next section, we will review
    some of the options available to format and filter information in container environments.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会在 Docker 主机中部署数十、数百甚至数千个容器。重要的是能够检索关于它们的信息，以便管理其属性和状态。在下一节中，我们将审查一些用于在容器环境中格式化和过滤信息的选项。
- en: Formatting and filtering information
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化和过滤信息
- en: Formatting and filtering the output of any command is always useful. In Docker
    commands with long lists or outputs, it is really necessary. Let's begin with
    formatting some command output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何命令输出进行格式化和过滤始终是有用的。在 Docker 命令中，具有长列表或输出时，这确实是必要的。让我们开始格式化一些命令输出。
- en: Almost all actions that represent or show any kind of information can be formatted.
    Docker uses Go templates to modify the output format. It is very useful to be
    able to format output for our specific needs. We will use the table format here.
    Each column will represent a specified key.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有表示或显示任何信息的操作都可以进行格式化。Docker 使用 Go 模板来修改输出格式。能够根据我们的特定需求格式化输出非常有用。在这里，我们将使用表格格式。每列将表示一个指定的键。
- en: 'We will consider a brief example output listing all the deployed containers
    in a host using `docker container ls` with the table format:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个简短的示例输出，列出主机上所有部署容器，使用`docker container ls`以表格格式：
- en: '[PRE24]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have used `--no-trunc` to disable the truncation of printed values. Without
    using this option, all long strings will be truncated and will only show a few
    characters. Usually, they will be enough to identify a value, but sometimes, we
    need the entire string; for example, to review the container's main executed command.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用`--no-trunc`来禁用打印数值的截断。如果不使用此选项，所有长字符串都会被截断，只显示少量字符。通常，这些字符足以识别值，但有时我们需要整个字符串；例如，用于查看容器的主要执行命令。
- en: It is very useful to know what keys can be queried for formatting. To obtain
    all allowed keys for formatting, we will use `--format='{{json .}}'`. This will
    show all the columns or keys for a specified action (for example, try `docker
    container ls --all --format='{{json .}}'`). The output will be shown in unformatted
    JSON.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 知道可以查询哪些键来进行格式化非常有用。为了获取所有允许用于格式化的键，我们将使用`--format='{{json .}}'`。这将显示指定操作的所有列或键（例如，尝试`docker
    container ls --all --format='{{json .}}'`）。输出将显示为未格式化的JSON。
- en: The unformatted JSON output is not easy to read. We can use **jq** ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)),
    which is a command-line JSON processor for better reading. Using jq, we will obtain
    more prettily formatted JSON.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 未格式化的 JSON 输出不容易阅读。我们可以使用 **jq** ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))，这是一种命令行
    JSON 处理器，便于阅读。使用 jq，我们将获得更漂亮的 JSON 格式化输出。
- en: 'There are a number of customized options for formatting:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多定制化的格式化选项：
- en: '| `json` | As we have seen, this option will format the output as a single-line
    JSON string. For example, we can use `--format=''{{json .Config}}''` with `docker
    inspect` output for a container to obtain all its configuration keys and values.
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `json` | 如我们所见，此选项将输出格式化为单行 JSON 字符串。例如，我们可以使用 `--format=''{{json .Config}}''`
    与 `docker inspect` 输出容器，获取其所有配置的键和值。 |'
- en: '| `table` | The table format option is not available in all outputs, but it
    will work pretty well on lists. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `table` | 表格格式选项并非在所有输出中都可用，但在列表中会表现得非常好。 |'
- en: '| `join/split` | With these options, we will be able to join or split key outputs;
    for example, `''{{json .Mounts}}''` or `''{{split .Image ":"}}''`. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `join/split` | 使用这些选项，我们可以连接或拆分关键输出；例如，`''{{json .Mounts}}''` 或 `''{{split
    .Image ":"}}''`。 |'
- en: '| `lower/upper/title` | These options allow us to change strings to lowercase,
    uppercase, or just capitalize the first character; for example, `''{{title .Name}}''`
    will show all names with a capitalized first character. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `lower/upper/title` | 这些选项允许我们将字符串转换为小写、大写或仅将首字母大写；例如，`''{{title .Name}}''`
    将显示所有首字母大写的名称。 |'
- en: '| `range` | This option will help us format list/array values. You have to
    use `''{{range <JSON keys> }}{{end}}''` to correctly manage the listed values.
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `range` | 此选项将帮助我们格式化列表/数组值。你必须使用 `''{{range <JSON keys> }}{{end}}''` 来正确管理列出的值。
    |'
- en: '| `println` | This option will print each queried value in a new line. It is
    very interesting for formatting range values. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `println` | 此选项将在新的一行中打印每个查询值。它对于格式化范围值非常有趣。 |'
- en: The `--pretty` option is available for inspecting some objects. It is very useful
    but, as we mentioned previously, it is not available for all objects. For example,
    you can use it to inspect services, which we will learn about in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`--pretty` 选项可用于检查某些对象。它非常有用，但如前所述，并非所有对象都可用。例如，您可以使用它来检查服务，我们将在[第 8 章](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml)中学习，*使用
    Docker Swarm 进行编排*。'
- en: Formatting will help us to obtain only required pieces of information, but it
    will not be easy when we have to manage a lot of items. We will filter the information
    using the `--filter` option to retrieve only specific objects matching some keys
    and values. Not all keys will be available for filtering. We will use keys with
    their values for filters and we can use as many filter options as required. If
    we add more than one filter with the same key, they will be used as `OR`. But
    if we use different keys, this will be an `AND` filter. We will use "equal" (using
    `=`) or "different" (using `<>` ) to compare key values.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化将帮助我们只获取所需的信息，但当我们必须处理大量项目时，将不太容易。我们将使用 `--filter` 选项来过滤信息，只检索匹配某些键和值的特定对象。并非所有键都可用于过滤。我们将使用带有其值的键进行过滤，并且可以根据需要使用多个过滤选项。如果我们添加多个相同键的过滤器，它们将作为
    `OR` 使用。但如果我们使用不同的键，则将是 `AND` 过滤器。我们将使用“相等”（使用 `=`）或“不同”（使用 `<>`）来比较键值。
- en: 'Container objects can be filtered by means of the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 容器对象可以通过以下方式进行过滤：
- en: '**ID or name**: With these options, we can find containers by their IDs or
    names.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID 或名称**：使用这些选项，我们可以通过容器的 ID 或名称来查找容器。'
- en: '**Label**: This case is special as we can express the query using a key to
    match all the containers with that label or key-value format, in order to find
    a specific value for that key.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：此情况特别，因为我们可以使用键来匹配所有带有该标签或键值格式的容器，以便找到该键的特定值。'
- en: '**Exited**: We will use this option with an exited integer when using `--all`
    to filter containers stopped with errors, for example.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已退出**：当使用 `--all` 过滤停止并带有错误的容器时，我们将使用带有退出整数的此选项，例如。'
- en: '**Status**: We use this option to filter by container state (`created`, `restarting`,
    `running`, `removing`, `paused`, `exited` or `dead`).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：我们使用此选项按容器状态（`created`、`restarting`、`running`、`removing`、`paused`、`exited`
    或 `dead`）进行过滤。'
- en: '**Ancestor**: This is very important because it will allow us to filter by
    image name and tags.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**祖先**：这一点非常重要，因为它将允许我们按镜像名称和标签进行过滤。'
- en: '**Before/since**: This filter allows us to specify dates, for example, to find
    a container running for a long time or filter by its creation date.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**之前/自此**：此过滤器允许我们指定日期，例如，查找运行时间较长的容器或按其创建日期进行筛选。'
- en: '**Volume/network**: This option allows us to filter which containers are using
    a volume or network. It is useful for removing old resources.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷/网络**：这个选项允许我们筛选使用卷或网络的容器。它对于删除旧资源非常有用。'
- en: '**Publish or expose**: These options filter which containers are publishing
    or exposing specified ports. We can use a range of ports and protocols (`<startport-endport>`/`[<proto>]`).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布或暴露**：这些选项过滤哪些容器正在发布或暴露指定的端口。我们可以使用一系列的端口和协议（`<startport-endport>`/`[<proto>]`）。'
- en: '**Health**: This filter allows us to search containers by their health check
    status (healthy, unhealthy, starting, or none).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：此过滤器允许我们根据容器的健康检查状态（健康、不健康、启动中或无）进行筛选。'
- en: '**Is-task**: This option is very interesting because it allows us to filter
    containers created by tasks when using Docker Swarm orchestration.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Is-task**：这个选项非常有趣，因为它允许我们在使用 Docker Swarm 编排时，按任务创建的容器进行筛选。'
- en: Notice that `--format` is used for filtering on the `docker <object> inspect`
    command. We can only query specific object keys and subkeys. For example, using
    `--format='{{json .Config}}'` will just show keys and values under the `Config`
    key***.***
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`--format` 用于过滤 `docker <object> inspect` 命令。我们只能查询特定的对象键和子键。例如，使用 `--format='{{json
    .Config}}'` 将只显示 `Config` 键下的键和值***。***
- en: In the next section, we will review how to use host attached devices as if they
    were inside containers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将回顾如何将主机附加的设备像在容器内部一样使用。
- en: Managing devices
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理设备
- en: We can provide access to host devices inside containers. We use the `--device`
    argument with `docker container create` or `docker container run` for this. We
    will be able to use hardware devices connected directly to a host, such as serial
    controllers, block storage, or audio devices.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为容器提供主机设备的访问权限。我们使用 `--device` 参数与 `docker container create` 或 `docker container
    run` 一起使用来实现这一点。这样，我们将能够使用直接连接到主机的硬件设备，例如串口控制器、块存储或音频设备。
- en: By default, devices will have read and write permissions. To be able to manipulate
    special devices, the `mknod` permission is also added by default. We can override
    these default settings using `r`, `w`, and `m` in the command line as modifiers
    of the `--device` option.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，设备将具有读写权限。为了能够操作特殊设备，默认情况下还会添加 `mknod` 权限。我们可以通过在命令行中使用 `r`、`w` 和 `m`
    来覆盖这些默认设置，作为 `--device` 选项的修饰符。
- en: 'As an example, we can mount our `lvm` mapped block device to a defined directory;
    notice that the mounting capability must be added. In this example, we added `SYS_ADMIN`
    capabilities:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们可以将我们的 `lvm` 映射的块设备挂载到定义的目录；请注意，必须添加挂载功能。在这个例子中，我们添加了 `SYS_ADMIN` 功能：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following example, we are using our host sound device inside a container.
    Adding these devices to containers will allow us to run some applications with
    sound:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在容器内使用我们的主机声音设备。将这些设备添加到容器中将允许我们运行带有声音的应用程序：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have learned that not just files or directories can be accessed inside
    containers. We can use special devices as if they were directly attached to containers.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们了解到不仅仅是文件或目录可以在容器内部访问。我们可以像直接连接到容器一样使用特殊设备。
- en: Chapter labs
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章实验
- en: In the labs in this chapter, we will run containers and interact with them.
    We will also review some examples, limiting their resources and formatting and
    filtering the command output.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的实验中，我们将运行容器并与它们互动。我们还将回顾一些示例，限制它们的资源，格式化和过滤命令输出。
- en: To run these labs, deploy `environments/standalone-environment` from this book's
    GitHub repository ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment` folder to start your virtual
    environment.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 若要运行这些实验，请从本书的 GitHub 仓库中部署 `environments/standalone-environment`（[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)），如果您还没有这样做。您也可以使用自己的
    CentOS 7 服务器。从 `environments/standalone-environment` 文件夹中使用 `vagrant up` 启动虚拟环境。
- en: 'If you are using `standalone-environment`, wait until it is running. We can
    check the statuses of our nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`standalone-environment`，请等待它启动。我们可以使用`vagrant status`检查节点的状态。使用`vagrant
    ssh standalone`连接到你的实验节点。`standalone`是你节点的名称。你将使用`vagrant`用户，并通过`sudo`获取管理员权限。你应该得到如下输出：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now connect to the `standalone` node using `vagrant ssh standalone`.
    This process may vary if you''ve already deployed a `standalone` virtual node
    before and you just started it using `vagrant up`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`vagrant ssh standalone`连接到`standalone`节点。如果你之前已经部署过`standalone`虚拟节点，并且只是通过`vagrant
    up`启动它，过程可能有所不同：
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you are reusing your `standalone-environment`, this means Docker Engine
    is installed. If you started a new instance, please execute the `/vagrant/install_requirements.sh`
    script so that you have all the required tools (Docker Engine and docker-compose):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在重用`standalone-environment`，这意味着Docker Engine已经安装。如果你启动了一个新的实例，请执行`/vagrant/install_requirements.sh`脚本，以确保你拥有所有必需的工具（Docker
    Engine和docker-compose）：
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, you are ready to start the labs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好开始实验。
- en: Reviewing Docker command-line object options
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查Docker命令行对象选项
- en: 'The Docker command line will allow us to interact with Docker daemons. We will
    use Docker objects or resources with their allowed actions. In the following screenshot,
    we can easily review this behavior in the Docker `help` command''s output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令行将允许我们与Docker守护进程交互。我们将使用Docker对象或资源及其允许的操作。在下面的截图中，我们可以轻松地查看Docker
    `help`命令输出中的这种行为：
- en: '![](img/d6824a64-9226-4ae4-ac05-f40a7896651d.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6824a64-9226-4ae4-ac05-f40a7896651d.jpg)'
- en: 'Objects will appear in the first part, after common options. At the bottom,
    we will have all the options allowed. As we mentioned in this chapter, not all
    objects have the same actions. This chapter is dedicated to containers. So, let''s
    review what actions are allowed with containers (the output is truncated):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对象将在第一部分中出现，之后是常见的选项。在底部，我们将看到所有允许的选项。正如我们在本章中提到的，并非所有对象都有相同的操作。本章专门讨论容器。那么，让我们回顾容器允许的操作（输出被截断）：
- en: '[PRE30]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We should use `--help` with each kind of object to review what actions are available
    for them. If we have not set any `DOCKER_HOST` variable (nor using `-H` ), we
    will interact with the local Docker daemon. We will use these arguments in the
    command line to connect to remote daemons.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在每种对象上使用`--help`来查看它们可用的操作。如果我们没有设置任何`DOCKER_HOST`变量（也没有使用`-H`），我们将与本地Docker守护进程交互。我们将在命令行中使用这些参数来连接远程守护进程。
- en: 'Actually, there are many well-known Docker command-line aliases:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有许多知名的Docker命令行别名：
- en: '`docker run`: `docker container run`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run`: `docker container run`'
- en: '`docker ps`: `docker container ls`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps`: `docker container ls`'
- en: '`docker rm`: `docker container rm`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rm`: `docker container rm`'
- en: '`docker start/stop`: `docker container start/stop`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker start/stop`: `docker container start/stop`'
- en: '`docker port`: `docker container port`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker port`: `docker container port`'
- en: '`docker rmi`: `docker image rm`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rmi`: `docker image rm`'
- en: It is recommended to use long command-line terms as they actually indicate an
    object and action. This will avoid confusion or the misspelling of commands.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用长命令行术语，因为它们实际上指示了一个对象和一个操作。这将避免混淆或拼写错误。
- en: Executing containers
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行容器
- en: 'This is a long lab in which we are going to review many actions and options
    available to containers. Let''s get started:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长时间的实验，我们将回顾容器的许多操作和选项。让我们开始吧：
- en: 'Execute an interactive container based on an Alpine image in the background:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台基于Alpine镜像执行一个交互式容器：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we will review and rename the container `myalpineshell`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将查看并重命名容器`myalpineshell`：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use `-l` or `--last` to obtain the latest container that was executed on
    our Docker host. Notice that we will use `-q` in the following code to obtain
    the container's ID.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-l`或`--last`来获取在Docker主机上执行的最新容器。请注意，接下来的代码中我们将使用`-q`来获取容器的ID。
- en: 'Now, we rename the previously launched container using its ID:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用容器的ID来重命名之前启动的容器：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we review the latest container again, we will see that we have a different
    name. Notice that the container is running (the output will show different dates
    for you):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看最新的容器，我们会看到它有一个不同的名称。注意，容器正在运行（输出将显示不同的日期）：
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We attach our Terminal to the running `myalpineshell` container and we create
    an empty file named `TESTFILE` under the `/tmp` directory. Then, we `exit` from
    the container:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将终端附加到正在运行的`myalpineshell`容器，并在`/tmp`目录下创建一个名为`TESTFILE`的空文件。然后，我们从容器中`exit`：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we review the container''s status again, we will find that it has stopped,
    but that it exited correctly:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次查看容器状态，我们会发现它已经停止，但退出状态是正确的：
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The container now shows an `Exited (0)` status. The Alpine image's main process
    is a shell. Its CMD is `/bin/sh`. We exited by issuing the `exit` command. Therefore,
    the exit status was `0`. No problem was identified during execution.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器现在显示`Exited (0)`状态。Alpine镜像的主进程是一个shell。其CMD是`/bin/sh`。我们通过执行`exit`命令退出。因此，退出状态是`0`，执行过程中没有发现问题。
- en: 'Now, we are going to force a failure status by executing, for example, a command
    that doesn''t exist in the image. We will execute the `curl` command on a new
    container:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过执行一个不存在于镜像中的命令来强制使容器失败。例如，我们将在一个新容器中执行`curl`命令：
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the `curl` binary does not exist, we cannot even execute the desired command.
    As a result, the container was created but not executed:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`curl`二进制文件不存在，我们甚至无法执行所需的命令。因此，容器已创建但未执行：
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we will execute `ls -l /tmp/TESTFILE` on a new container:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在新容器中执行`ls -l /tmp/TESTFILE`：
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As expected, the `/tmp/TESTFILE` file does not exist in this new container.
    We only created it in the `myalpineshell` container. In fact, the file is still
    there. Notice that this time, the container was executed and that the exit status
    shows an error code. This is the exit code of the execution of the `ls` command
    against a non-existent file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`/tmp/TESTFILE`文件在这个新容器中不存在。我们只在`myalpineshell`容器中创建了它。实际上，文件仍然在那里。请注意，这次容器被执行了，且退出状态显示为错误代码。这是执行`ls`命令时因文件不存在而导致的退出代码。
- en: 'Let''s rename the last executed container again:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次重命名最后执行的容器：
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we will create the `/tmp/TESTFILE` file on our own host filesystem and
    copy it to the `secondshell` container:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在主机文件系统上创建`/tmp/TESTFILE`文件，并将其复制到`secondshell`容器中：
- en: '[PRE41]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is not possible to copy files from one container to another using `docker
    container cp`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 无法使用`docker container cp`从一个容器复制文件到另一个容器。
- en: 'Now, let''s start the `secondshell` container again and observe the new results:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新启动`secondshell`容器并观察新的结果：
- en: '[PRE42]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The file now exists inside the `secondshell` container and, as a result, the
    execution exited correctly. We can notice this new result in the `STATUS` column
    (`Exited (0)`). We have manipulated a dead container by copying a file inside
    it. Therefore, containers are still present in our host system until we remove
    them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件现在存在于`secondshell`容器内，因此执行正确退出。我们可以在`STATUS`列中看到这一新结果（`Exited (0)`）。我们通过将文件复制到已停止的容器中，操作了一个死容器。因此，容器仍然存在于主机系统中，直到我们将其删除。
- en: 'Now, we will remove the `secondshell` container and try to filter the container
    list''s output. We will search for the `secondshell` and `myalpineshell` containers:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将删除`secondshell`容器，并尝试过滤容器列表的输出。我们将搜索`secondshell`和`myalpineshell`容器：
- en: '[PRE43]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As expected, we only get the `myalpineshell` container.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们只得到了`myalpineshell`容器。
- en: 'To finish this lab, we will start the `myalpineshell` container once more using
    `docker container start -a -i` to attach our Terminal to the started container.
    Then, we will send the container to the background using the *Ctrl* + *P* + *Q*
    escape sequence. Finally, we will attach a second shell to the container using
    the `docker container exec` command:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个实验，我们将再次启动`myalpineshell`容器，使用`docker container start -a -i`将终端附加到已启动的容器。然后，我们将使用*Ctrl*
    + *P* + *Q*逃脱序列将容器发送到后台。最后，我们将使用`docker container exec`命令附加第二个shell到容器：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can observe that exiting from the newly executed shell process does not
    kill the `myalpineshell` container. Both processes share the same namespaces:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，退出新执行的shell进程并不会终止`myalpineshell`容器。两个进程共享相同的命名空间：
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Limiting container resources
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制容器资源
- en: In this lab, we are going to use the `frjaraur/stress-ng:alpine` image from
    Docker Hub. This image is based on Alpine Linux with the `stress-ng` packages
    installed. It is small and will help us stress our containers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用来自Docker Hub的`frjaraur/stress-ng:alpine`镜像。该镜像基于Alpine Linux，并安装了`stress-ng`包。它很小，有助于我们对容器施加压力。
- en: We will start with testing memory limits. In this lab, we will use two Terminals
    on the same host. On the first Terminal, we will launch `docker container stats`.
    Keep this running during all these labs because, in this Terminal, we are going
    to observe different behaviors.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从测试内存限制开始。在这个实验中，我们将在同一主机上使用两个终端。在第一个终端中，我们将启动 `docker container stats`。在所有实验过程中保持这个终端运行，因为在这个终端中，我们将观察不同的行为。
- en: 'In the second Terminal, we will launch two containers that will try to consume
    2 GB of memory. We will use `--vm 2 --vm-bytes 1024M` to create two processes
    with 1,024 MB of memory in each:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个终端中，我们将启动两个容器，这两个容器将尝试消耗 2 GB 内存。我们将使用 `--vm 2 --vm-bytes 1024M` 创建两个进程，每个进程分配
    1,024 MB 内存：
- en: 'We are going to launch a container with a memory reservation. This means that
    the Docker daemon will reserve at least that amount of memory for this container.
    Remember that this is not a limit; it is a reservation:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将启动一个具有内存预留的容器。这意味着 Docker 守护进程将为该容器预留至少该数量的内存。请记住，这不是限制；这是预留：
- en: '[PRE46]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we will launch a limited container. Only 250 MB of memory will be allowed,
    although the container will try to consume 2 GB:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将启动一个限制内存的容器。只允许 250 MB 内存，尽管该容器会尝试消耗 2 GB：
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the first Terminal, we have `docker container stats` running to review our
    container''s resource consumption. We will have something like this (IDs and usage
    will vary):'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个终端中，我们运行 `docker container stats` 来查看容器的资源消耗。我们会看到类似这样的内容（ID 和使用情况会有所不同）：
- en: '[PRE48]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you obtain a warning message about limiting resources, this is normal. The
    `WARNING: Your kernel does not support swap limit capabilities or the cgroup is
    not mounted. Memory limited without swap.` message indicates that your operating
    system will not limit `swap` for containers. It comes disabled by default on Debian/Ubuntu.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你收到关于限制资源的警告消息，这是正常的。`WARNING: Your kernel does not support swap limit capabilities
    or the cgroup is not mounted. Memory limited without swap.` 这条消息表示你的操作系统不会限制容器的
    `swap`。在 Debian/Ubuntu 上，默认情况下它是禁用的。'
- en: We can observe that the non-limited container is taking more than the specified
    memory. In the second case, the container was limited to 250 MB, although the
    process could consume more, it was limited and it will not get more than this
    memory. It is confined to 250 MB, as we can observe in the `MEM USAGE/LIMIT MEM`
    column. It could reach 100% of its confined memory, but it cannot surpass that
    limit.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到没有限制的容器正在消耗超过指定的内存。在第二个案例中，容器限制为 250 MB，尽管进程可以消耗更多内存，但它被限制在 250 MB 内，不会超过此限制。正如我们在
    `MEM USAGE/LIMIT MEM` 列中看到的，它最多只能达到其限定的内存，但不能超过这个限制。
- en: 'Remove the `2GBreserved` and `2GBlimited` containers:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `2GBreserved` 和 `2GBlimited` 容器：
- en: '[PRE49]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we will limit the CPU consumption.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将限制 CPU 消耗。
- en: 'We will launch three containers with different CPU limitations and process
    requirements. The first container is limited to one CPU, but with two CPU requirements.
    This is not a genuine requirement, but the process will try to use two CPUs if
    they are present in this system:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将启动三个具有不同 CPU 限制和进程要求的容器。第一个容器限制为一个 CPU，但需要两个 CPU。这不是一个真实的需求，但如果系统中有两个 CPU，进程将尝试使用两个
    CPU：
- en: '[PRE50]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The second container is limited to two CPUs with a requirement of two CPUs.
    It will try to use both during execution:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个容器限制为两个 CPU，并且需要两个 CPU。在执行过程中，它将尝试使用这两个 CPU：
- en: '[PRE51]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The third container is limited to four CPUs with two CPUs required. In this
    case, the processes could consume four CPUs, but as they will just use two CPUs,
    they will not have a real limitation unless we try to use more than four CPUs:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个容器限制为四个 CPU，且需要两个 CPU。在这种情况下，进程可以使用四个 CPU，但由于它们只使用两个 CPU，因此除非我们尝试使用超过四个 CPU，否则不会有真正的限制：
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we observe the Docker container''s stats output, we can confirm the expected
    results:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们观察 Docker 容器的统计输出，我们可以确认预期结果：
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With that, we have reviewed how we can limit the container's resources. We tested
    CPU and memory usage with `docker container stats`, pushing them to their defined
    limits.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经回顾了如何限制容器的资源。我们通过 `docker container stats` 测试了 CPU 和内存的使用情况，将它们推向了预定的限制。
- en: Now, let's review formatting and filtering with some labs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一些实验来回顾格式化和过滤。
- en: Formatting and filtering container list output
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化和过滤容器列表输出
- en: 'In this lab, we will review the `docker container ls` output. Let''s get started:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将回顾 `docker container ls` 输出。让我们开始吧：
- en: 'Launch a number of containers. For this example, we will run three `nginx:alpine`
    instances with sequence names:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动多个容器。在这个示例中，我们将运行三个 `nginx:alpine` 实例，并使用顺序名称：
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s list the running containers using the `docker container ls` default
    output:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`docker container ls`默认输出列出正在运行的容器：
- en: '[PRE55]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since we want to be able to review the current status of the containers, we
    can format the output so that it includes label information:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望能够查看容器的当前状态，因此我们可以格式化输出，使其包括标签信息：
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s filter just the development containers (`stage=development`):'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们只过滤出开发容器（`stage=development`）：
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s kill just those development containers using the list output:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用列表输出杀死那些开发容器：
- en: '[PRE58]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Only `web1`, labeled as `production`, is still running as expected.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 只有被标记为`production`的`web1`仍在按预期运行。
- en: Filtering and formatting are very useful. Practice these methods because they
    are important for the Docker Certified Associate exam.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤和格式化非常有用。练习这些方法，因为它们对Docker认证助理考试非常重要。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was dedicated to the Docker command line and running containers.
    We found a powerful command line that allowed us to create containers from image
    artifacts, share them between hosts, and execute the already built application
    components.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讲解了Docker命令行和运行容器。我们发现了一个强大的命令行工具，它允许我们从镜像工件创建容器，在主机之间共享它们，并执行已经构建好的应用组件。
- en: We learned how to interact with different Docker objects, as well as what kind
    of objects are available in standalone Docker host environments and what objects
    are available in orchestrated environments.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何与不同的Docker对象进行交互，以及在独立Docker主机环境和编排环境中有哪些可用的对象。
- en: We then reviewed how containers can be created, executed, paused/unpaused, and
    stopped or killed. They will stay in our Docker host until they are removed from
    the system. We also learned how to manipulate the container's execution behavior
    and how they exist within the network. To improve security, we introduced a number
    of options and we also learned how executing containers in read-only mode can
    be very useful.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了如何创建、执行、暂停/恢复、停止或杀死容器。它们会一直存在于我们的Docker主机中，直到被从系统中移除。我们还学习了如何操控容器的执行行为以及它们如何在网络中存在。为了提高安全性，我们介绍了许多选项，并且还学习了以只读模式执行容器是如何非常有用的。
- en: Limiting the container's resources is necessary for production. By default,
    they will be able to consume all the host's resources, which can be very dangerous.
    We learned how to avoid this situation using soft and hard limits to ensure that
    our applications will run on a host with enough resources and does not disturb
    others.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 限制容器资源是生产环境中的必要操作。默认情况下，它们可以消耗主机的所有资源，这可能非常危险。我们学习了如何通过软硬限制来避免这种情况，确保我们的应用程序可以在具有足够资源的主机上运行，并且不会干扰其他应用。
- en: Formatting and filtering specific information is needed while deploying applications
    on dynamic environments. We learned how format and filter actions will help us
    retrieve specific information.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态环境中部署应用时，需要格式化和过滤特定信息。我们学习了格式化和过滤操作如何帮助我们检索特定的信息。
- en: We concluded this chapter by learning how to use a host's devices as if they
    were attached directly to containers.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后，我们学习了如何将主机的设备作为直接附加到容器的设备来使用。
- en: In the next chapter, we will look at container persistency and their networking
    features.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论容器的持久性和它们的网络功能。
- en: Questions
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following options is not available for containers?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项不适用于容器？
- en: a) `build` b) `update` c) `destroy` d) `create`
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: a) `build` b) `update` c) `destroy` d) `create`
- en: Which of the following sentences is false?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个句子是错误的？
- en: a) A container's life is managed using `start` and `stop` commands
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: a) 容器的生命周期通过`start`和`stop`命令来管理
- en: b) Containers always stop after 10 seconds
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: b) 容器总是在10秒后停止
- en: c) Containers can be created and then started
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: c) 容器可以先创建然后启动
- en: d) Volumes created during the container's lifetime must be deleted by hand unless
    we use the `-v` option when deleting the container
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: d) 容器生命周期内创建的卷必须手动删除，除非我们在删除容器时使用`-v`选项
- en: Which of the following sentences is true in relation to `docker kill`?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个句子是关于`docker kill`的正确描述？
- en: a) It will kill all container processes
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: a) 它会杀死所有容器进程
- en: b) It will send a `SIGKILL` signal to the container's main process
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: b) 它会向容器的主进程发送一个`SIGKILL`信号
- en: c) It will remove the container once it is killed
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: c) 它会在容器被杀死后移除容器
- en: d) It will wait 10 seconds by default before really killing the container
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: d) 它默认会等待10秒钟再真正杀死容器
- en: We executed a container named `webserver`. Which of the following sentences
    is false?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行了一个名为`webserver`的容器。以下哪一句是错误的？
- en: a) It can be removed using `docker container rm --force` b) We can update its
    image using `docker container update` c) We can rename the `webserver` container
    to `websrv` using `docker container rename` d) We can view the container's output
    using `docker container logs`
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: a) 可以使用`docker container rm --force`删除它。 b) 我们可以使用`docker container update`更新它的镜像。
    c) 我们可以使用`docker container rename`将`webserver`容器重命名为`websrv`。 d) 我们可以使用`docker
    container logs`查看容器的输出。
- en: We have executed the `docker container run --name app1 --user 1000 --memory
    100m --privileged alpine touch /testfile` command. Which of the following sentences
    are true?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行了`docker container run --name app1 --user 1000 --memory 100m --privileged
    alpine touch /testfile`命令。以下哪一句是正确的？
- en: a) `/testfile` was created as root because the container was executed with all
    capabilities.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: a) `/testfile`作为root用户创建，因为容器执行时具备所有权限。
- en: b) The container will not be able to consume more than 100 m of host memory.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: b) 容器无法使用超过100m的主机内存。
- en: c) `/testfile` was not created because we used a user with an ID of `1000` and
    it will not be able to write on `/`, the root directory.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: c) `/testfile`没有创建，因为我们使用了ID为`1000`的用户，并且该用户无法在根目录(`/`)写入。
- en: d) We used `--privileged`. This option will disable all root capabilities inside
    the container and, as a result, the file can't be created.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: d) 我们使用了`--privileged`选项。这个选项将禁用容器内所有的root权限，因此无法创建文件。
- en: Further reading
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Refer to the following links to find out more about the topics that were covered
    in this chapter:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解本章涉及的主题：
- en: 'Docker command-line reference: [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker命令行参考：[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)
- en: 'Memory limits behavior: [https://medium.com/faun/understanding-docker-container-memory-limit-behavior-41add155236c](https://medium.com/faun/understanding-docker-container-memory-limit-behavior-41add155236c)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存限制行为：[https://medium.com/faun/understanding-docker-container-memory-limit-behavior-41add155236c](https://medium.com/faun/understanding-docker-container-memory-limit-behavior-41add155236c)
