- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Using Single-Host Networking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单主机网络
- en: In the previous chapter, we learned about the most important architectural patterns
    and best practices that are used when dealing with distributed application architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了分布式应用架构中使用的最重要的架构模式和最佳实践。
- en: In this chapter, we will introduce the Docker container networking model and
    its single-host implementation in the form of the bridge network. This chapter
    also introduces the concept of **Software Defined Networks** (**SDNs**) and how
    they are used to secure containerized applications. Furthermore, we will demonstrate
    how container ports can be opened to the public and thus make containerized components
    accessible to the outside world. Finally, we will introduce Traefik, a reverse
    proxy, which can be used to enable sophisticated HTTP application-level routing
    between containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Docker 容器网络模型及其在桥接网络中的单主机实现。本章还介绍了**软件定义网络**（**SDN**）的概念，以及它们如何用于保护容器化的应用程序。此外，我们将演示如何将容器端口公开，从而使容器化的组件可以被外界访问。最后，我们将介绍
    Traefik，一个反向代理，它可以用来在容器之间启用复杂的 HTTP 应用层路由。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Dissecting the container network model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解剖容器网络模型
- en: Network firewalling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络防火墙
- en: Working with the bridge network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用桥接网络
- en: The host and null network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机和空网络
- en: Running in an existing network namespace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有网络命名空间中运行
- en: Managing container ports
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器端口
- en: HTTP-level routing using a reverse proxy
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向代理进行 HTTP 层路由
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够完成以下任务：
- en: Create, inspect, and delete a custom bridge network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、检查和删除自定义桥接网络
- en: Run a container attached to a custom bridge network
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个附加到自定义桥接网络的容器
- en: Isolate containers from each other by running them on different bridge networks
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将容器运行在不同的桥接网络上来隔离容器
- en: Publish a container port to a host port of your choice
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器端口发布到你选择的主机端口
- en: Add Traefik as a reverse proxy to enable application-level routing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Traefik 作为反向代理以启用应用层路由
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, the only thing you will need is a Docker host that is able
    to run Linux containers. You can use your laptop with Docker Desktop for this
    purpose.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你所需的唯一条件是一个能够运行 Linux 容器的 Docker 主机。你可以使用安装了 Docker Desktop 的笔记本电脑来完成这个任务。
- en: 'To start with, let’s first create a folder for this chapter where we are going
    to store the code for our examples:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个用于本章的文件夹，在其中存储我们示例的代码：
- en: 'Navigate to the folder where you have cloned the repository accompanying this
    book. Usually, this is the following:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你克隆本书所附仓库的文件夹。通常，这是以下路径：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a subfolder for this chapter and navigate to it:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于本章的子文件夹并导航到它：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s get started!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Dissecting the container network model
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖容器网络模型
- en: 'So far, we have mostly worked with single containers, but in reality, a containerized
    business application consists of several containers that need to collaborate to
    achieve a goal. Therefore, we need a way for individual containers to communicate
    with each other. This is achieved by establishing pathways, which we can use to
    send data packets back and forth between containers. These pathways are called
    networks. Docker has defined a very simple networking model, the so-called **container
    network model** (**CNM**), to specify the requirements that any software that
    implements a container network has to fulfill. The following is a graphical representation
    of the CNM:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要处理的是单个容器，但实际上，一个容器化的业务应用程序由多个容器组成，这些容器需要协同工作以实现目标。因此，我们需要一种方式使得各个容器之间能够通信。这是通过建立路径来实现的，我们可以利用这些路径在容器之间来回发送数据包。这些路径被称为网络。Docker
    定义了一个非常简单的网络模型，即所谓的**容器网络模型**（**CNM**），以指定任何实现容器网络的软件必须满足的要求。以下是 CNM 的图形表示：
- en: '![Figure 10.1 – The Docker CNM](img/B19199_10_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – Docker CNM](img/B19199_10_01.jpg)'
- en: Figure 10.1 – The Docker CNM
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Docker CNM
- en: 'The CNM has three elements – sandboxes, endpoints, and networks:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CNM 有三个元素——沙箱、端点和网络：
- en: '**Network Sandboxes**: The sandbox perfectly isolates a container from the
    outside world. No inbound network connection is allowed into the sandboxed container,
    but it is very unlikely that a container will be of any value in a system if absolutely
    no communication with it is possible. To work around this, we have element number
    two, which is the endpoint.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络沙箱**：沙箱完全隔离容器与外界的连接。沙箱容器不允许任何外部网络连接进入，但如果容器与外界完全没有任何通信，它在系统中几乎没有任何价值。为了弥补这一点，我们引入了第二个元素，即端点。'
- en: '**Endpoint**: An endpoint is a controlled gateway from the outside world into
    the network’s sandbox, which shields the container. The endpoint connects the
    network sandbox (but not the container) to the third element of the model, which
    is the network.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点**：端点是从外部世界到网络沙箱的受控网关，沙箱用来保护容器。端点将网络沙箱（而不是容器）连接到模型的第三个元素——网络。'
- en: '**Network**: The network is the pathway that transports the data packets of
    an instance of communication from endpoint to endpoint or, ultimately, from container
    to container.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：网络是传输通信实例数据包的路径，从端点到端点，或者最终从容器到容器。'
- en: It is important to note that a network sandbox can have zero to many endpoints,
    or, said differently, each container living in a network sandbox can either be
    attached to no network at all or it can be attached to multiple different networks
    at the same time. In the preceding diagram, the middle one of the three **Network
    Sandboxes** is attached to both **Network 1** and **Network 2** using an endpoint.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，一个网络沙箱可以有零个到多个端点，换句话说，每个位于网络沙箱中的容器可以没有连接到任何网络，或者可以同时连接到多个不同的网络。在上面的示意图中，三个**网络沙箱**中的中间一个通过端点同时连接到**网络1**和**网络2**。
- en: This networking model is very generic and does not specify where the individual
    containers that communicate with each other over a network run. All containers
    could, for example, run on the same host (local) or they could be distributed
    across a cluster of hosts (global).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种网络模型非常通用，并没有指定通过网络进行通信的各个容器运行的位置。例如，所有容器可以运行在同一主机上（本地），也可以分布在多个主机的集群中（全球）。
- en: 'Of course, the CNM is just a model describing how networking works among containers.
    To be able to use networking with our containers, we need real implementations
    of the CNM. For both local and global scopes, we have multiple implementations
    of the CNM. In the following table, we’ve given a short overview of the existing
    implementations and their main characteristics. The list is in no particular order:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CNM 仅仅是一个描述容器之间如何实现网络连接的模型。为了能够在容器中使用网络，我们需要 CNM 的实际实现。对于本地和全球范围，我们有多种 CNM
    实现。在下表中，我们简要概述了现有实现及其主要特性。列表没有特定顺序：
- en: '| **Network** | **Company** | **Scope** | **Description** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **网络** | **公司** | **范围** | **描述** |'
- en: '| Bridge | Docker | Local | Simple network based on Linux bridges to allow
    networking on a single host |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Bridge | Docker | 本地 | 基于 Linux 桥接的简单网络，允许在单一主机上进行网络连接 |'
- en: '| Macvlan | Docker | Local | Configures multiple layer-2 (that is, MAC) addresses
    on a single physical host interface |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Macvlan | Docker | 本地 | 在单一物理主机接口上配置多个二层（即 MAC）地址 |'
- en: '| Overlay | Docker | Global | Multi-node capable container network based on
    **Virtual Extensible** **LAN** (**VXLan**) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Overlay | Docker | 全球 | 基于**虚拟可扩展** **局域网**（**VXLan**）的多节点容器网络 |'
- en: '| Weave Net | Weaveworks | Global | Simple, resilient, multi-host Docker networking
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Weave Net | Weaveworks | 全球 | 简单、弹性、支持多主机的 Docker 网络 |'
- en: '| Contiv Network Plugin | Cisco | Global | Open source container networking
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Contiv 网络插件 | Cisco | 全球 | 开源容器网络 |'
- en: Table 10.1 – Network types
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 – 网络类型
- en: All network types not directly provided by Docker can be added to a Docker host
    as a plugin.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Docker 未直接提供的网络类型都可以作为插件添加到 Docker 主机中。
- en: In the next section, we will describe how network firewalling works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述网络防火墙的工作原理。
- en: Network firewalling
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络防火墙
- en: Docker has always had the mantra of security first. This philosophy had a direct
    influence on how networking in a single- and multi-host Docker environment was
    designed and implemented. SDNs are easy and cheap to create, yet they perfectly
    firewall containers that are attached to this network from other non-attached
    containers, and from the outside world. All containers that belong to the same
    network can freely communicate with each other, while others have no means to
    do so.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 一直秉持着“安全第一”的原则。这个理念直接影响了单主机和多主机 Docker 环境中网络的设计与实现。SDN（软件定义网络）既容易且便宜创建，又能够完美地将连接到此网络的容器与其他未连接的容器，以及外部世界隔离开来。所有属于同一网络的容器可以自由地相互通信，而其他容器则无法做到这一点。
- en: 'In the following diagram, we have two networks called **front** and **back**.
    Attached to the **front** network, we have containers **c1** and **c2**, and attached
    to the **back** network, we have containers **c3** and **c4**. **c1** and **c2**
    can freely communicate with each other, as can **c3** and **c4**, but **c1** and
    **c2** have no way to communicate with either **c3** or **c4**, and vice versa:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们有两个网络，分别名为 **front** 和 **back**。容器 **c1** 和 **c2** 附加到 **front** 网络，容器
    **c3** 和 **c4** 附加到 **back** 网络。**c1** 和 **c2** 可以自由地相互通信，**c3** 和 **c4** 也可以自由通信，但
    **c1** 和 **c2** 无法与 **c3** 或 **c4** 进行通信，反之亦然：
- en: '![Figure 10.2 – Docker networks](img/B19199_10_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – Docker 网络](img/B19199_10_02.jpg)'
- en: Figure 10.2 – Docker networks
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Docker 网络
- en: 'Now, what about a situation in which we have an application consisting of three
    services: `webAPI`, `productCatalog`, and `database`? We want `webAPI` to be able
    to communicate with `productCatalog`, but not with the database, and we want `productCatalog`
    to be able to communicate with the database service. We can solve this situation
    by placing `webAPI` and the database on different networks and attaching `productCatalog`
    to both of these networks, as shown in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们有一个由三个服务组成的应用程序：`webAPI`、`productCatalog` 和 `database`，该怎么办呢？我们希望`webAPI`能够与`productCatalog`进行通信，但不能与数据库通信，同时我们希望`productCatalog`能够与数据库服务进行通信。我们可以通过将`webAPI`和数据库放在不同的网络上，并将`productCatalog`连接到这两个网络来解决这个问题，如下图所示：
- en: '![Figure 10.3 – Container attached to multiple networks](img/B19199_10_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 容器连接到多个网络](img/B19199_10_03.jpg)'
- en: Figure 10.3 – Container attached to multiple networks
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 容器连接到多个网络
- en: Since creating SDNs is cheap, and each network provides added security by isolating
    resources from unauthorized access, it is highly recommended that you design and
    run applications so that they use multiple networks and only run services on the
    same network that absolutely need to communicate with each other. In the preceding
    example, there is absolutely no need for the `webAPI` component to ever communicate
    directly with the `database` service, so we have put them on different networks.
    If the worst-case scenario happens and a hacker compromises `webAPI`, they won't
    be able to access the database from there without also hacking the `productCatalog`
    service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建 SDN 很便宜，而且每个网络通过隔离资源以防止未授权访问提供了额外的安全性，强烈建议您设计并运行应用程序，使其使用多个网络，并且仅在绝对需要相互通信的服务才在同一网络上运行。在前面的例子中，`webAPI`
    组件完全不需要与 `database` 服务直接通信，因此我们将它们放在了不同的网络上。如果最坏的情况发生，黑客侵入了 `webAPI`，他们也无法通过它访问数据库，除非黑客同时攻破了
    `productCatalog` 服务。
- en: Now we are ready to discuss the first implementation of the CNM, the bridge
    network.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以讨论 CNM（容器网络模型）的第一个实现——桥接网络。
- en: Working with the bridge network
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用桥接网络
- en: The Docker bridge network is the first implementation of the CNM that we’re
    going to look at in detail. This network implementation is based on the Linux
    bridge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 桥接网络是我们将详细探讨的 CNM 的第一个实现。这个网络实现基于 Linux 桥接。
- en: When the Docker daemon runs for the first time, it creates a Linux bridge and
    calls it `docker0`. This is the default behavior and can be changed by changing
    the configuration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker 守护进程第一次运行时，它会创建一个 Linux 桥接并将其命名为 `docker0`。这是默认行为，可以通过更改配置来进行修改。
- en: Docker then creates a network with this Linux bridge and calls it the network
    bridge. All the containers that we create on a Docker host and that we do not
    explicitly bind to another network lead to Docker automatically attaching the
    containers to this bridge network.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Docker 使用这个 Linux 桥接创建一个网络，并将其称为网络桥接。我们在 Docker 主机上创建的所有容器，如果没有显式绑定到其他网络，都会导致
    Docker 自动将这些容器附加到该桥接网络上。
- en: 'To verify that we indeed have a network called `bridge` of the `bridge` type
    defined on our host, we can list all the networks on the host with the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们确实在主机上定义了一个名为`bridge`的桥接类型网络，我们可以使用以下命令列出主机上的所有网络：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should provide an output similar to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应提供类似以下的输出：
- en: '![Figure 10.4 – Listing all the Docker networks available by default](img/B19199_10_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 列出默认情况下所有可用的 Docker 网络](img/B19199_10_04.jpg)'
- en: Figure 10.4 – Listing all the Docker networks available by default
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 列出默认情况下所有可用的 Docker 网络
- en: In your case, the IDs will be different, but the rest of the output should look
    the same. We do indeed have a first network called `bridge` using the `bridge`
    driver. The scope being `local` just means that this type of network is restricted
    to a single host and cannot span across multiple hosts. In [*Chapter 14*](B19199_14.xhtml#_idTextAnchor303),
    *Introducing* *Docker Swarm*, we will also discuss other types of networks that
    have a global scope, meaning they can span whole clusters of hosts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，ID 会不同，但其余的输出应保持一致。我们确实有一个名为`bridge`的第一个网络，使用的是`bridge`驱动程序。`local`范围意味着该类型的网络仅限于单个主机，不能跨多个主机。在[*第
    14 章*](B19199_14.xhtml#_idTextAnchor303)，*介绍* *Docker Swarm*中，我们还将讨论其他具有全局范围的网络类型，意味着它们可以跨多个主机群集。
- en: 'Now, let’s look a little bit deeper into what this bridge network is all about.
    For this, we are going to use the Docker `inspect` command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解这个桥接网络的具体内容。为此，我们将使用 Docker 的`inspect`命令：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When executed, this outputs a big chunk of detailed information about the network
    in question. This information should look as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，这将输出关于相关网络的大量详细信息。这些信息应如下所示：
- en: '![Figure 10.5 – Output generated when inspecting the Docker bridge network](img/B19199_10_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 检查 Docker 桥接网络时生成的输出](img/B19199_10_05.jpg)'
- en: Figure 10.5 – Output generated when inspecting the Docker bridge network
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 检查 Docker 桥接网络时生成的输出
- en: We saw the `ID`, `Name`, `Driver`, and `Scope` values when we listed all the
    networks, so that is nothing new, but let’s have a look at the **IP address management**
    (**IPAM**) block.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列出所有网络时看到了`ID`、`Name`、`Driver`和`Scope`值，所以这并不新鲜，但让我们来看一下**IP 地址管理**（**IPAM**）块。
- en: 'IPAM is a piece of software that is used to track the IP addresses that are
    used on a computer. The important part of the IPAM block is the *config* node
    with its values for the subnet and gateway. The subnet for the bridge network
    is defined by default as `172.17.0.0/16`. This means that all containers attached
    to this network will get an IP address assigned by Docker that is taken from the
    given range, which is `172.17.0.2` to `172.17.255.255`. The `172.17.0.1` address
    is reserved for the router of this network whose role in this type of network
    is taken by the Linux bridge. We can expect that the very first container that
    will be attached to this network by Docker will get the `172.17.0.2` address.
    All subsequent containers will get a higher number; the following diagram illustrates
    this fact:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: IPAM 是一款用于跟踪计算机上使用的 IP 地址的软件。IPAM 块中的重要部分是带有子网和网关值的*config*节点。桥接网络的子网默认定义为`172.17.0.0/16`。这意味着所有连接到此网络的容器将获得由
    Docker 分配的 IP 地址，该地址来自给定的范围，即 `172.17.0.2` 至 `172.17.255.255`。`172.17.0.1` 地址保留给该网络的路由器，在这种网络类型中，路由器由
    Linux 桥接担当。我们可以预期，Docker 首次将附加到该网络的容器将获得`172.17.0.2`地址。所有后续容器将获得更高的编号；下图说明了这一点：
- en: '![Figure 10.6 – The bridge network](img/B19199_10_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 桥接网络](img/B19199_10_06.jpg)'
- en: Figure 10.6 – The bridge network
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 桥接网络
- en: In the preceding diagram, we can see the network namespace of the host, which
    includes the host’s `eth0` endpoint, which is typically an NIC if the Docker host
    runs on bare metal or a virtual NIC if the Docker host is a VM. All traffic to
    the host comes through `eth0`. The Linux bridge is responsible for routing the
    network traffic between the host’s network and the subnet of the bridge network.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到主机的网络命名空间，其中包括主机的`eth0`端点，如果 Docker 主机运行在裸机上，它通常是一个 NIC；如果 Docker
    主机是虚拟机，它通常是一个虚拟 NIC。所有到主机的流量都通过`eth0`。Linux 桥接负责在主机的网络和桥接网络的子网之间路由网络流量。
- en: What is a NIC?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 NIC？
- en: A **Network Interface Card** (**NIC**), sometimes referred to as a network interface
    connector, is a hardware component that enables a computer or device to connect
    to a network. It serves as an interface between the computer and the network,
    allowing data to be transmitted and received. NICs are typically built-in components
    on motherboards or installed as expansion cards and support various types of network
    connections, such as Ethernet, Wi-Fi, or fiber-optic connections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络接口卡**（**NIC**），有时也被称为网络接口连接器，是一种硬件组件，允许计算机或设备连接到网络。它作为计算机与网络之间的接口，允许数据的传输和接收。NIC
    通常是主板上的内置组件，或者作为扩展卡安装，并支持各种类型的网络连接，例如以太网、Wi-Fi 或光纤连接。'
- en: 'By default, only egress traffic is allowed, and all ingress is blocked. What
    this means is that while containerized applications can reach the internet, they
    cannot be reached by any outside traffic. Each container attached to the network
    gets its own **virtual ethernet** (**veth**) connection to the bridge. This is
    illustrated in the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有出口流量被允许，所有入口流量都会被阻止。这意味着，虽然容器化应用程序可以访问互联网，但它们不能被任何外部流量访问。每个连接到网络的容器都获得自己的**虚拟以太网**（**veth**）连接到桥接网络。下图对此进行了说明：
- en: '![Figure 10.7 – Details of the bridge network](img/B19199_10_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 桥接网络的详细信息](img/B19199_10_07.jpg)'
- en: Figure 10.7 – Details of the bridge network
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 桥接网络的详细信息
- en: 'The preceding diagram shows us the world from the perspective of the host.
    We will explore what this situation looks like from within a container later on
    in this section. We are not limited to just the bridge network, as Docker allows
    us to define our own custom bridge networks. This is not just a feature that is
    nice to have; it is a recommended best practice not to run all containers on the
    same network. Instead, we should use additional bridge networks to further isolate
    containers that have no need to communicate with each other. To create a custom
    bridge network called `sample-net`, use the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示从主机的角度展示了整个情况。我们稍后将在本节中探索从容器内部看到的情况。我们不仅限于使用桥接网络，因为 Docker 允许我们定义自己的自定义桥接网络。这不仅是一个“有用的功能”，它也是一种推荐的最佳实践——不要将所有容器都运行在同一个网络上。相反，我们应使用额外的桥接网络，进一步隔离那些不需要相互通信的容器。要创建一个名为
    `sample-net` 的自定义桥接网络，请使用以下命令：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we do this, we can then inspect what subnet Docker has created for this
    new custom network, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，就可以查看 Docker 为这个新的自定义网络创建了什么子网，如下所示：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This returns the following value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下值：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Evidently, Docker has just assigned the next free block of IP addresses to
    our new custom bridge network. If, for some reason, we want to specify our own
    subnet range when creating a network, we can do so by using the `--``subnet` parameter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Docker 刚刚为我们的新自定义桥接网络分配了下一个空闲的 IP 地址块。如果由于某些原因，我们希望在创建网络时指定自己的子网范围，可以通过使用
    `--subnet` 参数来实现：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid conflicts due to duplicate IP addresses, make sure you avoid creating
    networks with overlapping subnets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免因重复的 IP 地址而发生冲突，请确保避免创建具有重叠子网的网络。
- en: Now that we have discussed what a bridge network is and how we can create a
    custom bridge network, we want to understand how we can attach containers to these
    networks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了桥接网络是什么，以及如何创建自定义桥接网络，我们接下来要了解的是如何将容器连接到这些网络。
- en: 'First, let’s interactively run an Alpine container without specifying the network
    to be attached:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们互动地运行一个 Alpine 容器，但不指定要连接的网络：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In another Terminal window, let’s inspect the `c1` container:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，让我们检查 `c1` 容器：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the vast output, let’s concentrate for a moment on the part that provides
    network-related information. This can be found under the `NetworkSettings` node.
    I have it listed in the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量输出中，让我们暂时集中关注提供网络相关信息的部分。这可以在`NetworkSettings`节点下找到。我在以下输出中列出了它：
- en: '![Figure 10.8 – The NetworkSettings section of the container metadata](img/B19199_10_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 容器元数据中的 NetworkSettings 部分](img/B19199_10_08.jpg)'
- en: Figure 10.8 – The NetworkSettings section of the container metadata
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 容器元数据中的 NetworkSettings 部分
- en: In the preceding output, we can see that the container is indeed attached to
    the bridge network since `NetworkID` is equal to `d172692...`, which we can see
    from the preceding code being the ID of the bridge network. We can also see that
    the container was assigned the IP address of `172.17.0.2` as expected and that
    the gateway is at `172.17.0.1`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到容器确实已连接到桥接网络，因为`NetworkID`等于`d172692...`，我们可以从前面的代码中看到它是桥接网络的ID。我们还可以看到容器被分配了预期的
    IP 地址`172.17.0.2`，并且网关位于`172.17.0.1`。
- en: Please note that the container also had a `MacAddress` associated with it. This
    is important as the Linux bridge uses the `MacAddress` for routing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，容器也有一个与之关联的`MacAddress`。这一点很重要，因为 Linux 桥接会使用`MacAddress`来进行路由。
- en: 'So far, we have approached this from the outside of the container’s network
    namespace. Now, let’s see what the situation looks like when we’re not only inside
    the container but inside the container’s network namespace. Inside the `c1` container,
    let’s use the `ip` tool to inspect what’s going on. Run the `ip addr` command
    and observe the output that is generated, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们是从容器网络命名空间之外的角度来处理的。现在，让我们看看当我们不仅在容器内部，而且在容器的网络命名空间内部时，情况会是什么样的。在`c1`容器内，我们使用`ip`工具检查正在发生的事情。运行`ip
    addr`命令并观察生成的输出，如下所示：
- en: '![Figure 10.9 – Container namespace, as seen by the IP tool](img/B19199_10_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 容器命名空间，IP 工具视图](img/B19199_10_09.jpg)'
- en: Figure 10.9 – Container namespace, as seen by the IP tool
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 容器命名空间，IP 工具视图
- en: The interesting part of the preceding output is `54:`, that is, the `eth0` endpoint.
    The `veth0` endpoint that the Linux bridge created outside of the container namespace
    is mapped to `eth0` inside the container. Docker always maps the first endpoint
    of a container network namespace to `eth0`, as seen from inside the namespace.
    If the network namespace is attached to an additional network, then that endpoint
    will be mapped to `eth1`, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出中有趣的部分是`54:`，即`eth0`端点。Linux 桥接在容器命名空间外部创建的`veth0`端点映射到容器内部的`eth0`。Docker
    总是将容器网络命名空间的第一个端点映射为`eth0`，从命名空间内部来看。如果网络命名空间附加到其他网络，那么该端点将映射为`eth1`，依此类推。
- en: 'Since at this point, we’re not really interested in any endpoint other than
    `eth0`, we could have used a more specific variant of the command, which would
    have given us the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时我们并不关心除了`eth0`之外的任何端点，我们可以使用该命令的更具体版本，这样会得到以下输出：
- en: '![Figure 10.10 – eth0 endpoint as seen from inside of the container](img/B19199_10_10.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 从容器内部看到的 eth0 端点](img/B19199_10_10.jpg)'
- en: Figure 10.10 – eth0 endpoint as seen from inside of the container
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 从容器内部看到的 eth0 端点
- en: In the output, we can also see what MAC address (`02:42:ac:11:00:02`) and what
    IP (`172.17.0.2`) have been associated with this container network namespace by
    Docker.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们还可以看到此容器网络命名空间由 Docker 分配的 MAC 地址（`02:42:ac:11:00:02`）和 IP 地址（`172.17.0.2`）。
- en: 'We can also get some information about how requests are routed by using the
    `ip` `route` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ip` `route`命令获取一些关于请求如何路由的信息：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This gives us the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给我们以下输出：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This output tells us that all the traffic to the gateway at `172.17.0.1` is
    routed through the `eth0` device.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们，所有到达`172.17.0.1`网关的流量都通过`eth0`设备进行路由。
- en: 'Now, let’s run another container called `c2` on the same network and in `detach`
    mode:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一网络上以`detach`模式运行另一个名为`c2`的容器：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `c2` container will also be attached to the bridge network since we have
    not specified any other network. Its IP address will be the next free one within
    the subnet, which is `172.17.0.3`, as we can readily test with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`c2`容器也会被附加到桥接网络上，因为我们没有指定其他网络。它的 IP 地址将是子网中的下一个空闲地址，即`172.17.0.3`，我们可以通过以下命令轻松测试：'
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we have two containers attached to the bridge network. We can try to inspect
    this network once again to find a list of all containers attached to it in the
    output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个容器连接到桥接网络。我们可以再次尝试检查这个网络，在输出中找到所有连接到它的容器列表：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This information can be found under the `Containers` node:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息可以在`Containers`节点下找到：
- en: '![Figure 10.11 – The Containers section of the output of the Docker network
    inspect bridge](img/B19199_10_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – Docker 网络桥接检查输出中的容器部分](img/B19199_10_11.jpg)'
- en: Figure 10.11 – The Containers section of the output of the Docker network inspect
    bridge
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – Docker网络检查`bridge`网络输出中的容器部分
- en: Once again, we have shortened the output to the relevant part for readability.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们已经缩短了输出，只保留相关部分以便于阅读。
- en: 'Now, let’s create two additional containers, `c3` and `c4`, and attach them
    to `sample-net`, which we created earlier. For this, we’ll use the `--``network`
    parameter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个额外的容器`c3`和`c4`，并将它们附加到我们之前创建的`sample-net`网络。为此，我们将使用`--network`参数：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s inspect the `sample-net` network and confirm that `c3` and `c4` are indeed
    attached to it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下`sample-net`网络，并确认`c3`和`c4`确实已连接到该网络：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will give us the following output for the `Containers` section:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下的`Containers`部分输出：
- en: '![Figure 10.12 – The Containers section of the Docker network inspect test-net
    command](img/B19199_10_12.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – Docker网络检查`test-net`命令输出中的容器部分](img/B19199_10_12.jpg)'
- en: Figure 10.12 – The Containers section of the Docker network inspect test-net
    command
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – Docker网络检查`test-net`命令输出中的容器部分
- en: 'The next question we’re going to ask ourselves is whether the `c3` and `c4`
    containers can freely communicate with each other. To demonstrate that this is
    indeed the case, we can `exec` into the `c3` container:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要问自己一个问题，即`c3`和`c4`容器是否可以自由地相互通信。为了证明这一点，我们可以通过`exec`进入`c3`容器：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once inside the container, we can try to `ping` container `c4` by name and
    by IP address:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，我们可以尝试通过名称和IP地址`ping`容器`c4`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We should get this output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到这个输出：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instead of the container name, here, we use `c4`’s IP address:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是`c4`的IP地址，而不是容器的名称：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should see the following result:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到以下结果：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The answer in both cases confirms to us that the communication between containers
    attached to the same network is working as expected. The fact that we can even
    use the name of the container we want to connect to shows us that the name resolution
    provided by the Docker DNS service works inside this network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，答案都证实了同一网络上附加的容器之间的通信正常。我们甚至可以使用想要连接的容器的名称，这表明Docker的DNS服务在该网络中起作用。
- en: 'Now, we want to make sure that the `bridge` and `sample-net` networks are firewalled
    from each other. To demonstrate this, we can try to `ping` the `c2` container
    from the `c3` container, either by its name or by its IP address. Let’s start
    with pinging by name:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望确保`bridge`网络和`sample-net`网络是相互隔离的。为了证明这一点，我们可以尝试从`c3`容器`ping` `c2`容器，可以通过名称或IP地址。让我们从按名称ping开始：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the result of the ping using the IP address of the `c2` container
    instead:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`c2`容器的IP地址进行ping测试的结果：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It gives us this output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它给了我们以下输出：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding command remained hanging and I had to terminate the command with
    *Ctrl* + *C*. From the output of pinging `c2`, we can also see that the name resolution
    does not work across networks. This is the expected behavior. Networks provide
    an extra layer of isolation, and thus security, to containers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令一直处于挂起状态，我不得不用*Ctrl* + *C*终止命令。从ping`c2`的输出中，我们还可以看到，跨网络的名称解析并不工作。这是预期的行为。网络为容器提供了额外的隔离层，从而增强了安全性。
- en: 'Earlier, we learned that a container can be attached to multiple networks.
    Let’s first create a network called `test-net`. Note that the following command
    does not define the driver of the network; thus, the default driver is used, which
    happens to be the bridge driver:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们学习了，容器可以附加到多个网络。让我们首先创建一个名为`test-net`的网络。请注意，以下命令没有定义网络的驱动程序；因此，使用的是默认驱动程序，恰好是bridge驱动程序：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we attach a container, `c5`, to our `sample-net` network:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`c5`容器附加到`sample-net`网络：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we attach the `c6` container to the `sample-net` and `test-net` networks
    at the same time:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`c6`容器同时附加到`sample-net`和`test-net`网络：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we can test that `c6` is reachable from the `c5` container attached to
    the `test-net` network, as well as from the `c3` container attached to the `sample-net`
    network. The result will show that the connection indeed works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试`c5`容器（附加在`test-net`网络上）是否能够从中访问`c6`，以及`sample-net`网络上附加的`c3`容器是否能够访问`c6`。结果将表明连接确实有效。
- en: 'If we want to remove an existing network, we can use the `docker network rm`
    command, but note that we cannot accidentally delete a network that has containers
    attached to it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除一个现有的网络，可以使用`docker network rm`命令，但请注意，不能意外删除已经附加了容器的网络：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It results in this output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这个输出：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before we continue, let’s clean up and remove all the containers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们清理并删除所有容器：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can remove the two custom networks that we created:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除我们创建的两个自定义网络：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, we could remove all the networks that no container is attached
    to with the `prune` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `prune` 命令删除所有没有容器连接的网络：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I used the `--force` (or `-f`) argument here to prevent Docker from reconfirming
    that I really want to remove all unused networks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了 `--force`（或 `-f`）参数，以防止 Docker 再次确认我是否确实要删除所有未使用的网络。
- en: Double-check with the `docker network ls` command that you are only left with
    the three default networks provided by Docker.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker network ls` 命令再次确认，只剩下 Docker 提供的三个默认网络。
- en: The next network types we are going to inspect a bit are the `host` and `null`
    network types.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要检查的网络类型是 `host` 和 `null` 网络类型。
- en: The host and null networks
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机网络和空网络
- en: In this section, we are going to look at two predefined and somewhat unique
    types of networks, the host and the null networks. Let’s start with the former.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两种预定义的、稍微独特的网络类型：主机网络和空网络。我们先从前者开始。
- en: The host network
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机网络
- en: There are occasions when we want to run a container in the network namespace
    of the host. This may be necessary when we need to run some software in a container
    that is used to analyze or debug the host network's traffic, but keep in mind
    that these are very specific scenarios. When running business software in containers,
    there is no good reason to ever run the respective containers attached to the
    host’s network. For security reasons, it is strongly recommended that you do not
    run any such container attached to the host network in a production or production-like
    environment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在主机的网络命名空间中运行容器。这在需要在容器中运行用于分析或调试主机网络流量的软件时可能是必要的，但请记住，这些情况是非常特定的。在容器中运行业务软件时，通常没有理由将容器连接到主机的网络。出于安全考虑，强烈建议你不要在生产或类似生产的环境中将任何容器连接到主机网络。
- en: 'That said, how can we run a container inside the network namespace of the host?
    Simply by attaching the container to the `host` network:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们如何在主机的网络命名空间中运行容器呢？只需将容器附加到 `host` 网络即可：
- en: 'Run an Alpine container and attach it to the `host` network:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个 Alpine 容器，并将其连接到 `host` 网络：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the `ip` tool to analyze the network namespace from within the container.
    You will see that we get exactly the same picture as we would if we were running
    the `ip` tool directly on the host. For example, I inspect the `eth0` device on
    my laptop with the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ip` 工具从容器内部分析网络命名空间。你会发现，我们得到的结果和在主机上直接运行 `ip` 工具时完全一样。例如，我用以下命令检查了我的笔记本电脑上的
    `eth0` 设备：
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As a result, I get this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我得到了这个：
- en: '![Figure 10.13 – Showing the eth0 device from inside a container](img/B19199_10_13.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 从容器内部查看 eth0 设备](img/B19199_10_13.jpg)'
- en: Figure 10.13 – Showing the eth0 device from inside a container
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 从容器内部查看 eth0 设备
- en: Here, I can see that `192.168.65.3` is the IP address that the host has been
    assigned and that the MAC address shown here also corresponds to that of the host.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以看到 `192.168.65.3` 是主机分配的 IP 地址，显示的 MAC 地址也对应于主机的地址。
- en: 'We can also inspect the routes:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以检查路由：
- en: '[PRE37]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On my MacBook Air M1, this is what I get:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 MacBook Air M1 上，我得到的是：
- en: '![Figure 10.14 – Routes from within a container](img/B19199_10_14.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 从容器内部查看的路由](img/B19199_10_14.jpg)'
- en: Figure 10.14 – Routes from within a container
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 从容器内部查看的路由
- en: 'Before we move on to the next section of this chapter, I want to once again
    point out that running a container on the host network can be dangerous due to
    potential security vulnerabilities and conflicts:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本章的下一部分之前，我再次强调，因潜在的安全漏洞和冲突，将容器运行在主机网络上可能是危险的：
- en: '**Security risks**: By using the host network, the container has the same network
    access as the host machine. This means that if an application running within the
    container has a vulnerability that is exploited, the attacker could gain access
    to the host network and potentially compromise other services or data.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全风险**：通过使用主机网络，容器拥有与主机相同的网络访问权限。这意味着，如果容器内运行的应用程序存在漏洞并被利用，攻击者可能会获得对主机网络的访问权限，进而危及其他服务或数据。'
- en: '**Port conflicts**: When a container uses the host network, it shares the same
    network namespace as the host. This means that if your containerized application
    and a host application listen on the same port, there can be conflicts.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口冲突**：当容器使用主机网络时，它与主机共享相同的网络命名空间。这意味着，如果你的容器化应用程序和主机上的应用程序在同一端口上监听，就会发生冲突。'
- en: '**Isolation**: One of the major benefits of using Docker is the isolation it
    provides at various levels (process, filesystem, or network). By using the host
    network, you lose this level of isolation, which could lead to unforeseen issues.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：使用 Docker 的主要好处之一是它在各个层面（进程、文件系统或网络）提供的隔离性。通过使用主机网络，你会失去这一层隔离，这可能会导致一些不可预见的问题。'
- en: Therefore, it’s generally recommended to use a user-defined network instead
    of the host network when running Docker containers, as it provides better isolation
    and reduces the risk of conflicts and security vulnerabilities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常建议在运行 Docker 容器时使用用户定义的网络，而不是主机网络，因为它提供更好的隔离性，并减少冲突和安全漏洞的风险。
- en: The null network
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空网络
- en: 'Sometimes, we need to run a few application services or jobs that do not need
    any network connection at all to execute the task at hand. It is strongly advised
    that you run those applications in a container that is attached to the `none`
    network. This container will be completely isolated and is thus safe from any
    outside access. Let’s run such a container:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要运行一些不需要任何网络连接即可执行任务的应用服务或作业。强烈建议你在附加到 `none` 网络的容器中运行这些应用程序。这样，容器将完全隔离，从而避免任何外部访问。让我们运行这样一个容器：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once inside the container, we can verify that there is no `eth0` network endpoint
    available:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 进入容器后，我们可以验证是否没有 `eth0` 网络端点可用：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is also no routing information available, as we can demonstrate by using
    the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 也没有可用的路由信息，正如我们可以通过以下命令演示的那样：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This returns nothing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这不返回任何内容。
- en: In the following section, we are going to learn how we can run a container inside
    the existing network namespace of another container.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何在另一个容器的现有网络命名空间中运行一个容器。
- en: Running in an existing network namespace
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现有网络命名空间中运行
- en: Normally, Docker creates a new network namespace for each container we run.
    The network namespace of the container corresponds to the sandbox of the container
    network model we described earlier on. As we attach the container to a network,
    we define an endpoint that connects the container network namespace to the actual
    network. This way, we have one container per network namespace.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Docker 为我们运行的每个容器创建一个新的网络命名空间。容器的网络命名空间对应于我们之前描述的容器网络模型中的沙箱。当我们将容器附加到网络时，我们定义一个端点，将容器网络命名空间与实际网络连接起来。这样，我们每个网络命名空间都有一个容器。
- en: 'Docker provides an additional way for us to define the network namespace that
    a container runs in. When creating a new container, we can specify that it should
    be attached to (or maybe we should say included in) the network namespace of an
    existing container. With this technique, we can run multiple containers in a single
    network namespace:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为我们提供了另一种方法来定义容器运行的网络命名空间。在创建新容器时，我们可以指定它应该附加到（或者我们应该说是包含在）一个现有容器的网络命名空间中。通过这种技术，我们可以在单一网络命名空间中运行多个容器：
- en: '![Figure 10.15 – Multiple containers running in a single network namespace](img/B19199_10_15.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 在单一网络命名空间中运行多个容器](img/B19199_10_15.jpg)'
- en: Figure 10.15 – Multiple containers running in a single network namespace
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 在单一网络命名空间中运行多个容器
- en: In the preceding diagram, we can see that in the leftmost network namespace,
    we have two containers. The two containers, since they share the same namespace,
    can communicate on `localhost` with each other. The network namespace (and not
    the individual containers) is then attached to the **front** network.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图中，我们可以看到，在最左侧的网络命名空间中，我们有两个容器。由于这两个容器共享相同的命名空间，它们可以在 `localhost` 上相互通信。然后，网络命名空间（而不是单独的容器）被附加到
    **front** 网络。
- en: This is useful when we want to debug the network of an existing container without
    running additional processes inside that container. We can just attach a special
    utility container to the network namespace of the container to inspect. This feature
    is also used by Kubernetes when it creates a Pod. We will learn more about Kubernetes
    and Pods in subsequent chapters of this book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要调试现有容器的网络而不在该容器内运行其他进程时，这是非常有用的。我们可以简单地将一个特殊的实用容器附加到容器的网络命名空间中进行检查。这个特性也被Kubernetes在创建Pod时使用。我们将在本书后续章节中进一步了解Kubernetes和Pod。
- en: 'Now, let’s demonstrate how this works:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示一下这是如何工作的：
- en: 'First, we create a new `bridge` network:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的`bridge`网络：
- en: '[PRE41]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we run a container attached to this network:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行一个附加到这个网络的容器：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we run another container and attach it to the network of our web container:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行另一个容器并将其附加到我们web容器的网络中：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Specifically, note how we define the network: `--network container:web`. This
    tells Docker that our new container will use the same network namespace as the
    container called `web`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意如何定义网络：`--network container:web`。这告诉Docker我们的新容器将使用与名为`web`的容器相同的网络命名空间。
- en: 'Since the new container is in the same network namespace as the web container
    running nginx, we’re now able to access nginx on `localhost`! We can prove this
    by using the `wget` tool, which is part of the Alpine container, to connect to
    nginx. We should see the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于新容器与运行nginx的web容器处于相同的网络命名空间中，我们现在可以在`localhost`上访问nginx了！我们可以通过使用Alpine容器中的`wget`工具来证明这一点。我们应该看到以下内容：
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we have shortened the output for readability. Please also note that
    there is an important difference between running two containers attached to the
    same network and two containers running in the same network namespace. In both
    cases, the containers can freely communicate with each other, but in the latter
    case, the communication happens over `localhost`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了便于阅读，我们已经缩短了输出。还要注意，运行两个附加到同一网络的容器和运行在相同网络命名空间中的两个容器之间有一个重要的区别。在这两种情况下，容器可以自由地相互通信，但在后一种情况下，通信是通过`localhost`进行的。
- en: 'To clean up the container and network, we can use the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清理容器和网络，我们可以使用以下命令：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next section, we are going to learn how to expose container ports on
    the container host.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习如何在容器主机上公开容器端口。
- en: Managing container ports
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器端口
- en: Now that we know how we can isolate firewall containers from each other by placing
    them on different networks, and that we can have a container attached to more
    than one network, we have one problem that remains unsolved. How can we expose
    an application service to the outside world? Imagine a container running a web
    server hosting our `webAPI` from before. We want customers from the internet to
    be able to access this API. We have designed it to be a publicly accessible API.
    To achieve this, we have to, figuratively speaking, open a gate in our firewall
    through which we can funnel external traffic to our API. For security reasons,
    we don’t just want to open the doors wide; we want to have a single controlled
    gate that traffic flows through.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何通过将它们放置在不同网络上来隔离防火墙容器，以及如何使容器附加到多个网络，我们还有一个未解决的问题。如何将应用服务暴露给外部世界？想象一个运行Web服务器并托管我们以前的`webAPI`的容器。我们希望来自互联网的客户能够访问这个API。我们设计它为一个可公开访问的API。为了实现这一点，我们需要象征性地打开我们防火墙中的一扇门，通过这扇门，我们可以将外部流量引导到我们的API。出于安全考虑，我们不仅仅想要敞开大门；我们希望有一个单一的可控门，流量通过它流动。
- en: 'We can create this kind of gate by mapping a container port to an available
    port on the host. We’re also calling this container port to publish a port. Remember
    that the container has its own virtual network stack, as does the host. Therefore,
    container ports and host ports exist completely independently and by default have
    nothing in common at all, but we can now wire a container port with a free host
    port and funnel external traffic through this link, as illustrated in the following
    diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将容器端口映射到主机上的一个可用端口来创建这种类型的门。我们也称这个容器端口发布为端口。请记住，容器有自己的虚拟网络堆栈，主机也有。因此，容器端口和主机端口完全独立存在，并且默认情况下根本没有任何共同点，但现在我们可以通过这个链接将容器端口与空闲的主机端口连接起来，并引导外部流量，就像下图所示的那样：
- en: '![Figure 10.16 – Mapping container ports to host ports](img/B19199_10_16.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 将容器端口映射到主机端口](img/B19199_10_16.jpg)'
- en: Figure 10.16 – Mapping container ports to host ports
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 将容器端口映射到主机端口
- en: 'But now, it is time to demonstrate how we can actually map a container port
    to a host port. This is done when creating a container. We have different ways
    of doing so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在是时候展示如何实际将容器端口映射到宿主机端口了。这是在创建容器时完成的。我们有不同的方式来做到这一点：
- en: 'First, we can let Docker decide which host port our container port should be
    mapped to. Docker will then select one of the free host ports in the range of
    `32xxx`. This automatic mapping is done by using the `-``P` parameter:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以让 Docker 决定我们的容器端口应该映射到哪个宿主机端口。Docker 会从 `32xxx` 范围内选择一个空闲的宿主机端口。这个自动映射是通过使用
    `-P` 参数完成的：
- en: '[PRE46]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding command runs an nginx server in a container. nginx is listening
    at port `80` inside the container. With the `-P` parameter, we’re telling Docker
    to map all the exposed container ports to a free port in the `32xxx` range. We
    can find out which host port Docker is using by using the `docker container` `port`
    command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在容器中运行一个 nginx 服务器。nginx 在容器内监听端口 `80`。通过 `-P` 参数，我们告诉 Docker 将所有暴露的容器端口映射到
    `32xxx` 范围内的一个空闲端口。我们可以通过使用 `docker container` `port` 命令来找出 Docker 正在使用的宿主机端口：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The nginx container only exposes port `80`, and we can see that it has been
    mapped to the host port `32768`. If we open a new browser window and navigate
    to `localhost:32768`, we should see the following screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 容器只暴露端口 `80`，我们可以看到它已经映射到宿主机端口 `32768`。如果我们打开一个新的浏览器窗口并访问 `localhost:32768`，我们应该会看到以下界面：
- en: '![Figure 10.17 – The welcome page of nginx](img/B19199_10_17.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – nginx 欢迎页面](img/B19199_10_17.jpg)'
- en: Figure 10.17 – The welcome page of nginx
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – nginx 欢迎页面
- en: 'An alternative way to find out which host port Docker is using for our container
    is to inspect it. The host port is part of the `NetworkSettings` node:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种了解 Docker 为我们的容器使用哪个宿主机端口的方法是检查容器。宿主机端口是 `NetworkSettings` 节点的一部分：
- en: '[PRE48]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, the third way of getting this information is to list the container:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，获取这些信息的第三种方法是列出容器：
- en: '[PRE49]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Please note that in the preceding output, the `/tcp` part tells us that the
    port has been opened for communication with the TCP protocol, but not for the
    UDP protocol. TCP is the default, and if we want to specify that we want to open
    the port for UDP, then we have to specify this explicitly. The special (IP) address,
    `0.0.0.0`, in the mapping tells us that traffic from any host IP address can now
    reach container port `80` of the web container.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的输出中，`/tcp` 部分告诉我们该端口已为 TCP 协议的通信打开，但未为 UDP 协议打开。TCP 是默认协议，如果我们希望明确指定打开端口用于
    UDP 协议，我们必须显式地指定这一点。映射中的特殊（IP）地址 `0.0.0.0` 告诉我们，来自任何主机 IP 地址的流量现在可以访问 web 容器的端口
    `80`。
- en: 'Sometimes, we want to map a container port to a very specific host port. We
    can do this by using the `-p` parameter (or `--publish`). Let’s look at how this
    is done with the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，我们希望将容器端口映射到一个非常特定的宿主机端口。我们可以通过使用 `-p` 参数（或 `--publish`）来实现。让我们来看一下如何通过以下命令实现：
- en: '[PRE50]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The value of the `-p` parameter is in the form of `<host port>:<container port>`.
    Therefore, in the preceding case, we map container port `80` to host port `8080`.
    Once the `web2` container runs, we can test it in the browser by navigating to
    `localhost:8080`, and we should be greeted by the same nginx welcome page that
    we saw in the previous example that dealt with automatic port mapping.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 参数的值采用 `<host port>:<container port>` 的形式。因此，在上述案例中，我们将容器端口 `80` 映射到宿主机端口
    `8080`。一旦 `web2` 容器启动，我们可以通过访问 `localhost:8080` 在浏览器中进行测试，我们应该会看到与之前自动端口映射示例中相同的
    nginx 欢迎页面。'
- en: 'When using the UDP protocol for communication over a certain port, the publish
    parameter will look like so: `-p 3000:4321/udp`. Note that if we want to allow
    communication with both TCP and UDP protocols over the same port, then we have
    to map each protocol separately.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 UDP 协议在某个端口上进行通信时，publish 参数的格式如下：`-p 3000:4321/udp`。请注意，如果我们希望在同一端口上同时支持
    TCP 和 UDP 协议的通信，我们必须分别为每个协议映射端口。
- en: In the next section, we will talk about HTTP routing using a reverse proxy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论使用反向代理进行 HTTP 路由。
- en: HTTP-level routing using a reverse proxy
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理进行 HTTP 层路由
- en: Imagine you have been tasked with containerizing a monolithic application. The
    application has organically evolved over the years into an unmaintainable behemoth.
    Changing even a minor feature in the source code may break other features due
    to the tight coupling that exists in the code base. Releases are rare due to their
    complexity and require the whole team to be on board. The application has to be
    taken down during the release window, which costs the company a lot of money due
    to lost opportunities, not to mention their loss of reputation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被指派将一个单体应用容器化。这个应用在多年的演化过程中变成了一个难以维护的庞然大物。即便是对源代码中的一个小功能进行修改，也可能由于代码库中紧密耦合的关系而破坏其他功能。由于复杂性，发布非常稀少，并且需要整个团队的支持。每次发布都需要停机，这会导致公司因错失商机而付出大量金钱，更别提它们的声誉损失了。
- en: Management has decided to put an end to that vicious cycle and improve the situation
    by containerizing the monolith. This alone will lead to a massively decreased
    time between releases, as witnessed within the industry. As a later step, the
    company wants to break out every piece of functionality from the monolith and
    implement it as a microservice. This process will continue until the monolith
    has been completely starved.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层已决定结束这一恶性循环，并通过将单体应用容器化来改善局势。仅此一步就能显著缩短发布周期，行业内已有实例证明了这一点。作为后续步骤，公司希望将单体应用中的每一部分功能拆分出来，并实现为微服务。这个过程将持续进行，直到单体应用完全被“饿死”。
- en: But it is this second point that leads to some head-scratching for the team
    involved. How will we break down the monolith into loosely coupled microservices
    without affecting all the many clients of the monolith out there? The public API
    of the monolith, though very complex, has a well-structured design. Public URIs
    were carefully crafted and should not be changed at any cost. For example, there
    is a product catalog function implemented in the app that can be accessed via
    [https://acme.com/catalog?category=bicycles](https://acme.com/catalog?category=bicycles)
    so that we can access a list of bicycles offered by the company.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但正是这个第二个问题让参与团队头疼不已。我们如何在不影响单体应用众多客户端的情况下，将单体应用拆分为松耦合的微服务呢？尽管单体应用的公共 API 非常复杂，但它具有良好的结构设计。公共
    URI 是经过精心设计的，任何情况下都不应更改。例如，应用中实现了一个产品目录功能，可以通过[https://acme.com/catalog?category=bicycles](https://acme.com/catalog?category=bicycles)来访问，从而获取公司提供的自行车列表。
- en: On the other hand, there is a URL called `https://acme.com/checkout` that we
    can use to initiate the checkout of a customer’s shopping cart, and so on. I hope
    it is clear where we are going with this.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，还有一个名为`https://acme.com/checkout`的 URL，可以用来启动客户购物车的结账流程，等等。我希望你能理解我们想表达的意思。
- en: Containerizing the monolith
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化单体应用
- en: 'Let’s start with the monolith. I have prepared a simple code base that has
    been implemented in Python 3.7 and uses Flask to implement the public REST API.
    The sample app is not really a full-blown application but just complex enough
    to allow for some redesign. The sample code can be found in the `ch10/e-shop`
    folder. Inside this folder is a subfolder called `monolith` containing the Python
    application. Follow these steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单体应用开始。我准备了一个简单的代码库，它是用 Python 3.7 实现的，并使用 Flask 来实现公共的 REST API。这个示例应用并不是真正的完整应用，只是足够复杂，允许进行一些重新设计。示例代码可以在`ch10/e-shop`文件夹中找到。在这个文件夹内有一个名为`monolith`的子文件夹，里面包含了
    Python 应用程序。请按照以下步骤操作：
- en: 'In a new Terminal window, navigate to that folder, install the required dependencies,
    and run the application:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端窗口中，进入该文件夹，安装所需的依赖，并运行该应用：
- en: '[PRE51]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The application will start and listen on localhost on port `5000`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用将启动并在本地主机的`5000`端口上监听：
- en: '![Figure 10.18 – Running the Python monolith](img/B19199_10_18.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 运行 Python 单体应用](img/B19199_10_18.jpg)'
- en: Figure 10.18 – Running the Python monolith
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 运行 Python 单体应用
- en: 'We can use `curl` to test the app. Open another Terminal window and use the
    following command to retrieve a list of all the bicycles the company offers:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`来测试这个应用。打开另一个终端窗口，并使用以下命令获取公司提供的所有自行车列表：
- en: '[PRE52]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This results in the following output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we have a JSON-formatted list of three types of bicycles. OK – so far,
    so good.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个 JSON 格式的自行车类型列表。好吧，至此一切顺利。
- en: 'Now, let’s change the `hosts` file, add an entry for `acme.com`, and map it
    to `127.0.0.1`, the loop-back address. This way, we can simulate a real client
    accessing the app at `http://acme.com/catalog?type=bicycle` instead of using `localhost`.
    You need to use `sudo` to edit the `/etc/hosts` file on a macOS or on Linux. You
    should add a line to the `hosts` file that looks like this:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `hosts` 文件，添加 `acme.com` 的条目，并将其映射到 `127.0.0.1`（回送地址）。这样，我们可以模拟一个真实客户端通过
    `http://acme.com/catalog?type=bicycle` 访问应用程序，而不是使用 `localhost`。你需要使用 `sudo` 来编辑
    macOS 或 Linux 上的 `/etc/hosts` 文件。你应该在 `hosts` 文件中添加一行，如下所示：
- en: '[PRE54]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Windows host file
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 主机文件
- en: On Windows, you can edit the file by, for example, running Notepad as an administrator,
    opening the `c:\Windows\System32\Drivers\etc\hosts` file, and modifying it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以通过例如以管理员身份运行记事本，打开 `c:\Windows\System32\Drivers\etc\hosts` 文件并进行修改，来编辑该文件。
- en: 'Save your changes and assert that it works by pinging `acme.com`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的更改，并通过 ping `acme.com` 来验证它是否有效：
- en: '[PRE55]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After all this, it is time to containerize the application. The only change
    we need to make to the application is ensuring that we have the application web
    server listening on `0.0.0.0` instead of `localhost`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一切之后，是时候将应用程序容器化了。我们需要对应用程序进行的唯一更改是确保应用程序的 Web 服务器监听 `0.0.0.0`，而不是 `localhost`。
- en: 'We can do this easily by modifying the application and adding the following
    start logic at the end of `main.py`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过修改应用程序，并在 `main.py` 文件末尾添加以下启动逻辑来轻松完成此操作：
- en: '[PRE56]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we can start the application as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式启动应用程序：
- en: '[PRE57]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, add a Dockerfile to the monolith folder with the following content:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 monolith 文件夹中添加一个 Dockerfile，内容如下：
- en: '![Figure 10.19 – The Dockerfile for the monolith](img/B19199_10_19.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – Monolith 的 Dockerfile](img/B19199_10_19.jpg)'
- en: Figure 10.19 – The Dockerfile for the monolith
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – Monolith 的 Dockerfile
- en: 'In your Terminal window, from within the monolith folder, execute the following
    command to build a Docker image for the application:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，从 monolith 文件夹内执行以下命令以为应用程序构建一个 Docker 镜像：
- en: '[PRE58]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After the image has been built, try to run the application:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像构建完成后，尝试运行应用程序：
- en: '[PRE59]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Notice that the output from the app now running inside a container is indistinguishable
    from what we got when running the application directly on the host. We can now
    test whether the application still works as before by using the two `curl` commands
    to access the catalog and the checkout logic:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在在容器中运行的应用程序输出与直接在主机上运行应用程序时的输出无法区分。我们现在可以使用两个 `curl` 命令来访问目录和结账逻辑，从而测试应用程序是否仍然像以前一样工作：
- en: '![Figure 10.20 – Testing the monolith while running in a container](img/B19199_10_20.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 在容器中运行时测试 monolith](img/B19199_10_20.jpg)'
- en: Figure 10.20 – Testing the monolith while running in a container
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 在容器中运行时测试 monolith
- en: Evidently, the monolith still works exactly the same way as before, even when
    using the correct URL, that is, `http://acme.com`. Great! Now, let’s break out
    part of the monolith’s functionality into a Node.js microservice, which will be
    deployed separately.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，monolith 仍然完全按照之前的方式工作，即使使用正确的 URL，即 `http://acme.com`。太棒了！现在，让我们将 monolith
    的一部分功能拆分为一个 Node.js 微服务，并将其单独部署。
- en: Extracting the first microservice
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取第一个微服务
- en: The team, after some brainstorming, has decided that the catalog product is
    a good candidate for the first piece of functionality that is cohesive yet self-contained
    enough to be extracted from the monolith. They decide to implement the product
    catalog as a microservice implemented in Node.js.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 团队经过一些头脑风暴后决定，产品目录是一个很好的候选功能，可以从 monolith 中提取出来，既是一个紧密集成的功能，又足够自包含。他们决定将产品目录作为一个微服务实现，并使用
    Node.js 来实现。
- en: 'You can find the code they came up with and the Dockerfile in the `catalog`
    subfolder of the project folder, that is, `e-shop`. It is a simple Express.js
    application that replicates the functionality that was previously available in
    the monolith. Let’s get started:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目文件夹中的 `catalog` 子文件夹（即 `e-shop`）中找到他们编写的代码和 Dockerfile。它是一个简单的 Express.js
    应用程序，复制了以前在 monolith 中提供的功能。让我们开始吧：
- en: 'In your Terminal window, from within the `catalog` folder, build the Docker
    image for this new microservice:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，从 `catalog` 文件夹内为这个新的微服务构建 Docker 镜像：
- en: '[PRE60]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, run a container from the new image you just built:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从你刚刚构建的新镜像运行一个容器：
- en: '[PRE61]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'From a different Terminal window, try to access the microservice and validate
    that it returns the same data as the monolith:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个终端窗口，尝试访问微服务并验证它返回与 monolith 相同的数据：
- en: '[PRE62]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Please notice the differences in the URL compared to when accessing the same
    functionality in the monolith. Here, we are accessing the microservice on port
    `3000` (instead of `5000`).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与访问单体应用相同功能时的 URL 比较，在这里，我们访问的是 `3000` 端口的微服务（而不是 `5000` 端口）。
- en: But we said that we didn’t want to have to change the clients that access our
    e-shop application. What can we do? Luckily, there are solutions to problems like
    this. We need to reroute incoming requests. We’ll show you how to do this in the
    next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们说过，我们不想更改访问我们电子商店应用的客户端。我们该怎么办？幸运的是，这类问题有解决方案。我们需要重新路由传入的请求。我们将在下一部分展示如何做到这一点。
- en: Using Traefik to reroute traffic
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Traefik 重新路由流量
- en: In the previous section, we realized that we would have to reroute incoming
    traffic with a target URL starting with `http://acme.com:5000/catalog` to an alternative
    URL such as `product-catalog:3000/catalog`. We will be using Traefik to do exactly
    that.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们意识到，我们必须将目标 URL 开头为 `http://acme.com:5000/catalog` 的传入流量重新路由到类似 `product-catalog:3000/catalog`
    的替代 URL。我们将使用 Traefik 来完成这个任务。
- en: Traefik is a cloud-native edge router and it is open source, which is great
    for our specific case. It even has a nice web UI that you can use to manage and
    monitor your routes. Traefik can be combined with Docker in a very straightforward
    way, as we will see in a moment.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik 是一个云原生的边缘路由器，并且是开源的，这对我们的特定场景非常有用。它甚至有一个不错的 web UI，您可以用它来管理和监控您的路由。Traefik
    可以非常直接地与 Docker 配合使用，稍后我们会看到。
- en: 'To integrate well with Docker, Traefik relies on the metadata found for each
    container or service. This metadata can be applied in the form of labels that
    contain the routing information:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Docker 进行良好的集成，Traefik 依赖于每个容器或服务中的元数据。这些元数据可以以包含路由信息的标签形式应用：
- en: 'First, let’s look at how to run the `catalog` service. Here is the Docker `run`
    command:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下如何运行 `catalog` 服务。以下是 Docker 的 `run` 命令：
- en: '[PRE63]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let’s quickly look at the four labels we define:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们定义的四个标签：
- en: '`traefik.enable=true`: This tells Traefik that this particular container should
    be included in the routing (the default is `false`).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.enable=true`：这告诉 Traefik 该特定容器应包含在路由中（默认值为 `false`）。'
- en: '`traefik.port=3000`: The router should forward the call to port `3000` (which
    is the port that the Express.js app is listening on).'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.port=3000`：路由器应将请求转发到端口 `3000`（这是 Express.js 应用程序监听的端口）。'
- en: '`traefik.priority=10`: This gives this route high priority. We will see why
    in a second.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.priority=10`：这为该路由提供了较高的优先级。我们稍后会看到原因。'
- en: '`traefik.http.routers.catalog.rule="Host(\"acme.com\") && PathPrefix(\"/catalog\")"`:
    The route must include the hostname, `acme.com`, and the path must start with
    `/catalog` in order to be rerouted to this service. As an example, `acme.com/catalog?type=bicycles`
    would qualify for this rule.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.http.routers.catalog.rule="Host(\"acme.com\") && PathPrefix(\"/catalog\")"`：该路由必须包含主机名
    `acme.com`，并且路径必须以 `/catalog` 开头，才能被重新路由到该服务。例如，`acme.com/catalog?type=bicycles`
    将符合此规则。'
- en: Please note the special form of the fourth label. Its general form is `traefik.http.routers.<service
    name>.rule`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意第四个标签的特殊形式。它的一般形式是 `traefik.http.routers.<服务名称>.rule`。
- en: 'Now, let’s look at how we can run the `eshop` container:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何运行 `eshop` 容器：
- en: '[PRE64]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we forward any matching calls to port `5000`, which corresponds to the
    port where the `eshop` application is listening. Pay attention to the priority,
    which is set to `1` (low). This, in combination with the high priority of the
    catalog service, allows us to filter out all URLs starting with `/catalog` and
    redirect them to the `catalog` service, while all other URLs will go to the `eshop`
    service.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将所有匹配的请求转发到端口 `5000`，该端口对应于 `eshop` 应用程序监听的端口。请注意优先级，设置为 `1`（低）。这一点与目录服务的高优先级配合使用，允许我们将所有以
    `/catalog` 开头的 URL 过滤出来，并将它们重定向到 `catalog` 服务，而其他所有 URL 将转到 `eshop` 服务。
- en: 'Now, we can finally run Traefik as the edge router that will serve as a reverse
    proxy in front of our application. This is how we start it:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以将 Traefik 作为边缘路由器运行，作为我们应用程序前端的反向代理。这就是我们启动它的方式：
- en: '[PRE65]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note how we mount the Docker socket into the container using the `-v` (or `--volume`)
    parameter so that Traefik can interact with the Docker engine. We will be able
    to send web traffic to port `80` of Traefik, from where it will be rerouted according
    to our rules in the routing definitions found in the metadata of the participating
    container. Furthermore, we can access the web UI of Traefik via port `8080`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用 `-v`（或 `--volume`）参数将 Docker 套接字挂载到容器中，这样 Traefik 就能与 Docker 引擎交互。我们能够将
    Web 流量发送到 Traefik 的端口 `80`，然后根据我们在参与容器的元数据中定义的路由规则将流量重新路由。此外，我们还可以通过端口 `8080`
    访问 Traefik 的 Web UI。
- en: 'Now that everything is running, that is, the monolith, the first microservice
    called `catalog`, and Traefik, we can test whether everything works as expected.
    Use `curl` once again to do so:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切都在运行，也就是单体应用、名为 `catalog` 的第一个微服务，以及 Traefik，我们可以测试一切是否按预期工作。再次使用 `curl`
    来测试：
- en: '[PRE66]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we mentioned earlier, we are now sending all traffic to port `80`, which
    is the port Traefik is listening on. This proxy will then reroute the traffic
    to the correct destination.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，现在我们将所有流量发送到端口 `80`，这是 Traefik 监听的端口。这个代理会将流量重新路由到正确的目的地。
- en: 'Before proceeding, stop and remove all containers:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请停止并删除所有容器：
- en: '[PRE67]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: That’s it for this chapter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容到此为止。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about how containers running on a single host can
    communicate with each other. First, we looked at the CNM, which defines the requirements
    of a container network, and then we looked at several implementations of the CNM,
    such as the bridge network. We then looked at how the bridge network functions
    in detail and also what kind of information Docker provides us with about the
    networks and the containers attached to those networks. We also learned about
    adopting two different perspectives, from both outside and inside the container.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何让运行在单一主机上的容器互相通信。首先，我们介绍了 CNM，它定义了容器网络的要求，然后我们看了 CNM 的几种实现方式，如桥接网络。接着，我们详细了解了桥接网络的工作原理，以及
    Docker 为我们提供的关于网络和附加到这些网络的容器的各种信息。我们还学到了从容器内外两个不同的视角来观察容器网络。
- en: In the next chapter, we’re going to introduce Docker Compose. We will learn
    about creating an application that consists of multiple services, each running
    in a container, and how Docker Compose allows us to easily build, run, and scale
    such an application using a declarative approach.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Docker Compose。我们将学习如何创建一个由多个服务组成的应用，每个服务都运行在一个容器中，以及 Docker Compose
    如何通过声明式方法帮助我们轻松构建、运行和扩展这样的应用。
- en: Further reading
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some articles that describe the topics that were presented in this
    chapter in more detail:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些文章，详细描述了本章中介绍的主题：
- en: '*Docker networking* *overview*: [http://dockr.ly/2sXGzQ](http://dockr.ly/2sXGzQn)n'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker 网络* *概述*：[http://dockr.ly/2sXGzQ](http://dockr.ly/2sXGzQn)n'
- en: '*What is a* *bridge?*: [https://bit.ly/2HyC3Od](https://bit.ly/2HyC3Od)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是* *桥接？*：[https://bit.ly/2HyC3Od](https://bit.ly/2HyC3Od)'
- en: '*Using bridge* *networks*: [http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用桥接* *网络*：[http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)'
- en: '*Using Macvlan* *networks*: [http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Macvlan* *网络*：[http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)'
- en: '*Networking using the host* *network*: [http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用主机* *网络进行网络连接*：[http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)'
- en: Questions
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess the skills that you have gained from this chapter, please try to
    answer the following questions:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你在本章中获得的技能，请尝试回答以下问题：
- en: Name the three core elements of the **container network** **model** (**CNM**).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**容器网络** **模型**（**CNM**）的三个核心要素是什么？'
- en: How do you create a custom `bridge` network called, for example, `frontend`?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个名为 `frontend` 的自定义 `bridge` 网络？
- en: How do you run two `nginx:alpine` containers attached to the frontend network?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何运行两个附加到前端网络的 `nginx:alpine` 容器？
- en: 'For the frontend network, get the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于前端网络，获取以下内容：
- en: The IPs of all the attached containers
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有附加容器的 IP 地址
- en: The subnet associated with the network
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网络相关的子网
- en: What is the purpose of the `host` network?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host` 网络的作用是什么？'
- en: Name one or two scenarios where the use of the `host` network is appropriate.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请举出一到两个使用 `host` 网络适合的场景。
- en: What is the purpose of the `none` network?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`none` 网络的作用是什么？'
- en: In what scenarios should the `none` network be used?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么场景下应该使用 `none` 网络？
- en: Why would we use a reverse proxy such as Traefik together with our containerized
    application?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要将反向代理（如 Traefik）与容器化应用一起使用？
- en: Answers
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are example answers for the questions of this chapter:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的示例答案：
- en: 'The three core elements of the Docker CNM are as follows:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker CNM 的三个核心元素如下：
- en: '**Sandbox**: A network namespace for a container where its network stack resides'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙盒**：容器的网络命名空间，其中容器的网络栈存在'
- en: '**Endpoint**: An interface that connects a container to a network'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点**：将容器与网络连接的接口'
- en: '**Network**: A collection of endpoints that can communicate with each other
    directly'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：一组可以直接相互通信的端点'
- en: 'To create a custom Docker `bridge` network called `frontend`, you can use the
    `docker network create` command with the `--driver` flag set to `bridge` (which
    is the default driver) and the `--subnet` flag to specify the subnet for the network.
    Here’s an example command:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个名为 `frontend` 的自定义 Docker `bridge` 网络，可以使用 `docker network create` 命令，并将
    `--driver` 标志设置为 `bridge`（这是默认驱动程序），同时使用 `--subnet` 标志指定网络的子网。以下是示例命令：
- en: '[PRE68]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will create a bridge network named `frontend` with a subnet of `172.25.0.0/16`.
    You can then use this network when starting containers with the `--``network`
    option:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `frontend` 的桥接网络，子网为 `172.25.0.0/16`。然后，你可以在启动容器时使用 `--network` 选项来使用此网络：
- en: '[PRE69]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To run two `nginx:alpine` containers attached to the `frontend` network that
    we created earlier, you can use the following `docker` `run` commands:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行两个附加到我们之前创建的 `frontend` 网络的 `nginx:alpine` 容器，可以使用以下 `docker` `run` 命令：
- en: '[PRE70]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: These commands will start two containers named `nginx1` and `nginx2` with the
    `nginx:alpine` image and attach them to the `frontend` network. The `-d` flag
    runs the containers in the background as daemons. You can then access the containers
    by their container names (`nginx1` and `nginx2`) or their IP addresses within
    the `frontend` network.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将启动两个名为 `nginx1` 和 `nginx2` 的容器，使用 `nginx:alpine` 镜像，并将它们连接到 `frontend`
    网络。`-d` 标志使容器在后台以守护进程方式运行。然后，你可以通过容器名称（`nginx1` 和 `nginx2`）或它们在 `frontend` 网络中的
    IP 地址来访问容器。
- en: 'Here is the solution:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是解决方案：
- en: 'To get the IPs of all the containers attached to the `frontend` Docker network,
    you can use the `docker network inspect` command, followed by the network name.
    Here’s an example command:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取所有附加到 `frontend` Docker 网络的容器的 IP 地址，可以使用 `docker network inspect` 命令，后跟网络名称。以下是示例命令：
- en: '[PRE71]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This will output the IPv4 addresses of all the containers attached to the frontend
    network, separated by spaces.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将输出所有附加到 frontend 网络的容器的 IPv4 地址，地址之间以空格分隔。
- en: 'To get the subnet associated with the `frontend` network, you can again use
    the `docker network inspect` command followed by the network name. Here’s an example
    command:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取与 `frontend` 网络关联的子网，可以再次使用 `docker network inspect` 命令，后跟网络名称。以下是示例命令：
- en: '[PRE72]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will output the subnet associated with the `frontend` network in CIDR notation
    (e.g., `172.25.0.0/16`). The `jq` command is used here to parse the output of
    the `docker network inspect` command and extract the subnet.
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将输出与 `frontend` 网络关联的子网，采用 CIDR 表示法（例如 `172.25.0.0/16`）。这里使用 `jq` 命令来解析 `docker
    network inspect` 命令的输出并提取子网信息。
- en: The Docker `host` network is a networking mode that allows a Docker container
    to use the host’s networking stack instead of creating a separate network namespace.
    In other words, containers running in `host` network mode can directly access
    the network interfaces and ports of the Docker host machine.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker `host` 网络是一种网络模式，允许 Docker 容器使用主机的网络堆栈，而不是创建一个单独的网络命名空间。换句话说，在 `host`
    网络模式下运行的容器可以直接访问 Docker 主机的网络接口和端口。
- en: The purpose of using the `host` network mode is to improve network performance
    since it avoids the overhead of containerization and network virtualization. This
    mode is often used for applications that require low-latency network communication
    or need to listen on a large number of ports.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `host` 网络模式的目的是提高网络性能，因为它避免了容器化和网络虚拟化的开销。此模式通常用于需要低延迟网络通信或需要监听大量端口的应用程序。
- en: However, using the `host` network mode can also present security risks since
    it exposes the container’s services directly on the Docker host’s network interfaces,
    potentially making them accessible to other containers or hosts on the same network.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `host` 网络模式也可能带来安全风险，因为它将容器的服务直接暴露在 Docker 主机的网络接口上，这可能使它们能够被同一网络上的其他容器或主机访问。
- en: 'The Docker `host` network mode is appropriate for scenarios where network performance
    is critical and where network isolation is not a requirement. For example, see
    the following:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker的`host`网络模式适用于网络性能至关重要且不要求网络隔离的场景。例如，见以下内容：
- en: In cases where the containerized application needs to communicate with other
    services running on the host machine, such as a database or cache service, the
    use of the `host` network mode can improve performance by eliminating the need
    for `host` network mode can simplify network configuration and management by allowing
    the container to use the same network interfaces and IP addresses as the host
    machine, without the need to manage port mapping between the container and host
    network namespaces.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器化应用程序需要与主机机器上运行的其他服务（如数据库或缓存服务）通信的情况下，使用`host`网络模式可以通过消除网络配置管理的复杂性来提高性能，允许容器使用与主机机器相同的网络接口和IP地址，而无需管理容器与主机网络命名空间之间的端口映射。
- en: The purpose of the Docker `none` network is to completely disable networking
    for a container. When a container is started with the `none` network mode, it
    does not have any network interfaces or access to the network stack of the host
    machine. This means that the container cannot communicate with the outside world
    or any other container.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker的`none`网络模式的目的是完全禁用容器的网络功能。当容器以`none`网络模式启动时，它没有任何网络接口，也无法访问主机机器的网络栈。这意味着该容器无法与外部世界或其他容器通信。
- en: The `none` network mode is useful in scenarios where the container does not
    require network connectivity, such as when running a batch process or a single-use
    container that performs a specific task and then exits. It can also be used for
    security purposes, to isolate the container from the network and prevent any potential
    network-based attacks.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`none`网络模式适用于容器不需要网络连接的场景，例如运行一个批处理过程或一个只执行特定任务并随后退出的单次使用容器。它也可以出于安全目的使用，将容器与网络隔离，以防止潜在的网络攻击。'
- en: It’s important to note that when a container is started with the `none` network
    mode, it can still access its own filesystem and any volumes that are mounted
    to it. However, if the container requires network access later on, it must be
    stopped and restarted with a different network mode.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当容器以`none`网络模式启动时，它仍然可以访问自己的文件系统以及挂载到其上的任何卷。然而，如果容器之后需要网络访问，它必须被停止并以不同的网络模式重新启动。
- en: 'The Docker `none` network mode is useful in scenarios where the container does
    not require network connectivity, such as the following:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker的`none`网络模式适用于容器不需要网络连接的场景，例如以下情况：
- en: Running a batch process or a single-use container that performs a specific task
    and then exits
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个批处理过程或一个只执行特定任务并随后退出的单次使用容器
- en: Running a container that does not need to communicate with other containers
    or the host machine
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个不需要与其他容器或主机通信的容器
- en: Running a container that has no need for external network access, such as a
    container that is used only for testing or debugging
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个不需要外部网络访问的容器，例如一个仅用于测试或调试的容器
- en: Running a container that requires high security and isolation from the network
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个需要高安全性并与网络隔离的容器
- en: 'There are several reasons why we might use a reverse proxy such as Traefik
    together with our containerized application:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能会将反向代理（如Traefik）与容器化应用程序一起使用的原因有几个：
- en: '**Load balancing**: A reverse proxy can distribute incoming traffic across
    multiple instances of our application running on different containers, ensuring
    that no single instance becomes overwhelmed with requests.'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：反向代理可以将传入流量分配到运行在不同容器上的多个应用实例，确保没有单一实例因请求过多而被压垮。'
- en: '**Routing**: With a reverse proxy, we can route incoming requests to the appropriate
    container based on the URL or domain name. This allows us to run multiple applications
    on the same host, each with its own unique domain or URL.'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：使用反向代理，我们可以根据URL或域名将传入的请求路由到适当的容器。这允许我们在同一主机上运行多个应用程序，每个应用程序都有自己独特的域名或URL。'
- en: '**SSL/TLS termination**: A reverse proxy can terminate SSL/TLS connections
    and handle certificate management, eliminating the need for our application to
    do this itself. This can simplify our application code and reduce the risk of
    security vulnerabilities.'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSL/TLS终止**：反向代理可以终止SSL/TLS连接并处理证书管理，从而消除我们应用程序需要自行处理这些事务的需求。这可以简化我们的应用代码，并降低安全漏洞的风险。'
- en: '**Security**: A reverse proxy can act as a buffer between our application and
    the public internet, providing an additional layer of security. For example, it
    can block certain types of traffic or filter out malicious requests.'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：反向代理可以充当我们应用程序与公共互联网之间的缓冲区，提供额外的安全层。例如，它可以阻止某些类型的流量或过滤掉恶意请求。'
- en: '**Scalability**: By using a reverse proxy such as Traefik, we can quickly and
    easily scale our application up or down by adding or removing containers. The
    reverse proxy can automatically route traffic to the appropriate containers, making
    it easy to manage our application’s infrastructure.'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：通过使用如Traefik这样的反向代理，我们可以通过添加或移除容器，快速而轻松地扩展应用程序。反向代理可以自动将流量路由到适当的容器，使得管理应用程序的基础设施变得更加容易。'
