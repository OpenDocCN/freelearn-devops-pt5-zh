- en: Chapter 2. Start Treating Your Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 开始将基础设施视为代码
- en: Ladies and gentlemen, put your hands in the air, for Programmable Infrastructure
    is here!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 诸位，举起你们的手，程序化基础设施来了！
- en: Perhaps **Infrastructure-as-Code** (**IaC**) is not an entirely new concept
    considering how long Configuration Management has been around. Codifying server,
    storage, and networking infrastructure and their relationships, however, is a
    relatively recent tendency brought about by the rise of cloud computing. But let
    us leave Configuration Management for later and focus our attention on that second
    aspect of IaC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 也许**基础设施即代码**（**IaC**）并不是一个全新的概念，因为配置管理已经存在了很长时间。然而，将服务器、存储和网络基础设施及其关系编写成代码的做法，是云计算崛起后才出现的相对较新的趋势。不过，让我们先放下配置管理，集中注意力在IaC的第二个方面。
- en: 'You should recall from the previous chapter some of the benefits of storing
    all the things as code:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得上一章中存储所有内容为代码的一些好处：
- en: Code can be kept under version control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以保持版本控制
- en: Code can be shared/collaborated on easily
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以轻松共享和协作
- en: Code doubles as documentation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码即文档
- en: Code is reproducible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是可复现的
- en: That last point was a big win for me personally. Automated provisioning helped
    reduce the time it took to deploy a full-featured cloud environment from four
    hours down to one, and the occurrences of human error to almost zero (one shall
    not be trusted with an input field).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点对我个人来说是一个巨大的收获。自动化资源配置帮助将部署一个功能齐全的云环境的时间从四小时减少到一个小时，并且将人为错误的发生率降到了几乎为零（不能让一个人负责输入字段）。
- en: Being able to rapidly provision resources becomes a significant advantage when
    a team starts using multiple environments in parallel and needs those brought
    up or down on-demand. In this chapter, we examine in detail how to describe (in
    code) and deploy one such environment on AWS with minimal manual interaction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队开始并行使用多个环境并且需要随时启动或停止这些环境时，能够快速配置资源成为一个显著的优势。在这一章节中，我们将详细探讨如何用代码描述并在 AWS
    上部署这样的一个环境，并尽量减少手动操作。
- en: 'To implement IaC in the cloud, we will look at two tools or services: **Terraform**
    and **CloudFormation**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在云中实现IaC，我们将关注两个工具或服务：**Terraform**和**CloudFormation**。
- en: 'We will go through examples of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下示例进行讲解：
- en: Configuring the tool
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置工具
- en: Writing an IaC template
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写IaC模板
- en: Deploying a template
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模板
- en: Deploying subsequent changes to the template
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模板的后续变更
- en: Deleting a template and removing the provisioned infrastructure
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除模板并移除已配置的基础设施
- en: For the purpose of these examples, let us assume our application requires a
    **Virtual Private Cloud** (**VPC**) that hosts a **Relational Database Services**
    (**RDS**) backend and a couple of **Elastic Compute Cloud** (**EC2**) instances
    behind an **Elastic Load Balancer** (**ELB**). We will keep most components behind
    **Network Address Translation** (**NAT**), allowing only the load balancer to
    be accessed externally.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，假设我们的应用程序需要一个**虚拟私有云**（**VPC**），它托管一个**关系型数据库服务**（**RDS**）后端和若干个在**弹性负载均衡器**（**ELB**）后面的**弹性计算云**（**EC2**）实例。我们将大多数组件置于**网络地址转换**（**NAT**）背后，只允许负载均衡器可以从外部访问。
- en: IaC using Terraform
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 实现基础设施即代码（IaC）
- en: One of the tools that can help deploy infrastructure on AWS is HashiCorp's Terraform
    ([https://www.terraform.io](https://www.terraform.io)). HashiCorp is that genius
    bunch that gave us Vagrant, Packer, and Consul. I would recommend you look up
    their website if you have not already.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 部署AWS基础设施的工具之一是HashiCorp的Terraform（[https://www.terraform.io](https://www.terraform.io)）。HashiCorp是那个给我们带来Vagrant、Packer和Consul的天才团队。如果你还没看过他们的网站，我推荐你去看看。
- en: Using **Terraform** (**TF**), we will be able to write a template describing
    an environment, perform a *dry run* to see what is about to happen and whether
    it is expected, deploy the template, and make any late adjustments where necessary-all
    of this without leaving the shell prompt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Terraform**（**TF**），我们可以编写一个模板来描述一个环境，进行*模拟运行*查看即将发生的事情以及是否符合预期，部署模板，并在必要时进行任何后期调整——这一切都无需离开终端。
- en: Configuration
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'Firstly, you will need to have a copy of TF ([https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html))
    on your machine and available on the CLI. You should be able to query the currently
    installed version, which in my case is 0.6.15:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在你的机器上安装一份TF（[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)），并确保它能在CLI中使用。你应该能够查询到当前安装的版本，在我这里是0.6.15：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since TF makes use of the AWS APIs, it requires a set of authentication keys
    and some level of access to your AWS account. In order to deploy the examples
    in this chapter you could create a new **Identity** **and** **Access Management**
    (**IAM**) user with the following permissions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TF 使用 AWS API，它需要一组认证密钥以及一定的 AWS 账户访问权限。为了部署本章中的示例，您可以创建一个新的 **身份** **和**
    **访问管理**（**IAM**）用户，并授予以下权限：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to this file for more information: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅此文件以获取更多信息：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json)。
- en: 'One way to make the credentials of the IAM user available to TF is by exporting
    the following environment variables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使 IAM 用户的凭证可供 TF 使用的一种方法是通过导出以下环境变量：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This should be sufficient to get us started.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以让我们开始了。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Downloading the example code**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码包的详细步骤已在本书的前言中提到。
- en: 'The code bundle for the book is also hosted on GitHub at: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS).
    We also have other code bundles from our rich catalog of books and videos available
    at: [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码包也托管在 GitHub 上：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS)。我们还有来自我们丰富书籍和视频目录的其他代码包，可以在：[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)
    中查看。快去看看吧！
- en: Template design
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板设计
- en: 'Before we get to coding, here are some of the rules:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，这里有一些规则：
- en: You could choose to write a TF template as a single large file or a combination
    of smaller ones
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择将 TF 模板编写为一个大的文件，或多个小文件的组合
- en: Templates can be written in pure JSON or TF's own format
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板可以用纯 JSON 或 TF 自有格式编写
- en: TF will look for files with`.tf` or `.tf.json` extensions in a given folder
    and load them in alphabetical order
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF 会在给定的文件夹中查找扩展名为 `.tf` 或 `.tf.json` 的文件，并按字母顺序加载它们。
- en: TF templates are declarative, hence the order in which resources appear in them
    does not affect the flow of execution
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF 模板是声明式的，因此资源在模板中出现的顺序不会影响执行流程
- en: 'A TF template generally consists of three sections: *resources*, *variables*,
    and *outputs*. As mentioned in the preceding section, it is a matter of personal
    preference how you arrange these; however, for better readability I suggest we
    make use of the TF format and write each section to a separate file. Also, while
    the file extensions are of importance, the filenames are up to you.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TF 模板通常由三部分组成：*资源*、*变量* 和 *输出*。如前所述，如何排列这些部分是个人偏好问题；然而，为了更好的可读性，我建议我们使用 TF 格式，并将每个部分写入单独的文件中。此外，尽管文件扩展名很重要，文件名则由你决定。
- en: Resources
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'In a way, this file holds the main part of a template, as the resources represent
    the actual components that end up being provisioned. For example, we will be using
    the VPC Terraform resource, RDS, ELB and a few others to provision what roughly
    looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种程度上讲，这个文件包含了模板的主要部分，因为资源代表了最终被配置的实际组件。例如，我们将使用 VPC Terraform 资源、RDS、ELB 以及其他几个资源来配置大致如下所示的内容：
- en: '![Resources](img/B05585_02_05a-1024x844.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![资源](img/B05585_02_05a-1024x844.jpg)'
- en: Since template elements can be written in any order, TF determines the flow
    of execution by examining any references that it finds (for example, a VPC should
    exist before an ELB that is said to belong to it is created). Alternatively, explicit
    flow control attributes such as `depends_on` are used, as we will observe shortly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板元素可以按任何顺序编写，TF 通过检查它找到的任何引用来确定执行流程（例如，VPC 应该在 ELB 被创建之前存在，ELB 被认为属于它）。另外，也可以使用显式的流程控制属性，例如
    `depends_on`，正如我们稍后会看到的那样。
- en: To find out more, let us go through the contents of the `resources.tf` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多信息，让我们浏览一下 `resources.tf` 文件的内容。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf)。
- en: 'First, we tell Terraform what provider to use for our infrastructure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉Terraform使用哪个提供程序来部署我们的基础设施：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that no credentials are specified, since we set them as environment
    variables earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到没有指定凭证，因为我们之前已经将它们设置为环境变量。
- en: 'Now we can add the VPC and its networking components:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加VPC及其网络组件：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So far, we have declared the VPC, its Internet and NAT gateways, plus a set
    of public and private subnets with matching routing tables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经声明了VPC、其互联网和NAT网关，以及一组具有匹配路由表的公有和私有子网。
- en: 'It will help clarify the syntax if we examined some of those resource blocks,
    line by line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们逐行查看一些资源块，它有助于澄清语法：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first argument is the type of the resource followed by an arbitrary name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是资源的类型，后面跟着一个任意的名称：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `aws_subnet` resource named `public-1` has a `vpc_id` property, which refers
    to the `id` attribute of a different `aws_vpc` resource named `terraform-vpc`.
    Such references to other resources implicitly define the execution flow, that
    is to say, the VPC needs to exist before the subnet can be created:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`public-1`的`aws_subnet`资源具有一个`vpc_id`属性，它引用了名为`terraform-vpc`的另一个`aws_vpc`资源的`id`属性。对其他资源的这种引用隐式地定义了执行流程，也就是说，VPC必须先存在，才能创建子网：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will talk more about variables in a moment, but the format is `var.var_name
    as shown here`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更多地讨论变量，但格式是`var.var_name`，如这里所示。
- en: Here, we use the `cidrsubnet` function with the `vpc-cidr` variable, which returns
    a `cidr_block` to be assigned to the `public-1` subnet. Please refer to the TF
    documentation for this and other useful functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`cidrsubnet`函数和`vpc-cidr`变量，它返回一个`cidr_block`，将分配给`public-1`子网。有关此函数和其他有用函数的详细信息，请参阅TF文档。
- en: 'Next, we add a RDS to the VPC:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将RDS添加到VPC中：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we mostly see references to variables with a few calls to other resources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们主要看到对变量的引用，并且有一些对其他资源的调用。
- en: 'Following the RDS is an ELB:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在RDS之后是一个ELB：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, we define the EC2 Auto Scaling Group and related resources such as the
    Launch Configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了EC2自动扩展组和相关资源，如启动配置。
- en: 'For the Launch Configuration we define the AMI and type of instance to be used,
    the name of the SSH keypair, EC2 security group(s) and the UserData to be used
    to bootstrap the instances:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于启动配置，我们定义了要使用的AMI和实例类型，SSH密钥对的名称，EC2安全组以及用于引导实例的UserData：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Auto Scaling Group takes the ID of the Launch Configuration, a list of
    VPC subnets, the min/max number of instances and the name of the ELB to attach
    provisioned instances to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展组接收启动配置的ID、VPC子网列表、实例的最小/最大数量以及附加到已配置实例的ELB名称：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `user_data` shell script will install and start NGINX onto the
    EC2 node(s).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`user_data`shell脚本将在EC2节点上安装并启动NGINX。
- en: Variables
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: We have made great use of variables to define our resources, making the template
    as re-usable as possible. Let us now look inside `variables.tf` to study these
    further.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们充分利用变量来定义我们的资源，使模板尽可能可重用。现在，让我们看看`variables.tf`，进一步研究这些变量。
- en: 'Similarly to the resources list, we start with the VPC:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与资源列表类似，我们从VPC开始：
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf)。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The syntax is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`variable_name` is arbitrary, but needs to match relevant `var.var_name` references
    made in other parts of the template. For example, the `aws-region` variable will
    satisfy the `${var.aws-region}` reference we made earlier when describing the
    region of the `provider aws resource`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`variable_name`是任意的，但需要与模板中其他部分引用的相关`var.var_name`匹配。例如，`aws-region`变量将满足我们在描述`provider
    aws resource`区域时使用的`${var.aws-region}`引用。'
- en: 'We will mostly use `string` variables, but there is another useful type called
    **map** that can hold lookup tables. Maps are queried in a similar way to looking
    up values in a hash/dict (Please see: [https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数时候会使用 `string` 类型变量，但还有另一种有用的类型叫做 **map**，它可以存储查找表。Map 查询的方式类似于在哈希/字典中查找值（请参见：[https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)）。
- en: 'Next comes RDS:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 RDS：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we add our EC2 related variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加与 EC2 相关的变量：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We now have the type and description of all our variables defined in `variables.tf`,
    but no values have been assigned to them yet.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 `variables.tf` 中定义了所有变量的类型和描述，但尚未分配值。
- en: 'TF is quite flexible with how this can be done. We could do it any of the following
    ways:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: TF 在这方面非常灵活。我们可以采用以下任何方式：
- en: Assign (default) values directly in `variables.tf:`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `variables.tf` 中直接分配（默认）值：
- en: variable "`aws-region`" { `type = "string"``description = "AWS region"``default
    = 'us-east-1'` }
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 "`aws-region`" { `type = "string"``description = "AWS 区域"``default = 'us-east-1'`
    }
- en: Not assign a value to a variable, in which case TF will prompt for it at run
    time
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不为变量分配值，这样 TF 会在运行时提示输入值
- en: '`*` Pass a `-var ''key=value''` argument directly to the TF command, like so:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 直接向 TF 命令传递 `-var ''key=value''` 参数，如下所示：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Store `key=value` pairs in a file
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `key=value` 键值对存储在文件中
- en: Use environment variables prefixed with `TF_VAR`, as in `TF_VAR_ aws-region`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以 `TF_VAR` 为前缀的环境变量，例如 `TF_VAR_aws-region`
- en: Using a `key=value` pairs file proves to be quite convenient within teams, as
    each engineer can have a private copy (excluded from revision control). If the
    file is named `terraform.tfvars` it will be read automatically by TF; alternatively,
    `-var-file` can be used on the command line to specify a different source.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `key=value` 键值对文件在团队内非常方便，因为每个工程师可以拥有一个私人副本（排除在版本控制之外）。如果文件名为 `terraform.tfvars`，TF
    会自动读取它；另外，也可以在命令行上使用 `-var-file` 来指定不同的源文件。
- en: 'Here is the content of our sample `terraform.tfvars` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们示例 `terraform.tfvars` 文件的内容：
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars)。
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A point of interest is `aws-availability-zones`, as it holds multiple values
    that we interact with using the element and split functions, as seen in `resources.tf`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的点是 `aws-availability-zones`，因为它包含多个值，我们通过元素和拆分函数与之进行交互，如在 `resources.tf`
    中所示。
- en: Outputs
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: The third, mostly informational part of our template contains the TF Outputs.
    These allow selected values to be returned to the user when testing, deploying
    or after a template has been deployed. The concept is similar to how echo statements
    are commonly used in shell scripts to display useful information during execution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模板中的第三部分，主要是提供信息的部分，包含 TF 输出。这些输出允许在测试、部署或模板部署后将选定的值返回给用户。这个概念类似于在 shell 脚本中常用的
    `echo` 语句，用于在执行过程中显示有用的信息。
- en: 'Let us add outputs to our template by creating an `outputs.tf` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个 `outputs.tf` 文件来向模板中添加输出：
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf)。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To configure an output, you simply reference a given resource and its attribute.
    As shown in preceding code, we have chosen the ID of the VPC, the Elastic IP address
    of the NAT gateway, the DNS name of the ELB and the endpoint address of the RDS
    instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置输出，您只需引用给定资源及其属性。如前面的代码所示，我们选择了 VPC 的 ID、NAT 网关的弹性 IP 地址、ELB 的 DNS 名称和 RDS
    实例的端点地址。
- en: 'This section completes the template in this example. You should now have four
    files in your template folder: `resources.tf`, `variables.tf`, `terraform.tfvars`,
    and `outputs.tf`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成了本示例中的模板。现在，您应该在模板文件夹中有四个文件：`resources.tf`、`variables.tf`、`terraform.tfvars`
    和 `outputs.tf`。
- en: Operations
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: 'We shall examine five main TF operations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查五个主要的 TF 操作：
- en: Validating a template
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模板
- en: Testing (dry-run)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（干运行）
- en: Initial deployment
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始部署
- en: Updating a deployment
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新部署
- en: Removal of a deployment
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个部署
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following command line examples, Terraform is run within the folder that
    contains the template files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下命令行示例中，Terraform 在包含模板文件的文件夹中运行。
- en: Validation
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证
- en: 'Before going any further, a basic syntax check should be done with the `terraform
    validate` command. After renaming one of the variables in `resources.tf`, validate
    returns an `unknown variable` error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步操作之前，应使用 `terraform validate` 命令进行基本的语法检查。在 `resources.tf` 中重命名一个变量后，validate
    会返回一个 `unknown variable` 错误：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once the variable name has been corrected, re-running `validate` returns no
    output, meaning validation has passed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变量名被修正，重新运行`validate`命令将不会输出任何内容，这意味着验证已通过。
- en: Dry-run
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 干运行
- en: 'The next step is to perform a test/dry-run execution with `terraform plan`,
    which displays what would happen during an actual deployment. The command returns
    a color-coded list of resources and their properties or more precisely, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行一个测试/干运行，使用 `terraform plan`，它显示了实际部署过程中会发生的情况。该命令返回一个带有颜色编码的资源及其属性列表，或更准确地说，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To literally get the picture of what the to-be-deployed infrastructure looks
    like, you could use `terraform graph`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要真实地了解将要部署的基础设施的样子，你可以使用 `terraform graph`：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'DOT files can be manipulated with the **Graphviz** open source software (Please
    see [http://www.graphviz.org](http://www.graphviz.org)) or many online readers/converters.
    The following diagram is a portion of a larger graph representing the template
    we designed earlier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DOT 文件可以通过 **Graphviz** 开源软件进行操作（请参见 [http://www.graphviz.org](http://www.graphviz.org)）或许多在线读取器/转换器。以下图示是一个较大图表的一部分，表示我们之前设计的模板：
- en: '![Dry-run](img/image_02_002.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Dry-run](img/image_02_002.jpg)'
- en: Terraform graph
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 图表
- en: Deployment
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: 'If you are happy with the plan and graph, the template can now be deployed
    using `terraform apply`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对计划和图表满意，模板现在可以通过 `terraform apply` 部署：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The state of your infrastructure has been saved to the following path. This
    state is required to modify and destroy your infrastructure, so keep it safe.
    To inspect the complete state, use the `terraform show` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你的基础设施状态已保存到以下路径。这个状态对于修改和销毁你的基础设施是必需的，因此请妥善保管它。要查看完整的状态，请使用 `terraform show`
    命令。
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At the end of a successful deployment, you will notice the `Outputs` we configured
    earlier and a message about another important part of *TF - the state file* (please
    refer to [https://www.terraform.io/docs/state/](https://www.terraform.io/docs/state/)):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功部署结束时，你会看到之前配置的`Outputs`以及关于另一个重要部分*TF - 状态文件*的信息（请参见 [https://www.terraform.io/docs/state/](https://www.terraform.io/docs/state/)）：
- en: TF stores the state of your managed infrastructure from the last time TF was
    run. By default, this state is stored in a local file named `terraform.tfstate`,
    but it can also be stored remotely, which works better in a team environment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TF 存储的是上次运行 TF 时管理的基础设施的状态。默认情况下，这个状态存储在一个名为`terraform.tfstate`的本地文件中，但它也可以远程存储，这在团队环境中效果更佳。
- en: TF uses this local state to create plans and make changes to your infrastructure.
    Prior to any operation, TF does a refresh to update the state with the real infrastructure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: TF 使用此本地状态来创建计划并对你的基础设施进行更改。在任何操作之前，TF 会执行刷新，以用实际基础设施更新状态。
- en: 'In a sense, the `state` file contains a snapshot of your infrastructure and
    is used to calculate any changes when a template has been modified. Normally,
    you would keep the `terraform.tfstate` file under version control alongside your
    templates. In a team environment however, if you encounter too many merge conflicts
    you can switch to storing the `state` file(s) in an alternative location such
    as S3 (please see: [https://www.terraform.io/docs/state/remote/index.html](https://www.terraform.io/docs/state/remote/index.html)).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上讲，`state` 文件包含了你基础设施的快照，并用于在模板被修改时计算任何更改。通常，你会将 `terraform.tfstate` 文件与模板一起纳入版本控制。然而，在团队环境中，如果遇到过多的合并冲突，你可以选择将
    `state` 文件存储在如 S3 这样的替代位置（请参见：[https://www.terraform.io/docs/state/remote/index.html](https://www.terraform.io/docs/state/remote/index.html)）。
- en: 'Allow a few minutes for the EC2 node to fully initialize, then try loading
    the ELB URI from the preceding `Outputs` in your browser. You should be greeted
    by **nginx**, as shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让 EC2 节点完全初始化几分钟，然后尝试从前面的 `Outputs` 中加载 ELB URI 到浏览器中。你应该会看到 **nginx**，如下图所示：
- en: '![Deployment](img/image_02_003.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Deployment](img/image_02_003.jpg)'
- en: Updates
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: As per Murphy 's Law, as soon as we deploy a template, a change to it will become
    necessary. Fortunately, all that is needed for this is to update and re-deploy
    the given template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据墨菲定律，一旦我们部署了一个模板，就会需要对其进行更改。幸运的是，所需的仅仅是更新并重新部署该模板。
- en: 'Let''s say we need to add a new rule to the ELB security group (shown in bold):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要向ELB安全组添加一个新规则（加粗部分显示）：
- en: 'Update the `"aws_security_group" "terraform-elb"` resource block in `resources.tf`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`resources.tf`中的`"aws_security_group" "terraform-elb"`资源块：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verify what is about to change:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证即将更改的内容：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Deploy the change:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署更改：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some update operations can be destructive (please refer to [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)).
    You should always check the CloudFormation documentation on the resource you are
    planning to modify to see whether a change is going to cause an interruption.
    TF provides some protection via the `prevent_destroy` life cycle property (please
    refer to [https://www.terraform.io/docs/configuration/resources.html#prevent_destroy](https://www.terraform.io/docs/configuration/resources.html#prevent_destroy)).
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些更新操作可能是破坏性的（请参见[http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)）。你应该始终查看CloudFormation文档，了解你计划修改的资源是否会导致中断。TF通过`prevent_destroy`生命周期属性提供了一些保护（请参见[https://www.terraform.io/docs/configuration/resources.html#prevent_destroy](https://www.terraform.io/docs/configuration/resources.html#prevent_destroy)）。
- en: Removal
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除
- en: This is a friendly reminder to always remove AWS resources after you are done
    experimenting with them to avoid any unexpected charges.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个友好的提醒：完成实验后，务必移除AWS资源，以避免产生意外费用。
- en: 'Before performing any `delete` operations, we will need to grant such privileges
    to the (`terraform`) IAM user we created in the beginning of this chapter. As
    a shortcut, you could temporarily attach the **AdministratorAccess** managed policy
    to the user via the AWS Console, as shown in the following figure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何`delete`操作之前，我们需要授予之前在本章开始时创建的(`terraform`) IAM用户相关权限。作为快捷方式，你可以通过AWS控制台临时将**AdministratorAccess**托管策略附加到该用户，如下图所示：
- en: '![Removal](img/image_02_004.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Removal](img/image_02_004.jpg)'
- en: 'To remove the VPC and all associated resources that we created as part of this
    example, we will use `terraform destroy`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移除我们在本示例中创建的VPC及其所有相关资源，我们将使用`terraform destroy`：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Terraform` asks for a confirmation then proceeds to destroy resources, ending
    with the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Terraform`会请求确认后继续销毁资源，最终显示如下：'
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we remove the temporary admin access we granted to the IAM user by detaching
    the **AdministratorAccess** managed policy, as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过卸载**AdministratorAccess**托管策略来移除之前授予IAM用户的临时管理员访问权限，如下图所示：
- en: '![Removal](img/image_02_005.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Removal](img/image_02_005.jpg)'
- en: Then, verify that the VPC is no longer visible in the AWS Console.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，验证VPC是否已在AWS控制台中消失。
- en: IaC using CloudFormation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation进行基础设施即代码（IaC）
- en: '**CloudFormation** is an AWS service for deploying infrastructure as code.
    As before, we are going to describe our infrastructure via templates containing
    parameters (variables), resources, and outputs.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**CloudFormation**是AWS提供的一项基础设施即代码（IaC）服务。和之前一样，我们将通过包含参数（变量）、资源和输出的模板来描述我们的基础设施。'
- en: CloudFormation calls each deployed template a **Stack**. Creating, listing,
    updating, and deleting stacks is possible via the AWS Console, CLI, or API. In
    a small setup, you would probably deploy each of your stacks individually, but
    as your architecture becomes more complex, you can start nesting stacks. You would
    have a top-level or a parent stack (template) that invokes a number of sub-stacks.
    Nested stacks allow you to pass variables between them and, of course, save you
    the time of having to deploy each one individually.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation将每个部署的模板称为**Stack**。可以通过AWS控制台、CLI或API创建、列出、更新和删除Stack。在小型设置中，你可能会单独部署每个Stack，但随着架构变得更复杂，你可以开始嵌套Stack。你将有一个顶级或父级Stack（模板），它调用多个子Stack。嵌套Stack允许你在它们之间传递变量，并且当然能节省你单独部署每个Stack的时间。
- en: Configuration
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: CloudFormation provides a GUI via the AWS Console; we however, are going to
    focus on the AWS CLI since it is most suitable for automating tasks in the future.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation通过AWS控制台提供GUI界面；然而，我们将重点关注AWS CLI，因为它更适合未来的自动化任务。
- en: 'Depending on the OS you run, you could download an installer from [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)
    or use Python PIP:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的操作系统，你可以从 [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/) 下载安装程序，或者使用
    Python PIP：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will need a set of API keys, so let''s create a new IAM user called `cloudformation`
    with the following privileges:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一组 API 密钥，因此让我们创建一个名为 `cloudformation` 的新 IAM 用户，并赋予以下权限：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json)。
- en: 'You have the choice of using `aws configure`, which will prompt you for the
    API credentials, or if you prefer not to store them permanently, you could use
    an environment variable:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用 `aws configure`，它会提示你输入 API 凭证，或者如果你不想永久存储它们，你也可以使用环境变量：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'CloudFormation templates do not store any AWS region information, so to avoid
    specifying it on the command line each time. It can be exported as well:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 模板不会存储任何 AWS 区域信息，因此为了避免每次在命令行中指定，可以将其导出：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With those environment variables in place, `awscli` should be ready for use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好这些环境变量后，`awscli` 应该可以开始使用了。
- en: Template design
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板设计
- en: 'CloudFormation templates are written in JSON and usually contain at least three
    sections (in any order): parameters, resources and outputs.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 模板是用 JSON 编写的，通常至少包含三个部分（顺序无关）：参数、资源和输出。
- en: Unfortunately it is not possible to store these into separate files (with the
    exception of parameter values), so in this example we will work with a single
    template file named `main.json`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，无法将这些参数存储到单独的文件中（参数值除外），因此在这个例子中，我们将使用一个名为`main.json`的单一模板文件。
- en: Templates can be used locally or imported from a remote location (an S3 bucket
    is a common choice).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以在本地使用，也可以从远程位置导入（S3 存储桶是常见的选择）。
- en: Parameters
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: Parameters add flexibility and portability to our Stack by letting us pass variables
    to it such as instance types, AMI ids, SSH keypair names and similar values which
    it is best not to hard-code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 参数通过允许我们传递变量（例如实例类型、AMI ID、SSH 密钥对名称等）为我们的堆栈增加了灵活性和可移植性，这些值最好不要硬编码。
- en: Each parameter takes an arbitrary logical name (alphanumeric, unique within
    the template), description, type, and an optional default value. The available
    types are `String`, `Number`, `CommaDelimitedList`, and the more special AWS-specific
    type, such as `AWS::EC2::KeyPair::KeyName`, as seen in the preceding code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都有一个任意的逻辑名称（字母数字，模板中唯一）、描述、类型和一个可选的默认值。可用的类型包括 `String`、`Number`、`CommaDelimitedList`，以及一些特定于
    AWS 的特殊类型，例如 `AWS::EC2::KeyPair::KeyName`，如前面的代码所示。
- en: The latter is useful for validation, as CloudFormation will check whether a
    key pair with the given name actually exists in your AWS account.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 后者对于验证很有用，因为 CloudFormation 会检查给定名称的密钥对是否确实存在于你的 AWS 账户中。
- en: Parameters can also have properties such as `AllowedValues`, `Min/MaxLength`,
    `Min/MaxValue`, `NoEcho` and other (please see [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参数还可以具有诸如 `AllowedValues`、`Min/MaxLength`、`Min/MaxValue`、`NoEcho` 等属性（请参阅 [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html)）。
- en: There is a limit of 60 parameters per template.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板的参数限制为 60 个。
- en: 'Let us examine the parameters found at the top of our template:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下模板顶部的参数：
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json)。
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have used the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下内容：
- en: '`CommaDelimitedList`, which we will conveniently query later with a special
    function'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommaDelimitedList`，我们稍后会通过一个特殊的函数方便地查询它'
- en: '`AllowedValues` and `MinValue` to enforce constraints'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AllowedValues` 和 `MinValue` 来强制执行约束
- en: '`NoEcho` for passwords or other sensitive data'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoEcho` 用于密码或其他敏感数据'
- en: Some AWS-specific types to have CloudFormation further validate input
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些AWS特定的类型用于进一步验证输入
- en: You will notice that there are no values assigned to any of the preceding parameters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，前面的参数没有被赋予任何值。
- en: 'To maintain a reusable template, we will store values in a separate file (`parameters.json`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护可重用的模板，我们将值存储在一个单独的文件中（`parameters.json`）：
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json)。
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Resources
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: You are already familiar with the concept of resources and how they are used
    to describe different pieces of infrastructure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉资源的概念，以及它们如何用于描述不同的基础设施组件。
- en: Regardless of how resources appear in a template, CloudFormation will follow
    its internal logic to decide the order in which these get provisioned.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 无论资源在模板中的出现顺序如何，CloudFormation都会遵循其内部逻辑来决定这些资源的配置顺序。
- en: 'The syntax for declaring a resource is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 声明资源的语法如下：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: IDs need to be alphanumeric and unique within the template.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ID需要是字母数字组合，并且在模板内是唯一的。
- en: 'The list of CloudFormation resource types and their properties can be found
    here: [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation资源类型及其属性的列表可以在这里找到：[http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)
- en: The max number of resources a template can have is 200\. Reaching that limit,
    you will need to split a template into smaller ones and possibly look into nested
    stacks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模板中最多可以有200个资源。达到该限制后，你需要将模板拆分成更小的模板，并可能需要考虑使用嵌套堆栈。
- en: 'Back to our example, as per tradition we start by creating a VPC and its supporting
    elements such as subnets, Internet gateway and NAT gateway:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，按照传统，我们首先创建一个VPC及其支持元素，如子网、互联网网关和NAT网关：
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json)。
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note some of the `CloudFormation` functions used in the preceding code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面代码中使用的一些`CloudFormation`函数：
- en: '`"Fn::Select"` in `"CidrBlock" : { "Fn::Select" : [ "0", {"Ref" : "publicCidr"}
    ] }`, which allows us to query the `CommaDelimitedList` type parameters we set
    earlier'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Fn::Select"`在`"CidrBlock" : { "Fn::Select" : [ "0", {"Ref" : "publicCidr"}
    ] }`中使用，允许我们查询之前设置的`CommaDelimitedList`类型的参数。'
- en: '`"Fn::Join"`, for concatenating strings'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Fn::Join"`，用于连接字符串'
- en: '`"Fn::GetAtt"`, for retrieving resource attributes'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Fn::GetAtt"`，用于获取资源属性'
- en: Also, the `DependsOn` property of the `natGateway` resource allows us to set
    explicit conditions on the order of execution. In this case, we are saying that
    the Internet Gateway resource needs to be ready (attached to the VPC) before the
    NAT Gateway is provisioned.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`natGateway`资源的`DependsOn`属性允许我们对执行顺序设置明确的条件。在这种情况下，我们声明互联网网关资源需要准备好（已附加到VPC）后，才会配置NAT网关。
- en: 'After the VPC, let''s add RDS:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建VPC之后，我们添加RDS：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then add the ELB:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加ELB：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And add the EC2 resources:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加EC2资源：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We still use a `UserData` shell script to install the NGINX package; however,
    the presentation is slightly different this time. `CloudFormation` is going to
    concatenate the lines using a new line character as a delimiter then encode the
    result in `Base64`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用`UserData`脚本来安装NGINX包；然而，这次展示的方式略有不同。`CloudFormation`将使用换行符作为分隔符连接这些行，然后将结果编码为`Base64`格式：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We use `DependsOn` to ensure the RDS instance goes in before `autoScalingGroup`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`DependsOn`确保RDS实例在`autoScalingGroup`之前创建：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Outputs
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Again, we will use these to highlight some resource attributes following a successful
    deployment. Another important feature of `Outputs`, however, is that they can
    be used as input parameters for other templates (stacks). This becomes very useful
    with nested stacks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将使用这些输出，突出显示成功部署后某些资源属性。然而，`Outputs`的另一个重要特点是，它们可以作为其他模板（堆栈）的输入参数。这在嵌套堆栈中非常有用。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once declared, `Outputs` cannot be subsequently updated on their own. You will
    need to modify at least one resource in order to trigger an Output update.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明，`Outputs`就不能单独更新。你需要修改至少一个资源，才能触发`Output`的更新。
- en: 'We add the `VPC ID`, `NAT IP` address and `ELB DNS` name as `Outputs`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`VPC ID`、`NAT IP`地址和`ELB DNS`名称作为`Outputs`添加：
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json)。
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Currently, a template can have no more than 60 Outputs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，一个模板最多可以有60个`Outputs`。
- en: Operations
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: 'If you have been following along, you should now have a `main.json` and a `parameters.json`
    in your current folder. It is time to put them to use, so here are a few operations
    we are going to perform:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随教程，你现在应该在当前文件夹中有一个`main.json`和一个`parameters.json`。是时候开始使用它们了，接下来我们将进行一些操作：
- en: Validate a template
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模板
- en: Deploy a stack
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个堆栈
- en: Update a stack
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新堆栈
- en: Delete a stack
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个堆栈
- en: Template validation
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板验证
- en: 'First things first, a basic check of our JSON template with `validate-template`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`validate-template`对JSON模板进行基本检查：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If there's no errors, the CLI returns the parsed template. Note that we could
    have just as easily pointed to a remote location using `--template-url` instead
    of `-template-body`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，CLI将返回解析后的模板。请注意，我们也可以使用`--template-url`指向一个远程位置，而不是`-template-body`。
- en: Deploying a Stack
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署堆栈
- en: 'To deploy our template (stack), we will use `create-stack`. It takes an arbitrary
    name, the location of the template, and the file containing parameter values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署我们的模板（堆栈），我们将使用`create-stack`。它需要一个任意名称、模板的位置以及包含参数值的文件：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'CloudFormation starts creating the stack and no further output is returned.
    To get progress information on the CLI, use `describe-stacks`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation开始创建堆栈，此时没有进一步的输出返回。要获取CLI上的进度信息，请使用`describe-stacks`：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And for even more details, use `describe-stack-events`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 若想获取更多详细信息，请使用`describe-stack-events`。
- en: 'After a few minutes (based on our small template) `StackStatus` changes from
    `CREATE_IN_PROGRESS` to `CREATE_COMPLETE` and we are provided the requested `Outputs`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后（基于我们的小模板），`StackStatus`从`CREATE_IN_PROGRESS`变为`CREATE_COMPLETE`，并返回我们请求的`Outputs`：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, the `elbDNS` URL should return the nginx welcome page, as shown
    here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`elbDNS` URL 应该返回nginx欢迎页面，如下所示：
- en: '![Deploying a Stack](img/image_02_006.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Deploying a Stack](img/image_02_006.jpg)'
- en: If not, you might need to allow some more time for the EC2 node to fully initialize.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回，可能需要等待更多时间，直到EC2节点完全初始化。
- en: Updating a stack
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新堆栈
- en: '`CloudFormation` offers two ways of updating a deployed stack.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloudFormation`提供了两种更新已部署堆栈的方法。'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some update operations can be destructive (please refer to [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)).
    You should always check the `CloudFormation` documentation on the resource you
    are planning to modify to see whether a change is going to cause any interruption.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更新操作可能是破坏性的（请参阅[http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)）。你应该始终检查你计划修改的资源的`CloudFormation`文档，看看更改是否会导致任何中断。
- en: 'If you would like to quickly deploy a minor change, then all you need to do
    is modify the template file and deploy it directly with `update-stack`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望快速部署一个小的变更，你只需要修改模板文件并直接使用`update-stack`进行部署：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Otherwise, a good practice would be to use `Change Sets` to preview stack changes
    before deploying them. For example, let us update the rules in the ELB security
    group as we did before:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，好的做法是使用`Change Sets`预览堆栈的更改，然后再进行部署。例如，我们可以像之前那样更新ELB安全组中的规则：
- en: 'Modify the `main.json` template (add another rule to `elbSecurityGroup`):'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`main.json`模板（向`elbSecurityGroup`添加另一个规则）：
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create a Change Set`:`
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建变更集`:` '
- en: '[PRE49]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Preview the Change Set:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预览变更集：
- en: '[PRE50]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Execute the Change Set:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行变更集：
- en: '[PRE51]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Whether via a Change Set or updating directly, if you are simply modifying parameter
    values (`parameters.json`) you can skip re-uploading the template (`main.json`)
    with `--use-previous-template`.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论是通过变更集还是直接更新，如果您仅仅是在修改参数值（`parameters.json`），则可以跳过重新上传模板（`main.json`），使用`--use-previous-template`。
- en: Deleting a stack
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除堆栈
- en: 'In order to tidy up after our experiments, we will need to grant temporary
    Admin privileges to the CloudFormation IAM user (the same procedure as in the
    earlier TF section); run `delete-stack`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理我们的实验，我们需要向CloudFormation IAM用户授予临时管理员权限（与之前TF部分相同的程序）；运行`delete-stack`：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then revoke the Admin privileges.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后撤销管理员权限。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the importance and usefulness of Infrastructure
    as Code and ways to implement it using `Terraform` or AWS `CloudFormation`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了基础设施即代码的重要性和实用性，以及如何使用`Terraform`或AWS`CloudFormation`实现这一点。
- en: We examined the structure and individual components of both a TF and a CF template
    then practiced deploying those onto AWS using the CLI. I trust that the examples
    we went through have demonstrated the benefits and immediate gains from the practice
    of deploying infrastructure as code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了TF和CF模板的结构和各个组成部分，然后通过CLI实践将其部署到AWS。我相信我们通过的示例展示了将基础设施作为代码进行部署的好处和立竿见影的收益。
- en: So far, however, we have only done half the job. With the provisioning stage
    completed, you will naturally want to start configuring your infrastructure, and
    that is what we are going to do in the next chapter on *Configuration Management*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们只完成了一半的工作。随着配置阶段的完成，您自然会希望开始配置您的基础设施，这就是我们将在下一章关于*配置管理*中做的事情。
