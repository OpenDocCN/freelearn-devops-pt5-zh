- en: Modern Infrastructures and Applications with Docker
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker的现代基础设施和应用程序
- en: Microservices and containers have probably been the most frequently mentioned
    buzzwords in recent years. These days, we can still hear about them at conferences
    across the globe. Although both terms are definitely related when talking about
    modern applications, they are not the same. In fact, we can execute microservices
    without containers and run big monolithic applications in containers. In the middle
    of the container world, there is a well-known word that comes to mind when we
    find ourselves talking about them – Docker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和容器可能是近年来最常被提及的流行词汇。如今，我们仍然可以在全球各地的会议上听到关于它们的讨论。虽然这两个术语在谈论现代应用时肯定相关，但它们并不相同。事实上，我们可以在没有容器的情况下执行微服务，也可以在容器中运行大型单体应用程序。在容器的世界中，当我们谈论容器时，一个广为人知的词汇浮现在脑海中——Docker。
- en: This book is a guide to passing the Docker Certified Associate exam, which is
    a certification of knowledge pertaining to this technology. We will cover each
    topic needed to pass this exam. In this chapter, we will start with what microservices
    are and why they are important in modern applications. We will also cover how
    Docker manages the requirements of this application's logical components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是一本关于通过Docker认证助理考试的指南，这项考试是对与该技术相关的知识的认证。我们将涵盖通过该考试所需的每个主题。本章将从什么是微服务以及它们在现代应用程序中的重要性开始。我们还将讲解Docker如何管理该应用程序的逻辑组件的需求。
- en: This chapter will guide you through Docker's main concepts and will give you
    a basic idea of the tools and resources provided to manage containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你了解Docker的主要概念，并为你提供一个基本的理解，帮助你掌握管理容器所需的工具和资源。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding the evolution of applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用程序的演变
- en: Infrastructures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施
- en: Processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: Microservices and processes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与进程
- en: What are containers?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Learning about the main concepts of containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习容器的主要概念
- en: Docker components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker组件
- en: Building, shipping, and running workflows
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、运输和运行工作流程
- en: Windows containers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows容器
- en: Customizing Docker
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义Docker
- en: Docker security
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker安全
- en: Let's get started!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will learn about various Docker Engine concepts. We''ll
    provide some labs at the end of this chapter that will help you understand and
    learn about the concepts shown. These labs can be run on your laptop or PC using
    the provided Vagrant standalone environment or any already deployed Docker host
    that you own. You can find additional information in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习各种Docker引擎的概念。我们将在本章末尾提供一些实验室，这些实验室将帮助你理解和学习所展示的概念。这些实验室可以在你的笔记本电脑或PC上运行，使用提供的Vagrant独立环境或你拥有的任何已部署的Docker主机。你可以在本书的GitHub仓库中找到更多信息：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下视频，了解实际中的代码：
- en: '"[https://bit.ly/3jikiSl](https://bit.ly/3jikiSl)"'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/3jikiSl](https://bit.ly/3jikiSl)"'
- en: Understanding the evolution of applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序的演变
- en: As we will probably read about on every IT medium, the concept of microservices
    is key in the development of new modern applications. Let's go back in time a
    little to see how applications have been developed over the years.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可能在每个IT媒体中看到的，微服务的概念是现代应用开发的关键。让我们稍微回顾一下，看看多年来应用程序是如何发展的。
- en: Monolithic applications are applications in which all components are combined
    into a single program that usually runs on a single platform. These applications
    were not designed with reusability in mind, nor any kind of modularity, for that
    matter. This means that every time a part of their code required an update, all
    the applications had to be involved in the process; for example, having to recompile
    all the application code in order for it to work. Of course, things were not so
    strict then.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用是指将所有组件组合成一个通常在单个平台上运行的单一程序的应用程序。这些应用程序在设计时并未考虑可重用性，也没有考虑模块化。这意味着每次它们的代码需要更新时，所有应用程序都必须参与这个过程；例如，必须重新编译所有应用程序代码才能使其正常工作。当然，那时的要求并不那么严格。
- en: Applications grew in number in terms of tasks and functionalities, with some
    of these tasks being distributed to other systems or even other smaller applications.
    However, the core components were kept immutable. We used this model of programming
    because running all application components together, on the same host, was better
    than trying to find some required information from other hosts. Network speed
    was insufficient in this regard, however. These applications were difficult to
    scale and difficult to upgrade. In fact, certain applications were locked to specific
    hardware and operating systems, which meant that developers needed to have the
    same hardware architectures at development stages to evolve applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在任务和功能方面的数量不断增加，其中一些任务被分配到其他系统甚至更小的应用程序中。然而，核心组件保持不变。我们使用这种编程模型，因为将所有应用组件放在同一主机上运行比从其他主机上查找所需信息更好。然而，网络速度在这方面不足。这些应用程序难以扩展，且难以升级。实际上，某些应用程序被锁定在特定的硬件和操作系统上，这意味着开发人员在开发阶段需要使用相同的硬件架构才能演化应用程序。
- en: 'We will discuss the infrastructure associated with these monolithic applications
    in the next section. The following diagram represents how the decoupling of tasks
    or functionalities has evolved from monolithic applications to **Simple Object
    Access Protocol** (**SOAP**) applications and the new paradigm of microservices:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论与这些单体应用相关的基础设施。以下图表展示了任务或功能的解耦是如何从单体应用程序发展到**简单对象访问协议**（**SOAP**）应用程序，并最终演变成微服务的新范式：
- en: '![](img/4a2e3633-c533-4089-a8d4-d12cd4478860.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a2e3633-c533-4089-a8d4-d12cd4478860.png)'
- en: In trying to achieve better application performance and decoupling components,
    we moved to three-tier architectures, based on a presentation tier, an application
    tier, and a data tier. This allowed different types of administrators and developers
    to be involved in application updates and upgrades. Each layer could be running
    on different hosts, but components only talked to one another inside the same
    application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更好的应用性能和解耦组件，我们转向了三层架构，基于表现层、应用层和数据层。这使得不同类型的管理员和开发人员可以参与到应用更新和升级中。每一层都可以在不同的主机上运行，但组件只会在同一应用内部进行通信。
- en: This model is still present in our data centers right now, separating frontends
    from application backends before reaching the database, where all the requisite
    data is stored. These components evolved to provide scalability, high availability,
    and management. On occasion, we had to include new middleware components to achieve
    these functionalities (thus adding to the final equation; for example, application
    servers, applications for distributed transactions, queueing, and load balancers).
    Updates and upgrades were easier, and we isolated components to focus our developers
    on those different application functionalities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这一模型现在仍然存在于我们的数据中心中，在到达数据库之前将前端与应用后端分离，数据库中存储着所有必需的数据。这些组件发展成提供可扩展性、高可用性和管理功能的系统。偶尔，我们需要加入新的中间件组件来实现这些功能（从而增加了最终的方程式；例如，应用服务器、分布式事务应用程序、排队和负载均衡器）。更新和升级变得更容易，我们通过隔离组件来专注于不同的应用功能。
- en: This model was extended and it got even better with the emergence of virtual
    machines in our data centers. We will cover how virtual machines have improved
    the application of this model in more detail in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟机在数据中心的出现，这一模型得到了扩展，并变得更好。我们将在下一节中更详细地讨论虚拟机如何改进该模型的应用。
- en: As Linux systems have grown in popularity, the interaction between different
    components, and eventually different applications, has become a requirement. SOAP
    and other queueing message integration have helped applications and components
    exchange their information, and networking improvements in our data centers have
    allowed us to start distributing these elements in different nodes, or even locations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Linux 系统的普及，不同组件之间的交互，最终是不同应用之间的交互，已经成为了一项必要的要求。SOAP 和其他排队消息集成技术帮助应用程序和组件交换信息，而我们数据中心的网络改进使我们能够开始将这些元素分布到不同的节点，甚至不同的地点。
- en: Microservices are a step further to decoupling application components into smaller
    units. We usually define a microservice as a small unit of business functionality
    that we can develop and deploy standalone. With this definition, an application
    will be a compound of many microservices. Microservices are very light in terms
    of host resource usage, and this allows them to start and stop very quickly. Also,
    it allows us to move application health from a high availability concept to resilience,
    assuming that the process dies (this can be caused by problems or just a component
    code update) and we need to start a new one as quickly as possible to keep our
    main functionality healthy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是将应用程序组件解耦为更小单元的一步。我们通常将微服务定义为一个小的业务功能单元，能够独立开发和部署。按照这个定义，应用程序将由许多微服务组成。微服务在主机资源使用方面非常轻量，这使得它们可以非常快速地启动和停止。同时，它还允许我们将应用程序的健康状态从高可用性概念转向弹性，即使进程崩溃（这可能是由问题或仅仅是组件代码更新引起的），我们也能尽快启动一个新的进程，以保持主要功能的健康。
- en: Microservices architecture comes with stateless in mind. This means that the
    microservice state should be managed outside of its own logic because we need
    to be able to run many replicas for our microservice (scale up or down) and run
    its content on all nodes of our environment, as required by our global load, for
    example. We decoupled the functionality from the infrastructure (we will see how
    far this concept of "run everywhere" can go in the next chapter).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构考虑的是无状态设计。这意味着微服务的状态应该在其自身逻辑之外进行管理，因为我们需要能够为我们的微服务运行多个副本（向上或向下扩展），并根据我们的全球负载要求（例如）在环境中的所有节点上运行其内容。我们将功能与基础设施解耦（我们将在下一章中看到这个“随处运行”概念可以走多远）。
- en: 'Microservices provide the following features:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务提供以下特性：
- en: Managing an application in pieces allows us to substitute a component for a
    newer version or even a completely new functionality without losing application
    functionality.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序分成多个部分进行管理，使我们能够用更新版本甚至完全新的功能替代一个组件，而不会丢失应用程序功能。
- en: Developers can focus on one particular application feature or functionality,
    and will just need to know how to interact with other, similar pieces.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以专注于某个特定的应用功能或特性，只需要知道如何与其他类似的部分交互。
- en: Microservices interaction will usually be effected using standard HTTP/HTTPS
    API **Representational State Transfer** (**REST**) calls. The objective of RESTful
    systems is to increase the speed of performance, reliability, and the ability
    to scale.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务之间的交互通常通过标准的 HTTP/HTTPS API **表述性状态转移**（**REST**）调用实现。RESTful 系统的目标是提高性能、可靠性以及可扩展性。
- en: Microservices are components that are prepared to have isolated life cycles.
    This means that one unhealthy component will not wholly affect application usage.
    We will provide resilience to each component, and an application will not have
    full outages.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是准备拥有独立生命周期的组件。这意味着一个不健康的组件不会完全影响应用程序的使用。我们将为每个组件提供弹性，并且应用程序不会发生完全的故障。
- en: Each microservice can be written in different programming languages, allowing
    us to choose the best one for maximum performance and portability.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务可以用不同的编程语言编写，这使我们能够选择最适合的语言，以获得最佳性能和可移植性。
- en: Now that we have briefly reviewed the well-known application architectures that
    have developed over the years, let's take a look at the concept of modern applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要回顾了多年来发展起来的著名应用架构，接下来让我们看看现代应用程序的概念。
- en: 'A modern application has the following features:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序具有以下特点：
- en: The components will be based on microservices.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些组件将基于微服务。
- en: The application component's health will be based on resilience.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序组件的健康状态将基于弹性。
- en: The component's states will be managed externally.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的状态将由外部管理。
- en: It will run everywhere.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将随处运行。
- en: It will be prepared for easy component updates.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将为组件的轻松更新做好准备。
- en: Each application component will be able to run on its own but will provide a
    way to be consumed by other components.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序组件将能够独立运行，但会提供一种与其他组件交互的方式。
- en: Let's take a look.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起来看看。
- en: Infrastructures
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施
- en: For every described application model that developers are using for their applications,
    we need to provide some aligned infrastructure architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员为其应用程序使用的每个描述的应用模型，我们需要提供一些协调一致的基础设施架构。
- en: On monolithic applications, as we have seen, all application functionalities
    run together. In some cases, applications were built for a specific architecture,
    operating system, libraries, binary versions, and so on. This means that we need
    at least one hardware node for production and the same node architecture, and
    eventually resources, for development. If we add the previous environments to
    this equation, such as certification or preproduction for performance testing,
    for example, the number of nodes for each application would be very important
    in terms of physical space, resources, and money spent on an application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用中，正如我们所看到的，所有应用功能都是一起运行的。在某些情况下，应用是为特定的架构、操作系统、库、二进制版本等构建的。这意味着我们至少需要一个硬件节点用于生产环境，并且需要相同的节点架构，最终还需要相同的资源来进行开发。如果将先前的环境（例如认证或预生产环境，用于性能测试）添加到这个方程中，每个应用所需的节点数量在物理空间、资源和应用所花费的资金上都会变得非常重要。
- en: For each application release, developers usually need to have a full production-like
    environment, meaning that only configurations will be different between environments.
    This is hard because when any operating system component or feature gets updated,
    changes must be replicated on all application environments. There are many tools
    to help us with these tasks, but it is not easy, and the cost of having almost-replicated
    environments is something to look at. And, on the other hand, node provision could
    take months because, in many cases, a new application release would mean having
    to buy new hardware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次应用发布，开发人员通常需要一个完整的生产环境，意味着只有配置在不同的环境之间会有所不同。这很困难，因为每当操作系统的组件或功能更新时，必须将这些更改复制到所有应用环境中。虽然有许多工具可以帮助我们完成这些任务，但这并不容易，而几乎完全复制的环境所带来的成本也是一个需要关注的问题。另一方面，节点的提供可能需要数月时间，因为在许多情况下，一个新的应用发布意味着必须购买新的硬件。
- en: Third-tier applications would usually be deployed on old infrastructures using
    application servers to allow application administrators to scale up components
    whenever possible and prioritize some components over others.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三层应用通常会部署在旧的基础设施上，使用应用服务器来允许应用管理员在可能的情况下扩展组件，并优先考虑某些组件。
- en: With virtual machines in our data centers, we were able to distribute host hardware
    resources between virtual nodes. This was a revolution in terms of node provision
    time and the costs of maintenance and licensing. Virtual machines worked very
    well on monolithic and third-tier applications, but application performance depends
    on the host shared resources that are applied to the virtual node. Deploying application
    components on different virtual nodes was a common use case because it allowed
    us to run these virtually everywhere. On the other hand, we were still dependent
    on operating system resources and releases, so building a new release was dependent
    on the operating system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据中心使用虚拟机后，我们能够在虚拟节点之间分配主机硬件资源。这在节点提供时间、维护成本和许可费用方面是一场革命。虚拟机在单体应用和第三层应用上表现得非常好，但应用性能取决于应用于虚拟节点的主机共享资源。将应用组件部署在不同的虚拟节点上是一个常见的用例，因为它使我们能够几乎在任何地方运行这些应用。另一方面，我们仍然依赖操作系统资源和版本，因此构建新版本仍然依赖于操作系统。
- en: From a developer's perspective, having different environments for building components,
    testing them side by side, and certificating applications became very easy. However,
    these new infrastructure components needed new administrators and efforts to provide
    nodes for development and deployment. In fast-growing enterprises with many changes
    in their applications, this model helps significantly in providing tools and environments
    to developers. However, agility problems persist when new applications have to
    be created weekly or if we need to accomplish many releases/fixes per day. New
    provisioning tools such as Ansible or Puppet allowed virtualization administrators
    to provide these nodes faster than ever, but as infrastructures grew, management
    became complicated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发人员的角度来看，拥有不同的环境来构建组件、并行测试它们以及对应用进行认证变得非常简单。然而，这些新的基础设施组件需要新的管理员，并且需要提供开发和部署所需的节点。在快速增长的企业中，应用程序经常发生变化，这种模型帮助开发人员提供工具和环境。然而，当新应用需要每周创建，或者我们需要每天完成大量版本发布/修复时，敏捷性问题依然存在。像Ansible或Puppet这样的新部署工具使虚拟化管理员能够比以往更快地提供这些节点，但随着基础设施的增长，管理变得更加复杂。
- en: Local data centers were rendered obsolete and although it took time, infrastructure
    teams started to use computer cloud providers. They started with a couple of services,
    such as **Infrastructure as a Service** (**IaaS**), that allowed us to deploy
    virtual nodes on the cloud as if they were on our data center. With new networking
    speeds and reliability, it was easy to start deploying our applications everywhere,
    data centers started to get smaller, and applications began to run on distributed
    environments on different cloud providers. For easy automation, cloud providers
    prepared their infrastructure's API for us, allowing users to deploy virtual machines
    in minutes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本地数据中心已经变得过时，尽管这花费了一些时间，但基础设施团队开始使用云计算提供商。他们从一些服务开始，比如**基础设施即服务**（**IaaS**），这使我们可以像在数据中心一样，在云上部署虚拟节点。随着新的网络速度和可靠性的出现，我们可以轻松地开始将应用程序部署到任何地方，数据中心变得越来越小，应用程序开始在不同云提供商的分布式环境中运行。为了简化自动化，云提供商为我们准备了基础设施的API，使用户能够在几分钟内部署虚拟机。
- en: However, as many virtualization options appeared, other options based on Linux
    kernel features and its isolation models came into being, reclaiming some old
    projects from the past, such as chroot and jail environments (quite common on
    **Berkeley Software Distribution** (**BSD**) operating systems) or Solaris zones.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着许多虚拟化选项的出现，基于Linux内核功能及其隔离模型的其他选项也应运而生，重新拾起一些过去的老项目，如chroot和监狱环境（在**伯克利软件分发版**（**BSD**）操作系统中相当常见）或Solaris
    zones。
- en: The concept of process containers is not new; in fact, it is more than 10 years
    old. Process containers were designed to isolate certain resources, such as CPU,
    memory, disk I/O, or the network, to a group of processes. This concept is what
    is now known as **control groups** (also known as **cgroups**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 进程容器的概念并不新鲜，事实上，它已经有超过10年的历史。进程容器的设计目的是将某些资源，如CPU、内存、磁盘I/O或网络，隔离到一组进程中。这一概念就是现在所称的**控制组**（也称为**cgroups**）。
- en: 'This following diagram shows a rough timeline regarding the introduction of
    containers to enterprise environments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了容器进入企业环境的大致时间线：
- en: '![](img/7a084f41-a694-415e-abb7-62f49b0094a6.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a084f41-a694-415e-abb7-62f49b0094a6.png)'
- en: A few years later, a container manager implementation was released to provide
    an easy way to control the usage of cgroups, while also integrating Linux namespaces.
    This project was named **Linux Containers** (**LXC**), is still available today,
    and was crucial for others in finding an easy way to improve process isolation
    usage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，发布了一种容器管理器实现，提供了一种便捷的方式来控制cgroups的使用，同时也整合了Linux命名空间。这个项目被命名为**Linux容器**（**LXC**），至今仍然可用，并且对于其他人来说，它为提高进程隔离使用提供了一个简单的解决方案。
- en: In 2013, a new vision of how containers should run on our environments was introduced,
    providing an easy-to-use interface for containers. It started with an open source
    solution, and Solomon Hykes, among others, started what became known as Docker,
    Inc. They quickly provided a set of tools for running, creating, and sharing containers
    with the community. Docker, Inc. started to grow very rapidly as containers became
    increasingly popular.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，关于容器如何在我们环境中运行的全新愿景被提出，提供了一个易于使用的容器接口。它从一个开源解决方案开始，Solomon Hykes等人启动了后来被称为Docker,
    Inc.的公司。他们迅速提供了一套工具，用于在社区中运行、创建和分享容器。随着容器的日益流行，Docker, Inc.迅速发展壮大。
- en: Containers have been a great revolution for our applications and infrastructures
    and we are going to explore this area further as we progress.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为我们的应用程序和基础设施带来了巨大的变革，随着我们深入探索这一领域，容器技术将继续发展。
- en: Processes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: A process is a way in which we can interact with an underlying operating system.
    We can describe a program as a set of coded instructions to execute on our system;
    a process will be that code in action. During process execution, it will use system
    resources, such as CPU and memory, and although it will run on its own environment,
    it can share information with another process that runs in parallel on the same
    system. Operating systems provide tools that allow us to manipulate the behavior
    of this process during execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是我们与底层操作系统交互的一种方式。我们可以将程序描述为一组在系统上执行的编码指令；而进程则是这些代码在执行过程中展现出来的形式。在进程执行过程中，它会使用系统资源，如CPU和内存，尽管它在自己的环境中运行，但它可以与在同一系统上并行运行的其他进程共享信息。操作系统提供了可以在执行过程中操作进程行为的工具。
- en: Each process in a system is identified uniquely by what is called the process
    identifier. Parent-child relations between processes are created when a process
    calls a new one during its execution. The second process becomes a subprocess
    of the first one (this is its child process) and we will have information regarding
    this relationship with what is called the parent PID.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每个进程都有一个唯一的标识符，称为进程标识符。进程之间的父子关系是在一个进程执行过程中调用另一个进程时创建的。第二个进程成为第一个进程的子进程（即其子进程），我们可以通过称为父
    PID 的信息获取到这一关系。
- en: Processes run because a user or other process launched it. This allows the system
    to know who launched that action, and the owner of that process will be known
    by their user ID. Effective ownership of child processes is implicit when the
    main process uses impersonation to create them. New processes will use the main
    process designated user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的运行是因为用户或其他进程启动了它。这使得系统能够知道是谁发起了该操作，且该进程的所有者会通过其用户 ID 被识别。当主进程使用假冒身份创建子进程时，子进程的有效所有权是隐式的。新进程将使用主进程指定的用户。
- en: For interaction with the underlying system, each process runs with its own environment
    variables and we can also manipulate this environment with the built-in features
    of the operating system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与底层系统进行交互，每个进程都带有自己的环境变量，并且我们也可以使用操作系统的内建功能来操控这个环境。
- en: Processes can open, write, and close files as needed and use pointers to descriptors
    during execution for easy access to this filesystem's resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以根据需要打开、写入和关闭文件，并在执行过程中使用描述符指针，以便轻松访问文件系统的资源。
- en: All processes running on a system are managed by operating system kernels and
    have also been scheduled on CPU by the kernel. The operating system kernel will
    be responsible for providing system resources to process and interact with system
    devices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中运行的所有进程都由操作系统内核进行管理，并且已由内核安排在 CPU 上执行。操作系统内核负责为进程提供系统资源并与系统设备进行交互。
- en: To summarize, we can say that the kernel is the part of the operating system
    that interfaces with host hardware, using different forms of isolation for operating
    system processes under the definition of **kernel space**. Other processes will
    run under the definition of **user space**. Kernel space has a higher priority
    for resources and manages user space.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以说内核是操作系统的一部分，负责与主机硬件进行交互，并在**内核空间**定义下，使用不同形式的隔离来管理操作系统进程。其他进程则运行在**用户空间**的定义下。内核空间拥有更高的资源优先级并管理用户空间。
- en: These definitions are common to all modern operating systems and will be crucial
    in understanding containers. Now that we know how processes are identified and
    that there is isolation between the system and its users, we can move on to the
    next section and understand how containers match microservices programming.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义是所有现代操作系统共有的，并且在理解容器时至关重要。现在我们知道了进程是如何被识别的，并且系统与其用户之间有隔离，我们可以进入下一部分，了解容器如何与微服务编程匹配。
- en: Microservices and processes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与进程
- en: So far, we have briefly reviewed a number of different application models (monolith,
    SOAP, and the new microservices architecture) and we have defined microservices
    as the minimum piece of software with functionality that we can build as a component
    for an application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们简要回顾了几种不同的应用模型（单体应用、SOAP 以及新的微服务架构），并将微服务定义为我们可以作为应用组件构建的最小功能软件单元。
- en: With this definition, we will associate a microservice with a process. This
    is the most common way of running microservices. A process with full functionality
    can be described as a microservice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，我们将一个微服务与一个进程关联起来。这是运行微服务最常见的方式。一个具有完整功能的进程可以被描述为一个微服务。
- en: An application is composed of microservices, and hence processes, as expected.
    The interaction between them will usually be made using HTTP/HTTPS/API REST.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序由微服务组成，因此也由进程组成。它们之间的交互通常通过 HTTP/HTTPS/API REST 来进行。
- en: This is, of course, a definition, but we recommend this approach to ensure proper
    microservice health management.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个定义，但我们推荐这种方法，以确保正确的微服务健康管理。
- en: What are containers?
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: So far, we have defined microservices and how processes fit in this model. As
    we saw previously, containers are related to process isolation. We will define
    a container as a process with all its requirements isolated with kernel features.
    This package-like object will contain all the code and its dependencies, libraries,
    binaries, and settings that are required to run our process. With this definition,
    it is easy to understand why containers are so popular in microservices environments,
    but, of course, we can execute microservices without containers. On the contrary,
    we can run containers with a full application, with many processes that don't
    need to be isolated from each other inside this package-like object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了微服务以及进程如何适应这个模型。如前所述，容器与进程隔离有关。我们将容器定义为一个进程，它的所有需求都通过内核特性进行隔离。这个类似包的对象将包含运行我们的进程所需的所有代码及其依赖项、库、二进制文件和设置。凭借这个定义，我们很容易理解为什么容器在微服务环境中如此流行，但当然，我们也可以在没有容器的情况下执行微服务。相反，我们可以在一个完整的应用程序中运行容器，容器内部有许多进程，它们不需要在这个类似包的对象中相互隔离。
- en: In terms of multi-process containers, what is the difference between a virtual
    machine and containers? Let's review container features against virtual machines.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在多进程容器方面，虚拟机和容器之间有什么区别？让我们对比一下容器和虚拟机的特点。
- en: Containers are mainly based on cgroups and kernel namespaces.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器主要基于cgroups和内核命名空间（kernel namespaces）。
- en: Virtual machines, on the other hand, are based on hypervisor software. This
    software, which can run as part of the operating system in many cases, will provide
    sandboxed resources to the guest virtualized hardware that runs a virtual machine
    operating system. This means that each virtual machine will run its own operating
    system and allow us to execute different operating systems on the same hardware
    host. When virtual machines arrived, people started to use them as sandboxed environments
    for testing, but as hypervisors gained in maturity, data centers started to have
    virtual machines in production, and now this is common and standard practice in
    cloud providers (cloud providers currently offer hardware as a service, too).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，虚拟机基于虚拟机监控程序（hypervisor）软件。这个软件，在许多情况下可以作为操作系统的一部分运行，将为运行虚拟机操作系统的客虚拟化硬件提供沙箱式资源。这意味着每个虚拟机将运行自己的操作系统，并允许我们在同一硬件主机上执行不同的操作系统。虚拟机出现时，人们开始将它们用作沙箱环境进行测试，但随着虚拟机监控程序的成熟，数据中心开始在生产环境中使用虚拟机，现在云服务提供商也普遍采用这种做法（云服务提供商目前也提供硬件即服务）。
- en: 'In this schema, we''re showing the different logic layers, beginning with the
    machine hardware. We will have many layers for executing a process inside virtual
    machines. Each virtual machine will have its own operating system and services,
    even if we are just running a single process:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个架构中，我们展示了不同的逻辑层次，从机器硬件开始。执行虚拟机中的进程将有许多层次。每个虚拟机将拥有自己的操作系统和服务，即使我们仅仅运行一个单一的进程：
- en: '![](img/90237020-cbfc-4a3d-b539-b736f91d5177.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90237020-cbfc-4a3d-b539-b736f91d5177.png)'
- en: Each virtual machine will get a portion of resources and guest operating systems,
    and the kernel will manage how they are shared among different running processes.
    Each virtual machine will execute its own kernel and the operating system running
    on top of those of the host. There is complete isolation between the guest operating
    systems because hypervisor software will keep them separated. On the other hand,
    there is an overhead associated with running multiple operating systems side by
    side and when microservices come to mind, this solution wastes numerous host resources.
    Just running the operating system will consume a lot of resources. Even the fastest
    hardware nodes with fast SSD disks require resources and time to start and stop
    virtual machines. As we have seen, microservices are just a process with complete
    functionality inside an application, so running the entire operating system for
    just a couple of processes doesn't seem like a good idea.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟机将获得一部分资源和客操作系统，内核将管理如何在不同的运行进程之间共享这些资源。每个虚拟机将执行自己的内核，并运行在主机内核之上的操作系统。由于虚拟机监控程序软件将它们隔离开，因此客操作系统之间是完全隔离的。另一方面，运行多个操作系统并行会带来开销，而当考虑到微服务时，这种解决方案浪费了大量主机资源。仅仅启动操作系统就会消耗大量资源。即使是最快的硬件节点和快速的SSD硬盘，也需要资源和时间来启动和停止虚拟机。正如我们所见，微服务只是一个具有完整功能的进程，因此仅为少数进程运行整个操作系统似乎不是一个好主意。
- en: On each guest host, we need to configure everything needed for our microservice.
    This means access, users, configurations, networking, and more. In fact, we need
    administrators for these systems as if they were bare-metal nodes. This requires
    a significant amount of effort and is the reason why configuration management
    tools are so popular these days. Ansible, Puppet, Chef, and SaltStack, among others,
    help us to homogenize our environments. However, remember that developers need
    their own environments, too, so multiply these resources by all the required environments
    in the development pipeline.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个宿主机上，我们需要为微服务配置一切所需的内容。这意味着访问、用户、配置、网络等。事实上，我们需要为这些系统配置管理员，就像它们是裸机节点一样。这需要大量的工作，这也是配置管理工具如此流行的原因。Ansible、Puppet、Chef
    和 SaltStack 等工具帮助我们统一环境。然而，记住开发人员也需要自己的环境，因此需要将这些资源乘以开发流水线中所有所需的环境数量。
- en: How can we scale up on service peaks? Well, we have virtual machine templates
    and, currently, almost all hypervisors allow us to interact with them using the
    command line or their own administrative API implementations, so it is easy to
    copy or clone a node for scaling application components. But this will require
    double the resources – remember that we will run another complete operating system
    with its own resources, filesystems, network, and so on. Virtual machines are
    not the perfect solution for elastic services (which can scale up and down, run
    everywhere, and are created on-demand in many cases).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在服务高峰期进行扩展？好吧，我们有虚拟机模板，目前几乎所有的虚拟机监控程序都允许我们通过命令行或它们自己的管理 API 实现与之交互，因此很容易复制或克隆节点以扩展应用组件。但这将需要双倍的资源——记住我们将运行另一个完整的操作系统，其自身的资源、文件系统、网络等。虚拟机并不是弹性服务（可以扩展、缩放、到处运行并且在许多情况下按需创建）的完美解决方案。
- en: Containers will share the same kernel because they are just isolated processes.
    We will just add a templated filesystem and resources (CPU, memory, disk I/O,
    network, and so on, and, in some cases, host devices) to a process. It will run
    sandboxed inside and will only use its defined environment. As a result, containers
    are lightweight and start and stop as fast as their main processes. In fact, containers
    are as lightweight as the processes they run, since we don't have anything else
    running inside a container. All the resources that are consumed by a container
    are process-related. This is great in terms of hardware resource allocation. We
    can find out the real consumption of our application by observing the load of
    all of its microservices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将共享相同的内核，因为它们只是隔离的进程。我们只需为进程添加一个模板化的文件系统和资源（如 CPU、内存、磁盘 I/O、网络等，有时还包括主机设备）。它将在沙箱内运行，并仅使用其定义的环境。因此，容器是轻量级的，启动和停止速度与其主进程一样快。事实上，容器和它们运行的进程一样轻量，因为容器内没有其他东西在运行。容器消耗的所有资源都是与进程相关的。这在硬件资源分配方面非常好。我们可以通过观察所有微服务的负载来了解我们应用程序的实际消耗情况。
- en: Containers are a perfect solution for microservices as they will run only one
    process inside. This process should have all the required functionality for a
    specific task, as we described in terms of microservices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是微服务的完美解决方案，因为它们只会在内部运行一个进程。该进程应具备执行特定任务所需的所有功能，正如我们在微服务中描述的那样。
- en: Similar to virtual machines, there is the concept of a template for container
    creation called Image. Docker images are standard for many container runtimes.
    They ensure that all containers that are created from a container image will run
    with the same properties and features. In other words, this eliminates the *it
    works on my computer!* problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于虚拟机，容器创建也有一个名为镜像的模板概念。Docker 镜像是许多容器运行时的标准。它们确保所有从容器镜像创建的容器都将以相同的属性和功能运行。换句话说，这消除了
    *在我的电脑上能运行！* 的问题。
- en: Docker containers improve security in our environments because they are secure
    by default. Kernel isolation and the kind of resources managed inside containers
    provide a secure environment during execution. There are many ways to improve
    this security further, as we will see in the following chapters. By default, containers
    will run with a limited set of system calls allowed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器通过默认安全性提高了我们环境的安全性。内核隔离和容器内管理的资源类型为执行提供了一个安全的环境。我们可以通过接下来的章节进一步了解如何增强这种安全性。默认情况下，容器将仅允许有限的系统调用。
- en: 'This schema describes the main differences between running processes on different
    virtual machines and using containers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个架构描述了在不同虚拟机上运行进程与使用容器之间的主要区别：
- en: '![](img/24bca328-db2b-4fa0-9d47-42caa9b18020.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24bca328-db2b-4fa0-9d47-42caa9b18020.png)'
- en: Containers are faster to deploy and manage, lightweight, and secure by default.
    Because of their speed upon execution, containers are aligned with the concept
    of resilience. And because of the package-like environment, we can run containers
    everywhere. We only need a container runtime to execute deployments on any cloud
    provider, as we do on our data centers. The same concept will be applied to all
    development stages, so integration and performance tests can be run with confidence.
    If the previous tests were passed, since we are using the same artifact across
    all stages, we can ensure its execution in production.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的部署和管理速度更快，轻量且默认安全。由于容器在执行时的速度，容器与**弹性**的概念高度契合。由于其类似软件包的环境，我们可以在任何地方运行容器。我们只需要一个容器运行时来执行任何云服务提供商上的部署，就像我们在数据中心中所做的那样。这个概念将应用于所有开发阶段，因此可以放心地进行集成和性能测试。如果前面的测试通过了，由于我们在所有阶段使用相同的工件，我们可以确保它在生产环境中的执行。
- en: In the following chapters, we will dive deep into Docker container components.
    For now, however, just think of a Docker container as a sandboxed process that
    runs in our system, isolated from all other running processes on the same host,
    based on a template named Docker Image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨 Docker 容器的组件。不过，目前请将 Docker 容器视为一个沙箱化的进程，它在我们的系统中运行，与同一主机上所有其他正在运行的进程隔离，并且基于一个名为
    Docker 镜像的模板。
- en: Learning about the main concepts of containers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习容器的主要概念
- en: When talking about containers, we need to understand the main concepts behind
    the scenes. Let's decouple the container concept into different pieces and try
    to understand each one in turn.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 说到容器时，我们需要理解其背后的主要概念。让我们将容器的概念分解成不同的部分，逐一尝试理解每个部分。
- en: Container runtime
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器运行时
- en: The runtime for running containers will be the software and operating system
    features that make process execution and isolation possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器的运行时将是使进程执行和隔离成为可能的软件和操作系统功能。
- en: Docker, Inc. provides a container runtime named Docker, based on open source
    projects sponsored by them and other well-known enterprises that empower container
    movement (Red Hat/IBM and Google, among many others). This container runtime comes
    packaged with other components and tools. We will analyze each one in detail in
    the *Docker components* section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker, Inc. 提供了一种名为 Docker 的容器运行时，基于由他们和其他知名企业（如 Red Hat/IBM 和 Google 等）赞助的开源项目，推动容器技术的发展。这个容器运行时与其他组件和工具一起打包。我们将在*Docker
    组件*部分详细分析每个组件。
- en: Images
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像
- en: We use images as templates for creating containers. Images will contain everything
    required by our process or processes to run correctly. These components can be
    binaries, libraries, configuration files, and so on that can be a part of operating
    system files or just components built by yourself for this application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用镜像作为创建容器的模板。镜像将包含我们的进程或多个进程正确运行所需的一切。这些组件可以是二进制文件、库、配置文件等，它们可以是操作系统文件的一部分，也可以是为该应用程序专门构建的组件。
- en: Images, like templates, are immutable. This means that they don't change between
    executions. Every time we use an image, we will get the same results. We will
    only change configuration and environment to manage the behavior of different
    processes between environments. Developers will create their application component
    template and they can be sure that if the application passed all the tests, it
    will work in production as expected. These features ensure faster workflows and
    less time to market.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像就像模板一样是不可变的。这意味着它们在执行过程中不会改变。每次使用镜像时，我们都会得到相同的结果。我们只会更改配置和环境，以管理不同环境中进程的行为。开发人员将创建自己的应用程序组件模板，他们可以确保如果应用程序通过了所有测试，它将在生产环境中按预期工作。这些特性确保了更快的工作流程和更短的市场投放时间。
- en: Docker images are built up from a series of layers, and all these layers packaged
    together contain everything required for running our application process. All
    these layers are read-only and the changes are stored in the next upper layer
    during image creation. This way, each layer only has a set of differences from
    the layer before it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是由一系列层构建而成的，这些层打包在一起，包含了运行我们应用程序进程所需的一切。这些层都是只读的，修改内容会在创建镜像时存储在上面的层中。这样，每一层只包含与前一层的差异。
- en: Layers are packaged to allow ease of transport between different systems or
    environments, and they include meta-information about the required architecture
    to run (will it run on Linux or Windows, or does it require an ARM processor,
    for example?). Images include information about how the process should be run,
    which user will execute the main process, where persistent data will be stored,
    what ports your process will expose in order to communicate with other components
    or users, and more.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 层是经过打包的，以便在不同的系统或环境之间轻松传输，并且它们包含关于运行所需架构的元信息（例如，它是否可以在Linux或Windows上运行，或者是否需要ARM处理器等）。镜像包含有关如何运行进程的信息，包括哪个用户将执行主进程、持久数据将存储的位置、您的进程将暴露哪些端口以便与其他组件或用户通信等。
- en: 'Images can be built with reproducible methods using Dockerfiles or store changes
    made on running containers to obtain a new image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以通过可重现的方法使用Dockerfile构建，或者通过存储在运行容器中的更改来获得新镜像：
- en: '![](img/ff4eb34d-600f-4247-b621-7c868bc877b1.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff4eb34d-600f-4247-b621-7c868bc877b1.png)'
- en: This was a quick review of images. Now, let's take a look at containers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对镜像的简要回顾。现在，让我们来看一下容器。
- en: Containers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: 'As we described earlier, a container is a process with all its requirements
    that runs separately from all the other processes running on the same host. Now
    that we know what templates are, we can say that containers are created using
    images as templates. In fact, a container adds a new read-write layer on top of
    image layers in order to store filesystem differences from these layers. The following
    diagram represents the different layers involved in container execution. As we
    can observe, the top layer is what we really call the container because it is
    read-write and allows changes to be stored on the host disk:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，容器是一个独立运行的进程，它包含所有所需的资源，并与在同一主机上运行的其他进程相互隔离。现在我们了解了模板是什么，我们可以说容器是使用镜像作为模板创建的。实际上，容器在镜像层之上添加了一个新的读写层，用于存储与这些镜像层的文件系统差异。下图表示了容器执行过程中涉及的不同层次。正如我们所观察到的，最上面的一层才是我们真正称之为容器的部分，因为它是读写的，并允许将更改存储到主机磁盘上：
- en: '![](img/d56a8c6f-8016-41da-b0a7-7a1df1d9ecfa.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d56a8c6f-8016-41da-b0a7-7a1df1d9ecfa.png)'
- en: All image layers are read-only layers, which means all the changes are stored
    in the container's read-write layer. This means that all these changes will be
    lost when we remove a container from a host, but the image will remain until we
    remove it. Images are immutable and always remain unchanged.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有镜像层都是只读层，这意味着所有的更改都存储在容器的读写层中。这意味着，当我们从主机中移除容器时，这些更改将会丢失，但镜像会一直保留，直到我们将其移除。镜像是不可变的，始终保持不变。
- en: 'This container behavior lets us run many containers using the same underlying
    image, and each one will store changes on its own read-write layer. The following
    diagram represents how different images will use the same image layers. All three
    containers are based on the same image:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种容器行为使我们能够使用相同的基础镜像运行多个容器，每个容器将在自己的读写层上存储更改。下图表示了不同的镜像如何使用相同的镜像层。所有三个容器都基于相同的镜像：
- en: '![](img/65827040-d4ff-4669-b122-aa61240f621a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65827040-d4ff-4669-b122-aa61240f621a.png)'
- en: There are different approaches to managing image layers when building and container
    layers on execution. Docker uses storage drivers to manage this content, on read-only
    layers and read-write ones. These drivers are operating system-dependent, but
    they all implement what is known as copy-on-write filesystems.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像和容器层执行时，有不同的方法来管理镜像层。Docker使用存储驱动程序来管理这些内容，包括只读层和读写层。这些驱动程序依赖于操作系统，但它们都实现了所谓的写时复制文件系统。
- en: A storage driver (known as **graph-driver**) will manage how Docker will store
    and manage the interactions between layers. As we mentioned previously, there
    are different drivers integrations available, and Docker will choose the best
    one for your system, depending on your host's kernel and operating system. **Overlay2**
    is the most common and preferred driver for Linux operating systems. Others, such
    as aufs, overlay, and btfs, among others, are also available, but keep in mind
    that overlay2 is recommended for production environments on modern operating systems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存储驱动程序（称为**graph-driver**）将管理Docker如何存储和管理层之间的交互。正如我们之前提到的，有不同的驱动程序集成可供选择，Docker将根据主机的内核和操作系统选择最佳的驱动程序。**Overlay2**是Linux操作系统中最常见和推荐的驱动程序。其他驱动程序，如aufs、overlay和btfs等，也可用，但请记住，overlay2被推荐用于现代操作系统中的生产环境。
- en: 'Devicemapper is also a supported graph driver and it was very common on Red
    Hat environments before overlay2 was supported on modern operating system releases
    (Red Hat 7.6 and above). Devicemapper uses block devices for storing layers and
    can be deployed in observance of two different strategies: `loopback-lvm` (by
    default and only for testing purposes) and `direct-lvm` (requires additional block
    device pool configurations and is intended for production environments). This
    link provides the required steps for deploying: `direct-lvm`: [https://docs.docker.com/storage/storagedriver/device-mapper-driver/](https://docs.docker.com/storage/storagedriver/device-mapper-driver/)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Devicemapper 也是一种受支持的图形驱动程序，在现代操作系统版本（Red Hat 7.6 及以上）支持 overlay2 之前，它在 Red
    Hat 环境中非常常见。Devicemapper 使用块设备来存储层，并且可以采用两种不同的策略进行部署：`loopback-lvm`（默认且仅用于测试目的）和
    `direct-lvm`（需要额外的块设备池配置，适用于生产环境）。以下链接提供了部署 `direct-lvm` 所需的步骤：[https://docs.docker.com/storage/storagedriver/device-mapper-driver/](https://docs.docker.com/storage/storagedriver/device-mapper-driver/)
- en: As you may have noticed, using copy-on-write filesystems will make containers
    very small in terms of disk space usage. All common files are shared between the
    same image-based containers. They just store differences from immutable files
    that are part of image layers. Consequently, container layers will be very small
    (of course, this depends on what you are storing on containers, but keep in mind
    that good containers are small). When an existing file in a container has to be
    modified (remember a file that comes from underlying layers), the storage driver
    will perform a copy operation to the container layer. This process is fast, but
    keep in mind that everything that is going to be changed on containers will follow
    this process. As a reference, don't use copy-on-write with heavy I/O operations,
    nor process logs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，使用写时复制文件系统将使容器在磁盘空间使用上非常小。所有常见文件在相同的基于镜像的容器之间是共享的。它们只存储与不可变文件的差异，而这些不可变文件是镜像层的一部分。因此，容器层会非常小（当然，这取决于你在容器中存储的内容，但请记住，好的容器应该很小）。当容器中的现有文件必须被修改时（记住这些文件来自底层层），存储驱动程序会对容器层执行复制操作。这个过程很快，但请记住，容器中所有要更改的内容都将遵循这个过程。作为参考，不要在重
    I/O 操作或进程日志中使用写时复制。
- en: Copy-on-write is a strategy for creating maximum efficiency and small layer-based
    filesystems. This storage strategy works by copying files between layers. When
    a layer needs to change a file from another underlaying layer, it will be copied
    to this top one. If it just needs read access, it will use it from underlying
    layers. This way, I/O access is minimized and the size of the layers is very small.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 写时复制（Copy-on-write）是一种用于创建最大效率和小型层级文件系统的策略。该存储策略通过在层之间复制文件来工作。当某一层需要更改来自另一层的文件时，它会被复制到该层顶部。如果只是需要读取访问，它将使用来自底层层的文件。通过这种方式，I/O
    访问被最小化，层的大小也非常小。
- en: A common question that many people ask is whether containers are ephemeral.
    The short answer is *no*. In fact, containers are not ephemeral for a host. This
    means that when we create or run a container on that host, it will remain there
    until someone removes it. We can start a stopped container on the same host if
    it is not deleted yet. Everything that was inside this container before will be
    there, but it is not a good place to store process state because it is only local
    to that host. If we want to be able to run containers everywhere and use orchestration
    tools to manage their states, processes must use external resources to store their
    status.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人常问的一个问题是容器是否是临时性的。简短的回答是*不是*。实际上，容器对主机来说并不是临时性的。这意味着当我们在该主机上创建或运行一个容器时，它将一直存在，直到有人将其删除。如果容器没有被删除，我们可以在同一主机上重新启动已停止的容器。容器中以前的所有内容都会保留，但它不是一个存储进程状态的好地方，因为它只对该主机本地有效。如果我们希望能够在任何地方运行容器并使用编排工具来管理它们的状态，进程必须使用外部资源来存储其状态。
- en: As we'll see in later chapters, Swarm or Kubernetes will manage service or application
    component status and, if a required container fails, it will create a new container.
    Orchestration will create a new container instead of reusing the old one because,
    in many cases, this new process will be executed elsewhere in the clustered pool
    of hosts. So, it is important to understand that your application components that
    will run as containers must be logically ephemeral and that their status should
    be managed outside containers (database, external filesystem, inform other services,
    and so on).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在后续章节中将看到的，Swarm 或 Kubernetes 将管理服务或应用程序组件的状态，如果所需的容器失败，它将创建一个新的容器。编排将创建一个新容器，而不是重用旧容器，因为在许多情况下，这个新进程会在集群池中的其他主机上执行。因此，理解你的应用程序组件将在容器中运行时必须是逻辑上短暂的，并且它们的状态应由容器之外的机制管理（如数据库、外部文件系统、通知其他服务等）是很重要的。
- en: The same concept will be applied in terms of networking. Usually, you will let
    a container runtime or orchestrator manage container IP addresses for simplicity
    and dynamism. Unless strictly necessary, don't use fixed IP addresses, and let
    internal IPAMs configure them for you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念也适用于网络。通常，你会让容器运行时或编排器管理容器的 IP 地址，以简化和动态化操作。除非绝对必要，否则不要使用固定的 IP 地址，而是让内部
    IPAM 来为你配置它们。
- en: Networking in containers is based on host bridge interfaces and firewall-level
    NAT rules. A Docker container runtime will manage the creation of virtual interfaces
    for containers and process isolation between different logical networks creating
    mentioned rules. We will see all the network options provided and their use cases
    in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml), *Container Persistency
    and Networking*. In addition, publishing an application is managed by the runtime
    and orchestration will add different properties and many other options.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的网络是基于主机桥接接口和防火墙级别的 NAT 规则。Docker 容器运行时会管理容器虚拟接口的创建，以及在不同逻辑网络之间进行进程隔离，创建上述规则。我们将在[第4章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)中看到所有提供的网络选项及其使用案例，*容器持久性与网络*。此外，发布应用程序是由运行时管理的，编排将添加不同的属性和许多其他选项。
- en: Using volumes will let us manage the interaction between the process and the
    container filesystem. Volumes will bypass the copy-on-write filesystem and hence
    writing will be much faster. In addition to this, data stored in a volume will
    not follow the container life cycle. This means that even if we delete the container
    that was using that volume, all the data that was stored there will remain until
    someone deletes it. We can define a volume as the mechanism we will use to persist
    data between containers. We will learn that volumes are an easy way to share data
    between containers and deploy applications that need to persist their data during
    the life of the application (for example, databases or static content). Using
    volumes will not increase container layer size, but using them locally will require
    additional host disk resources under the Docker filesystem/directory tree.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用卷可以帮助我们管理进程与容器文件系统之间的交互。卷会绕过写时复制文件系统，因此写入操作会更快。除此之外，存储在卷中的数据不会随着容器的生命周期而改变。这意味着，即使我们删除了正在使用该卷的容器，存储在其中的所有数据仍然会保留，直到有人删除它。我们可以将卷定义为在容器之间持久化数据的机制。我们将了解到，卷是容器之间共享数据的简单方式，并且可以部署需要在应用程序生命周期内持久化数据的应用程序（例如，数据库或静态内容）。使用卷不会增加容器的层大小，但在本地使用它们时，需要额外的主机磁盘资源，这些资源位于
    Docker 文件系统/目录树下。
- en: Process isolation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程隔离
- en: 'As we mentioned previously, a kernel provides namespaces for process isolation.
    Let''s review what each namespace provides. Each container runs with its own kernel
    namespaces for the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，内核提供了进程隔离的命名空间。让我们回顾一下每个命名空间提供的内容。每个容器都有自己的内核命名空间，涉及以下方面：
- en: '**Processes**: The main process will be the parent of all other ones within
    the container.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**：主进程将成为容器内所有其他进程的父进程。'
- en: '**Network**: Each container will get its own network stack with its own interfaces
    and IP addresses and will use host interfaces.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：每个容器将拥有自己的网络栈，配备自己的接口和 IP 地址，并将使用主机接口。'
- en: '**Users**: We will be able to map container user IDs with different host user
    IDs.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：我们可以将容器的用户ID映射到不同的主机用户ID。'
- en: '**IPC**: Each container will have its own shared memory, semaphores, and message
    queues without conflicting other processes on the host.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPC**：每个容器将拥有自己的共享内存、信号量和消息队列，不会与主机上的其他进程发生冲突。'
- en: '**Mounts**: Each container will have its own root filesystem and we can provide
    external mounts, which we will learn about in upcoming chapters.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：每个容器将拥有自己的根文件系统，我们可以提供外部挂载，关于这一点我们将在接下来的章节中学习。'
- en: '**UTS**: Each container will get its own hostname and time will be synced with
    the host.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UTS**：每个容器将拥有自己的主机名，且时间将与主机同步。'
- en: 'The following diagram represents a process tree from the host perspective and
    inside a container. Processes inside a container are namespaced and, as a result,
    their parent PID will be the main process, with its own PID of 1:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示表示了从主机角度和容器内部的进程树。容器内部的进程是命名空间化的，因此，它们的父进程PID将是主进程，且PID为1：
- en: '![](img/e1385aa3-f6dd-4342-b1f1-2ffececa05e0.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1385aa3-f6dd-4342-b1f1-2ffececa05e0.jpg)'
- en: Namespaces have been available in Linux since version 2.6.26 (July 2008), and
    they provide the first level of isolation for a process running within a container
    so that it won't see others. This means they cannot affect other processes running
    on the host or in any other container. The maturity level of these kernel features
    allows us to trust in Docker namespace isolation implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间自Linux 2.6.26版本（2008年7月）以来就已经可用，它为容器内运行的进程提供了第一层隔离，使其无法看到其他进程。这意味着它们无法影响主机或其他容器中运行的进程。这些内核功能的成熟度使我们能够信任Docker命名空间隔离的实现。
- en: Networking is isolated too, as each container gets its own network stack, but
    communications will pass through host bridge interfaces. Every time we create
    a Docker network for containers, we will create a new network bridge, which we
    will learn more about in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*. This means that containers sharing a network,
    which is a host bridge interface, will see one another, but all other containers
    running on a different interface will not have access to them. Orchestration will
    add different approaches to container runtime networking but, at the host level,
    described rules are applied.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 网络也是隔离的，因为每个容器都有自己的网络栈，但通信会通过主机桥接接口。每当我们为容器创建Docker网络时，我们会创建一个新的网络桥接，这一点我们将在[第4章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)，*容器持久性和网络*中进一步学习。这意味着共享同一网络（即主机桥接接口）的容器将能彼此看到，但所有在不同接口上运行的容器将无法访问它们。编排将为容器运行时网络提供不同的处理方法，但在主机层面，已描述的规则将被应用。
- en: Host resources available to a container are managed by control groups. This
    isolation will not allow a container to bring down a host by exhausting its resources.
    You should not allow containers with non-limited resources in production. This
    must be mandatory in multi-tenant environments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可用的主机资源由控制组管理。这种隔离将不允许容器通过耗尽资源使主机崩溃。在生产环境中，您不应允许资源无限制的容器。此项在多租户环境中必须强制执行。
- en: Orchestration
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编排
- en: This book contains a general chapter about orchestration, [Chapter 7](3b13261c-9b4d-46e2-b115-fc323563f646.xhtml),
    *Introduction to Orchestration*, and two specific chapters devoted to Swarm and
    Kubernetes, respectively, [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*, and [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml),
    *Orchestration Using Kubernetes*. Orchestration is the mechanism that will manage
    container interactions, publishing, and health in clustered pools of hosts. It
    will allow us to deploy an application based on many components or containers
    and keep it healthy during its entire life cycle. With orchestration, component
    updates are easy because it will take care of the required changes in the platform
    to accomplish a new, appropriate state.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含了关于编排的一般章节，[第7章](3b13261c-9b4d-46e2-b115-fc323563f646.xhtml)，*编排简介*，以及两章分别专门讲解Swarm和Kubernetes，[第8章](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml)，*使用Docker
    Swarm进行编排*，和[第9章](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml)，*使用Kubernetes进行编排*。编排是管理容器交互、发布和集群池主机健康状况的机制。它将允许我们基于多个组件或容器部署应用程序，并在整个生命周期内保持其健康。通过编排，组件更新变得容易，因为它会负责在平台中进行必要的更改，以实现新的、合适的状态。
- en: Deploying an application using orchestration will require a number of instances
    for our process or processes, the expected state, and instructions for managing
    its life during execution. Orchestration will provide new objects, communication
    between containers running on different hosts, features for running containers
    on specific nodes within the cluster, and the mechanisms to keep the required
    number of process replicas alive with the desired release version.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编排部署应用程序将需要多个实例来运行我们的进程，定义预期的状态，并在执行过程中管理其生命周期。编排将提供新的对象，容器间的通信，运行在集群中特定节点上的容器功能，以及保持所需进程副本数和所需发布版本的机制。
- en: Swarm is included inside Docker binaries and comes as standard. It is easy to
    deploy and manage. Its unit of deployment is known as a **service**. In a Swarm
    environment, we don't deploy containers because containers are not managed by
    orchestration. Instead, we deploy services and those services will be represented
    by tasks, which will run containers to maintain its state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 包含在 Docker 二进制文件中，并作为标准功能提供。它易于部署和管理。它的部署单元被称为**服务**。在 Swarm 环境中，我们不直接部署容器，因为容器并不是由编排管理的。相反，我们部署服务，这些服务将通过任务来表示，任务会运行容器以维持其状态。
- en: Currently, Kubernetes is the most widely used form of orchestration. It requires
    extra deployment effort using a Docker community container runtime. It adds many
    features, multi-container objects known as **pods** that share a networking layer,
    and flat networking for all orchestrated pods, among other things. Kubernetes
    is community-driven and evolves very fast. One of the features that makes this
    platform so popular is the availability to create your own kind of resources,
    allowing us to develop new extensions when they are not available.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Kubernetes 是最广泛使用的编排形式。它需要额外的部署工作，使用 Docker 社区容器运行时。它增加了许多功能，包括共享网络层的多容器对象，称为**Pod**，以及为所有编排的
    Pod 提供的扁平化网络等。Kubernetes 是由社区驱动的，发展非常迅速。使这个平台如此受欢迎的一个特点是能够创建自己的资源类型，当所需资源不可用时，我们可以开发新的扩展功能。
- en: We will analyze the features of pods and Kubernetes in detail in [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml),
    *Orchestration Using Kubernetes*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml)《使用 Kubernetes 进行编排》中详细分析
    Pod 和 Kubernetes 的功能。
- en: Docker Enterprise provides orchestrators deployed under Universal Control Plane
    with high availability on all components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise 提供了在“统一控制平面”下部署的高可用性编排器，确保所有组件的高可用性。
- en: Registry
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像仓库
- en: We have already learned that containers execute processes within an isolated
    environment, created from a template image. So, the only requirements for deploying
    that container on a new node will be the container runtime and the template used
    to create that container. This template can be shared between nodes using simple
    Docker command options. But this procedure can become more difficult as the number
    of nodes grows. To improve image distribution, we will use image registries, which
    are storage points for these kinds of objects. Each image will be stored in its
    own repository. This concept is similar to code repositories, allowing us to use
    tags to describe these images, aligning code releases with image versioning.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，容器在一个隔离的环境中执行进程，该环境是通过模板镜像创建的。因此，将容器部署到新节点上的唯一要求是容器运行时和用于创建该容器的模板。这个模板可以通过简单的
    Docker 命令选项在节点之间共享。但随着节点数量的增加，这个过程可能会变得更加复杂。为了改善镜像分发，我们将使用镜像仓库，它们是这些对象的存储点。每个镜像将存储在自己的仓库中。这个概念类似于代码仓库，允许我们使用标签来描述这些镜像，从而将代码发布与镜像版本管理对齐。
- en: An application deployment pipeline has different environments, and having a
    common point of truth between them will help us to manage these objects through
    the different workflow stages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序部署流水线有不同的环境，确保它们之间有一个共同的真实点将帮助我们在不同的工作流阶段管理这些对象。
- en: 'Docker provides two different approaches for registry: the community version
    and Docker Trusted Registry. The community version does not provide any security
    at all, nor role-based access to image repositories. On the other hand, Docker
    Trusted Registry comes with the Docker Enterprise solution and is an enterprise-grade
    registry, with included security, image vulnerability scanning, integrated workflows,
    and role-based access. We will learn about Docker Enterprise''s registry in [Chapter
    13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml), *Implementing an Enterprise-Grade
    Registry with DTR*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了两种不同的注册表方法：社区版和 Docker Trusted Registry。社区版完全没有任何安全性，也没有基于角色的访问控制。另一方面，Docker
    Trusted Registry 随 Docker 企业解决方案提供，是一个企业级注册表，包含了安全性、镜像漏洞扫描、集成工作流和基于角色的访问控制。我们将在[第
    13 章](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml)中学习 Docker 企业版的注册表，*实施企业级注册表与
    DTR*。
- en: Docker components
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 组件
- en: In this section, we are going to describe the main Docker components and binaries
    used for building, distributing, and deploying containers in all execution stages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述用于构建、分发和部署容器的主要 Docker 组件和二进制文件，涵盖所有执行阶段。
- en: Docker Engine is the core component of container platforms. Docker is a client-server
    application and Docker Engine will provide the server side. This means that we
    have the main process that runs as a daemon on the host, and a client-side application
    that communicates with the server using REST API calls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine 是容器平台的核心组件。Docker 是一个客户端-服务器应用程序，Docker Engine 提供服务器端。这意味着我们有一个在主机上作为守护进程运行的主进程，以及一个与服务器通过
    REST API 调用进行通信的客户端应用程序。
- en: 'Docker Engine''s latest version provides separate packages for the client and
    the server. On Ubuntu, for example, if we take a look at the available packages,
    we will have something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine 的最新版本提供了客户端和服务器的独立软件包。例如，在 Ubuntu 上，如果我们查看可用的软件包，会看到如下内容：
- en: '`- docker-ce-cli` – Docker CLI: The open source application container engine'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`- docker-ce-cli` – Docker CLI：开源应用容器引擎'
- en: '`- docker-ce` – Docker: The open source application container engine'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`- docker-ce` – Docker：开源应用容器引擎'
- en: 'The following diagram represents Docker daemon and its different levels of
    management:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Docker 守护进程及其不同的管理层级：
- en: '![](img/869e5251-5150-40b1-95ba-cc5be82a7c16.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/869e5251-5150-40b1-95ba-cc5be82a7c16.jpg)'
- en: Docker daemon listens for Docker API requests and will be responsible for all
    Docker object actions, such as creating an image, list volumes, and running a
    container.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程监听 Docker API 请求，并将负责所有 Docker 对象的操作，例如创建镜像、列出卷和运行容器。
- en: Docker API is available using a Unix socket by default. Docker API can be used
    from within code-using interfaces that are available for many programming languages.
    Querying for running containers can be managed using a Docker client or its API
    directly; for example, with`curl --no-buffer -XGET --unix-socket /var/run/docker.sock
    http://localhost/v1.24/containers/json`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker API 可通过 Unix 套接字访问。Docker API 可以通过多种编程语言的接口在代码中使用。查询正在运行的容器可以通过
    Docker 客户端或其 API 直接管理；例如，使用 `curl --no-buffer -XGET --unix-socket /var/run/docker.sock
    http://localhost/v1.24/containers/json`。
- en: When deploying cluster-wide environments with Swarm orchestration, daemons will
    share information between them to allow the execution of distributed services
    within the pool of nodes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Swarm 协调器部署集群环境时，守护进程将共享信息，以便在节点池中执行分布式服务。
- en: On the other hand, the Docker client will provide users with the command line
    required to interact with the daemon. It will construct the required API calls
    with their payloads to tell the daemon which actions it should execute.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Docker 客户端将为用户提供与守护进程交互所需的命令行。它将构建所需的 API 调用，并携带有效负载，告诉守护进程应执行哪些操作。
- en: Now, let's deep dive into a Docker daemon component to find out more about its
    behavior and usage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 Docker 守护进程的一个组件，进一步了解它的行为和用法。
- en: Docker daemon
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 守护进程
- en: Docker daemon will usually run as a systemd-managed service, although it can
    run as a standalone process (it is very useful when debugging daemon errors, for
    example). As we have seen previously, `dockerd` provides an API interface that
    allows clients to send commands and interact with this daemon. `containerd`, in
    fact, manages containers. It was introduced as a separate daemon in Docker 1.11
    and is responsible for managing storage, networking, and interaction between namespaces.
    Also, it will manage image shipping and then, finally, it will run containers
    using another external component. This external component, `RunC`, will be the
    real executor of containers. Its function just receives an order to run a container.
    These components are part of the community, so the only one that Docker provides
    is `dockerd`. All other daemon components are community-driven and use standard
    image specifications (**Open Containers Initiative** – **OCI**). In 2017, Docker
    donated `containerd` as part of their contribution to the open source community
    and is now part of the **Cloud Native Computing Foundation** (**CNCF**). OCI was
    founded as an open governance structure for the express purpose of creating open
    industry standards around container formats and runtimes in 2015\. The CNCF hosts
    and manages most of the currently most-used components of the newest technology
    infrastructures. It is a part of the nonprofit Linux Foundation and is involved
    in projects such as Kubernetes, Containerd, and The Update Framework.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程通常作为 systemd 管理的服务运行，尽管它也可以作为独立进程运行（例如在调试守护进程错误时非常有用）。正如我们之前所见，`dockerd`
    提供了一个 API 接口，允许客户端发送命令并与该守护进程交互。实际上，`containerd` 管理着容器。它在 Docker 1.11 中作为一个独立的守护进程引入，负责管理存储、网络以及命名空间之间的交互。此外，它还会管理镜像传输，最后，它会使用另一个外部组件来运行容器。这个外部组件，`RunC`，将是容器的实际执行者。它的功能就是接收运行容器的命令。这些组件是由社区维护的，因此
    Docker 提供的唯一守护进程是 `dockerd`。所有其他守护进程组件都是社区驱动的，并使用标准的镜像规范（**开放容器倡议** – **OCI**）。2017
    年，Docker 将 `containerd` 捐赠给开源社区，作为对开源社区的贡献，现在它是 **云原生计算基金会**（**CNCF**）的一部分。OCI
    于 2015 年成立，作为一个开放治理结构，旨在围绕容器格式和运行时创建开放的行业标准。CNCF 主持并管理目前大多数最新技术基础设施中最常用的组件。它是非营利的
    Linux 基金会的一部分，参与了像 Kubernetes、Containerd 和 The Update Framework 等项目。
- en: By way of a summary, `dockerd` will manage interaction with the Docker client.
    To run a container, first, the configuration needs to be created so that daemon
    triggers `containerd` (using gRPC) to create it. This piece will create an OCI
    definition that will use `RunC` to run this new container. Docker implements these
    components with different names (changed between releases), but the concept is
    still valid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`dockerd` 将管理与 Docker 客户端的交互。要运行容器，首先需要创建配置，使得守护进程触发 `containerd`（通过 gRPC）来创建容器。此过程将创建一个
    OCI 定义，并使用 `RunC` 来运行这个新容器。Docker 以不同的名称实现了这些组件（在不同版本之间有所变化），但其基本概念依然有效。
- en: 'Docker daemon can listen for Docker Engine API requests on different types
    of sockets: `unix`, `tcp`, and `fd`. By default, Daemon on Linux will use a Unix
    domain socket (or IPC socket) that''s created at `/var/run/docker.sock` when starting
    the daemon. Only root and Docker groups can access this socket, so only root and
    members of the Docker group will be able to create containers, build images, and
    so on. In fact, access to a socket is required for any Docker action.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程可以在不同类型的套接字上监听 Docker 引擎 API 请求：`unix`、`tcp` 和 `fd`。默认情况下，Linux 上的守护进程会使用一个
    Unix 域套接字（或 IPC 套接字），该套接字在启动守护进程时会创建在 `/var/run/docker.sock` 路径下。只有 root 用户和 Docker
    组成员可以访问此套接字，因此只有 root 用户和 Docker 组成员能够创建容器、构建镜像等。实际上，执行任何 Docker 操作都需要访问这个套接字。
- en: Docker client
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 客户端
- en: Docker client is used to interact with a server. It needs to be connected to
    a Docker daemon to perform any action, such as building an image or running a
    container.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端用于与服务器交互。它需要连接到 Docker 守护进程才能执行任何操作，例如构建镜像或运行容器。
- en: A Docker daemon and client can run on the same host system, or we can manage
    a connected remote daemon. The Docker client and daemon communicate using a server-side
    REST API. This communication can be executed over UNIX sockets (by default) or
    a network interface, as we learned earlier.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程和客户端可以在同一主机系统上运行，或者我们可以管理一个连接的远程守护进程。Docker 客户端和守护进程通过服务器端 REST API
    进行通信。正如我们之前所学，这种通信可以通过 UNIX 套接字（默认情况下）或网络接口执行。
- en: Docker objects
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 对象
- en: The Docker daemon will manage all kinds of Docker objects using the Docker client
    command line.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程将使用 Docker 客户端命令行管理各种 Docker 对象。
- en: 'The following are the most common objects at the time of writing this book:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是截至本书写作时最常见的对象：
- en: '`IMAGE`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE`'
- en: '`CONTAINER`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTAINER`'
- en: '`VOLUME`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`'
- en: '`NETWORK`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NETWORK`'
- en: '`PLUGIN`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PLUGIN`'
- en: 'There are other objects that are only available when we deploy Docker Swarm
    orchestration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些对象，仅在我们部署Docker Swarm编排时才可用：
- en: '`NODE`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NODE`'
- en: '`SERVICE`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERVICE`'
- en: '`SECRET`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECRET`'
- en: '`CONFIG`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG`'
- en: '`STACK`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STACK`'
- en: '`SWARM`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SWARM`'
- en: The Docker command line provides the actions that Docker daemon is allowed to
    execute via REST API calls. There are common actions such as list (or `ls`), `create`,
    `rm` (for remove), and `inspect`, and other actions that are restricted to specific
    objects, such as `cp` (for coping).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令行提供了Docker守护进程通过REST API调用可以执行的操作。有一些常见操作，比如列出（或`ls`）、`create`、`rm`（删除）和`inspect`，还有一些针对特定对象的限制操作，如`cp`（复制）。
- en: 'For example, we can get a list of running containers on a host by running the
    following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过运行以下命令来获取主机上正在运行的容器列表：
- en: '[PRE0]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are many commonly used aliases, such as `docker ps` for `docker container
    ls` or `docker run` for `docker container run`. I recommend using a long command-line
    format because it is easier to remember if we understand which actions are allowed
    for each object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多常用的别名，例如将`docker container ls`简写为`docker ps`，将`docker container run`简写为`docker
    run`。我建议使用长格式命令行，因为如果我们理解每个对象可以执行哪些操作，长格式会更容易记住。
- en: There are other tools available on the Docker ecosystem, such as `docker-machine`
    and `docker-compose`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统中还有其他工具，例如`docker-machine`和`docker-compose`。
- en: Docker Machine is a community tool created by Docker that allows users and administrators
    to easily deploy Docker Engine on hosts. It was developed in order to fast provision
    Docker Engine on cloud providers such as Azure and AWS, but it evolved to offer
    other implementations, and nowadays, it is possible to use many different drivers
    for many different environments. We can use `docker-machine` to deploy `docker-engine`
    on VMWare (over Cloud Air, Fusion, Workstation, or vSphere), Microsoft Hyper-V,
    and OpenStack, among others. It is also very useful for quick labs, or demonstration
    and test environments on VirtualBox or KVM, and it even allows us to provision
    `docker-engine` software using SSH. `docker-machine` runs on Windows and Linux,
    and provides an integration between client and provisioned Docker host daemons.
    This way, we can interact with its Docker daemon remotely, without being connected
    using SSH, for example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine是由Docker创建的社区工具，允许用户和管理员轻松地在主机上部署Docker Engine。它的开发目的是为了快速在Azure和AWS等云服务上部署Docker
    Engine，但后来发展出其他实现方式，现在可以使用许多不同的驱动程序适用于多种不同的环境。我们可以使用`docker-machine`将`docker-engine`部署到VMWare（包括Cloud
    Air、Fusion、Workstation或vSphere）、Microsoft Hyper-V和OpenStack等平台。它对于在VirtualBox或KVM上进行快速实验、演示和测试环境也非常有用，甚至可以通过SSH来配置`docker-engine`软件。`docker-machine`可以在Windows和Linux上运行，并提供客户端与已配置的Docker主机守护进程之间的集成。通过这种方式，我们可以远程与Docker守护进程交互，而无需通过SSH连接。
- en: On the other hand, Docker Compose is a tool that will allow us to run multi-container
    applications on a single host. We will just introduce this concept here in relation
    to multi-service applications that will run on Swarm or Kubernetes clusters. We
    will learn about `docker-compose` in [Chapter 5](1c86479c-e4f5-4508-9eca-d29bb3dbaf4b.xhtml),
    *Deploying Multi-Container Applications*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Docker Compose是一个工具，可以让我们在单个主机上运行多容器应用程序。我们在这里介绍这个概念，主要是与在Swarm或Kubernetes集群上运行的多服务应用程序相关。我们将在[第5章](1c86479c-e4f5-4508-9eca-d29bb3dbaf4b.xhtml)中了解`docker-compose`，*部署多容器应用程序*。
- en: Building, shipping, and running workflows
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建、发布和运行工作流
- en: 'Docker provides the tools for creating images (templates for containers, remember),
    distributing those images to systems other than the one used for building the
    image, and finally, running containers based on these images:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了创建镜像（容器的模板，记住）的工具，将这些镜像分发到除构建镜像的系统以外的其他系统，最后基于这些镜像运行容器：
- en: '![](img/e5b4a773-3969-4635-8355-3ef34ed67026.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5b4a773-3969-4635-8355-3ef34ed67026.jpg)'
- en: Docker Engine will participate in all workflow steps, and we can use just one
    host or many during these processes, including our developers' laptops.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine将在所有工作流步骤中参与，我们可以在这些过程中只使用一个主机或多个主机，包括开发人员的笔记本电脑。
- en: Let's provide a quick review of the usual workflow processes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下常见的工作流过程。
- en: Building
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建
- en: 'Building applications using containers is easy. Here are the standard steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器构建应用程序很容易。以下是标准步骤：
- en: The developer usually codes an application on their own computer.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员通常在自己的计算机上编写应用程序。
- en: When the code is ready, or there is a new release, new functionalities, or a
    bug has simply been fixed, a commit is deployed.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码准备好，或者有新版本发布、新功能，或只是修复了一个 bug 时，都会进行提交部署。
- en: If our code has to be compiled, we can do it at this stage. If we are using
    an interpreted language for our code, we will just add it to the next stage.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的代码需要编译，可以在这个阶段进行。如果我们使用的是解释型语言编写的代码，我们将把它添加到下一个阶段。
- en: Either manually or using continuous integration orchestration, we can create
    a Docker image integrating compiled binary or interpreted code with the required
    runtime and all its dependencies. Images are our new component artifacts.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是手动操作还是使用持续集成编排，我们都可以创建一个 Docker 镜像，将编译的二进制代码或解释型代码与所需的运行时和所有依赖项集成在一起。镜像是我们新的组件制品。
- en: We have passed the building stage and the built image, with everything included,
    must be deployed to production. But first, we need to ensure its functionality
    and health (Will it work? How about performance?). We can do all these tests on
    different environments using the image artifact we created.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了构建阶段，构建好的镜像包含了所有内容，必须部署到生产环境。但首先，我们需要确保它的功能和健康状态（它能正常工作吗？性能如何？）。我们可以在不同的环境中使用我们创建的镜像制品进行所有这些测试。
- en: Shipping
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布
- en: 'Sharing created artifacts is easier with containers. Here are some of the new
    steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器共享创建的制品更为简单。以下是一些新的步骤：
- en: The created image is on our build host system (or even on our laptop). We will
    push this artifact to an image registry to ensure that it is available for the
    next workflow processes.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建的镜像位于我们的构建主机系统上（甚至在我们的笔记本电脑上）。我们将把这个制品推送到镜像注册表，以确保它可以用于下一步的工作流过程。
- en: Docker Enterprise provides integrations on Docker Trusted Registry to follow
    separate steps from the first push, image scanning to look for vulnerabilities,
    and different image pulls from different environments during continuous integration
    stages.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 企业版提供了与 Docker 信任注册表的集成，按照从第一次推送到镜像扫描以寻找漏洞、以及在持续集成阶段从不同环境拉取不同镜像的步骤进行操作。
- en: All pushes and pulls are managed by Docker Engine and triggered by Docker clients.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有推送和拉取操作由 Docker 引擎管理，并由 Docker 客户端触发。
- en: Now that the image has been shipped on different environments, during integration
    and performance tests, we need to launch containers using environment variables
    or configurations for each stage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在镜像已经在不同的环境中发布，在集成和性能测试期间，我们需要使用每个阶段的环境变量或配置来启动容器。
- en: Running
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行
- en: 'So, we have new artifacts that are easy to share between different environments,
    but we need to execute them in production. Here are some of the benefits of containers
    for our applications:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了易于在不同环境之间共享的新制品，但我们需要在生产环境中执行它们。以下是容器为我们的应用程序带来的一些好处：
- en: All environments will use Docker Engine to execute our containers (processes),
    but that's all. We don't really need any portion of software other than Docker
    Engine to execute the image correctly (naturally, we have simplified this idea
    because we will need volumes and external resources in many cases).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有环境将使用 Docker 引擎来执行我们的容器（进程），但仅此而已。实际上，我们不需要除了 Docker 引擎之外的任何软件部分来正确执行镜像（当然，我们简化了这个概念，因为在许多情况下我们需要使用卷和外部资源）。
- en: If our image passed all the tests defined in the workflow, it is ready for production,
    and this step will be as simple as deploying the image built originally on the
    previous environment, using all the required arguments and environment variables
    or configurations for production.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的镜像通过了工作流中定义的所有测试，它就可以投入生产，这一步将和在之前的环境中部署最初构建的镜像一样简单，只需使用所有必要的参数、环境变量或配置进行生产部署。
- en: If our environments were orchestration-managed using Swarm or Kubernetes, all
    these steps would have been run securely, with resilience, using internal load
    balancers, and with required replicas, among other properties, that this kind
    of platform provides.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的环境是使用 Swarm 或 Kubernetes 进行编排管理的，那么所有这些步骤都会安全地运行，具备韧性，使用内部负载均衡器，并具备所需的副本等平台特性。
- en: As a summary, keep in mind that Docker Engine provides all the actions required
    for building, shipping, and running container-based applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，请记住，Docker 引擎提供了构建、发布和运行基于容器的应用程序所需的所有操作。
- en: Windows containers
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 容器
- en: Containers started with Linux, but nowadays, we can run and orchestrate containers
    on Windows. Microsoft integrated containers on Windows in Windows 2016\. With
    this release, they consolidated a partnership with Docker to create a container
    engine that runs containers natively on Windows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 容器最初是基于Linux启动的，但如今我们可以在Windows上运行和编排容器。微软在Windows 2016中集成了容器功能。通过这一版本，他们与Docker建立了合作关系，共同开发了一个在Windows上本地运行容器的引擎。
- en: 'After a few releases, Microsoft decided to have two different approaches to
    containers on Windows, these being the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 经历几次发布后，微软决定在Windows上采用两种不同的容器方式，分别如下：
- en: '**Windows Server Containers** (**WSC**), or process containers'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Server容器**（**WSC**），或进程容器'
- en: Hyper-V Containers
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hyper-V容器
- en: Because of the nature of Windows operating system implementation, we can share
    kernels but we can't isolate processes from the system services and DLLs. In this
    situation, process containers need a copy of the required system services and
    many DLLs to be able to make API calls to the underlying host operating system.
    This means that containers that use process container isolation will run with
    many system processes and DLLs inside. In this case, images are very big and will
    have a different kind of portability; we will only be able to run Windows containers
    based on the same underlying operating system version.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Windows操作系统实现的特性，我们可以共享内核，但无法将进程与系统服务和DLL隔离。在这种情况下，进程容器需要复制所需的系统服务和多个DLL，以便能够向底层主机操作系统发出API调用。这意味着，使用进程容器隔离的容器将包含许多系统进程和DLL。在这种情况下，镜像非常庞大，并且具有不同的可移植性；我们只能运行基于相同底层操作系统版本的Windows容器。
- en: As we have seen, process containers need to copy a portion of the underlying
    operating system inside in order to run. This means that we can only run the same
    operating system containers. For example, running containers on top of Windows
    Server 2016 will require a Windows Server 2016 base image.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，进程容器需要将一部分底层操作系统复制到内部才能运行。这意味着我们只能运行相同操作系统的容器。例如，在Windows Server 2016上运行容器需要一个Windows
    Server 2016基础镜像。
- en: On the other hand, Hyper-V containers will not have these limitations because
    they will run on top of a virtualized kernel. This adds overhead, but the isolation
    is substantially better. In this case, we won't be able to run these kinds of
    containers on older Microsoft Windows versions. These containers will use optimized
    virtualization to isolate the new kernel for our process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Hyper-V容器不会有这些限制，因为它们将运行在虚拟化内核之上。这会增加一些开销，但隔离性大大提高。在这种情况下，我们将无法在较旧的Microsoft
    Windows版本上运行这些类型的容器。这些容器将使用优化的虚拟化来隔离我们的进程的新内核。
- en: 'The following diagram represents both types of MS Windows container isolation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示了两种类型的Microsoft Windows容器隔离：
- en: '![](img/bfa4c480-9fa6-480a-ad8e-c9c2bfb55e00.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfa4c480-9fa6-480a-ad8e-c9c2bfb55e00.jpg)'
- en: Process isolation is a default container isolation on Windows Server, but Windows
    10 Pro and Enterprise will run Hyper-V isolation. Since the Windows 10 October
    2018 update, we can choose to use old-style process isolation with the `--isolation=process`
    flag on Windows 10 Pro and Enterprise.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 进程隔离是Windows Server上的默认容器隔离模式，但Windows 10 Pro和Enterprise将运行Hyper-V隔离。从Windows
    10 2018年10月更新开始，我们可以选择使用旧式进程隔离，并通过`--isolation=process`标志在Windows 10 Pro和Enterprise上启用。
- en: Please check the Windows operating system's portability because this is a very
    common problem on Windows containers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查Windows操作系统的可移植性，因为这是Windows容器中非常常见的问题。
- en: Networking in Windows containers is different from Linux. The Docker host uses
    a Hyper-V virtual switch to provide connectivity to containers and connects them
    to virtual switches using either a host virtual interface (Windows Server containers)
    or a synthetic VM interface (Hyper-V containers).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Windows容器的网络配置不同于Linux。Docker主机使用Hyper-V虚拟交换机为容器提供连接，并通过主机虚拟接口（Windows Server容器）或合成虚拟机接口（Hyper-V容器）将其连接到虚拟交换机。
- en: Customizing Docker
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制Docker
- en: Docker behavior can be managed at daemon and client levels. These configurations
    can be executed using command-line arguments, environment variables, or definitions
    on configuration files.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Docker行为可以在守护进程和客户端层面进行管理。这些配置可以通过命令行参数、环境变量或配置文件中的定义来执行。
- en: Customizing the Docker daemon
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制Docker守护进程
- en: 'Docker daemon behavior is managed by various configuration files and variables:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程行为由各种配置文件和变量进行管理：
- en: '**key.json**: This file contains a unique identifier for this daemon; in fact,
    it is the daemon''s public key that uses the JSON web key format.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key.json**：这个文件包含该守护进程的唯一标识符；实际上，它是守护进程的公钥，采用 JSON Web Key 格式。'
- en: '**daemon.json**: This is the Docker daemon configuration file. It contains
    all its parameters in JSON format. It has a key-value (or list of values) format
    in which all the daemon''s flags will be available to modify its behavior. Be
    careful with configurations implemented on the `systemd` service file because
    they must not conflict with options set via the JSON file; otherwise, the daemon
    will fail to start.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**daemon.json**：这是 Docker 守护进程的配置文件。它以 JSON 格式包含了所有的参数。它采用键值（或值的列表）格式，所有守护进程的标志都可以在此文件中进行修改。注意，在
    `systemd` 服务文件中实现的配置必须与通过 JSON 文件设置的选项不冲突，否则守护进程将无法启动。'
- en: '**Environment variables**: `HTTPS_PROXY`, `HTTP_PROXY`, and `NO_PROXY` (or
    using lowercase) will manage the utilization of Docker daemon and the client behind
    the proxies. The configuration can be implemented in the Docker daemon `systemd`
    unit config files using, for example, `/etc/systemd/system/docker.service.d/http-proxy.conf`,
    and following the content for `HTTPS_PROXY` (the same configuration might be applied
    to `HTTP_PROXY`):'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：`HTTPS_PROXY`、`HTTP_PROXY` 和 `NO_PROXY`（或使用小写字母）将管理 Docker 守护进程及其客户端在代理后面的使用。该配置可以在
    Docker 守护进程的 `systemd` 单元配置文件中实现，例如 `/etc/systemd/system/docker.service.d/http-proxy.conf`，并按照以下内容配置
    `HTTPS_PROXY`（相同的配置也可以应用于 `HTTP_PROXY`）：'
- en: '[PRE1]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Be careful with the `key.json` file while cloning virtual machines because
    using the same keys on different daemons will result in strange behaviors. This
    file is owned by system administrators, so you will need to use a privileged user
    to review its content. This JSON file contains Docker Daemon''s certificate in
    JSON Web Key format. We can just review the `key.json` file''s content using the
    `cat` and `jq` commands `(jq` is not required, but I used it to format output.
    This command will help with JSON files or JSON output):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在克隆虚拟机时要小心 `key.json` 文件，因为在不同守护进程上使用相同的密钥会导致奇怪的行为。此文件由系统管理员拥有，因此你需要使用特权用户查看其内容。这个
    JSON 文件包含了 Docker 守护进程的证书，采用 JSON Web Key 格式。我们可以通过 `cat` 和 `jq` 命令查看 `key.json`
    文件的内容（`jq` 并非必需，但我用它来格式化输出。此命令对 JSON 文件或 JSON 输出非常有用）：
- en: '`**$ sudo cat /etc/docker/key.json |jq**`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ sudo cat /etc/docker/key.json |jq**`'
- en: '`{`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`"crv": "P-256",`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`"crv": "P-256",`'
- en: '`"d": "f_RvzIUEPu3oo7GLohd9cxqDlT9gQyXSfeWoOnM0ZLU",`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`"d": "f_RvzIUEPu3oo7GLohd9cxqDlT9gQyXSfeWoOnM0ZLU",`'
- en: '`"kid": "QP6X:5YVF:FZAC:ETDZ:HOHI:KJV2:JIZW: IG47:3GU6:YQJ4:YRGF:VKMP",`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`"kid": "QP6X:5YVF:FZAC:ETDZ:HOHI:KJV2:JIZW: IG47:3GU6:YQJ4:YRGF:VKMP",`'
- en: '`"kty": "EC",`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`"kty": "EC",`'
- en: '`"x": "y4HbXr4BKRi5zECbJdGYvFE2KtMp9DZfPL81r_qe52I",`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`"x": "y4HbXr4BKRi5zECbJdGYvFE2KtMp9DZfPL81r_qe52I",`'
- en: '`"y": "ami9cOOKSA8joCMwW-y96G2mBGwcXthYz3FuK-mZe14"`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`"y": "ami9cOOKSA8joCMwW-y96G2mBGwcXthYz3FuK-mZe14"`'
- en: '`}`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'The daemon configuration file, `daemon.json`, will be located by default at
    the following locations:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，守护进程配置文件 `daemon.json` 将位于以下位置：
- en: '`/etc/docker/daemon.json` on Linux systems'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 系统中的 `/etc/docker/daemon.json`
- en: '`%programdata%\docker\config\daemon.json` on Windows systems'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 系统中的 `%programdata%\docker\config\daemon.json`
- en: In both cases, the configuration file's location can be changed using `--config-file`
    to specify a custom non-default file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，配置文件的位置可以通过 `--config-file` 来更改，以指定一个自定义的非默认文件。
- en: 'Let''s provide a quick review of the most common and important flags or keys
    we will configure for Docker daemon. Some of these options are so important that
    they are usually referenced in the Docker Certified Associate exam. Don''t worry;
    we will learn about the most important ones, along with their corresponding JSON
    keys, here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们将为 Docker 守护进程配置的最常见和重要的标志或键。以下这些选项非常重要，通常会出现在 Docker 认证助理考试中。别担心；我们将在这里学习最重要的选项以及它们对应的
    JSON 键：
- en: '| **Daemon argument** | **JSON key** | **Argument description** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **守护进程参数** | **JSON 键** | **参数描述** |'
- en: '| `-b`, `--bridge` string | `bridge` | Attach containers to a network bridge.
    This option allows us to change the default bridge behavior. In some cases, it''s
    useful to create your own bridge interfaces and use the Docker daemon attached
    to one of them. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `-b`, `--bridge` 字符串 | `bridge` | 将容器连接到网络桥接。此选项允许我们更改默认的桥接行为。在某些情况下，创建自己的桥接接口并使用附加到其中的
    Docker 守护进程会非常有用。 |'
- en: '| `--cgroup-parent` string | `cgroup-parent` | Set the parent cgroup for all
    containers. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `--cgroup-parent` 字符串 | `cgroup-parent` | 为所有容器设置父级 cgroup。 |'
- en: '| `-D`, `--debug` | `debug` | This option enables debug mode, which is fundamental
    to resolving issues. Usually, it''s better to stop Docker service and run the
    Docker daemon by hand using the `-D` option to review all `dockerd` debugging
    events. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `-D`, `--debug` | `debug` | 此选项启用调试模式，对于解决问题非常重要。通常，最好停止 Docker 服务并手动使用 `-D`
    选项运行 Docker 守护进程，以查看所有 `dockerd` 调试事件。 |'
- en: '| `--data-root` string | `data-root` | This is the root directory of the persistent
    Docker state (default `/var/lib/docker`). With this option, we can change the
    path to store all Docker data (Swarm KeyValue, images, internal volumes, and so
    on). |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `--data-root` string | `data-root` | 这是持久化 Docker 状态的根目录（默认为 `/var/lib/docker`）。通过此选项，我们可以更改存储所有
    Docker 数据（Swarm 键值、镜像、内部卷等）的路径。 |'
- en: '| `--dns` list | `dns` | This is the DNS server to use (default `[]`). These
    three options allow us to change the container DNS behavior, for example, to use
    a specific DNS for the container environment. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `--dns` list | `dns` | 这是要使用的 DNS 服务器（默认为 `[]`）。这三个选项使我们能够更改容器的 DNS 行为，例如，为容器环境使用特定的
    DNS。 |'
- en: '| `--dns-opt` list | `dns-opt` | These are the DNS options to use (default
    `[]`). |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `--dns-opt` list | `dns-opt` | 这是要使用的 DNS 选项（默认为 `[]`）。 |'
- en: '| `--dns-search` list | `dns-search` | These are the DNS search domains to
    use (default `[]`). |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `--dns-search` list | `dns-search` | 这是要使用的 DNS 搜索域（默认为 `[]`）。 |'
- en: '| `--experimental` | `experimental` | This enables experimental features; don''t
    use it in production. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `--experimental` | `experimental` | 这启用实验性功能；不要在生产环境中使用它。 |'
- en: '| `-G`, `--group` string | `group` | This is the group for the Unix socket
    (default `docker`). |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `-G`, `--group` string | `group` | 这是 Unix 套接字的组（默认为 `docker`）。 |'
- en: '| `-H`, `--host` list | `host` | This is the option that allows us to specify
    the socket(s) to use. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `-H`, `--host` list | `host` | 这是允许我们指定要使用的套接字的选项。 |'
- en: '| `--icc` | `icc` | This enables inter-container communication (default `true`).
    With this option, we can disable any container''s internal communications. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `--icc` | `icc` | 这启用容器间通信（默认为 `true`）。通过此选项，我们可以禁用任何容器的内部通信。 |'
- en: '| `--ip` IP | `ip` | This is the default IP when binding container ports (default
    `0.0.0.0`). With this option, we can ensure that only specific subnets will have
    access to container-exposed ports. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `--ip` IP | `ip` | 这是绑定容器端口时的默认 IP（默认为 `0.0.0.0`）。通过此选项，我们可以确保只有特定子网能够访问容器暴露的端口。
    |'
- en: '| `--label` list | `label` | Set key=value labels to the daemon (default `[]`).
    With labels, we can configure environment properties for container location when
    using a cluster of hosts. There is a better tagging method you can use when using
    Swarm, as we will learn in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `--label` list | `label` | 为守护进程设置键=值标签（默认为 `[]`）。使用标签时，我们可以配置容器位置的环境属性，当使用主机集群时，便可以应用这些配置。使用
    Swarm 时有更好的标签方法，我们将在[第8章](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml)《*使用 Docker
    Swarm 进行编排*》中学习。 |'
- en: '| `--live-restore` | `live-restore` | This enables the live restoration of
    Docker when containers are still running. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `--live-restore` | `live-restore` | 启用在容器仍在运行时进行 Docker 的实时恢复。 |'
- en: '| `--log-driver` string | `log-driver` | This is the default driver for container
    logs (default `json-file`) if we need to use an external log manager (ELK framework
    or just a Syslog Server, for example). |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `--log-driver` string | `log-driver` | 这是容器日志的默认驱动程序（默认为 `json-file`），如果我们需要使用外部日志管理器（例如
    ELK 框架或仅使用 Syslog 服务器）。 |'
- en: '| `-l`, `--log-level` string | `log-level` | This sets the logging level (`debug`,
    `info`, `warn`, `error`, `fatal`) (default `info`). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `-l`, `--log-level` string | `log-level` | 这设置了日志记录级别（`debug`，`info`，`warn`，`error`，`fatal`）（默认为
    `info`）。 |'
- en: '| `--seccomp-profile` string | `seccomp-profile` | This is the path to the
    seccomp profile if we want to use anything other than the default option. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `--seccomp-profile` string | `seccomp-profile` | 如果我们希望使用默认选项以外的配置，这是 seccomp
    配置文件的路径。 |'
- en: '| `--selinux-enabled` | `selinux-enabled` | Enables SELinux support. This option
    is crucial for production environments using Red Hat Linux/CentOS. It is disabled
    by default. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `--selinux-enabled` | `selinux-enabled` | 启用 SELinux 支持。此选项对使用 Red Hat Linux/CentOS
    的生产环境至关重要。默认情况下它是禁用的。 |'
- en: '| `-s`, `--storage-driver` string | `storage-driver` | This is the storage
    driver to use. This argument allows us to change the default driver selected by
    Docker. In the latest versions, we will use `overlay2` because of its stability
    and performance. Other options include `aufs`, `btrfs`, and `devicemapper`. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `-s`，`--storage-driver` 字符串 | `storage-driver` | 这是要使用的存储驱动程序。此参数允许我们更改Docker选择的默认驱动程序。在最新版本中，我们将使用`overlay2`，因为它具有更好的稳定性和性能。其他选项包括`aufs`、`btrfs`和`devicemapper`。
    |'
- en: '| `--storage-opt` list | `storage-opts` | Storage driver options (default `[]`).
    Depending on the storage driver used, we will need to add options as arguments,
    for example, using `devicemapper` or for specifying a maximum container size on
    `overlay2` or Windows filter (MS Windows copy-on-write implementation). |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `--storage-opt` 列表 | `storage-opts` | 存储驱动程序选项（默认值 `[]`）。根据使用的存储驱动程序，我们需要添加选项作为参数，例如，使用`devicemapper`或指定`overlay2`或Windows过滤器（MS
    Windows写时复制实现）上的最大容器大小。 |'
- en: '| `--tls` | `tls` | This option enables TLS encryption between client and server
    (implied by `--tlsverify`). |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `--tls` | `tls` | 此选项启用客户端和服务器之间的TLS加密（由`--tlsverify`隐式启用）。 |'
- en: '| `--tlscacert` string | `tlscacert` | Trust certs signed only by this CA (default
    `~/.docker/ca.pem`). |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `--tlscacert` 字符串 | `tlscacert` | 仅信任由此CA签名的证书（默认值 `~/.docker/ca.pem`）。 |'
- en: '| `--tlscert` string | `tlscert` | This is the path to the TLS certificate
    file (default `~/.docker/cert.pem`). |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `--tlscert` 字符串 | `tlscert` | 这是TLS证书文件的路径（默认值 `~/.docker/cert.pem`）。 |'
- en: '| `--tlskey` string | `tlskey` | This is the path to the TLS key file (default
    `~/.docker/key.pem`). |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `--tlskey` 字符串 | `tlskey` | 这是TLS密钥文件的路径（默认值 `~/.docker/key.pem`）。 |'
- en: '| `--tlsverify` | `tlsverify` | Use TLS and verify the remote. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `--tlsverify` | `tlsverify` | 使用TLS并验证远程端。 |'
- en: Logging information in container environments can be deployed using different
    layers of knowledge. As shown in the previous table, Docker daemon has its own
    logging configuration using `--log-driver`. This configuration will be applied
    to all containers by default if we do not specify any configuration during container
    execution. Therefore, we can redirect all container logs to some remote logging
    system using the ELK framework, for example ([https://www.elastic.co/es/what-is/elk-stack](https://www.elastic.co/es/what-is/elk-stack)),
    while some specific containers can be redirected to another logging backend. This
    can also be applied locally using different logging drivers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 容器环境中的日志信息可以通过不同的知识层级进行部署。如前表所示，Docker守护进程有自己的日志配置，使用`--log-driver`。如果我们在容器执行期间没有指定任何配置，则此配置将默认应用于所有容器。因此，我们可以使用ELK框架将所有容器日志重定向到某个远程日志系统，例如([https://www.elastic.co/es/what-is/elk-stack](https://www.elastic.co/es/what-is/elk-stack))，而某些特定容器则可以重定向到另一个日志后端。这也可以通过不同的日志驱动程序在本地应用。
- en: Docker client customization
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker客户端定制
- en: The client will store its configuration under the users' home directory on `.docker`.
    There is a config file where the Docker client will look for its configurations
    (`$HOME/.docker/config.json` on Linux or `%USERPROFILE%/.docker/config.json` on
    Windows). In this file, we will set a proxy for our containers if it's needed
    to connect to the internet or other external services, for example.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将把配置存储在用户的主目录下的`.docker`目录中。这里有一个配置文件，Docker客户端会在其中查找其配置（在Linux上是`$HOME/.docker/config.json`，在Windows上是`%USERPROFILE%/.docker/config.json`）。在这个文件中，我们将为容器设置代理，如果需要连接到互联网或其他外部服务时，例如。
- en: 'If we need to pass proxy settings to containers upon startup, we will configure
    the `proxies` key in `.docker/config.json` for our user, for example, using `my-company-proxy`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在启动时向容器传递代理设置，我们将为我们的用户在`.docker/config.json`中配置`proxies`键，例如，使用`my-company-proxy`：
- en: '[PRE2]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These configurations can be added as arguments when starting up the Docker
    container, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置可以在启动Docker容器时作为参数添加，具体如下：
- en: '[PRE3]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will see what "environment option" means in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*. Just keep in mind that, sometimes, our corporate
    environment will need applications to use proxies and that there are methods to
    configure these settings, either as user variables or using client configurations.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)《运行Docker容器》中看到“环境选项”是什么意思。只需记住，有时我们的公司环境需要应用程序使用代理，并且有配置这些设置的方法，无论是作为用户变量，还是通过客户端配置来实现。
- en: 'Other client features, such as experimental flags or output formatting, will
    be configured in the `config.json` file. Here is an example of some configurations:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其他客户端功能，例如实验性标志或输出格式，将配置在`config.json`文件中。以下是一些配置的示例：
- en: '[PRE4]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Docker security
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 安全性
- en: There are many topics related to container security. In this chapter, we will
    review the ones related to the container runtime.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器安全相关的主题很多。本章将回顾与容器运行时相关的那些。
- en: As we have seen, Docker provides a client-server environment. From the client
    side, there are a few things that will improve the way in which we will be able
    to access the environment.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Docker 提供了一个客户端-服务器环境。从客户端的角度来看，有一些事项可以改善我们访问环境的方式。
- en: Configuration files and certificates for different clusters on hosts must be
    secured using filesystem security at the operating system level. However, as you
    should have noticed, a Docker client always needs a server in order to do anything
    with containers. Docker client is just the tool to connect to servers. With this
    picture in mind, client-server security is a must. Now, let's take a look at different
    kinds of access to the Docker daemon.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不同主机上不同集群的配置文件和证书必须使用操作系统级别的文件系统安全性来加固。然而，正如您应该注意到的，Docker 客户端总是需要一个服务器来与容器进行交互。Docker
    客户端只是连接到服务器的工具。牢记这一点，客户端-服务器安全性至关重要。现在，让我们来看看访问 Docker 守护进程的不同方式。
- en: Docker client-server security
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 客户端-服务器安全性
- en: The Docker daemon will listen on system sockets (`unix`, `tcp`, and `fd`). We
    have seen that we can change this behavior and that, by default, the daemon will
    listen on the `/var/run/docker.sock` local Unix socket.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程将监听系统套接字（`unix`、`tcp` 和 `fd`）。我们已经看到，我们可以更改此行为，默认情况下，守护进程将监听本地 Unix
    套接字`/var/run/docker.sock`。
- en: Giving users RW access to `/var/run/docker.sock` will add access to the local
    Docker daemon. This allows them to create images, run containers (even privileged,
    root user containers, and mount local filesystems inside them), create images,
    and more. It is very important to know who can use your Docker engine. If you
    deployed a Docker Swarm cluster, this is even worse because if the accessed host
    has a master role, the user will be able to create a service that will run containers
    across the entirety of the cluster. So keep your Docker daemon socket safe from
    non-trusted users and only allow authorized ones (in fact, we will look at other
    advanced mechanisms to provide secure user access to the container platform).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 给予用户对`/var/run/docker.sock`的读写权限将允许其访问本地 Docker 守护进程。这使他们能够创建镜像、运行容器（甚至是特权容器、root
    用户容器，并在其中挂载本地文件系统）、创建镜像等等。了解谁可以使用您的 Docker 引擎非常重要。如果您部署了 Docker Swarm 集群，情况会更糟，因为如果被访问的主机拥有主节点角色，用户将能够创建一个服务，在整个集群中运行容器。因此，务必确保
    Docker 守护进程的套接字不被不受信任的用户访问，只允许授权用户访问（实际上，我们将查看其他高级机制来为容器平台提供安全的用户访问）。
- en: Docker daemon is secure by default because it does not export its service. We
    can enable remote TCP accesses by adding `-H tcp://<HOST_IP>` to the Docker daemon
    start process. By default, port `2375` will be used. If we use 0.0.0.0 as the
    host IP address, Docker daemon will listen on all interfaces.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程默认是安全的，因为它不会导出其服务。我们可以通过在 Docker 守护进程启动过程中添加 `-H tcp://<HOST_IP>`
    来启用远程 TCP 访问。默认情况下，将使用端口`2375`。如果我们使用 0.0.0.0 作为主机 IP 地址，Docker 守护进程将会在所有接口上监听。
- en: 'We can enable remote access to Docker daemon using a TCP socket. By default,
    communication will not be secure and the daemon will listen on port `2375`. To
    ensure that the client-to-daemon connection is encrypted, you will need to use
    either a reverse proxy or built-in TLS-based HTTPS encrypted socket. We can allow
    the daemon to listen on all host interface IP addresses or just one using this
    IP when starting the daemon. To use TLS-based communications, we need to follow
    this procedure (assuming your server hostname is in the `$HOST` variable):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 TCP 套接字启用对 Docker 守护进程的远程访问。默认情况下，通信将不安全，并且守护进程将在端口`2375`上监听。为了确保客户端与守护进程之间的连接是加密的，您需要使用反向代理或内建的基于
    TLS 的 HTTPS 加密套接字。我们可以允许守护进程在所有主机接口的 IP 地址上监听，或者仅使用此 IP 地址启动守护进程时进行监听。要使用基于 TLS
    的通信，我们需要遵循以下步骤（假设您的服务器主机名在 `$HOST` 变量中）：
- en: 'Create a **certificate authority** (**CA**). The following commands will create
    its private and public keys:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建**证书颁发机构**（**CA**）。以下命令将创建其私钥和公钥：
- en: '[PRE5]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a server CA-signed key, ensuring that the common name matches the hostname
    you use to connect to Docker daemon from the client:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个服务器 CA 签名的密钥，确保公共名称与您用于从客户端连接到 Docker 守护进程的主机名匹配：
- en: '[PRE6]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Start Docker daemon with TLS enabled and use arguments for the CA, server certificate,
    and CA-signed key. This time, Docker daemon using TLS will run on port `2376`
    (which is standard for the daemon TLS):'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动启用TLS的Docker守护程序，并使用CA、服务器证书和CA签名的密钥作为参数。这次，使用TLS的Docker守护程序将在端口`2376`上运行（这是守护程序TLS的标准端口）：
- en: '[PRE7]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the same CA, create a client CA-signed key, specifying that this key
    will be used for client authentication:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的CA，创建一个客户端CA签名的密钥，指定该密钥将用于客户端身份验证：
- en: '[PRE8]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will move generated client certificates to the client''s host (the client''s
    laptop, for example). We will also copy the public CA certificate file. With its
    own client certificates and the CA, we will be able to connect to a remote Docker
    daemon using TLS to secure the communications. We will use the Docker command
    line with `--tlsverify` and other arguments to specify the server''s same CA,
    the client certificate, and its signed key (the daemon''s default port for TLS
    communications is `2376`). Let''s review an example using `docker version`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将生成的客户端证书移动到客户端主机（例如客户端的笔记本电脑）。我们还将复制公共CA证书文件。拥有自己的客户端证书和CA后，我们将能够使用TLS连接到远程Docker守护程序以保护通信。我们将使用带有`--tlsverify`和其他参数的Docker命令行来指定服务器的相同CA、客户端证书及其签名密钥（守护程序的TLS通信默认端口为`2376`）。让我们通过`docker
    version`命令查看一个示例：
- en: '[PRE9]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All these steps should be done to provide TLS communications, and *steps 4*
    and *5* should be undertaken for all client connections if we want to identify
    their connections (if you don't want to use a unique client certificate/key pair,
    for example). On enterprise environments, with hundreds or even thousands of users,
    this is ungovernable and Docker Enterprise will provide a better solution with
    all these steps included automatically, thereby providing granulated accesses.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供TLS通信，应完成所有这些步骤，并且*步骤4*和*5*应用于所有客户端连接，如果我们希望识别它们的连接（例如，如果不想使用唯一的客户端证书/密钥对）。在企业环境中，具有数百甚至数千用户时，这是不可管理的，Docker
    Enterprise将通过自动包含所有这些步骤提供更好的解决方案，从而提供细粒度的访问控制。
- en: Since Docker version 18.09, we can interact with Docker daemon using the `$
    docker -H ssh://me@example.com:22 ps` command, for example. To use the SSH connection,
    you need to set up an ssh public key authentication.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker 18.09版本起，我们可以使用`$ docker -H ssh://me@example.com:22 ps`命令与Docker守护程序交互。要使用SSH连接，您需要设置SSH公钥身份验证。
- en: Docker daemon security
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker守护程序安全性
- en: 'Docker container runtime security is based on the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器运行时安全性基于以下内容：
- en: Security provided by the kernel to containers
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核为容器提供的安全性
- en: The attack surface of the runtime itself
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时本身的攻击面
- en: Operating system security applied to the runtime
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于运行时的操作系统安全性
- en: Let's take a look at these in more detail.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些内容。
- en: Namespaces
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'We have been talking about kernel namespaces and how they implement the required
    isolation for containers. Every container runs with the following namespaces:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论内核命名空间及其如何为容器实现所需的隔离。每个容器都使用以下命名空间运行：
- en: '`pid`: Process isolation (**Process ID** – **PID**)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid`：进程隔离（**进程ID** – **PID**）'
- en: '`net`: Manages network interfaces (**Networking** – **NET**)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`：管理网络接口（**网络** – **NET**）'
- en: '`ipc`: Manages access to IPC resources (**InterProcess Communication** – **IPC**)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipc`：管理对IPC资源（**进程间通信** – **IPC**）'
- en: '`mnt`: Manages filesystem mount points (**Mount** – **MNT**)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnt`：管理文件系统挂载点（**挂载** – **MNT**）'
- en: '`uts`: Isolates kernel and version identifiers (**Unix Timesharing System**
    – **UTS**)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uts`：隔离内核和版本标识符（**Unix分时系统** – **UTS**）'
- en: As each container runs with its own `pid` namespace, it will only have access
    to the listed process on this namespace. The `net` namespace will provide its
    own interfaces, which will allow us to start many processes using the same port
    on different containers. Container visibility is enabled by default. All containers
    will have access to external networks using host bridge interfaces.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都以自己的`pid`命名空间运行，它只能访问此命名空间中列出的进程。`net`命名空间将提供自己的接口，允许我们在不同容器上的相同端口上启动多个进程。容器的可见性默认启用。所有容器将通过主机桥接口访问外部网络。
- en: A complete root filesystem will be inside each container, and it will use this
    as a standard Unix filesystem (with its own `/tmp`, and network files such as
    `/etc/hosts` and `/etc/resolv.conf`). This dedicated filesystem is based on copy-on-write,
    using different layers from images.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器内部都会有一个完整的根文件系统，并将其用作标准的 Unix 文件系统（具有自己的 `/tmp`，以及网络文件如 `/etc/hosts` 和 `/etc/resolv.conf`）。这个专用文件系统基于写时复制（copy-on-write），使用来自镜像的不同层。
- en: Namespaces provide layers of isolation for the container, and control groups
    will manage how many resources will be available for the container. This will
    ensure that the host will not get exhausted. In multi-tenant environments, or
    just for production, it is very important to manage the resources of containers
    and to not allow non-limited containers.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间为容器提供了隔离层，而控制组将管理容器可以使用的资源量。这将确保主机不会耗尽资源。在多租户环境中，或者仅仅是为了生产环境，管理容器资源非常重要，不能允许没有资源限制的容器。
- en: The attack surface of the daemon is based on user access. By default, Docker
    daemon does not provide any role-based access solution, but we have seen that
    we can ensure an encrypted communication for external clients.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程的攻击面基于用户访问权限。默认情况下，Docker 守护进程不提供任何基于角色的访问解决方案，但我们已经看到我们可以为外部客户端确保加密通信。
- en: As Docker daemon runs as root (the experimental mode will allow us to run rootless),
    all containers will be able to, for example, mount any directory on your host.
    This can be a real problem and that is why it's so important to ensure that only
    required users have access to the Docker socket (local or remote).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 守护进程以 root 用户身份运行（实验模式将允许我们以无 root 模式运行），所有容器都将能够，例如，挂载主机上的任何目录。这可能是一个真正的问题，这也是为什么确保只有必要的用户才能访问
    Docker 套接字（无论是本地还是远程）是如此重要。
- en: As we will see in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml), *Running
    Docker Containers*, containers will run as root if we don't specify a user on
    image building or container startup. We will review this topic later and improve
    this default user usage.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 3 章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)《运行 Docker 容器》中看到的，*如果我们在构建镜像或启动容器时未指定用户，容器将以
    root 用户身份运行*。我们稍后会复习这个话题并改进默认的用户使用方式。
- en: It is recommended to run just Docker daemon on server-dedicated hosts because
    Docker can be dangerous in the wrong hands when it comes to other services running
    on the same host.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在专用主机上仅运行 Docker 守护进程，因为当其他服务也运行在同一主机时，Docker 可能会非常危险。
- en: User namespace
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户命名空间
- en: As we've already seen, Linux namespaces provide isolation for processes. These
    processes just see what cgroups and these namespaces offer, and for these processes,
    they are running along on their own.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Linux 命名空间为进程提供了隔离。这些进程只能看到 cgroups 和这些命名空间所提供的内容，对这些进程来说，它们在独立运行。
- en: We always recommend running processes inside containers as non-root users (`nginx`,
    for example, does not require root to be running if we use upper ports), but there
    are some cases where they must be run as root. To prevent privilege escalation
    from within these root containers, we can apply user remapping. This mechanism
    will map a root user (UID 0) inside the container, with the user's non-root (UID
    30000).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终建议在容器内以非 root 用户身份运行进程（例如，`nginx` 如果使用上层端口，则无需 root 权限即可运行），但有些情况下它们必须以
    root 用户身份运行。为了防止这些 root 容器内的权限提升，我们可以应用用户重映射。该机制将容器内的 root 用户（UID 0）映射为非 root
    用户（UID 30000）。
- en: 'User remapping is managed by two files:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 用户重映射由两个文件管理：
- en: '`/etc/subid`: This sets the user ID range for subordinates.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/subid`：这设置了下属的用户 ID 范围。'
- en: '`/etc/subgid`: This sets the group ID range for subordinates.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/subgid`：这设置了下属的组 ID 范围。'
- en: With these files, we set the first sequence ID for users and groups, respectively.
    This is an example format for the subordinate ID, `nonroot:30000:65536`. This
    means that UID 0 inside the container will be mapped as UID `30000` on the Docker
    host and so forth.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些文件，我们分别为用户和组设置了第一个序列 ID。这是下属 ID 的示例格式，`nonroot:30000:65536`。这意味着容器内的 UID
    0 将映射为 Docker 主机上的 UID `30000`，依此类推。
- en: We will configure Docker daemon to use this user remapping with the `--userns-remap`
    flag or the `userns-remap` key in JSON format. In special cases, we can change
    the user namespace behavior when running the container.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置 Docker 守护进程，使用 `--userns-remap` 标志或 JSON 格式中的 `userns-remap` 键来使用此用户重映射。在特殊情况下，我们可以在运行容器时更改用户命名空间的行为。
- en: Kernel capabilities (seccomp)
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核能力（seccomp）
- en: By default, Docker starts containers with a restricted set of capabilities.
    This means that containers will run unprivileged by default. So, running processes
    inside containers improves application security by default.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker以有限的能力集启动容器。这意味着容器默认以无特权模式运行。因此，在容器内运行进程默认提高了应用程序的安全性。
- en: 'These are the 14 capabilities available by default to any container running
    in your system: `SETPCAP`, `MKNOD`, `AUDIT_WRITE`, `CHOWN`, `NET_RAW`, `DAC_OVERRIDE`,
    `FOWNER`, `FSETID`, `KILL`, `SETGID`, `SETUID`, `NET_BIND_SERVICE`, `SYS_CHROOT`,
    and `SETFCAP`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是默认情况下在你的系统中运行的任何容器可用的14种能力：`SETPCAP`、`MKNOD`、`AUDIT_WRITE`、`CHOWN`、`NET_RAW`、`DAC_OVERRIDE`、`FOWNER`、`FSETID`、`KILL`、`SETGID`、`SETUID`、`NET_BIND_SERVICE`、`SYS_CHROOT`、和`SETFCAP`。
- en: The most important thing to understand at this point is that we can run processes
    inside a container listening on ports under 1024 because we have `NET_BIND_SERVICE`
    capability, for example, or that we can use ICMP inside containers because we
    have `NET_RAW` capability enabled.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此时最重要的理解点是，我们可以在容器内部运行监听1024以下端口的进程，因为我们具备了`NET_BIND_SERVICE`能力，例如，或者我们可以在容器内使用ICMP，因为我们启用了`NET_RAW`能力。
- en: On the other hand, there are many capabilities not enabled by default. For example,
    there are many system operations that will need `SYS_ADMIN` capability, or we
    will need `NET_ADMIN` capability to create new interfaces (running `openvpn` inside
    Docker containers will require it).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有许多能力默认情况下并未启用。例如，许多系统操作需要`SYS_ADMIN`能力，或者我们需要`NET_ADMIN`能力来创建新的接口（在Docker容器中运行`openvpn`时需要此能力）。
- en: 'Processes will not have real root privileges inside containers. Using seccomp
    capabilities, it is possible to do the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内的进程不会拥有实际的root权限。通过使用seccomp能力，可以做到以下几点：
- en: Deny `mount` operations
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝`mount`操作
- en: Deny access to raw sockets (to prevent packet spoofing)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝访问原始套接字（以防止数据包欺骗）
- en: Deny access to some filesystem operations, such as file ownership
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝访问某些文件系统操作，例如文件所有权
- en: Deny module loading, and many others
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝模块加载，以及其他许多操作
- en: 'The permitted capabilities are defined using a default `seccomp` profile. Docker
    uses `seccomp` in filter mode, disabling all non-whitelisted calls defined on
    its own JSON format in profile files. There is a default profile that will be
    used when running containers. We can use our own `seccomp` profile using the `--security-opt`
    flag on launch. So, manipulating allowed capabilities is easy during container
    execution. We will learn more about how to manipulate the behavior of any container
    at the start of [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)*, Running
    Docker Containers*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的能力是通过默认的`seccomp`配置文件定义的。Docker在过滤模式下使用`seccomp`，禁用所有未在其JSON格式的配置文件中列入白名单的调用。运行容器时会使用默认配置文件。我们可以通过在启动时使用`--security-opt`标志来使用自定义的`seccomp`配置文件。因此，在容器执行过程中，操作允许的能力非常简单。我们将在[第3章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)*，运行Docker容器*的开始部分学习更多关于如何操作容器行为的内容：
- en: '[PRE10]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This line will run our container, adding the `NET_ADMIN` capability. Using a
    custom `seccomp` profile, we will be adding even more, as defined on `custom-profile.json`.
    For security reasons, we can even use `--cap-drop` to drop some of the default
    capabilities if we are sure that we don't need them.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将运行我们的容器，添加`NET_ADMIN`能力。使用自定义的`seccomp`配置文件，我们将添加更多能力，如`custom-profile.json`中所定义的。出于安全原因，如果我们确定不需要某些默认能力，还可以使用`--cap-drop`来删除它们。
- en: Avoid using the `--privileged` flag as your container will run unconfined, which
    means that it will run nearly with the same access to the host as processes running
    outside containers on the host. In this case, resources will be unlimited for
    this container (the `SYS_RESOURCE` capability will be enabled and limit flags
    will not be used). Best practice for users would be to remove all capabilities
    except those required by the process to work.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`--privileged`标志，因为你的容器将在无约束的情况下运行，这意味着它将几乎与主机上运行的进程具有相同的访问权限。此时，该容器的资源将不受限制（`SYS_RESOURCE`能力将被启用，且限制标志不会被使用）。对于用户来说，最佳做法是移除所有不必要的能力，只保留进程运行所需的能力。
- en: Linux security modules
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux安全模块
- en: Linux operating systems provide tools to ensure security. In some cases, they
    come installed and configured by default in out-of-the-box installations, while
    in other cases, they will require additional administrator interaction.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统提供了确保安全的工具。在某些情况下，它们会在开箱即用的安装中预先安装并配置好，而在其他情况下，则需要管理员进行额外的配置。
- en: AppArmor and SELinux are probably the most common. Both provide finer-grained
    control over file operations and other security features. For example, we can
    ensure that only the allowed process can modify some special files or directories
    (for example, `/etc/passwd`).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor和SELinux可能是最常见的两种。它们都提供对文件操作和其他安全功能的更细粒度控制。例如，我们可以确保只有允许的进程可以修改一些特殊的文件或目录（例如，`/etc/passwd`）。
- en: Docker provides templates and policies that are installed with the product that
    ensures complete integration with these tools to harden Docker hosts. Never disable
    SELinux or AppArmor on production and use policies to add features or accesses
    for your processes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供的模板和策略随产品一起安装，确保与这些工具的完整集成，从而增强Docker主机的安全性。绝不在生产环境中禁用SELinux或AppArmor，而是使用策略为你的进程添加功能或访问权限。
- en: We can review which security modules are enabled in our Docker runtime by looking
    at the `SecurityOptions` section of the `Docker system info` output.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看`Docker system info`输出中的`SecurityOptions`部分来检查在我们的Docker运行时中启用了哪些安全模块。
- en: We can easily review Docker runtime features using `docker system info`. It
    is good to know that the output can be displayed in JSON format using `docker
    system info --format '{{json .}}'` and that we can filter by using the `--filter`
    option. Filtering allows us, for example, to retrieve only security options applied
    to the `docker system info --format '{{json .SecurityOptions}}'` daemon.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`docker system info`轻松查看Docker运行时功能。需要注意的是，输出可以通过`docker system info
    --format '{{json .}}'`以JSON格式显示，而且我们可以使用`--filter`选项进行过滤。例如，过滤可以帮助我们仅获取应用于`docker
    system info --format '{{json .SecurityOptions}}'`守护进程的安全选项。
- en: By default, Red Hat flavor hosts will not have SELinux enabled, but, on the
    other hand, Ubuntu will run by default with AppArmor.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Red Hat版本的主机不会启用SELinux，另一方面，Ubuntu默认情况下会启用AppArmor。
- en: There is a very common issue when we move the default Docker data root path
    to another location in Red Hat Linux. If SELinux is enabled (by default on these
    systems), you will need to add a new path to the allowed context by using `# semanage
    fcontext -a -e /var/lib/docker _MY_NEW_DATA-ROOT_PATH` and then `# restorecon
    -R -v _MY_NEW_DATA-ROOT_PATH`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在将默认Docker数据根路径移动到Red Hat Linux的其他位置时，有一个非常常见的问题。如果启用了SELinux（在这些系统上默认启用），则需要通过使用`#
    semanage fcontext -a -e /var/lib/docker _MY_NEW_DATA-ROOT_PATH`来将新路径添加到允许的上下文中，然后使用`#
    restorecon -R -v _MY_NEW_DATA-ROOT_PATH`。
- en: Docker Content Trust
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker内容信任
- en: 'Docker Content Trust is the mechanism provided by Docker to improve content
    security. It will provide image ownership and verification of immutability. This
    option, which is applied at Docker runtime, will help to harden content execution.
    We can ensure that only certain images can run on Docker hosts. This will provide
    two different levels of security:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Docker内容信任是Docker提供的一种机制，用于增强内容安全性。它将提供镜像的所有权和不可变性的验证。此选项在Docker运行时应用，有助于加强内容执行的安全性。我们可以确保只有特定的镜像可以在Docker主机上运行。这将提供两个不同级别的安全性：
- en: Only allow signed images
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅允许签名镜像
- en: Only allow signed images by certain users or groups/teams (we will learn about
    the concepts that are integrated with Docker UCP in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅允许特定用户或组/团队签名的镜像（我们将在[第11章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)中了解与Docker
    UCP集成的概念，*统一控制平面*）
- en: We will learn about volumes, which are the objects used for container persistent
    storage, in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml), *Container
    Persistency and Networking*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)中了解卷，这些卷是用于容器持久存储的对象，*容器持久性和网络*。
- en: Enabling and disabling Docker Content Trust can be managed by setting the `DOCKER_CONTENT_TRUST=1`
    environment variable in a client session, in the `systemd` Docker unit. Alternatively,
    we can use `--disable-content-trust=false` (true by default) on image and container
    operations.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 启用和禁用Docker内容信任可以通过在客户端会话中设置`DOCKER_CONTENT_TRUST=1`环境变量，在`systemd` Docker单元中进行管理。或者，我们可以在镜像和容器操作中使用`--disable-content-trust=false`（默认值为true）。
- en: With any of these flags enabling content trust, all Docker operations will be
    trusted, which means that we won't be able to download and execute any non-trusted
    flags (signed images).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 启用任何这些标志以启用内容信任时，所有Docker操作都会被信任，这意味着我们将无法下载和执行任何非受信任的标志（签名镜像）。
- en: Chapter labs
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章实验
- en: We will use CentOS 7 as the operating system for the node labs in this book,
    unless otherwise indicated. We will install Docker Community Edition now and Docker
    Enterprise for the specific chapters pertaining to this platform.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，否则我们将在本书中使用 CentOS 7 作为节点实验室的操作系统。我们将现在安装 Docker 社区版，并在涉及该平台的特定章节中安装
    Docker 企业版。
- en: Deploy `environments/standalone-environment` from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment`folder to start your virtual
    environment.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请从本书的 GitHub 仓库（[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)）部署
    `environments/standalone-environment`。您也可以使用自己的 CentOS 7 服务器。请从 `environments/standalone-environment`
    文件夹使用 `vagrant up` 启动虚拟环境。
- en: 'If you are using a standalone environment, wait until it is running. We can
    check the statuses of the nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是独立环境，请等待直到它正在运行。我们可以使用 `vagrant status` 来检查节点的状态。使用 `vagrant ssh standalone`
    连接到您的实验节点。`standalone` 是您的节点名称。您将使用具有 root 权限的 `vagrant` 用户，通过 `sudo` 进行操作。您应该会看到以下输出：
- en: '[PRE11]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now connect to a standalone node using `vagrant ssh standalone`. This
    process may vary if you''ve already deployed a standalone virtual node before
    and you just started it using `vagrant up`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `vagrant ssh standalone` 连接到独立节点。如果您之前已部署过独立虚拟节点，并且只是使用 `vagrant up`
    启动它，那么这个过程可能会有所不同：
- en: '[PRE12]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, you are ready to start the labs.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始实验了。
- en: Installing the Docker runtime and executing a "hello world" container
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker 运行时并执行一个 "hello world" 容器
- en: 'This lab will guide you through the Docker runtime installation steps and running
    your first container. Let''s get started:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验将引导您完成 Docker 运行时安装步骤，并运行您的第一个容器。让我们开始吧：
- en: 'To ensure that no previous versions are installed, we will remove any `docker*`
    packages:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保没有安装任何旧版本，我们将删除任何 `docker*` 软件包：
- en: '[PRE13]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the required packages by running the following command:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来添加所需的软件包：
- en: '[PRE14]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will be using a stable release, so we will add its package repository, as
    follows:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个稳定版本，因此我们将添加其软件包仓库，如下所示：
- en: '[PRE15]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, install Docker packages and `containerd`. We are installing the server
    and client on this host (since version 18.06, Docker provides different packages
    for `docker-cli` and Docker daemon):'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，安装 Docker 软件包和 `containerd`。我们正在为此主机安装服务器和客户端（自版本 18.06 起，Docker 提供了不同的软件包用于
    `docker-cli` 和 Docker 守护进程）：
- en: '[PRE16]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Docker is installed, but on Red Hat-like operating systems, it is not enabled
    on boot by default and will not start. Verify this situation and enable and start
    the Docker service:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 已安装，但在类似 Red Hat 的操作系统中，默认情况下它不会在启动时启用，因此不会自动启动。验证这种情况并启用并启动 Docker 服务：
- en: '[PRE17]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that Docker is installed and running, we can run our first container:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Docker 已安装并正在运行，我们可以运行我们的第一个容器：
- en: '[PRE18]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command will send a request to Docker daemon to run a container based on
    the `hello-world` image, located on Docker Hub ([http://hub.docker.com](http://hub.docker.com)).
    To use this image, Docker daemon downloads all the layers if we have not executed
    any container with this image before; in other words, if the image is not present
    on the local Docker host. Once all the image layers have been downloaded, Docker
    daemon will start a `hello-world` container.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将向 Docker 守护进程发送请求，运行一个基于 `hello-world` 镜像的容器，该镜像位于 Docker Hub 上（[http://hub.docker.com](http://hub.docker.com)）。为了使用此镜像，如果我们之前没有运行过任何该镜像的容器，Docker
    守护进程将下载所有镜像层；换句话说，如果该镜像在本地 Docker 主机上不存在。一旦所有镜像层下载完成，Docker 守护进程将启动一个 `hello-world`
    容器。
- en: This book is a guide for the DCA exam and is the simplest lab we can easily
    deploy. However, you should be able to understand and describe this simple process,
    as well as think about all the common issues that we may encounter. For example,
    what happens if the image is on your host and is different, but with the same
    name and tags? What happens if one layer cannot be downloaded? What happens if
    you are connected to a remote daemon? We will review some of these questions at
    the end of this chapter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是DCA考试的指南，也是我们可以轻松部署的最简单实验。尽管如此，你应该能够理解并描述这个简单的过程，并思考我们可能遇到的所有常见问题。例如，如果镜像在你的主机上并且不同，但名称和标签相同，会发生什么？如果某一层无法下载，会发生什么？如果你连接到远程守护进程，会发生什么？我们将在本章末尾回顾其中的一些问题。
- en: 'As you should have noticed, we are always using `sudo` to root because our
    user has not got access to the Docker UNIX socket. This is the first security
    layer an attacker must bypass on your system. We usually enable a user to run
    containers in production environments because we want to isolate operating system
    responsibilities and management from Docker. Just add our user to the Docker group,
    or add a new group of users with access to the socket. In this case, we will just
    add our lab user to the Docker group:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你应该已经注意到的，我们总是使用`sudo`来获取根权限，因为我们的用户没有访问Docker UNIX套接字的权限。这是攻击者必须绕过的系统的第一层安全防护。我们通常在生产环境中启用用户运行容器，因为我们希望将操作系统的职责和管理与Docker隔离开来。只需要将我们的用户添加到Docker组中，或者添加一个新组，允许该组的用户访问套接字。在这种情况下，我们将把我们的实验室用户添加到Docker组中：
- en: '[PRE19]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Docker runtime processes and namespace isolation
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker运行时进程与命名空间隔离
- en: 'In this lab, we are going to review what we learned about process isolation
    and Docker daemon components and execution workflow. Let''s get started:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将回顾我们关于进程隔离、Docker守护进程组件和执行工作流的学习内容。让我们开始吧：
- en: 'Briefly review the Docker `systemd` daemon:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简要回顾一下Docker的`systemd`守护进程：
- en: '[PRE20]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This output shows that the service is using a default `systemd` unit configuration
    and that `dockerd` is using the default parameters; that is, it's using the file
    descriptor socket on `/var/run/docker.sock` and the default `docker0` bridge interface.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示服务使用的是默认的`systemd`单元配置，并且`dockerd`使用默认参数；也就是说，它使用的是`/var/run/docker.sock`上的文件描述符套接字和默认的`docker0`桥接接口。
- en: 'Notice that `dockerd` uses a separate `containerd` process to execute containers.
    Let''s run some containers in the background and review their processes. We will
    run a simple alpine with an `nginx` daemon:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`dockerd`使用一个单独的`containerd`进程来执行容器。让我们在后台运行一些容器并查看它们的进程。我们将运行一个简单的alpine镜像，带有`nginx`守护进程：
- en: '[PRE21]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will look for the `nginx` and `containerd` processes (process IDs will
    be completely different on your system; you just need to understand the workflow):'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将查找`nginx`和`containerd`进程（进程ID在你的系统上会完全不同；你只需要理解其工作流程）：
- en: '[PRE22]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that, at the end, the container started from `20848` PID. Following
    the `runtime-runc` location, we discover `state.json`, which is the container
    state file:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，最后，容器是从PID `20848`启动的。跟随`runtime-runc`位置，我们发现了`state.json`，它是容器的状态文件：
- en: '[PRE23]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This file contains container runtime information: PID, mounts, devices, capabilities
    applied, resources, and more.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含容器运行时信息：PID、挂载、设备、应用的能力、资源等。
- en: 'Our NGINX server runs under PID `20863` and the `nginx` child process with
    PID `20901` on the Docker host, but let''s take a look inside:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的NGINX服务器在Docker主机上运行，其PID为`20863`，而`nginx`子进程的PID为`20901`，但让我们深入了解一下：
- en: '[PRE24]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using `docker container exec`, we can run a new process using a container namespace.
    This is like running a new process inside the container.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker container exec`，我们可以使用容器命名空间运行一个新进程。这就像在容器内运行一个新进程。
- en: As you can observe, inside the container, `nginx` has PID `1` and it is the
    worker process parent. And, of course, we see our command, `ps -ef`, because it
    was launched using its namespaces.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所观察到，在容器内部，`nginx`的PID是`1`，它是工作进程的父进程。当然，我们可以看到我们的命令`ps -ef`，因为它是通过使用其命名空间启动的。
- en: We can run other containers using the same image and we will obtain the same
    results. Processes inside each container are isolated from other containers and
    host processes, but users on the Docker host will see all the processes, along
    with their real PIDs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的镜像运行其他容器，并获得相同的结果。每个容器内部的进程与其他容器和主机进程是隔离的，但Docker主机上的用户可以看到所有进程及其真实PID。
- en: 'Let''s take a look at `nginx` process namespaces. We will use the `lsns` command
    to review all the host-running process''s namespaces. We will obtain a list of
    all running processes and their namespaces. We will look for `nginx` processes
    (we will not use `grep` to filter the output because we want to read the headers):'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看 `nginx` 进程命名空间。我们将使用 `lsns` 命令来查看所有主机运行的进程命名空间。我们将获取所有正在运行的进程及其命名空间的列表。我们将查找
    `nginx` 进程（我们不会使用 `grep` 来过滤输出，因为我们希望查看标题）：
- en: '[PRE25]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This lab demonstrated process isolation within a process running inside containers.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验演示了容器内进程的隔离。
- en: Docker capabilities
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 能力
- en: 'This lab will cover seccomp capability management. We will launch containers
    using dropped capabilities to ensure that, by using seccomp to avoid some system
    calls, processes in containers will only execute allowed actions. Let''s get started:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验将涵盖 seccomp 能力管理。我们将使用丢弃的能力启动容器，以确保通过使用 seccomp 避免某些系统调用，容器内的进程仅执行允许的操作。让我们开始吧：
- en: 'First, run a container using the default allowed capabilities. During the execution
    of this alpine container, we will change the ownership of the `/etc/passwd` file:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用默认允许的能力运行一个容器。在执行这个 Alpine 容器时，我们将更改 `/etc/passwd` 文件的所有权：
- en: '[PRE26]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, there is nothing to stop us from changing whatever file ownership
    resides inside the container's filesystem because the main process (in this case,
    `/bin/sh`) runs as the root user.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，没有任何事情能阻止我们更改容器文件系统内的文件所有权，因为主进程（在本例中是 `/bin/sh`）以 root 用户身份运行。
- en: 'Drop all the capabilities. Let''s see what happens:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 丢弃所有能力。让我们看看会发生什么：
- en: '[PRE27]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will observe that the operation was forbidden. Since containers run without
    any capabilities, the `chown` command is not allowed to change file ownership.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现操作被禁止了。由于容器在没有任何能力的情况下运行，`chown` 命令不允许更改文件所有权。
- en: 'Now, just add the `CHOWN` capability to allow a change of ownership for files
    inside the container:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需添加 `CHOWN` 能力，允许更改容器内文件的所有权：
- en: '[PRE28]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how modern applications are based on microservices.
    We learned what containers are and their benefits, and how microservices and containers
    match when we associate a process with specific functionality or a task (microservice)
    and we run it inside a container. We reviewed container concepts. Then, we talked
    about images, containers, and the mechanisms that isolate processes from the host.
    We introduced orchestration and registries as requirements for deploying applications
    with resilience on cluster environments and the ways in which we can manage images.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了现代应用程序如何基于微服务构建。我们了解了什么是容器及其优点，以及微服务和容器如何匹配。当我们将一个进程与特定功能或任务（微服务）关联并将其运行在容器内时，我们探讨了容器的概念。接着，我们谈论了镜像、容器以及将进程与主机隔离的机制。我们介绍了编排和注册表，作为在集群环境中部署具有韧性的应用程序的要求，以及我们可以管理镜像的方式。
- en: We then have learned about Docker's main components and how Docker Client interacts
    with Docker Engine securely. We introduced the most common Docker objects and
    the workflow we will use to create, share, and deploy new applications based on
    containers.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们了解了 Docker 的主要组件以及 Docker 客户端如何与 Docker 引擎安全交互。我们介绍了最常见的 Docker 对象以及我们将用来创建、共享和部署基于容器的新应用程序的工作流程。
- en: Nowadays, we can use containers on Microsoft Windows, but this all started with
    Linux. We compared both approaches to understand the similarities and differences
    between them and the advanced methods used to isolate processes on Windows using
    Hyper-V.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Microsoft Windows 上使用容器，但这一切始于 Linux。我们比较了这两种方法，以理解它们之间的相似性和差异，并探讨了在
    Windows 上使用 Hyper-V 隔离进程的高级方法。
- en: Finally, we reviewed how to configure Docker Engine using JSON files and environment
    variables, learned that containers are secure by default, and reviewed the different
    mechanisms used to accomplish this.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了如何使用 JSON 文件和环境变量配置 Docker 引擎，了解到容器默认是安全的，并回顾了实现这一点的不同机制。
- en: In the next chapter, we will build images using different methods and learn
    the processes and primitives necessary to create good images.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用不同的方法构建镜像，并学习创建优质镜像所需的流程和原语。
- en: Questions
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it true that we can only run one process per container? (select which sentences
    are true)
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个进程可以在每个容器中运行吗？（选择哪些句子是正确的）
- en: a) We cannot execute more than one process per container. This is a limitation.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: a) 我们不能在每个容器中执行多个进程。这是一个限制。
- en: b) We can run more than one process per container, but it is not recommended.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: b) 我们可以在一个容器中运行多个进程，但不推荐这样做。
- en: c) We will only run one process per container to follow microservices logic.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: c) 我们将只在每个容器中运行一个进程，以遵循微服务逻辑。
- en: d) All of the above sentences are false.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: d) 上述所有句子都是错误的。
- en: What kernel facilities provide host CPU resource isolation on containers?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些内核功能提供容器的主机 CPU 资源隔离？
- en: a) Kernel namespaces.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: a) 内核命名空间。
- en: b) Cgroups (control groups).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: b) Cgroups（控制组）。
- en: c) Kernel domains.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: c) 内核域。
- en: d) None of them. It is not possible to isolate host resources.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: d) 都不是。无法隔离主机资源。
- en: Which of the following sentences are true?
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些句子是正确的？
- en: a) All containers will run as root by default.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: a) 所有容器默认都将以 root 用户身份运行。
- en: b) The user namespace will allow us to map UID 0 to another one on our host
    system, controlled and without any non-required privileges.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: b) 用户命名空间将允许我们将 UID 0 映射到主机系统上的另一个 UID，受控并且没有任何不必要的权限。
- en: c) As the Docker daemon runs as root, only root users can run containers on
    Docker hosts.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: c) 由于 Docker 守护进程以 root 用户身份运行，因此只有 root 用户才能在 Docker 主机上运行容器。
- en: d) All of the above sentences are false.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: d) 上述所有句子都是错误的。
- en: What have we learned about Windows Docker hosts?
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们关于 Windows Docker 主机学到了什么？
- en: a) Linux containers can run on Windows hosts too.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: a) Linux 容器也可以在 Windows 主机上运行。
- en: b) Windows Hyper-V containers will run a small virtual machine, providing the
    required resources for containers and do not have any Windows operating system
    dependencies.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: b) Windows Hyper-V 容器将运行一个小型虚拟机，为容器提供所需资源，并且没有任何 Windows 操作系统依赖性。
- en: c) Windows Process Isolation requires system DLLs and services on containers
    to run properly, and do not provide complete portability.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: c) Windows 进程隔离需要系统 DLL 和服务才能在容器中正常运行，且无法提供完全的可移植性。
- en: d) Windows images are bigger than Linux ones because Windows operating system
    component integrations are required in many cases to run even small processes.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: d) Windows 镜像比 Linux 镜像大，因为许多情况下，运行即使是小进程也需要集成 Windows 操作系统组件。
- en: Which of the following sentences are true regarding the Docker daemon configuration?
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些句子关于 Docker 守护进程配置是正确的？
- en: a) We will configure Docker daemon on Linux using JSON format keys and values
    on `/etc/docker/daemon.json` or `systemd` unit files.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: a) 我们将在 Linux 上使用 JSON 格式的键值对配置 Docker 守护进程，配置文件位于 `/etc/docker/daemon.json`
    或 `systemd` 单元文件中。
- en: b) On Windows hosts, we will use `%programdata%\docker\config\daemon.json` to
    configure Docker daemon.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在 Windows 主机上，我们将使用 `%programdata%\docker\config\daemon.json` 来配置 Docker
    守护进程。
- en: c) By default, the Docker client connection to the remote Docker daemon is insecure.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: c) 默认情况下，Docker 客户端连接到远程 Docker 守护进程是不安全的。
- en: d) None of the above sentences are true.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: d) 上述句子都不正确。
- en: Further reading
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'What are microservices?: [https://microservices.io/](https://microservices.io/)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是微服务?: [https://microservices.io/](https://microservices.io/)'
- en: 'What is a container?: [https://www.docker.com/resources/what-container](https://www.docker.com/resources/what-container)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是容器?: [https://www.docker.com/resources/what-container](https://www.docker.com/resources/what-container)'
- en: 'What is Docker?: [https://www.redhat.com/en/topics/containers/what-is-docker](https://www.redhat.com/en/topics/containers/what-is-docker)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是 Docker?: [https://www.redhat.com/en/topics/containers/what-is-docker](https://www.redhat.com/en/topics/containers/what-is-docker)'
- en: 'Docker Engine installation and configuration: [https://docs.docker.com/engine/](https://docs.docker.com/engine/)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 引擎安装与配置: [https://docs.docker.com/engine/](https://docs.docker.com/engine/)'
- en: 'Docker storage drivers: [https://docs.docker.com/storage/storagedriver/](https://docs.docker.com/storage/storagedriver/)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 存储驱动程序: [https://docs.docker.com/storage/storagedriver/](https://docs.docker.com/storage/storagedriver/)'
