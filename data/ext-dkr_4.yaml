- en: Chapter 4. Network Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 网络插件
- en: 'In this chapter, we are going to be looking at the next type of plugin: networking.
    We will discuss how to make use of the new networking tools introduced with Docker
    1.9, along with third-party tools that add even more functionality to the already
    powerful built-in tools. The two main tools that we are going to look at are as
    follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍下一种插件类型：网络。我们将讨论如何使用 Docker 1.9 引入的新网络工具，以及第三方工具，这些工具为已经强大的内置工具增加了更多功能。我们将关注的两个主要工具如下：
- en: '**Docker Overlay Network**: [https://docs.docker.com/engine/userguide/networking/dockernetworks/](https://docs.docker.com/engine/userguide/networking/dockernetworks)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 覆盖网络**: [https://docs.docker.com/engine/userguide/networking/dockernetworks/](https://docs.docker.com/engine/userguide/networking/dockernetworks/)'
- en: '**Weave**: [https://weave.works/](https://weave.works)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Weave**: [https://weave.works/](https://weave.works)'
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter assumes that you are using Docker 1.10+, some commands may not
    work in the previous versions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您使用的是 Docker 1.10+ 版本，某些命令可能在旧版本中无法使用。
- en: Docker networking
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络
- en: Before we start to go into detail about Networking in Docker, I should mention
    that we have managed to make it to the fourth chapter in the book without having
    to really think about networking, this is because, by default, Docker creates
    a network bridge between the containers and your host machine's network interface.
    This is Docker networking at its most basic form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始详细讨论 Docker 中的网络之前，我应该提到，我们已经顺利进入本书的第四章，而不需要真正思考网络问题，这是因为 Docker 默认在容器和主机机器的网络接口之间创建了一个网络桥接。这是
    Docker 网络的最基本形式。
- en: Like basic storage, this limits you to bring up your containers on a single
    host even when using a clustering tool such as Docker Swarm, as you may have already
    noticed in [Chapter 2](ch02.html "Chapter 2. Introducing First-party Tools"),
    *Introducing First-party Tools*, when we were bringing up our WordPress installation,
    the web and database containers where launched on a single host within the cluster.
    If we were to try and bind each of the two containers to different host, they
    would not be able to talk to each other.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基本存储一样，这限制了您在单个主机上启动容器，即使您使用了像 Docker Swarm 这样的集群工具，正如您在[第二章](ch02.html "第二章
    引入第一方工具")，*引入第一方工具*中所看到的，当我们启动 WordPress 安装时，Web 和数据库容器都是在集群中的单个主机上启动的。如果我们尝试将这两个容器绑定到不同的主机，它们将无法相互通信。
- en: Luckily, Docker has you covered and provides its own multi-host networking layer
    to use with Docker Swarm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker 为您提供了支持，并提供了自己的多主机网络层，供 Docker Swarm 使用。
- en: Multi-host networking with overlays
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多主机网络与覆盖网络
- en: Docker released its production-ready multi-host overlay networking functionality
    in Docker 1.9\. Before this release, the functionality was classed as experimental.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在 Docker 1.9 中发布了其生产就绪的多主机覆盖网络功能。在此版本之前，这个功能被视为实验性的。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An overlay network is a computer network that is built on top of another network.
    Nodes in the overlay network can be thought of as being connected by virtual or
    logical links, each of which corresponds to a path, perhaps through many physical
    links, in the underlying network:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖网络是一种建立在另一个网络之上的计算机网络。覆盖网络中的节点可以被认为是通过虚拟或逻辑链路连接的，每条链路对应一个路径，可能通过许多物理链路，在底层网络中传输：
- en: '[https://en.wikipedia.org/wiki/Overlay_network](https://en.wikipedia.org/wiki/Overlay_ne)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Overlay_network](https://en.wikipedia.org/wiki/Overlay_ne)'
- en: 'In Docker terms, it allows containers on one Docker host to talk directly to
    containers on another Docker host as if they were on the same host, as shown in
    the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 术语中，它允许一个 Docker 主机上的容器直接与另一个 Docker 主机上的容器通信，就好像它们在同一主机上一样，如下图所示：
- en: '![Multi-host networking with overlays](img/B05468_04_06.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![多主机网络与覆盖网络](img/B05468_04_06.jpg)'
- en: 'As you can see from the preceding diagram, there are some prerequisites. Firstly,
    you must be running a Docker Swarm cluster. Here we have a Docker Swarm cluster
    made up of two nodes and a master, all of which have the overlay network configured.
    You will also need a Service Discovery service, where it can be accessed by the
    Docker Swarm cluster. For this, you can use the following applications:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的图示中看到的，首先有一些前提条件。首先，您必须运行一个 Docker Swarm 集群。在这里，我们有一个由两个节点和一个主节点组成的 Docker
    Swarm 集群，它们都已配置了覆盖网络。您还需要一个服务发现服务，该服务可以被 Docker Swarm 集群访问。为此，您可以使用以下应用程序：
- en: '**Consul**: [https://www.consul.io/](https://www.consul.io/)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul**: [https://www.consul.io/](https://www.consul.io/)'
- en: '**Etcd**: [https://coreos.com/etcd/](https://coreos.com/etcd/)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Etcd**：[https://coreos.com/etcd/](https://coreos.com/etcd/)'
- en: '**ZooKeeper**: [http://zookeeper.apache.org/](http://zookeeper.apache.org/)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ZooKeeper**：[http://zookeeper.apache.org/](http://zookeeper.apache.org/)'
- en: For the purpose of this chapter, we will be using Consul by HashiCorp ([https://hashicorp.com/](https://hashicorp.com/))
    and we will also be launching our cluster using Docker Machine in DigitalOcean.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用HashiCorp的Consul（[https://hashicorp.com/](https://hashicorp.com/)），并且我们还将通过Docker
    Machine在DigitalOcean上启动我们的集群。
- en: Launching Discovery
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动发现
- en: Back in [Chapter 2](ch02.html "Chapter 2. Introducing First-party Tools"), *Introducing
    First-party Tools*, we launched our Docker Swarm cluster using a one-off token
    from the Docker hub. One of the requirements of multi-host networking is a persistent
    key/value store so that we have permanent and accessible place to store values
    about our cluster, we will be using Consul to provide this in our example cluster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。介绍第一方工具")，*介绍第一方工具*，我们通过Docker Hub中的一次性令牌启动了我们的Docker
    Swarm集群。多主机网络的一个要求是持久化的键值存储，以便我们有一个永久且可访问的地方来存储有关集群的值，我们将在我们的示例集群中使用Consul来提供这个功能。
- en: Consul is an open source tool written by HashiCorp for discovering and configuring
    services in an infrastructure. It provides several key features, including Service
    Discovery, health checking, and a key/value store, all while being multi-datacenter
    aware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Consul是由HashiCorp编写的开源工具，用于在基础设施中发现和配置服务。它提供了多个关键功能，包括服务发现、健康检查和键值存储，并且能够支持多数据中心。
- en: 'To launch the Docker host, which will run Consul, run the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动将运行Consul的Docker主机，运行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You may notice that we have added an additional line to the `docker-machine`
    command, this launches the DigitalOcean Droplet with private networking enabled.
    Once the Docker host has launched, we can launch the Consul service by running
    the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们在`docker-machine`命令中添加了一个额外的行，这样会启动具有私有网络的DigitalOcean Droplet。一旦Docker主机启动完成，我们可以通过运行以下命令启动Consul服务：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will download a copy of my Consul container image, also now there is an
    official image that can be found at [https://hub.docker.com/_/consul/](https://hub.docker.com/_/consul/);
    however, this image as it is new may not work with the preceding example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载我的Consul容器镜像，现在也有一个官方镜像，可以在[https://hub.docker.com/_/consul/](https://hub.docker.com/_/consul/)找到；然而，由于这个镜像是新的，可能不适用于前面的示例。
- en: 'As this is the only command we need to run on this host, we are not configuring
    our local Docker client to use the host; instead, we are passing the configuration
    over at runtime using `$(docker-machine config service-discovery)`. To check whether
    everything is running as expected, you can run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们在此主机上需要运行的唯一命令，我们没有配置本地的Docker客户端以使用该主机；相反，我们是在运行时通过`$(docker-machine
    config service-discovery)`传递配置。为了检查一切是否按预期运行，你可以运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you should see a single container running something similar to the following
    terminal output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该看到一个正在运行的容器，类似于以下终端输出：
- en: '![Launching Discovery](img/B05468_04_07.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![启动发现](img/B05468_04_07.jpg)'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before we progress further, it should be noted that launching Consul with the
    `-bootstrap-expect 1` flag should never be attempted in production. You should
    consider bringing multiple Consul hosts. For more information on a highly available
    Consul cluster, refer to the following URL for details on how to configure a full
    Consul cluster:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步推进之前，应该注意，使用`-bootstrap-expect 1`标志启动Consul不应在生产环境中尝试。你应该考虑引入多个Consul主机。有关如何配置高度可用的Consul集群的更多信息，请参考以下网址，了解如何配置完整的Consul集群：
- en: '[https://www.consul.io/docs/guides/bootstrapping.html](https://www.consul.io/docs/guides/bootstrapping.html)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.consul.io/docs/guides/bootstrapping.html](https://www.consul.io/docs/guides/bootstrapping.html)'
- en: 'You can also get an idea of what information Docker will be storing in Consul
    by opening the web interface, to do this type the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过打开Web界面来了解Docker将会在Consul中存储哪些信息，方法是输入以下命令：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see an almost empty Consul view, as shown in the following image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个几乎空白的Consul视图，如下图所示：
- en: '![Launching Discovery](img/B05468_04_08.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![启动发现](img/B05468_04_08.jpg)'
- en: We will come back to the web interface once we have launched the Docker Swarm
    cluster. Now we have the service discover container running and accessible, it's
    time to start launching the rest of the cluster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了Docker Swarm集群并且服务发现容器正在运行并可以访问，我们将返回Web界面，开始启动其余的集群部分。
- en: Readying the Swarm
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Swarm
- en: 'Let''s start to launch the Docker Swarm cluster, first of all the Swarm master.
    We will call this `chapter04-00`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始启动Docker Swarm集群，首先是Swarm主节点。我们将其命名为`chapter04-00`：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the command is very similar to the one used in [Chapter 2](ch02.html
    "Chapter 2. Introducing First-party Tools"), *Introducing First-party Tools*;
    however, we are supplying details of our Consul installation. We are doing this
    by passing in the IP address of the `service-discovery` host using the `docker-machine
    ip` command.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令与[第2章](ch02.html "第2章：介绍第一方工具")中的命令非常相似，*介绍第一方工具*；然而，我们这里提供了Consul安装的详细信息。我们通过使用`docker-machine
    ip`命令传递`service-discovery`主机的IP地址来做到这一点。
- en: 'Once the Swarm master is booted, we are going to launch two Swarm nodes using
    the following commands:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Swarm主节点启动，我们将使用以下命令启动两个Swarm节点：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the second node, we are going to use the following commands:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个节点，我们将使用以下命令：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have our master and two nodes up and running, let''s switch to
    the environment and make sure that the cluster is showing the correct number of
    hosts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了主节点和两个节点，让我们切换到环境中，并确保集群显示正确的主机数量：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see something similar to the following screenshot when running `docker
    info`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker info`时，你应该会看到类似于以下截图的内容：
- en: '![Readying the Swarm](img/B05468_04_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![准备Swarm](img/B05468_04_01.jpg)'
- en: So, we now have our cluster launched, and everything is talking to each other.
    We will now be able to create our overlay network.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经启动了集群，所有节点都能相互通信。接下来，我们将能够创建我们的覆盖网络。
- en: Adding the overlay network
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加覆盖网络
- en: 'For testing purpose, we are going to be creating a very basic network and launching
    a very basic container. The following command will create the overlay network,
    and thanks to the service-discovery provided by Consul, the network settings will
    be distributed to each node within our Docker Swarm cluster:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们将创建一个非常基础的网络并启动一个非常基础的容器。以下命令将创建覆盖网络，并且得益于Consul提供的服务发现，网络设置将分发到Docker
    Swarm集群中的每个节点：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, there you have it, we have created an overlay network called `chapter04-overlay-network`
    with a subnet of `10.0.9.0/24` on our cluster. To make sure that everything is
    OK, you can run the following commands to list the networks configured within
    the cluster:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，我们已经在集群中创建了一个名为`chapter04-overlay-network`的覆盖网络，子网为`10.0.9.0/24`。为了确保一切正常，你可以运行以下命令来列出集群中配置的网络：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also check on the individual nodes by running the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过运行以下命令来检查各个节点：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Adding the overlay network](img/B05468_04_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![添加覆盖网络](img/B05468_04_02.jpg)'
- en: As you can see, each node has its host and bridge networks available, meaning
    that you don't have to use the overlay network if you don't want to; however,
    we do so that its time to launch a container and configure it to use our newly
    added network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个节点都有自己的主机和桥接网络，这意味着如果你不想使用覆盖网络，完全可以不使用；不过，我们使用它，这样就可以启动一个容器并配置它使用我们新添加的网络。
- en: Using the overlay network
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用覆盖网络
- en: 'To start with, we will be launching a container that runs NGINX:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将启动一个运行NGINX的容器：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we are configuring our container to use `chapter04-overlay-network`
    by passing the `--net` flag. We are also making sure that the container is launched
    on the `chapter04-01` node. Next up, let's see if we can view the content being
    served by our NGINX container.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过传递`--net`标志来配置容器使用`chapter04-overlay-network`。我们还确保容器在`chapter04-01`节点上启动。接下来，让我们看看能否查看到NGINX容器提供的内容。
- en: 'To do this, let''s launch a container on our second node, `chapter04-02`, and
    run `wget` to fetch the page being served by NGINX:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在第二个节点`chapter04-02`上启动一个容器，并运行`wget`来获取NGINX提供的页面：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If everything went as planned, you will see `Hello from NGINX` returned by
    the command. We can also ping the NGINX container from the second node by running
    the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，你将会看到命令返回`Hello from NGINX`。我们也可以通过在第二个节点上运行以下命令来ping NGINX容器：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see an IP address within the 10.0.9.0/24 subnet returned, as shown
    in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到一个IP地址，位于10.0.9.0/24子网范围内，正如下面的截图所示：
- en: '![Using the overlay network](img/B05468_04_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用覆盖网络](img/B05468_04_03.jpg)'
- en: 'If you want to take a look at the network that has been configured on the `chapter04-web`
    container, you can run the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看已经配置在`chapter04-web`容器上的网络，可以运行以下命令：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see something similar to the following terminal output returned:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于以下终端输出的内容：
- en: '![Using the overlay network](img/B05468_04_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用覆盖网络](img/B05468_04_04.jpg)'
- en: 'Finally, you can access the container in your browser by running the following
    command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过运行以下命令在浏览器中访问容器：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The page will look something similar to the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 页面将会类似于以下截图所示：
- en: '![Using the overlay network](img/B05468_04_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用覆盖网络](img/B05468_04_05.jpg)'
- en: While the page itself isn't much to look at, there are actually some quite clever
    things going on in the background that you may not have noticed, the biggest of
    which is that we haven't had to link our containers together. In the previous
    chapters, we had used the link flag when launching multiple containers to link
    them together. Now we are launching our containers in the same Overlay Network,
    Docker assumes that all of the containers within this network will be able to
    talk each other, and it handles the linking of the containers automatically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然页面本身看起来并不复杂，但实际上后台有一些相当巧妙的操作你可能没有注意到，其中最大的一点是我们不再需要手动链接我们的容器。在前几章中，我们在启动多个容器时使用了link标志来将它们链接在一起。现在，我们在同一个Overlay网络中启动容器，Docker假设这个网络中的所有容器都能相互通信，并且它会自动处理容器之间的链接。
- en: Docker has also configured a gateway for the containers in order to be able
    to route traffic outside of our Overlay Network by default. If you wanted to create
    an internal only networking, then you could add the `--internal` flag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还为容器配置了一个网关，以便能够默认将流量路由到我们的Overlay网络外部。如果你想创建一个仅限内部的网络，可以添加`--internal`标志。
- en: Back to Consul
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回到Consul
- en: 'Don''t forget that while we have been creating the networks and launching our
    containers, the service discovery container has been running in the background.
    Going back to the Consul web interface, you should notice that under the **Key/Value**
    option, you will see a list of the nodes within our Docker Swarm cluster:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，在我们创建网络和启动容器时，服务发现容器一直在后台运行。返回到Consul的Web界面，你应该会注意到在**Key/Value**选项下，你会看到Docker
    Swarm集群内节点的列表：
- en: '![Back to Consul](img/B05468_04_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![返回到Consul](img/B05468_04_09.jpg)'
- en: 'Clicking around, you should also see other values, such as the networking ones,
    that are being shared within the Docker Swarm cluster:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 点击查看，你还应该看到其他一些共享的值，例如网络相关的，这些都在Docker Swarm集群中共享：
- en: '![Back to Consul](img/B05468_04_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![返回到Consul](img/B05468_04_10.jpg)'
- en: Before we tear down our Docker Swarm cluster, let's look at launching our WordPress
    stack using Docker Compose.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拆除Docker Swarm集群之前，让我们先看看如何使用Docker Compose启动WordPress栈。
- en: Composing multi-host networks
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多主机网络
- en: 'As in the previous chapters, we are going to launch our trusty WordPress installation.
    We are going to make it a little interesting by:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如同前几章一样，我们将启动我们可靠的WordPress安装。我们将稍微有些不同，添加一些有趣的部分：
- en: Creating an external network called `wpoutside`. This network will be able to
    get external access, our webserver will be launched over here.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`wpoutside`的外部网络。这个网络将能够进行外部访问，我们的网站服务器将会在这里启动。
- en: Creating an internal network called `wpinside`. This network will not be able
    to get any external access, on containers on the same network will be able to
    access, we will be adding both web server and database containers to this network.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`wpinside`的内部网络。这个网络无法进行外部访问，但同一网络上的容器能够相互访问，我们将把网站服务器和数据库容器添加到这个网络中。
- en: Launching our web server container one node and the database container on our
    second node.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动我们的网站服务器容器在一个节点上，数据库容器在第二个节点上。
- en: 'Before we launch our containers, we should terminate the `chapter04-web` container:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动容器之前，我们应该终止`chapter04-web`容器：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s create two overlay networks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个覆盖网络：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we are giving the networks different subnets, and for `wpinside`,
    we are passing the `--internal` flag, meaning that the network will not have an
    external gateway.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为网络分配了不同的子网，而对于`wpinside`，我们传递了`--internal`标志，这意味着该网络将没有外部网关。
- en: 'Now, let''s take a look at our `docker-compose.yml` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们的`docker-compose.yml`文件：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, I have highlighted the changes made in the file since the previous
    chapter. The interesting thing to note is that while it is possible to define
    your network within the `docker-compose.yml` file, you will get a lot more control
    by setting up the network using the `docker network create` command. To do this,
    we need to tell Docker Compose to use the externally defined networks for the
    project. We are also using labels to bind the containers to a host in our Docker
    Swarm cluster.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我已经标出了自上一章以来文件中的更改。有趣的是，尽管可以在`docker-compose.yml`文件中定义网络，但通过使用`docker network
    create`命令设置网络，您将获得更多的控制权。为此，我们需要告诉Docker Compose使用为项目外部定义的网络。我们还使用标签将容器绑定到我们Docker
    Swarm集群中的主机。
- en: 'Now that we have the two overlay networks created, you can launch the WordPress
    stack by running the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了两个覆盖网络，您可以通过运行以下命令启动WordPress堆栈：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can check everything launched as expected by running the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令检查一切是否按预期启动：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make sure that the containers have launched on different hosts, run the
    following command and check the last column:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保容器在不同主机上启动，请运行以下命令并检查最后一列：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see what IP addresses are assigned to the containers, run the following
    commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看分配给容器的IP地址，请运行以下命令：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see two IP addresses for `my-wordpress-app` and a single for `my-wordpress-database`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到`my-wordpress-app`的两个IP地址和`my-wordpress-database`的单个IP地址：
- en: '![Composing multi-host networks](img/B05468_04_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![构建多主机网络](img/B05468_04_11.jpg)'
- en: 'Before we log in to WordPress, we can try some ping tests. First, we will run
    the tests on your `my-wordpress-app` container by running the following commands:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们登录WordPress之前，可以尝试一些ping测试。首先，我们将在您的`my-wordpress-app`容器上运行以下命令：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the first command, you will see Google''s external IP address returned.
    For the second, you will get the IP of your `my-wordpress-database` container,
    which will be on the `10.0.11.0/24` subnet we defined for the `wpinside` overlay
    network:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一条命令，您将看到返回的谷歌外部IP地址。对于第二条命令，您将获得`my-wordpress-database`容器的IP地址，它位于我们为`wpinside`覆盖网络定义的`10.0.11.0/24`子网中：
- en: '![Composing multi-host networks](img/B05468_04_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![构建多主机网络](img/B05468_04_11.jpg)'
- en: 'Trying similar commands on `my-wordpress-database` should give you different
    results, try running the following commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`my-wordpress-database`上尝试类似命令应该会给您不同的结果，尝试运行以下命令：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, pinging `my-wordpress-app` works fine; however, when you try
    and ping Google, you get an error saying something like `Network is unreachable`
    or some another error. This is exactly what we would expect to see as `my-wordpress-database`
    has no external network access and therefore it cannot route to `www.google.com`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ping `my-wordpress-app`正常工作；但是，当您尝试ping Google时，会收到类似“网络无法访问”或其他错误的消息。这正是我们预期的结果，因为`my-wordpress-database`没有外部网络访问权限，因此无法路由到`www.google.com`：
- en: '![Composing multi-host networks](img/B05468_04_12.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![构建多主机网络](img/B05468_04_12.jpg)'
- en: 'Finally, if you would like to access WordPress, you can type in either of the
    following commands. First of all, we need to confirm which host the `my-wordpress-app`
    container is launched on. To confirm the host, run:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想访问WordPress，可以输入以下命令之一。首先，我们需要确认`my-wordpress-app`容器启动在哪个主机上。要确认主机，请运行：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, depending on which host, run one of the following three commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据不同的主机，运行以下三条命令之一：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Your browser will open the now familiar WordPress installation page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器将打开现在熟悉的WordPress安装页面。
- en: 'Before moving on further, you should tear down your Docker Swarm cluster. To
    do this, run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您应该拆除Docker Swarm集群。为此，请运行以下命令：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summing up multi-host networking
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结多主机网络
- en: Although overlay networks were classed as production-ready in Docker version
    1.9, with the advancements in Docker version 1.10 and the new Docker Compose v2
    file format, Docker networking has really come into its own.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Docker 1.9版本中，覆盖网络被视为生产就绪，但随着Docker 1.10版本的进步以及新的Docker Compose v2文件格式的推出，Docker网络真的得到了更好的发展。
- en: While the overlay network functionality is built into Docker and Swarm, as you
    have seen in the examples we have worked through, it is extremely powerful. When
    used in conjunction with third-party volume plugins that we covered in [Chapter
    3](ch03.html "Chapter 3. Volume Plugins"), *Volume Plugins*, and Docker Swarm,
    we can start to build highly available deployments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然覆盖网络功能已内置于Docker和Swarm中，正如我们在之前的示例中所看到的，它非常强大。当与我们在[第3章](ch03.html "第3章：卷插件")中介绍的第三方卷插件、*卷插件*以及Docker
    Swarm结合使用时，我们可以开始构建高可用的部署。
- en: Weaving a network
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编织网络
- en: Next up, we are going to take a look at Weave Net and Scope by Weaveworks. This
    is one of the original Docker networking tools, and at its core, it is a mature
    software-defined networking service.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看Weave Net和Weaveworks的Scope。这是最初的Docker网络工具之一，其核心是一个成熟的软件定义网络服务。
- en: 'Weave Net is described as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Weave Net的描述如下：
- en: '*"Weave Net creates a container SDN that can run across any mixture of public
    and private cloud, virtual machines and bare metal. The container SDN can carry
    any layer 2 and layer 3 traffic, including multicast. If you can run it over Ethernet,
    you can run it on Weave Net."*'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Weave Net 创建了一个容器SDN，可以跨任何公共和私有云、虚拟机以及裸机运行。容器SDN可以承载任何二层和三层流量，包括多播。如果它可以通过以太网运行，您就可以在Weave
    Net上运行。"*'
- en: 'In fact, there are two drivers provided by Weave, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Weave提供了两个驱动，如下所示：
- en: Weave Mesh is a local scope driver that operates without the need for a cluster
    store. It can be used to create networks that span non-clustered machines. With
    this, you get a single network called Weave, which spans all of the machines you
    have Weave launched on.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weave Mesh是一个本地作用域驱动，它在不需要集群存储的情况下运行。它可以用来创建跨非集群机器的网络。通过这种方式，您可以获得一个名为Weave的单一网络，覆盖您启动Weave的所有机器。
- en: Weave, like Docker's own overlay driver, is a global scope driver. This means
    that it can be used with Docker Swarm and Docker Compose, because of this, you
    will need to launch a cluster store.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weave像Docker自己的覆盖驱动一样，是一个全局作用域驱动。这意味着它可以与Docker Swarm和Docker Compose一起使用，因此，您需要启动一个集群存储。
- en: First of all, let's look at the Weave driver and how to use it with Docker Swarm
    and then we will take a look at using the Weavemesh driver.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下Weave驱动及其如何与Docker Swarm一起使用，然后我们将看看如何使用Weavemesh驱动。
- en: Configuring a Cluster again
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次配置集群
- en: 'Like Docker multi-host networking, we will need to launch a service discovery
    instance and our Swarm cluster. Let''s launch the service discovery host with
    Docker Machine:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 像Docker的多主机网络一样，我们需要启动一个服务发现实例和我们的Swarm集群。让我们使用Docker Machine启动服务发现主机：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, we don''t need to enable the Consul web interface, so run the following
    command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不需要启用Consul web界面，因此运行以下命令：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now launch the Docker Swarm cluster, first the master:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动Docker Swarm集群，首先是主节点：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we will launch our first node:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将启动我们的第一个节点：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we will launch the second node:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将启动第二个节点：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To check whether everything is working as expected, run the following commands
    to switch our local Docker client to connect to the Swarm cluster and also check
    whether the three nodes are visible:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切是否按预期工作，运行以下命令切换我们的本地Docker客户端连接到Swarm集群，并检查三个节点是否可见：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Installing and configuring Weave
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置Weave
- en: 'Now that we have our cluster up and running, we can install and configure Weave.
    Installing Weave is simple, all you have to do is download the binary and give
    it the correct permissions. Let''s do this on the Swarm master using `docker-machine
    ssh` to connect to the host and run the `install` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的集群已经启动并运行，我们可以安装和配置Weave。安装Weave非常简单，您只需下载二进制文件并给予正确的权限。在Swarm主节点上使用`docker-machine
    ssh`连接到主机并运行`install`命令来完成此操作：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we start Weave, again using `docker-machine ssh`, we can run the following
    command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动Weave，再次使用`docker-machine ssh`，我们可以运行以下命令：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will have notice that Weave deployed three containers from the Docker Hub,
    they are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，Weave从Docker Hub部署了三个容器，它们如下所示：
- en: weaveworks/weaveexec
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weaveworks/weaveexec
- en: weaveworks/weave
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weaveworks/weave
- en: weaveworks/plugin
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weaveworks/plugin
- en: Also, we are telling Weave to expect three peers to join the cluster by passing
    the `--init-peer-count 3` flag, that's pretty much all we have to do to configure
    Weave on our first cluster node.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们告诉Weave预期有三个节点加入集群，通过传递`--init-peer-count 3`标志来实现，这基本上就是我们在第一个集群节点上配置Weave所需做的全部。
- en: 'Next, we need to install Weave onto our other two cluster nodes, again using
    the `docker-machine ssh` command run the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在其他两个集群节点上安装 Weave，仍然使用 `docker-machine ssh` 命令运行以下内容：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have Weave up and running on the node, we need to tell it to connect
    to the Weave installation running on the Swarm master. To do this, run the following
    command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 Weave 已经在节点上启动并运行，我们需要告诉它连接到 Swarm 主节点上运行的 Weave 安装。为此，请运行以下命令：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then on our last cluster node, we will run the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们最后一个集群节点上，我们将运行以下命令：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once all three nodes in the Swarm cluster have Weave installed and configured,
    we will run the following command to ensure that all three nodes are talking to
    each other:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Swarm 集群中的所有三个节点都安装并配置了 Weave，我们将运行以下命令，以确保所有三个节点能够相互通信：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The command should return confirmation that there are three peers with six
    established connections along with other information about the installation, as
    shown in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该返回确认信息，显示有三个对等节点以及六个已建立的连接，并附带其他安装信息，如以下截图所示：
- en: '![Installing and configuring Weave](img/B05468_04_14.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![安装和配置 Weave](img/B05468_04_14.jpg)'
- en: 'Now that we have confirmation that everything is working as expected, we will
    list the networks in Docker using the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认一切按预期工作，我们将使用以下命令列出 Docker 中的网络：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As per the following terminal session, you should see that there is a `weavemesh`
    network called `weave` on each of the nodes within the cluster; we will discuss
    more about that later:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下终端会话，你应该会看到集群中每个节点都有一个名为 `weave` 的 `weavemesh` 网络；我们稍后会进一步讨论这点：
- en: '![Installing and configuring Weave](img/B05468_04_15.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![安装和配置 Weave](img/B05468_04_15.jpg)'
- en: Docker Compose and Weave
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose 和 Weave
- en: 'So, let''s launch our WordPress installation. The Docker Compose file looks
    a little different from the overlay network one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们启动我们的 WordPress 安装。Docker Compose 文件看起来与 Overlay 网络的文件略有不同：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I have highlighted a few changes from the Overlay Docker Compose file: first
    off, we will define a hostname and provide a DNS server and search domain. To
    get the right values for the `dns` and `dns_search` keys, you can run the following
    command to have Weave let you know what it has configured:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我突出显示了 Overlay Docker Compose 文件中的一些更改：首先，我们将定义一个主机名并提供 DNS 服务器和搜索域。为了获得 `dns`
    和 `dns_search` 键的正确值，你可以运行以下命令，让 Weave 告诉你它已配置的内容：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, in my case, it returned `172.17.0.1` and `weave.local`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在我的情况下，它返回了`172.17.0.1`和`weave.local`：
- en: '![Docker Compose and Weave](img/B05468_04_16.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Docker Compose 和 Weave](img/B05468_04_16.jpg)'
- en: Also, for the MySQL connection from the WordPress container to the Database
    one, we are using the internal DNS name as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于从 WordPress 容器到数据库容器的 MySQL 连接，我们也在使用内部 DNS 名称。
- en: We are also letting Docker Compose create a network for us using the Weave driver,
    this will add a single network named after the project. Docker Compose gets the
    project name from the folder our Docker Compose file is, in my case, it's a folder
    called `wordpress`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还让 Docker Compose 为我们创建一个使用 Weave 驱动程序的网络，这将添加一个以项目命名的单一网络。Docker Compose
    从 Docker Compose 文件所在的文件夹中获取项目名称，在我的例子中，它是一个名为 `wordpress` 的文件夹。
- en: 'To launch your containers and check whether they are running as expected, run
    the following commands:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动你的容器并检查它们是否按预期运行，请运行以下命令：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see something similar to the following terminal output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于以下终端输出的内容：
- en: '![Docker Compose and Weave](img/B05468_04_17.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Docker Compose 和 Weave](img/B05468_04_17.jpg)'
- en: 'If you really want to, you can access your WordPress installation by running
    the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想要，你可以通过运行以下命令访问你的 WordPress 安装：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are some things happening in the background that Docker''s multi-host
    networking doesn''t give you, such as internal DNS. Weave has its own internal
    DNS system that you can register your containers with, as you saw in the Docker
    Compose file that we provided details for records for both containers. Run the
    following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台有一些 Docker 的多主机网络无法提供的功能，例如内部 DNS。Weave 有自己的内部 DNS 系统，你可以在其中注册你的容器，正如我们在
    Docker Compose 文件中为两个容器提供的记录详细信息所示。运行以下命令：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It will show you all the DNS records that Weave has configured. In my case,
    it looks like the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示 Weave 配置的所有 DNS 记录。在我的情况下，它看起来像以下截图：
- en: '![Docker Compose and Weave](img/B05468_04_18.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Docker Compose 和 Weave](img/B05468_04_18.jpg)'
- en: Weave Scope
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Weave Scope
- en: While we have our three-node Swarm cluster up and running, let's quickly install
    Scope. Scope is a tool for visualizing your Containers and host. We will just
    be installing it to run locally, but Weave Works will be offering a cloud-based
    service, which can be found at [http://scope.weave.works/](http://scope.weave.works/)
    (at the time of writing this book, it was in private beta).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的三节点 Swarm 集群启动并运行时，快速安装 Scope。Scope 是一个用于可视化你的容器和主机的工具。我们将只在本地安装它，但 Weave
    Works 会提供基于云的服务，可以在 [http://scope.weave.works/](http://scope.weave.works/) 找到（在编写本书时，它还处于私有测试阶段）。
- en: Similar to the way we installed Weave Net, we will be using the `docker-machine
    ssh` command to download the binary and launch and configure the service.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们安装 Weave Net 的方式，我们将使用 `docker-machine ssh` 命令来下载二进制文件并启动和配置服务。
- en: 'We will write the code on the Swarm master first:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 Swarm 主节点上编写代码：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we will write the code for remaining two nodes:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为剩下的两个节点编写代码：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see on the two remaining nodes, we are telling Scope to connect to
    the Scope instance running on the Swarm master.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在剩下的两个节点上，我们正在告诉 Scope 连接到在 Swarm 主节点上运行的 Scope 实例。
- en: 'Now that Scope is installed, open it in your browser by running the following
    command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Scope 已经安装，运行以下命令在浏览器中打开它：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When your browser opens, you will be presented with a visual representation
    of your Swarm cluster, and the containers that are running.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的浏览器打开时，你将看到一个关于你 Swarm 集群和正在运行的容器的可视化表示。
- en: 'I am not going to go into any more detail on Scope here, as at the moment,
    it doesn''t have much to do with networking, have a look around to start seeing
    more information on your cluster and how it all hangs together. Mine looked similar
    to the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不打算深入讲解 Scope，因为目前它与网络配置关系不大，先浏览一下你的集群，看看它是如何连接在一起的。我的界面看起来类似于下面的截图：
- en: '![Weave Scope](img/B05468_04_19.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Weave Scope](img/B05468_04_19.jpg)'
- en: Calling off the Swarm
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消 Swarm
- en: As you can see, while Weave is quite a powerful SDN, it is straightforward to
    configure. However, replicating the multi-host networking Docker provides is only
    one of its tricks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，虽然 Weave 是一个功能强大的 SDN，但它的配置非常简单。然而，复制 Docker 提供的多主机网络仅仅是它的一个小技巧。
- en: 'Let''s shut down our Swarm cluster and terminate the hosts before we start
    to look at the Weavemesh network driver:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始查看 Weavemesh 网络驱动之前，让我们关闭我们的 Swarm 集群并终止主机：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Before you move on, log in to your DigitalOcean control panel and make sure
    that you don't have any machines labelled with `chapter04` running, remember that
    you will be charged per hour whether you are using them or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，登录到你的 DigitalOcean 控制面板，确保没有标记为 `chapter04` 的机器正在运行，记住，无论你是否使用这些机器，都会按小时收费。
- en: Weavemesh Driver
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Weavemesh 驱动
- en: We have looked at how Weave Net can by used alongside a Docker Swarm cluster
    to create multi-host networking, now let's take a look at the second Weave network
    driver, Weavemesh. As you may recall, when we first installed Weave Net, a network
    called "weave" was automatically create using the "weavemesh" driver on each node
    within our cluster.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何将 Weave Net 与 Docker Swarm 集群一起使用来创建多主机网络，现在让我们来看看第二个 Weave 网络驱动——Weavemesh。正如你可能记得的那样，当我们第一次安装
    Weave Net 时，系统会自动创建一个名为 "weave" 的网络，并使用 "weavemesh" 驱动程序在我们集群的每个节点上配置。
- en: This time, let's bring up two independent Docker hosts DigitalOcean using Docker
    Machine. To make it interesting, we will launch one host in London and the other
    in New York City. As these are going to be acting as individual hosts, we do not
    need to launch a key/value store, or configure Docker Swarm.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，让我们使用 Docker Machine 在 DigitalOcean 上启动两个独立的 Docker 主机。为了增加趣味性，我们将在伦敦启动一台主机，另一个则在纽约市。由于这些将作为独立主机运行，我们不需要启动键值存储，也不需要配置
    Docker Swarm。
- en: 'First, type the following command to launch a host in London host:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入以下命令来启动一个位于伦敦的主机：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, the following command is to launch another host is New York City.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，下面的命令是用来启动另一个位于纽约市的主机。
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we have our two Docker hosts up and running, let''s install and configure
    Weave:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的两台 Docker 主机都已启动并运行，接下来让我们安装并配置 Weave：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see, this time we are telling Weave to launch with a password. This
    flag will enable encryption between the networking layer on our two hosts. Now
    that we have the London host configured, let''s do the one in New York City and
    then get it talking to the host in London:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这次我们告诉 Weave 启动时使用密码。这个标志将启用我们两个主机之间网络层的加密。现在我们已经配置了伦敦主机，让我们配置纽约市的主机，并让它与伦敦主机进行通信：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we have Weave configured on our two hosts, we can check the status
    of Weave by running the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在两台主机上配置了 Weave，我们可以通过运行以下命令来检查 Weave 的状态：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see from the following terminal output, encryption is enabled and
    we have two peers within our Weave network:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从下面的终端输出可以看出，已启用加密，并且我们在 Weave 网络中有两个对等节点：
- en: '![Weavemesh Driver](img/B05468_04_20.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Weavemesh Driver](img/B05468_04_20.jpg)'
- en: 'So, let''s take a look at Weave''s party trick. We will keep it basic to start
    with by launching our NGINX container:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看 Weave 的绝招。我们将从启动我们的 NGINX 容器开始，保持简单：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we can check whether the container is up and running:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查容器是否已启动并正在运行：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s also check whether it''s responding on port 80:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是否在端口 80 上响应：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, let''s do a ping test:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们进行一次 ping 测试：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Your terminal session should look something similar to the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你的终端会话应该看起来像下面的截图：
- en: '![Weavemesh Driver](img/B05468_04_21.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Weavemesh Driver](img/B05468_04_21.jpg)'
- en: On the surface, this test doesn't look like much; however, if you look closely
    at the commands we used, you will see just how powerful the weavemesh driver is.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，这个测试似乎没有什么特别的；然而，如果你仔细查看我们使用的命令，你会看到 weavemesh 驱动程序的强大功能。
- en: First of all, when we launched our NGINX container on the New York City Docker
    host, we did not publish any ports, meaning that port 80 was only available on
    the weave network that we attached it to.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们在纽约市的 Docker 主机上启动 NGINX 容器时，我们没有发布任何端口，这意味着端口 80 只在我们附加的 weave 网络上可用。
- en: Secondly, when we ran the check on port 80 and did the ping test, we did that
    from our Docker host in London. We temporally launched a basic container, attached
    it to the `weave` network and configured it use Weave DNS service so that it could
    resolve the `nginx.weave.local` domain.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当我们在端口 80 上进行检查并进行 ping 测试时，是在伦敦的 Docker 主机上进行的。我们临时启动了一个基本容器，将其附加到 `weave`
    网络，并配置它使用 Weave DNS 服务，这样它就可以解析 `nginx.weave.local` 域名。
- en: 'Let''s do our tests again, but this time, using a local virtual machine:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次进行测试，这次使用本地虚拟机：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, install Weave as we did on our other two Docker hosts:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照我们在其他两个 Docker 主机上所做的步骤安装 Weave：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then run the tests again:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行测试：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the ping test, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 ping 测试，如下所示：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, it worked!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它工作正常！
- en: '![Weavemesh Driver](img/B05468_04_22.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Weavemesh Driver](img/B05468_04_22.jpg)'
- en: We now have three Docker hosts in our Weavemesh network, all of which can talk
    to each other. To prove this, we are going to do one final test. Let's launch
    a container on our local Docker host and try the tests from the New York City
    host.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Weavemesh 网络中有三台 Docker 主机，它们都可以互相通信。为了证明这一点，我们将进行最后一次测试。让我们在本地 Docker
    主机上启动一个容器，并尝试从纽约市主机进行测试。
- en: 'Create a NGINX container called `vm.weave.local` on our local Docker host:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的本地 Docker 主机上创建一个名为 `vm.weave.local` 的 NGINX 容器：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then try connecting to port 80 and pinging the new container from the Docker
    host in New York City:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试从纽约市的 Docker 主机连接到端口 80 并 ping 新容器：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'My terminal session looked similar to the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我的终端会话看起来像下面的截图：
- en: '![Weavemesh Driver](img/B05468_04_23.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Weavemesh Driver](img/B05468_04_23.jpg)'
- en: Now that we don't have the constants of the Docker Swarm cluster, we can also
    start to do some tasks that are only available outside of Swarm.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于没有 Docker Swarm 集群的常量，我们也可以开始执行一些只有在 Swarm 外部才可用的任务。
- en: 'First of all, you attach container to the Weave network after they have been
    launched, let''s launch an NGINX container called `lonely` on our London Docker
    host:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在启动容器后将其连接到 Weave 网络，让我们在伦敦的 Docker 主机上启动一个名为 `lonely` 的 NGINX 容器：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, let''s connect to the London Docker host and attached the container to
    the weave network:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接到伦敦的 Docker 主机并将容器连接到 weave 网络：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When you run the command, it will return an IP address. This will be the new
    IP address of our container; in my case, it is 10.40.0.0\. Let''s run our test
    from both the New York City and Local Docker hosts:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行命令时，它会返回一个 IP 地址。这将是我们容器的新 IP 地址；在我的例子中，它是 10.40.0.0。让我们从纽约市和本地 Docker 主机运行我们的测试：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Your terminal session should look similar to the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你的终端会话应该类似于下面的截图：
- en: '![Weavemesh Driver](img/B05468_04_24.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![Weavemesh 驱动](img/B05468_04_24.jpg)'
- en: 'Now that we have our container on the network, we can manually add a DNS for
    the host by running the following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的容器已接入网络，我们可以通过运行以下命令手动为主机添加 DNS：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see, we can now access port 80 using [http://lonely.weave.local](http://lonely.weave.local)
    from our New York City Docker host:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在可以通过[http://lonely.weave.local](http://lonely.weave.local)从我们的纽约市 Docker
    主机访问端口 80：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The only downside is that there is no easy way of adding the DNS resolution
    to the host we have attached to the "weave" network.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是，无法轻松地为我们已连接到 "weave" 网络的主机添加 DNS 解析。
- en: 'Now that we are finished with our Docker hosts, let''s terminate them so that
    we don''t incur unnecessary cost:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了 Docker 主机的配置，接下来让我们终止它们，以避免不必要的费用：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Again, remember to check your DigitalOcean control panel to ensure that your
    hosts have been correctly terminated.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，请检查你的 DigitalOcean 控制面板，确保主机已正确终止。
- en: Summarizing Weave
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Weave 总结
- en: As you have seen and I have already mentioned, Weave is an incredibly powerful
    software-defined network, which is really easy to configure. Speaking from experience,
    this is a difficult combination to pull off, as most SDN solutions are incredibly
    complex to install, configure, and maintain.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我也已经提到过，Weave 是一个极其强大的软件定义网络，配置起来非常简单。根据我的经验，这是一个难得的组合，因为大多数 SDN 解决方案的安装、配置和维护都非常复杂。
- en: We have only touched on what is possible with "weave" and "weavemesh" drivers.
    For a full feature list, along with instructions on some most of the advanced
    use cases, refer to [http://docs.weave.works/weave/latest_release/features.html](http://docs.weave.works/weave/latest_release/features.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是初步接触了 "weave" 和 "weavemesh" 驱动的可能性。有关完整的功能列表以及一些高级用例的说明，请参考[http://docs.weave.works/weave/latest_release/features.html](http://docs.weave.works/weave/latest_release/features.html)。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at three different network drivers, all three
    of which add quite powerful functionality to your basic Docker installation. These,
    along with the volume drivers, really extend Docker to the point where you can
    run large fault-tolerant clusters of containers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了三种不同的网络驱动，它们都为你的基本 Docker 安装增添了非常强大的功能。与卷驱动一起，这些驱动真正扩展了 Docker，使你能够运行大规模的容错容器集群。
- en: Personally, when I first installed Weave and started to communicate with containers
    across different Docker hosts in different hosting providers so easily, I was
    absolutely blown away.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，当我第一次安装 Weave 并开始在不同托管提供商的 Docker 主机上轻松地与容器进行通信时，我简直是惊呆了。
- en: In the next chapter, we will look at how you should approach to creating your
    own extension.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨如何着手创建你自己的扩展。
