- en: Securing Kubernetes Clusters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Kubernetes 集群
- en: Security implementation is a game between a team with a total lock-down strategy
    and a team that plans to win by providing complete freedom to everyone. You can
    think of it as a battle between anarchists and totalitarians. The only way the
    game can be won is if both blend into something new. The only viable strategy
    is freedom without sacrificing security (too much).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全实现是一场由一个拥有完全封锁策略的团队与一个通过为每个人提供完全自由来取得胜利的团队之间的博弈。你可以把它看作是无政府主义者和极权主义者之间的斗争。游戏能够获胜的唯一方式是两者融合成一种新的方式。唯一可行的策略是，在不牺牲安全性的情况下实现自由（尽可能少地牺牲安全性）。
- en: Right now, our cluster is as secured as it can get. There is only one user (you).
    No one else can operate it. The others cannot even list the Pods in the cluster.
    You are the judge, the jury, and the executioner. You are the undisputed king
    with god-like powers that are not shared with anyone else.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的集群已经尽可能地安全了。这里只有一个用户（你）。没有其他人能够操作它。其他人甚至不能列出集群中的 Pods。你是裁判、陪审团和执行者。你是无可争议的王者，拥有像神一样的权力，这些权力不与任何人共享。
- en: The I-and-only-I-can-do-things strategy works well when simulating a cluster
    on a laptop. It serves the purpose when the only goal is to learn alone. The moment
    we create a "real" cluster where the whole company will collaborate (in some form
    or another), we'll need to define (and apply) an authentication and authorization
    strategy. If your business is small and there are only a few people who will ever
    operate the cluster, giving everyone the same cluster-wide administrative set
    of permissions is a simple and legitimate solution. More often than not, this
    will not be the case.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “只有我能做事”策略在模拟笔记本电脑上的集群时非常有效。当唯一的目标是独自学习时，它就能达到目的。当我们创建一个“真实”的集群，整个公司将以某种形式进行协作时，我们就需要定义（并应用）认证和授权策略。如果你的公司很小，只有少数几个人会操作集群，那么为每个人提供相同的集群范围内的管理员权限是一种简单而合法的解决方案。但大多数情况下，情况并非如此。
- en: Your company probably has people with different levels of trust. Even if that's
    not the case, different people will require different levels of access. Some will
    be allowed to do anything they want, while others will not have any type of access.
    Most will be able to do something in between. We might choose to give everyone
    a separate Namespace and forbid them from accessing others. Some might be able
    to operate a production Namespace while others might have interest only in the
    one assigned for development and testing. The number of permutations we can apply
    is infinite. Still, one thing is certain. We will need to create an authentication
    and authorization mechanism. Most likely, we'll need to create permissions that
    are sometimes applied cluster-wide and, in other cases, limited to Namespaces.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你的公司可能有不同信任级别的人。即使不是这样，不同的人也会需要不同级别的访问权限。有些人可以做任何他们想做的事情，而其他人则没有任何类型的访问权限。大多数人能够在两者之间做一些事情。我们可能选择为每个人提供一个单独的
    Namespace，并禁止他们访问其他 Namespace。有些人可能能够操作生产 Namespace，而其他人可能只对分配给开发和测试的 Namespace
    感兴趣。我们可以应用的排列组合是无限的。然而，有一点是肯定的。我们将需要创建认证和授权机制。很可能，我们需要创建一些权限，这些权限有时会在整个集群范围内应用，而在其他情况下则仅限于某些
    Namespaces。
- en: Those and many other policies can be created by employing Kubernetes authorization
    and authentication.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他许多策略可以通过使用 Kubernetes 授权和认证来创建。
- en: Accessing Kubernetes API
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 Kubernetes API
- en: Every interaction with Kubernetes goes through its API and needs to be authorized.
    That communication can be initiated through a user or a service account. All Kubernetes
    objects currently running inside our cluster are interacting with the API through
    service accounts. We won't go deep into those. Instead, we'll concentrate on the
    authorization of human users.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 的每一次交互都必须经过其 API，并且需要进行授权。这种通信可以通过用户或服务账户发起。目前在我们集群中运行的所有 Kubernetes
    对象都是通过服务账户与 API 进行交互的。我们不会深入讨论这些内容，而是专注于人类用户的授权。
- en: Typically, the Kubernetes API is served on a secured port. Our Minikube cluster
    is no exception. We can check the port from the `kubectl` config.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Kubernetes API 是在一个安全的端口上提供服务的。我们的 Minikube 集群也不例外。我们可以通过 `kubectl` 配置查看端口。
- en: All the commands from this chapter are available in the [`12-auth.sh`](https://gist.github.com/f2c4a72a1e010f1237eea7283a9a0c11)
    ([https://gist.github.com/vfarcic/f2c4a72a1e010f1237eea7283a9a0c11](https://gist.github.com/vfarcic/f2c4a72a1e010f1237eea7283a9a0c11))
    Gist.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有命令都可以在 [`12-auth.sh`](https://gist.github.com/f2c4a72a1e010f1237eea7283a9a0c11)
    ([https://gist.github.com/vfarcic/f2c4a72a1e010f1237eea7283a9a0c11](https://gist.github.com/vfarcic/f2c4a72a1e010f1237eea7283a9a0c11))
    Gist 中找到。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We used `jsonpath` to output the `cluster.server` entry located in the cluster
    with the name `minikube`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `jsonpath` 输出了位于名为 `minikube` 的集群中的 `cluster.server` 条目。
- en: 'The output is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that `kubectl` accesses the Minikube Kubernetes API on the port `8443`.
    Since the access is secured, it requires certificates which are stored as the
    `certificate-authority` entry. Let's take a look.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `kubectl` 正在通过 `8443` 端口访问 Minikube Kubernetes API。由于访问已被加密，它需要证书，这些证书存储在
    `certificate-authority` 条目中。让我们看一下。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ca.crt` certificate was created with the Minikube cluster and, currently,
    provides the only way we can access the API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ca.crt` 证书是与 Minikube 集群一起创建的，目前，它是我们访问 API 的唯一方式。'
- en: If this was a "real" cluster, we'd need to enable access for other users as
    well. We could send them the certificate we already have, but that would be very
    insecure and would lead to a lot of potential problems. Soon, we'll explore how
    to enable other users to access the cluster securely. For now, we'll focus on
    the exploration of the process Kubernetes uses to authorize requests to its API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个“真实”的集群，我们还需要为其他用户启用访问权限。我们可以将已经拥有的证书发送给他们，但那样会非常不安全，并且可能导致许多潜在问题。稍后我们将探讨如何安全地为其他用户启用集群访问权限。目前，我们将专注于探索
    Kubernetes 用于授权 API 请求的过程。
- en: Each request to the API goes through three stages. It needs to be authenticated,
    it needs to be authorized, and it needs to pass the admission control.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对 API 的请求都经过三个阶段。首先需要进行身份验证，其次需要授权，最后需要通过准入控制。
- en: The authentication process is retrieving the username from the HTTP request.
    If the request cannot be authenticated, the operation is aborted with the status
    code 401.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证过程是从 HTTP 请求中获取用户名。如果请求无法通过身份验证，则操作将以 401 状态码中止。
- en: Once the user is authenticated, the authorization validates whether it is allowed
    to execute the specified action. The authorization can be performed through ABAC,
    RBAC, or Webhook modes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户通过身份验证，授权过程将验证是否允许执行指定的操作。授权可以通过 ABAC、RBAC 或 Webhook 模式进行。
- en: Finally, once a request is authorized, it passes through admission controllers.
    They intercept requests to the API before the objects are persisted and can modify
    them. They are advanced topics that we won't cover in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦请求被授权，它将经过准入控制器。准入控制器在对象被持久化之前拦截请求，并可以对其进行修改。它们是高级主题，本文不会涵盖这些内容。
- en: Authentication is pretty standard, and there's not much to say about it. On
    the other hand, admission controllers are too advanced to be covered just yet.
    Therefore, we're left with authorization as the topic we'll explore in more detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证过程相当标准，没有太多要说的。另一方面，准入控制器是非常复杂的内容，不适合在此详细讨论。因此，我们将重点研究授权这一主题。
- en: Authorizing requests
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权请求
- en: Just like almost everything else in Kubernetes, authorization is modular. We
    can choose to use *Node*, *ABAC*, *Webhook*, or *RBAC* authorization. Node authorization
    is used for particular purposes. It grants permissions to kubelets based on the
    Pods they are scheduled to run. **Attribute-based access control** (**ABAC**)
    is based on attributes combined with policies and is considered deprecated in
    favor of RBAC. Webhooks are used for event notifications through HTTP POST requests.
    Finally, **Role-based access control** (**RBAC**) grants (or denies) access to
    resources based on roles of individual users or groups.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Kubernetes 中的几乎所有其他功能一样，授权是模块化的。我们可以选择使用 *Node*、*ABAC*、*Webhook* 或 *RBAC*
    授权。Node 授权用于特定目的。它根据 kubelet 被调度运行的 Pods 授予权限。**基于属性的访问控制**（**ABAC**）基于属性和策略的组合，并且由于
    RBAC 的引入，它被认为已经过时。Webhook 用于通过 HTTP POST 请求进行事件通知。最后，**基于角色的访问控制**（**RBAC**）根据单个用户或组的角色授予（或拒绝）对资源的访问权限。
- en: Among the four authorization methods, RBAC is the right choice for user-based
    authorization. Since we'll focus this chapter on the exploration of the means
    to authorize humans, RBAC will be our primary focus.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在四种授权方法中，RBAC 是基于用户授权的正确选择。由于本章将重点探讨授权人类的方式，RBAC 将是我们的主要关注点。
- en: What can we do with RBAC? To begin with, we can use it to secure the cluster
    by allowing access only to authorized users. We can define roles that would grant
    different levels of access to users and groups. Some could have god-like permissions
    that would allow them to do almost anything, while others could be limited only
    to basic non-destructive operations. There can be many other roles in between.
    We can combine RBAC with Namespaces and allow users to operate only within specific
    segments of a cluster. There are many other combinations we could apply depending
    on particular use-cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 RBAC 做什么？首先，我们可以通过仅允许授权用户访问来确保集群的安全。我们可以定义不同的角色，为用户和组授予不同级别的访问权限。有些角色可能拥有类似上帝的权限，几乎可以做任何事，而其他角色则可能仅限于基本的非破坏性操作。介于两者之间可能还有许多其他角色。我们可以将
    RBAC 与命名空间结合使用，只允许用户在集群的特定部分进行操作。根据具体的使用案例，我们还可以应用许多其他组合。
- en: Since I get uncomfortable with too much theory, we'll leave the rest for later
    and explore details through a few examples. As you might already suspect, we'll
    kick it off with a new Minikube cluster.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我对过多的理论感到不舒服，我们将把其余的内容留到以后，通过一些示例来探索细节。正如你可能已经猜到的，我们将从一个新的 Minikube 集群开始。
- en: Creating a Cluster
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建集群
- en: 'The commands that will create a Minikube cluster are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Minikube 集群的命令如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: RBAC is installed by default starting from minikube v0.26\. If your version
    is older than that, you'll need to add `--extra-config apiserver.Authorization.Mode=RBAC`
    argument. Or, better yet, upgrade your minikube binary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从 minikube v0.26 开始，RBAC 默认已安装。如果你的版本较旧，则需要添加 `--extra-config apiserver.Authorization.Mode=RBAC`
    参数。或者，更好的是，升级你的 minikube 二进制文件。
- en: It might come in handy to have a few objects in the cluster so we'll deploy
    the `go-demo-2` application. We'll use it to test different permutations of the
    authorization strategies we'll use soon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中拥有一些对象可能会派上用场，因此我们将部署 `go-demo-2` 应用程序。我们将使用它来测试我们很快将使用的不同授权策略的各种组合。
- en: 'The definition of the `go-demo-2` application is the same as the one we created
    in the previous chapters so we''ll skip the explanation and just execute `kubectl
    create`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-demo-2` 应用程序的定义与我们在前几章中创建的相同，因此我们将跳过解释，直接执行 `kubectl create`：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating users
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: The word about Kubernetes awesomeness is spreading in your company. People are
    becoming curious and would like to try it out. Since you are the Kubernetes guru,
    it came as no surprise that you received a call from John Doe. He wants to "play"
    with Kubernetes, but he does not have time to set up his own cluster. Since he
    knows that you already have a cluster up and running, he'd appreciate if you would
    let him use yours.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的强大功能在你的公司中传播开来了。人们变得好奇，并希望尝试一下。作为 Kubernetes 专家，你接到 John Doe 的电话也就不足为奇了。他想“玩”
    Kubernetes，但他没有时间自己搭建集群。由于他知道你已经搭建好了集群，他希望你能让他使用你的集群。
- en: Since you have no intention giving John your certificates, you decide to let
    him authenticate with his user.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不打算将证书给 John，因此决定让他使用自己的用户进行身份验证。
- en: You will have to create certificates for him, so the first step you'll need
    to do is to verify that OpenSSL is installed on your laptop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为他创建证书，因此第一步是验证你的笔记本是否已安装 OpenSSL。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It shouldn''t matter which version of OpenSSL is installed. We output the `version`
    only to verify that the software is working. If the output is something like `command
    not found: openssl`, you will have to install the binaries ([https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '安装的 OpenSSL 版本不应该有问题。我们输出`version`只是为了验证软件是否正常工作。如果输出类似于`command not found:
    openssl`，则需要安装二进制文件（[https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)）。'
- en: The first thing we'll do is to create a private key for John. We'll assume that
    John Doe's username is `jdoe`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是为 John 创建一个私钥。我们假设 John Doe 的用户名是 `jdoe`。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We created the directory `keys` and generated a private key `jdoe.key`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 `keys` 目录，并生成了一个私钥 `jdoe.key`。
- en: 'Next, we''ll use the private key to generate a certificate:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用私钥生成证书：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A note to Windows users
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给 Windows 用户的提示
- en: If you received an error like `Subject does not start with '/'. Problems making
    Certificate Request`, please replace `-subj "/CN=jdoe/O=devs"` with `-subj "//CN=jdoe\O=devs"`
    in the previous command and execute it again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到类似于`Subject does not start with '/'。制作证书请求时出现问题`的错误，请将前一个命令中的`-subj "/CN=jdoe/O=devs"`替换为`-subj
    "//CN=jdoe\O=devs"`，然后重新执行该命令。
- en: We created the certificate `jdoe.csr` with a specific subject that will help
    us identify John. `CN` is the username and `O` represents the organization he
    belongs. John is a developer, so `devs` should do.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了证书 `jdoe.csr`，其中包含一个特定的主题，这有助于我们识别约翰。`CN` 是用户名，`O` 表示他所属的组织。约翰是开发者，因此 `devs`
    应该是合适的。
- en: For the final certificate, we'll need the cluster's **certificate authority**
    (**CA**). It will be responsible for approving the request and for generating
    the necessary certificate John will use to access the cluster. Since we used Minikube,
    the authority is already produced for us as part of the cluster creation. It should
    be in the `.minikube` directory inside the OS user's home folder. Let's confirm
    it's there.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终的证书，我们需要集群的**证书颁发机构**（**CA**）。它将负责批准请求并生成约翰用于访问集群的必要证书。由于我们使用了 Minikube，证书颁发机构在集群创建时已经为我们生成。它应该位于操作系统用户的主文件夹中的
    `.minikube` 目录下。让我们确认一下它是否在那里。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Minikube's directory might be somewhere else. If that's the case, please replace
    `~/.minikube` with the correct path.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 的目录可能在其他地方。如果是这种情况，请将 `~/.minikube` 替换为正确的路径。
- en: 'The output is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we can generate the final certificate by approving the certificate sign
    request `jdoe.csr`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过批准证书签名请求 `jdoe.csr` 来生成最终的证书。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we feel generous, we made the certificate `jdoe.crt` valid for a whole
    year (365 days).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们心胸宽广，我们让证书 `jdoe.crt` 的有效期为一年（365天）。
- en: To simplify the process, we'll copy the cluster's certificate authority to the
    `keys` directory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化过程，我们将集群的证书颁发机构复制到 `keys` 目录中。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s check what we generated:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们生成的内容：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: John does not need the `jdoe.csr` file. We used it only to generate the final
    certificate `jdoe.crt`. He will need all the others though.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰不需要 `jdoe.csr` 文件。我们只用了它来生成最终证书 `jdoe.crt`。不过，他确实需要其他所有的文件。
- en: Apart from the keys, John will need to know the address of the cluster. At the
    beginning of the chapter, we already created the `jsonpath` that retrieves the
    server so that part should be easy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了密钥之外，约翰还需要知道集群的地址。在本章的开始，我们已经创建了 `jsonpath`，它可以检索服务器地址，所以这部分应该很简单。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Equipped with the new certificate, the key, the cluster authority, and the address
    of the server, John can configure his `kubectl` installation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了新的证书、密钥、集群证书颁发机构和服务器地址，约翰可以配置他的 `kubectl` 安装。
- en: Since John is not around, we'll do some role playing and impersonate him.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于约翰不在场，我们将进行角色扮演，代替他执行操作。
- en: John will first have to set the cluster using the address and the certificate
    authority we sent him.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰首先需要使用我们发送给他的地址和证书颁发机构来设置集群。
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We created a new cluster called `jdoe`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `jdoe` 的新集群。
- en: Next, he'll have to set the credentials using the certificate and the key we
    created for him.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，他将需要使用我们为他创建的证书和密钥来设置凭证。
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created a new set of credentials called `jdoe`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一组名为 `jdoe` 的新凭证。
- en: 'Finally, John will have to create a new context:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，约翰需要创建一个新的上下文：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We created the context `jdoe` that uses the newly created cluster and the user.
    We also made sure that we're using the newly created context.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了使用新创建的集群和用户的 `jdoe` 上下文，并确保我们正在使用这个新创建的上下文。
- en: 'Let''s take a look at the config:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下配置：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output, limited to John''s settings, is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 限制在约翰设置中的输出结果如下：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: John should be happy thinking that he can access our cluster. Since he's a curious
    person, he'll want to see the Pods we're running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰应该会很高兴地认为他可以访问我们的集群。因为他是一个好奇的人，他肯定会想看看我们正在运行的 Pods。
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That's frustrating. John can reach our cluster, but he cannot retrieve the list
    of Pods. Since hope dies last, John might check whether he is forbidden from seeing
    other types of objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这真让人沮丧。约翰可以访问我们的集群，但他无法获取 Pods 的列表。由于希望永不熄灭，约翰可能会检查是否被禁止查看其他类型的对象。
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is a long list of all the objects he's forbidden from seeing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个长长的列表，列出了他被禁止查看的所有对象。
- en: John picks up his phone to beg not only that you give him the access to the
    cluster, but also the permissions to "play" with it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰拿起手机，不仅请求你给予他访问集群的权限，还请求他有权限“玩”集群。
- en: Before we change John's permission, we should explore the components involved
    in the RBAC authorization process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改约翰的权限之前，我们应该先了解一下参与 RBAC 授权过程的组件。
- en: Exploring RBAC authorization
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 RBAC 授权
- en: Managing Kubernetes RBAC requires knowledge of a few elements. Specifically,
    we should learn about Rules, Roles, Subjects, and RoleBindings.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 Kubernetes RBAC 需要了解一些元素。具体来说，我们需要了解规则（Rules）、角色（Roles）、主体（Subjects）和 RoleBindings。
- en: A *Rule* is a set of operations (verbs), resources, and API groups. Verbs describe
    activities that can be performed on resources which belong to different API Groups.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rule* 是一组操作（动词）、资源和 API 组。动词描述了可以在属于不同 API 组的资源上执行的活动。'
- en: Permissions defined through Rules are additive. We cannot deny access to some
    resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过规则定义的权限是累加的。我们无法拒绝对某些资源的访问。
- en: 'Currently supported verbs are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持的动词如下：
- en: '| **Verb** | **Description** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **动词** | **描述** |'
- en: '| get | Retrieves information about a specific object |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| get | 检索特定对象的信息 |'
- en: '| list | Retrieves information about a collection of objects |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| list | 检索一组对象的信息 |'
- en: '| create | Creates a specific object |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| create | 创建特定对象 |'
- en: '| update | Updates a specific object |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| update | 更新特定对象 |'
- en: '| patch | Patches a specific object |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| patch | 补丁特定对象 |'
- en: '| watch | Watches for changes to an object |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| watch | 监听对象的变化 |'
- en: '| proxy | Proxies requests |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| proxy | 代理请求 |'
- en: '| redirect | Redirects requests |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| redirect | 重定向请求 |'
- en: '| delete | Deletes a specific object |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| delete | 删除特定对象 |'
- en: '| deletecollection | Deletes a collection of objects |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| deletecollection | 删除一组对象 |'
- en: If, for example, we'd like to allow a user only to create objects and retrieve
    their information, we'd use the verbs `get`, `list` and `create`. A verb can be
    an asterisk (`*`), thus allowing all verbs (operations).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们只希望允许用户创建对象并获取其信息，我们将使用动词 `get`、`list` 和 `create`。动词可以是星号（`*`），从而允许所有动词（操作）。
- en: Verbs are combined with Kubernetes resources. For example, if we'd like to allow
    a user only to create Pods and retrieve their information, we'd mix `get`, `list`
    and `create` verbs with the `pods` resource.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 动词与 Kubernetes 资源结合使用。例如，如果我们只希望允许用户创建 Pods 并获取其信息，我们将 `get`、`list` 和 `create`
    动词与 `pods` 资源结合使用。
- en: The last element of a Rule is the API Group. RBAC uses the `rbac.authorization.k8s.io`
    group. If we'd switch to a different authorization method, we'd need to change
    the group as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的最后一个元素是 API 组。RBAC 使用 `rbac.authorization.k8s.io` 组。如果我们切换到其他授权方法，我们还需要更改该组。
- en: A *Role* is a collection of Rules. It defines one or more Rules that can be
    bound to a user or a group of users. The vital aspect of Roles is that they are
    applied to a Namespace. If we'd like to create a role that refers to a whole cluster,
    we'd use *ClusterRole* instead. Both are defined in the same way, and the only
    difference is in the scope (Namespace or an entire cluster).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Role* 是一组规则（Rules）。它定义一个或多个可以绑定到用户或用户组的规则。角色的关键在于它们是应用于某个 Namespace 的。如果我们希望创建一个指向整个集群的角色，我们将使用
    *ClusterRole*。两者的定义方式相同，唯一的区别在于作用范围（Namespace 或整个集群）。'
- en: The next piece of the authorization mechanism is *Subjects*. They define entities
    that are executing operations. A Subject can be a *User*, a *Group*, or a *Service
    Account*. A User is a person or a process residing outside a cluster. A Service
    Account is used for processes running inside Pods that want to use the API. Since
    this chapter focuses on human authentication, we won't explore them right now.
    Finally, Groups are collections of Users or Service Accounts. Some Groups are
    created by default (for example, `cluster-admin`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 授权机制的下一个元素是 *Subjects*。它们定义了执行操作的实体。Subject 可以是 *用户*（User）、*组*（Group）或 *服务帐户*（Service
    Account）。用户是一个或一个位于集群外的进程。服务帐户用于在 Pods 内部运行的进程，且这些进程想要使用 API。由于本章关注人类身份验证，因此我们现在不讨论它们。最后，组是用户或服务帐户的集合。某些组是默认创建的（例如，`cluster-admin`）。
- en: Finally, we need *RoleBindings*. As the name suggests, they bind Subjects to
    Roles. Since Subjects define users, RoleBindings effectively bind users (or Groups
    or Service Accounts) to Roles, thus giving them permissions to perform certain
    operations on specific objects within a Namespace. Just like roles, RoleBindings
    have a cluster-wide alternative called *ClusterRoleBindings*. The only difference
    is that their scope is not limited to a Namespace, but applied to a whole cluster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要 *RoleBindings*。顾名思义，它们将 Subjects 绑定到 Roles。由于 Subjects 定义了用户，RoleBindings
    实际上是将用户（或组或服务帐户）绑定到 Roles，从而授予他们在特定 Namespace 内执行某些操作的权限。与角色一样，RoleBindings 有一个集群范围的替代方案，叫做
    *ClusterRoleBindings*。唯一的区别是它们的作用范围不限于某个 Namespace，而是应用于整个集群。
- en: All that might seem confusing and overwhelming. You might even say that you
    did not understand anything. Fear not. We'll explore each of the RBAC components
    in more details through practical examples. We went through the explanation because
    people say that things should be explained first, and demonstrated later. I don't
    think that's a right approach, but I didn't want you to say that I did not provide
    the theory. In any case, the examples that follow will clarify everything.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能看起来令人困惑和压倒性。你甚至可能会说你什么都没理解。别担心。我们将通过实际示例更详细地探讨每个RBAC组件。我们先进行了说明，因为人们说应该先解释理论，后演示。我认为这不是正确的方法，但我不希望你说我没有提供理论。不管怎样，接下来的示例会澄清一切。
- en: Let's go back to John's issue and try to solve it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到John的问题，并尝试解决它。
- en: Peeking into pre-defined Cluster roles
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看预定义的集群角色
- en: John is frustrated. He can access the cluster, but he is not permitted to perform
    any operation. He cannot even list the Pods. Naturally, he asked us to be more
    generous and allow him to "play" with our cluster.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: John感到沮丧。他可以访问集群，但不被允许执行任何操作。他甚至不能列出Pods。自然，他请求我们更加宽容，允许他在我们的集群中“玩”。
- en: Since we are not taking anything for granted, we decided that the first action
    should be to verify John's claim. Is it true that he cannot even retrieve the
    Pods running inside the cluster?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不做任何假设，我们决定第一步应该是验证John的说法。是不是他连获取集群中的Pods都做不到？
- en: Before we move further, we'll stop impersonating John and go back to using the
    cluster with god-like administrative privileges granted to the `minikube` user.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将停止模拟John的身份，回到使用`minikube`用户授予的类似神的管理员权限来使用集群。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we switched to the `minikube` context (and the `minikube` user), we
    regained full permissions, and `kubectl get all` returned all the objects from
    the `default` Namespace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们切换到`minikube`上下文（以及`minikube`用户），我们重新获得了完全的权限，`kubectl get all`返回了`default`命名空间中的所有对象。
- en: Let's verify that John indeed cannot list Pods in the `default` Namespace.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下John确实不能在`default`命名空间中列出Pods。
- en: We could configure the same certificates as those he's using, but that would
    complicate the process. Instead, we'll use a `kubectl` command that will allow
    us to check whether we could perform an action if we would be a specific user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置与他使用相同的证书，但那会使过程更加复杂。相反，我们将使用一个`kubectl`命令，允许我们检查如果我们是特定用户，是否能执行某个操作。
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The response is `no`, indicating that `jdoe` cannot `get pods`. The `--as` argument
    is a global option that can be applied to any command. The `kubectl auth can-i`
    is a "special" command. It does not perform any action but only validates whether
    an operation could be performed. Without the `--as` argument, it would verify
    whether the current user (in this case `minikube`) could do something.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是`no`，表明`jdoe`不能`get pods`。`--as`参数是一个全局选项，可以应用于任何命令。`kubectl auth can-i`是一个“特殊”命令。它不会执行任何操作，而只是验证是否可以执行某个操作。如果没有`--as`参数，它将验证当前用户（在此情况下为`minikube`）是否可以执行某个操作。
- en: We already discussed Roles and ClusterRoles briefly. Let's see whether there
    are any already configured in the cluster or the `default` namespace.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要讨论了角色（Roles）和集群角色（ClusterRoles）。让我们看看集群中或`default`命名空间中是否已配置这些角色。
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output reveals that `no resources` were `found`. We do not have any Roles
    in the `default` Namespace. That was the expected outcome since a Kubernetes cluster
    comes with no pre-defined Roles. We'd need to create those we need ourselves.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示`no resources`被`found`。在`default`命名空间中没有任何角色。这个结果是预期的，因为Kubernetes集群没有预定义的角色。我们需要自己创建需要的角色。
- en: How about Cluster Roles? Let's check them out.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那么集群角色怎么样呢？让我们检查一下。
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time we got quite a few resources. Our cluster already has some Cluster
    Roles defined by default. Those prefixed with `system:` are Cluster Roles reserved
    for Kubernetes system use. Modifications to those roles can result in non-functional
    clusters, so we should not update them. Instead, we'll skip system Roles and focus
    on those that should be assigned to users.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们获得了相当多的资源。我们的集群已经默认定义了一些集群角色。那些以`system:`开头的角色是为Kubernetes系统保留的集群角色。修改这些角色可能导致集群无法正常工作，因此我们不应更新它们。相反，我们将跳过系统角色，专注于应该分配给用户的角色。
- en: 'The output, limited to Cluster Roles that are meant to be bound to users, is
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果仅限于那些应分配给用户的集群角色，具体如下：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Cluster Role with the least permissions is `view`. Let''s take a closer
    look at it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 权限最少的集群角色是`view`。我们来仔细看看它：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output, limited to the first few rows, is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 限制输出为前几行，如下所示：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It contains a long list of resources, all of them with the `get`, `list`, and
    `watch` verbs. It looks like it would allow users bound to it to retrieve all
    the resources. We have yet to validate whether the list of resources is truly
    complete. For now, it looks like an excellent candidate to assign to users that
    should have very limited permissions. Unlike Roles that are tied to a specific
    Namespace, Cluster Roles are available across the whole cluster. That is a significant
    difference that we'll exploit later on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个长长的资源列表，所有资源都具有`get`、`list`和`watch`操作权限。看起来，它会允许绑定该角色的用户检索所有资源。我们尚未验证这些资源列表是否真的完整。现在来看，它似乎是一个非常适合分配给那些应拥有非常有限权限的用户的角色。与绑定到特定命名空间的角色不同，集群角色可在整个集群中使用。这是一个显著的区别，我们稍后会利用这一点。
- en: Let's explore another pre-defined Cluster Role.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索另一个预定义的集群角色。
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output, limited to Pods, is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 限制输出为Pods，如下所示：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see, the `edit` Cluster Role allows us to perform any action on Pods.
    If we go through the whole list, we'd see that the `edit` role allows us to execute
    almost any operation on any Kubernetes object. It seems like it gives us unlimited
    permissions. However, there are a few resources that are not listed. We can observe
    those differences through the Cluster Role `admin`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`edit`集群角色允许我们对Pods执行任何操作。如果我们浏览整个列表，会看到`edit`角色允许我们对任何Kubernetes对象执行几乎所有操作。它看起来赋予了我们无限的权限。然而，仍有一些资源未列出。我们可以通过集群角色`admin`来观察这些差异。
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you pay close attention, you'll notice that the Cluster Role `admin` has
    a few additional entries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会注意到集群角色`admin`有一些额外的条目。
- en: 'The output, limited to the records not present in the Cluster Role `edit`,
    is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 限制输出为不包含在集群角色`edit`中的记录，如下所示：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The main difference between `edit` and `admin` is that the latter allows us
    to manipulate Roles and RoleBindings. While `edit` permits us to do almost any
    operation related to Kubernetes objects like Pods and Deployments, `admin` goes
    a bit further and provides an additional capability that allows us to define permissions
    for other users by modifying existing or creating new Roles and Role Bindings.
    The major restriction of the `admin` role is that it cannot alter the Namespace
    itself, nor it can update Resource Quotas (we haven't explored them yet).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit`和`admin`的主要区别在于，后者允许我们操作角色和角色绑定。而`edit`允许我们执行与Kubernetes对象如Pods和Deployments相关的几乎所有操作，`admin`则更进一步，提供了一个额外的功能，允许我们通过修改现有角色或创建新的角色和角色绑定来定义其他用户的权限。`admin`角色的主要限制是，它无法更改命名空间本身，也无法更新资源配额（我们尚未探索这些配额）。'
- en: There is only one more pre-defined non-system Cluster Role left.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个预定义的非系统集群角色。
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The Cluster Role `cluster-admin` holds nothing back. An asterisk (`*`) means
    everything. It provides god-like powers. A user bound to this role can do anything,
    without any restrictions. The `cluster-admin` role is the one bound to the `minikube`
    user. We can confirm that easily by executing:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色`cluster-admin`毫无保留地提供权限。星号（`*`）意味着所有内容。它赋予了类似上帝般的权限。绑定该角色的用户可以执行任何操作，没有任何限制。`cluster-admin`角色是绑定到`minikube`用户的。我们可以通过执行以下命令轻松确认这一点：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The output is `yes`. Even though we did not really confirm that the `cluster-admin`
    role is bound to `minikube`, we did verify that it can do anything.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为`yes`。尽管我们并未真正确认`cluster-admin`角色已绑定到`minikube`，但我们确实验证了它可以执行任何操作。
- en: Creating Role bindings and Cluster Role bindings
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建角色绑定和集群角色绑定
- en: 'Role Bindings bind a User (or a Group, or a Service Account) to a Role (or
    a Cluster Role). Since John wants more visibility to our cluster, we''ll create
    a Role Binding that will allow him to view (almost) all the objects in the `default`
    namespace. That should be a good start of our quest to give John just the right
    amount of privileges:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 角色绑定将用户（或组，或服务账户）绑定到角色（或集群角色）。由于John希望能更多地了解我们的集群，我们将创建一个角色绑定，允许他查看`default`命名空间中（几乎）所有的对象。这应该是我们赋予John适当权限之旅的良好开始：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We created a Role Binding called `jdoe`. Since the Cluster Role `view` already
    provides, more or less, what we need, we used it instead of creating a whole new
    Role.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`jdoe`的角色绑定。由于集群角色`view`已经提供了我们大致需要的权限，我们直接使用它，而不是创建一个全新的角色。
- en: The output of the latter command proved that the new Role Binding `jdoe` was
    indeed created.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 后者命令的输出证明新创建的角色绑定`jdoe`确实已创建。
- en: This is a good moment to clarify that a Role Binding does not need to be used
    only with a Role, but that it can also be combined with a Cluster Role (as in
    our example). As the rule of thumb, we define Cluster Roles when we think that
    they might be used cluster-wide (with Cluster Role Bindings) or in multiple Namespaces
    (with Role Bindings). The scope of the permissions is defined with the type of
    binding, not with the type of role. Since we used Role Binding, the scope is limited
    to a single Namespace which, in our case, is the `default`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的时机来澄清一下，Role Binding 并不一定只能与 Role 配合使用，它也可以与 Cluster Role 结合使用（如我们的示例所示）。作为一个经验法则，当我们认为某个角色可能会在集群范围内使用（配合
    Cluster Role Bindings）或在多个命名空间中使用（配合 Role Bindings）时，我们会定义 Cluster Roles。权限的作用范围是通过绑定类型来定义的，而不是通过角色类型来定义的。由于我们使用的是
    Role Binding，作用范围仅限于单个命名空间，在我们的例子中是 `default`。
- en: 'Let''s take a look at the details of the newly created Role Binding:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看新创建的 Role Binding 的详细信息：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can see that the Role Binding `jdoe` has a single subject with the User
    `jdoe`. It might be a bit confusing that the Namespace is empty and you might
    think that the Role Binding applies to all Namespaces. Such an assumption would
    be false. Remember, a Role Binding is always tied to a specific Namespace, and
    we just described the one created in the `default` Namespace. The same Role Binding
    should not be available anywhere else. Let''s confirm that:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Role Binding `jdoe` 只有一个主体，即用户 `jdoe`。命名空间为空可能有点令人困惑，您可能会认为这个 Role Binding
    适用于所有命名空间。但这种假设是错误的。请记住，Role Binding 始终与特定命名空间相关联，我们刚刚描述的是在 `default` 命名空间中创建的
    Role Binding。相同的 Role Binding 不应该在其他地方可用。让我们确认这一点：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We described the Role Binding `jdoe` in the Namespace `kube-system`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了命名空间 `kube-system` 中的 Role Binding `jdoe`。
- en: 'The output is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Namespace `kube-system` does not have that Role Binding. We never created
    it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间 `kube-system` 没有该 Role Binding。我们从未创建过它。
- en: 'It might be easier to verify that our permissions are set correctly through
    the `kubectl auth can-i` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `kubectl auth can-i` 命令验证我们的权限是否设置正确可能会更容易：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first command validated whether the user `jdoe` can `get pods` from the
    `default` Namespace. The answer was `yes`. The second checked whether the Pods
    could be retrieved from all the Namespaces and the answer was `no`. Currently,
    John can only see the Pods from the `default` Namespace, and he is forbidden from
    exploring those from the other Namespaces.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令验证了用户 `jdoe` 是否可以从 `default` 命名空间中 `获取 Pods`。答案是 `yes`。第二个命令检查了 Pods 是否可以从所有命名空间中检索，答案是
    `no`。目前，John 只能看到 `default` 命名空间中的 Pods，且无法查看其他命名空间中的 Pods。
- en: 'From now on, John should be able to view the Pods in the `default` Namespace.
    However, he works in the same company as we do and we should have more trust in
    him. Why don''t we give him permissions to view Pods in any Namespace? Why not
    apply the same permissions cluster-wide? Before we do that, we''ll delete the
    Role Binding we created and start over:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，John 应该能够查看 `default` 命名空间中的 Pods。然而，既然他和我们在同一家公司工作，我们应该对他有更多的信任。为什么不赋予他查看任何命名空间
    Pods 的权限呢？为什么不将相同的权限应用于整个集群？在我们这么做之前，我们将删除之前创建的 Role Binding 并重新开始：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We'll change John's `view` permissions so that they are applied across the whole
    cluster. Instead of executing yet another ad-hoc kubectl commands, we'll define
    `ClusterRoleBinding` resource in YAML format so that the change is documented.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 John 的 `view` 权限，使其能够跨整个集群应用。我们不再执行其他临时的 kubectl 命令，而是以 YAML 格式定义 `ClusterRoleBinding`
    资源，以便更好地记录这个变更。
- en: Let's take a look at the definition in the `auth/crb-view.yml` file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看 `auth/crb-view.yml` 文件中的定义。
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Functionally, the difference is that, this time, we're creating `ClusterRoleBinding`
    instead of `RoleBinding`. Also, we specified the `apiGroup` explicitly thus making
    it clear that the `ClusterRole` is RBAC.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 功能上，区别在于这次我们创建的是 `ClusterRoleBinding`，而不是 `RoleBinding`。此外，我们显式地指定了 `apiGroup`，这样可以明确指出
    `ClusterRole` 是 RBAC 类型。
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We created the role defined in the YAML file, and the output confirmed that
    `clusterrolebinding "view"` was `created`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 YAML 文件中定义的角色，输出确认了 `clusterrolebinding "view"` 已被 `created`。
- en: We can further validate that everything looks correct by describing the newly
    created role.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过描述新创建的角色来进一步验证一切是否正常。
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we''ll impersonate John and validate that he can indeed retrieve the
    Pods from any Namespace:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将模拟 John 并验证他是否能够从任何命名空间中获取 Pods：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The output is `yes`, thus confirming that `jdoe` can view the Pods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`yes`，因此确认`jdoe`可以查看Pods。
- en: We're so excited that we cannot wait to let John know that he was granted permissions.
    However, a minute into the phone call, he raises a concern. While being able to
    view Pods across the cluster is a good start, he will need a place where he and
    other developers will have more freedom. They will need to be able to deploy,
    update, delete, and access their applications. They will probably need to do more,
    but they can't give you more information. They are not yet very experienced with
    Kubernetes, so they don't know what to expect. He's asking you to find a solution
    that will allow them to perform actions that will help them develop and test their
    software without affecting other users of the cluster.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常激动，迫不及待地想告诉John，他已经被授予了权限。然而，通话开始一分钟后，他提出了一个问题。虽然能够查看跨集群的Pods是一个好的开始，但他需要一个地方，让他和其他开发人员能拥有更多的自由。他们需要能够部署、更新、删除并访问他们的应用程序。他们可能需要做更多的事情，但他们无法提供更多的信息。他们对Kubernetes还不太熟悉，因此不知道该期待什么。他请求你找到一个解决方案，让他们能够执行帮助他们开发和测试软件的操作，而不会影响集群中的其他用户。
- en: The new request provides an excellent opportunity to combine Namespaces with
    Role Bindings. We can create a `dev` Namespace and allow a selected group of users
    to do almost anything in it. That should give developers enough freedom within
    the `dev` Namespace while avoiding the risks of negatively impacting the resources
    running in others.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新请求为结合命名空间与角色绑定提供了一个很好的机会。我们可以创建一个`dev`命名空间，并允许一组选定的用户在其中几乎做任何事情。这应该能够在`dev`命名空间内为开发人员提供足够的自由，同时避免影响其他命名空间中资源的风险。
- en: 'Let''s take a look at the `auth/rb-dev.yml` definition:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`auth/rb-dev.yml`的定义：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first section defines the `dev` Namespace, while the second specifies the
    binding with the same name. Since we're using `RoleBinding` (not `ClusterRoleBinding`),
    the effects will be limited to the `dev` Namespace. At the moment, there is only
    one subject (the User `jdoe`). We can expect the list to grow with time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分定义了`dev`命名空间，而第二部分指定了同名的绑定。由于我们使用的是`RoleBinding`（而非`ClusterRoleBinding`），因此影响将仅限于`dev`命名空间。目前，只有一个主体（用户`jdoe`）。我们可以预计，随着时间推移，列表会增长。
- en: Finally, `roleRef` uses `ClusterRole` (not `Role`) `kind`. Even though the Cluster
    Role is available across the whole cluster, the fact that we are combining it
    with `RoleBinding` will limit it to the specified Namespace.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`roleRef`使用的是`ClusterRole`（而不是`Role`）类型。尽管集群角色在整个集群中可用，但由于我们将其与`RoleBinding`结合使用，这将使其仅限于指定的命名空间。
- en: The Cluster Role `admin` has an extensive set of resources and verbs, and the
    Users (at the moment only `jdoe`) will be able to do almost anything within the
    `dev` Namespace.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin`集群角色有一整套广泛的资源和操作，用户（目前只有`jdoe`）将能够在`dev`命名空间内几乎执行任何操作。'
- en: 'Let''s create the new resources:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建新资源：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can see that the Namespace and the Role Binding were created.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到命名空间和角色绑定已经创建。
- en: 'Let''s verify that, for example, `jdoe` can create and delete Deployments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下，例如，`jdoe`是否可以创建和删除Deployments：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In both cases, the output was `yes`, confirming that `jdoe` can perform at least
    `create` and `delete` actions with Deployments. Since we already explored the
    list of resources defined in the Cluster Role `admin`, we can assume that we'd
    get the same response if we'd check other operations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，输出都是`yes`，确认`jdoe`至少可以执行`create`和`delete`操作。由于我们已经查看了`admin`集群角色中定义的资源列表，我们可以假设，如果我们检查其他操作，也会得到相同的响应。
- en: 'Still, there are a few permissions that are not granted to John. Only the `cluster-admin`
    role covers all the permissions. The Cluster Role `admin` is very wide, but it
    does not include all the resources and verbs. We can confirm that with the command
    that follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，John仍然没有获得一些权限。只有`cluster-admin`角色涵盖了所有权限。`admin`集群角色非常广泛，但它并不包含所有资源和操作。我们可以通过以下命令确认这一点：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The output is `no`, indicating that there are still a few operations forbidden
    to John within the `dev` Namespace. Those operations are mostly related to cluster
    administration that is still in our control.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`no`，表示在`dev`命名空间内，John仍然有一些操作是被禁止的。这些操作主要与集群管理相关，仍然在我们的控制之中。
- en: John is happy. He and his fellow developers have a segment of the cluster where
    they can do almost anything without affecting other Namespaces.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: John 很高兴。他和他的开发同事们有一个集群区域，他们可以在其中几乎做任何事情，而不会影响其他命名空间。
- en: John is a team player, but he'd also like to have space for himself. Now that
    he knows how easy it was to create a Namespace for developers, he's wondering
    whether we could generate one only for him. You are starting to feel like he's
    an ungrateful guy that will always be asking for more, but you cannot deny the
    fact that his new request makes sense. It should be easy to create his personal
    Namespace, so why not grant him that wish.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: John 是一个团队合作者，但他也希望有自己的空间。现在他知道为开发者创建命名空间有多简单，他在想是否可以为他自己生成一个命名空间。你开始觉得他是一个不知足的人，总是要求更多，但你不能否认他的新请求是有道理的。创建他的个人命名空间应该很简单，那为什么不满足他的愿望呢？
- en: 'Let''s take a look at yet another YAML definition:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下另一个 YAML 定义：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This definition is not much different from the previous one. The important change
    is that the Namespace is `jdoe`, and that John is likely to be its only user,
    at least until he decides to add someone else. By referencing the role `cluster-admin`,
    he's given full permissions to do whatever he wants within that Namespace. He
    might deploy something cool and give others permissions to see it. Everyone likes
    to show off every once in a while. In any case, that would be his decision. It's
    his Namespace, and he should be able to do anything he likes inside it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与之前的差别不大。重要的变化是命名空间是`jdoe`，而且 John 可能是唯一的用户，至少在他决定添加其他人之前。通过引用 `cluster-admin`
    角色，他被赋予了在该命名空间内做任何事情的完全权限。他可能会部署一些酷东西，并授权其他人查看。每个人偶尔都会想炫耀一下。无论如何，那将是他的决定。毕竟，这是他的命名空间，他应该可以在其中做任何他喜欢的事。
- en: 'Let''s create the new resources:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建新的资源：
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Before we move on, we'll confirm that John can indeed do anything he likes in
    the `jdoe` Namespace.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将确认 John 是否真的可以在 `jdoe` 命名空间中做任何他喜欢的事情。
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As expected, the response is `yes`, indicating that John is a god-like figure
    in his own little galaxy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，回应是`yes`，这意味着 John 在他自己小小的星系中是一个神一般的人物。
- en: John loves the idea of having his own Namespace. He'll use it as his playground.
    However, there's one more thing he's missing. He happens to be a release manager.
    Unlike his other fellow developers, he's in charge of deploying new releases to
    production. He's planning to automate that process with Jenkins. However, that
    will require a bit of time, and until then he should be allowed to perform deployments
    manually. We already decided that production releases should be deployed to the
    `default` Namespace, so he'll need additional permissions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: John 喜欢拥有自己命名空间的想法。他将其作为自己的游乐场。然而，他还有一件事没有满足。他恰好是一个发布经理。与其他开发者不同，他负责将新版本部署到生产环境。他计划通过
    Jenkins 来自动化这个过程。然而，这需要一些时间，直到那时，他应该被允许手动执行部署。我们已经决定生产版本应部署到 `default` 命名空间，因此他将需要额外的权限。
- en: After a short discussion, we decided that the minimum permissions required for
    the release manager is to perform actions on Pods, Deployments, and ReplicaSets.
    People with that role should be able to do almost anything related to Pods, while
    the allowed actions for the Deployments and ReplicaSets should be restricted to
    `create`, `get`, `list`, `update`, and `watch`. We don't think that they should
    be able to delete them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 经过短暂的讨论，我们决定发布经理所需的最小权限是对 Pods、Deployments 和 ReplicaSets 执行操作。拥有该角色的人应该能够做几乎所有与
    Pods 相关的事情，而对 Deployments 和 ReplicaSets 的允许操作应仅限于 `create`、`get`、`list`、`update`
    和 `watch`。我们认为他们不应该能删除它们。
- en: We're not entirely confident that those are all the permissions release managers
    will need, but it's a good start. We can always update the role later on if the
    need arises.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不完全确信这些就是发布经理所需要的全部权限，但这是一个很好的开始。如果有需要，我们以后可以随时更新角色。
- en: John will be the only release manager for now. We'll add more users once we're
    confident that the role is working as expected.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，John 将是唯一的发布经理。一旦我们确信该角色按预期工作，我们会添加更多用户。
- en: 'Now that we have a plan, we can proceed to create a role and a binding that
    will define the permissions for release managers. The first thing we need to do
    is to figure out the resources, the Verbs, and the API Groups we''ll use. We might
    want to take a look at the Cluster Role `admin` for inspiration:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了计划，我们可以继续创建一个角色和绑定，来定义发布经理的权限。我们首先需要做的是弄清楚将要使用的资源、操作动词和 API 组。我们可能需要参考一下`admin`集群角色，以获取灵感：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output, limited to Pods, is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 仅限Pods的输出如下：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we'd specify only `pods` as a Rule resource, we would probably not create
    all the Pods-related permissions we need. Even though most of the operations we
    can perform on Pods are covered with the `pods` resource, we might need to add
    a few sub-resources as well. For example, if we'd like to be able to retrieve
    the logs, we'll need `pods/log` resource. In that case, `pods` would be a namespaced
    resource, and `log` would be a sub-resource of `pods`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅将`pods`作为规则资源进行指定，可能无法创建我们需要的所有与Pods相关的权限。尽管大多数对Pods的操作可以通过`pods`资源来实现，我们可能还需要添加一些子资源。例如，如果我们希望能够检索日志，就需要`pods/log`资源。在这种情况下，`pods`将是一个命名空间资源，而`log`将是`pods`的子资源。
- en: Deployment and ReplicaSet objects present a different challenge. If we go back
    to the output of the `kubectl describe clusterrole admin` command, we'll notice
    that the `deployments` have API Groups. Unlike sub-resources that are separated
    from resources with a slash (`/`), API Groups are separated with a dot (`.`).
    So, when we see a resource like `deployments.apps`, it means that it is a Deployment
    through the API Group `apps`. Core API Groups are omitted.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment和ReplicaSet对象带来了不同的挑战。如果我们回顾一下`kubectl describe clusterrole admin`命令的输出，我们会注意到`deployments`有API组。与通过斜杠（`/`）分隔的子资源不同，API组是通过点（`.`）来分隔的。因此，当我们看到像`deployments.apps`这样的资源时，意味着它是通过API组`apps`的Deployment。核心API组则被省略。
- en: 'It''ll probably be easier to understand sub-resources and API Groups by exploring
    the definition in `auth/crb-release-manager.yml`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索`auth/crb-release-manager.yml`中的定义，理解子资源和API组可能会更容易：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Most of that definition follows the same formula we already used a few times.
    We''ll focus only on the `rules` section of the `ClusterRole`. It is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义的大部分内容遵循我们已经使用过几次的相同模式。我们将重点关注`ClusterRole`的`rules`部分。其内容如下：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The level of access release managers' need differs between Pods on the one hand
    and Deployments and ReplicaSets on the other. Therefore, we split them into two
    groups.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 发布经理需要的访问级别在Pods和Deployments、ReplicaSets之间有所不同。因此，我们将它们分为两组。
- en: The first group specifies the `pods` resource together with a few sub-resources
    (`attach`, `exec`, `log`, and `status`). That should cover all the use cases we
    explored so far. Since we did not create Pod proxies nor port forwarding, they
    are not included.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组规则指定了`pods`资源，并附带了几个子资源（`attach`、`exec`、`log`和`status`）。这应该涵盖了我们迄今为止探索的所有用例。由于我们没有创建Pod代理或端口转发，它们没有被包括在内。
- en: We already said that release managers should be able to perform any operation
    on Pods, so the `verbs` consist of a single entry with an asterisk (`*`). On the
    other hand, all Pod resources belong to the same Core group, so we did not have
    to specify any in the `apiGroups` field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过发布经理应该能够对Pods执行任何操作，所以`verbs`只包含一个带星号（`*`）的条目。另一方面，所有Pod资源都属于同一个Core组，因此我们无需在`apiGroups`字段中指定任何内容。
- en: The second group of rules is set for `deployments` and `replicasets` resources.
    Considering we decided that we'll be more restrictive with them, we specified
    more specific `verbs`, allowing release managers only to `create`, `get`, `list`,
    and `watch`. Since we did not specify `delete`, `deletecollection`, `patch`, and
    `update` Verbs, release managers will not be able to perform related actions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组规则针对的是`deployments`和`replicasets`资源。考虑到我们决定对它们采取更严格的控制，我们指定了更具体的`verbs`，只允许发布经理执行`create`、`get`、`list`和`watch`操作。由于我们没有指定`delete`、`deletecollection`、`patch`和`update`动词，发布经理将无法执行相关操作。
- en: As you can see, RBAC Rules can be anything from being very simple to finely
    tuned to particular needs. It's up to us to decide the level granularity we'd
    like to accomplish.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，RBAC规则可以从非常简单到非常精细化，取决于具体需求。我们可以自行决定希望达到的粒度级别。
- en: Let's create the role and the binding related to release managers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建与发布经理相关的角色和绑定。
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To be on the safe side, we'll describe the newly created Cluster Role, and confirm
    that it has the permissions we need.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们将描述新创建的Cluster Role，并确认它具备我们需要的权限。
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, the users assigned to the role can do (almost) anything with
    Pods, while their permissions with Deployments and ReplicaSets are limited to
    creation and viewing. They will not be able to update or delete them. Access to
    any other resource is forbidden.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，被分配到该角色的用户几乎可以对Pods执行任何操作，而他们在Deployments和ReplicaSets上的权限仅限于创建和查看。他们不能更新或删除这些资源。访问任何其他资源是被禁止的。
- en: 'At the moment, John is the only User bound to the `release-manager` role. We''ll
    impersonate him, and verify that he can, for example, do anything related to Pods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，John是唯一被绑定到`release-manager`角色的用户。我们将模拟他，并验证他是否能够做一些与Pods相关的操作：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We'll do a similar type of verification but limited to creation of Deployments.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行类似的验证，但仅限于创建Deployments。
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In both cases, we got the answer `yes`, thus confirming that John can perform
    those actions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都得到了`yes`的答案，从而确认了John可以执行这些操作。
- en: The last verification we'll do, before letting John know about his new permissions,
    is to verify that he cannot delete Deployments.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在告诉John他的新权限之前，我们最后一次验证将是确认他不能删除Deployments。
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The output is `no`, clearly indicating that such action is forbidden.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`no`，明确表示此操作是被禁止的。
- en: We phone John to tell him all the things he's now permitted to do within the
    cluster in his role as release manager.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打电话给John，告诉他他作为发布经理现在在集群中被允许做的所有事情。
- en: Let's see a few of the things John would do with his newly generated permissions.
    We'll simulate that we are him by switching to the `jdoe` context.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看John在获得新权限后会做些什么。我们将通过切换到`jdoe`上下文来模拟他。
- en: '[PRE71]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A quick validation that John can create Deployments could be done with Mongo
    DB.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Mongo DB可以快速验证John是否能够创建Deployments。
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: John managed to create the Deployment in the `default` Namespace.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: John成功地在`default`命名空间中创建了Deployment。
- en: '[PRE73]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We can see that John cannot delete the ReplicaSet created by the Deployment.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，John无法删除由Deployment创建的ReplicaSet。
- en: 'Let''s check whether John can perform any action in his own Namespace:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查John是否可以在自己的命名空间中执行任何操作：
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We updated the `jdoe` context so that it uses the Namespace with the same name
    as default. Further on, we made sure that the context is used, and created a new
    Deployment based on the `mongo` image.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了`jdoe`的上下文，使其使用与默认命名空间相同名称的命名空间。接下来，我们确保使用该上下文，并基于`mongo`镜像创建了新的Deployment。
- en: Since John should be able to do anything within his Namespace, he should be
    able to delete the Deployment as well.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于John应该能够在他的命名空间内执行任何操作，他应该也能够删除该Deployment。
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, let''s try something that requires a truly high level of permissions:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试一些需要较高权限的操作：
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: John is even able to add new users to his Namespace and bind them to any role
    (as long as it does not exceed his permissions).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: John甚至能够向他的命名空间添加新用户，并将他们绑定到任何角色（只要不超出他的权限）。
- en: Replacing Users with Groups
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用组替代用户
- en: Defining a single user that can access the `jdoe` Namespace was probably the
    best approach. We expect that only John will want to access it. He is the owner
    of that Namespace. It's his private playground. Even if he chooses to add more
    users to it, he'll probably do it independently from our YAML definitions. After
    all, what's the point of giving him god-like privileges if not to let him do things
    without asking for our permission or involvement? From our perspective, that Namespace
    has, and will continue having only one User.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个可以访问`jdoe`命名空间的单一用户可能是最好的方法。我们预计只有John会想要访问它。他是该命名空间的所有者，这是他的私人游乐场。即使他选择添加更多用户，他也可能会独立于我们的YAML定义进行操作。毕竟，如果不给他类似神的权限，那么赋予他这种权限又有什么意义呢？从我们的角度看，该命名空间只有一个用户，且将继续只有一个用户。
- en: We cannot apply the same logic to the permissions in `default` and `dev` Namespaces.
    We might choose to give everyone in our organization the `view` role in the `default`
    Namespace. Similarly, developers in our company should be able to `deploy`, `update`,
    and `delete` resources from the `dev` Namespace. All in all, we can expect that
    the number of users in the `view` and `dev` bindings will increase with time.
    Continually adding new users is repetitive, boring, and error-prone process you
    probably don't want to do. Instead of becoming a person who hates his tedious
    job, we can create a system that groups users based on their roles. We already
    did a step in that direction when we created John's certificate.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法对`default`和`dev`命名空间中的权限应用相同的逻辑。我们可能会选择为我们组织中的每个人在`default`命名空间中授予`view`角色。类似地，我们公司中的开发人员应该能够从`dev`命名空间中`部署`、`更新`和`删除`资源。总的来说，我们可以预期，随着时间的推移，`view`和`dev`绑定中的用户数量会增加。不断地添加新用户是一个重复、无聊且容易出错的过程，你可能不希望去做。与其成为一个讨厌自己繁琐工作的人的人，不如创建一个基于角色将用户分组的系统。在我们创建约翰的证书时，我们已经朝这个方向迈出了第一步。
- en: Let's take another look at the subject of the certificate we created earlier.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看我们之前创建的证书的主题。
- en: '[PRE79]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We can see that the name is `jdoe` and that he belongs to the organization `devs`.
    We'll ignore the fact that he should probably belong to at least one more organization
    (`release-manager`).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到用户名是`jdoe`，他属于`devs`组织。我们将忽略他可能应该至少属于另一个组织（`release-manager`）这一事实。
- en: If you paid close attention, you probably remember that I mentioned a few times
    that RBAC can be used with Users, Groups, and Service Accounts. Groups are the
    same as Users, except that they are validating whether the certificate attached
    to a request to the API belongs to a specified group (`O`), instead of a name
    (`CN`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你可能记得我提到过几次，RBAC可以与用户、组和服务帐户一起使用。组与用户相同，只不过它们验证附加在请求API的证书是否属于指定的组（`O`），而不是名称（`CN`）。
- en: Let's take a quick look at yet another YAML definition.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下另一个YAML定义。
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You'll notice that the Role Binding `dev` and the Cluster Role Binding `view`
    are almost the same as those we used before. The only difference is in the `subjects.kind`
    field. This time, we're using `Group` as the value. As a result, we'll grant permissions
    to all users that belong to the organization `devs`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，角色绑定`dev`和集群角色绑定`view`几乎与我们之前使用的相同。唯一的区别在于`subjects.kind`字段。这次，我们使用`Group`作为值。因此，我们将授予属于`devs`组织的所有用户权限。
- en: We'll need to switch the context back to `minikube` before we apply the changes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用更改之前，我们需要将上下文切换回`minikube`。
- en: '[PRE83]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE84]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can see that the new definition reconfigured a few resources.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，新定义重新配置了一些资源。
- en: Now that the new definition is applied, we can validate whether John can still
    create objects inside the `dev` Namespace.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在新定义已应用，我们可以验证约翰是否仍然能够在`dev`命名空间中创建对象。
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The output is `no`, indicating that `jdoe` cannot `create deployments`. Before
    you start wondering what's wrong, I should inform you that the response is expected
    and correct. The `--as` argument is impersonating John, but the certificate is
    still from `minikube`. Kubernetes has no way of knowing that `jdoe` belongs to
    the group `devs`. At least, not until John issues a request with his own certificate.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`no`，表示`jdoe`不能`创建部署`。在你开始想知道哪里出错之前，我应该告诉你，这是预期且正确的响应。`--as`参数模拟了约翰的身份，但证书仍然来自`minikube`。Kubernetes无法知道`jdoe`属于`devs`组。至少，在约翰发出自己的证书请求之前，是无法知道的。
- en: Instead of using the `--as` argument, we'll switch back to the `jdoe` context
    and try to create a Deployment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再使用`--as`参数，而是切换回`jdoe`上下文，并尝试创建一个部署。
- en: '[PRE86]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This time the output is `deployment "new-db" created`, clearly indicating that
    the John as a member of the `devs` group can `create deployments`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这次输出是`deployment "new-db" created`，这明确表明，作为`devs`组成员的约翰可以`创建部署`。
- en: From now on, any user with a certificate that has `/O=devs` in the subject will
    have the same permissions as John within the `dev` Namespace as well as `view`
    permissions everywhere else. We just saved ourselves from constantly modifying
    YAML files and applying changes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，任何证书的主题中包含`/O=devs`的用户，都将拥有与约翰在`dev`命名空间内相同的权限，并且在其他地方拥有`view`权限。我们刚刚避免了不断修改YAML文件和应用更改的麻烦。
- en: What now?
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在怎么办？
- en: Authorization and authentication are critical security components. Without a
    proper set of permissions, we are risking exposure with potentially devastating
    results. Moreover, with appropriate Rules, Roles, and RoleBindings, we can make
    a cluster not only more secure but also increase collaboration between different
    members of our organization. The only trick is to find a right balance between
    tight security and freedom. It takes time until that equilibrium is established.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 授权和认证是至关重要的安全组件。如果没有适当的权限设置，我们可能会面临暴露风险，带来潜在的严重后果。此外，通过合适的规则（Rules）、角色（Roles）和角色绑定（RoleBindings），我们不仅可以让集群更安全，还可以促进组织内部不同成员之间的协作。唯一的挑战是找到安全性和自由之间的平衡。这需要时间，直到达成平衡。
- en: RBAC combined with Namespaces provides an excellent separation. Without Namespaces,
    we'd need to create multiple clusters. Without RBAC, those clusters would be exposed
    or locked down to only a handful of users. The two combined provide an excellent
    way to increase collaboration without sacrificing security.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 结合命名空间和RBAC提供了很好的隔离。如果没有命名空间，我们就需要创建多个集群。如果没有RBAC，这些集群要么会暴露，要么仅限于少数几个用户。两者结合提供了一种在不牺牲安全性的前提下，增加协作的优秀方式。
- en: We did not explore Service Accounts. They are the third kind of Subjects, besides
    Users and Groups. We'll leave that for some other time and place since they are
    used primarily for Pods that need to access the Kubernetes API. This chapter focused
    on humans and the ways we can enable them to reach a cluster in a safe and controlled
    manner.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有深入探讨服务账户（Service Accounts）。它们是除用户（Users）和组（Groups）之外的第三种主题（Subjects）。我们将留到以后再讨论，因为它们主要用于需要访问
    Kubernetes API 的 Pod。本章重点讨论的是人类以及我们如何以安全、受控的方式让他们访问集群。
- en: We are still missing one important restriction. By combining Namespaces and
    RBAC, we can restrict what users can do. However, that will not prevent them from
    deploying applications that could potentially bring down the whole cluster. We
    need to add Resource Quotas to the mix. That will be the subject of the next chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少一个重要的限制条件。通过结合命名空间（Namespaces）和基于角色的访问控制（RBAC），我们可以限制用户的操作。然而，这并不能防止他们部署可能会导致整个集群崩溃的应用程序。我们需要将资源配额（Resource
    Quotas）加入其中。这将是下一章的内容。
- en: For now, we'll destroy the cluster and take a rest. We covered a lot of ground
    in this chapter. We deserve a break.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将销毁集群，休息一下。本章我们涵盖了很多内容，值得休息一下。
- en: '[PRE87]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If you'd like to know more about Roles, please explore the Role v1 rbac ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#role-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#role-v1-rbac))
    and ClusterRole v1 rbac ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrole-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrole-v1-rbac))
    API documentation. Similarly, you might want to visit the RoleBinding v1 rbac
    ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#rolebinding-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#rolebinding-v1-rbac))
    and ClusterRoleBinding v1 rbac ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrolebinding-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrolebinding-v1-rbac))
    API documentation as well.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于角色的信息，请查阅 Role v1 rbac 的 API 文档（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#role-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#role-v1-rbac)）和
    ClusterRole v1 rbac 的 API 文档（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrole-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrole-v1-rbac)）。同样，你可能也想访问
    RoleBinding v1 rbac 的 API 文档（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#rolebinding-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#rolebinding-v1-rbac)）和
    ClusterRoleBinding v1 rbac 的 API 文档（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrolebinding-v1-rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrolebinding-v1-rbac)）。
- en: Kubernetes RBAC compared to Docker Swarm RBAC
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes RBAC 与 Docker Swarm RBAC 对比
- en: Docker has RBAC. Just as Kubernetes, it is organized around subjects, roles,
    and resource collections. In many aspects, both provide a very similar set of
    features. Should we quickly declare it a tie?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 也有 RBAC。与 Kubernetes 一样，它围绕主题（subjects）、角色（roles）和资源集合（resource collections）进行组织。在许多方面，二者提供了非常相似的功能。我们是否应该迅速宣布平局？
- en: There is one crucial difference between Kubernetes RBAC and the one provided
    by Docker. The latter is not free. You'd need to purchase Docker **Enterprise
    Edition** (**EE**) to secure your cluster beyond "only those with the certificate
    can access it." If you do have Docker EE, you already made up your mind, and the
    discussion whether to use one or the other is over. Docker EE is great, and soon
    it will work not only with Swarm but also with Kubernetes. You bought it, and
    there's not much reason to switch to something else. However, this comparison
    focuses on what open source core versions can offer. It ignores third party and
    enterprise additions.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes RBAC 和 Docker 提供的 RBAC 之间有一个关键区别。后者不是免费的。你需要购买 Docker **企业版** (**EE**)
    来保障集群的安全，而不仅仅是“只有持证人才能访问”。如果你已经购买了 Docker EE，那么你已经做出了决定，关于是否使用 Docker 或 Kubernetes
    的讨论也就结束了。Docker EE 很棒，而且很快它不仅会与 Swarm 一起工作，还会与 Kubernetes 一起工作。你已经购买了它，没有太多理由去切换到其他东西。然而，这个对比专注于开源核心版本能提供的功能，忽略了第三方和企业版本的扩展。
- en: If we stick with an "only what's in the box" comparison, Kubernetes is a clear
    winner. It has RBAC, and Docker Swarm doesn't. The problem is not that Swarm doesn't
    have RBAC, but that it doesn't have any user-based authentication baked in. Therefore,
    this is a very short comparison. If you don't want to purchase enterprise products,
    and you do need an authorization and authentication mechanism, Kubernetes is the
    only option. Just as with Namespaces, Kubernetes shows its strength by the sheer
    number of features that do not exist in Swarm.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们坚持做一个“仅限开箱即用”的对比，Kubernetes 显然是赢家。它有 RBAC，而 Docker Swarm 没有。问题不在于 Swarm
    没有 RBAC，而在于它没有任何内建的基于用户的认证机制。因此，这是一个非常简短的对比。如果你不想购买企业产品，并且确实需要一个授权和认证机制，那么 Kubernetes
    是唯一的选择。就像命名空间一样，Kubernetes 通过其众多 Swarm 所没有的功能展现了它的优势。
