- en: '*Chapter 3*: Running Application Containers on Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*: 在Kubernetes上运行应用容器'
- en: This chapter contains a comprehensive overview of the smallest Lego block that
    Kubernetes provides – the Pod. Included is an explanation of the PodSpec YAML
    format and possible configurations, and a quick discussion of how Kubernetes handles
    and schedules Pods. The Pod is the most basic way to run applications on Kubernetes
    and is used in all higher-order application controllers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了Kubernetes提供的最小乐高模块——Pod的全面概述。包括对PodSpec YAML格式及其可能配置的解释，以及Kubernetes如何处理和调度Pod的简要讨论。Pod是Kubernetes上运行应用程序的最基本方式，并且在所有高级应用程序控制器中都有使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What is a Pod?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Pod？
- en: Namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The Pod life cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod生命周期
- en: The Pod resource spec
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod资源规格
- en: Pod scheduling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod调度
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool, along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods for getting up and running with Kubernetes
    quickly, and for instructions on how to install the `kubectl` tool.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中详细介绍的命令，您需要一台支持`kubectl`命令行工具的计算机，并且需要一个工作中的Kubernetes集群。请参阅[*第1章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)，*与Kubernetes通信*，了解几种快速启动Kubernetes的方法，以及如何安装`kubectl`工具的说明。
- en: 'The code used in this chapter can be found in the book''s GitHub repository
    at the following link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的GitHub仓库中找到，链接如下：
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3)'
- en: What is a Pod?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Pod？
- en: The Pod is the simplest compute resource in Kubernetes. It specifies one or
    more containers to be started and run by the Kubernetes scheduler on a node. Pods
    have many potential configurations and extensions but remain the most basic way
    to run applications on Kubernetes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes中最简单的计算资源。它指定一个或多个容器，由Kubernetes调度器在节点上启动和运行。Pod有许多潜在的配置和扩展，但仍然是Kubernetes上运行应用程序的最基本方式。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A Pod by itself is not a very good way to run applications on Kubernetes. Pods
    should be treated like fdisposable things in order to take advantage of the true
    capabilities of a container orchestrator like Kubernetes. This means treating
    containers (and therefore Pods) like cattle, not pets. To really make use of containers
    and Kubernetes, applications should be run in self-healing, scalable groups. The
    Pod is the building block of these groups, and we'll get into how to configure
    applications this way in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用Pod并不是在Kubernetes上运行应用程序的最佳方式。为了充分利用像Kubernetes这样的容器编排工具的真正能力，Pod应被视为一次性资源。这意味着应将容器（因此也包括Pod）视为牲畜，而不是宠物。要真正利用容器和Kubernetes，应用程序应在自愈、可扩展的组中运行。Pod是这些组的构建块，我们将在后续章节中讲解如何以这种方式配置应用程序。
- en: Implementing Pods
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Pods
- en: Pods are implemented using Linux isolation tenets such as groups and namespaces,
    and generally can be thought of as a logical host machine. Pods run one or more
    containers (which can be based on Docker, CRI-O, or other runtimes) and these
    containers can communicate with each other in the same ways that different processes
    on a VM can communicate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是通过Linux隔离原则（如组和命名空间）实现的，通常可以看作是一个逻辑主机。Pod可以运行一个或多个容器（这些容器可以基于Docker、CRI-O或其他运行时），并且这些容器之间可以像虚拟机中的不同进程那样进行通信。
- en: In order for containers within two different Pods to communicate, they need
    to access the other Pod (and container) via its IP. By default, only containers
    running on the same Pod can use lower-level methods of communication, though it
    is possible to configure different Pods with the availability to talk to each
    other via host IPC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使两个不同Pod中的容器能够通信，它们需要通过Pod的IP访问另一个Pod（及其容器）。默认情况下，只有运行在同一Pod中的容器可以使用较低层次的通信方式，尽管可以配置不同的Pod，使其通过主机IPC相互通信。
- en: Pod paradigms
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod范式
- en: 'At the most basic level, there are two types of Pods:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从最基本的层面来看，Pod有两种类型：
- en: Single-container Pods
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单容器Pod
- en: Multi-container Pods
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多容器Pod
- en: It is generally a best practice to include a single container per Pod. This
    approach allows you to scale the different parts of your application separately,
    and generally keeps things simple when it comes to creating a Pod that starts
    and runs without issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最佳实践是每个Pod只包含一个容器。这样做可以让你分别扩展应用的不同部分，并且在创建能够正常启动和运行的Pod时通常会更简单。
- en: 'Multi-container Pods, on the other hand, are more complex but can be useful
    in various circumstances:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，多容器Pod更为复杂，但在某些情况下非常有用：
- en: If there are multiple parts of your application that run in separate containers
    but are tightly coupled, you can run them both inside the same Pod to make communication
    and filesystem access seamless.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用有多个部分运行在独立的容器中，但它们是紧密耦合的，你可以将它们放在同一个Pod中运行，以便实现无缝的通信和文件系统访问。
- en: When implementing the *sidecar* pattern, where utility containers are injected
    alongside your main application to handle logging, metrics, networking, or advanced
    functionality such as a Service Mesh (more on this in [*Chapter 14*](B14790_14_Final_PG_ePub.xhtml#_idTextAnchor307),
    *Service Meshes and Serverless*).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现*侧车*模式时，工具容器会与主应用一起注入，用于处理日志、指标、网络或更高级的功能，如服务网格（关于这方面的内容可以参考[*第14章*](B14790_14_Final_PG_ePub.xhtml#_idTextAnchor307)，*服务网格与无服务器架构*）。
- en: 'The following diagram shows a common sidecar implementation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个常见的侧车实现：
- en: '![Figure 3.1 – Common sidebar implementation](img/B14790_03_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 常见侧边栏实现](img/B14790_03_001.jpg)'
- en: Figure 3.1 – Common sidebar implementation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 常见侧边栏实现
- en: 'In this example, we have a single Pod with two containers: our application
    container running a web server, and a logging application that pulls logs from
    our server Pod and forwards them to our logging infrastructure. This is a very
    applicable use of the sidecar pattern, though many log collectors work at the
    node level, not at the Pod level, so this is not a universal way of collecting
    logs from our app containers in Kubernetes.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个Pod，里面有两个容器：一个运行Web服务器的应用容器和一个日志应用，它从我们的服务器Pod拉取日志并将其转发到日志基础设施。这是*侧车*模式的一个非常典型的应用，尽管许多日志收集器是在节点级别工作，而不是Pod级别，因此这并不是在Kubernetes中从我们的应用容器收集日志的普遍方式。
- en: Pod networking
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 网络
- en: As we just mentioned, Pods have their own IP addresses that can be used in inter-pod
    communication. Each Pod has an IP address as well as ports, which are shared among
    the containers running in a Pod if there is more than one container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚提到的，Pods有自己的IP地址，可以用于Pod间的通信。每个Pod都有一个IP地址以及端口，如果Pod中有多个容器，这些端口是容器之间共享的。
- en: Within a Pod, as we mentioned before, containers can communicate without calling
    the wrapping Pod's IP – instead they can simply use localhost. This is because
    containers within a Pod share a network namespace – in essence, they communicate
    via the same *bridge*, which is implemented using a virtual network interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Pod内，如前所述，容器之间可以不通过Pod的IP来通信——它们可以直接使用localhost。这是因为Pod内的容器共享一个网络命名空间——本质上，它们通过相同的*桥接*进行通信，而这个桥接是通过虚拟网络接口实现的。
- en: Pod storage
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod存储
- en: Storage in Kubernetes is a large topic on its own, and we will review it in
    depth in [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166), *Storage
    on Kubernetes* – but for now, you can think of Pod storage as either persistent
    or non-persistent volumes attached to a Pod. Non-persistent volumes can be used
    by a Pod to store data or files depending on the type, but they are deleted when
    the Pod shuts down. Persistent-type volumes will remain past Pod shutdown and
    can even be used to share data between multiple Pods or applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的存储是一个庞大的话题，我们将在[*第7章*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166)，*Kubernetes上的存储*中深入探讨——但现在，你可以将Pod存储理解为附加到Pod上的持久性或非持久性卷。非持久性卷可以被Pod用于存储数据或文件，具体取决于卷的类型，但它们会在Pod关闭时被删除。持久性卷将在Pod关闭后仍然存在，甚至可以在多个Pod或应用之间共享数据。
- en: Before we can continue with our discussion of Pods, we will take a quick moment
    to discuss namespaces. Since we'll be working with `kubectl` commands during our
    work with Pods, it's important to know how namespaces tie into Kubernetes and
    `kubectl`, since it can be a big "gotcha."
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论Pods之前，我们先简要讨论一下命名空间。由于我们在与Pods的操作中将使用`kubectl`命令，因此了解命名空间如何与Kubernetes和`kubectl`关联是非常重要的，因为这可能是一个大“陷阱”。
- en: Namespaces
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: We talked briefly about namespaces in the section on authorization in *Chapter
    1*, *Communicating with Kubernetes*, but we will reiterate and expand on their
    purpose here. Namespaces are a way to logically separate different areas within
    your cluster. A common use case is having a namespace per environment – one for
    dev, one for staging, one for production – all living inside the same cluster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第1章*《与Kubernetes通信》的授权部分中简要讨论了命名空间，但在这里我们将重申并扩展它们的目的。命名空间是一种在集群中逻辑上分离不同区域的方法。一个常见的用例是为每个环境设置一个命名空间——一个用于开发环境，一个用于暂存环境，一个用于生产环境——它们都存在于同一个集群中。
- en: As we mentioned in the *Authorization* section, it is possible to specify user
    permissions on a per-namespace basis – for instance, letting a user deploy new
    applications and resources to the `dev` namespace but not to production.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*授权*部分中提到的，可以在每个命名空间的基础上指定用户权限——例如，允许用户将新应用和资源部署到`dev`命名空间，而不能部署到生产环境。
- en: 'In your running cluster, you can see what namespaces exist by running `kubectl
    get namespaces` or `kubectl get ns`, which should result in the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的运行集群中，你可以通过运行`kubectl get namespaces`或`kubectl get ns`来查看现有的命名空间，这将输出如下内容：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create a namespace imperatively, you can simply run `kubectl create namespace
    staging`, or run `kubectl apply -f /path/to/file.yaml` with the following YAML
    resource spec:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制创建命名空间，你可以简单地运行`kubectl create namespace staging`，或者运行`kubectl apply -f /path/to/file.yaml`，并使用以下YAML资源规格：
- en: Staging-ns.yaml
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Staging-ns.yaml
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, a `Namespace` spec is very simple. Let's move on to something
    more complex – the PodSpec itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Namespace`规格非常简单。让我们继续讨论一些更复杂的内容——PodSpec本身。
- en: The Pod life cycle
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod生命周期
- en: To quickly see which Pods are running in your cluster, you can run `kubectl
    get pods` or `kubectl get pods --all-namespaces` to get Pods in either the current
    namespace (defined by your `kubectl` context, or the default namespace if none
    is specified) or all namespaces, respectively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 若要快速查看集群中正在运行的Pods，可以运行`kubectl get pods`或`kubectl get pods --all-namespaces`，分别查看当前命名空间（由`kubectl`上下文定义，或者如果未指定则是默认命名空间）或所有命名空间中的Pods。
- en: 'The output of `kubectl get pods` looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get pods`的输出如下所示：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, Pods have a `STATUS` value that tells us in which state the
    Pod currently is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Pods有一个`STATUS`值，告诉我们Pod当前处于哪个状态。
- en: 'The values for Pod state are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Pod状态的值如下：
- en: '`Running` status, a Pod has successfully spun up its container(s) without any
    issues. If the Pod has a single container, and it''s in `Running` status, then
    the container has not completed or exited its process. It could also currently
    be restarting, which you can tell by checking the `READY` column. If, for instance,
    the `READY` value is `0/1`, that means that the container in the Pod is currently
    not passing health checks. This could be for a variety of reasons: the container
    could still be spinning up, a database connection could be non-functional, or
    some important configuration could be preventing the application process from
    starting.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running`状态表示Pod已经成功启动其容器，且没有任何问题。如果Pod只有一个容器，且其状态为`Running`，则表示容器尚未完成或退出其进程。它也可能正在重启，你可以通过检查`READY`列来判断。例如，如果`READY`值为`0/1`，则意味着Pod中的容器当前未通过健康检查。这可能有多种原因：容器可能仍在启动中，数据库连接可能不可用，或某些重要的配置可能阻止了应用进程的启动。'
- en: '`Succeeded` state if those containers have completed their process command.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果容器已完成其进程命令，则为`Succeeded`状态。
- en: '`Pending` statuses designate that at least one container in the Pod is waiting
    for its image. This is likely because the container image is still being fetched
    from an external repository, or because the Pod itself is waiting to be scheduled
    by `kube-scheduler`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pending`状态表示Pod中至少有一个容器正在等待其镜像。这通常是因为容器镜像仍在从外部仓库拉取，或因为Pod本身正在等待`kube-scheduler`调度。'
- en: '`Unknown` status means that Kubernetes cannot tell what state the Pod is actually
    in. This usually means that the node that the Pod lives on is experiencing some
    form of error. It may be out of disk space, disconnected from the rest of the
    cluster, or otherwise be encountering problems.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown`状态意味着Kubernetes无法确定Pod当前的状态。这通常表示Pod所在的节点正在经历某种错误。可能是磁盘空间不足、与集群其他部分断开连接，或遇到其他问题。'
- en: '`Failed` status, one or more of the containers in the Pod has terminated with
    a failure status. Additionally, the other containers in the Pod must have terminated
    in either success or failure. This can happen for a variety of reasons due to
    the cluster removing Pods or something inside the container application breaking
    the process.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Failed` 状态，表示 Pod 中一个或多个容器已经以失败状态终止。此外，Pod 中的其他容器必须已经以成功或失败状态终止。这可能是由于集群删除
    Pod 或容器应用程序内部的某些问题导致进程中断。'
- en: Understanding the Pod resource spec
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Pod 资源规格
- en: Since the Pod resource spec is the first one we've really dug into, we will
    spend our time detailing the various parts of the YAML file and how they fit together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pod 资源规格是我们深入研究的第一个内容，我们将花时间详细讲解 YAML 文件的各个部分以及它们如何组合在一起。
- en: 'Let''s start things off with a fully spec''d-out Pod file, which we can then
    pick apart and review:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个完全规范化的 Pod 文件开始，然后我们可以拆解它并进行回顾：
- en: Simple-pod.yaml
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Simple-pod.yaml
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This Pod YAML file is somewhat more complicated than the one that we looked
    at in the first chapter. It exposes some new Pod functionality that we will review
    shortly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Pod YAML 文件比我们在第一章中看到的稍微复杂一些。它展示了一些新的 Pod 功能，我们稍后将进行回顾。
- en: API version
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 版本
- en: 'Let''s start at line 1: `apiVersion`. As we mentioned in [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016),
    *Communicating with Kubernetes*, `apiVersion` tells Kubernetes which version of
    the API to look at when creating and configuring your resource. Pods have been
    around for a long time in Kubernetes, so the PodSpec is solidified into API version
    `v1`. Other resource types may contain group names in addition to version names
    – for instance, a CronJob resource in Kubernetes uses `batch/v1beta1` `apiVersion`,
    while the Job resource uses the `batch/v1` `apiVersion`. In both of these, `batch`
    corresponds to the API group name.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 1 行开始：`apiVersion`。正如我们在 [*第 1 章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)
    中提到的，*与 Kubernetes 通信*，`apiVersion` 告诉 Kubernetes 在创建和配置资源时应该查看哪个版本的 API。Pod 在
    Kubernetes 中已经存在很长时间，因此 PodSpec 已经固定为 API 版本 `v1`。其他资源类型可能除了版本名外，还包含组名——例如，Kubernetes
    中的 CronJob 资源使用 `batch/v1beta1` `apiVersion`，而 Job 资源则使用 `batch/v1` `apiVersion`。在这两种情况下，`batch`
    对应于 API 组名。
- en: Kind
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: The `kind` value corresponds to the actual name of the resource type in Kubernetes.
    In this case, we're trying to spec out a Pod, so that's what we put. The `kind`
    value is always in camel case, such as `Pod`, `ConfigMap`, `CronJob`, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind` 值对应于 Kubernetes 中资源类型的实际名称。在这种情况下，我们要指定一个 Pod，这就是我们填写的内容。`kind` 值总是采用驼峰命名法，例如
    `Pod`、`ConfigMap`、`CronJob` 等等。'
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: For a full list of `kind` values, check the official Kubernetes documentation
    at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/). New Kubernetes
    `kind` values are added in new releases so the ones reviewed in this book may
    not be an exhaustive list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的 `kind` 值列表，请参考官方 Kubernetes 文档：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。新的
    Kubernetes `kind` 值会在新版本中添加，因此本书中讨论的值可能不是完整的列表。
- en: Metadata
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据
- en: Metadata is a top-level key that can have several different values underneath.
    First of all, `name` is the resource name, which is what the resource will display
    as via `kubectl` and what it is stored as in `etcd`. `namespace` corresponds to
    the namespace that the resource should be created in. If no namespace is specified
    in the YAML spec, the resource will be created in the `default` namespace – unless
    a namespace is specified in the `apply` or `create` commands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是一个顶级键，可以在其下有多个不同的值。首先，`name` 是资源的名称，它是通过 `kubectl` 显示的内容，并且在 `etcd` 中存储的名称。`namespace`
    对应于资源应创建的命名空间。如果 YAML 规范中未指定命名空间，则资源将创建在 `default` 命名空间中——除非在 `apply` 或 `create`
    命令中指定了命名空间。
- en: Next, `labels` are key-value pairs that are used to add metadata to a resource.
    `labels` are special compared to other metadata because they are used by default
    in Kubernetes native `selectors` to filter and select resources – but they can
    also be used for custom functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`labels` 是用于向资源添加元数据的键值对。与其他元数据不同，`labels` 是 Kubernetes 原生 `selectors` 默认使用的，用于过滤和选择资源——但它们也可以用于自定义功能。
- en: 'Finally, the `metadata` block can play host to multiple `annotations` which,
    like `labels`, can be used by controllers and custom Kubernetes functionality
    to provide additional configuration and feature-specific data. In this PodSpec,
    we have several annotations specified in our metadata:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`metadata`块可以包含多个`annotations`，这些`annotations`像`labels`一样，可以被控制器和自定义的Kubernetes功能使用，用于提供额外的配置和特定功能的数据。在这个PodSpec中，我们在`metadata`中指定了几个注解：
- en: pod-with-annotations.yaml
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-annotations.yaml
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generally, it is better to use `labels` for Kubernetes-specific functionality
    and selectors while using `annotations` for adding data or extension functionality
    – this is just a convention.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，最好使用`labels`来处理Kubernetes特定的功能和选择器，而使用`annotations`来添加数据或扩展功能——这只是一个约定。
- en: Spec
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spec
- en: '`spec` is the top-level key that contains the resource-specific configuration.
    In this case, since our `kind` value is `Pod`, we''ll add some configuration that
    is specific to our Pod. All further keys will be indented under this `spec` key
    and will represent our Pod configuration.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`是包含资源特定配置的顶级键。在这种情况下，由于我们的`kind`值是`Pod`，我们将添加一些特定于Pod的配置。所有后续的键都会在`spec`键下缩进，并表示我们的Pod配置。'
- en: Containers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: The `containers` key expects a list of one or more containers that will run
    within a Pod. Each container spec will expose its own configuration values, which
    are indented under the container list item in your resource YAML. We will review
    some of these configurations here, but for a full list, check the Kubernetes documentation
    ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`containers`键期望一个包含一个或多个容器的列表，这些容器将在Pod内运行。每个容器的规格将暴露它自己的配置值，这些值会在资源YAML中容器列表项下进行缩进。我们将在这里回顾其中一些配置，但完整的配置清单请参考Kubernetes文档（[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)）。'
- en: Name
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称
- en: Inside a container spec, `name` pertains to what the container will be named
    within a Pod. Container names can be used to specifically access the logs of a
    particular container using the `kubectl logs` command, but we'll get to that later.
    For now, ensure you choose a clear name for each container in your Pod to make
    things easier when it comes to debugging.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器规格中，`name`与容器在Pod中的名称相关。容器名称可以用来通过`kubectl logs`命令特定地访问某个容器的日志，但我们稍后会讲到。现在，确保为Pod中的每个容器选择一个清晰的名称，以便在调试时更容易。
- en: Image
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像
- en: For each container, `image` is used to specify the name of the Docker (or other
    runtime) image that should be started within the Pod. Images will be pulled from
    the configured repository, which is the public Docker Hub by default, but can
    be a private repository as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个容器，`image`用于指定应该在Pod中启动的Docker（或其他运行时）镜像的名称。镜像将从配置的仓库中拉取，默认是公共的Docker Hub，也可以是私有仓库。
- en: And that's it – that's all you need to specify a Pod and run it in Kubernetes.
    Everything from this point on in the `Pod` section falls under the *additional
    configuration* umbrella.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——这就是你在Kubernetes中指定并运行一个Pod所需的一切。从此之后，`Pod`部分中的所有内容都属于*附加配置*范围。
- en: Pod resource specifications
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod资源规格
- en: Pods can be configured to have specific amounts of memory and compute allocated
    to them. This prevents particularly hungry applications from impacting cluster
    performance and can also help prevent memory leaks. There are two possible resources
    that can be specified – `cpu` and `memory`. For each of these, there are two different
    types of specifications, `Requests` and `Limits`, for a total of four possible
    resource specification keys.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Pods可以配置特定的内存和计算资源分配。这样可以防止资源消耗较大的应用程序影响集群性能，同时也有助于防止内存泄漏。可以指定两种资源——`cpu`和`memory`。对于每种资源，都有两种不同类型的规格——`Requests`和`Limits`，总共有四个可能的资源规格键。
- en: Memory requests and limits can be configured with any typical memory number
    suffix, or its power-of-two equivalent – for instance, 50 Mi (mebibytes), 50 MB
    (megabytes), or 1 Gi (gibibytes).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存请求和限制可以使用任何典型的内存数量后缀进行配置，或者使用其二的幂等效值——例如，50 Mi（兆二进制字节），50 MB（兆字节）或1 Gi（吉比字节）。
- en: 'CPU requests and limits can be configured either by using `m` which corresponds
    to 1 milli-CPU, or by just using a decimal number. So `200m` is equivalent to
    `0.2`, which equals 20% or one fifth of a logical CPU. This quantity will be the
    same amount of compute power regardless of the number of cores. 1 CPU equals a
    virtual core in AWS or a core in GCP. Let''s look at how these resource requests
    and limits look in our YAML file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 请求和限制可以通过使用 `m`（对应于 1 毫 CPU）或仅使用十进制数来配置。因此，`200m` 相当于 `0.2`，等于 20% 或一个逻辑
    CPU 的五分之一。无论核心数量如何，此数量将是相同的计算能力。1 CPU 等于 AWS 中的虚拟核心或 GCP 中的核心。让我们看看这些资源请求和限制在我们的
    YAML 文件中是什么样子的：
- en: pod-with-resource-limits.yaml
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-resource-limits.yaml
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this `Pod`, we have a container running a Docker image that is specified
    with both requests and limits on `cpu` and `memory`. In this case, our container
    image name, `mydockername`, is a placeholder - but if you want to test the Pod
    resource limits in this example, you can use the busybox image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `Pod` 中，我们有一个运行 Docker 镜像的容器，该镜像具有对 `cpu` 和 `memory` 的请求和限制。在这种情况下，我们的容器镜像名称
    `mydockername` 是一个占位符 - 但如果你想在这个示例中测试 Pod 资源限制，你可以使用 busybox 镜像。
- en: Container start commands
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器启动命令
- en: 'When a container starts in a Kubernetes Pod, it runs the default start script
    for the container – for instance, the script specified in the Docker container
    spec. In order to override this functionality with different commands or additional
    arguments, you can provide the `command` and `args` keys. Let''s look at a container
    configured with a `start` command and some arguments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个容器在 Kubernetes Pod 中启动时，它会运行容器规范中指定的默认启动脚本 - 例如 Docker 容器规范中指定的脚本。为了使用不同的命令或附加参数覆盖此功能，你可以提供
    `command` 和 `args` 键。让我们来看一个配置了 `start` 命令和一些参数的容器：
- en: pod-with-start-command.yaml
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-start-command.yaml
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we specify a command as well as a list of arguments as an array
    of strings, separated with commas where spaces would be.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们指定了一个命令以及作为字符串数组的参数列表，用逗号分隔，空格应用空格。
- en: Init containers
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化容器
- en: '`init` containers are special containers within a Pod that start, run, and
    shut down before the normal Pod container(s) start.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 容器是 Pod 中的特殊容器，在普通 Pod 容器启动之前启动、运行和关闭。'
- en: '`init` containers can be used for many different use cases, such as initializing
    files before an application starts or ensuring that other applications or services
    are running before starting a Pod.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 容器可用于许多不同的用例，例如在应用程序启动之前初始化文件或确保在启动 Pod 之前运行其他应用程序或服务。'
- en: If multiple `init` containers are specified, they will run in order until all
    `init` containers have shut down. For this reason, `init` containers must run
    a script that completes and has an endpoint. If your `init` container script or
    application keeps running, the normal container(s) in your Pod will not start.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了多个 `init` 容器，它们将按顺序运行，直到所有 `init` 容器都关闭。因此，`init` 容器必须运行一个完成并具有终点的脚本。如果你的
    `init` 容器脚本或应用程序继续运行，Pod 中的普通容器将不会启动。
- en: 'In the following Pod, the `init` container is running a loop to check that
    our `config-service` exists via `nslookup`. Once it sees that `config-service`
    is up, the script ends, which triggers our `my-app` app container to start:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Pod 中，`init` 容器正在运行一个循环，通过 `nslookup` 检查我们的 `config-service` 是否存在。一旦它发现
    `config-service` 已经启动，脚本就会结束，这将触发我们的 `my-app` 应用容器启动：
- en: pod-with-init-container.yaml
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-init-container.yaml
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When an `init` container fails, Kubernetes will automatically restart the Pod,
    similar to the usual Pod startup functionality. This functionality can be changed
    by changing `restartPolicy` at the Pod level.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `init` 容器失败时，Kubernetes 将自动重新启动 Pod，类似于通常的 Pod 启动功能。可以通过在 Pod 级别更改 `restartPolicy`
    来更改此功能。
- en: 'Here''s a diagram showing the typical Pod startup flow in Kubernetes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示 Kubernetes 中典型 Pod 启动流程的图表：
- en: '![Figure 3.2 – Init container flowchart](img/B14790_03_002.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 初始化容器流程图](img/B14790_03_002.jpg)'
- en: Figure 3.2 – Init container flowchart
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 初始化容器流程图
- en: 'If a Pod has more than one `initContainer`, they will be invoked sequentially.
    This is valuable for times where you set up `initContainers` with modular steps
    that must be executed in order. The following YAML shows this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 Pod 有多个 `initContainer`，它们将按顺序调用。这对于设置了必须按顺序执行的模块化步骤的 `initContainers`
    非常有价值。下面的 YAML 显示了这一点：
- en: pod-with-multiple-init-containers.yaml
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-multiple-init-containers.yaml
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For instance, in this `Pod` YAML file, the `step-1 init` container needs to
    succeed before `init-step-2` is invoked, and both need to show success before
    the `my-app` container will be started.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个`Pod` YAML文件中，`step-1 init`容器需要先成功运行，才能启动`init-step-2`，而且只有当两个容器都显示成功时，`my-app`容器才会启动。
- en: Introducing different types of probes in Kubernetes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Kubernetes中引入不同类型的探针
- en: In order to know when a container (and therefore a Pod) has failed, Kubernetes
    needs to know how to test that the container is functioning. We do this by defining
    `probes`, which Kubernetes can run at a specified interval to determine whether
    the container is working.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道容器（因此也知道Pod）何时失败，Kubernetes需要知道如何测试容器是否正常运行。我们通过定义`probes`来实现这一点，Kubernetes会在指定的间隔时间内运行这些探针，以判断容器是否工作正常。
- en: There are three types of probes that Kubernetes lets us configure – readiness,
    liveness, and startup.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许我们配置三种类型的探针——准备就绪探针、存活探针和启动探针。
- en: Readiness probes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备就绪探针
- en: First off, readiness probes can be used to determine whether a container is
    ready to perform a function such as accepting traffic via HTTP. These probes are
    helpful in the beginning stages of a running application, where it may still be
    fetching the configuration, for instance, and not yet be ready to accept connections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，准备就绪探针可以用来判断容器是否准备好执行某些操作，比如通过HTTP接受流量。这些探针在应用程序的初期阶段非常有用，比如容器可能仍在获取配置，尚未准备好接受连接。
- en: 'Let''s take a look at what a Pod with a readiness probe configured looks like.
    What follows is a PodSpec with a readiness probe attached:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置了准备就绪探针的Pod是怎样的。以下是附带准备就绪探针的PodSpec：
- en: pod-with-readiness-probe.yaml
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-readiness-probe.yaml
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For starters, as you can see, probes are defined per container, not per Pod.
    Kubernetes will run all probes per container and use that to determine the total
    health of the Pod.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如您所见，探针是按容器定义的，而不是按Pod定义的。Kubernetes会对每个容器运行所有的探针，并利用这些信息来判断Pod的整体健康状态。
- en: Liveness probes
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存活探针
- en: 'Liveness probes can be used to determine whether an application has failed
    for some reason (for instance, due to a memory error). For application containers
    that run a long time, liveness probes can come in handy as a method to help Kubernetes
    recycle old and broken Pods for new ones. Though probes in and of themselves won''t
    cause a container to restart, other Kubernetes resources and controllers will
    check the probe status and use it to restart Pods when necessary. Here is a PodSpec
    with a liveness probe definition attached to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 存活探针可以用来判断应用程序是否由于某种原因（例如内存错误）失败。对于长时间运行的应用容器，存活探针非常有用，它能帮助Kubernetes回收旧的或故障的Pod，替换成新的Pod。虽然探针本身不会导致容器重启，但其他Kubernetes资源和控制器会检查探针状态，并在必要时使用它来重启Pod。以下是附带存活探针定义的PodSpec：
- en: pod-with-liveness-probe.yaml
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-liveness-probe.yaml
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, our liveness probe is specified in the same way as our readiness
    probe, with one addition – `failureThreshold`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的存活探针（liveness probe）的定义与准备就绪探针（readiness probe）相同，唯一的不同是增加了`failureThreshold`。
- en: The `failureThreshold` value will determine how many times Kubernetes will attempt
    the probe before taking action. For liveness probes, Kubernetes will restart the
    Pod once the `failureThreshold` is crossed. For readiness probes, Kubernetes will
    simply mark the Pod as `Not Ready`. The default value for this threshold is `3`,
    but it can be changed to any value greater than or equal to `1`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`failureThreshold`的值将决定Kubernetes在采取行动之前尝试探测的次数。对于存活探针，当`failureThreshold`被超越时，Kubernetes会重启Pod；而对于准备就绪探针，Kubernetes则会简单地将Pod标记为`Not
    Ready`。该阈值的默认值是`3`，但可以更改为大于或等于`1`的任何值。'
- en: In this case, we are using the `exec` mechanism with our probe. We will review
    the various probe mechanisms available shortly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`exec`机制来进行探测。稍后我们会回顾各种可用的探测机制。
- en: Startup probes
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动探针
- en: 'Finally, startup probes are a special type of probe that will only run once,
    on container startup. Some (often older) applications will take a long time to
    start up in a container, so by providing some extra leeway when a container starts
    up the first time, you can prevent the liveness or readiness probes failing and
    causing a restart. Here''s a startup probe configured with our Pod:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动探针（startup probe）是一种特殊类型的探针，它只会在容器启动时运行一次。有些（通常是较旧的）应用程序在容器中启动时可能需要很长时间，因此通过在容器首次启动时提供一些额外的宽限期，您可以避免存活探针或准备就绪探针失败，从而导致重启。以下是配置了启动探针的Pod示例：
- en: pod-with-startup-probe.yaml
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-startup-probe.yaml
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Startup probes provide a benefit greater than simply extending the time between
    liveness or readiness probes – they allow Kubernetes to maintain a quick reaction
    time when addressing problems that happen after startup and (more importantly)
    to prevent slow-starting applications from restarting constantly. If your application
    takes many seconds or even a minute or two to start up, you will have a much easier
    time implementing a startup probe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 启动探针提供的好处不仅仅是延长存活性探针或就绪探针之间的时间——它们还可以让 Kubernetes 在解决启动后发生的问题时保持快速反应（更重要的是）并防止启动缓慢的应用程序不断重启。如果你的应用程序启动需要很多秒，甚至一两分钟，你将更容易实现启动探针。
- en: '`successThreshold` is just what it seems, the opposite side of the coin to
    `failureThreshold`. It specifies how many successes in a row are required before
    a container is marked `Ready`. For applications that can go up and down on startup
    before stabilizing (like some self-clustering applications), changing this value
    can be useful. The default is `1`, and for liveness probes the only possible value
    is `1`, but we can change the value for readiness and startup probes.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`successThreshold` 就是字面意思，它是与 `failureThreshold` 对应的另一面。它指定容器被标记为 `Ready` 之前需要连续多少次成功。对于那些在启动时可能会波动直到稳定的应用程序（例如某些自我集群化应用程序），更改此值可能会很有用。默认值是
    `1`，对于存活性探针，唯一的可能值是 `1`，但是我们可以更改就绪探针和启动探针的值。'
- en: Probe mechanism configuration
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探针机制配置
- en: 'There are multiple mechanisms to specify any of the three probes: `exec`, `httpGet`,
    and `tcpSocket`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种机制可以指定三种探针之一：`exec`、`httpGet` 和 `tcpSocket`。
- en: The `exec` method allows you to specify a command that will be run inside the
    container. A successfully executed command will result in a passed probe, while
    a command that fails will result in a fail on the probe. All the probes we've
    configured so far have used the `exec` method, so configuration should be self-evident.
    If the chosen command (with any arguments specified in comma-separated list form)
    fails, the probe will fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 方法允许你指定一个将在容器内运行的命令。成功执行的命令将导致探针通过，而失败的命令将导致探针失败。到目前为止，我们配置的所有探针都使用了
    `exec` 方法，因此配置应该是显而易见的。如果所选命令（带有以逗号分隔的参数列表）失败，则探针将失败。'
- en: The `httpGet` method for probes allows you to specify a URL on the container
    that will be hit with an HTTP `GET` request. If the HTTP request returns a code
    anywhere between `200` to `400`, it will result in a success on the probe. Any
    other HTTP code will result in a failure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpGet` 方法允许你指定一个容器上的 URL，该 URL 将通过 HTTP `GET` 请求访问。如果 HTTP 请求返回的状态码在 `200`
    到 `400` 之间，则探针成功。任何其他 HTTP 状态码都将导致探针失败。'
- en: 'The configuration for `httpGet` looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpGet` 的配置如下所示：'
- en: pod-with-get-probe.yaml
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-get-probe.yaml
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the `tcpSocket` method will try to open the specified socket on the
    container and will use the result to dictate a success or failure. The `tcpSocket`
    configuration looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`tcpSocket` 方法将尝试打开容器上指定的套接字，并使用结果来决定探针的成功或失败。`tcpSocket` 的配置如下所示：
- en: pod-with-tcp-probe.yaml
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-tcp-probe.yaml
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this type of probe takes in a port, which will be pinged every
    time the check occurs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种类型的探针需要一个端口，每次检查发生时都会对该端口进行 ping 操作。
- en: Common Pod transitions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的 Pod 状态转换
- en: 'Failing Pods in Kubernetes tend to transition between statuses quite a bit.
    For a first-time user, this can be intimidating, so it is valuable to break down
    how the Pod statuses we listed earlier interact with probe functionality. Just
    to reiterate, here are our statuses:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，失败的 Pod 往往会频繁地在状态之间转换。对于第一次使用者来说，这可能会令人感到困惑，因此将 Pod 状态与探针功能之间的互动分解开来是很有价值的。再次重申，以下是我们的状态：
- en: '`Running`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行中`'
- en: '`Succeeded`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`成功`'
- en: '`Pending`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`待处理`'
- en: '`Unknown`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未知`'
- en: '`Failed`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`失败`'
- en: A common flow is to run `kubectl get pods -w` (the `-w` flag adds a watch to
    the command) and see offending Pods transitioning between `Pending` and `Failed`.
    Typically, what is occurring is that the Pods (and their containers) are spinning
    up and pulling images – which is the `Pending` state since the health checks have
    not yet started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的流程是运行 `kubectl get pods -w`（`-w` 标志为命令添加监视功能），并查看有问题的 Pod 在 `待处理` 和 `失败`
    之间转换。通常，发生的情况是 Pod（及其容器）正在启动并拉取镜像——这就是 `待处理` 状态，因为健康检查尚未开始。
- en: Once the initial probe timeout (which as we saw in the previous section is configurable)
    elapses, the first probe fails. This can continue for seconds or even minutes
    depending on how high the failure threshold is, with the status still pinned at
    `Pending`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始探测超时（正如我们在前一节中看到的可配置的），第一个探测失败。这可能持续几秒钟甚至几分钟，具体取决于失败阈值设置的高低，状态仍然固定在`Pending`。
- en: Finally, our failure threshold is reached, and our Pod status transitions to
    `Failed`. At this point, one of two things can happen, and the decision is based
    purely on the `RestartPolicy` on the PodSpec, which can either be `Always`, `Never`,
    or `OnFailure`. If a Pod fails and the `restartPolicy` is `Never`, the Pod will
    stay in the failed status. If it is one of the other two options, the Pod will
    restart automatically, and go back to `Pending`, which is the root cause of our
    never-ending transition cycle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们达到了失败阈值，我们的 Pod 状态转为`Failed`。此时，会有两种可能发生，决策完全基于 PodSpec 中的 `RestartPolicy`，可以是`Always`、`Never`或者`OnFailure`。如果
    Pod 失败且`restartPolicy`为`Never`，则 Pod 将保持在失败状态。如果是其他两个选项之一，Pod 将自动重启，并返回到`Pending`状态，这就是我们永无止境的过渡循环的根本原因。
- en: For a different example, you may see Pods stuck forever in the `Pending` status.
    This can be due to the Pod failing to be scheduled on any node. This could be
    due to resource request constraints (which we will cover in depth later in this
    book, in [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186), *Pod Placement
    Controls*), or other issues such as nodes being unreachable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为不同的例子，您可能会看到 Pod 永远停留在`Pending`状态。这可能是因为 Pod 无法在任何节点上调度。这可能是由于资源请求约束（我们将在本书后面深入介绍，在[*第
    8 章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中的*Pod 放置控制*），或其他问题，比如节点无法访问。
- en: Finally, with `Unknown`, typically the node that the Pod is scheduled on is
    unreachable for some reason – the node might have shut down, for instance, or
    is unreachable via the network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`Unknown`状态，通常 Pod 被调度的节点由于某些原因无法访问 – 比如节点可能已关闭，或通过网络无法访问。
- en: Pod scheduling
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod 调度
- en: The complexities of Pod scheduling and the ways the Kubernetes lets you influence
    and control it will be saved for our [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls* – but for now we will review the basics.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 调度的复杂性以及 Kubernetes 允许您影响和控制它的方式将保存在我们的[*第 8 章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中的*Pod
    放置控制*中，但现在我们将回顾基础知识。
- en: When deciding where to schedule a Pod, Kubernetes takes many factors into account,
    but the most important to consider (when not delving into the more complex controls
    that Kubernetes lets us use) are Pod priority, node availability, and resource
    availability.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定在哪里调度一个 Pod 时，Kubernetes 考虑了许多因素，但最重要的是要考虑（当不涉及 Kubernetes 允许我们使用的更复杂控制时）Pod
    优先级、节点可用性和资源可用性。
- en: The Kubernetes scheduler operates a constant control loop that monitors the
    cluster for unbound (unscheduled) Pods. If one or more unbound Pods is found,
    the scheduler will use the Pod priority to decide which one to schedule first.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 调度器运行一个常量控制循环，监视集群中未绑定（未调度）的 Pod。如果找到一个或多个未绑定的 Pod，调度器将使用 Pod 优先级来决定首先调度哪一个。
- en: Once the scheduler has decided on a Pod to schedule, it will perform several
    rounds and types of checks in order to find the local optima of a node for where
    to schedule the Pod. The latter rounds of checks are dictated by granular scheduling
    controls, which we'll get into in the [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*. We'll worry about the first couple of checks for now.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调度程序决定要调度一个 Pod，它将执行多轮和类型的检查，以找到调度 Pod 的节点的局部最优解。后面的检查轮次由精细的调度控制指导，我们稍后会深入探讨在[*第
    8 章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中的*Pod 放置控制*。现在，我们先担心前几轮的检查。
- en: First, Kubernetes checks to see which nodes are even schedulable at the current
    moment. Nodes may be non-functioning or otherwise encountering issues that would
    prevent new Pods from being scheduled.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kubernetes 检查当前时间哪些节点是可调度的。节点可能是不工作或者遇到其他问题，这将阻止新的 Pod 被调度。
- en: Secondly, Kubernetes filters schedulable nodes by checking to see which of those
    nodes match the minimum resource requirement stated in the PodSpec.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Kubernetes 通过检查哪些节点与 PodSpec 中声明的最小资源需求匹配，来筛选可调度的节点。
- en: At this point, in the absence of any other placement controls, the scheduler
    will make its decision and assign our new Pod to a node. When the `kubelet` on
    that node sees that it has a new Pod assigned to it, the Pod will be spun up.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，在缺乏任何其他放置控制的情况下，调度器将做出决策并将我们的新 Pod 分配给一个节点。当该节点上的 `kubelet` 看到它分配了一个新的
    Pod 时，该 Pod 将被启动。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that Pods are the most basic building block we have
    to work with in Kubernetes. It's important to have a strong understanding of Pods
    and all their subtleties because all compute on Kubernetes uses Pods as a building
    block. It's probably pretty obvious by now, but Pods are very small, individual
    things that are not very sturdy. Running an application as a single Pod on Kubernetes
    with no controller is a bad decision, and any issue with your Pod will result
    in downtime.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到 Pods 是我们在 Kubernetes 中处理的最基本的构建块。对 Pods 及其所有微妙之处有深入的理解非常重要，因为在 Kubernetes
    上所有的计算都使用 Pods 作为构建块。现在可能已经很明显了，但 Pods 是非常小、个体化的东西，不是很结实。在 Kubernetes 上以单个 Pod
    运行应用程序而没有控制器是一个糟糕的决定，你的 Pod 出现任何问题都会导致停机。
- en: In the next chapter, we'll see how to prevent this by using Pod controllers
    to run multiple replicas of an application at once.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过使用 Pod 控制器一次运行多个应用程序副本来防止这种情况发生。
- en: Questions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How could you use namespaces to separate application environments?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用命名空间来分隔应用程序环境？
- en: What is a possible reason for a Pod status to be listed as `Unknown`?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pod 状态显示为 `Unknown` 的可能原因是什么？
- en: What could be a reason for constraining Pod memory resources?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制 Pod 内存资源的原因可能是什么？
- en: If an application running on Kubernetes often does not start in time before
    a failed probe restarts the Pod, which probe type should you tune? Readiness,
    liveness, or startup?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行在 Kubernetes 上的应用程序经常在失败的探测重启 Pod 之前无法及时启动，你应该调整哪种探测类型？就绪性、存活性还是启动？
- en: Further reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 官方文档：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes 逆天之路*：[https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
