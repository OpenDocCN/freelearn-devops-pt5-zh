- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Data Volumes and Configuration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据卷和配置
- en: In the previous chapter, we learned how to build and share our container images.
    Focus was placed on how to build images that are as small as possible by only
    containing artifacts that are needed by the containerized application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何构建和共享我们的容器镜像。重点放在如何构建尽可能小的镜像，只包含容器化应用程序所需的工件。
- en: In this chapter, we are going to learn how we can work with stateful containers
    – that is, containers that consume and produce data. We will also learn how to
    configure our containers at runtime and at image build time, using environment
    variables and config files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用有状态容器——即那些消耗和生成数据的容器。我们还将学习如何在运行时和镜像构建时，通过使用环境变量和配置文件来配置容器。
- en: 'Here is a list of the topics we’re going to discuss:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将讨论的主题列表：
- en: Creating and mounting data volumes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和挂载数据卷
- en: Sharing data between containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器之间的数据共享
- en: Using host volumes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机卷
- en: Defining volumes in images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义图像中的卷
- en: Configuring containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置容器
- en: 'After working through this chapter, you will be able to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容后，您将能够执行以下操作：
- en: Create, delete, and list data volumes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、删除和列出数据卷
- en: Mount an existing data volume into a container
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有数据卷挂载到容器中
- en: Create durable data from within a container using a data volume
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷从容器内部创建持久数据
- en: Share data between multiple containers using data volumes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷在多个容器之间共享数据
- en: Mount any host folder into a container using data volumes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷将任何主机文件夹挂载到容器中
- en: Define the access mode (read/write or read-only) for a container when accessing
    data in a data volume
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问数据卷中的数据时，为容器定义访问模式（读/写或只读）
- en: Configure environment variables for applications running in a container
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置在容器中运行的应用程序的环境变量
- en: Parameterize a Dockerfile by using build arguments
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用构建参数化Dockerfile
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need Docker Desktop installed on your machine. There is
    no code accompanying this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，您需要在机器上安装Docker Desktop。本章没有随附代码。
- en: 'Before we start, we need to create a folder for [*Chapter 5*](B19199_05.xhtml#_idTextAnchor109)
    inside our code repository:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要在代码库中为[*第5章*](B19199_05.xhtml#_idTextAnchor109)创建一个文件夹：
- en: 'Use this command to navigate to the folder where you checked out the code from
    GitHub:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令导航到您从GitHub检出代码的文件夹：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you did not check out the GitHub repository at the default location, the
    preceding command may vary for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有在默认位置检出GitHub仓库，则前面的命令可能会有所不同。
- en: 'Create a sub-folder for [*Chapter 5*](B19199_05.xhtml#_idTextAnchor109) and
    navigate to it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[*第5章*](B19199_05.xhtml#_idTextAnchor109)创建一个子文件夹并进入该文件夹：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s get started!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating and mounting data volumes
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和挂载数据卷
- en: All meaningful applications consume or produce data. Yet containers are, ideally,
    meant to be stateless. How are we going to deal with this? One way is to use Docker
    volumes. Volumes allow containers to consume, produce, and modify a state. Volumes
    have a life cycle that goes beyond the life cycle of containers. When a container
    that uses a volume dies, the volume continues to exist. This is great for the
    durability of the state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有意义的应用程序都消耗或生成数据。然而，理想情况下，容器应该是无状态的。我们该如何处理这个问题呢？一种方法是使用Docker卷。卷允许容器消耗、生成和修改状态。卷的生命周期超出了容器的生命周期。当使用卷的容器终止时，卷仍然存在。这对状态的持久性非常有利。
- en: Modifying the container layer
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改容器层
- en: 'Before we dive into volumes, let’s first discuss what happens if an application
    in a container changes something in the filesystem of the container. In this case,
    the changes are all happening in the writable container layer that we introduced
    in [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083), *Creating and Managing Container
    Images*. Let’s quickly demonstrate this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论卷之前，先来讨论一下如果容器中的应用程序更改了容器文件系统中的某些内容会发生什么。在这种情况下，所有的更改都发生在我们在[*第4章*](B19199_04.xhtml#_idTextAnchor083)中介绍的可写容器层中，*创建和管理容器镜像*。让我们快速演示一下：
- en: 'Run a container and execute a script in it that is creating a new file, like
    this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个容器并在其中执行一个脚本，脚本创建一个新文件，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command creates a container named `demo`, and, inside this container,
    creates a file called `sample.txt` with the content `This is a test`. The container
    exits after running the `echo` command but remains in memory, available for us
    to do our investigations.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令创建了一个名为 `demo` 的容器，并在该容器内创建了一个名为 `sample.txt` 的文件，文件内容为 `This is a test`。容器在执行
    `echo` 命令后退出，但仍保留在内存中，供我们进行调查。
- en: 'Let’s use the `diff` command to find out what has changed in the container’s
    filesystem concerning the filesystem of the original image, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `diff` 命令，找出与原始镜像的文件系统相比，容器的文件系统发生了哪些变化，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于下图所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A new file, as indicated by the letter `A`, has been added to the filesystem
    of the container, as expected. Since all layers that stem from the underlying
    image (Alpine, in this case) are immutable, the change could only happen in the
    writeable container layer.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新文件，如字母 `A` 所示，已被添加到容器的文件系统中，这符合预期。由于所有来自底层镜像（在本例中为 Alpine）的层都是不可变的，更改只能发生在可写的容器层中。
- en: Files that have changed compared to the original image will be marked with a
    `C` and those that have been deleted with a `D`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始镜像相比发生变化的文件将标记为 `C`，而被删除的文件将标记为 `D`。
- en: Now, if we remove the container from memory, its container layer will also be
    removed, and with it, all the changes will be irreversibly deleted. If we need
    our changes to persist even beyond the lifetime of the container, this is not
    a solution. Luckily, we have better options, in the form of Docker volumes. Let’s
    get to know them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从内存中移除容器，它的容器层也会被删除，所有的更改将不可逆地丢失。如果我们希望我们的更改能够持续存在，即使容器已经被销毁，这就不是一个解决方案。幸运的是，我们有更好的选择，那就是
    Docker 卷。让我们来了解一下它们。
- en: Creating volumes
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建卷
- en: When using Docker Desktop on a macOS or Windows computer, containers are not
    running natively on macOS or Windows but rather in a (hidden) VM created by Docker
    Desktop.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 macOS 或 Windows 计算机上使用 Docker Desktop 时，容器并不是直接在 macOS 或 Windows 上运行，而是在
    Docker Desktop 创建的（隐藏的）虚拟机中运行。
- en: To demonstrate how and where the underlying data structures are created in the
    respective filesystem (macOS or Windows), we need to be a bit creative. If, on
    the other hand, we are doing the same on a Linux computer, things are straightforward.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示底层数据结构是如何以及在何处创建到相应的文件系统（macOS 或 Windows）中的，我们需要发挥一些创造力。另一方面，如果我们在 Linux
    计算机上做相同的事情，一切都会简单直接。
- en: 'Let’s start with a simple exercise to create a volume:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先做一个简单的练习来创建一个卷：
- en: 'Open a new Terminal window and type in this command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并输入以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get this response:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到这样的响应：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the name of the created volume will be the output.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建的卷的名称将是输出内容。
- en: The default volume driver is the so-called **local driver**, which stores the
    data locally in the host filesystem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的卷驱动程序是所谓的**本地驱动程序**，它将数据存储在主机文件系统中。
- en: 'The easiest way to find out where the data is stored on the host is by using
    the `docker volume inspect` command on the volume we just created. The actual
    location can differ from system to system, so this is the safest way to find the
    target folder. So, let’s use this command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找数据在主机上存储位置的最简单方法是使用 `docker volume inspect` 命令检查我们刚创建的卷。实际位置可能因系统而异，因此这是找到目标文件夹的最安全方法。让我们使用这个命令：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should see something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似这样的内容：
- en: '![Figure 5.1 – Inspecting the Docker volume called sample](img/B19199_05_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 检查名为 sample 的 Docker 卷](img/B19199_05_01.jpg)'
- en: Figure 5.1 – Inspecting the Docker volume called sample
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 检查名为 sample 的 Docker 卷
- en: The host folder can be found in the output under `Mountpoint`. In our case,
    the folder is `/var/lib/docker/volumes/sample/_data`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主机文件夹可以在输出中的 `Mountpoint` 下找到。在我们的例子中，文件夹是 `/var/lib/docker/volumes/sample/_data`。
- en: 'Alternatively, we can create a volume using the dashboard of Docker Desktop:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，我们可以通过 Docker Desktop 的仪表板来创建卷：
- en: Open the Dashboard of Docker Desktop.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Docker Desktop 的仪表板。
- en: On the left-hand side, select the **Volumes** tab.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，选择 **Volumes** 标签。
- en: 'In the top-right corner, click the **Create** button, as shown in the following
    screenshot:'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角，点击 **Create** 按钮，如下图所示：
- en: '![Figure 5.2 – Creating a new Docker volume with Docker Desktop](img/B19199_05_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 使用 Docker Desktop 创建一个新的 Docker 卷](img/B19199_05_02.jpg)'
- en: Figure 5.2 – Creating a new Docker volume with Docker Desktop
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 使用 Docker Desktop 创建一个新的 Docker 卷
- en: 'Type in `sample-2` as the name for the new volume and click **Create**. You
    should now see this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`sample-2`作为新卷的名称，并点击**创建**。你现在应该看到这个：
- en: '![Figure 5.3 – List of Docker volumes shown in Docker Desktop](img/B19199_05_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 在 Docker Desktop 中显示的 Docker 卷列表](img/B19199_05_03.jpg)'
- en: Figure 5.3 – List of Docker volumes shown in Docker Desktop
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 在 Docker Desktop 中显示的 Docker 卷列表
- en: There are other volume drivers available from third parties, in the form of
    plugins. We can use the `--driver` parameter in the `create` command to select
    a different volume driver.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些第三方的卷驱动程序，以插件的形式提供。我们可以在`create`命令中使用`--driver`参数来选择不同的卷驱动程序。
- en: Other volume drivers use different types of storage systems to back a volume,
    such as cloud storage, **Network File System** (**NFS**) drives, software-defined
    storage, and more. The discussion of the correct usage of other volume drivers
    is beyond the scope of this book, though.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他卷驱动程序使用不同类型的存储系统来支持卷，比如云存储、**网络文件系统**（**NFS**）驱动、软件定义存储等。不过，其他卷驱动程序的正确使用讨论超出了本书的范围。
- en: Mounting a volume
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载卷
- en: 'Once we have created a named volume, we can mount it into a container by following
    these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个命名卷，我们可以通过以下步骤将其挂载到容器中：
- en: 'For this, we can use the `--volume` or `-v` parameter in the `docker container
    run` command, like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们可以在`docker container run`命令中使用`--volume`或`-v`参数，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you are working on a clean Docker environment, then the output produced
    by this command should look similar to this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个干净的 Docker 环境中工作，那么此命令生成的输出应该类似于这个：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Otherwise, you should just see the prompt of the Bourne shell running inside
    the Alpine container:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你应该只会看到运行在 Alpine 容器中的 Bourne shell 提示符：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding command mounts the sample volume to the `/data` folder inside
    the container.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将示例卷挂载到容器内的`/data`文件夹。
- en: 'Inside the container, we can now create files in the `/data` folder, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内，我们现在可以在`/data`文件夹中创建文件，如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we were to navigate to the host folder that contains the data of the volume
    and list its content, we should see the two files we just created inside the container.
    But this is a bit more involved so long as we are working on a Mac or Windows
    computer and will be explained in detail in the *Accessing Docker volumes* section.
    Stay tuned.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们导航到包含该卷数据的主机文件夹并列出其内容，我们应该能够看到容器中刚刚创建的两个文件。但这在 Mac 或 Windows 电脑上会稍微复杂一些，将在*访问
    Docker 卷*一节中详细解释。敬请期待。
- en: Exit the tool container by pressing *Ctrl* + *D*.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *D*退出工具容器。
- en: 'Now, let’s delete the dangling `test` container:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除悬挂的`test`容器：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we must run another one based on CentOS. This time, we are even mounting
    our volume to a different container folder, `/app/data`, like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须基于 CentOS 运行另一个命令。这一次，我们甚至将卷挂载到另一个容器文件夹`/app/data`，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see an output similar to this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于这样的输出：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last line of the preceding output indicates that we are at the prompt of
    the Bash shell running inside the CentOS container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出的最后一行表明我们处于运行在 CentOS 容器中的 Bash shell 提示符下。
- en: 'Once inside the CentOS container, we can navigate to the `/app/data` folder
    to which we have mounted the volume and list its content, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入 CentOS 容器，我们可以导航到我们已挂载卷的`/app/data`文件夹，并列出其内容，如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As expected, we should see these two files:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们应该看到这两个文件：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the definitive proof that data in a Docker volume persists beyond the
    lifetime of a container, as well as that volumes can be reused by other, even
    different, containers from the one that used it first.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数据在 Docker 卷中持久化超出容器生命周期的决定性证据，此外，卷可以被其他容器（甚至与第一个使用它的容器不同的容器）重复使用。
- en: It is important to note that the folder inside the container to which we mount
    a Docker volume is excluded from the Union filesystem. That is, each change inside
    this folder and any of its subfolders will not be part of the container layer
    but will be persisted in the backing storage provided by the volume driver. This
    fact is really important since the container layer is deleted when the corresponding
    container is stopped and removed from the system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们在容器中挂载 Docker 卷的文件夹被排除在联合文件系统之外。也就是说，任何在此文件夹及其子文件夹中的更改都不会成为容器层的一部分，而是会被持久化到由卷驱动程序提供的支持存储中。这一点非常重要，因为当容器停止并从系统中删除时，容器层会被删除。
- en: Exit the CentOS container with *Ctr*l + *D*.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*退出 CentOS 容器。
- en: Great – we have learned how to mount Docker volumes into a container! Next,
    we will learn how to delete existing volumes from our system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们已经学会了如何将 Docker 卷挂载到容器中！接下来，我们将学习如何从系统中删除现有的卷。
- en: Removing volumes
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除卷
- en: 'Volumes can be removed using the `docker volume rm` command. It is important
    to remember that removing a volume destroys the containing data irreversibly,
    and thus is to be considered a dangerous command. Docker helps us a bit in this
    regard, as it does not allow us to delete a volume that is still in use by a container.
    Always make sure before you remove or delete a volume that you either have a backup
    of its data or you don’t need this data anymore. Let’s learn how to remove volumes
    by following these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以使用 `docker volume rm` 命令删除。重要的是要记住，删除卷会不可逆地销毁其中的所有数据，因此这是一个危险命令。在这方面，Docker
    给我们提供了一些帮助，因为它不允许我们删除正在被容器使用的卷。始终确保在删除或移除卷之前，要么备份好其中的数据，要么确认不再需要这些数据。接下来，让我们按照以下步骤学习如何删除卷：
- en: 'The following command deletes the sample volume that we created earlier:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令删除我们之前创建的示例卷：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After executing the preceding command, double-check that the folder on the
    host has been deleted. You can use this command to list all volumes defined on
    your system:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面的命令后，请再次确认主机上的文件夹是否已删除。你可以使用以下命令列出系统上定义的所有卷：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure the `sample` volume has been deleted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `sample` 卷已经被删除。
- en: Now, also remove the `sample-2` volume from your system.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，亦请从系统中删除 `sample-2` 卷。
- en: 'To remove all running containers to clean up the system, run the following
    command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除所有正在运行的容器以清理系统，请运行以下命令：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that by using the `-v` or `--volume` flag in the command you use to remove
    a container, you can ask the system to also remove any anonymous volume associated
    with that particular container. Of course, that will only work if the particular
    volume is only used by this container.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，使用 `-v` 或 `--volume` 标志在移除容器时，可以要求系统同时删除与该容器关联的匿名卷。当然，这只有在该卷仅被该容器使用时才有效。
- en: In the next section, we will show you how to access the backing folder of a
    volume when working with Docker Desktop.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将展示如何在使用 Docker Desktop 时访问卷的底层文件夹。
- en: Accessing Docker volumes
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 Docker 卷
- en: 'Now, let’s for a moment assume that we are on a Mac with macOS. This operating
    system is not based on Linux but on a different Unix flavor. Let’s see whether
    we can find the data structure for the `sample` and `sample-2` volumes, where
    the `docker volume inspect` command told us so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们正在使用 macOS 操作系统。这个操作系统不是基于 Linux，而是基于其他 Unix 变种。让我们看看是否能找到 `sample`
    和 `sample-2` 卷的数据结构，正如 `docker volume inspect` 命令告诉我们的那样：
- en: 'First, let’s create two named Docker volumes, either using the command line
    or doing the same via the dashboard of Docker Desktop:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建两个命名的 Docker 卷，可以使用命令行或通过 Docker Desktop 仪表板执行相同的操作：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In your Terminal, try to navigate to that folder:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中，尝试导航到该文件夹：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the author’s MacBook Air, this is the response to the preceding command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的 MacBook Air 上，执行前面的命令后返回了以下响应：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This was expected since Docker is not running natively on Mac but inside a slim
    VM, as mentioned earlier in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 并非在 Mac 上本地运行，而是运行在一个精简的虚拟机内，正如本章前面提到的，因此这种情况是可以预期的。
- en: Similarly, if you are using a Windows machine, you won’t find the data where
    the `inspect` command indicated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你使用的是 Windows 机器，你将无法在 `inspect` 命令所指示的位置找到数据。
- en: It turns out that on a Mac, the data for the VM that Docker creates can be found
    in the `~/``Library/Containers/com.docker.docker/Data/vms/0` folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，在 Mac 上，Docker 创建的虚拟机的数据可以在 `~/Library/Containers/com.docker.docker/Data/vms/0`
    文件夹中找到。
- en: To access this data, we need to somehow get into this VM. On a Mac, we have
    two options to do so. The first is to use the `terminal screen` command. However,
    this is very specific to macOS and thus we will not discuss it here. The second
    option is to get access to the filesystem of Docker on Mac via the special `nsenter`
    command, which should be executed inside a Linux container such as Debian. This
    also works on Windows, and thus we will show the steps needed using this second
    option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这些数据，我们需要以某种方式进入这个虚拟机。在 Mac 上，我们有两种方式可以实现。第一种是使用 `terminal screen` 命令，但这非常特定于
    macOS，因此我们在这里不讨论。第二种方式是通过特殊的 `nsenter` 命令访问 Mac 上 Docker 的文件系统，该命令应在 Linux 容器（如
    Debian）内执行。这在 Windows 上也有效，因此我们将展示使用第二种方式所需的步骤。
- en: 'To run a container that can inspect the underlying host filesystem on your
    system, use this command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行一个可以检查系统上底层主机文件系统的容器，请使用以下命令：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When running the container, we execute the following command inside the container:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器时，我们在容器内执行以下命令：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If that sounds complicated to you, don’t worry; you will understand more as
    we proceed through this book. If there is one takeaway, then it is to realize
    how powerful the right use of containers can be.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，不用担心；随着我们继续阅读这本书，你会逐渐明白。如果有一个要记住的要点，那就是要意识到正确使用容器有多么强大。
- en: 'From within this container, we can now list all the volumes that are defined
    with `/ # ls -l /var/lib/docker/volumes`. What we get should look similar to this:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在这个容器中，我们现在可以列出所有定义的卷，使用`/ # ls -l /var/lib/docker/volumes`。我们得到的结果应该类似于此：'
- en: '![Figure 5.4 – List of Docker volumes via nsenter](img/B19199_05_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 通过nsenter列出Docker卷](img/B19199_05_04.jpg)'
- en: Figure 5.4 – List of Docker volumes via nsenter
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 通过nsenter列出Docker卷
- en: 'Next, navigate to the folder representing the mount point of the volume:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到表示卷挂载点的文件夹：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And then list its content, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后列出其内容，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This should output the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出如下内容：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The folder is currently empty since we have not yet stored any data in the volume.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹目前是空的，因为我们还没有在卷中存储任何数据。
- en: 'Similarly, for our `sample-2` volume, we can use the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，对于我们的`sample-2`卷，我们可以使用以下命令：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should output the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出如下内容：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, this indicates that the folder is currently empty.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这表示文件夹目前是空的。
- en: Next, let’s generate two files with data in the `sample` volume from within
    an Alpine container. First, open a new Terminal window, since the other one is
    blocked by our `nsenter` session.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们从Alpine容器中在`sample`卷中生成两个带数据的文件。首先，打开一个新的终端窗口，因为另一个窗口被我们的`nsenter`会话阻塞。
- en: 'To run the container and mount the `sample` volume to the `/data` folder of
    the container, use the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行容器并将`sample`卷挂载到容器的`/data`文件夹中，请使用以下代码：
- en: '[PRE30]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Generate two files in the `/data` folder inside the container, like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内的`/data`文件夹中生成两个文件，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exit the Alpine container by pressing *Ctrl* + *D*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *D*退出Alpine容器。
- en: 'Back in the `nsenter` session, try to list the content of the sample volume
    again using this command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`nsenter`会话，使用以下命令再次尝试列出示例卷的内容：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time, you should see this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你应该看到如下内容：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This indicates that we have data written to the filesystem of the host.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们已将数据写入主机的文件系统。
- en: 'Let’s try to create a file from within this special container, and then list
    the content of the folder, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在这个特殊容器中创建一个文件，然后列出文件夹的内容，如下所示：
- en: '[PRE34]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s see what we got:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们得到了什么：
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This gives us something like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了类似于这样的结果：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s see whether we can see this new file from within a container mounting
    the sample volume. From within a new Terminal window, run this command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看能否从挂载示例卷的容器中看到这个新文件。在一个新的终端窗口中运行此命令：
- en: '[PRE37]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That should output this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出如下内容：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding output is showing us that we can add content directly to the host
    folder backing the volume and then access it from a container that has the volume
    mounted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示我们可以直接向支持卷的主机文件夹添加内容，然后从挂载该卷的容器中访问它。
- en: To exit our special privileged container with the `nsenter` tool, we can just
    press *Ctrl* + *D* twice.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出我们的特殊特权容器，可以按*Ctrl* + *D*两次。
- en: 'We have now created data using two different methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用两种不同的方法创建了数据：
- en: From within a container that has a sample volume mounted
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个挂载了示例卷的容器中
- en: Using a special privileged folder to access the hidden VM used by Docker Desktop,
    and directly writing into the backing folder of the sample volume
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊特权文件夹访问Docker Desktop使用的隐藏虚拟机，并直接写入示例卷的后备文件夹
- en: In the next section, we will learn how to share data between containers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习如何在容器之间共享数据。
- en: Sharing data between containers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器之间共享数据
- en: Containers are like sandboxes for the applications running inside them. This
    is mostly beneficial and wanted, to protect applications running in different
    containers from each other. It also means that the whole filesystem visible to
    an application running inside a container is private to this application, and
    no other application running in a different container can interfere with it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 容器就像是运行在其中的应用程序的沙盒。这大多数时候是有益的并且是我们期望的，它可以保护运行在不同容器中的应用程序相互隔离。它还意味着，容器内应用程序可见的整个文件系统对于该应用程序来说是私有的，其他运行在不同容器中的应用程序无法干扰它。
- en: At times, though, we want to share data between containers. Say an application
    running in **container A** produces some data that will be consumed by another
    application running in **container B**. How can we achieve this? Well, I’m sure
    you’ve already guessed it – we can use Docker volumes for this purpose. We can
    create a volume and mount it to container A, as well as to container B. In this
    way, both applications A and B have access to the same data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们希望在容器之间共享数据。比如，运行在**容器 A**中的应用程序生成了一些数据，而这些数据将被运行在**容器 B**中的另一个应用程序使用。我们如何实现这个目标呢？我相信你已经猜到了——我们可以为此目的使用
    Docker 卷。我们可以创建一个卷并将其挂载到容器 A，以及容器 B。这样，应用程序 A 和 B 都可以访问相同的数据。
- en: Now, as always when multiple applications or processes concurrently access data,
    we have to be very careful to avoid inconsistencies. To avoid concurrency problems
    such as race conditions, we should ideally have only one application or process
    that is creating or modifying data, while all other processes concurrently accessing
    this data only read it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如每次多个应用程序或进程同时访问数据时一样，我们必须非常小心，以避免数据不一致。为了避免并发问题，如竞争条件，理想情况下我们应该只有一个应用程序或进程在创建或修改数据，而所有其他并发访问这些数据的进程只能读取它。
- en: Race condition
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件
- en: A race condition is a situation that can occur in computer programming when
    the output of a program or process is affected by the order and timing of events
    in ways that are unpredictable or unexpected. In a race condition, two or more
    parts of a program are trying to access or modify the same data or resource simultaneously,
    and the outcome depends on the timing of these events. This can result in incorrect
    or inconsistent output, errors, or crashes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件是计算机编程中可能发生的一种情况，当程序或进程的输出受到事件的顺序和时机的影响，以一种不可预测或意外的方式。在竞争条件中，程序的两个或多个部分同时尝试访问或修改相同的数据或资源，结果取决于这些事件的时机。这可能导致不正确或不一致的输出、错误或崩溃。
- en: 'We can enforce a process running in a container to only be able to read the
    data in a volume by mounting this volume as read-only. Here’s how we can do this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制容器内的进程只能读取卷中的数据，通过将该卷挂载为只读模式。下面是我们如何做到这一点：
- en: 'Execute the following command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are creating a container called `writer` that has a volume, `shared-data`,
    mounted in default read/write mode.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`writer`的容器，并在默认的读写模式下挂载了一个卷`shared-data`。
- en: 'Try to create a file inside this container, like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在此容器中创建一个文件，像这样：
- en: '[PRE40]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It should succeed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该成功。
- en: Exit this container by pressing *Ctrl* + *D* or typing `exit` and hitting the
    *Enter* key at the prompt.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *D* 或输入`exit`并按*Enter*键退出此容器。
- en: 'Then, execute the following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，执行以下命令：
- en: '[PRE41]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here we have a container called `reader` that has the same volume mounted as
    **read-only** (**ro**).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个名为`reader`的容器，它将相同的卷挂载为**只读**（**ro**）。
- en: 'First, make sure you can see the file created in the first container, like
    this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保你可以在第一个容器中看到创建的文件，像这样：
- en: '[PRE42]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This should give you something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你类似这样的结果：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, try to create a file, like this:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试创建一个文件，像这样：
- en: '[PRE44]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It will fail with the following message:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它将失败，并显示以下消息：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is expected since the volume was mounted as read-only.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为该卷被挂载为只读模式。
- en: 'Let’s exit the container by typing `exit` at the command prompt. Back on the
    host, let’s clean up all containers and volumes, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在命令提示符下输入`exit`来退出容器。回到主机后，让我们清理所有容器和卷，如下所示：
- en: '[PRE46]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Exercise**: Analyze the preceding commands carefully and try to understand
    what exactly they do and how they work.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**：仔细分析之前的命令，尝试理解它们到底做了什么以及如何工作。'
- en: Next, we will show you how to mount arbitrary folders from the Docker host into
    a container.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何将来自 Docker 主机的任意文件夹挂载到容器中。
- en: Using host volumes
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机卷
- en: 'In certain scenarios, such as when developing new containerized applications
    or when a containerized application needs to consume data from a certain folder
    produced – say, by a legacy application – it is very helpful to use volumes that
    mount a specific host folder. Let’s look at the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，例如开发新的容器化应用程序或当容器化应用程序需要使用某个特定文件夹中的数据（例如由遗留应用程序生成的数据）时，使用挂载特定主机文件夹的卷非常有用。让我们来看以下示例：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding expression interactively starts an Alpine container with a shell
    and mounts the `src` subfolder of the current directory into the container at
    `/app/src`. We need to use `$(pwd)` (or `pwd`, for that matter), which is the
    current directory, as when working with volumes, we always need to use absolute
    paths.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式交互式地启动一个带有shell的Alpine容器，并将当前目录中的`src`子文件夹挂载到容器的`/app/src`目录。我们需要使用`$(pwd)`（或者`pwd`），即当前目录，因为在使用卷时，我们始终需要使用绝对路径。
- en: Developers use these techniques all the time when they are working on their
    application that runs in a container and wants to make sure that the container
    always contains the latest changes to the code, without the need to rebuild the
    image and rerun the container after each change.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在工作时经常使用这些技术，尤其是当他们在容器中运行应用程序时，希望确保容器始终包含代码的最新更改，而无需在每次更改后重新构建镜像和重新运行容器。
- en: 'Let’s make a sample to demonstrate how that works. Let’s say we want to create
    a simple static website while using Nginx as our web server, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个示例来展示它是如何工作的。假设我们要创建一个简单的静态网站，并使用Nginx作为我们的Web服务器，如下所示：
- en: 'First, let’s create a new subfolder on the host. The best place to do this
    is inside the chapter folder we created at the beginning of the chapter. There,
    we will put our web assets such as HTML, CSS, and JavaScript files. Use this command
    to create the subfolder and navigate to it:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在主机上创建一个新的子文件夹。最好将它创建在我们在本章开始时创建的章节文件夹中。在那里，我们将放置我们的Web资产，如HTML、CSS和JavaScript文件。使用以下命令来创建子文件夹并导航到它：
- en: '[PRE48]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, create a simple web page, like this:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个简单的网页，像这样：
- en: '[PRE49]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, add a Dockerfile that will contain instructions on how to build the image
    containing our sample website. Add a file called `Dockerfile` to the folder, with
    this content:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个Dockerfile，里面包含构建包含我们示例网站的镜像的指令。向文件夹中添加一个名为`Dockerfile`的文件，并写入以下内容：
- en: '[PRE50]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Dockerfile starts with the latest Alpine version of Nginx and then copies
    all files from the current host directory into the `/usr/share/nginx/html` containers
    folder. This is where Nginx expects web assets to be located.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile从最新的Alpine版本的Nginx开始，然后将当前主机目录中的所有文件复制到容器的`/usr/share/nginx/html`文件夹中。这是Nginx期望Web资产所在的位置。
- en: 'Now, let’s build the image with the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令构建镜像：
- en: '[PRE51]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Please do not forget the period (`.`) at the end of the preceding command.
    The output of this command will look similar to this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要忘记在上面的命令末尾加上句点（`.`）。此命令的输出将类似于以下内容：
- en: '![Figure 5.5 – Building a Docker image for a sample Nginx web server](img/B19199_05_05.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 为示例Nginx Web服务器构建Docker镜像](img/B19199_05_05.jpg)'
- en: Figure 5.5 – Building a Docker image for a sample Nginx web server
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 为示例Nginx Web服务器构建Docker镜像
- en: 'Finally, we will run a container from this image. We will run the container
    in detached mode, like this:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将从这个镜像运行一个容器。我们将以分离模式运行该容器，如下所示：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note the `-p 8080:80` parameter. We haven’t discussed this yet, but we will
    do so in detail in [*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using* *Single-Host
    Networking*. At the moment, just know that this maps the container port `80` on
    which Nginx is listening for incoming requests to port `8080` of your laptop,
    where you can then access the application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`-p 8080:80`参数。我们还没有讨论这个，但我们将在[*第10章*](B19199_10.xhtml#_idTextAnchor218)中详细讲解，*使用*
    *单主机网络*。目前，只需要知道它将Nginx监听传入请求的容器端口`80`映射到你笔记本电脑的`8080`端口，这样你就可以访问应用程序了。
- en: Now, open a browser tab and navigate to `http://localhost:8080/index.xhtml`;
    you should see your website, which currently consists only of a title, **Personal
    Website**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开浏览器标签页并导航到`http://localhost:8080/index.xhtml`；你应该能看到你的网站，目前它只有一个标题，**个人网站**。
- en: 'Now, edit the `index.xhtml` file in your favorite editor so that it looks like
    this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用你最喜欢的编辑器编辑`index.xhtml`文件，使其看起来像这样：
- en: '[PRE53]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, save it, and then refresh the browser. Oh! That didn’t work. The browser
    still displays the previous version of the `index.xhtml` file, which consists
    only of the title. So, let’s stop and remove the current container, then rebuild
    the image and rerun the container, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存并刷新浏览器。哦！那不行。浏览器仍然显示`index.xhtml`文件的上一个版本，只包含标题。所以，让我们停止并删除当前容器，然后重建镜像并重新运行容器，如下所示：
- en: '[PRE54]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Refresh the browser again. This time, the new content should be shown. Well,
    it worked, but there is way too much friction involved. Imagine having to do this
    every time that you make a simple change to your website. That’s not sustainable.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次刷新浏览器。这次，新内容应该会显示出来。好吧，这次行得通了，但过程中的摩擦太大。想象一下，每次对你的网站进行简单更改时都需要这样做。这是不可持续的。
- en: 'Now is the time to use host-mounted volumes. Once again, remove the current
    container and rerun it with the volume mount, like this:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候使用主机挂载的卷了。再次删除当前容器，并使用卷挂载重新运行它，像这样：
- en: '[PRE55]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are working on Windows, a pop-up window will be displayed that says Docker
    wants to access the hard drive and that you have to click on the **Share** **access**
    button.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 上工作，将会显示一个弹出窗口，提示 Docker 需要访问硬盘，你需要点击 **共享** **访问** 按钮。
- en: Now, append some more content to the `index.xhtml` file and save it. Then, refresh
    your browser. You should see the changes. This is exactly what we wanted to achieve;
    we also call this an edit-and-continue experience. You can make as many changes
    in your web files and always immediately see the result in the browser, without
    having to rebuild the image and restart the container containing your website.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将一些内容附加到`index.xhtml`文件中并保存。然后，刷新浏览器。你应该能看到变化。这正是我们想要实现的效果；我们也称之为编辑并继续体验。你可以在网页文件中做任意更改，并立即在浏览器中看到结果，而不需要重新构建镜像或重新启动包含你网站的容器。
- en: 'When you’re done playing with your web server and wish to clean up your system,
    remove the container with the following command:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你玩完你的网页服务器并希望清理系统时，可以使用以下命令删除容器：
- en: '[PRE56]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is important to note that the updates are now propagated bi-directionally.
    If you make changes on the host, they will be propagated to the container, and
    vice versa. It’s also important to note that when you mount the current folder
    into the container target folder, `/usr/share/nginx/html`, the content that is
    already there is replaced by the content of the host folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，现在的更新是双向传播的。如果你在主机上进行更改，它们会传播到容器中，反之亦然。同样重要的是，当你将当前文件夹挂载到容器的目标文件夹`/usr/share/nginx/html`时，已经存在的内容会被主机文件夹的内容替换。
- en: In the next section, we will learn how to define volumes used in a Docker image.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何定义在 Docker 镜像中使用的卷。
- en: Defining volumes in images
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在镜像中定义卷
- en: 'If we go back to what we have learned about containers in [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083),
    *Creating and Managing Container Images*, for more moment, then we have this:
    the filesystem of each container, when started, is made up of the immutable layers
    of the underlying image, plus a writable container layer specific to this very
    container. All changes that the processes running inside the container make to
    the filesystem will be persisted in this container layer. Once the container is
    stopped and removed from the system, the corresponding container layer is deleted
    from the system and irreversibly lost.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下在[*第4章*](B19199_04.xhtml#_idTextAnchor083)《创建与管理容器镜像》中学到的内容，我们会看到：每个容器的文件系统，在启动时，是由基础镜像的不可变层以及特定于该容器的可写容器层组成。容器内运行的进程对文件系统所做的所有更改都会保存在这个容器层中。一旦容器停止并从系统中删除，相应的容器层也会从系统中删除并不可恢复地丢失。
- en: Some applications, such as databases running in containers, need to persist
    their data beyond the lifetime of the container. In this case, they can use volumes.
    To make things a bit more explicit, let’s look at a concrete example. MongoDB
    is a popular open source document database. Many developers use MongoDB as a storage
    service for their applications. The maintainers of MongoDB have created an image
    and published it on Docker Hub, which can be used to run an instance of the database
    in a container. This database will be producing data that needs to be persisted
    long term, but the MongoDB maintainers do not know who uses this image and how
    it is used. So, they can’t influence the `docker container run` command with which
    the users of the database will start this container. So, how can they define volumes?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序，如运行在容器中的数据库，需要将其数据持久化，超出容器的生命周期。在这种情况下，它们可以使用卷。为了更加明确，我们来看一个具体的例子。MongoDB
    是一个流行的开源文档数据库。许多开发者将 MongoDB 作为他们应用程序的存储服务。MongoDB 的维护者创建了一个镜像并发布在 Docker Hub
    上，可以用来在容器中运行数据库实例。这个数据库会产生需要长期持久化的数据，但 MongoDB 的维护者并不知道谁在使用这个镜像以及如何使用它。因此，他们无法影响数据库用户启动容器时使用的
    `docker container run` 命令。那么，他们如何定义卷呢？
- en: 'Luckily, there is a way of defining volumes in the Dockerfile. The keyword
    to do so is `VOLUME`, and we can either add the absolute path to a single folder
    or a comma-separated list of paths. These paths represent the folders of the container’s
    filesystem. Let’s look at a few samples of such volume definitions, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种在 Dockerfile 中定义卷的方法。用于定义卷的关键字是 `VOLUME`，我们可以添加一个单独文件夹的绝对路径，或是一个用逗号分隔的路径列表。这些路径代表容器文件系统中的文件夹。让我们来看几个卷定义的示例，如下所示：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first line in the preceding snippet defines a single volume to be mounted
    at `/app/data`. The second line defines three volumes as a comma-separated list.
    The last one defines the same as the second line, but this time, the value is
    formatted as a JSON array.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码片段中的第一行定义了一个单一卷，并将其挂载到 `/app/data`。第二行定义了三个卷，作为一个逗号分隔的列表。最后一行定义的内容与第二行相同，但这次其值是以
    JSON 数组的格式表示的。
- en: When a container is started, Docker automatically creates a volume and mounts
    it to the corresponding target folder of the container for each path defined in
    the Dockerfile. Since each volume is created automatically by Docker, it will
    have an SHA-256 as its ID.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，Docker 会自动为 Dockerfile 中定义的每个路径创建一个卷，并将其挂载到容器的相应目标文件夹。由于每个卷都是由 Docker
    自动创建的，它将有一个 SHA-256 作为其 ID。
- en: At container runtime, the folders defined as volumes in the Dockerfile are excluded
    from the Union filesystem, and thus any changes in those folders do not change
    the container layer but are persisted to the respective volume. It is now the
    responsibility of the operations engineers to make sure that the backing storage
    of the volumes is properly backed up.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器运行时，Dockerfile 中定义为卷的文件夹将被排除在联合文件系统之外，因此这些文件夹中的任何更改不会影响容器层，而是持久化到相应的卷中。现在，操作工程师的责任是确保卷的后端存储得到了妥善的备份。
- en: 'We can use the `docker image inspect` command to get information about the
    volumes defined in the Dockerfile. Let’s see what MongoDB gives us by following
    these steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker image inspect` 命令来获取 Dockerfile 中定义的卷的信息。让我们通过以下步骤看看 MongoDB
    给我们提供了什么：
- en: 'First, we will pull the image with the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下命令拉取镜像：
- en: '[PRE58]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we will inspect this image, and use the `--format` parameter to only
    extract the essential part from the massive amount of data, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查这个镜像，并使用 `--format` 参数只提取大量数据中的关键部分，如下所示：
- en: '[PRE59]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note `| jq .` at the end of the command. We are piping the output of `docker
    image inspect` into the `jq` tool, which nicely formats the output.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令末尾的 `| jq .`。我们将 `docker image inspect` 的输出通过管道传输到 `jq` 工具，该工具将输出格式化得非常整齐。
- en: Tip
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you haven’t installed `jq` yet on your system, you can do so with `brew install
    jq` on macOS or `choco install jq` on Windows.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在系统上安装 `jq`，可以在 macOS 上使用 `brew install jq` 或在 Windows 上使用 `choco install
    jq` 来安装它。
- en: 'The preceding command will return the following result:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令将返回如下结果：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we can see, the Dockerfile for MongoDB defines two volumes at `/data/configdb`
    and `/data/db`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，MongoDB 的 Dockerfile 定义了两个卷，分别位于 `/data/configdb` 和 `/data/db`。
- en: 'Now, let’s run an instance of MongoDB in the background as a daemon, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在后台以守护进程的方式运行一个 MongoDB 实例，如下所示：
- en: '[PRE61]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can now use the `docker container inspect` command to get information about
    the volumes that have been created, among other things. Use this command to just
    get the volume information:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`docker container inspect`命令获取有关已创建的卷的其他信息。使用此命令仅获取卷信息：
- en: '[PRE62]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding command should output something like this (shortened):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应该会输出类似于以下内容的结果（已缩短）：
- en: '![Figure 5.6 – Inspecting the MongoDB volumes](img/B19199_05_06.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 检查 MongoDB 卷](img/B19199_05_06.jpg)'
- en: Figure 5.6 – Inspecting the MongoDB volumes
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 检查 MongoDB 卷
- en: The `Source` field gives us the path to the host directory, where the data produced
    by MongoDB inside the container will be stored.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Source`字段提供了主机目录的路径，MongoDB 在容器内产生的数据将存储在该路径下。'
- en: 'Before you leave, clean up the Mongo DB container with the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 离开之前，使用以下命令清理 MongoDB 容器：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That’s it for the moment concerning volumes. In the next section, we will explore
    how we can configure applications running in containers, and the container image
    build process itself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于卷的内容暂时就这些。在下一节中，我们将探讨如何配置运行在容器中的应用程序以及容器镜像构建过程本身。
- en: Configuring containers
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置容器
- en: More often than not, we need to provide some configuration to the application
    running inside a container. The configuration is often used to allow the same
    container to run in very different environments, such as in development, test,
    staging, or production environments. In Linux, configuration values are often
    provided via environment variables.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们需要为容器内部运行的应用程序提供一些配置。配置通常用于允许同一个容器在非常不同的环境中运行，例如开发、测试、预发布或生产环境。在 Linux
    中，配置值通常通过环境变量提供。
- en: We have learned that an application running inside a container is completely
    shielded from its host environment. Thus, the environment variables that we see
    on the host are different from the ones that we see within a container.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，运行在容器中的应用程序与其主机环境完全隔离。因此，我们在主机上看到的环境变量与容器内看到的环境变量是不同的。
- en: 'Let’s prove this by looking at what is defined on our host:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看主机上定义的内容来证明这一点：
- en: 'Use this command to display a list of all environment variables defined for
    your Terminal session:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令显示为您的终端会话定义的所有环境变量列表：
- en: '[PRE64]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'On the author’s macOS, the output is something like this (shortened):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的 macOS 上，输出大致如下（已缩短）：
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, let’s run a shell inside an Alpine container:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 Alpine 容器中运行一个 Shell：
- en: 'Run the container with this command:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行容器：
- en: '[PRE66]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Just as a reminder, we are using the `--rm` command-line parameter so that we
    do not have to remove the dangling container once we stop it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们使用了`--rm`命令行参数，这样在停止容器后我们就不必手动删除悬空的容器。
- en: 'Then, list the environment variables we can see there with this command:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令列出我们可以看到的环境变量：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This should produce the following output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding output is different than what we saw directly on the host.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出与我们在主机上直接看到的内容不同。
- en: Hit *Ctrl* + *D* to leave and stop the Alpine container.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *D* 离开并停止 Alpine 容器。
- en: Next, let’s define environment variables for containers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为容器定义环境变量。
- en: Defining environment variables for containers
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为容器定义环境变量
- en: 'Now, the good thing is that we can pass some configuration values into the
    container at start time. We can use the `--env` (or the short form, `-e`) parameter
    in the form of `--env <key>=<value>` to do so, where `<key>` is the name of the
    environment variable and `<value>` represents the value to be associated with
    that variable. Let’s assume we want the app that is to be run in our container
    to have access to an environment variable called `LOG_DIR`, with a value of `/var/log/my-log`.
    We can do so with this command:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好消息是我们可以在容器启动时传递一些配置值。我们可以使用`--env`（或简写形式`-e`）参数，格式为`--env <key>=<value>`，其中`<key>`是环境变量的名称，`<value>`是该变量的值。假设我们希望在容器中运行的应用程序可以访问名为`LOG_DIR`的环境变量，其值为`/var/log/my-log`。我们可以通过以下命令实现：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding code starts a shell in an Alpine container and defines the requested
    environment inside the running container. To prove that this is true, we can execute
    this command inside the Alpine container:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码启动了一个 Alpine 容器中的 Shell，并在运行的容器内定义了所请求的环境变量。为了证明这一点，我们可以在 Alpine 容器内执行以下命令：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output should be as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output looks as expected. We now have the requested environment variable
    with the correct value available inside the container. We can, of course, define
    more than just one environment variable when we run a container. We just need
    to repeat the `--env` (or `-e`) parameter. Have a look at this sample:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如预期那样。现在我们可以在容器中使用所请求的环境变量，并且它们具有正确的值。当然，我们在运行容器时可以定义多个环境变量。只需要重复使用`--env`（或`-e`）参数。请查看以下示例：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After running the preceding command, we are left at the command prompt inside
    the Alpine container:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，我们会停留在Alpine容器中的命令提示符下：
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s list the environment variables with the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令列出环境变量：
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We will see the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下内容：
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, let’s look at situations where we have many environment variables to configure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下在需要配置多个环境变量的情况下如何操作。
- en: Using configuration files
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置文件
- en: Complex applications can have many environment variables to configure, and thus
    our command to run the corresponding container can quickly become unwieldy. For
    this purpose, Docker allows us to pass a collection of environment variable definitions
    as a file. We have the `--env-file` parameter in the `docker container run` command
    for this purpose.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的应用程序可能有许多环境变量需要配置，因此，我们运行对应容器的命令可能会变得非常繁琐。为此，Docker允许我们通过文件传递一组环境变量定义。我们在`docker
    container run`命令中使用`--env-file`参数来实现这一点。
- en: 'Let’s try this out, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下，如下所示：
- en: 'Navigate to the source folder for `chapter 5` that we created at the beginning
    of this chapter:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入我们在本章开始时创建的`chapter 5`源文件夹：
- en: '[PRE76]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create a `config-file` subfolder and navigate to it, like this:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`config-file`的子文件夹并进入该文件夹，如下所示：
- en: '[PRE77]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use your favorite editor to create a file called `development.config` in this
    folder. Add the following content to the file and save it, as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器，在此文件夹中创建一个名为`development.config`的文件。将以下内容添加到文件中并保存，如下所示：
- en: '[PRE78]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Notice how we have the definition of a single environment variable per line
    in `<key>=<value>` format, where, once again, `<key>` is the name of the environment
    variable, and `<value>` represents the value to be associated with that variable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何按`<key>=<value>`格式，在每行中定义一个环境变量，其中，`<key>`是环境变量的名称，`<value>`表示要与该变量关联的值。
- en: 'Now, from within the `config-file` subfolder, let’s run an Alpine container,
    pass the file as an environment file, and run the `export` command inside the
    container to verify that the variables listed inside the file have indeed been
    created as environment variables inside the container, like this:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`config-file`子文件夹中，让我们运行一个Alpine容器，将该文件作为环境文件传递，并在容器内运行`export`命令，以验证文件中列出的变量是否已确实作为环境变量创建在容器内，如下所示：
- en: '[PRE79]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And indeed, the variables are defined, as we can see in the output generated:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，变量已经定义，我们可以在生成的输出中看到：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is exactly what we expected.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们预期的结果。
- en: Next, let’s look at how to define default values for environment variables that
    are valid for all container instances of a given Docker image.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何为所有给定Docker镜像的容器实例定义环境变量的默认值。
- en: Defining environment variables in container images
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器镜像中定义环境变量
- en: 'Sometimes, we want to define some default value for an environment variable
    that must be present in each container instance of a given container image. We
    can do so in the Dockerfile that is used to create that image by following these
    steps:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望为环境变量定义一些默认值，确保这些变量在每个容器实例中都存在。我们可以通过以下步骤，在用于创建该镜像的Dockerfile中进行定义：
- en: 'Navigate to the source folder for `chapter 5` that we created at the beginning
    of this chapter:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入我们在本章开始时创建的`chapter 5`源文件夹：
- en: '[PRE81]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a subfolder called `config-in-image` and navigate to it, like this:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`config-in-image`的子文件夹并进入该文件夹，如下所示：
- en: '[PRE82]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Use your favorite editor to create a file called `Dockerfile` in the `config-in-image`
    subfolder. Add the following content to the file and save it:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器，在`config-in-image`子文件夹中创建一个名为`Dockerfile`的文件。将以下内容添加到文件中并保存：
- en: '[PRE83]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create a container image called `my-alpine` using the preceding Dockerfile,
    as follows:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的Dockerfile创建一个名为`my-alpine`的容器镜像，如下所示：
- en: '[PRE84]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t forget the period at the end of the preceding line!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了前一行末尾的句号！
- en: 'Run a container instance from this image that outputs the environment variables
    defined inside the container, like this:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该镜像运行一个容器实例，并输出容器内部定义的环境变量，如下所示：
- en: '[PRE85]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You should see the following in your output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到以下内容：
- en: '[PRE86]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is exactly what we expected.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所预期的。
- en: 'The good thing, though, is that we are not stuck with those variable values
    at all. We can override one or many of them by using the `--env` parameter in
    the `docker container run` command. Use this command:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不过，值得庆幸的是，我们完全不需要拘泥于这些变量值。我们可以通过在`docker container run`命令中使用`--env`参数来覆盖其中一个或多个变量。使用此命令：
- en: '[PRE87]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, have a look at the following command and its output:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，看看以下命令及其输出：
- en: '[PRE88]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We can also override default values by using environment files together with
    the `--env-file` parameter in the `docker container run` command. Please try it
    out for yourself.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用环境文件和`--env-file`参数在`docker container run`命令中覆盖默认值。请自己尝试一下。
- en: In the next section, we are going to introduce environment variables that are
    used at the build time of a Docker image.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍在Docker镜像构建时使用的环境变量。
- en: Environment variables at build time
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建时的环境变量
- en: 'Sometimes, we want to be able to define some environment variables that are
    valid at the time when we build a container image. Imagine that you want to define
    a `BASE_IMAGE_VERSION` environment variable that shall then be used as a parameter
    in your Dockerfile. Imagine the following Dockerfile:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望能够定义一些在构建容器镜像时有效的环境变量。假设你想定义一个`BASE_IMAGE_VERSION`环境变量，然后在Dockerfile中作为参数使用。想象一下以下的Dockerfile：
- en: '[PRE89]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We are using the `ARG` keyword to define a default value that is used each time
    we build an image from the preceding Dockerfile. In this case, that means that
    our image uses the `node:12.7-stretch` base image.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ARG`关键字来定义一个默认值，该默认值将在每次从前面的Dockerfile构建镜像时使用。在本例中，这意味着我们的镜像使用的是`node:12.7-stretch`基础镜像。
- en: 'Now, if we want to create a special image for, say, testing purposes, we can
    override this variable at image build time using the `--build-arg` parameter,
    as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想为某些特定目的（例如测试）创建一个特殊的镜像，我们可以在镜像构建时通过使用`--build-arg`参数来覆盖这个变量，如下所示：
- en: '[PRE90]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this case, the resulting `my-node-test:latest` image will be built from the
    `node:12.7-alpine` base image and not from the `node:12.7-stretch` default image.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，生成的`my-node-test:latest`镜像将从`node:12.7-alpine`基础镜像构建，而不是从`node:12.7-stretch`默认镜像构建。
- en: To summarize, environment variables defined via `--env` or `--env-file` are
    valid at container runtime. Variables defined with `ARG` in the Dockerfile or
    `--build-arg` in the `docker container build` command are valid at container image
    build time. The former is used to configure an application running inside a container,
    while the latter is used to parameterize the container image build process.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过`--env`或`--env-file`定义的环境变量在容器运行时有效。通过Dockerfile中的`ARG`或`docker container
    build`命令中的`--build-arg`定义的变量在容器镜像构建时有效。前者用于配置容器内运行的应用程序，而后者用于参数化容器镜像的构建过程。
- en: And with that, we have come to the end of this chapter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了本章的内容。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced Docker volumes, which can be used to persist
    the state produced by containers and make them durable. We can also use volumes
    to provide containers with data originating from various sources. We learned how
    to create, mount, and use volumes. We also learned various techniques for defining
    volumes such as by name, by mounting a host directory, or by defining volumes
    in a container image.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Docker卷，它可以用于持久化容器产生的状态，并使其具有持久性。我们还可以使用卷为容器提供来自各种来源的数据。我们学习了如何创建、挂载和使用卷。我们还学习了多种定义卷的技术，如通过名称、挂载主机目录或在容器镜像中定义卷。
- en: In this chapter, we also discussed how we can configure environment variables
    that can be used by applications running inside a container. We have shown how
    to define those variables in the `docker container run` command, either explicitly,
    one by one, or as a collection in a configuration file. Finally, we learned how
    to parameterize the build process of container images by using build arguments.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还讨论了如何配置环境变量，以供运行在容器内的应用程序使用。我们展示了如何在`docker container run`命令中显式地逐个定义这些变量，或者将它们作为配置文件中的集合来定义。最后，我们学习了如何通过使用构建参数来参数化容器镜像的构建过程。
- en: In the next chapter, we are going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些常用的技术，这些技术可以让开发人员在容器中运行时对其代码进行演进、修改、调试和测试。
- en: Further reading
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following arti[cles provide more in-de](http://dockr.ly/2EUjTml)pth information:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章提供了更深入的信息：[http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)
- en: '*Use* *volumes*: [http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* *卷*：[http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)'
- en: '*Manage data in* *Docker*: [http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理Docker中的数据*：[http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)'
- en: '*Docker volumes* on **Play with Docker** (**PWD**): [http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Play with Docker**（**PWD**）上的*Docker卷*：[http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)'
- en: '`nsenter` —Linux man page, at [https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsenter` —Linux手册页，链接：[https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
- en: '*Set environment* *variables*: [https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置环境* *变量*：[https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)'
- en: '*Understanding how ARG and FROM* *interact*: [https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解ARG和FROM* *如何交互*：[https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)'
- en: Questions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题，以评估您的学习进度：
- en: How would you create a named data volume with a name such as `my-products` using
    the default driver?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用默认驱动程序创建一个名为`my-products`的数据卷？
- en: How would you run a container using the Alpine image and mount the `my-products`
    volume in read-only mode into the `/data` container folder?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Alpine镜像运行容器，并将`my-products`卷以只读模式挂载到`/data`容器文件夹中？
- en: How would you locate the folder that is associated with the `my-products` volume
    and navigate to it? Also, how would you create a file, `sample.txt`, with some
    content?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何找到与`my-products`卷关联的文件夹并导航到它？同时，如何创建一个包含内容的`sample.txt`文件？
- en: How would you run another Alpine container where you mount the `my-products`
    volume to the `/app-data` folder, in read/write mode? Inside this container, navigate
    to the `/app-data` folder and create a `hello.txt` file with some content.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何运行另一个Alpine容器，将`my-products`卷挂载到`/app-data`文件夹中，且为读写模式？在该容器内，导航到`/app-data`文件夹并创建一个包含内容的`hello.txt`文件。
- en: How would you mount a host volume – for example, `~/my-project` – into a container?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将主机卷（例如，`~/my-project`）挂载到容器中？
- en: How would you remove all unused volumes from your system?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从系统中删除所有未使用的卷？
- en: The list of environment variables that an application running in a container
    sees is the same as if the application were to run directly on the host.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器中运行的应用程序所看到的环境变量列表与应用程序直接在主机上运行时是相同的。
- en: 'True'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Your application, which shall run in a container, needs a huge list of environment
    variables for configuration. What is the simplest method to run a container with
    your application and provide all this information to it?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序将在容器中运行，需要大量的环境变量进行配置。运行容器并提供所有这些信息的最简单方法是什么？
- en: Answers
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: 'To create a named volume, run the following command:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个命名卷，请运行以下命令：
- en: '[PRE91]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Execute the following command:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE92]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To achieve this result, do this:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现此结果，请执行以下操作：
- en: To get the path on the host for the volume, use this command
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取卷在主机上的路径，请使用此命令：
- en: '[PRE93]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This should result in the following output
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE94]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, execute the following command to run a container and execute `nsenter`
    within it:'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行以下命令运行一个容器并在其中执行`nsenter`：
- en: '[PRE95]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Navigate to the folder containing the data for the `my-products` volume:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到包含`my-products`卷数据的文件夹：
- en: '[PRE96]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create a file containing the text `"I love Docker"` within this folder:'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中创建一个包含文本`"I love Docker"`的文件：
- en: '[PRE97]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Exit `nsenter` and its container by pressing *Ctrl* + *D*.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *D*退出`nsenter`及其容器。
- en: 'Execute the following command to verify that the file generated in the host
    filesystem is indeed part of the volume and accessible to the container to which
    we’ll mount this volume:'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以验证在主机文件系统中生成的文件是否确实是卷的一部分，并且可以访问我们将挂载此卷的容器：
- en: '[PRE98]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output of the preceding command should look similar to this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出应类似于以下内容：
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: And indeed, we can see the file.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实可以看到该文件。
- en: 'Optional: Run a modified version of the command to output the content of the
    `sample.txt` file.'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选：运行修改版的命令，输出`sample.txt`文件的内容。
- en: 'Execute the following command:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE100]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In another Terminal, execute this command:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中执行此命令：
- en: '[PRE101]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Execute a command such as this:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE102]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Exit both containers and then, back on the host, execute this command:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出两个容器，然后在主机上执行以下命令：
- en: '[PRE103]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The answer is *False* (B). Each container is a sandbox and thus has its very
    own environment.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是*False*（B）。每个容器都是一个沙盒，因此有其独立的环境。
- en: 'Collect all environment variables and their respective values in a configuration
    file, which you then provide to the container with the `--env-file` command-line
    parameter in the `docker container run` command, like so:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置文件中收集所有环境变量及其相应的值，然后通过`docker container run`命令中的`--env-file`命令行参数提供给容器，如下所示：
- en: '[PRE104]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
