- en: '*Chapter 7*: Configuration Management with Ansible'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：使用 Ansible 进行配置管理'
- en: 'We have already covered the two most crucial phases of the continuous delivery
    process: the commit phase and automated acceptance testing. We also explained
    how to cluster your environments for both your application and Jenkins agents.
    In this chapter, we will focus on configuration management, which connects the
    virtual containerized environment to the real server infrastructure.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了持续交付过程中的两个最关键的阶段：提交阶段和自动化验收测试。我们还解释了如何为应用程序和 Jenkins 代理集群化你的环境。在本章中，我们将重点讨论配置管理，它将虚拟容器化环境与真实服务器基础设施连接起来。
- en: 'This chapter will cover the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Introducing configuration management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理简介
- en: Installing Ansible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Using Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible
- en: Deployment with Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 部署
- en: Ansible with Docker and Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 与 Docker 和 Kubernetes
- en: Introducing infrastructure as code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码简介
- en: Introducing Terraform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 简介
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the instructions in this chapter, you''ll need the following
    hardware/software:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的指引，你需要以下硬件/软件：
- en: Java 8+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8+
- en: Python
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Remote machines with the Ubuntu operating system and SSH server installed
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Ubuntu 操作系统和 SSH 服务器的远程机器
- en: An AWS account
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 账户
- en: All the examples and solutions to the exercises can be found on GitHub at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter07).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例和练习解决方案都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter07)。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3JkcGLE](https://bit.ly/3JkcGLE).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码实践视频可以在 [https://bit.ly/3JkcGLE](https://bit.ly/3JkcGLE) 查看。
- en: Introducing configuration management
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理简介
- en: 'Configuration management is the process of controlling configuration changes
    in such a way that the system maintains integrity over time. Even though the term
    did not originate in the IT industry, currently, it is broadly used to refer to
    software and hardware. In this context, it concerns the following aspects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是控制配置变化的过程，以确保系统在一段时间内保持完整性。尽管这个术语并不是起源于 IT 行业，但目前它被广泛应用于软件和硬件的领域。在此背景下，它涉及以下几个方面：
- en: '**Application configuration**: This involves software properties that decide
    how the system works, which are usually expressed in the form of flags or properties
    files passed to the application, for example, the database address, the maximum
    chunk size for file processing, or the logging level. They can be applied during
    different development phases: build, package, deploy, or run.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用配置**：这涉及决定系统如何运行的软件属性，通常以标志或属性文件的形式传递给应用程序，例如数据库地址、文件处理的最大块大小或日志记录级别。这些配置可以在不同的开发阶段应用：构建、打包、部署或运行。'
- en: '**Server configuration**: This defines what dependencies should be installed
    on each server and specifies the way applications are orchestrated (which application
    is run on which server, and in how many instances).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器配置**：这定义了每个服务器上应安装的依赖项，并指定应用程序的编排方式（哪个应用程序运行在哪个服务器上，以及运行多少个实例）。'
- en: '**Infrastructure configuration**: This involves server infrastructure and environment
    configuration. If you use on-premises servers, then this part is related to the
    manual hardware and network installation; if you use cloud solutions, then this
    part can be automated with the **infrastructure as code** (**IaC**)e approach.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施配置**：这涉及服务器基础设施和环境配置。如果你使用的是本地服务器，那么这部分与手动硬件和网络安装有关；如果使用的是云解决方案，那么这部分可以通过**基础设施即代码**（**IaC**）方法自动化。'
- en: 'As an example, we can think of the calculator web service, which uses the Hazelcast
    server. Let''s look at the following diagram, which presents how configuration
    management works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们可以考虑使用 Hazelcast 服务器的计算器 Web 服务。让我们看一下下面的图表，展示了配置管理是如何工作的：
- en: '![Figure 7.1 – Sample configuration management'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 示例配置管理'
- en: '](img/B18223_07_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_07_01.jpg)'
- en: Figure 7.1 – Sample configuration management
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 示例配置管理
- en: The configuration management tool reads the configuration file and prepares
    the environment. It installs dependent tools and libraries and deploys the applications
    to multiple instances. Additionally, in the case of cloud deployment, it can provide
    the necessary infrastructure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具读取配置文件并准备环境。它安装依赖的工具和库，并将应用程序部署到多个实例上。此外，在云部署的情况下，它还可以提供必要的基础设施。
- en: In the preceding example, **Infrastructure Configuration** specifies the required
    servers and S**erver Configuration** defines that the **Calculator** service should
    be deployed in two instances, on **Server 1** and **Server 2**, and that the Hazelcast
    service should be installed on **Server 3**. **Calculator Application Configuration** specifies
    the port and the address of the Hazelcast server so that the services can communicate.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，**基础设施配置**指定了所需的服务器，而**服务器配置**定义了**计算器**服务应该部署在**服务器1**和**服务器2**的两个实例上，并且Hazelcast服务应该安装在**服务器3**上。**计算器应用程序配置**指定了Hazelcast服务器的端口和地址，以便各个服务能够通信。
- en: Information
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The configuration can differ, depending on the type of the environment (QA,
    staging, or production); for example, server addresses can be different.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以根据环境类型（QA、暂存或生产环境）有所不同；例如，服务器地址可能会不同。
- en: There are many approaches to configuration management, but before we look into
    concrete solutions, let's comment on what characteristics a good configuration
    management tool should have.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理有很多方法，但在我们深入探讨具体解决方案之前，先评论一下一个好的配置管理工具应该具备哪些特性。
- en: Traits of good configuration management
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优秀配置管理的特点
- en: 'What should a modern configuration management solution look like? Let''s walk
    through the most important factors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现代配置管理解决方案应该是什么样的？让我们看看最重要的几个因素：
- en: '**Automation**: Each environment should be automatically reproducible, including
    the operating system, the network configuration, the software installed, and the
    applications deployed. In such an approach, fixing production issues means nothing
    more than an automatic rebuild of the environment. What''s more, it simplifies
    server replications and ensures that the staging and production environments are
    exactly the same.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：每个环境都应该是自动可重现的，包括操作系统、网络配置、已安装的软件和已部署的应用程序。在这种方法中，解决生产环境问题意味着仅仅是自动重建环境。更重要的是，它简化了服务器的复制，并确保暂存和生产环境完全相同。'
- en: '**Version control**: Every change in the configuration should be tracked, so
    that we know who made it, why, and when. Usually, that means keeping the configuration
    in the source code repository, either with the code or in a separate place. The
    former solution is recommended because configuration properties have a different
    life cycle than the application itself. Version control also helps with fixing
    production issues; the configuration can always be rolled back to the previous
    version, and the environment automatically rebuilt. The only exception to the
    version control-based solution is storing credentials and other sensitive information;
    these should never be checked in.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：每一次配置更改都应该被追踪，这样我们就知道是谁、为什么以及何时做出的更改。通常，这意味着将配置保存在源代码仓库中，可以与代码一起存储，也可以存放在单独的位置。推荐使用前者，因为配置属性的生命周期与应用程序本身不同。版本控制还可以帮助解决生产环境问题；配置可以随时回滚到上一个版本，并自动重建环境。唯一的例外是存储凭证和其他敏感信息；这些信息绝对不能被提交到版本控制中。'
- en: '**Incremental changes**: Applying a change in the configuration should not
    require rebuilding the whole environment. On the contrary, a small change in the
    configuration should only change the related part of the infrastructure.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量更改**：应用配置更改不应该需要重建整个环境。相反，配置中的小更改应该只会影响相关的基础设施部分。'
- en: '**Server provisioning**: Thanks to automation, adding a new server should be
    as quick as adding its address to the configuration (and executing one command).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器配置**：得益于自动化，添加新服务器应该像将其地址添加到配置中（并执行一个命令）一样快速。'
- en: '**Security**: The access to both the configuration management tool and the
    machines under its control should be well secured. When using the SSH protocol
    for communication, the access to the keys or credentials needs to be well protected.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：对配置管理工具及其控制下的机器的访问应该得到充分保护。当使用SSH协议进行通信时，访问密钥或凭证需要得到妥善保护。'
- en: '**Simplicity**: Every member of the team should be able to read the configuration,
    make a change, and apply it to the environment. The properties themselves should
    also be kept as simple as possible, and the ones that are not subject to change
    are better off kept hardcoded.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：团队中的每个成员都应该能够阅读配置，进行修改，并将其应用到环境中。配置项本身也应该尽可能简单，且那些不需要改变的配置最好保持硬编码。'
- en: It is important to keep these points in mind while creating the configuration,
    and even beforehand while choosing the right configuration management tool.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建配置时，甚至在选择合适的配置管理工具时，记住这些要点非常重要。
- en: Overview of configuration management tools
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理工具概览
- en: 'In the classic sense, before the cloud era, configuration management referred
    to the process that started when all the servers were already in place. So, the
    starting point was a set of IP addresses with machines accessible via SSH. For
    that purpose, the most popular configuration management tools are Ansible, Puppet,
    and Chef. Each of them is a good choice; they are all open source products with
    free basic versions and paid enterprise editions. The most important differences
    between them are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统意义上，在云时代之前，配置管理指的是在所有服务器都已经到位时开始的过程。因此，起点是一组可以通过 SSH 访问的 IP 地址。为此，最流行的配置管理工具有
    Ansible、Puppet 和 Chef。每个工具都是不错的选择；它们都是开源产品，提供免费的基础版本和付费的企业版。它们之间最重要的区别如下：
- en: '**Configuration language**: Chef uses Ruby, Puppet uses its own DSL (based
    on Ruby), and Ansible uses YAML.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置语言**：Chef 使用 Ruby，Puppet 使用自己的 DSL（基于 Ruby），而 Ansible 使用 YAML。'
- en: '**Agent-based**: Puppet and Chef use agents for communication, which means
    that each managed server needs to have a special tool installed. Ansible, on the
    other hand, is agentless and uses the standard SSH protocol for communication.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于代理**：Puppet 和 Chef 使用代理进行通信，这意味着每台被管理的服务器都需要安装一个特殊的工具。而 Ansible 则不需要代理，使用标准的
    SSH 协议进行通信。'
- en: The agentless feature is a significant advantage because it implies no need
    to install anything on servers. What's more, Ansible is quickly trending upward,
    which is why it was chosen for this book. Nevertheless, other tools can also be used successfully
    for the continuous delivery process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理特性是一个显著的优势，因为它意味着不需要在服务器上安装任何东西。而且，Ansible 正在快速崛起，这也是为什么它被选择用于本书的原因。然而，其他工具也可以在持续交付过程中成功使用。
- en: Together with cloud transformation, the meaning of configuration management
    widened and started to include what is called **IaC**. As the input, you no longer
    need a set of IP addresses, but it's enough to provide the credentials to your
    favorite cloud provider. Then, IaC tools can provision servers for you. What's
    more, each cloud provider offers a portfolio of services, so in many cases, you
    don't even need to provision bare-metal servers, but directly use cloud services.
    While you can still use Ansible, Puppet, or Chef for that purpose, there is a
    tool called Terraform that is dedicated to the IaC use case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云转型的进行，配置管理的意义也在扩大，开始包括所谓的 **IaC**（基础设施即代码）。作为输入，你不再需要一组 IP 地址，而只需要提供你喜欢的云服务提供商的凭据。然后，IaC
    工具可以为你配置服务器。此外，每个云服务提供商都提供一系列服务，因此在许多情况下，你甚至不需要配置裸机服务器，而是直接使用云服务。虽然你仍然可以使用 Ansible、Puppet
    或 Chef 达到这个目的，但有一个专门针对 IaC 用例的工具叫做 Terraform。
- en: Let's first describe the classic approach to configuration management with Ansible,
    and then walk through the IaC solution using Terraform.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述使用 Ansible 的经典配置管理方法，然后介绍使用 Terraform 的 IaC 解决方案。
- en: Installing Ansible
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Ansible is an open source, agentless automation engine for software provisioning,
    configuration management, and application deployment. Its first release was in
    2012, and its basic version is free for both personal and commercial use. The
    enterprise version is called **Ansible Tower**, which provides GUI management and dashboards,
    the REST API, role-based access control, and some more features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个开源的无代理自动化引擎，用于软件配置、管理和应用部署。它的第一次发布是在 2012 年，基础版本对个人和商业使用都是免费的。企业版叫做
    **Ansible Tower**，它提供了 GUI 管理和仪表盘、REST API、基于角色的访问控制以及其他一些功能。
- en: We will present the installation process and a description of how Ansible can
    be used separately, as well as in conjunction with Docker.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别介绍安装过程以及 Ansible 如何单独使用，或与 Docker 一起使用的描述。
- en: Ansible server requirements
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 服务器要求
- en: Ansible uses the SSH protocol for communication and has no special requirements
    regarding the machine it manages. There is also no central master server, so it's
    enough to install the Ansible client tool anywhere; we can then use it to manage
    the whole infrastructure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 使用 SSH 协议进行通信，并且对它管理的机器没有特殊要求。也没有中央主服务器，因此只需在任何地方安装 Ansible 客户端工具；然后我们可以使用它来管理整个基础设施。
- en: Information
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The only requirement for the machines being managed is to have the Python tool
    (and obviously, the SSH server) installed. These tools are, however, almost always
    available on any server by default.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 被管理的机器的唯一要求是必须安装 Python 工具（显然，也需要安装 SSH 服务器）。然而，这些工具几乎在任何服务器上默认都能使用。
- en: Ansible installation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 安装
- en: 'The installation instructions will differ depending on the operating system.
    In the case of Ubuntu, it''s enough to run the following commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明将根据操作系统有所不同。以 Ubuntu 为例，只需运行以下命令：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Information
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can find the installation guides for all the operating systems on the official
    Ansible page, at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方 Ansible 页面找到所有操作系统的安装指南，地址为 [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)。
- en: 'After the installation process is complete, we can execute the `ansible` command
    to check that everything was installed successfully:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，我们可以执行 `ansible` 命令来检查是否一切安装成功：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using Ansible
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible
- en: In order to use Ansible, we first need to define the inventory, which represents
    the available resources. Then, we will be able to either execute a single command
    or define a set of tasks using the Ansible playbook.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Ansible，我们首先需要定义库存，它表示可用的资源。然后，我们将能够执行单个命令或使用 Ansible 剧本定义一组任务。
- en: Creating an inventory
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建库存
- en: An inventory is a list of all the servers that are managed by Ansible. Each
    server requires nothing more than the Python interpreter and the SSH server installed.
    By default, Ansible assumes that SSH keys are used for authentication; however,
    it is also possible to use a username and password by adding the `--ask-pass` option
    to the Ansible commands.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 库存是 Ansible 管理的所有服务器的列表。每个服务器只需要安装 Python 解释器和 SSH 服务器。默认情况下，Ansible 假定使用 SSH
    密钥进行身份验证；然而，也可以通过在 Ansible 命令中添加 `--ask-pass` 选项来使用用户名和密码。
- en: Tip
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: SSH keys can be generated with the `ssh-keygen` tool, and they are usually stored
    in the `~/.ssh` directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ssh-keygen` 工具生成 SSH 密钥，通常它们存储在 `~/.ssh` 目录中。
- en: 'The inventory is defined by default in the `/etc/ansible/hosts` file (but its
    location can be defined with the `–i` parameter), and it has the following structure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 库存默认定义在 `/etc/ansible/hosts` 文件中（但可以通过 `–i` 参数定义位置），它的结构如下：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The inventory syntax also accepts ranges of servers, for example, `www[01-22].company.com`.
    The SSH port should also be specified if it's anything other than `22` (the default).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 库存语法还支持服务器的范围，例如 `www[01-22].company.com`。如果 SSH 端口不是 `22`（默认端口），还应指定端口号。
- en: 'There can be many groups in the inventory file. As an example, let''s define
    two machines in one group of servers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 库存文件中可以包含多个组。例如，让我们在一个服务器组中定义两台机器：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also create the configuration with server aliases and specify the remote
    user:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建带有服务器别名的配置，并指定远程用户：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding file defines a group called `webservers`, which consists of two
    servers. The Ansible client will log into both of them as the user `ubuntu`. When
    we have the inventory created, let's discover how we can use it to execute the
    same command on many servers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的文件定义了一个名为 `webservers` 的组，该组包含两台服务器。Ansible 客户端将以 `ubuntu` 用户身份登录这两台服务器。当我们创建好库存后，让我们了解如何使用它在多台服务器上执行相同的命令。
- en: Information
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Ansible offers the possibility to dynamically pull the inventory from a cloud
    provider (for example, Amazon EC2/Eucalyptus), LDAP, or Cobbler. Read more about
    dynamic inventories at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 提供了从云提供商（例如，Amazon EC2/Eucalyptus）、LDAP 或 Cobbler 动态拉取库存的功能。关于动态库存的更多信息，请参阅
    [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html)。
- en: Ad hoc commands
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时命令
- en: 'The simplest command we can run is a ping on all servers. Assuming that we
    have two remote machines (`192.168.64.12` and `192.168.64.13`) with SSH servers
    configured and the inventory file (as defined in the last section), let''s execute
    the `ping` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行的最简单的命令是在所有服务器上进行 ping 测试。假设我们有两台远程机器（`192.168.64.12` 和 `192.168.64.13`），它们配置了
    SSH 服务器，并且有一个清单文件（如上一节所定义），我们可以执行 `ping` 命令：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We used the `-m <module_name>` option, which allows for specifying the module
    that should be executed on the remote hosts. The result is successful, which means that the
    servers are reachable, and the authentication is configured correctly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `-m <module_name>` 选项，它允许指定应该在远程主机上执行的模块。结果是成功的，这意味着服务器是可达的，且身份验证已正确配置。
- en: 'Note that we used `all`, so that all servers would be addressed, but we could
    also call them by the `webservers` group name, or by the single host alias. As
    a second example, let''s execute a shell command on only one of the servers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `all`，因此所有服务器都会被处理，但我们也可以通过 `webservers` 组名或单个主机别名来调用它们。作为第二个例子，我们只在其中一台服务器上执行
    shell 命令：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `-a <arguments>` option specifies the arguments that are passed to the Ansible
    module. In this case, we didn't specify the module, so the arguments are executed
    as a shell Unix command. The result was successful, and `hello` was printed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a <arguments>` 选项指定传递给 Ansible 模块的参数。在这个例子中，我们没有指定模块，因此这些参数作为一个 shell Unix
    命令执行。结果是成功的，并且打印出了 `hello`。'
- en: Tip
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If the `ansible` command is connecting to the server for the first time (or
    if the server is reinstalled), then we are prompted with the key confirmation
    message (the SSH message, when the host is not present in `known_hosts`). Since
    it may interrupt an automated script, we can disable the prompt message by uncommenting `host_key_checking
    = False` in the `/etc/ansible/ansible.cfg` file, or by setting the environment
    variable, `ANSIBLE_HOST_KEY_CHECKING=False`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ansible` 命令是第一次连接到服务器（或者服务器被重新安装），则会出现密钥确认提示信息（即 SSH 消息，当主机不在 `known_hosts`
    文件中时）。由于这可能会中断自动化脚本，我们可以通过在 `/etc/ansible/ansible.cfg` 文件中取消注释 `host_key_checking
    = False` 来禁用提示信息，或者通过设置环境变量 `ANSIBLE_HOST_KEY_CHECKING=False` 来实现。
- en: 'In its simplistic form, the Ansible ad hoc command syntax looks as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，Ansible 临时命令的语法如下所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The purpose of ad hoc commands is to do something quickly when it is not necessary
    to repeat it. For example, we may want to check whether a server is alive or power off
    all the machines for the Christmas break. This mechanism can be seen as a command
    execution on a group of machines, with the additional syntax simplification provided
    by the modules. The real power of Ansible automation, however, lies in playbooks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 临时命令的目的是在不需要重复执行的情况下快速完成某些任务。例如，我们可能想检查某台服务器是否在线，或者在圣诞假期期间关闭所有机器。这个机制可以看作是在一组机器上执行命令，同时利用模块提供的额外语法简化。然而，Ansible
    自动化的真正威力在于剧本。
- en: Playbooks
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剧本
- en: An **Ansible playbook** is a configuration file that describes how servers should
    be configured. It provides a way to define a sequence of tasks that should be
    performed on each of the machines. A playbook is expressed in the YAML configuration
    language, which makes it human-readable and easy to understand. Let's start with
    a sample playbook, and then see how we can use it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible 剧本** 是一个配置文件，用来描述如何配置服务器。它提供了一种定义应在每台机器上执行的任务顺序的方式。剧本采用 YAML 配置语言表示，使其既易于阅读又易于理解。我们先从一个示例剧本开始，然后看看如何使用它。'
- en: Defining a playbook
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个剧本
- en: 'A playbook is composed of one or many plays. Each play contains a host group
    name, tasks to perform, and configuration details (for example, the remote username
    or access rights). An example playbook might look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个剧本由一个或多个剧集（play）组成。每个剧集包含一个主机组名称、要执行的任务和配置细节（例如，远程用户名或访问权限）。一个示例剧本可能如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This configuration contains one play, which performs the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置包含一个剧集，它执行以下操作：
- en: Only executes on the `web1` host
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在 `web1` 主机上执行
- en: Gains root access using the `sudo` command
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sudo` 命令获得 root 权限
- en: 'Executes two tasks:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行两个任务：
- en: '`apt` Ansible module (called with two parameters, `name=apache2` and `state=latest`)
    checks whether the `apache2` package is installed on the server, and if it isn''t,
    it uses the `apt-get` tool to install it.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt` Ansible 模块（通过两个参数调用，`name=apache2` 和 `state=latest`）检查服务器上是否安装了 `apache2`
    软件包，如果没有，它将使用 `apt-get` 工具进行安装。'
- en: '`service` Ansible module (called with three parameters, `name=apache2`, `state=started`,
    and `enabled=yes`) checks whether the `apache2` Unix service is started, and if
    it isn''t, it uses the `service` command to start it.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service` Ansible 模块（通过三个参数 `name=apache2`、`state=started` 和 `enabled=yes`
    调用）检查 `apache2` Unix 服务是否已启动，如果未启动，它将使用 `service` 命令启动它。'
- en: Note that each task has a human-readable name, which is used in the console output,
    such that `apt` and `service` are Ansible modules, and `name=apache2`, `state=latest`,
    and `state=started` are module arguments. You already saw Ansible modules and
    arguments while using ad hoc commands. In the preceding playbook, we only defined
    one play, but there can be many of them, and each can be related to different
    groups of hosts.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个任务都有一个人类可读的名称，该名称用于控制台输出，其中 `apt` 和 `service` 是 Ansible 模块，而 `name=apache2`、`state=latest`
    和 `state=started` 是模块参数。在使用临时命令时，您已经看到了 Ansible 模块和参数。在前面的 playbook 中，我们只定义了一个
    play，但可以有多个 play，每个 play 可以与不同的主机组相关联。
- en: Information
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that since we used the `apt` Ansible module, the playbook is dedicated
    to Debian/Ubuntu servers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用了 `apt` Ansible 模块，因此该 playbook 仅适用于 Debian/Ubuntu 服务器。
- en: 'For example, we could define two groups of servers in the inventory: `database`
    and `webservers`. Then, in the playbook, we could specify the tasks that should
    be executed on all database-hosting machines, and some different tasks that should
    be executed on all the web servers. By using one command, we could set up the
    whole environment.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在清单中定义两个服务器组：`database` 和 `webservers`。然后，在 playbook 中，我们可以指定应该在所有数据库托管机器上执行的任务，以及应该在所有
    Web 服务器上执行的一些不同任务。通过使用一个命令，我们可以设置整个环境。
- en: Executing the playbook
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 playbook
- en: 'When `playbook.yml` is defined, we can execute it using the `ansible-playbook`
    command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `playbook.yml` 定义好后，我们可以使用 `ansible-playbook` 命令来执行它：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If the server requires entering the password for the `sudo` command, then we
    need to add the `--ask-sudo-pass` option to the `ansible-playbook` command. It's
    also possible to pass the `sudo` password (if required) by setting the extra variable,
    `-e ansible_become_pass=<sudo_password>`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器需要输入 `sudo` 命令的密码，则需要在 `ansible-playbook` 命令中添加 `--ask-sudo-pass` 选项。也可以通过设置额外变量
    `-e ansible_become_pass=<sudo_password>` 来传递 `sudo` 密码（如果需要）。
- en: The playbook configuration was executed, and therefore, the `apache2` tool was
    installed and started. Note that if the task has changed something on the server,
    it is marked as `changed`. On the contrary, if there was no change, the task is
    marked as `ok`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: playbook 配置已执行，因此 `apache2` 工具已安装并启动。请注意，如果任务已对服务器做出更改，则标记为 `changed`。相反，如果没有任何更改，任务将标记为
    `ok`。
- en: Tip
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is possible to run tasks in parallel by using the `-f <num_of_threads>` option.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `-f <num_of_threads>` 选项并行运行任务。
- en: The playbook's idempotency
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: playbook 的幂等性
- en: 'We can execute the command again, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次执行该命令，如下所示：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the output is slightly different. This time, the command didn't change
    anything on the server. That's because each Ansible module is designed to be idempotent.
    In other words, executing the same module many times in a sequence should have
    the same effect as executing it only once.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出略有不同。这次命令没有更改服务器上的任何内容。这是因为每个 Ansible 模块设计为幂等的。换句话说，多次执行相同的模块，效果应与只执行一次相同。
- en: The simplest way to achieve idempotency is to always check first whether the
    task has been executed yet, and only execute it if it hasn't. Idempotency is a
    powerful feature, and we should always write our Ansible tasks this way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现幂等性最简单的方法是首先检查任务是否已执行过，只有在未执行时才执行该任务。幂等性是一个强大的功能，我们应该始终以这种方式编写 Ansible 任务。
- en: If all the tasks are idempotent, then we can execute them as many times as we
    want. In that context, we can think of the playbook as a description of the desired
    state of remote machines. Then, the `ansible-playbook` command takes care of bringing
    the machine (or group of machines) into that state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有任务都是幂等的，我们可以执行任意次数。在这种情况下，我们可以将 playbook 看作是远程机器所需状态的描述。然后，`ansible-playbook`
    命令负责将机器（或机器组）带入该状态。
- en: Handlers
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理程序
- en: Some operations should only be executed if some other tasks are changed. For
    example, imagine that you copy the configuration file to the remote machine and
    the Apache server should only be restarted if the configuration file has changed. *How
    could we approach such a case?*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有些操作应该仅在其他任务发生变化时执行。例如，假设你将配置文件复制到远程机器，并且只有在配置文件发生变化时，Apache服务器才应该重新启动。*我们该如何处理这种情况呢？*
- en: 'Ansible provides an event-oriented mechanism to notify about the changes. In
    order to use it, we need to know two keywords:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一个事件驱动机制来通知变化。为了使用它，我们需要知道两个关键字：
- en: '`handlers`: This specifies the tasks executed when notified.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`：指定在通知时执行的任务。'
- en: '`notify`: This specifies the handlers that should be executed.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`：指定应该执行的处理器。'
- en: 'Let''s look at the following example of how we could copy the configuration
    to the server and restart Apache only if the configuration has changed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，说明如何将配置复制到服务器，并且只有在配置发生变化时才重新启动Apache：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can create the `foo.conf` file and run the `ansible-playbook` command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`foo.conf`文件并运行`ansible-playbook`命令：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Information
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Handlers are always executed at the end of the play, and only once, even if
    triggered by multiple tasks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器总是在play的最后执行，并且只会执行一次，即使被多个任务触发。
- en: 'Ansible copied the file and restarted the Apache server. It''s important to
    understand that if we run the command again, nothing will happen. However, if
    we change the content of the `foo.conf` file and then run the `ansible-playbook` command,
    the file will be copied again (and the Apache server will be restarted):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible已经复制了文件并重新启动了Apache服务器。重要的是要理解，如果我们再次运行命令，什么也不会发生。但是，如果我们更改了`foo.conf`文件的内容，然后运行`ansible-playbook`命令，文件会再次被复制（并且Apache服务器会被重新启动）：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We used the `copy` module, which is smart enough to detect whether the file
    has changed and then make a change on the server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`copy`模块，它足够智能，可以检测文件是否已更改，然后在服务器上进行相应的修改。
- en: Tip
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There is also a publish-subscribe mechanism in Ansible. Using it means assigning
    a topic to many handlers. Then, a task notifies the topic to execute all related
    handlers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中也有发布-订阅机制。使用它意味着将一个主题分配给多个处理器。然后，一个任务通过通知该主题来执行所有相关的处理器。
- en: Variables
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'While the Ansible automation makes things identical and repeatable for multiple
    hosts, it is inevitable that servers may require some differences. For example,
    think of the application port number. It can be different, depending on the machine.
    Luckily, Ansible provides variables, which are a good mechanism to deal with server
    differences. Let''s create a new playbook and define a variable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ansible自动化使得多个主机的操作变得相同且可重复，但不可避免的是，服务器可能需要一些差异。例如，考虑应用端口号。根据机器的不同，它可能会有所不同。幸运的是，Ansible提供了变量，这是一种很好的机制来处理服务器之间的差异。让我们创建一个新的playbook并定义一个变量：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The configuration defines the `http_port` variable with the value `8080`. Now,
    we can use it by using the `Jinja2` syntax:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 配置定义了`http_port`变量，其值为`8080`。现在，我们可以通过使用`Jinja2`语法来使用它：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `Jinja2` language allows for doing way more than just getting a variable.
    We can use it to create conditions, loops, and much more. You can find more details
    on the Jinja page, at [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jinja2`语言不仅仅允许获取变量。我们可以使用它来创建条件、循环等更多功能。你可以在Jinja页面找到更多详细信息：[https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)。'
- en: 'The `debug` module prints the message while executing. If we run the `ansible-playbook`
    command, we can see the variable usage:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`模块在执行时打印消息。如果我们运行`ansible-playbook`命令，我们可以看到变量的使用：'
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Apart from user-defined variables, there are also predefined automatic variables.
    For example, the `hostvars` variable stores a map with the information regarding
    all hosts from the inventory. Using the Jinja2 syntax, we can iterate and print
    the IP addresses of all the hosts in the inventory:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户定义的变量外，还有预定义的自动变量。例如，`hostvars`变量存储了一个映射，包含了所有主机的相关信息。使用Jinja2语法，我们可以迭代并打印所有主机的IP地址：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we can execute the `ansible-playbook` command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行`ansible-playbook`命令：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that with the use of the Jinja2 language, we can specify the flow control
    operations inside the Ansible playbook file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过使用Jinja2语言，我们可以在Ansible playbook文件中指定流程控制操作。
- en: Roles
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: We can install any tool on the remote server by using Ansible playbooks. Imagine
    that we would like to have a server with MySQL. We could easily prepare a playbook
    similar to the one with the `apache2` package. However, if you think about it,
    a server with MySQL is quite a common case, and someone has surely already prepared
    a playbook for it, so maybe we can just reuse it. This is where Ansible roles
    and Ansible Galaxy come into play.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Ansible playbooks 在远程服务器上安装任何工具。假设我们想要在服务器上安装 MySQL。我们可以轻松地准备一个类似于
    `apache2` 包的 playbook。然而，如果仔细想想，MySQL 服务器是一个相当常见的案例，肯定有人已经为此准备了 playbook，那么我们或许可以直接重用它。这就是
    Ansible 角色和 Ansible Galaxy 发挥作用的地方。
- en: Understanding roles
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解角色
- en: 'An Ansible role is a well-structured playbook part prepared to be included
    in playbooks. Roles are separate units that always have the following directory
    structure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 角色是一个结构良好的 playbook 部分，准备好可以被包含到 playbook 中。角色是独立的单元，始终具有以下目录结构：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Information
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read more about roles and what each directory means on the official
    Ansible page at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Ansible 官方页面上了解更多关于角色以及每个目录含义的内容，网址是 [https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html)。
- en: 'In each of the directories, we can define the `main.yml` file, which contains
    the playbook parts that can be included in the `playbook.yml` file. Continuing
    the MySQL case, there is a role defined on GitHub at [https://github.com/geerlingguy/ansible-role-mysql](https://github.com/geerlingguy/ansible-role-mysql).
    This repository contains task templates that can be used in our playbook. Let''s
    look at a part of the `tasks/setup-Debian.yml` file, which installs the `mysql`
    package in Ubuntu/Debian:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个目录中，我们可以定义 `main.yml` 文件，其中包含可以包含到 `playbook.yml` 文件中的 playbook 部分。以 MySQL
    为例，GitHub 上有一个角色定义在 [https://github.com/geerlingguy/ansible-role-mysql](https://github.com/geerlingguy/ansible-role-mysql)
    上。这个仓库包含可以在我们的 playbook 中使用的任务模板。让我们来看一下 `tasks/setup-Debian.yml` 文件的部分内容，它在 Ubuntu/Debian
    中安装 `mysql` 包：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is only one of the tasks defined in the `tasks/main.yml` file. Others tasks
    are responsible for the installation of MySQL into other operating systems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 `tasks/main.yml` 文件中定义的任务之一。其他任务负责将 MySQL 安装到其他操作系统上。
- en: 'If we use this role in order to install MySQL on the server, it''s enough to
    create the following `playbook.yml`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个角色来安装服务器上的 MySQL，只需创建以下 `playbook.yml` 即可：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Such a configuration installs the MySQL database on all servers using the `geerlingguy.mysql` role.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的配置会使用 `geerlingguy.mysql` 角色在所有服务器上安装 MySQL 数据库。
- en: Ansible Galaxy
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: Ansible Galaxy is to Ansible what Docker Hub is to Docker—it stores common roles
    so that they can be reused by others. You can browse the available roles on the
    Ansible Galaxy page at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Galaxy 对 Ansible 就像 Docker Hub 对 Docker 一样——它存储常见的角色，供他人重用。你可以在 Ansible
    Galaxy 页面浏览可用的角色，网址是 [https://galaxy.ansible.com/](https://galaxy.ansible.com/)。
- en: 'To install a role from Ansible Galaxy, we can use the `ansible-galaxy` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Ansible Galaxy 安装一个角色，我们可以使用 `ansible-galaxy` 命令：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command automatically downloads the role. In the case of the MySQL example,
    we could download the role by executing the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会自动下载角色。以 MySQL 为例，我们可以通过执行以下命令下载该角色：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The command downloads the `mysql` role, which can later be used in the playbook
    file. If you defined `playbook.yml` as described in the preceding snippet, the
    following command installs MySQL into all of your servers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会下载 `mysql` 角色，之后可以在 playbook 文件中使用它。如果你按照前面片段中描述的方式定义了 `playbook.yml`，则以下命令会将
    MySQL 安装到所有服务器中：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that you know about the basics of Ansible, let's see how we can use it to
    deploy our own applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Ansible 的基础知识，让我们来看一下如何使用它来部署我们自己的应用程序。
- en: Deployment with Ansible
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 部署
- en: We have covered the most fundamental features of Ansible. Now, let's forget,
    just for a little while, about Docker, Kubernetes, and most of the things we've
    learned so far. Let's configure a complete deployment step by only using Ansible.
    We will run the calculator service on one server and the Hazelcast service on
    the second server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 Ansible 的最基本特性。现在，让我们暂时忘记 Docker、Kubernetes 和我们至今学到的大多数内容。让我们仅使用 Ansible
    配置一个完整的部署步骤。我们将在一台服务器上运行计算器服务，在另一台服务器上运行 Hazelcast 服务。
- en: Installing Hazelcast
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Hazelcast
- en: 'We can specify a play in the new playbook. Let''s create the `playbook.yml` file,
    with the following content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在新的playbook中指定一个任务。让我们创建一个`playbook.yml`文件，内容如下：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The configuration is executed on the `web1` server and it requires root permissions.
    It performs a few steps that will lead to a complete Hazelcast server installation.
    Let''s walk through what we defined:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 配置将在`web1`服务器上执行，并且需要root权限。它执行几个步骤，最终将完成Hazelcast服务器的安装。让我们逐步查看我们定义的内容：
- en: '**Prepare the environment**: This task ensures that the Java runtime environment
    is installed. Basically, it prepares the server environment so that Hazelcast
    will have all the necessary dependencies. With more complex applications, the
    list of dependent tools and libraries can be way longer.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备环境**：此任务确保Java运行时环境已安装。基本上，它为服务器环境做准备，以确保Hazelcast能够拥有所有必要的依赖项。对于更复杂的应用程序，依赖工具和库的列表可能会更长。'
- en: '**Download Hazelcast tool**: Hazelcast is provided in the form of a JAR, which
    can be downloaded from the internet. We hardcoded the version, but in a real-life
    scenario, it would be better to extract it to a variable.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载Hazelcast工具**：Hazelcast以JAR形式提供，可以从互联网上下载。我们硬编码了版本，但在实际情况中，最好将其提取到一个变量中。'
- en: '`/etc/init.d/` directory.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/etc/init.d/`目录。'
- en: '**Start the Hazelcast service**: When Hazelcast is configured as a Unix service,
    we can start it in the standard way.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动Hazelcast服务**：当Hazelcast被配置为Unix服务时，我们可以以标准方式启动它。'
- en: 'In the same directory, let''s create `hazelcast.sh`, which is a script (shown
    as follows) that is responsible for running Hazelcast as a Unix service:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下，让我们创建`hazelcast.sh`，这是一个负责将Hazelcast作为Unix服务运行的脚本（如下所示）：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After this step, we could execute the playbook and have Hazelcast started on
    the `web1` server machine. However, let's first create a second play to start
    the calculator service, and then run it all together.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们可以执行playbook并在`web1`服务器上启动Hazelcast。然而，我们先创建第二个任务来启动计算器服务，然后一起运行。
- en: Deploying a web service
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署网页服务
- en: 'We prepare the calculator web service in two steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两步准备`calculator`网页服务：
- en: Change the Hazelcast host address.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改Hazelcast主机地址。
- en: Add calculator deployment to the playbook.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计算器部署添加到playbook中。
- en: Changing the Hazelcast host address
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改Hazelcast主机地址
- en: Previously, we hardcoded the Hazelcast host address as `hazelcast`, so now we
    should change it in the `src/main/java/com/leszko/calculator/CalculatorApplication.java`
    file to `192.168.64.12` (the same IP address we have in our inventory, as `web1`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们硬编码了Hazelcast主机地址为`hazelcast`，所以现在我们应该将它更改为`src/main/java/com/leszko/calculator/CalculatorApplication.java`文件中的`192.168.64.12`（与我们的清单中`web1`的IP地址相同）。
- en: Tip
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In real-life projects, the application properties are usually kept in the `properties`
    file. For example, for the Spring Boot framework, it's a file called `application.properties` or `application.yml`.
    Then, we could change them with Ansible and therefore be more flexible.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，应用程序的属性通常保存在`properties`文件中。例如，对于Spring Boot框架，它是一个名为`application.properties`或`application.yml`的文件。然后，我们可以使用Ansible更改它们，从而更加灵活。
- en: Adding calculator deployment to the playbook
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将计算器部署添加到playbook中
- en: 'Finally, we can add the deployment configuration as a new play in the `playbook.yml` file.
    It is similar to the one we created for Hazelcast:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将部署配置作为新任务添加到`playbook.yml`文件中。它与我们为Hazelcast创建的配置类似：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The configuration is very similar to what we saw in the case of Hazelcast. One
    difference is that this time, we don't download the JAR from the internet, but
    we copy it from our filesystem. The other difference is that we restart the service
    using the Ansible handler. That's because we want to restart the calculator each
    time a new version is copied.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 配置与我们在Hazelcast案例中看到的非常相似。唯一的不同之处是，这次我们不会从互联网上下载JAR文件，而是从我们的文件系统中复制它。另一个不同之处是，我们使用Ansible处理器重新启动服务。这样做是因为我们希望每次复制新版本时重新启动计算器。
- en: 'Before we start it all together, we also need to define `calculator.sh`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一起开始之前，我们还需要定义`calculator.sh`：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When everything is prepared, we will use this configuration to start the complete
    system.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切准备就绪时，我们将使用此配置来启动完整的系统。
- en: Running the deployment
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行部署
- en: 'As always, we can execute the playbook using the `ansible-playbook` command.
    Before that, we need to build the calculator project with Gradle:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可以使用`ansible-playbook`命令执行playbook。在此之前，我们需要使用Gradle构建计算器项目：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the successful deployment, the service should be available, and we can
    check that it's working at `http://192.168.64.13:8080/sum?a=1&b=2` (the IP address
    should be the same one that we have in our inventory as `web2`). As expected,
    it should return `3` as the output.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 部署成功后，服务应该可以使用，我们可以通过`http://192.168.64.13:8080/sum?a=1&b=2`检查其是否正常工作（IP地址应该与我们的库存中标记为`web2`的IP地址相同）。如预期，它应该返回`3`作为输出。
- en: Note that we have configured the whole environment by executing one command.
    What's more, if we need to scale the service, then it's enough to add a new server
    to the inventory and rerun the `ansible-playbook` command. Also, note that we
    could package it as an Ansible role and upload it to GitHub, and from then on,
    everyone could run the same system on their Ubuntu servers. That's the power of
    Ansible!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过执行一条命令配置了整个环境。更重要的是，如果我们需要扩展服务，只需将新服务器添加到库存中并重新运行`ansible-playbook`命令。另外，注意我们可以将其打包为Ansible角色并上传到GitHub，从此每个人都可以在他们的Ubuntu服务器上运行相同的系统。这就是Ansible的强大之处！
- en: We have shown how to use Ansible for environmental configuration and application
    deployment. The next step is to use Ansible with Docker and Kubernetes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用Ansible进行环境配置和应用部署。接下来的步骤是将Ansible与Docker和Kubernetes结合使用。
- en: Ansible with Docker and Kubernetes
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible与Docker和Kubernetes
- en: 'As you may have noticed, Ansible and Docker (along with Kubernetes) address similar software
    deployment issues:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Ansible和Docker（以及Kubernetes）都解决了类似的软件部署问题：
- en: '**Environmental configuration**: Both Ansible and Docker provide a way to configure
    the environment; however, they use different means. While Ansible uses scripts
    (encapsulated inside the Ansible modules), Docker encapsulates the whole environment
    inside a container.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境配置**：Ansible和Docker都提供了配置环境的方法；然而，它们采用了不同的手段。Ansible通过脚本（封装在Ansible模块内）来实现，而Docker则将整个环境封装在一个容器内。'
- en: '**Dependencies**: Ansible provides a way to deploy different services on the
    same or different hosts and lets them be deployed together. Kubernetes has similar
    functionality, which allows for running multiple containers at the same time.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖关系**：Ansible提供了一种方式，在相同或不同的主机上部署不同的服务，并允许它们一起部署。Kubernetes具有类似的功能，可以同时运行多个容器。'
- en: '**Scalability**: Ansible helps to scale the services providing the inventory
    and host groups. Kubernetes has similar functionality to automatically increase
    or decrease the number of running containers.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Ansible通过提供库存和主机组来帮助扩展服务。Kubernetes具有类似的功能，能够自动增加或减少运行中的容器数量。'
- en: '`playbook.yml`. In the case of Docker and Kubernetes, we have `Dockerfile` for
    the environment and `deployment.yml` for the dependencies and scaling.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook.yml`。在Docker和Kubernetes的情况下，我们有用于环境的`Dockerfile`和用于依赖关系与扩展的`deployment.yml`。'
- en: '**Simplicity**: Both tools are very simple to use and provide a way to set
    up the whole running environment with a configuration file and just one command execution.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简易性**：这两种工具都非常简单易用，通过配置文件和仅仅一条命令执行就能设置整个运行环境。'
- en: If we compare the tools, Docker does a little more, since it provides isolation,
    portability, and a kind of security. We could even imagine using Docker/Kubernetes
    without any other configuration management tools. Then, *why do we need Ansible
    at all?*
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对比这些工具，Docker做得更多，因为它提供了隔离性、可移植性以及某种程度的安全性。我们甚至可以设想，使用Docker/Kubernetes而不依赖任何其他配置管理工具。那么，*我们为什么还需要Ansible呢？*
- en: Benefits of Ansible
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible的优点
- en: 'Ansible may seem redundant; however, it brings additional benefits to the delivery
    process, which are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可能显得有些冗余；然而，它为交付过程带来了额外的好处，具体如下：
- en: '**Docker environment**: The Docker/Kubernetes hosts themselves have to be configured
    and managed. Every container is ultimately running on Linux machines, which need
    kernel patching, Docker Engine updates, and network configuration, for example.
    What''s more, there may be different server machines with different Linux distributions,
    and the responsibility of Ansible is to make sure everything is up and running.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker环境**：Docker/Kubernetes主机本身需要配置和管理。每个容器最终都在Linux机器上运行，这些机器需要进行内核补丁、Docker引擎更新和网络配置等工作。而且，可能有不同的服务器机器使用不同的Linux发行版，Ansible的责任是确保一切正常运行。'
- en: '**Non-Dockerized applications**: Not everything is run inside a container.
    If part of the infrastructure is containerized and part is deployed in the standard
    way or in the cloud, then Ansible can manage it all with the playbook configuration
    file. There may be different reasons for not running an application as a container;
    for example, performance, security, specific hardware requirements, or working
    with the legacy software.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非 Docker 化应用**：并非所有内容都运行在容器中。如果部分基础设施已经容器化，而部分则采用传统方式或部署在云中，那么 Ansible 可以通过执行剧本配置文件来管理这一切。没有将应用程序作为容器运行可能有不同的原因；例如，性能、安全性、特定的硬件要求或与遗留软件的兼容性。'
- en: '**Inventory**: Ansible offers a very friendly way to manage the physical infrastructure
    by using inventories, which store information about all the servers. It can also
    split the physical infrastructure into different environments—production, testing,
    and development.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清单**：Ansible 提供了一种非常友好的方式来通过清单管理物理基础设施，清单中存储着所有服务器的信息。它还可以将物理基础设施分为不同的环境——生产、测试和开发。'
- en: '**Cloud provisioning**: Ansible can be responsible for provisioning Kubernetes
    clusters or installing Kubernetes in the cloud; for example, we can imagine integration
    tests in which the first step is to create a Kubernetes cluster on **Google Cloud
    Platform** (**GCP**) (only then can we deploy the whole application and perform
    the testing process).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云资源配置**：Ansible 可以负责配置 Kubernetes 集群或在云中安装 Kubernetes；例如，我们可以设想一种集成测试，其中第一步是在
    **Google Cloud Platform**（**GCP**）上创建 Kubernetes 集群（只有在此之后，我们才能部署整个应用程序并执行测试过程）。'
- en: '**GUI**: Ansible offers GUI managers (commercial Ansible Tower and open source
    AWX), which aim to improve the experience of infrastructure management.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI**：Ansible 提供了图形化管理工具（商业版 Ansible Tower 和开源版 AWX），旨在提升基础设施管理的体验。'
- en: '**Improving the testing process**: Ansible can help with integration and acceptance
    testing, as it can encapsulate testing scripts.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进测试过程**：Ansible 可以帮助进行集成测试和验收测试，因为它可以封装测试脚本。'
- en: 'We can look at Ansible as the tool that takes care of the infrastructure, while
    Docker and Kubernetes are tools that take care of the environmental configuration
    and clustering. An overview is presented in the following diagram:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把 Ansible 看作是负责基础设施的工具，而 Docker 和 Kubernetes 是负责环境配置和集群的工具。下图展示了一个概览：
- en: '![Figure 7.2 – Ansible as the infrastructure manager'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – Ansible 作为基础设施管理器'
- en: '](img/B18223_07_02.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_07_02.jpg)'
- en: Figure 7.2 – Ansible as the infrastructure manager
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Ansible 作为基础设施管理器
- en: 'Ansible manages the infrastructure: **Kubernetes clusters**, **Docker servers**,
    **Docker registries**, **servers without Docker**, and **cloud providers**. It
    also takes care of the physical location of the servers. Using the inventory host
    groups, it can link the web services to the databases that are close to their
    geographic locations.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 管理基础设施：**Kubernetes 集群**、**Docker 服务器**、**Docker 镜像库**、**没有 Docker 的服务器**以及
    **云服务提供商**。它还负责服务器的物理位置。通过使用清单主机组，它可以将 Web 服务与靠近其地理位置的数据库连接。
- en: Let's look at how we can use Ansible to install Docker on a server and deploy
    a sample application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用 Ansible 在服务器上安装 Docker 并部署一个示例应用程序。
- en: The Ansible Docker playbook
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible Docker 执行剧本
- en: Ansible integrates with Docker smoothly, because it provides a set of Docker-dedicated
    modules. If we create an Ansible playbook for Docker-based deployment, then the
    first task is to make sure that the Docker Engine is installed on every machine.
    Then, it should run a container using Docker.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 与 Docker 平稳集成，因为它提供了一套专门为 Docker 设计的模块。如果我们为基于 Docker 的部署创建 Ansible
    执行剧本，那么第一项任务是确保 Docker 引擎已安装在每台机器上。然后，它应该使用 Docker 运行一个容器。
- en: First, let's install Docker on an Ubuntu server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 Ubuntu 服务器上安装 Docker。
- en: Installing Docker
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'We can install the Docker Engine by using the following task in the Ansible
    playbook:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下任务在 Ansible 执行剧本中安装 Docker 引擎：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Information
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The playbook looks slightly different for each operating system. The one presented
    here is for Ubuntu 20.04.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的执行脚本略有不同。这里展示的是用于 Ubuntu 20.04 的版本。
- en: This configuration installs Docker and Docker Python tools (needed by Ansible).
    Note that we used a new Ansible syntax, `loop`, in order to make the playbook
    more concise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置安装了 Docker 和 Docker Python 工具（Ansible 所需）。请注意，我们使用了新的 Ansible 语法 `loop`，以便让剧本更加简洁。
- en: When Docker is installed, we can add a task that will run a Docker container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 后，我们可以添加一个任务来运行 Docker 容器。
- en: Running Docker containers
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Docker 容器
- en: 'Running Docker containers is done with the use of the `docker_container` module,
    and it looks as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Docker 容器通过使用`docker_container`模块来完成，具体如下所示：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Information
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read more about all of the options of the `docker_container` module
    at [https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html](https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读更多有关`docker_container`模块的所有选项，网址为[https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html](https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html)。
- en: With the two playbooks presented previously, we configured the Hazelcast server
    using Docker. Note that this is very convenient because we can run the same playbook
    on multiple (Ubuntu) servers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面介绍的两个 playbook 中，我们使用 Docker 配置了 Hazelcast 服务器。请注意，这非常方便，因为我们可以在多个（Ubuntu）服务器上运行相同的
    playbook。
- en: Now, let's take a look at how Ansible can help with Kubernetes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看 Ansible 如何帮助 Kubernetes。
- en: The Ansible Kubernetes playbook
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible Kubernetes Playbook
- en: 'Similar to Docker, Ansible can help with Kubernetes. When you have your Kubernetes
    cluster configured, then you can create Kubernetes resources using the Ansible `k8s` module.
    Here''s a sample Ansible task to create a namespace in Kubernetes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Docker，Ansible 也可以帮助管理 Kubernetes。当您的 Kubernetes 集群配置完成后，您可以使用 Ansible 的`k8s`模块创建
    Kubernetes 资源。以下是一个示例 Ansible 任务，用于在 Kubernetes 中创建命名空间：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The configuration here makes sure a namespace called `my-namespace` is created
    in the Kubernetes cluster.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的配置确保在 Kubernetes 集群中创建一个名为`my-namespace`的命名空间。
- en: Information
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can find more information about the Ansible `k8s` module at [https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_module.html](https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_module.html).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_module.html](https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_module.html)找到更多关于
    Ansible `k8s`模块的信息。
- en: We have covered configuration management with Ansible, which is a perfect approach
    if your deployment environment consists of bare-metal servers. You can also use
    Ansible with cloud providers, and there are a number of modules dedicated to that
    purpose. For example, `amazon.aws.ec2_instance` lets you create and manage AWS
    EC2 instances. However, when it comes to the cloud, there are better solutions.
    Let's see what they are and how to use them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了使用 Ansible 进行配置管理，这在您的部署环境由裸金属服务器构成时是一个完美的方案。您也可以将 Ansible 与云服务提供商一起使用，并且有许多专门为此目的设计的模块。例如，`amazon.aws.ec2_instance`
    让您可以创建和管理 AWS EC2 实例。然而，云计算有更好的解决方案。让我们看看它们是什么，以及如何使用它们。
- en: Introducing IaC
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 IaC
- en: IaC is the process of managing and provisioning computing resources instead
    of physical hardware configuration. It is mostly associated with the cloud approach,
    in which you can request the necessary infrastructure in a programmable manner.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: IaC（基础设施即代码）是管理和提供计算资源的过程，取代了物理硬件配置。它通常与云计算方法相关，您可以以可编程的方式请求所需的基础设施。
- en: 'Managing computer infrastructure was always a hard, time-consuming, and error-prone
    activity. You had to manually place the hardware, connect the network, install
    the operating system, and take care of its updates. Together with the cloud, things
    became simple; all you had to do was to write a few commands or make a few clicks
    in the web UI. IaC goes one step further, as it allows you to specify in a declarative
    manner what infrastructure you need. To understand it better, let''s take a look
    at the following diagram:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 管理计算机基础设施一直是一个艰巨、耗时且容易出错的任务。您必须手动放置硬件、连接网络、安装操作系统并维护其更新。随着云计算的出现，一切变得简单；您只需要写几个命令或在
    Web UI 中点击几下即可。IaC 更进一步，它允许您以声明的方式指定所需的基础设施。为了更好地理解它，让我们看看下面的图示：
- en: '![Figure 7.3 – IaC'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – IaC'
- en: '](img/B18223_07_03.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_07_03.jpg)'
- en: Figure 7.3 – IaC
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – IaC
- en: You prepare a declarative description of your infrastructure, for example, that
    you need three servers, a Kubernetes cluster, and a load balancer. Then, you pass
    this configuration to a tool that uses a cloud-specific API (for example, the
    AWS API) in order to make sure the infrastructure is as requested. Note that you
    should store the infrastructure configuration in the source code repository, and
    you can create multiple identical environments from the same configuration.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好基础设施的声明性描述，例如，你需要三台服务器，一个 Kubernetes 集群和一个负载均衡器。然后，你将这个配置传递给一个工具，该工具使用云特定的
    API（例如，AWS API），以确保基础设施符合要求。请注意，你应将基础设施配置存储在源代码仓库中，并且可以从相同的配置创建多个相同的环境。
- en: You can see that the IaC idea is very similar to configuration management; however,
    while configuration management makes sure your software is configured as specified,
    IaC makes sure that your infrastructure is configured as specified.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，IaC 的概念与配置管理非常相似；然而，配置管理确保你的软件按指定方式配置，而 IaC 确保你的基础设施按指定方式配置。
- en: Now, let's look into the benefits of using IaC.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看使用 IaC 的好处。
- en: Benefits of IaC
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IaC 的好处
- en: 'There are a number of benefits that infrastructure brings into all DevOps activities.
    Let''s walk through the most important ones:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施为所有 DevOps 活动带来了许多好处。我们来逐一了解其中最重要的一些：
- en: '**Speed**: Creating the whole infrastructure means nothing more than running
    a script, which significantly reduces the time needed before we can start deploying
    the applications.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：创建整个基础设施不过是运行一个脚本，这大大缩短了我们可以开始部署应用程序的时间。'
- en: '**Cost reduction**: Automating the infrastructure provisioning reduces the
    number of DevOps team members required to operate server environments.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本降低**：自动化基础设施的提供减少了操作服务器环境所需的 DevOps 团队成员数量。'
- en: '**Consistency**: IaC configuration files become the single point of truth,
    so they guarantee that every created environment is exactly the same.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：IaC 配置文件成为唯一的真实来源，因此它们确保每个创建的环境都是完全相同的。'
- en: '**Risk reduction**: Infrastructure configuration is stored in the source code
    repository and follows the standard code review process, which reduces the probability
    of making a mistake.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险降低**：基础设施配置存储在源代码仓库中，并遵循标准的代码审查流程，这降低了出错的概率。'
- en: '**Collaboration**: Multiple people can share the code and work on the same
    configuration files, which increases work efficiency.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：多人可以共享代码并在相同的配置文件上工作，从而提高工作效率。'
- en: I hope these points have convinced you that IaC is a great approach. Let's now
    look into the tools you can use for IaC.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些要点已经让你相信 IaC 是一种很好的方法。现在，让我们来看看你可以使用的 IaC 工具。
- en: Tools for IaC
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IaC 工具
- en: 'When it comes to IaC, there are a number of tools you can use. The choice depends
    on the cloud provider you use and on your own preferences. Let''s walk through
    the most popular solutions:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到 IaC 时，有许多工具可以使用。选择取决于你所使用的云服务提供商和你自己的偏好。我们来看看最流行的解决方案：
- en: '**Terraform**: The most popular IaC tool on the market. It''s open source and
    uses plugin-based modules called *providers* to support different infrastructure
    APIs. Currently, more than 1,000 Terraform providers exist, including AWS, Azure,
    GCP, and DigitalOcean.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform**：市场上最流行的 IaC 工具。它是开源的，使用基于插件的模块，称为 *providers*，来支持不同的基础设施 API。目前，已有超过
    1,000 个 Terraform providers，包括 AWS、Azure、GCP 和 DigitalOcean。'
- en: '**Cloud provider specific**: Each major cloud provider has its own IaC tool:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云服务提供商特定**：每个主要的云服务提供商都有自己的 IaC 工具：'
- en: '**AWS CloudFormation**: An Amazon service that allows you to specify AWS resources
    in the form of YAML or JSON template files'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CloudFormation**：一项由亚马逊提供的服务，允许你以 YAML 或 JSON 模板文件的形式指定 AWS 资源。'
- en: '**Azure Resource Manager** (**ARM**): A Microsoft Azure service that allows
    you to create and manage Azure resources with the use of ARM template files'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 资源管理器**（**ARM**）：一项微软 Azure 服务，允许你使用 ARM 模板文件创建和管理 Azure 资源。'
- en: '**Google Cloud Deployment Manager**: A Google service that allows you to manage
    Google Cloud Platform resources with the use of YAML files'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud 部署管理器**：一项由谷歌提供的服务，允许你使用 YAML 文件管理 Google Cloud Platform 资源。'
- en: '**General configuration management**: Ansible, Chef, and Puppet all provide
    dedicated modules to provision the infrastructure in the most popular cloud solutions.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用配置管理**：Ansible、Chef 和 Puppet 都提供专门的模块来为最流行的云解决方案提供基础设施。'
- en: '**Pulumi**: A very flexible tool that allows you to specify the desired infrastructure
    using general-purpose programming languages, such as JavaScript, Python, Go, or
    C#.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pulumi**：一个非常灵活的工具，允许你使用通用编程语言（如 JavaScript、Python、Go 或 C#）来指定所需的基础设施。'
- en: '**Vagrant**: Usually associated with virtual machine management, it provides
    a number of plugins to provision infrastructure using AWS and other cloud providers.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vagrant**：通常与虚拟机管理相关，提供了一些插件，利用 AWS 等云提供商来配置基础设施。'
- en: Of all the solutions mentioned, Terraform is by far the most popular. That is
    why we'll spend some more time understanding how it works.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有提到的解决方案中，Terraform 是最受欢迎的。因此，我们将花一些时间来理解它是如何工作的。
- en: Introduction to Terraform
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 介绍
- en: Terraform is an open source tool created and maintained by HashiCorp. It allows
    you to specify your infrastructure in the form of human-readable configuration
    files. Similar to Ansible, it works in a declarative manner, which means that
    you specify the expected outcome, and Terraform makes sure your environment is
    created as specified.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个由 HashiCorp 创建并维护的开源工具。它允许你以人类可读的配置文件形式指定你的基础设施。与 Ansible 类似，它以声明式的方式工作，这意味着你指定期望的结果，而
    Terraform 确保你的环境按照指定方式创建。
- en: Before we dive into a concrete example, let's spend a moment understanding how
    Terraform works.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体示例之前，先花点时间了解一下 Terraform 是如何工作的。
- en: Understanding Terraform
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Terraform
- en: 'Terraform reads a configuration file and adjusts the cloud resources accordingly.
    Let''s look at the following diagram, which presents this process:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 读取配置文件并相应地调整云资源。让我们看一下下面的图示，展示了这个过程：
- en: '![Figure 7.4 – Terraform workflow'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – Terraform 工作流](img/B18223_07_04.jpg)'
- en: '](img/B18223_07_04.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_07_04.jpg)'
- en: Figure 7.4 – Terraform workflow
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Terraform 工作流
- en: A user creates **Configuration File** and starts the **Terraform** tool. Then,
    **Terraform** checks the **Terraform State** and uses **Terraform Provider** to
    translate the declarative configuration file into the requests called against
    **Target API**, which is specific for the given cloud provider. As an example,
    we can think of a configuration file that defines three AWS EC2 instances. Terraform
    uses the AWS provider, which executes requests to the AWS API to make sure that
    three AWS EC2 instances are created.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 用户创建 **配置文件** 并启动 **Terraform** 工具。然后，**Terraform** 检查 **Terraform 状态** 并使用
    **Terraform 提供者** 将声明式配置文件转换为针对 **目标 API** 的请求，这个 API 是特定于给定云提供商的。举例来说，我们可以考虑一个定义三个
    AWS EC2 实例的配置文件。Terraform 使用 AWS 提供者，执行请求到 AWS API，确保创建了三个 AWS EC2 实例。
- en: Information
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: There are more than 1,000 Terraform providers available, and you can browse
    them via the Terraform Registry at [https://registry.terraform.io/](https://registry.terraform.io/).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过 1,000 个 Terraform 提供者可用，你可以通过 Terraform 注册表浏览它们，网址是 [https://registry.terraform.io/](https://registry.terraform.io/)。
- en: 'The Terraform workflow always consists of three stages:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 工作流始终包括三个阶段：
- en: '**Write**: User defines cloud resources as a configuration file.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Write**：用户将云资源定义为配置文件。'
- en: '**Plan**: Terraform compares the configuration file with the current state
    and prepares the execution plan.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Plan**：Terraform 比较配置文件与当前状态，并准备执行计划。'
- en: '**Apply**: User approves the plan and Terraform executes the planned operations
    using the cloud API.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apply**：用户批准计划，Terraform 使用云 API 执行计划中的操作。'
- en: This approach is very convenient because, with the plan stage, we can always
    check what Terraform is going to change in our infrastructure, before actually
    applying the change.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常方便，因为在计划阶段，我们可以始终检查 Terraform 在实际应用更改之前，将会对我们的基础设施进行哪些更改。
- en: Now that we understand the idea behind Terraform, let's look at how it all works
    in practice, starting from the Terraform installation process.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了 Terraform 背后的理念，让我们从 Terraform 的安装过程开始，看看它在实际中是如何工作的。
- en: Installing Terraform
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Terraform
- en: 'The installation process depends on the operating system. In the case of Ubuntu,
    you can execute the following commands:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程取决于操作系统。以 Ubuntu 为例，你可以执行以下命令：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Information
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can find the installation guides for all the operating systems on the official
    Terraform website, at [https://www.terraform.io/downloads](https://www.terraform.io/downloads).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Terraform 官方网站上找到所有操作系统的安装指南，网址是 [https://www.terraform.io/downloads](https://www.terraform.io/downloads)。
- en: 'After the installation process, we can verify that the `terraform` command
    works correctly:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，我们可以验证`terraform`命令是否正常工作：
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After Terraform is configured, we can move to the Terraform example.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 配置完成后，我们可以进入 Terraform 示例。
- en: Using Terraform
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform
- en: As an example, let's use Terraform to provision an AWS EC2 instance. For this
    purpose, we need to first configure AWS.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们使用 Terraform 来配置一个 AWS EC2 实例。为此，我们需要首先配置 AWS。
- en: Configuring AWS
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 AWS
- en: 'To access AWS from your machine, you will need the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的机器访问 AWS，你需要以下内容：
- en: An AWS account
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户
- en: The AWS CLI installed
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 AWS CLI
- en: Information
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: 'You can create a free AWS account at [https://aws.amazon.com/free](https://aws.amazon.com/free).
    To install the AWS CLI tool, please check the following instructions: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://aws.amazon.com/free](https://aws.amazon.com/free) 创建一个免费的 AWS
    账户。要安装 AWS CLI 工具，请查看以下说明：[https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)。
- en: 'Let''s configure the AWS CLI with the following command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令配置 AWS CLI：
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The AWS command prompts your AWS access key ID and AWS secret access key.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 命令会提示你输入 AWS 访问密钥 ID 和 AWS 秘密访问密钥。
- en: Information
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For instructions on how to create an AWS access key pair, please visit [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何创建 AWS 访问密钥对的说明，请访问 [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds)。
- en: After these steps, access to your AWS account is configured and we can start
    playing with Terraform.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你的 AWS 账户访问已配置，我们可以开始使用 Terraform 进行操作。
- en: Writing Terraform configuration
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Terraform 配置
- en: 'In a fresh directory, let''s create the `main.tf` file and add the following
    content:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新目录中，让我们创建 `main.tf` 文件并添加以下内容：
- en: '[PRE36]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding configuration, we defined the following parts:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，我们定义了以下部分：
- en: The Terraform tool version should be at least `1.1`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Terraform 工具版本应至少为 `1.1`。
- en: 'The configuration uses the `hashicorp/aws` provider:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置使用 `hashicorp/aws` 提供程序：
- en: The provider version needs to be at least `3.74`.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供程序版本需要至少为 `3.74`。
- en: Terraform will automatically download it from the **Terraform Registry**.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 将自动从 **Terraform Registry** 下载它。
- en: The credentials for the `aws` provider are stored in the `default` location
    created by the AWS CLI.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aws` 提供程序的凭证存储在 AWS CLI 创建的 `default` 位置中。'
- en: The provider creates all resources in the `us-east-1` region.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供程序在 `us-east-1` 区域创建所有资源。
- en: The provider creates `aws_instance` (an AWS EC2 instance) named `my_instance`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供程序创建一个名为 `my_instance` 的 `aws_instance`（AWS EC2 实例）。
- en: An EC2 instance is created from `ami-04505e74c0741db8d` (Ubuntu 20.04 LTS in
    the `us-east-1` region).
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 EC2 实例是从 `ami-04505e74c0741db8d`（`us-east-1` 区域中的 Ubuntu 20.04 LTS）创建的。
- en: The instance type is `t2.micro`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例类型为 `t2.micro`。
- en: You can see that the whole configuration is declarative. In other words, we
    define what we want, not the algorithm for how to achieve it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到整个配置是声明式的。换句话说，我们定义我们想要的目标，而不是如何实现它的算法。
- en: When the configuration is created, we need to download the required provider
    from the Terraform Registry.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置创建时，我们需要从 Terraform Registry 下载所需的提供程序。
- en: Initializing Terraform configuration
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化 Terraform 配置
- en: 'Let''s execute the following command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下命令：
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command downloads all required providers and stores them in the `.terraform`
    directory. Now, let's finally apply the Terraform configuration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会下载所有必需的提供程序并将它们存储在 `.terraform` 目录中。现在，让我们最终应用 Terraform 配置。
- en: Applying Terraform configuration
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用 Terraform 配置
- en: 'Before we make any Terraform changes, it''s good to first execute `terraform
    plan` to check what changes stand ahead of us:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何 Terraform 更改之前，最好先执行 `terraform plan` 来检查我们即将面临的更改：
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that by applying the configuration, we will create a resource in
    our infrastructure as described in the console output.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过应用配置，我们将在基础设施中创建一个资源，正如控制台输出所描述的那样。
- en: 'Let''s now apply our configuration:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用我们的配置：
- en: '[PRE39]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After confirming the change, you should see a lot of logs and the last `Apply
    complete!` message, which means that our infrastructure is created.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认更改后，你应该会看到大量日志，最后的 `Apply complete!` 消息，表示我们的基础设施已经创建完成。
- en: Now, let's verify that everything is as expected.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们验证一切是否如预期。
- en: Verifying the infrastructure
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证基础设施
- en: 'From the Terraform perspective, we can execute the following command to see
    the state of our infrastructure:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Terraform 的角度来看，我们可以执行以下命令来查看我们基础设施的状态：
- en: '[PRE40]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This prints all the information about the resource we created.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出我们所创建资源的所有信息。
- en: Information
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'Terraform, the same as Ansible, favors idempotent operations. That is why,
    if we execute `terraform plan` or `terraform apply` again, nothing will change.
    You will only see the following message: `No changes. Your infrastructure matches
    the configuration`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Ansible 一样，Terraform 倾向于进行幂等操作。这就是为什么，如果我们再次执行 `terraform plan` 或 `terraform
    apply`，什么也不会改变。你只会看到以下消息：`No changes. Your infrastructure matches the configuration`。
- en: 'We can now verify that our AWS EC2 instance is really created. Since we already
    installed the AWS CLI, we can check it with the following command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以验证我们的 AWS EC2 实例是否真正创建了。由于我们已经安装了 AWS CLI，我们可以使用以下命令检查：
- en: '[PRE41]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you prefer, you can also check in the AWS web console that the instance is
    created.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以在 AWS 网络控制台中检查实例是否已创建。
- en: '![Figure 7.5 – AWS EC2 instance created with Terraform'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 使用 Terraform 创建的 AWS EC2 实例'
- en: '](img/B18223_07_05.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_07_05.jpg)'
- en: Figure 7.5 – AWS EC2 instance created with Terraform
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 使用 Terraform 创建的 AWS EC2 实例
- en: We just verified that our Terraform configuration works as expected.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚验证了我们的 Terraform 配置按预期工作。
- en: Tip
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When working together with Ansible, we can make use of Ansible's dynamic inventories
    and let Ansible discover created EC2 instances. Read more at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Ansible 一起使用时，我们可以利用 Ansible 的动态清单，让 Ansible 发现已创建的 EC2 实例。详情请参阅 [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html)。
- en: To make our example complete, let's also see how to delete created resources.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的示例完整，让我们也来看看如何删除已创建的资源。
- en: Destroying the infrastructure
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 销毁基础设施
- en: 'Let''s remove the resources we created with the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令删除我们创建的资源：
- en: '[PRE42]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After the user confirmation, Terraform removed all the resources. You can check
    that our AWS EC2 instance does not exist anymore.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户确认之后，Terraform 删除了所有资源。你可以检查我们的 AWS EC2 实例是否已不存在。
- en: As the last thing with Terraform, let's see how it interacts with Kubernetes.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Terraform 的最后一步，让我们看看它是如何与 Kubernetes 交互的。
- en: Terraform and Kubernetes
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 和 Kubernetes
- en: 'There are two different use cases when it comes to the interaction between
    Terraform and Kubernetes:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Terraform 和 Kubernetes 之间的交互时，有两种不同的用例：
- en: Provisioning a Kubernetes cluster
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个 Kubernetes 集群
- en: Interacting with a Kubernetes cluster
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 集群交互
- en: Let's present them one by one.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一展示它们。
- en: Provisioning a Kubernetes cluster
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署一个 Kubernetes 集群
- en: 'Each of the major cloud providers offers managed Kubernetes clusters, and we
    can provision them using Terraform. The following Terraform providers are available:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主要的云提供商都提供托管的 Kubernetes 集群，我们可以使用 Terraform 来部署它们。以下是可用的 Terraform 提供程序：
- en: '**AWS**: This can provision clusters in Amazon **Elastic Kubernetes Service**
    (**EKS**).'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS**：这可以在 Amazon **Elastic Kubernetes Service** (**EKS**) 中部署集群。'
- en: '**Google**: This can provision clusters in **Google Kubernetes Engine** (**GKE**).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google**：这可以在 **Google Kubernetes Engine** (**GKE**) 中部署集群。'
- en: '**AzureRM**: This can provision clusters in **Azure Kubernetes Service** (**AKS**).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AzureRM**：这可以在 **Azure Kubernetes Service** (**AKS**) 中部署集群。'
- en: Using each of these providers is relatively simple and works similarly to how
    we described in our Terraform example.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些提供程序中的每一个都相对简单，且工作方式类似于我们在 Terraform 示例中描述的方式。
- en: Tip
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you install Kubernetes on bare-metal servers, you should use a configuration
    management tool, such as Ansible. To provision a cloud-managed Kubernetes cluster,
    you can use either Ansible or Terraform, but the former is a better fit.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在裸机服务器上安装 Kubernetes，你应该使用配置管理工具，例如 Ansible。要部署云托管的 Kubernetes 集群，你可以使用 Ansible
    或 Terraform，但前者更为适合。
- en: Let's also look at the second usage of Terraform with Kubernetes.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来看看 Terraform 在 Kubernetes 中的第二种使用方式。
- en: Interacting with a Kubernetes cluster
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 Kubernetes 集群交互
- en: Similar to Ansible, we can use Terraform to interact with a Kubernetes cluster.
    In other words, instead of applying Kubernetes configurations using the `kubectl`
    command, we can use a dedicated Terraform Kubernetes provider.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Ansible，我们可以使用 Terraform 与 Kubernetes 集群进行交互。换句话说，我们可以使用专门的 Terraform Kubernetes
    提供程序，而不是使用 `kubectl` 命令应用 Kubernetes 配置。
- en: 'A sample Terraform configuration to change Kubernetes resources looks as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例的 Terraform 配置，用于更改 Kubernetes 资源，示例如下：
- en: '[PRE43]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding configuration creates a namespace called `my-namespace` in the
    Kubernetes cluster.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置在 Kubernetes 集群中创建了一个名为 `my-namespace` 的命名空间。
- en: Tip
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'There are multiple ways you can interact with a Kubernetes cluster: `kubectl`,
    Ansible, Terraform, or some other tool. As a rule of thumb, I would always first
    try the simplest approach, which is the `kubectl` command, and only incorporate
    Ansible or Terraform if you have some special requirements; for example, you manage
    multiple Kubernetes clusters at the same time.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以与 Kubernetes 集群交互：`kubectl`、Ansible、Terraform 或其他工具。一般来说，我会首先尝试最简单的方法，即
    `kubectl` 命令，只有在有特殊需求时才会使用 Ansible 或 Terraform；例如，当你需要同时管理多个 Kubernetes 集群时。
- en: We covered the basics of Terraform, so let's wrap up this chapter with a short
    summary.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了 Terraform 的基础内容，现在让我们通过简短的总结来结束这一章。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered configuration management and IaC approaches, together with the
    related tooling. Note that whether you should use Ansible, Terraform, or neither
    of them inside your continuous delivery pipeline highly depends on your particular
    use case.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了配置管理和 IaC 方法，以及相关的工具。请注意，是否在你的持续交付管道中使用 Ansible、Terraform 或两者都不使用，取决于你的具体用例。
- en: Ansible shines when you have multiple bare-metal servers to manage, so if your
    release means making the same change into many servers at the same time, you'll
    most probably place Ansible commands inside your pipeline.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要管理多个裸金属服务器时，Ansible 的优势尤为明显。因此，如果你的发布意味着在多个服务器上同时进行相同的更改，你很可能会将 Ansible
    命令放入管道中。
- en: Terraform works best when you use the cloud. Therefore, if your release means
    making a change to your cloud infrastructure, then Terraform is the way to go.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 在你使用云时效果最佳。因此，如果你的发布意味着对云基础设施进行更改，那么 Terraform 是最佳选择。
- en: However, if your environment is only a single Kubernetes cluster, then there
    is nothing wrong with executing `kubectl` commands inside your pipeline.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的环境只有一个 Kubernetes 集群，那么在管道中执行 `kubectl` 命令并没有问题。
- en: 'The other takeaway points from this chapter are as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其他要点如下：
- en: Configuration management is the process of creating and applying the configurations
    of the application.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理是创建和应用应用程序配置的过程。
- en: Ansible is one of the most trending configuration management tools. It is agentless,
    and therefore, it requires no special server configuration.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 是最流行的配置管理工具之一。它不需要代理，因此不需要特殊的服务器配置。
- en: Ansible can be used with ad hoc commands, but the real power lies in Ansible
    playbooks.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 可以与临时命令一起使用，但真正的强大之处在于 Ansible playbook。
- en: The Ansible playbook is a definition of how the environment should be configured.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible playbook 是定义如何配置环境的文件。
- en: The purpose of Ansible roles is to reuse parts of playbooks.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 角色的目的是为了重用 playbook 的部分内容。
- en: Ansible Galaxy is an online service to share Ansible roles.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Galaxy 是一个在线服务，用于共享 Ansible 角色。
- en: IaC is a process of managing cloud resources.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IaC（基础设施即代码）是管理云资源的过程。
- en: Terraform is the most popular tool for IaC.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 是最流行的 IaC 工具。
- en: In the next chapter, we will wrap up the continuous delivery process and complete
    the final Jenkins pipeline.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将总结持续交付过程并完成最终的 Jenkins 管道。
- en: Exercises
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we covered the fundamentals of Ansible and ways to use it
    with Docker and Kubernetes. As exercises, try the following tasks:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讲解了 Ansible 的基础知识以及如何将它与 Docker 和 Kubernetes 一起使用。作为练习，请尝试以下任务：
- en: 'Create the server infrastructure and use Ansible to manage it:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务器基础设施并使用 Ansible 管理它：
- en: Connect a physical machine or run a VirtualBox machine to emulate the remote
    server.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接一台物理机器或运行 VirtualBox 虚拟机来模拟远程服务器。
- en: Configure SSH access to the remote machine (SSH keys).
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 SSH 访问远程机器（SSH 密钥）。
- en: Install Python on the remote machine.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程机器上安装 Python。
- en: Create an Ansible inventory with the remote machine.
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含远程机器的 Ansible 清单。
- en: Run the Ansible ad hoc command (with the `ping` module) to check that the infrastructure
    is configured correctly.
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Ansible 临时命令（使用`ping`模块）检查基础设施是否配置正确。
- en: 'Create a Python-based `hello world` web service and deploy it in a remote machine
    using Ansible playbook:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于 Python 的 `hello world` Web 服务，并使用 Ansible playbook 将其部署到远程机器：
- en: The service can look exactly the same as we described in the exercises for the
    chapter.
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务可以与我们在本章练习中描述的完全相同。
- en: Create a playbook that deploys the service into the remote machine.
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个剧本，将服务部署到远程机器。
- en: Run the `ansible-playbook` command and check whether the service was deployed.
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ansible-playbook`命令并检查服务是否已部署。
- en: 'Provision a GCP virtual machine instance using Terraform:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Terraform配置一个GCP虚拟机实例：
- en: Create an account in GCP.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCP中创建一个账户。
- en: Install the `gcloud` tool and authenticate (`gcloud init`).
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`gcloud`工具并进行身份验证（`gcloud init`）。
- en: Generate credentials and export them into the `GOOGLE_APPLICATION_CREDENTIALS`
    environment variable.
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成凭据并将其导出到`GOOGLE_APPLICATION_CREDENTIALS`环境变量中。
- en: Create a Terraform configuration that provisions a virtual machine instance.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Terraform配置文件，配置一个虚拟机实例。
- en: Apply the configuration using Terraform.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Terraform应用配置。
- en: Verify that the instance was created.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证实例是否已创建。
- en: Questions
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To verify your knowledge from this chapter, please answer the following questions:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你对本章内容的理解，请回答以下问题：
- en: What is configuration management?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是配置管理？
- en: What does it mean that the configuration management tool is agentless?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置管理工具是无代理（agentless）是什么意思？
- en: What are the three most popular configuration management tools?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个最流行的配置管理工具是什么？
- en: What is Ansible inventory?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Ansible清单（inventory）？
- en: What is the difference between Ansible ad hoc commands and playbooks?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible的临时命令和剧本有什么区别？
- en: What is an Ansible role?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Ansible角色？
- en: What is Ansible Galaxy?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Ansible Galaxy？
- en: What is IaC?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是IaC？
- en: What are the most popular tools for IaC?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些是最流行的IaC工具？
- en: Further reading
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To read more about configuration management and IaC, please refer to the following
    resources:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于配置管理和IaC的内容，请参考以下资源：
- en: '**Official Ansible documentation**: [https://docs.ansible.com/](https://docs.ansible.com/)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方Ansible文档**：[https://docs.ansible.com/](https://docs.ansible.com/)'
- en: '**Official Terraform documentation**: [https://www.terraform.io/docs](https://www.terraform.io/docs)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方Terraform文档**：[https://www.terraform.io/docs](https://www.terraform.io/docs)'
- en: '**Michael T. Nygard, Release It!**: ([https://pragprog.com/titles/mnee2/release-it-second-edition/](https://pragprog.com/titles/mnee2/release-it-second-edition/))'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Michael T. Nygard，《Release It!》**：([https://pragprog.com/titles/mnee2/release-it-second-edition/](https://pragprog.com/titles/mnee2/release-it-second-edition/))'
- en: '**Russ McKendrick, Learn Ansible**: ([https://www.packtpub.com/virtualization-and-cloud/learn-ansible](https://www.packtpub.com/virtualization-and-cloud/learn-ansible))'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Russ McKendrick，《Learn Ansible》**：([https://www.packtpub.com/virtualization-and-cloud/learn-ansible](https://www.packtpub.com/virtualization-and-cloud/learn-ansible))'
