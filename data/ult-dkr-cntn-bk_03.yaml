- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Mastering Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握容器
- en: In the previous chapter, you learned how to optimally prepare your working environment
    for the productive and frictionless use of Docker. In this chapter, we are going
    to get our hands dirty and learn about everything that is important to know when
    working with containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学会了如何为 Docker 的高效、无摩擦使用优化你的工作环境。本章我们将动手实践，了解在使用容器时必须掌握的一切重要知识。
- en: 'Here are the topics we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要涵盖的主题：
- en: Running the first container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: Starting, stopping, and removing containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、停止和删除容器
- en: Inspecting containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器
- en: Exec into a running container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入正在运行的容器
- en: Attaching to a running container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到一个正在运行的容器
- en: Retrieving container logs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取容器日志
- en: The anatomy of containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的结构
- en: 'After finishing this chapter, you will be able to do the following things:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做以下事情：
- en: Run, stop, and delete a container based on an existing image, such as Nginx,
    BusyBox, or Alpine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于现有镜像运行、停止和删除容器，例如 Nginx、BusyBox 或 Alpine
- en: List all containers on the system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出系统上所有的容器
- en: Inspect the metadata of a running or stopped container
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查运行中或停止的容器的元数据
- en: Retrieve the logs produced by an application running inside a container
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取容器内运行的应用程序产生的日志
- en: Run a process such as `/bin/sh` in an already-running container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已经运行的容器中运行像 `/bin/sh` 这样的进程
- en: Attach a terminal to an already-running container
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接终端到一个已运行的容器
- en: Explain in your own words, to an interested layman, the underpinnings of a container
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用你自己的话向一位感兴趣的外行解释容器的基础原理
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you should have Docker Desktop installed on your Linux workstation,
    macOS, or Windows PC. If you are on an older version of Windows or are using Windows
    10 Home Edition, then you should have Docker Toolbox installed and ready to use.
    On macOS, use the Terminal application, and on Windows, use the PowerShell console
    or Git Bash to try out the commands you will be learning.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你应该已经在你的 Linux 工作站、macOS 或 Windows 电脑上安装了 Docker Desktop。如果你使用的是旧版本的 Windows
    或 Windows 10 家庭版，你应该安装并准备好使用 Docker Toolbox。在 macOS 上，使用终端应用程序，在 Windows 上，使用
    PowerShell 控制台或 Git Bash 来尝试你将学习的命令。
- en: Running the first container
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: 'Before we start, we want to make sure that Docker is installed correctly on
    your system and ready to accept your commands. Open a new terminal window and
    type in the following command (note: do not type the `$` sign, as it is a placeholder
    for your prompt):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要确保 Docker 已经正确安装并准备好接受你的命令。打开一个新的终端窗口，输入以下命令（注意：不要输入 `$` 符号，它只是你的提示符占位符）：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If everything works correctly, you should see the version of the Docker client
    and server installed on your laptop output in the terminal. At the time of writing,
    it looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该在终端窗口中看到已安装的 Docker 客户端和服务器版本的输出。写作时，它是这样的：
- en: '![Figure 3.1 – Output of the docker version command](img/B19199_03_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – docker version 命令的输出](img/B19199_03_01.jpg)'
- en: Figure 3.1 – Output of the docker version command
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – docker version 命令的输出
- en: As you can see, I have version `20.10.20` installed on my MacBook Air M1 laptop.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我在我的 MacBook Air M1 笔记本上安装的版本是 `20.10.20`。
- en: If this doesn’t work for you, then something with your installation is not right.
    Please make sure that you have followed the instructions in the previous chapter
    on how to install Docker Desktop on your system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你不起作用，那么你的安装可能有问题。请确保你按照上一章的说明，正确地在系统上安装了 Docker Desktop。
- en: 'So, you’re ready to see some action. Please type the following command into
    your terminal window and hit the *Return* key:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在准备好看到一些操作了。请在终端窗口中输入以下命令并按下 *回车* 键：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run the preceding command the first time, you should see an output
    in your terminal window like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行前面的命令时，你应该在终端窗口看到类似这样的输出：
- en: '![Figure 3.2 – Running an Alpine container for the first time](img/B19199_03_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 第一次运行 Alpine 容器](img/B19199_03_02.jpg)'
- en: Figure 3.2 – Running an Alpine container for the first time
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 第一次运行 Alpine 容器
- en: 'Now that was easy! Let’s try to run the very same command again:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这么简单！我们再试一次运行同样的命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The second, third, or nth time you run the preceding command, you should see
    only this output in your terminal:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次、第三次或第 N 次运行前面的命令时，你应该只在终端看到以下输出：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Try to reason why the first time you run a command you see a different output
    than all of the subsequent times. But don’t worry if you can’t figure it out;
    we will explain the reasons in detail in the following sections of this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试推理为什么第一次运行命令时，输出与后续所有时间的输出不同。但如果你无法理解，也不用担心；我们将在本章接下来的部分详细解释原因。
- en: Starting, stopping, and removing containers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动、停止和删除容器
- en: 'You successfully ran a container in the previous section. Now, we want to investigate
    in detail what exactly happened and why. Let’s look again at the command we used:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一节成功地运行了一个容器。现在，我们想要详细探讨一下究竟发生了什么以及为什么发生。让我们再次看看我们使用的命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command contains multiple parts. First and foremost, we have the word `docker`.
    This is the name of the Docker `container`, which indicates the context we are
    working with, such as `container`, `image`, or `volume`. As we want to run a container,
    our context is `container`. Next is the actual command we want to execute in the
    given context, which is `run`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令包含多个部分。首先，最重要的是我们有单词 `docker`。这是 Docker `container` 的名称，表示我们正在使用的上下文，比如
    `container`、`image` 或 `volume`。由于我们想要运行一个容器，因此我们的上下文是 `container`。接下来是我们想要在给定上下文中执行的实际命令，即
    `run`。
- en: Let me recap – so far, we have `docker container run`, which means, “hey Docker,
    we want to run a container.”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我总结一下 – 到目前为止，我们有 `docker container run`，意思是，“嘿，Docker，我们想要运行一个容器。”
- en: Now we also need to tell Docker which container to run. In this case, this is
    the so-called `alpine` container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还需要告诉 Docker 运行哪个容器。在本例中，这是所谓的 `alpine` 容器。
- en: Alpine Linux
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux
- en: '`alpine` is a minimal Docker image based on Alpine Linux with a complete package
    index and is only about 5 MB in size. It is an official image supported by the
    Alpine open source project and Docker.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpine` 是基于 Alpine Linux 的最小 Docker 镜像，具有完整的软件包索引，大小仅约 5 MB。它是一个由 Alpine 开源项目和
    Docker 官方支持的镜像。'
- en: Finally, we need to define what kind of process or task will be executed inside
    the container when it is running. In our case, this is the last part of the command,
    `echo "``Hello World"`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义在容器运行时将执行的进程或任务。在我们的例子中，这是命令的最后一部分，`echo "``Hello World"`。
- en: 'The following figure may help you to get a better idea of the whole thing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示可能帮助你更好地理解整个过程：
- en: '![Figure 3.3 – docker run command explained](img/B19199_03_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 解释 docker run 命令](img/B19199_03_03.jpg)'
- en: Figure 3.3 – docker run command explained
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 解释 docker run 命令
- en: 'Now that we have understood the various parts of a command to run a container,
    let’s try to run another container with a different process executed inside it.
    Type the following command into your terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了运行容器的各种命令部分，让我们尝试运行另一个容器，并在其中执行不同的进程。在终端中输入以下命令：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see output in your terminal window similar to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端窗口中看到类似以下的输出：
- en: '![Figure 3.4 – Running the ping command inside a CentOS container](img/B19199_03_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 在 CentOS 容器中运行 ping 命令](img/B19199_03_04.jpg)'
- en: Figure 3.4 – Running the ping command inside a CentOS container
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 在 CentOS 容器中运行 ping 命令
- en: What changed is that this time, the container image we’re using is `centos`
    and the process we’re executing inside the `centos` container is `ping -c 5 127.0.0.1`,
    which pings the loopback IP address (`127.0.0.1`) five times until it stops.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更改的是这一次我们使用的容器镜像是 `centos`，并且在 `centos` 容器中执行的进程是 `ping -c 5 127.0.0.1`，它会 ping
    本地回环 IP 地址（`127.0.0.1`）五次，直到停止。
- en: CentOS
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CentOS
- en: '`centos` is the official Docker image for CentOS Linux, which is a community-supported
    distribution derived from sources freely provided to the public by Red Hat for
    **Red Hat Enterprise** **Linux** (**RHEL**).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`centos` 是 CentOS Linux 的官方 Docker 镜像，CentOS 是一个社区支持的发行版，源代码由 Red Hat 为 **Red
    Hat Enterprise** **Linux** (**RHEL**) 免费提供给公众。'
- en: 'Let’s analyze the output in detail. The first line is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析输出。第一行如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This tells us that Docker didn’t find an image named `centos:latest` in the
    local cache of the system. So, Docker knows that it has to pull the image from
    some registry where container images are stored. By default, your Docker environment
    is configured so that images are pulled from Docker Hub at `docker.io`. This is
    expressed by the second line, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 Docker 在本地缓存中没有找到名为 `centos:latest` 的镜像。因此，Docker 知道它必须从某个存储容器镜像的注册表中拉取镜像。默认情况下，你的
    Docker 环境配置为从 Docker Hub (`docker.io`) 拉取镜像。第二行表示如下：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next three lines of output are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行输出如下：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This tells us that Docker has successfully pulled the `centos:latest` image
    from Docker Hub. All of the subsequent lines of the output are generated by the
    process we ran inside the container, which is the `ping` tool in this case. If
    you have been attentive so far, then you might have noticed the `latest` keyword
    occurring a few times. Each image has a version (also called `tag`), and if we
    don’t specify a version explicitly, then Docker automatically assumes it is `latest`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 Docker 已经成功地从 Docker Hub 拉取了 `centos:latest` 镜像。输出的后续所有行都是我们在容器内运行的进程生成的，案例中的进程是
    `ping` 工具。如果你到目前为止一直很专心，你可能已经注意到 `latest` 关键字出现了好几次。每个镜像都有一个版本（也称为 `tag`），如果我们没有明确指定版本，Docker
    会默认认为它是 `latest`。
- en: If we run the preceding container again on our system, the first five lines
    of the output will be missing since, this time, Docker will find the container
    image cached locally and hence won’t have to download it first. Try it out and
    verify what I just told you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次在系统上运行之前的容器，输出的前五行将会缺失，因为这时 Docker 会发现容器镜像已在本地缓存，因此无需重新下载。试试看，验证一下我刚才说的内容。
- en: Running a random trivia question container
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行随机小知识问题容器
- en: For the subsequent sections of this chapter, we need a container that runs continuously
    in the background and produces some interesting output. That’s why we have chosen
    an algorithm that produces random trivia questions. The API that produces free
    random trivia can be found at [http://jservice.io/](http://jservice.io/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的部分，我们需要一个持续在后台运行并输出一些有趣内容的容器。这就是为什么我们选择了一个生成随机小知识问题的算法。提供免费的随机小知识 API
    可以在 [http://jservice.io/](http://jservice.io/) 上找到。
- en: 'Now, the goal is to have a process running inside a container that produces
    a new random trivia question every 5 seconds and outputs the question to `STDOUT`.
    The following script will do exactly that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，目标是让一个进程在容器内运行，每隔 5 秒钟生成一个新的随机小知识问题，并将问题输出到 `STDOUT`。以下脚本将实现这一目标：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you are using PowerShell, the preceding command can be translated to the
    following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 PowerShell，前面的命令可以转换为以下内容：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `ConvertFrom-Json` cmdlet requires that the `Microsoft.PowerShell.Utility`
    module be imported. If it’s not already imported, you’ll need to run `Import-Module
    Microsoft.PowerShell.Utility` before running the script.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertFrom-Json` cmdlet 要求导入 `Microsoft.PowerShell.Utility` 模块。如果尚未导入，你需要在运行脚本之前执行
    `Import-Module Microsoft.PowerShell.Utility`。'
- en: 'Try it in a terminal window. Stop the script by pressing *Ctrl* + *C*. The
    output should look similar to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中尝试。通过按 *Ctrl* + *C* 停止脚本。输出应该类似于以下内容：
- en: '![Figure 3.5 – Output random trivia](img/B19199_03_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 输出随机小知识](img/B19199_03_05.jpg)'
- en: Figure 3.5 – Output random trivia
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 输出随机小知识
- en: 'Each response is a different trivia question. You may need to install `jq`
    first on your Linux, macOS, or Windows computer. `jq` is a handy tool often used
    to nicely filter and format JSON output, which increases its readability on screen.
    Use your package manager to install `jq` if needed. On Windows, using Chocolatey,
    the command would be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应都是一个不同的小知识问题。你可能需要首先在 Linux、macOS 或 Windows 电脑上安装 `jq`。`jq` 是一个非常方便的工具，常用于优雅地过滤和格式化
    JSON 输出，增加其在屏幕上的可读性。如果需要，使用你的包管理器安装 `jq`。在 Windows 上，使用 Chocolatey 时，命令如下：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And on a Mac using Homebrew, you would type the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上使用 Homebrew 时，你需要输入以下命令：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s run this logic in an `alpine` container. Since this is not just
    a simple command, we want to wrap the preceding script in a script file and execute
    that one. To make things simpler, I have created a Docker image called `fundamentalsofdocker/trivia`
    that contains all of the necessary logic so that we can just use it here. Later
    on, once we have introduced Docker images, we will analyze this container image
    further. For the moment, let’s just use it as is. Execute the following command
    to run the container as a background service. In Linux, a background service is
    also called a daemon:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `alpine` 容器中运行这段逻辑。因为这不仅仅是一个简单的命令，我们希望将前面的脚本封装在一个脚本文件中并执行它。为了简化操作，我创建了一个名为
    `fundamentalsofdocker/trivia` 的 Docker 镜像，包含了所有必要的逻辑，因此我们可以直接在这里使用它。稍后，当我们介绍 Docker
    镜像时，我们将进一步分析这个容器镜像。现在，让我们直接使用它。执行以下命令将容器作为后台服务运行。在 Linux 中，后台服务也称为守护进程（daemon）：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are using the `\` character to allow line breaks in a single logical command
    that does not fit on a single line. This is a feature of the shell script we use.
    In PowerShell, use the backtick (`` ` ``) instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `\` 字符来允许在单个逻辑命令中换行，因为它在一行上无法完全显示。这是我们使用的 Shell 脚本的一个特性。在 PowerShell 中，使用反引号（``
    ` ``）代替。
- en: Also note that on `zsh`, you may have to press *Shift* + *Enter* instead of
    only *Enter* after the `\` character to start a new line. Otherwise, you will
    get an error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在 `zsh` 中，你可能需要按 *Shift* + *Enter*，而不仅仅是 *Enter*，在 `\` 字符后开始新的一行。否则，你会收到错误信息。
- en: In the preceding expression, we have used two new command-line parameters, `--detach`
    and `--name`. Now, `--detach` tells Docker to run the process in the container
    as a Linux daemon.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，我们使用了两个新的命令行参数，`--detach` 和 `--name`。现在，`--detach` 告诉 Docker 将容器中的进程作为
    Linux 守护进程运行。
- en: The `--name` parameter, in turn, can be used to give the container an explicit
    name. In the preceding sample, the name we chose is `trivia`. If we don’t specify
    an explicit container name when we run a container, then Docker will automatically
    assign the container a random but unique name. This name will be composed of the
    name of a famous scientist and an adjective. Such names could be `boring_borg`
    or `angry_goldberg`. They’re quite humorous, the Docker engineers, aren’t they?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`--name` 参数则可以用来为容器指定一个明确的名称。在前面的示例中，我们选择的名称是 `trivia`。如果在运行容器时没有指定明确的容器名称，Docker
    会自动为容器分配一个随机但唯一的名称。这个名称将由一个著名科学家的名字和一个形容词组成。例如，`boring_borg` 或 `angry_goldberg`。Docker
    的工程师们真是太幽默了，不是吗？'
- en: Finally, the container we’re running is derived from the `fundamentalsofdocker/trivia:ed2`
    image. Note how we are also using a tag, `ed2`, for the container. This tag just
    tells us that this image was originally created for the second edition of this
    book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们正在运行的容器是从 `fundamentalsofdocker/trivia:ed2` 镜像派生出来的。注意，我们还为容器使用了一个标签 `ed2`。这个标签只是告诉我们，这个镜像最初是为本书的第二版创建的。
- en: 'One important takeaway is that the container name has to be unique on the system.
    Let’s make sure that the trivia container is up and running:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，容器的名称在系统上必须是唯一的。让我们确保 `trivia` 容器已经启动并运行：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should give us something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给我们类似以下内容：
- en: '![Figure 3.6 – Details of the last run container](img/B19199_03_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 最后运行的容器详情](img/B19199_03_06.jpg)'
- en: Figure 3.6 – Details of the last run container
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 最后运行的容器详情
- en: An important part of the preceding output is the `STATUS` column, which in this
    case is `Up 6 minutes`. That is, the container has been up and running for 6 minutes
    now.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出中的一个重要部分是 `STATUS` 列，在这种情况下是 `Up 6 minutes`。也就是说，容器已经运行了 6 分钟。
- en: Don’t worry if the previous Docker command is not yet familiar to you; we will
    come back to it in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉之前的 Docker 命令，不必担心；我们将在下一节中再讲到它。
- en: 'To complete this section, let’s stop and remove the `trivia` container with
    the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，让我们使用以下命令停止并删除 `trivia` 容器：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding command, while forcefully removing the `trivia` container from
    our system, will just output the name of the container, `trivia`, in the output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令虽然强制删除了我们系统中的 `trivia` 容器，但输出中只会显示容器的名称 `trivia`。
- en: Now, it is time to learn how to list containers running or dangling on our system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习如何列出我们系统上运行或悬挂的容器了。
- en: Listing containers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出容器
- en: 'As we continue to run containers over time, we get a lot of them in our system.
    To find out what is currently running on our host, we can use the `container ls`
    command, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们不断运行容器，系统中会有很多容器。为了找出当前在主机上运行的容器，我们可以使用 `container ls` 命令，如下所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will list all currently running containers. Such a list might look similar
    to this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有当前正在运行的容器。这样的列表可能类似于以下内容：
- en: '![Figure 3.7 – List of all running containers on the system](img/B19199_03_07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 系统上所有正在运行的容器列表](img/B19199_03_07.jpg)'
- en: Figure 3.7 – List of all running containers on the system
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 系统上所有正在运行的容器列表
- en: 'By default, Docker outputs seven columns with the following meanings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 输出七列，含义如下：
- en: '| Column | Description |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 列      | 描述     |'
- en: '| `Container ID` | This is a short version of the unique ID of the container.
    It is an SHA-256, where Secure Hash Algorithm 256-bit (SHA-256) is a widely used
    cryptographic hash function that takes an input and generates a fixed-size (256-bit)
    output, known as a hash. The full ID is 64 characters long. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Container ID` | 这是容器唯一ID的简短版本。它是一个SHA-256值，SHA-256（安全哈希算法256位）是一种广泛使用的加密哈希函数，它接收一个输入并生成固定大小（256位）的输出，称为哈希值。完整的ID是64个字符长。
    |'
- en: '| `Image` | This is the name of the container image from which this container
    is instantiated. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Image` | 这是用来实例化此容器的容器镜像的名称。 |'
- en: '| `Command` | This is the command that is used to run the main process in the
    container. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Command` | 这是用于在容器中运行主进程的命令。 |'
- en: '| `Created` | This is the date and time when the container was created. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `Created` | 这是容器创建的日期和时间。 |'
- en: '| `Status` | This is the status of the container (created, restarting, running,
    removing, paused, exited, or dead). |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Status` | 这是容器的状态（已创建、重启中、运行中、移除中、暂停中、已退出或已死）。 |'
- en: '| `Ports` | This is the list of container ports that have been mapped to the
    host. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Ports` | 这是已映射到主机的容器端口列表。 |'
- en: '| `Names` | This is the name assigned to this container (note: multiple names
    for the same container are possible). |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Names` | 这是分配给容器的名称（注意：同一个容器可以有多个名称）。 |'
- en: Table 3.1 – Description of the columns of the docker container ls command
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表格3.1 – docker container ls命令列出的列的描述
- en: 'If we want to list not just the currently running containers but all containers
    that are defined on our system, then we can use the `-a` or `--all` command-line
    parameter, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不仅要列出当前正在运行的容器，而是要列出系统中定义的所有容器，我们可以使用`-a`或`--all`命令行参数，如下所示：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will list containers in any state, such as `created`, `running`, or `exited`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有状态下的容器，例如`created`（已创建）、`running`（正在运行）或`exited`（已退出）。
- en: 'Sometimes, we want to just list the IDs of all containers. For this, we have
    the `-q` or `--``quiet` parameter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只想列出所有容器的ID。为此，我们可以使用`-q`或`--quiet`参数：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You might wonder when this is useful. I will show you a command where it is
    very helpful right here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这个命令什么时候有用呢？我将在这里展示一个非常有用的命令：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lean back and take a deep breath. Then, try to find out what the preceding command
    does. Don’t read any further until you find the answer or give up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 放松一下，深呼吸。然后，尝试找出前面的命令做了什么。在你找到答案或放弃之前，不要继续阅读。
- en: 'Here is the solution: the preceding command forcefully deletes all containers
    that are currently defined on the system, including the stopped ones. The `rm`
    command stands for “remove,” and it will be explained soon.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案：上述命令强制删除系统上当前定义的所有容器，包括已停止的容器。`rm`命令代表“移除”，稍后会进行解释。
- en: 'In the previous section, we used the `-l` parameter in the list command, that
    is, `docker container ls -l`. Try to use the `docker help` command to find out
    what the `-l` parameter stands for. You can invoke help for the list command as
    follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在列表命令中使用了`-l`参数，也就是`docker container ls -l`。尝试使用`docker help`命令找出`-l`参数的含义。你可以如下调用帮助信息：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that you know how to list created, running, or stopped containers on your
    system, let’s learn how to stop and restart containers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经知道如何列出系统上已创建、正在运行或已停止的容器，接下来我们来学习如何停止和重启容器。
- en: Stopping and starting containers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止和启动容器
- en: 'Sometimes, we want to (temporarily) stop a running container. Let’s try this
    out with the trivia container we used previously:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望（暂时）停止一个正在运行的容器。让我们尝试使用之前的trivia容器来进行操作：
- en: 'Run the container again with this command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令再次运行容器：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we want to stop this container, then we can do so by issuing this command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想停止这个容器，可以通过执行以下命令来实现：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you try to stop the trivia container, you will probably notice that it
    takes a while until this command is executed. To be precise, it takes about 10
    seconds. *Why is this* *the case?*
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '当你尝试停止trivia容器时，可能会注意到这个命令执行时需要一些时间。准确地说，大约需要10秒钟。*为什么会这样*？ '
- en: Docker sends a Linux `SIGTERM` signal to the main process running inside the
    container. If the process doesn’t react to this signal and terminate itself, Docker
    waits for 10 seconds and then sends `SIGKILL`, which will kill the process forcefully
    and terminate the container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker会向容器内运行的主进程发送Linux的`SIGTERM`信号。如果该进程没有对信号作出响应并自行终止，Docker会等待10秒钟，然后发送`SIGKILL`，强制终止进程并停止容器。
- en: In the preceding command, we have used the name of the container to specify
    which container we want to stop. But we could have also used the container ID
    instead.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们使用了容器的名称来指定要停止的容器。但我们也可以使用容器ID来代替。
- en: 'How do we get the ID of a container? There are several ways of doing so. The
    manual approach is to list all running containers and find the one that we’re
    looking for in the list. From there, we copy its ID. A more automated way is to
    use some shell scripting and environment variables. If, for example, we want to
    get the ID of the trivia container, we can use this expression:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取容器的ID？有几种方法可以做到这一点。手动方法是列出所有正在运行的容器，并在列表中找到我们正在寻找的那个容器。从那里，我们复制它的ID。更自动化的方式是使用一些
    shell 脚本和环境变量。例如，如果我们想获取 trivia 容器的ID，可以使用以下表达式：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The equivalent command in PowerShell would look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，等效的命令如下所示：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the `-a` (or `--all`) parameter with the `docker container ls`
    command to list all containers, even the stopped ones. This is necessary in this
    case since we stopped the trivia container a moment ago.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`-a`（或`--all`）参数与`docker container ls`命令来列出所有容器，包括已停止的容器。由于我们刚才停止了 trivia
    容器，所以在这种情况下是必要的。
- en: 'Now, instead of using the container name, we can use the `$CONTAINER_ID` variable
    in our expression:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以不使用容器名称，而是在表达式中使用`$CONTAINER_ID`变量：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once we have stopped the container, its status changes to `Exited`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们停止了容器，它的状态将变为`Exited`。
- en: 'If a container is stopped, it can be started again using the `docker container
    start` command. Let’s do this with our `trivia` container. It is good to have
    it running again, as we’ll need it in the subsequent sections of this chapter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器已停止，可以使用`docker container start`命令重新启动它。让我们用`trivia`容器做这个操作。重新启动它是个好主意，因为在本章接下来的部分我们还会用到它：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also start it by using the name of the container:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用容器名称来启动它：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is now time to discuss what to do with stopped containers that we don’t need
    anymore.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论如何处理那些我们不再需要的已停止容器了。
- en: Removing containers
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除容器
- en: 'When we run the `docker container ls -a` command, we can see quite a few containers
    that are in the `Exited` status. If we don’t need these containers anymore, then
    it is a good thing to remove them from memory; otherwise, they unnecessarily occupy
    precious resources. The command to remove a container is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`docker container ls -a`命令时，可以看到许多处于`Exited`状态的容器。如果我们不再需要这些容器，最好将它们从内存中移除；否则，它们会不必要地占用宝贵的资源。移除容器的命令如下：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, `<container ID>` stands for the ID of the container – a SHA-256 code
    – that we want to remove. Another way to remove a container is the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<container ID>`代表我们想要移除的容器ID——一个 SHA-256 代码。移除容器的另一种方式如下：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we use the name of the container.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用容器的名称。
- en: Challenge
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战
- en: Try to remove one of your exited containers using its ID.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用容器的ID来移除一个已停止的容器。
- en: 'Sometimes, removing a container will not work as it is still running. If we
    want to force a removal, no matter what the condition of the container currently
    is, we can use the `-f` or `--force` command-line parameter:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，移除容器可能会失败，因为它仍在运行。如果我们想强制移除容器，无论容器当前的状态如何，我们可以使用`-f`或`--force`命令行参数：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have learned how to remove containers from our system, let’s learn
    how to inspect containers present in the system.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何从系统中移除容器，接下来让我们学习如何检查系统中存在的容器。
- en: Inspecting containers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查容器
- en: 'Containers are runtime instances of an image and have a lot of associated data
    that characterizes their behavior. To get more information about a specific container,
    we can use the `inspect` command. As usual, we have to provide either the container
    ID or the name to identify the container for which we want to obtain the data.
    So, let’s inspect our sample container. First, if it is not already running, we
    have to run it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的运行时实例，具有许多与其行为相关的特征数据。为了获取有关特定容器的更多信息，我们可以使用`inspect`命令。像往常一样，我们必须提供容器ID或名称，以标识我们想要获取数据的容器。那么，让我们检查一下我们的示例容器。如果它还没有运行，我们必须先启动它：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, use this command to inspect it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此命令来检查它：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The response is a big JSON object full of details. It looks similar to this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是一个包含详细信息的大型 JSON 对象。它看起来类似于这样：
- en: '![Figure 3.8 – Inspecting the trivia container](img/B19199_03_08.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 检查 trivia 容器](img/B19199_03_08.jpg)'
- en: Figure 3.8 – Inspecting the trivia container
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 检查 trivia 容器
- en: Note that the preceding screenshot only shows the first part of a much longer
    output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的截图只显示了更长输出的第一部分。
- en: 'Please take a moment to analyze what you have. You should see information such
    as the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间分析一下你所拥有的信息。你应该看到如下信息：
- en: The ID of the container
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的 ID
- en: The creation date and time of the container
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的创建日期和时间
- en: From which image the container is built
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是从哪个镜像构建的
- en: Many sections of the output, such as `Mounts` and `NetworkSettings`, don’t make
    much sense right now, but we will discuss those in the upcoming chapters of this
    book. The data you’re seeing here is also named the *metadata* of a container.
    We will be using the `inspect` command quite often in the remainder of this book
    as a source of information.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的许多部分，如 `Mounts` 和 `NetworkSettings`，现在可能没有太大意义，但我们将在本书的后续章节中讨论这些内容。你在这里看到的数据也被称为容器的
    *元数据*。在本书的余下部分，我们将经常使用 `inspect` 命令作为信息来源。
- en: 'Sometimes, we need just a tiny bit of the overall information, and to achieve
    this, we can use either the `grep` tool or a filter. The former method does not
    always result in the expected answer, so let’s look into the latter approach:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要一小部分整体信息，为了实现这一点，我们可以使用 `grep` 工具或过滤器。前者方法并不总是能得到预期的答案，因此让我们看看后者的方法：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `-f` or `--filter` parameter is used to define the `"{{json .State}}"`
    filter. The filter expression itself uses the Go template syntax. In this example,
    we only want to see the state part of the whole output in JSON format. To nicely
    format the output, we pipe the result into the `jq` tool:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 或 `--filter` 参数用于定义 `"{{json .State}}"` 过滤器。过滤器表达式本身使用 Go 模板语法。在这个例子中，我们只想看到整个输出中的状态部分，格式为
    JSON。为了更好地格式化输出，我们将结果通过管道传递给 `jq` 工具：'
- en: '![Figure 3.9 – The state node of the inspect output](img/B19199_03_09.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – inspect 输出的状态节点](img/B19199_03_09.jpg)'
- en: Figure 3.9 – The state node of the inspect output
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – inspect 输出的状态节点
- en: After we have learned how to retrieve loads of important and useful meta information
    about a container, we want to investigate how we can execute it in a running container.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学会如何检索关于容器的大量重要且有用的元信息后，我们希望调查如何在一个运行中的容器中执行它。
- en: Exec into a running container
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行进入正在运行的容器
- en: 'Sometimes, we want to run another process inside an already-running container.
    A typical reason could be to try to debug a misbehaving container. How can we
    do this? First, we need to know either the ID or the name of the container, and
    then we can define which process we want to run and how we want it to run. Once
    again, we use our currently running `trivia` container and we run a shell interactively
    inside it with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望在一个已经运行的容器内执行另一个进程。一个典型的原因可能是尝试调试一个行为异常的容器。我们如何做到这一点呢？首先，我们需要知道容器的 ID
    或名称，然后我们可以定义我们想要运行的进程以及如何运行它。再次，我们使用当前正在运行的 `trivia` 容器，并通过以下命令在其中交互式地运行一个 shell：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `-i` (or `--interactive`) flag signifies that we want to run the additional
    process interactively, and `-t` (or `--tty`) tells Docker that we want it to provide
    us with a TTY (a terminal emulator) for the command. Finally, the process we run
    inside the container is `/bin/sh`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`（或 `--interactive`）标志表示我们希望交互式地运行额外的进程，`-t`（或 `--tty`）告诉 Docker 我们希望它为我们提供一个
    TTY（终端模拟器）以运行该命令。最后，我们在容器内运行的进程是 `/bin/sh`。'
- en: 'If we execute the preceding command in our terminal, then we will be presented
    with a new prompt, `/app #`. We’re now in a Bourne shell inside the trivia container.
    We can easily prove that by, for example, executing the `ps` command, which will
    list all running processes in the context:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在终端执行上述命令，我们将看到一个新的提示符 `/app #`。我们现在处于 trivia 容器内的 Bourne shell 中。我们可以通过执行
    `ps` 命令轻松证明这一点，`ps` 会列出该上下文中的所有运行进程：'
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result should look somewhat similar to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来与此类似：
- en: '![Figure 3.10 – Executing into the running trivia container](img/B19199_03_10.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 进入正在运行的 trivia 容器](img/B19199_03_10.jpg)'
- en: Figure 3.10 – Executing into the running trivia container
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 进入正在运行的 trivia 容器
- en: We can clearly see that the process with PID `1` is the command that we have
    defined to run inside the trivia container. The process with PID `1` is also named
    the main process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，PID 为 `1` 的进程是我们定义在 trivia 容器中运行的命令。PID 为 `1` 的进程也被称为主进程。
- en: 'Exit the container by pressing *Ctrl* + *D*. We cannot only execute additional
    processes interactively in a container. Please consider the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *D*退出容器。我们不仅可以在容器中交互执行其他进程。请考虑以下命令：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output evidently looks very similar to the preceding output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，输出看起来与前面的输出非常相似：
- en: '![Figure 3.11 – List of processes running inside the trivia container](img/B19199_03_11.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 在小知识容器内运行的进程列表](img/B19199_03_11.jpg)'
- en: Figure 3.11 – List of processes running inside the trivia container
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 在小知识容器内运行的进程列表
- en: 'The difference is that we did not use an extra process to run a shell but executed
    the `ps` command directly. We can even run processes as a daemon using the `-d`
    flag and define environment variables valid inside the container, using the `-e`
    or `--env` flag variables, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，我们没有使用额外的进程来运行 shell，而是直接执行了`ps`命令。我们甚至可以使用`-d`标志以守护进程的方式运行进程，并使用`-e`或`--env`标志变量在容器内定义环境变量，如下所示：
- en: 'Run the following command to start a shell inside a trivia container and define
    an environment variable named `MY_VAR` that is valid inside this container:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，在一个小知识（trivia）容器内启动一个 shell，并定义一个名为`MY_VAR`的环境变量，该变量在该容器内有效：
- en: '[PRE37]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You’ll find yourself inside the `trivia` container. Output the content of the
    `MY_VAR` environment variable, as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将发现自己在`trivia`容器内。输出`MY_VAR`环境变量的内容，如下所示：
- en: '[PRE38]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see this output in the terminal:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在终端中看到这个输出：
- en: '[PRE39]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Figure 3.12 – Running a trivia container and defining an environment variable](img/B19199_03_12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 运行一个小知识容器并定义一个环境变量](img/B19199_03_12.jpg)'
- en: Figure 3.12 – Running a trivia container and defining an environment variable
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 运行一个小知识容器并定义一个环境变量
- en: 'To exit the trivia container, press *Ctrl* + *D*:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出小知识容器，请按*Ctrl* + *D*：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Great, we have learned how to execute into a running container and run additional
    processes. But there is another important way to work with a running container.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们学会了如何进入运行中的容器并执行其他进程。但是还有另一种重要的与运行中容器一起工作的方法。
- en: Attaching to a running container
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加到正在运行的容器
- en: 'We can use the `attach` command to attach our terminal’s standard input, output,
    or error (or any combination of the three) to a running container using the ID
    or name of the container. Let’s do this for our trivia container:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`attach`命令将我们终端的标准输入、输出或错误（或三者的任意组合）附加到正在运行的容器中，使用容器的 ID 或名称。让我们为我们的小知识容器执行这个操作：
- en: Open a new terminal window.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口。
- en: Tip
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You may want to use another terminal than the integrated terminal of VS Code
    for this exercise, as it seems to cause problems with the key combinations that
    we are going to use. On Mac, use the Terminal app, as an example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，您可能希望使用比 VS Code 集成终端更好的另一个终端，因为它似乎会导致我们将要使用的键组合出现问题。在 Mac 上，例如，使用终端应用程序。
- en: 'Run a new instance of the `trivia` Docker image in interactive mode:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互模式下运行`trivia` Docker 镜像的新实例：
- en: '[PRE41]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open yet another terminal window and use this command to attach it to the container:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端窗口，并使用这个命令将其附加到容器上：
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, we will see, every 5 seconds or so, a new quote appearing in the
    output.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将看到，大约每 5 秒，输出中会出现一个新的引用。
- en: To quit the container without stopping or killing it, we can use the *Ctrl +
    P* `+` *Ctrl* + *Q* key combination. This detaches us from the container while
    leaving it running in the background.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出容器而不停止或杀死它，我们可以使用*Ctrl + P* `+` *Ctrl* + *Q*键组合。这样可以从容器中分离出来，同时让它在后台运行。
- en: 'Stop and remove the container forcefully:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制停止并删除容器：
- en: '[PRE43]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s run another container, this time, an Nginx web server:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再运行另一个容器，这次是一个 Nginx web 服务器：
- en: 'Run the Nginx web server as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下步骤运行 Nginx web 服务器：
- en: '[PRE44]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Here, we run the Alpine version of Nginx as a daemon in a container named `nginx`.
    The `-p 8080:80` command-line parameter opens port `8080` on the host (that is,
    the user’s machine) for access to the Nginx web server running inside the container.
    Don’t worry about the syntax here as we will explain this feature in more detail
    in [*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using* *Single-Host Networking*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们作为守护进程运行 Alpine 版本的 Nginx，在名为`nginx`的容器中。`-p 8080:80`命令行参数在主机上打开端口`8080`，以便访问运行在容器内的
    Nginx web 服务器。不用担心这里的语法问题，因为我们将在[*第10章*](B19199_10.xhtml#_idTextAnchor218)，*使用单主机网络*中更详细地解释这个特性。
- en: On Windows, you’ll need to approve a prompt that Windows Firewall will pop up.
    You have to allow Docker Desktop on the firewall.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你需要批准一个 Windows 防火墙弹出的提示。你必须在防火墙中允许 Docker Desktop。
- en: 'Let’s see whether we can access Nginx using the `curl` tool by running this
    command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看能否通过运行以下命令使用 `curl` 工具访问 Nginx：
- en: '[PRE45]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If all works correctly, you should be greeted by the welcome page of Nginx:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到 Nginx 的欢迎页面：
- en: '![Figure 3.13 – Welcome message of the Nginx web server](img/B19199_03_13.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – Nginx Web 服务器的欢迎消息](img/B19199_03_13.jpg)'
- en: Figure 3.13 – Welcome message of the Nginx web server
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – Nginx Web 服务器的欢迎消息
- en: 'Now, let’s attach our terminal to the Nginx container to observe what’s happening:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将终端附加到 Nginx 容器，观察发生了什么：
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once you are attached to the container, you will not see anything at first.
    But now, open another terminal, and in this new terminal window, repeat the `curl`
    command a few times, for example, using the following script:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你附加到容器，你最初不会看到任何内容。但现在，打开另一个终端，在这个新终端窗口中重复运行 `curl` 命令几次，例如，使用以下脚本：
- en: '[PRE47]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or, in PowerShell, use the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 PowerShell 中使用以下命令：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should see the logging output of Nginx, which looks similar to this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 Nginx 的日志输出，类似于以下内容：
- en: '![Figure 3.14 – Output of Nginx](img/B19199_03_14.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – Nginx 输出](img/B19199_03_14.jpg)'
- en: Figure 3.14 – Output of Nginx
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – Nginx 输出
- en: Quit the container by pressing *Ctrl* + *C*. This will detach your terminal
    and, at the same time, stop the Nginx container.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 退出容器。这将分离你的终端，同时停止 Nginx 容器。
- en: 'To clean up, remove the Nginx container with the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清理，请使用以下命令删除 Nginx 容器：
- en: '[PRE49]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, we’re going to learn how to work with container logs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何处理容器日志。
- en: Retrieving container logs
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索容器日志
- en: It is a best practice for any good application to generate some logging information
    that developers and operators alike can use to find out what the application is
    doing at a given time, and whether there are any problems to help to pinpoint
    the root cause of the issue.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 任何好的应用程序的最佳实践是生成一些日志信息，开发人员和操作人员都可以用来了解应用程序在特定时间的运行情况，以及是否有任何问题，以帮助确定问题的根本原因。
- en: 'When running inside a container, the application should preferably output the
    log items to `STDOUT` and `STDERR` and not into a file. If the logging output
    is directed to `STDOUT` and `STDERR`, then Docker can collect this information
    and keep it ready for consumption by a user or any other external system:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行时，应用程序最好将日志条目输出到 `STDOUT` 和 `STDERR`，而不是文件。如果日志输出被定向到 `STDOUT` 和 `STDERR`，则
    Docker 可以收集这些信息并准备好供用户或任何其他外部系统使用：
- en: 'Run a trivia container in `detach` mode:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `detach` 模式下运行一个 trivia 容器：
- en: '[PRE50]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let it run for a minute or so so that it has time to generate a few trivia questions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让它运行一分钟左右，这样它就有时间生成几个 trivia 问题。
- en: 'To access the logs of a given container, we can use the `docker container logs`
    command. If, for example, we want to retrieve the logs of our `trivia` container,
    we can use the following expression:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问给定容器的日志，我们可以使用 `docker container logs` 命令。例如，如果我们想检索 `trivia` 容器的日志，可以使用以下表达式：
- en: '[PRE51]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will retrieve the whole log produced by the application from the very beginning
    of its existence.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索从应用程序存在之初生成的完整日志。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Stop, wait a second – this is not quite true, what I just said. By default,
    Docker uses the so-called `json-file` logging driver. This driver stores logging
    information in a file. If there is a file rolling policy defined, then `docker
    container logs` only retrieves what is in the currently active log file and not
    what is in previous rolled files that might still be available on the host.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 停一下，等一会儿——我刚才说的并不完全正确。默认情况下，Docker 使用所谓的 `json-file` 日志驱动程序。该驱动程序将日志信息存储在文件中。如果定义了文件滚动策略，那么
    `docker container logs` 仅会检索当前活动日志文件中的内容，而不会检索可能仍然存在于主机上的以前滚动过的文件。
- en: 'If we want to only get a few of the latest entries, we can use the `-t` or
    `--tail` parameter, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想获取一些最新的条目，可以使用 `-t` 或 `--tail` 参数，如下所示：
- en: '[PRE52]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will retrieve only the last five items that the process running inside
    the container produced.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅检索容器内部进程生成的最后五条记录。
- en: 'Sometimes, we want to follow the log that is produced by a container. This
    is possible when using the `-f` or `--follow` parameter. The following expression
    will output the last five log items and then follow the log as it is produced
    by the containerized process:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，我们希望跟踪容器产生的日志。这可以通过使用 `-f` 或 `--follow` 参数来实现。以下表达式将输出最后五个日志项，并在容器化进程产生日志时继续跟踪：
- en: '[PRE53]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Press *Ctrl + C* to stop following the logs.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl + C* 停止跟踪日志。
- en: 'Clean up your environment and remove the trivia container with the following:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理环境并使用以下命令移除不必要的容器：
- en: '[PRE54]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Often, using the default mechanism for container logging is not enough. We need
    a different way of logging. This is discussed in the following section.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用容器日志的默认机制不足以满足需求。我们需要另一种日志记录方式。接下来的章节将讨论这个问题。
- en: Logging drivers
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志驱动程序
- en: 'Docker includes multiple logging mechanisms to help us to get information from
    running containers. These mechanisms are named logging drivers. Which logging
    driver is used can be configured at the Docker daemon level. The default logging
    driver is `json-file`. Some of the drivers that are currently supported natively
    are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 包含多种日志机制，帮助我们从运行中的容器中获取信息。这些机制称为日志驱动程序。可以在 Docker 守护进程级别配置使用哪个日志驱动程序。默认的日志驱动程序是
    `json-file`。目前原生支持的驱动程序如下：
- en: '| **Driver** | **Description** |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **驱动程序** | **描述** |'
- en: '| `none` | No log output for the specific container is produced. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 不会为特定容器产生日志输出。 |'
- en: '| `json-file` | This is the default driver. The logging information is stored
    in files, formatted as JSON. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `json-file` | 这是默认的驱动程序。日志信息存储在文件中，并以 JSON 格式呈现。 |'
- en: '| `journald` | If the `journald` daemon is running on the host machine, we
    can use this driver. It forwards logging to the `journald` daemon. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `journald` | 如果主机上正在运行 `journald` 守护进程，我们可以使用此驱动程序。它会将日志转发到 `journald` 守护进程。
    |'
- en: '| `syslog` | If the `syslog` daemon is running on the host machine, we can
    configure this driver, which will forward the log messages to the `syslog` daemon.
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `syslog` | 如果主机上运行着 `syslog` 守护进程，我们可以配置此驱动程序，它将把日志消息转发到 `syslog` 守护进程。 |'
- en: '| `gelf` | When using this driver, log messages are written to a **Graylog
    Extended Log Format (GELF)** endpoint. Popular examples of such endpoints are
    Graylog and Logstash. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `gelf` | 使用此驱动程序时，日志消息将写入 **Graylog 扩展日志格式（GELF）** 端点。常见的此类端点包括 Graylog 和
    Logstash。 |'
- en: '| `fluentd` | Assuming that the `fluentd` daemon is installed on the host system,
    this driver writes log messages to it. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `fluentd` | 假设主机系统上已安装 `fluentd` 守护进程，此驱动程序会将日志消息写入该守护进程。 |'
- en: '| `awslogs` | The `awslogs` logging driver for Docker is a logging driver that
    allows Docker to send log data to Amazon CloudWatch Logs. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `awslogs` | `awslogs` 日志驱动程序允许 Docker 将日志数据发送到 Amazon CloudWatch Logs。 |'
- en: '| `splunk` | The Splunk logging driver for Docker allows Docker to send log
    data to Splunk, a popular platform for log management and analysis. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `splunk` | Splunk 日志驱动程序允许 Docker 将日志数据发送到 Splunk，这是一个流行的日志管理和分析平台。 |'
- en: Table 3.2 – List of logging drivers
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 – 日志驱动程序列表
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you change the logging driver, please be aware that the `docker container
    logs` command is only available for the `json-file` and `journald` drivers. Docker
    20.10 and up introduce *dual logging*, which uses a local buffer that allows you
    to use the `docker container logs` command for any logging driver.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改日志驱动程序，请注意，`docker container logs` 命令仅适用于 `json-file` 和 `journald` 驱动程序。Docker
    20.10 及更高版本引入了 *双重日志记录*，它使用本地缓冲区，使您可以为任何日志驱动程序使用 `docker container logs` 命令。
- en: Using a container-specific logging driver
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特定容器的日志驱动程序
- en: 'The logging driver can be set globally in the Docker daemon configuration file.
    But we can also define the logging driver on a container-by-container basis. In
    the following example, we run a `busybox` container and use the `--logdriver`
    parameter to configure the `none` logging driver:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 日志驱动程序可以在 Docker 守护进程配置文件中全局设置。但我们也可以为每个容器单独定义日志驱动程序。在以下示例中，我们运行一个 `busybox`
    容器，并使用 `--logdriver` 参数配置 `none` 日志驱动程序：
- en: 'Run an instance of the `busybox` Docker image and execute a simple script in
    it outputting a `Hello` message three times:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个 `busybox` Docker 镜像实例，并在其中执行一个简单脚本，输出三次 `Hello` 消息：
- en: '[PRE55]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We should see the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下内容：
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let’s try to get the logs of the preceding container:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取前面容器的日志：
- en: '[PRE57]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is to be expected since the `none` driver does not produce any logging
    output.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以预期的，因为 `none` 驱动程序不会产生任何日志输出。
- en: 'Let’s clean up and remove the `test` container:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们清理并移除 `test` 容器：
- en: '[PRE59]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: To end this section about logging, we want to discuss a somewhat advanced topic,
    namely, how to change the default logging driver.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束关于日志的这一部分时，我们将讨论一个相对高级的话题，即如何更改默认的日志驱动程序。
- en: Advanced topic – changing the default logging driver
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级话题 – 更改默认日志驱动程序
- en: 'Let’s change the default logging driver of a Linux host. The easiest way to
    do this is on a real Linux host. For this purpose, we’re going to use Vagrant
    with an Ubuntu image. Vagrant is an open source tool developed by HashiCorp that
    is often used to build and maintain portable virtual software development environments.
    Please follow these instructions:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改 Linux 主机的默认日志驱动程序。最简单的方式是在真实的 Linux 主机上执行此操作。为此，我们将使用带有 Ubuntu 镜像的 Vagrant。Vagrant
    是由 HashiCorp 开发的一个开源工具，通常用于构建和维护便携的虚拟软件开发环境。请按照以下说明进行操作：
- en: Open a new terminal window.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口。
- en: 'If you haven’t done so before, on your Mac and Windows machine, you may need
    to install a hypervisor such as VirtualBox first. If you’re using a Pro version
    of Windows, you can also use Hyper-V instead:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前没有做过，在你的 Mac 和 Windows 机器上，你可能需要首先安装一个虚拟机管理程序（如 VirtualBox）。如果你使用的是 Windows
    的专业版，也可以使用 Hyper-V：
- en: 'To install VirtualBox on a Mac with an Intel CPU, use Homebrew as follows:'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在带有 Intel CPU 的 Mac 上安装 VirtualBox，可以通过以下 Homebrew 命令：
- en: '[PRE60]'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On Windows, with Chocolatey, use the following:'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，使用 Chocolatey，执行以下操作：
- en: '[PRE61]'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'On a Mac with an M1/M2 CPU, at the time of writing, you need to install the
    developer preview of VirtualBox. Please follow the instructions here: [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有 M1/M2 CPU 的 Mac 上，在撰写时，你需要安装 VirtualBox 的开发者预览版。请按照这里的说明进行操作：[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)。
- en: 'Install Vagrant on your computer using your package manager, such as Chocolatey
    on Windows or Homebrew on Mac. On my MacBook Air M1, the command looks like this:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的包管理器（如 Windows 上的 Chocolatey 或 Mac 上的 Homebrew）在计算机上安装 Vagrant。在我的 MacBook
    Air M1 上，命令如下：
- en: '[PRE62]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On a Windows machine, the corresponding command would be the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，相应的命令如下：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once successfully installed, make sure Vagrant is available with the following
    command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，使用以下命令确保 Vagrant 可用：
- en: '[PRE64]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At the time of writing, Vagrant replies with the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，Vagrant 会回复以下内容：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In your terminal, execute the following command to initialize an Ubuntu 22.04
    VM with Vagrant:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行以下命令以初始化一个带有 Vagrant 的 Ubuntu 22.04 虚拟机：
- en: '[PRE66]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here is the generated output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的输出：
- en: '![Figure 3.15 – Initializing a Vagrant VM based on Ubuntu 22.04](img/B19199_03_15.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 基于 Ubuntu 22.04 初始化 Vagrant 虚拟机](img/B19199_03_15.jpg)'
- en: Figure 3.15 – Initializing a Vagrant VM based on Ubuntu 22.04
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 基于 Ubuntu 22.04 初始化 Vagrant 虚拟机
- en: Vagrant will create a file called `Vagrantfile` in the current folder. Optionally,
    you can use your editor to analyze the content of this file.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 会在当前文件夹中创建一个名为 `Vagrantfile` 的文件。你可以选择使用编辑器分析该文件的内容。
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On a Mac with an M1/M2 CPU, at the time of writing, the `bento/ubuntu-22.4`
    image does not work. An alternative that seems to work is `illker/ubuntu-2004`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有 M1/M2 CPU 的 Mac 上，在撰写时，`bento/ubuntu-22.4` 镜像无法使用。一个似乎有效的替代方案是 `illker/ubuntu-2004`。
- en: 'Now, start this VM using Vagrant:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 Vagrant 启动该虚拟机：
- en: '[PRE67]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Connect from your laptop to the VM using Secure Shell (`ssh`):'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用安全外壳协议（`ssh`）从笔记本电脑连接到虚拟机：
- en: '[PRE68]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: After this, you will find yourself inside the VM and can start working with
    Docker inside this VM.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将进入虚拟机并可以在其中开始使用 Docker。
- en: 'Once inside the Ubuntu VM, we want to edit the Docker daemon configuration
    file and trigger the Docker daemon to reload the configuration file thereafter:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入 Ubuntu 虚拟机，我们需要编辑 Docker 守护进程配置文件并触发 Docker 守护进程重新加载该配置文件：
- en: 'Navigate to the `/``etc/docker` folder:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/etc/docker` 文件夹：
- en: '[PRE69]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run `vi` as follows:'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式运行 `vi`：
- en: '[PRE70]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Enter the following content:'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE71]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding definition tells the Docker daemon to use the `json-log` driver
    with a maximum log file size of 10 MB before it is rolled, and the maximum number
    of log files that can be present on the system is three before the oldest file
    gets purged.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述定义指示 Docker 守护进程使用 `json-log` 驱动程序，最大日志文件大小为 10 MB，在文件被滚动之前，并且系统上可以存在的最大日志文件数为三个，超出后最旧的文件将被清除。
- en: Save and exit `vi` by first pressing *Esc*, then typing `:w:q` (which means
    *write and quit*), and finally hitting the *Enter* key.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先按 *Esc*，然后输入 `:w:q`（表示 *保存并退出*），最后按 *Enter* 键来保存并退出 `vi`。
- en: 'Now, we must send a `SIGHUP` signal to the Docker daemon so that it picks up
    the changes in the configuration file:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须向 Docker 守护进程发送一个 `SIGHUP` 信号，以便它能够读取配置文件中的更改：
- en: '[PRE72]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that the preceding command only reloads the config file and does not restart
    the daemon.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，前面的命令只会重新加载配置文件，而不会重新启动守护进程。
- en: Test your configuration by running a few containers and analyzing the log output.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行一些容器并分析日志输出，来测试你的配置。
- en: 'Clean up your system once you are done experimenting with the following:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成以下实验后，记得清理系统：
- en: '[PRE73]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Great! The previous section was an advanced topic and showed how you can change
    the log driver on a system level. Let’s now talk a bit about the anatomy of containers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！上一节是一个高级主题，展示了如何在系统级别更改日志驱动程序。现在，让我们谈谈容器的结构。
- en: The anatomy of containers
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的结构
- en: Many people wrongly compare containers to VMs. However, this is a questionable
    comparison. Containers are not just lightweight VMs. OK then, what is the correct
    description of a container?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人错误地将容器与虚拟机进行比较。然而，这种比较是值得怀疑的。容器不仅仅是轻量级的虚拟机。那么，容器的正确描述是什么呢？
- en: Containers are specially encapsulated and secured processes running on the host
    system. Containers leverage a lot of features and primitives available on the
    Linux operating system. The most important ones are **namespaces** and **control
    groups** (**cgroups** for short). All processes running in containers only share
    the same Linux kernel of the underlying host operating system. This is fundamentally
    different from VMs, as each VM contains its own full-blown operating system.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是运行在宿主系统上的特别封装和安全的进程。容器利用了 Linux 操作系统中许多可用的特性和原语。最重要的特性是**命名空间**和**控制组**（简称
    **cgroups**）。所有在容器中运行的进程仅共享底层宿主操作系统的同一个 Linux 内核。这与虚拟机有本质的不同，因为每个虚拟机都包含其自己的完整操作系统。
- en: The startup times of a typical container can be measured in milliseconds, while
    a VM normally needs several seconds to minutes to start up. VMs are meant to be
    long-living. It is a primary goal of each operations engineer to maximize the
    uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They
    come and go relatively quickly.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型容器的启动时间可以用毫秒来衡量，而虚拟机（VM）通常需要几秒钟到几分钟才能启动。虚拟机通常是长时间运行的。每个运维工程师的主要目标之一就是最大化虚拟机的正常运行时间。与此相反，容器是短暂的。它们来得快，去得也快。
- en: Let’s first get a high-level overview of the architecture that enables us to
    run containers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们高层次地概述一下使我们能够运行容器的架构。
- en: Architecture
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: 'Here, we have an architectural diagram of how this all fits together:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个架构图，展示了这一切是如何组合在一起的：
- en: '![Figure 3.16 – High-level architecture of Docker](img/B19199_03_16.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – Docker 的高层架构](img/B19199_03_16.jpg)'
- en: Figure 3.16 – High-level architecture of Docker
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – Docker 的高层架构
- en: In the lower part of the preceding diagram, we have the Linux operating system
    with its cgroups, namespaces, and layer capabilities as well as other operating
    system functionality that we do not need to explicitly mention here. Then, there
    is an intermediary layer composed of `containerd` and `runc`. On top of all that
    now sits the Docker engine. The Docker engine offers a RESTful interface to the
    outside world that can be accessed by any tool, such as the Docker CLI, Docker
    Desktop, or Kubernetes, to name just a few.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图表的下半部分，我们有 Linux 操作系统及其 cgroups、命名空间和层次能力，以及其他操作系统功能，这些我们在这里不需要明确提及。接下来，是一个中间层，包含
    `containerd` 和 `runc`。在所有这些之上，现在是 Docker 引擎。Docker 引擎提供了一个 RESTful 接口，外部世界可以通过任何工具访问，如
    Docker CLI、Docker Desktop 或 Kubernetes 等。
- en: Let’s now describe the main building blocks in a bit more detail.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地描述一下主要的构建块。
- en: Namespaces
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Linux namespaces were around for years before they were leveraged by Docker
    for their containers. A **namespace** is an abstraction of global resources such
    as filesystems, network access, and process trees (also named PID namespaces)
    or the system group IDs and user IDs. A Linux system is initialized with a single
    instance of each namespace type. After initialization, additional namespaces can
    be created or joined.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的命名空间在 Docker 使用容器之前就已经存在了多年。**命名空间**是对全局资源的抽象，例如文件系统、网络访问、进程树（也称为 PID
    命名空间）或系统组 ID 和用户 ID。Linux 系统在初始化时会创建每种命名空间类型的单一实例。初始化后，可以创建或加入额外的命名空间。
- en: The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version
    3.8, user namespaces were introduced, and with this, namespaces were ready to
    be used by containers.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 命名空间起源于 2002 年的 2.4.19 内核。在 3.8 版本内核中引入了用户命名空间，随之而来的是命名空间可以被容器使用。
- en: 'If we wrap a running process, say, in a filesystem namespace, then this provides
    the illusion that the process owns its own complete filesystem. This, of course,
    is not true; it is only a virtual filesystem. From the perspective of the host,
    the contained process gets a shielded subsection of the overall filesystem. It
    is like a filesystem in a filesystem:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个正在运行的进程，比如说在文件系统命名空间中，那么这将提供一个错觉，即进程拥有自己完整的文件系统。当然，这不是真的；这只是一个虚拟文件系统。从主机的角度看，包含的进程获得了整体文件系统的受保护的子部分。就像一个文件系统中的文件系统：
- en: '![Figure 3.17 – Namespaces explained](img/B19199_03_17.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 命名空间解释](img/B19199_03_17.jpg)'
- en: Figure 3.17 – Namespaces explained
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 命名空间解释
- en: The same applies to all of the other global resources for which namespaces exist.
    The user ID namespace is another example. Now that we have a user namespace, we
    can define a `jdoe` user many times on the system as long as it is living in its
    own namespace.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于所有其他全局资源，例如存在命名空间的用户 ID 命名空间就是另一个例子。现在我们有了用户命名空间，我们可以在系统上多次定义 `jdoe` 用户，只要它们位于各自的命名空间中。
- en: 'The PID namespace is what keeps processes in one container from seeing or interacting
    with processes in another container. A process might have the apparent PID 1 inside
    a container, but if we examine it from the host system, it will have an ordinary
    PID, say, `334`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: PID 命名空间是使得一个容器内的进程无法看到或与另一个容器内的进程交互的机制。一个进程在容器内可能具有看似的 PID 1，但如果我们从主机系统上检查它，它将具有普通的
    PID，例如 `334`：
- en: '![Figure 3.18 – Process tree on a Docker host](img/B19199_03_18_new.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – Docker 主机上的进程树](img/B19199_03_18_new.jpg)'
- en: Figure 3.18 – Process tree on a Docker host
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – Docker 主机上的进程树
- en: In each namespace, we can run one-to-many processes. That is important when
    we talk about containers, which we already experienced when we executed another
    process in an already-running container.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个命名空间中，我们可以运行一对多的进程。当我们谈论容器时，这一点非常重要，这一点我们已经在已运行的容器中执行另一个进程时体验到了。
- en: Control groups
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制组
- en: Linux cgroups are used to limit, manage, and isolate the resource usage of collections
    of processes running on a system. Resources are the CPU time, system memory, network
    bandwidth, or combinations of these resources.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 控制组（cgroups）用于限制、管理和隔离在系统上运行的一组进程的资源使用。资源包括 CPU 时间、系统内存、网络带宽或这些资源的组合。
- en: Engineers at Google originally implemented this feature in 2006\. The cgroups
    functionality was merged into the Linux kernel mainline in kernel version 2.6.24,
    which was released in January 2008.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌工程师最初在 2006 年实现了这一功能。控制组功能在 Linux 内核主线中被合并到 2.6.24 版本中，该版本于 2008 年 1 月发布。
- en: Using cgroups, administrators can limit the resources that containers can consume.
    With this, we can avoid, for example, the classic noisy neighbor problem, where
    a rogue process running in a container consumes all the CPU time or reserves massive
    amounts of RAM and, as such, starves all the other processes running on the host,
    whether they’re containerized or not.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cgroups，管理员可以限制容器可以消耗的资源。通过这种方式，我们可以避免例如经典的吵闹邻居问题，即运行在容器中的恶意进程占用所有 CPU 时间或大量内存，并因此使得所有运行在主机上的其他进程无法正常运行，无论它们是否被容器化。
- en: Union filesystem
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: '**Union filesystem** (**unionfs**) forms the backbone of what is known as container
    images. We will discuss container images in detail in the next chapter. Currently,
    we want to just understand what unionfs is and how it works a bit better. unionfs
    is mainly used on Linux and allows files and directories of distinct filesystems
    to be overlaid to form a single coherent filesystem. In this context, the individual
    filesystems are called branches. Contents of directories that have the same path
    within the merged branches will be seen together in a single merged directory,
    within the new virtual filesystem. When merging branches, the priority between
    the branches is specified. In that way, when two branches contain the same file,
    the one with the higher priority is seen in the final filesystem.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合文件系统** (**unionfs**) 构成了所谓容器镜像的基础。在下一章中，我们将详细讨论容器镜像。目前，我们只想稍微了解一下unionfs是什么，以及它是如何工作的。unionfs主要用于Linux，允许将不同文件系统中的文件和目录叠加在一起，形成一个单一的连贯文件系统。在这种情况下，单独的文件系统被称为分支。当合并的分支中有相同路径的目录时，这些目录的内容将在新的虚拟文件系统中的单一合并目录中一起显示。在合并分支时，会指定分支之间的优先级。通过这种方式，当两个分支包含相同的文件时，最终文件系统中会显示优先级更高的文件。'
- en: Container plumbing
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器管道
- en: The foundation on top of which Docker Engine is built comprises two components,
    `runc` and `containerd`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine构建的基础由两个组件组成，`runc` 和 `containerd`。
- en: Originally, Docker was built in a monolithic way and contained all of the functionality
    necessary to run containers. Over time, this became too rigid, and Docker started
    to break out parts of the functionality into their own components. Two important
    components are `runc` and `containerd`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Docker是以单体方式构建的，并包含运行容器所需的所有功能。随着时间的推移，这种方式变得过于僵化，Docker开始将一些功能拆分为独立的组件。两个重要的组件是`runc`和`containerd`。
- en: runc
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: runc
- en: runc is a lightweight, portable container runtime. It provides full support
    for Linux namespaces as well as native support for all security features available
    on Linux, such as SELinux, AppArmor, seccomp, and cgroups.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: runc是一个轻量级、可移植的容器运行时。它全面支持Linux命名空间，并原生支持Linux上所有的安全特性，如SELinux、AppArmor、seccomp和cgroups。
- en: runC is a tool for spawning and running containers according to the **Open Container
    Initiative** (**OCI**) specification. It is a formally specified configuration
    format, governed by the **Open Container Project** (**OCP**) under the auspices
    of the Linux Foundation.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: runC是一个根据**开放容器倡议** (**OCI**) 规范生成和运行容器的工具。它是一个正式指定的配置格式，由**开放容器项目** (**OCP**)
    在Linux基金会的支持下管理。
- en: containerd
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containerd
- en: runC is a low-level implementation of a container runtime; containerd builds
    on top of it and adds higher-level features, such as image transfer and storage,
    container execution, and supervision as well as network and storage attachments.
    With this, it manages the complete life cycle of containers. containerd is the
    reference implementation of the OCI specifications and is by far the most popular
    and widely used container runtime.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: runC是容器运行时的低级实现；containerd在其之上构建，添加了更高级的功能，如镜像传输与存储、容器执行与监控，以及网络和存储附加。通过这些，containerd管理容器的完整生命周期。containerd是OCI规范的参考实现，是目前最流行和广泛使用的容器运行时。
- en: Containerd was donated to and accepted by the CNCF in 2017\. There are alternative
    implementations of the OCI specification. Some of them are `rkt` by CoreOS, CRI-O
    by Red Hat, and LXD by Linux Containers. However, containerd is currently by far
    the most popular container runtime and is the default runtime of Kubernetes 1.8
    or later and the Docker platform.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Containerd于2017年捐赠并被CNCF接受。OCI规范有其他的实现方式，其中一些包括CoreOS的`rkt`、Red Hat的CRI-O和Linux
    Containers的LXD。然而，containerd目前仍然是最流行的容器运行时，并且是Kubernetes 1.8及更高版本和Docker平台的默认运行时。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you learned how to work with containers that are based on existing
    images. We showed how to run, stop, start, and remove a container. Then, we inspected
    the metadata of a container, extracted its logs, and learned how to run an arbitrary
    process in an already-running container. Last but not least, we dug a bit deeper
    and investigated how containers work and what features of the underlying Linux
    operating system they leverage.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用基于现有镜像的容器。我们展示了如何运行、停止、启动和删除容器。接着，我们检查了容器的元数据，提取了它的日志，并了解了如何在一个已经运行的容器中运行任意进程。最后，我们深入探讨了容器的工作原理以及它们利用底层Linux操作系统的哪些特性。
- en: In the next chapter, you’re going to learn what container images are and how
    we can build and share our own custom images. We’ll also be discussing the best
    practices commonly used when building custom images, such as minimizing their
    size and leveraging the image cache. Stay tuned!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习什么是容器镜像，以及我们如何构建和分享自己的自定义镜像。我们还将讨论构建自定义镜像时常用的最佳实践，例如最小化镜像大小和利用镜像缓存。敬请期待！
- en: Further reading
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章提供了与本章讨论主题相关的更多信息：
- en: Get started with containers at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)开始使用容器
- en: Get an overview of Docker container commands at [http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Docker 容器命令的概览，详见[http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
- en: Learn about isolating containers with a user namespace at [http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何通过用户命名空间来隔离容器，详见[http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
- en: Learn about limiting a container’s resources at [http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何限制容器的资源，详见[http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
- en: Questions
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your learning progress, please answer the following questions:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你的学习进度，请回答以下问题：
- en: Which two important concepts of Linux are enabling factors for containers?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪两个重要的 Linux 概念是容器的启用因素？
- en: What are the possible states a container can be in?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器可能处于哪些状态？
- en: Which command helps us to find out which containers are currently running on
    our Docker host?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令帮助我们查找当前在 Docker 主机上运行的容器？
- en: Which command is used to list only the IDs of all containers?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于仅列出所有容器的 ID？
- en: Answers
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章提出问题的一些示例答案：
- en: Linux had to first introduce **namespaces** and **cgroups** to make containers
    possible. Containers use those two concepts extensively. Namespaces are used to
    encapsulate and thus protect resources defined and/or running inside a container.
    cgroups are used to limit the resources processes running inside a container can
    use, such as memory, bandwidth, or CPU.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux 首先引入了**命名空间**和**cgroups**来使容器成为可能。容器广泛使用这两个概念。命名空间用于封装并保护容器内部定义和/或运行的资源。cgroups
    用于限制容器内部进程可使用的资源，如内存、带宽或 CPU。
- en: 'The possible states of a Docker container are as follows:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 容器的可能状态如下：
- en: '`created`: A container that has been created but not started'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`：已创建但尚未启动的容器'
- en: '`restarting`: A container that is in the process of being restarted'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restarting`：正在重启的容器'
- en: '`running`: A currently running container'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running`：当前正在运行的容器'
- en: '`paused`: A container whose processes have been paused'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paused`：进程已暂停的容器'
- en: '`exited`: A container that ran and completed'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exited`：已运行并完成的容器'
- en: '`dead`: A container that Docker Engine tried and failed to stop'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dead`：Docker 引擎尝试并未成功停止的容器'
- en: 'We can use the following (or the old, shorter version, `docker ps`):'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令（或旧的较短版本`docker ps`）：
- en: '[PRE74]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is used to list all containers that are currently running on our Docker
    host. Note that this will *not* list the stopped containers, for which you need
    the extra `--all` (or `-a`) parameter.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于列出当前在我们的 Docker 主机上运行的所有容器。请注意，这不会列出已停止的容器，若要查看这些容器，需要额外使用`--all`（或`-a`）参数。
- en: 'To list all container IDs, running or stopped, we can use the following:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有容器的 ID（无论是运行中还是已停止），我们可以使用以下命令：
- en: '[PRE75]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, `-q` stands for output ID only, and `-a` tells Docker that we want to
    see all containers, including stopped ones.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`-q`表示仅输出 ID，`-a`告诉 Docker 我们要查看所有容器，包括已停止的容器。
