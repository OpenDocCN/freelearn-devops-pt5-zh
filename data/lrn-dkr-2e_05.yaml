- en: Testing with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 进行测试
- en: Undoubtedly, the trait of testing has been at the forefront of the software
    engineering discipline. The deep and decisive presence of software in every kind
    of tangible object in our daily environments these days in order to have plenty
    of smart, connected, and digitized assets is widely accepted. Also, with an increased
    focus on distributed and synchronized software, the complexity of the software
    design, development, testing and debugging, deployment, and delivery are continuously
    on the rise. Various means and mechanisms are unearthed to simplify and streamline
    the much-needed automation of software building and the authentication of software
    reliability, resiliency, and sustainability. Docker is emerging as an extremely
    flexible tool to test a wide variety of software applications. In this chapter,
    we will discuss how to effectively leverage the noteworthy advancements of Docker
    for software testing and its unique advantages in accelerating and augmenting
    testing automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，测试这一特性一直处于软件工程学科的前沿。如今，软件在我们日常环境中每种有形物体中的深远影响已广泛被接受，这些物体都为了拥有大量智能、连接和数字化的资产。此外，随着对分布式和同步软件的关注增加，软件的设计、开发、测试、调试、部署和交付的复杂性也在不断上升。各种手段和机制被发现，以简化和优化软件构建自动化以及验证软件的可靠性、弹性和可持续性。Docker
    正在成为一个极其灵活的工具，用于测试各种软件应用程序。在本章中，我们将讨论如何有效地利用 Docker 的显著进展进行软件测试，并探讨其在加速和增强测试自动化方面的独特优势。
- en: 'The following topics are discussed in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题包括：
- en: A brief overview of TDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试驱动开发（TDD）**概述'
- en: Testing your code inside Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 中测试你的代码
- en: Integrating the Docker testing process into Jenkins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Docker 测试过程集成到 Jenkins 中
- en: Docker containers are currently being leveraged to create development and testing
    environments that are the exact replicas of the production environment. Containers
    require less overhead when compared with virtual machines, which have been the
    primary environments for development, staging, and deployment environments. Let's
    start with an overview of **Test-driven Development** (**TDD**) of the next generation
    software and how Docker-inspired containerization becomes handy in simplifying
    the TDD process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Docker 容器被广泛用于创建与生产环境完全相同的开发和测试环境。与虚拟机相比，容器所需的开销更小，虚拟机一直是开发、预发布和部署环境的主要方式。让我们从下一代软件的**测试驱动开发（TDD）**概述开始，看看
    Docker 启发的容器化如何在简化 TDD 过程时变得非常实用。
- en: A brief overview of TDD
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**测试驱动开发（TDD）**概述'
- en: The long and arduous journey of software development has taken many twists and
    turns in the past decades, and one of the prominent software engineering technique
    is nonetheless TDD.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发这条漫长而艰辛的旅程在过去几十年中经历了许多曲折变化，而**测试驱动开发（TDD）**无疑是其中一个突出的软件工程技术。
- en: For more details and documents on TDD refer to [http://agiledata.org/essays/tdd.html](http://agiledata.org/essays/tdd.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于 TDD 的详细信息和文档，请访问 [http://agiledata.org/essays/tdd.html](http://agiledata.org/essays/tdd.html)。
- en: 'In a nutshell, TDD is a software development practice in which the development
    cycle begins with writing a test case that will fail, then writes the actual software
    to make the test pass, and continues to refactor and repeat the cycle till the
    software reaches the acceptable level. This process is depicted in the following
    diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，TDD 是一种软件开发实践，其中开发周期以编写一个会失败的测试用例开始，然后编写实际的软件以通过该测试，接着持续重构并重复这一周期，直到软件达到可接受的水平。这个过程如下图所示：
- en: '![](img/image_09_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_001.jpg)'
- en: Testing your code inside Docker
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Docker 中测试你的代码
- en: In this section, we will take you through a journey in which we will show you
    how TDD is done using stubs and how Docker can come in handy when developing software
    in the deployment equivalent system. For this purpose, we take a web application
    use case that has a feature to track the visit count of each of its users. For
    this example, we use Python as the implementation language and `redis` as the
    key-value pair database to store the users hit count. Besides, to showcase the
    testing capability of Docker, we limit our implementation to just two functions—`hit`
    and `getHit`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将带领你踏上一个旅程，展示如何使用存根（stubs）进行 TDD，并演示在等同于部署系统的环境中开发软件时 Docker 如何发挥作用。为了这个目的，我们选择了一个网页应用的使用案例，其中有一个功能可以跟踪每个用户的访问次数。在这个例子中，我们使用
    Python 作为实现语言，`redis` 作为存储用户访问次数的键值数据库。此外，为了展示 Docker 的测试能力，我们将实现限制为两个函数——`hit`
    和 `getHit`。
- en: All the examples in this chapter use Python 3 as the runtime environment. The
    Ubuntu 16.04 installation comes with Python 3 by default. If you don't have Python
    3 installed on your system, refer to the respective manual to install Python 3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都使用Python 3作为运行环境。Ubuntu 16.04安装默认包含Python 3。如果你的系统没有安装Python 3，请参考相应的手册进行安装。
- en: 'As per the TDD practice, we start by adding unit test cases for the `hit` and
    `getHit` functions, as depicted in the following code snippet. Here, the test
    file is named `test_hitcount.py`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据TDD实践，我们首先为`hit`和`getHit`函数添加单元测试用例，如以下代码片段所示。这里，测试文件命名为`test_hitcount.py`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example is also available at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例也可以在[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)找到。
- en: Here, in the first line, we are importing the `unittest` Python module that
    provides the necessary framework and functionality to run the unit test and generate
    a detailed report on the test execution. In the second line, we are importing
    the `hitcount` Python module, where we are going to implement the hit count functionality.
    Then, we will continue to add the test code that will test the `hitcount` module's
    functionality.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行我们导入了`unittest` Python模块，它提供了必要的框架和功能来运行单元测试，并生成关于测试执行的详细报告。第二行，我们导入了`hitcount`
    Python模块，在该模块中我们将实现点击计数功能。然后，我们将继续添加测试代码，以测试`hitcount`模块的功能。
- en: 'Now, run the test suite using the unit test framework of Python, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Python的单元测试框架运行测试套件，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output generated by the unit test framework:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单元测试框架生成的输出：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As expected, the test failed with the `ImportError: No module named ''hitcount''`
    error message because we had not even created the file and hence, it could not
    import the `hitcount` module.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '如预期所示，测试失败并显示`ImportError: No module named ''hitcount''`错误信息，因为我们还没有创建该文件，因此无法导入`hitcount`模块。'
- en: 'Now, create a file with the `hitcount.py` name in the same directory as `test_hitcount.py`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在与`test_hitcount.py`相同的目录下创建一个名为`hitcount.py`的文件：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Continue to run the unit test suite:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行单元测试套件：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the output generated by the unit test framework:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单元测试框架生成的输出：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, the test suite failed like earlier, but with a different error message
    `AttributeError: ''module'' object has no attribute ''hit''`. We are getting this
    error because we have not implemented the `hit` function yet.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '如之前一样，测试套件失败了，但错误信息有所不同，显示为`AttributeError: ''module'' object has no attribute
    ''hit''`。我们之所以收到此错误，是因为我们还没有实现`hit`函数。'
- en: 'Let''s proceed to implement the `hit` and `getHit` functions in `hitcount.py`,
    as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`hitcount.py`中实现`hit`和`getHit`函数，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例也可以在GitHub上找到：[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)。
- en: To continue with this example, you must have the Python 3 compatible version
    of package installer (`pip3`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续这个示例，你必须有与Python 3兼容的包管理器版本（`pip3`）。
- en: 'The following command is used to install `pip3`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于安装`pip3`：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line of the preceding program, we are importing the `redis` driver,
    which is the connectivity driver of the `redis` database. In the following line,
    we are connecting to the `redis` database, and then we will continue to implement
    the `hit` and `getHit` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述程序的第一行，我们导入了`redis`驱动，它是连接`redis`数据库的驱动。在接下来的行中，我们将连接到`redis`数据库，然后继续实现`hit`和`getHit`函数。
- en: 'The `redis` driver is an optional Python module, so let''s proceed to install
    the `redis` driver using the `pip` installer, which is illustrated as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis`驱动是一个可选的Python模块，因此我们接下来将使用`pip`安装器安装`redis`驱动，如下所示：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our `unittest` module will still fail even after installing the `redis` driver
    because we are not running a `redis` database server yet. So, we can either run
    a `redis` database server to successfully complete our unit testing or take the
    traditional TDD approach of mocking the `redis` driver. Mocking is a testing approach
    wherein complex behavior is substituted by predefined or simulated behavior. In
    our example, to mock the `redis` driver, we are going to leverage a third-party
    Python package called `mockredis`. This mock package is available at [https://github.com/locationlabs/mockredis](https://github.com/locationlabs/mockredis)
    and the `pip` installer name is `mockredispy`. Let''s install this mock using
    the `pip` installer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使安装了`redis`驱动程序，我们的`unittest`模块仍然会失败，因为我们尚未运行`redis`数据库服务器。因此，我们可以运行`redis`数据库服务器以成功完成单元测试，或者采用模拟`redis`驱动程序的传统TDD方法。模拟是一种测试方法，其中复杂的行为被预定义或模拟的行为替代。在我们的示例中，为了模拟`redis`驱动程序，我们将利用一个名为`mockredis`的第三方Python包。此模拟包可在[https://github.com/locationlabs/mockredis](https://github.com/locationlabs/mockredis)获取，并且`pip`安装器名称为`mockredispy`。让我们使用`pip`安装器安装这个模拟：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having installed `mockredispy`, the `redis` mock, let''s refactor our test
    code `test_hitcount.py` (which we had written earlier) to use the simulated `redis`
    functionality provided by the `mockredis` module. This is accomplished by the
    `patch` method provided by the `unittest.mock` mocking framework, as shown in
    the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`mockredispy`模拟`redis`后，让我们重构我们之前编写的测试代码`test_hitcount.py`，以使用`mockredis`模块提供的模拟`redis`功能。这可以通过`unittest.mock`模拟框架提供的`patch`方法来实现，如下所示的代码所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在GitHub上获取，地址为[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)。
- en: 'Now, run the test suite again:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行测试套件：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, as we can see in the preceding output, we successfully implemented
    our visitors count functionality through the test, code, and refactor cycle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们在前面的输出中所看到的，我们成功通过测试、代码和重构周期实现了访客计数功能。
- en: Running the test inside a container
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在容器内运行测试
- en: In the previous section, we walked you through the complete cycle of TDD, in
    which we installed additional Python packages to complete our development. However,
    in the real world, one might work on multiple projects that might have conflicting
    libraries and hence, there is a need for the isolation of runtime environments.
    Before the advent of Docker technology, the Python community used to leverage
    the Virtualenv tool to isolate the Python runtime environment. Docker takes this
    isolation a step further by packaging the OS, the Python toolchain, and the runtime
    environment. This type of isolation gives a lot of flexibility to the development
    community to use appropriate software versions and libraries as per the project
    needs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们为您介绍了TDD的完整周期，我们安装了额外的Python包以完成开发。然而，在现实世界中，一个人可能会在多个可能存在冲突的项目上工作，因此需要隔离运行时环境。在Docker技术出现之前，Python社区通常使用Virtualenv工具来隔离Python运行时环境。Docker通过打包操作系统、Python工具链和运行时环境进一步加强了这种隔离。这种隔离方式为开发社区提供了很大的灵活性，可以根据项目需求使用适当的软件版本和库。
- en: 'Here is the step-by-step procedure to package the test and visitor count implementation
    of the previous section to a Docker container and perform the test inside the
    container:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将上一节的测试和访客计数实现打包到Docker容器中并在容器内执行测试的逐步过程：
- en: 'Craft a `Dockerfile` to build an image with the `python3` runtime, the `redis`
    and `mockredispy` packages, and both the `test_hitcount.py` test file and the
    visitors count implementation `hitcount.py`, and finally, launch the unit test:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Dockerfile`来构建一个包含`python3`运行时环境、`redis`和`mockredispy`包以及`test_hitcount.py`测试文件和访客计数实现`hitcount.py`的镜像，最后启动单元测试：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在GitHub上获取，地址为[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)。
- en: Now create a directory called `src`, where we crafted our `Dockerfile`. Move
    the `test_hitcount.py` and `hitcount.py` files to the newly created `src` directory.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为`src`的目录，我们在其中编写了我们的`Dockerfile`。将`test_hitcount.py`和`hitcount.py`文件移动到新创建的`src`目录。
- en: 'Build the `hit_unittest` Docker image using the `docker build` subcommand:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`hit_unittest` Docker镜像使用`docker build`子命令：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have successfully built the image, let''s launch our container
    with the unit testing bundle using the `docker run` subcommand, as illustrated
    here:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已成功构建了镜像，让我们使用 `docker run` 子命令启动包含单元测试包的容器，如下所示：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Apparently, the unit test ran successfully with no errors because we already
    packaged the tested code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，单元测试运行成功了，没有错误，因为我们已经打包了经过测试的代码。
- en: In this approach, for every change, the Docker image is built and then the container
    is launched to complete the test.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，对于每一个变更，都会构建 Docker 镜像，然后启动容器完成测试。
- en: Using a Docker container as a runtime environment
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Docker 容器作为运行时环境
- en: In the previous section, we built a Docker image to perform the testing. Particularly,
    in the TDD practice, the unit test cases and the code go through multiple changes.
    Consequently, the Docker image needs to be built over and over again, which is
    a daunting task. In this section, we will see an alternative approach in which
    the Docker container is built with a runtime environment, the development directory
    is mounted as a volume, and the test is performed inside the container.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们构建了一个 Docker 镜像来执行测试。特别是在 TDD 实践中，单元测试用例和代码会经历多次更改。因此，需要多次构建 Docker
    镜像，这是一项令人望而却步的任务。在本节中，我们将看到一种替代方法，其中 Docker 容器带有运行时环境，开发目录作为卷挂载，并在容器内执行测试。
- en: During this TDD cycle, if an additional library or update to the existing library
    is required, then the container will be updated with the required libraries and
    the updated container will be committed as a new image. This approach gives the
    isolation and flexibility that any developer would dream of because the runtime
    and its dependency live within the container, and any misconfigured runtime environment
    can be discarded and a new runtime environment can be built from a previously
    working image. This also helps to preserve the sanity of the Docker host from
    the installation and uninstallation of libraries.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 TDD 周期中，如果需要额外的库或更新现有库，那么容器将使用所需的库更新，并且更新后的容器将被提交为一个新镜像。这种方法提供了开发者梦寐以求的隔离性和灵活性，因为运行时及其依赖项存在于容器内，任何配置错误的运行时环境都可以被丢弃，并且可以从先前工作的镜像构建一个新的运行时环境。这也有助于保持
    Docker 主机的清醒状态，避免因库的安装和卸载而导致混乱。
- en: 'The following example is a step-by-step instruction on how to use the Docker
    container as a non-polluting yet very powerful runtime environment:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是如何将 Docker 容器作为一个非污染但非常强大的运行时环境的逐步说明：
- en: 'We begin with launching the Python runtime interactive container, using the
    `docker run` subcommand:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先启动 Python 运行时的交互式容器，使用 `docker run` 子命令：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, in this example, the `/home/peter/src/hitcount` Docker host directory
    is earmarked as the placeholder for the source code and test files. This directory
    is mounted in the container as `/src`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`/home/peter/src/hitcount` Docker 主机目录被指定为源代码和测试文件的占位符。这个目录作为 `/src`
    挂载到容器中。
- en: Now, on another Terminal of the Docker host, copy both the `test_hitcount.py`
    test file and the `hitcount.py` visitors count implementation to the `/home/peter/src/hitcount`
    directory.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 Docker 主机的另一个终端上，将 `test_hitcount.py` 测试文件和 `hitcount.py` 访问者计数实现复制到 `/home/peter/src/hitcount`
    目录中。
- en: 'Switch to the Python runtime interactive container Terminal, change the current
    working directory to `/src`, and run the unit test:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Python 运行时的交互式容器终端，将当前工作目录更改为 `/src`，并运行单元测试：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Evidently, the test failed because it could not find the `mockredis` Python
    library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，由于找不到 `mockredis` Python 库，测试失败了。
- en: 'Proceed to install the `mockredispy` pip package because the previous step
    failed as it could not find the `mockredis` library in the runtime environment:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续安装 `mockredispy` pip 包，因为之前的步骤由于在运行时环境中找不到 `mockredis` 库而失败了：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Rerun the Python unit test:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行 Python 单元测试：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, the test failed because the `redis` driver is not yet installed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于尚未安装 `redis` 驱动程序，测试失败了。
- en: 'Continue to install the `redis` driver using the `pip` installer, as shown
    here:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用 `pip` 安装器安装 `redis` 驱动程序，如下所示：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Having successfully installed the `redis` driver, let''s once again run the
    unit test:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功安装了 `redis` 驱动程序后，让我们再次运行单元测试：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Apparently, this time the unit test passed with no warnings or error messages.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这次单元测试通过了，没有任何警告或错误消息。
- en: 'Now we have a runtime environment that is good enough to run our test cases.
    It is better to commit these changes to a Docker image for reuse, using the `docker
    commit` subcommand:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们拥有了一个足够好的运行时环境来运行测试用例。最好将这些更改提交到 Docker 镜像中以便重复使用，使用 `docker commit` 子命令：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From now on, we can use the `python_rediswithmock` image to launch new containers
    for our TDD.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以使用 `python_rediswithmock` 镜像启动新容器进行我们的 TDD。
- en: In this section, we vividly illustrated the approach on how to use the Docker
    container as a testing environment, and also at the same time, preserve the sanity
    and sanctity of the Docker host by isolating and limiting the runtime dependency
    within the container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们生动地展示了如何使用 Docker 容器作为测试环境，同时通过将运行时依赖关系限制在容器内，保持 Docker 主机的正常性和神圣性。
- en: Integrating Docker testing into Jenkins
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Docker 测试集成到 Jenkins 中
- en: In the previous section, we laid out a stimulating foundation on software testing,
    how to leverage the Docker technology for the software testing, and the unique
    benefits of the container technology during the testing phase. In this section,
    we will introduce you to the steps required to prepare the Jenkins environment
    for testing with Docker, and then, demonstrate how Jenkins can be extended to
    integrate and automate testing with Docker, using the well-known hit count use
    case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们为软件测试奠定了刺激的基础，展示了如何利用 Docker 技术进行软件测试，以及在测试阶段容器技术的独特优势。在本节中，我们将向您介绍准备
    Jenkins 环境以进行 Docker 测试所需的步骤，然后演示如何扩展 Jenkins 集成并自动化 Docker 测试，使用广为人知的点击计数用例。
- en: Preparing the Jenkins environment
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备 Jenkins 环境
- en: 'In this section, we will take you through the steps to install Jenkins, the
    GitHub plugin for Jenkins and `git`, and the revision control tool. The steps
    are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将引导您完成安装 Jenkins、Jenkins 的 GitHub 插件以及 `git` 和版本控制工具的步骤。步骤如下：
- en: 'We begin with adding the Jenkins'' trusted PGP public key:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加 Jenkins 的受信任 PGP 公钥：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are using `wget` to download the PGP public key, and then we add it
    to the list of trusted keys using the `apt-key` tool. Since Ubuntu and Debian
    share the same software packaging, Jenkins provides a single common package for
    both Ubuntu and Debian.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `wget` 下载 PGP 公钥，然后使用 `apt-key` 工具将其添加到受信任的密钥列表中。由于 Ubuntu 和 Debian
    共享相同的软件包，因此 Jenkins 提供了一个通用的软件包，适用于这两个系统。
- en: 'Add the Debian package location to the `apt` package source list, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Debian 软件包位置添加到 `apt` 软件包源列表中，如下所示：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After adding the package source, continue to run the `apt-get` command `update`
    option to resynchronize the package index from the sources:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加软件包源后，继续运行 `apt-get` 命令的 `update` 选项以重新同步来自源的软件包索引：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, install Jenkins using the `apt-get` command `install` option, as demonstrated
    here:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `apt-get` 命令的 `install` 选项安装 Jenkins，如下所示：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, activate the Jenkins service using the `service` command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `service` 命令激活 Jenkins 服务：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Jenkins service can be accessed through any web browser by specifying the
    IP address (`54.86.87.243`) of the system in which Jenkins is installed. The default
    port number for Jenkins is `8080`. The latest Jenkins 2.62 is already installed.
    The following screenshot is the entry page or dashboard of Jenkins:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 服务可以通过任何 Web 浏览器访问，只需指定安装 Jenkins 的系统的 IP 地址（`54.86.87.243`）。Jenkins
    的默认端口号是 `8080`。最新版本的 Jenkins 2.62 已经安装。以下截图是 Jenkins 的入口页面或仪表盘：
- en: '![](img/image_09_002.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_002.jpg)'
- en: 'Provide the password from the file and login. This user is the admin:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供文件中的密码并登录。此用户为管理员：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will take you to the Customize Jenkins page, as shown in the following
    screenshot:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带您进入“自定义 Jenkins”页面，如下截图所示：
- en: '![](img/image_09_003.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_003.jpg)'
- en: Select Install suggested plugins on the left-hand side of the screen, which
    will take us to the installation page.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左侧选择“安装推荐插件”，这将带我们进入安装页面。
- en: 'On the Create First Admin User page, select Continue as admin:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建第一个管理员用户页面，选择“继续作为管理员”：
- en: '**![](img/image_09_004.jpg)**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/image_09_004.jpg)**'
- en: 'This will take us to the Jenkins is ready! page, as shown in the following
    screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们进入“Jenkins 已准备好！”页面，如下截图所示：
- en: '![](img/image_09_005.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_005.jpg)'
- en: 'Now, clicking on the Start using Jenkins button will take you to the Welcome
    to Jenkins! page:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击“开始使用 Jenkins”按钮将带您进入“欢迎使用 Jenkins！”页面：
- en: '![](img/image_09_006.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_006.jpg)'
- en: 'Ensure that the `git` package is installed, otherwise install the `git` package
    using the `apt-get` command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已安装`git`包，否则请使用`apt-get`命令安装`git`包：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far, we have been running the Docker client using the `sudo` command, but
    unfortunately, we could not invoke `sudo` inside Jenkins because sometimes it
    prompts for a password. To overcome the `sudo` password prompt issue, we can make
    use of the Docker group, wherein any user who is part of the Docker group can
    invoke the Docker client without using the `sudo` command. Jenkins installation
    always sets up a user and group called `jenkins` and runs the Jenkins server using
    that user and group. So, we just need to add the `jenkins` user to the Docker
    group to get the Docker client working without the sudo command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用`sudo`命令运行Docker客户端，但不幸的是，我们无法在Jenkins中调用`sudo`，因为有时它会提示输入密码。为了解决`sudo`密码提示问题，我们可以利用Docker组，Docker组中的任何用户都可以在不使用`sudo`命令的情况下调用Docker客户端。Jenkins安装过程中会自动创建一个名为`jenkins`的用户和组，并使用该用户和组运行Jenkins服务。因此，我们只需要将`jenkins`用户添加到Docker组中，就可以使Docker客户端在没有sudo命令的情况下正常工作：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Restart the Jenkins service for the group change to take effect using the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令重启Jenkins服务，以便使组更改生效：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have set up a Jenkins environment that is now capable of automatically pulling
    the latest source code from the [http://github.com](http://github.com) repository,
    packaging it as a Docker image, and executing the prescribed test scenarios.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个Jenkins环境，现在可以自动从[http://github.com](http://github.com)仓库中拉取最新的源代码，将其打包成Docker镜像，并执行预定的测试场景。
- en: You are also encouraged to run Jenkins as a Docker container from the official
    Jenkins Docker image at [https://github.com/jenkinsci/docker](https://github.com/jenkinsci/docker).
    This will be very good exercise also to validate your Docker container concepts
    from previous chapters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议您从官方Jenkins Docker镜像中以Docker容器形式运行Jenkins，镜像地址为[https://github.com/jenkinsci/docker](https://github.com/jenkinsci/docker)。这也是一个很好的练习，能帮助您验证前几章中学习的Docker容器概念。
- en: Automating the Docker testing process
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化Docker测试过程
- en: In this section, we will explore how to automate testing using Jenkins and Docker.
    As mentioned earlier, we are going to use GitHub as our repository. We have already
    uploaded the `Dockerfile`, `test_hitcount.py`, and `hitcount.py` files of our
    previous example to GitHub at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    which we are to use in the ensuing example. However, we strongly encourage you
    to set up your own repository at
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Jenkins和Docker实现自动化测试。如前所述，我们将使用GitHub作为我们的代码仓库。我们已经将之前示例中的`Dockerfile`、`test_hitcount.py`和`hitcount.py`文件上传到了GitHub，地址为[https://github.com/thedocker/testing](https://github.com/thedocker/testing)，接下来的示例将使用这些文件。然而，我们强烈建议您创建自己的代码仓库，地址为
- en: '[http://github.com](http://github.com), using the fork option that you can
    find at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    and substitute this address wherever applicable in the ensuing example.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://github.com](http://github.com)，使用fork选项，您可以在[https://github.com/thedocker/testing](https://github.com/thedocker/testing)找到此选项，并在接下来的示例中将此地址替换为合适的地方。'
- en: 'The following are the detailed steps to automate Docker testing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是自动化Docker测试的详细步骤：
- en: 'Configure Jenkins to trigger a build when a file is modified in the GitHub
    repository, which is illustrated in the following substeps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Jenkins以在GitHub仓库中的文件被修改时触发构建，以下是相关子步骤的说明：
- en: Connect to the Jenkins server again.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次连接到Jenkins服务器。
- en: Select create new jobs.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建新任务。
- en: 'As shown in the following screenshot, give a name to the project (for example,
    `Docker-Testing`), and select Freestyle project:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，为项目命名（例如，`Docker-Testing`），并选择自由风格项目：
- en: '![](img/JenkinsUpdate_1.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/JenkinsUpdate_1.png)'
- en: 'As shown in the next screenshot, select the Git radio button under Source Code
    Management, and specify the GitHub repository URL in the Repository URL text field:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，在源代码管理下选择Git单选按钮，并在仓库URL文本框中指定GitHub仓库的URL：
- en: '![](img/image_09_008.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_008.jpg)'
- en: Select Poll SCM under Build Triggers to schedule GitHub polling for every
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建触发器下选择Poll SCM，以安排每次
- en: '15-minute interval. Type the following line of code `H/15 * * * *` in the Schedule
    textbox, as shown in the following screenshot. For testing purposes, you can reduce
    the polling interval:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 15分钟间隔。在Schedule文本框中输入以下代码`H/15 * * * *`，如下图所示。出于测试目的，您可以减少轮询间隔：
- en: '![](img/JenkinsUpdate_2.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/JenkinsUpdate_2.png)'
- en: 'Scroll down the screen a little further and click on the Add build step button
    under Build. In the drop-down list, select Execute shell and type in the text,
    as shown in the following screenshot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动屏幕，点击“Build”下的“Add build step”按钮。在下拉列表中，选择“Execute shell”，并输入文本，如下截图所示：
- en: '![](img/JenkinsUpdate_3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/JenkinsUpdate_3.png)'
- en: Finally, save the configuration by clicking on the Save button.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过点击“保存”按钮保存配置。
- en: 'Go back to the Jenkins dashboard, and you can find your test listed on the
    dashboard:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Jenkins仪表板，你可以在仪表板上看到你的测试列出：
- en: '![](img/image_09_011.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_011.jpg)'
- en: 'You can either wait for the Jenkins schedule to kick-start the build or you
    can click on the clock icon on the right-hand side of the screen to kick-start
    the build immediately. As soon as the build is done, the dashboard is updated
    with the build status as a success or failure and the build number:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以等候Jenkins计划启动构建，或者点击屏幕右侧的时钟图标立即启动构建。构建完成后，仪表板会更新构建状态为成功或失败，并显示构建编号：
- en: '![](img/image_09_012.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_012.jpg)'
- en: 'If you hover the mouse closer to the build number, you will get a drop-down
    button with options, such as Changes and Console Output, as shown in the following
    screenshot:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在构建编号上，你会看到一个下拉按钮，提供一些选项，如“Changes”和“Console Output”，如下截图所示：
- en: '![](img/image_09_013.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_013.jpg)'
- en: 'The Console Output option will show the details highlighted for the build,
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Console Output”选项将显示构建的详细信息，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's test the failed case because of the wrong module name, `error_hitcount`,
    which we deliberately introduced. Now, let's experiment a negative scenario by
    deliberately introducing a bug in `test_hitcount.py` and observe the effect on
    the Jenkins build. As we have configured Jenkins, it faithfully polls the GitHub
    and kick-starts the build.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试由于错误的模块名`error_hitcount`导致的失败案例，这是我们故意引入的。现在，让我们通过故意在`test_hitcount.py`中引入一个bug来实验一个负面场景，并观察其对Jenkins构建的影响。正如我们配置的Jenkins，它会忠实地轮询GitHub并启动构建。
- en: 'Apparently, the build failed as we expected:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，构建失败正如我们预期的那样：
- en: '![](img/image_09_014.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_014.jpg)'
- en: 'As a final step, open Console Output of the failed build:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，打开失败构建的控制台输出：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Evidently, the test failed because of the wrong module name, `error_hitcount`,
    which we deliberately introduced.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试失败是由于我们故意引入的错误模块名`error_hitcount`。
- en: Cool, isn't it? We automated our testing using Jenkins and Docker. Besides,
    we are able to experience the power of testing automation using Jenkins and Docker.
    In a large-scale project, Jenkins and Docker can be combined together to automate
    the complete unit testing needs, and thus, to automatically capture any defects
    and deficiencies introduced by any developers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 酷吧？我们通过Jenkins和Docker实现了自动化测试。而且，我们能够体验到Jenkins和Docker带来的测试自动化的强大。在大规模项目中，Jenkins和Docker可以结合使用，以自动化整个单元测试需求，从而自动捕捉由任何开发人员引入的缺陷和不足。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The potential benefits of containerization are being discovered across the breadth
    and the length of software engineering. Previously, testing sophisticated software
    systems involved a number of expensive and hard-to-manage server modules and clusters.
    Considering the costs and complexities involved, most of the software testing
    is accomplished using mocking procedures and stubs. All of this is going to end
    for good with the maturity of the Docker technology. The openness and flexibility
    of Docker enable it to work seamlessly with other technologies to substantially
    reduce the testing time and complexity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的潜在好处正在软件工程的各个领域得到发现。以往，测试复杂的软件系统需要多个昂贵且难以管理的服务器模块和集群。考虑到成本和复杂性，大部分软件测试都通过模拟过程和桩程序来完成。随着Docker技术的成熟，所有这些都将永远结束。Docker的开放性和灵活性使其能够与其他技术无缝协作，显著减少测试时间和复杂性。
- en: For a long time, the leading ways of testing software systems included mocking,
    dependency, injection, and so on. Usually, these mandate creating many sophisticated
    abstractions in the code. The current practice for developing and running test
    cases against an application is actually done on stubs rather than on the full
    application. This means that, with a containerized workflow, it is very much possible
    to test against real application containers with all the dependencies. The contributions
    of the Docker paradigm, especially for the testing phenomenon and phase are therefore
    being carefully expounded and recorded in the recent past. Precisely speaking,
    the field of software engineering is moving towards smarter and sunnier days with
    all the innovations in the Docker space.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，测试软件系统的主要方式包括模拟、依赖注入等。这些方式通常要求在代码中创建许多复杂的抽象层。当前，开发和运行测试用例的做法实际上是在存根（stub）上进行，而不是在完整的应用程序上进行。这意味着，通过容器化工作流，完全有可能在具有所有依赖项的真实应用程序容器上进行测试。因此，Docker范式，特别是在测试现象和阶段中的贡献，最近得到了细致的阐述和记录。准确来说，软件工程领域正朝着更加智能和光明的未来迈进，Docker领域的创新正推动这一进程。
- en: In this chapter, we clearly expounded and explained a powerful testing framework
    for integrated applications using the Docker-inspired containerization paradigm.
    Increasingly, for the agile world, the proven and potential TDD method is being
    insisted as an efficient software building and sustenance methodology. This chapter
    has utilized the Python unit test framework to illustrate how the TDD methodology
    is a pioneering tool for software engineering. The unit test framework is tweaked
    to be efficiently and elegantly containerized, and the Docker container is seamlessly
    integrated with Jenkins, which is a modern day deployment tool for continuous
    delivery, and is part and parcel of the agile programming world, as described
    in this chapter. The Docker container source code is pre-checked before it enters
    into the GitHub code repository. The Jenkins tool downloads the code from GitHub
    and runs the test inside a container. In the next chapter, we will dive deep into
    and describe the theoretical aspects of the process isolation through the container
    technology and various debugging tools and techniques.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们清晰地阐述和解释了一种强大的集成应用程序测试框架，该框架采用了Docker启发的容器化范式。对于敏捷世界来说，经过验证且具有潜力的TDD方法正被坚持作为高效的软件构建和维持方法论。本章利用Python单元测试框架来说明TDD方法论如何成为软件工程的开创性工具。单元测试框架经过调整，以高效且优雅地容器化，并且Docker容器与Jenkins无缝集成。Jenkins是一个现代的持续交付部署工具，是敏捷编程世界的重要组成部分，如本章所述。Docker容器的源代码在进入GitHub代码仓库之前会进行预检查。Jenkins工具从GitHub下载代码并在容器内运行测试。在下一章中，我们将深入探讨并描述通过容器技术进行进程隔离的理论方面，以及各种调试工具和技术。
