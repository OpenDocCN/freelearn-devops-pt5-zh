- en: Running Containers in AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 上运行容器
- en: In [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your Infrastructure*,
    our architecture changed quite a bit. We explored different ways to scale our
    applications in AWS, but one of the major technologies that we left out was containers.
    Containers are at the heart of the **software development life cycle** (**SDLC**)
    of many major technology companies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)《**扩展你的基础架构**》中，我们的架构发生了很大的变化。我们探索了在
    AWS 中扩展应用程序的不同方法，但我们遗漏的一个主要技术就是容器。容器是许多大型科技公司**软件开发生命周期**（**SDLC**）的核心。
- en: So far, we have used our personal computers to develop our applications. This
    works well for simple projects, such as our Hello World application. However,
    when it comes to more complex projects with many dependencies, it's a different
    story. Have you ever heard of situations in which a certain feature works on a
    developer's laptop but does not work for the rest of the organization-or-even
    worse, *does not work in production?* A lot of these issues stem from the differences
    between environments. When we build our staging and production environments, we
    rely on CloudFormation, Terraform, and Ansible, to keep those environments consistent.
    Unfortunately, we can't easily replicate that to our local development environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用个人电脑来开发应用程序。这对于简单的项目，如我们的 Hello World 应用程序，效果很好。然而，当涉及到有许多依赖关系的复杂项目时，情况就不同了。你是否听说过某些功能在开发者的笔记本电脑上运行正常，但在其他组织成员那里却无法运行——甚至更糟的是，*在生产环境中无法运行*？这些问题中的很多源于环境之间的差异。当我们构建我们的预发布和生产环境时，我们依赖
    CloudFormation、Terraform 和 Ansible 来保持这些环境的一致性。不幸的是，我们无法轻松地将其复制到本地开发环境中。
- en: Containers address this issue. With them, we can package an application and
    include the operating system, the application code, and everything in between.
    Containers can also help at a later stage, when it's time to break out the monolithic
    approach.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 容器解决了这个问题。通过容器，我们可以打包一个应用程序，并包括操作系统、应用程序代码以及中间所有的内容。容器还可以在稍后的阶段提供帮助，当需要突破单体架构时尤为重要。
- en: 'In this chapter, we will look at **Docker**, the most popular container technology.
    After a brief explanation of what Docker is and how to use its basic functionalities,
    we will Dockerize our application. This will help us to understand the value of
    using Docker as a developer. In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**Docker**，最受欢迎的容器技术。在简要说明 Docker 是什么以及如何使用其基本功能后，我们将对我们的应用程序进行 Docker
    化。这将帮助我们理解作为开发者使用 Docker 的价值。本章将涵盖以下主题：
- en: Dockerizing our Hello World application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的 Hello World 应用程序 Docker 化
- en: Using the EC2 container service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EC2 容器服务
- en: Updating our CI/CD pipeline to utilize ECS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新我们的 CI/CD 管道以使用 ECS
- en: This book covers ECS, but also offers further options for using Docker in AWS.
    You can also take a look at CoreOS Tectonic ([https://tectonic.com/](https://tectonic.com/)),
    Mesosphere DC/OS ([https://mesosphere.com](https://mesosphere.com/)), or Docker
    Datacenter ([https://www.docker.com/products/docker-datacenter](https://www.docker.com/products/docker-datacenter)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了 ECS，但还提供了在 AWS 中使用 Docker 的更多选项。你还可以查看 CoreOS Tectonic（[https://tectonic.com/](https://tectonic.com/)）、Mesosphere
    DC/OS（[https://mesosphere.com](https://mesosphere.com/)）或 Docker Datacenter（[https://www.docker.com/products/docker-datacenter](https://www.docker.com/products/docker-datacenter)）。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Dockerfile
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '**EC2 Container Registry** (**ECR**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EC2 容器注册表**（**ECR**）'
- en: '**Elastic Container Service** (**ECS**)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性容器服务**（**ECS**）'
- en: '**Application Load Balancer** (**ALB**)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用负载均衡器**（**ALB**）'
- en: CodeBuild
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeBuild
- en: CodePipeline
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodePipeline
- en: 'The GitHub links for the code used in this chapter are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码的 GitHub 链接如下：
- en: '[https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)'
- en: '[https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json)'
- en: '[https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py)'
- en: '[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py)'
- en: Dockerizing our Hello World application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的 Hello World 应用程序 Docker 化
- en: Docker, and containers in general, are very powerful tools, worth exploring.
    By combining resource isolation features, including **union capable filesystem**
    (**UCF**), Docker allows for the creation of packages called **containers**, which
    include everything that is needed to run an application. Containers, like virtual
    machines, are self-contained, but they virtualize the OS itself, instead of virtualizing
    the hardware. In practice, this makes a huge difference. As you have probably
    noticed by now, starting a virtual machine, such as an EC2 instance, takes time.
    This comes from the fact that in order to start a virtual machine, the hypervisor
    (that's the name of the technology that creates and runs virtual machines) has
    to simulate all of the motions involved in starting a physical server, loading
    an operating system, and going through the different run-levels. In addition,
    virtual machines have a much larger footprint on the disk and in the memory. With
    Docker, the added layer is hardly noticeable, and the size of the containers can
    stay very small. In order to better illustrate this, we will first install Docker
    and explore its basic usage a bit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和容器总体来说是非常强大的工具，值得深入探索。通过结合资源隔离功能，包括**联合能力文件系统**（**UCF**），Docker 允许创建称为**容器**的包，这些容器包含运行应用程序所需的所有内容。容器像虚拟机一样是自包含的，但它们虚拟化的是操作系统本身，而不是硬件。实际上，这带来了巨大的差异。正如你现在可能已经注意到的那样，启动虚拟机（例如
    EC2 实例）需要一定的时间。这是因为为了启动虚拟机，虚拟机监控器（这是创建和运行虚拟机的技术名称）必须模拟启动物理服务器、加载操作系统并通过不同运行级别所涉及的所有动作。此外，虚拟机在磁盘和内存上占据更大的空间。使用
    Docker 时，附加的层几乎不可察觉，而且容器的大小可以保持非常小。为了更好地说明这一点，我们将首先安装 Docker，并稍微了解其基本用法。
- en: Getting started with Docker
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 Docker
- en: Before we start to use Docker, it might be useful to better understand Docker's
    concept and architecture. First, we will discuss Docker's fundamental changes
    with regards to the SDLC. Following that introduction, we will install Docker
    on our computers and look at some of the most common commands needed to use Docker.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Docker 之前，最好先更好地理解 Docker 的概念和架构。首先，我们将讨论 Docker 在 SDLC 中的基本变化。介绍之后，我们将在计算机上安装
    Docker，并学习一些使用 Docker 时最常用的命令。
- en: Docker fundamentals
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 基础
- en: 'The best way to understand how Docker works is to compare how using Docker
    differs from what we''ve done so far:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Docker 工作原理的最好方法是比较使用 Docker 与我们迄今为止所做的事情有什么不同：
- en: '![](img/c68877c6-26c3-4a77-a641-937b0f365231.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c68877c6-26c3-4a77-a641-937b0f365231.png)'
- en: 'The preceding diagram can be explained as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示可以解释如下：
- en: The first stack on the left represents what we did so far. Using the EC2 service,
    we picked an AMI providing AWS Linux, and, with the help of the user data field,
    we installed Ansible to configure our system. When Ansible kicks in, it installs
    and configures the system, so that later, CodeDeploy can deploy and run our application.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧的第一个堆栈表示我们迄今为止所做的工作。使用 EC2 服务，我们选择了提供 AWS Linux 的 AMI，并借助用户数据字段安装了 Ansible
    来配置我们的系统。当 Ansible 启动时，它会安装并配置系统，以便稍后 CodeDeploy 可以部署并运行我们的应用程序。
- en: The middle stack represents what it means to use Docker on top of EC2\. The
    process starts the same way with an AMI running AWS Linux. However, this time,
    instead of relying on Ansible and CodeDeploy, we will simply install the Docker
    server application. After that, we will deploy Docker containers, which will have
    everything that was previously provided by Ansible and CodeDeploy.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的堆栈表示在 EC2 上使用 Docker 的含义。这个过程的开始方式与使用运行 AWS Linux 的 AMI 相同。然而，这次，我们不再依赖 Ansible
    和 CodeDeploy，而是直接安装 Docker 服务器应用程序。之后，我们将部署 Docker 容器，这些容器将包含之前由 Ansible 和 CodeDeploy
    提供的所有内容。
- en: Finally, the big win of that architecture is what we see on the last stack on
    the right. No matter what the underlying technology is, as long as we can run
    a Docker server, we can run the exact same container. This means that we can easily
    test what we will deploy on EC2\. Similarly, if an issue happens in a container
    running on an EC2 instance, we can pull the exact same container and run it locally
    to possibly troubleshoot the issue.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，这种架构的巨大优势在于我们在右侧最后一个堆栈中看到的内容。无论底层技术是什么，只要我们能运行 Docker 服务器，就能运行完全相同的容器。这意味着我们可以轻松地测试将要部署到
    EC2 上的内容。类似地，如果一个 EC2 实例上的容器出现问题，我们可以拉取完全相同的容器并在本地运行，以便可能排除问题。
- en: 'In order to make that happen, Docker relies on a couple of key concepts, as
    shown in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，Docker 依赖于几个关键概念，如下图所示：
- en: '![](img/87dc7058-dd1d-4f80-a35d-4ac2568dce89.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87dc7058-dd1d-4f80-a35d-4ac2568dce89.png)'
- en: At its core, Docker runs a daemon that loads images (templates describing the
    stack of the application, including the operating system, application code, and
    everything in between) and runs them in self-contained directories called containers.
    When working in Docker, as a developer, your work mostly consists of building
    new images by layering new commands on top of pre-existing images. Images are
    stored in external registries. Those registries can be public or private. Finally,
    all the interaction is done through a RESTful API, usually using the command-line
    interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Docker 运行一个守护进程，该进程加载镜像（描述应用栈的模板，包括操作系统、应用代码以及中间的一切）并在名为容器的自包含目录中运行它们。在
    Docker 中工作时，作为开发人员，你的工作主要是通过在现有镜像上叠加新命令来构建新的镜像。镜像存储在外部注册表中，这些注册表可以是公共的，也可以是私有的。最终，所有的交互都通过
    RESTful API 完成，通常使用命令行界面。
- en: Docker in action
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 实践
- en: 'To see Docker in action, we will start by installing it on our computer. The
    installation of Docker is very straightforward; you can follow the instructions
    found at [http://dockr.ly/2iVx6yG](http://dockr.ly/2iVx6yG) to install and start
    Docker on Mac, Linux, and Windows. Docker provides two offerings: Docker **Community
    Edition** (**CE**) and Docker **Enterprise Edition** (**EE**). Throughout this
    book, we are going to focus on open source tools, as well as using Docker CE,
    which is free of cost. Again, we will be demonstrating the following examples
    on a Linux based Centos 7.x distribution. If you are also following the same operating
    system then follow the instructions available at [https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
    to set up Docker locally on your system. When you are done with the installation
    of Docker CE, verify the installed Docker version using the `docker` utility.
    At the time of writing this book, `18.06` is the latest version of Docker, although
    you might see a newer version on your system now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到 Docker 的实际操作，我们将从在我们的计算机上安装 Docker 开始。Docker 的安装非常简单；你可以按照 [http://dockr.ly/2iVx6yG](http://dockr.ly/2iVx6yG)
    上的说明，安装并启动适用于 Mac、Linux 和 Windows 的 Docker。Docker 提供了两个版本：Docker **社区版** (**CE**)
    和 Docker **企业版** (**EE**)。在本书中，我们将专注于开源工具，并使用免费的 Docker CE 版本。再次声明，我们将演示的示例是在基于
    Linux 的 Centos 7.x 发行版上进行的。如果你也使用相同的操作系统，请按照 [https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
    上的说明，在本地系统上设置 Docker。当 Docker CE 安装完成后，使用 `docker` 工具验证安装的 Docker 版本。在编写本书时，`18.06`
    是 Docker 的最新版本，尽管你现在在系统上可能会看到更新的版本：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once Docker is up and running, we can start using it as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 启动并运行，我们可以如下使用它：
- en: 'The first thing that we will do is pull an image from a registry. By default,
    Docker points to Docker Hub ([https://hub.docker.com](https://hub.docker.com/)),
    which is the official Docker registry from the company Docker Inc. In order to
    pull an image, we will run the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是从注册表中拉取一个镜像。默认情况下，Docker 会指向 Docker Hub ([https://hub.docker.com](https://hub.docker.com/))，这是
    Docker 公司官方的 Docker 注册表。为了拉取一个镜像，我们将运行以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will use the `latest` default tag, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `latest` 默认标签，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a matter of seconds, Docker will download the image called `alpine` from
    the registry, which is a minimal Docker image based on Alpine Linux with a complete
    package index. This is only `4.41 MB` in size:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟之内，Docker 会从注册表下载名为`alpine`的镜像，这是一个基于 Alpine Linux 的最小 Docker 镜像，包含完整的软件包索引。这个镜像的大小只有`4.41
    MB`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When working with Docker, the size of a container matters. Consequently, working
    with smaller base images, such as Alpine Linux, is highly recommended.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Docker 时，容器的大小很重要。因此，推荐使用较小的基础镜像，如 Alpine Linux。
- en: 'We can now run our container. In order to do this, we will start with the following
    simple command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行我们的容器。为了做到这一点，我们将从以下简单命令开始：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the surface, not a lot seems to have happened here, and we were left with
    the same output as we had when running echo `Hello World` without Docker. What
    really happened behind the scenes is a lot more interesting; Docker loaded the
    `alpine` Linux image that we previously pulled, and used the Alpine operating
    system `echo` command to print `Hello World`. Finally, because the `echo` command
    completed, the container was terminated.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表面上看，似乎并没有什么变化，我们得到的输出与没有 Docker 时运行 `echo Hello World` 得到的输出相同。实际上，幕后发生的事情更有趣；Docker
    加载了我们之前拉取的 `alpine` Linux 镜像，并使用 Alpine 操作系统的 `echo` 命令打印出 `Hello World`。最后，由于
    `echo` 命令完成，容器也被终止。
- en: 'Containers can also be used in a more interactive way, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也可以以更交互的方式使用，如下所示：
- en: 'We can, for example, start a shell and interact with it by using the following
    command:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们可以启动一个 shell 并通过以下命令与其互动：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-i` option means interactive; this allows us to type commands in our container
    while the `-t` option allocates a pseudo TTY to see what we are typing as well
    as the output of our commands.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 选项表示交互式；它允许我们在容器中输入命令，而 `-t` 选项分配一个伪 TTY，既能看到我们输入的内容，也能看到命令的输出。'
- en: 'Containers can also be run in the background by using the `-d` option, which
    will detach our container from the Terminal:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器也可以通过使用 `-d` 选项在后台运行，这样可以将我们的容器从终端分离出来：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command returns a 64-bit long ID of the container running the `alpine`
    image and the sleep `1000` command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令返回一个 64 位的容器 ID，表示正在运行 `alpine` 镜像和 `sleep 1000` 命令的容器。
- en: 'We can keep track of the different running containers running by using the
    following command:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下命令跟踪不同的运行容器：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令的输出如下：
- en: '![](img/1bd7bd33-00e4-4266-aae0-fe91c4a52faf.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bd7bd33-00e4-4266-aae0-fe91c4a52faf.png)'
- en: 'Running containers can be stopped using the `stop` option followed by the container
    name or ID (adapt the ID and name based on the output of your `docker ps` command):'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的容器可以通过`stop`选项停止，后面跟上容器的名称或ID（根据`docker ps`命令的输出调整ID和名称）：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also use the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Stopped containers can be started again with the `start` option, as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止的容器可以通过`start`选项重新启动，如下所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, containers can be removed by using the the `rm` command, but always
    stop the container before removing them:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，容器可以通过使用`rm`命令删除，但在删除之前请务必先停止容器：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令的输出如下：
- en: '![](img/110220a2-1d44-4f16-b631-f7ad7c814dfa.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/110220a2-1d44-4f16-b631-f7ad7c814dfa.png)'
- en: 'This brief overview should provide us with the knowledge we need when reading
    this chapter. We will discover a few more commands along the way, but for a complete
    list of options, you can use the `docker help` command or consult the Docker CLI
    documentation at [http://dockr.ly/2jEF8hj](http://dockr.ly/2jEF8hj). Running simple
    commands through containers is sometimes useful but, as we know, the real strength
    of Docker is its ability to handle any code, including our web application. In
    order to make that happen, we will use another key concept of Docker: a Dockerfile.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简要概述应能为我们提供在阅读本章时所需的知识。我们将沿途发现更多命令，但要查看完整的选项列表，你可以使用`docker help`命令，或查阅Docker
    CLI文档，网址为[http://dockr.ly/2jEF8hj](http://dockr.ly/2jEF8hj)。通过容器运行简单命令有时很有用，但正如我们所知，Docker的真正优势在于其能够处理任何代码，包括我们的Web应用程序。为了实现这一点，我们将使用Docker的另一个关键概念：Dockerfile。
- en: Creating our Dockerfile
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Dockerfile
- en: 'Dockerfiles are text files that are usually collocated with applications that
    instruct Docker on how to build a new Docker image. Through the creation of those
    files, you have the ability to tell Docker which Docker image to start from, what
    to copy on the container filesystem, what network port to expose, and so on. You
    can find the full documentation of the Dockerfile at [http://dockr.ly/2jmoZMw](http://dockr.ly/2jmoZMw).
    We are going to create a Dockerfile for our Hello World application, at the root
    of the `helloworld` project that we created in our GitHub repository, using the
    following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是文本文件，通常与应用程序一起存放，指示Docker如何构建新的Docker镜像。通过创建这些文件，你可以告诉Docker从哪个Docker镜像开始、要复制到容器文件系统中的内容、要公开的网络端口等等。你可以在[http://dockr.ly/2jmoZMw](http://dockr.ly/2jmoZMw)找到Dockerfile的完整文档。我们将为我们的Hello
    World应用程序创建一个Dockerfile，位于我们在GitHub仓库中创建的`helloworld`项目的根目录，使用以下命令：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first instruction of a Dockerfile is always a `FROM` instruction. This
    tells Docker which Docker image to start from. We could use the Alpine image,
    as we did, but we can also save some time by using an image that has more than
    just an operating system. Through Docker Hub, the official Docker registry, Docker
    provides a number of curated sets of Docker repositories called **official**.
    We know that in order to run our application, we need Node.js and `npm`. We can
    use the Docker CLI to look for an official `node` image. To do that, we will use
    the `docker search` command and filter only on official images:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的第一条指令始终是`FROM`指令。这告诉Docker从哪个Docker镜像开始。我们可以使用Alpine镜像，正如我们所做的那样，但我们也可以通过使用一个不仅仅是操作系统的镜像来节省一些时间。通过Docker
    Hub，Docker的官方注册表，Docker提供了许多经过精心策划的Docker仓库集，这些仓库被称为**官方**。我们知道，为了运行我们的应用程序，我们需要Node.js和`npm`。我们可以使用Docker
    CLI查找官方的`node`镜像。为此，我们将使用`docker search`命令，并仅筛选官方镜像：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, we can also search for this using our browser. As a result,
    we would end up with that same image, [https://hub.docker.com/_/node/](https://hub.docker.com/_/node/).
    As we can see, the following screenshot comes in a variety of versions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用浏览器进行搜索。结果，我们将看到相同的镜像，[https://hub.docker.com/_/node/](https://hub.docker.com/_/node/)。正如我们所见，以下截图有多个版本：
- en: '![](img/ea4202d1-ce5c-474e-a493-1bc16c06733a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea4202d1-ce5c-474e-a493-1bc16c06733a.png)'
- en: 'Docker images are always made up of a name and a tag, using the syntax `name:tag`.
    If the tag is omitted, Docker will default to `latest`. From the preceding `docker
    pull` command, we can see how the output says `Using default tag: latest`. When
    creating a Dockerfile, it is best practice to use an explicit tag that doesn''t
    change over time (unlike the `latest` tag).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker镜像总是由名称和标签组成，使用语法`name:tag`。如果省略标签，Docker将默认使用`latest`标签。从前面的`docker
    pull`命令中，我们可以看到输出显示`Using default tag: latest`。在创建Dockerfile时，最佳实践是使用一个不会随着时间改变的显式标签（不同于`latest`标签）。'
- en: If you are trying to migrate an application currently running on AWS Linux and
    make a certain number of assumptions based on that OS, you may want to look into
    using the official AWS Docker image. You can read more about this at [http://amzn.to/2jnmklF](http://amzn.to/2jnmklF).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试迁移一个当前运行在AWS Linux上的应用程序，并基于该操作系统做出一些假设，你可能想要使用官方的AWS Docker镜像。你可以在[http://amzn.to/2jnmklF](http://amzn.to/2jnmklF)上了解更多信息。
- en: 'On the first line of our file, we will add the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的第一行，我们将添加如下内容：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will tell Docker that we want to use that specific version of the `node`
    image. This means that we won''t have to install `node` or `npm`. Since we have
    the OS and runtime binaries needed by our application, we can start looking into
    adding our application to this image. First, we will want to create a directory
    on top of the `node:carbon` image''s filesystem, to hold our code. We can do that
    using the `RUN` instruction, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Docker我们想要使用特定版本的`node`镜像。这意味着我们不需要安装`node`或`npm`。因为我们已经有了应用程序所需的操作系统和运行时二进制文件，所以我们可以开始考虑将我们的应用程序添加到这个镜像中。首先，我们需要在`node:carbon`镜像的文件系统上创建一个目录，用来存放我们的代码。我们可以使用`RUN`指令来完成，具体如下：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now want to copy our application files onto the image. We will use the `COPY`
    directive to do that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要将应用程序文件复制到镜像中。我们将使用`COPY`指令来实现：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure that you copy the `helloworld.js` and `package.json` files inside
    the `/helloworld` project directory where you are locally developing Dockerfile.
    The files are placed at [https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)
    and [https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你将`helloworld.js`和`package.json`文件复制到你本地开发Dockerfile的`/helloworld`项目目录中。这些文件位于[https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)和[https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json)。
- en: 'We will now use the `WORKDIR` instruction to set our new working directory
    to be that `helloworld` directory:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`WORKDIR`指令将我们的新工作目录设置为`helloworld`目录：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now run the `npm install` command to download and install our dependencies.
    Because we won''t use that container to test our code, we can just install the
    `npm` packages needed for production, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`npm install`命令来下载并安装我们的依赖项。因为我们不会使用这个容器来测试我们的代码，我们可以只安装生产环境所需的`npm`包，如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our application uses port `3000`. We need to make this port accessible to our
    host. In order to do that, we will use the `EXPOSE` instruction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用`3000`端口。我们需要让这个端口对主机可访问。为此，我们将使用`EXPOSE`指令：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can start our application. For that, we will use the `ENTRYPOINT`
    instruction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启动我们的应用程序。为此，我们将使用`ENTRYPOINT`指令：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now save the file. It should look like the template at [https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile).
    We can now build our new image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保存文件。它应该看起来像[https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile)模板那样。我们现在可以构建我们的新镜像。
- en: 'Back in the Terminal, we will again use the `docker` command, but this time
    with the `build` argument. We will also use the `-t` option to provide the name
    `helloworld` to our image, followed by a (`.`) dot that indicates the location
    of our Dockerfile:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回到终端，我们将再次使用`docker`命令，但这次使用`build`参数。我们还将使用`-t`选项为我们的镜像提供名称`helloworld`，并在后面加上一个（`.`）点，表示Dockerfile的位置：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, each command produces a new intermediary container with the
    changes triggered by that step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个命令都会生成一个新的中间容器，并带有该步骤所触发的更改。
- en: 'We can now run our newly created image to create a container with the following
    command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们新创建的镜像，以以下命令创建一个容器：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are adding the`-p` option to our command to map the exposed port of
    our container to a port on our host. There are a few ways to validate that our
    container is working correctly. We can start by looking at the logs produced by
    our container (replace the container ID with the output of the previous command):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在命令中添加了`-p`选项，将容器的暴露端口映射到主机的端口。有几种方法可以验证我们的容器是否正常工作。我们可以首先查看容器生成的日志（将容器ID替换为之前命令的输出）：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also use the `docker ps` command to see the status of our container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`docker ps`命令查看我们容器的状态：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/e2440413-c06d-48aa-a81d-6b7da5fd9448.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2440413-c06d-48aa-a81d-6b7da5fd9448.png)'
- en: 'And, of course, we can simply test the application with the `curl` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以简单地使用`curl`命令来测试应用：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, if your host has a public IP then you can even verify the outputs on
    the browser with `<ip:exposedport>`, which in my case is `54.205.200.149:3000`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你的主机有公共IP，你甚至可以通过浏览器使用`<ip:exposedport>`来验证输出，在我的例子中是`54.205.200.149:3000`：
- en: '![](img/b3adc093-30ac-418d-ba0a-0e7e057a5f76.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3adc093-30ac-418d-ba0a-0e7e057a5f76.png)'
- en: 'Finally, kill the container using the `docker kill` command and container ID:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`docker kill`命令和容器ID来停止容器：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since our image is working correctly, we can commit the code to GitHub:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的镜像运行正常，我们可以将代码提交到GitHub：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, you can now create an account (for free) on Docker Hub and upload
    that new image. If you want to give it a try, you can follow the instructions
    at [http://dockr.ly/2ki6DQV](http://dockr.ly/2ki6DQV).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你现在可以在Docker Hub上创建一个帐户（免费）并上传这个新镜像。如果你想尝试，你可以按照[http://dockr.ly/2ki6DQV](http://dockr.ly/2ki6DQV)上的说明进行操作。
- en: 'Having the ability to easily share containers makes a big difference when collaborating
    on projects. Instead of sharing code and asking people to compile or build packages,
    you can actually share a Docker image. For instance, this can be done by running
    the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松分享容器，在协作项目中带来很大的不同。你无需分享代码并要求别人编译或构建包，而是可以直接分享Docker镜像。例如，可以通过运行以下命令来实现：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令的输出如下：
- en: '![](img/8bdb0d8a-8b89-48e9-8e3c-e0ae88bb3309.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bdb0d8a-8b89-48e9-8e3c-e0ae88bb3309.png)'
- en: You can experience the Hello World application, the exact way I see it, no matter
    what your underlying architecture is. This new way of running applications makes
    Docker a very strong solution for sharing work or collaborating on projects. Docker's
    strengths do not end with work collaboration, however. As we are about to see,
    using containers in production is also a very interesting option. In order to
    easily implement such solutions, AWS created the EC2 container service. We are
    going to use it to deploy our newly created `helloworld` image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以体验Hello World应用，正如我所看到的一样，无论你的底层架构是什么。通过这种新的应用运行方式，Docker成为了一个非常强大的工作分享或项目协作解决方案。然而，Docker的优势不仅限于工作协作。正如我们即将看到的，使用容器进行生产部署也是一个非常有趣的选择。为了便于实现这些解决方案，AWS创建了EC2容器服务。我们将使用它来部署我们新创建的`helloworld`镜像。
- en: Using the EC2 container service
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EC2容器服务
- en: 'We just went over creating a Docker image for our application. Here, we saw
    how easy and fast it is to start a container using Docker. This is a very transformative
    experience compared to using only virtual machine technologies such as EC2\. One
    possibility that we haven''t explicitly mentioned so far is that you can start
    multiple containers with the same image. We can, for example, start our `helloworld`
    container five times, binding five different ports using the following command
    (adapt the ID based on the image ID you built. If needed, run Docker images to
    find its ID):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讲解了如何为我们的应用创建一个Docker镜像。在这里，我们看到使用Docker启动容器是多么简单和快速。这与仅使用虚拟机技术（如EC2）相比，带来了非常有变革性的体验。我们至今没有明确提到的一种可能性是，你可以使用相同的镜像启动多个容器。例如，我们可以启动五次`helloworld`容器，并使用以下命令绑定五个不同的端口（根据你构建的镜像ID调整ID。如果需要，可以运行Docker
    images来查找镜像ID）：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can validate that everything is working using the `ps` and `curl` commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ps`和`curl`命令验证一切是否正常：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令的输出如下：
- en: '![](img/6bc2a770-1f61-41fa-b8aa-be32f8b55a01.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bc2a770-1f61-41fa-b8aa-be32f8b55a01.png)'
- en: 'Cleaning up containers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清理容器：
- en: 'We can clean up everything by stopping and removing all containers with these
    two handy one-line commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过停止并删除所有容器来清理一切，使用以下两个便捷的一行命令：
- en: '**`$ docker stop $(docker ps -a -q)`**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`$ docker stop $(docker ps -a -q)`**'
- en: '**`$ docker system prune`**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`$ docker system prune`**'
- en: 'The output of running the preceding commands is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面命令的输出结果如下：
- en: '![](img/f26a7e76-daad-43cd-bac0-4b92cec1cb45.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f26a7e76-daad-43cd-bac0-4b92cec1cb45.png)'
- en: This ability to start multiple containers on a single host with almost no overhead
    or latency makes Docker an ideal candidate for production. In addition, more and
    more companies are deciding to take the service-oriented architecture approach
    to an all-new level by breaking out each business function into a separate service.
    This is often called a **microservices** approach. Docker is a natural fit for
    microservices and for managing microservice architecture. This is because it provides
    a platform that is language agnostic (you can start any type of application written
    in any language inside your container), able to scale horizontally and vertically
    with ease, and a common story around deployment as we deploy containers instead
    of a variety of services. We will implement our container architecture using the
    **Infrastructure as Code** (**IaC**) best practices and use CloudFormation through
    the intermediary of Troposphere. The first service we are going to look at is
    AWS's ECR.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种几乎没有开销或延迟的单主机多容器启动能力，使 Docker 成为生产环境中的理想选择。此外，越来越多的公司决定通过将每个业务功能拆分为独立服务，将面向服务的架构方法提升到一个全新的水平。这通常被称为
    **微服务** 方法。Docker 非常适合微服务及其管理。这是因为它提供了一个与语言无关的平台（您可以在容器中启动任何语言编写的应用程序），能够轻松地进行横向和纵向扩展，并且围绕部署有一个共同的故事——我们部署的是容器，而不是多种服务。我们将使用
    **基础设施即代码**（**IaC**）最佳实践来实现我们的容器架构，并通过 Troposphere 中介使用 CloudFormation。我们将要查看的第一个服务是
    AWS 的 ECR。
- en: Creating an ECR repository to manage our Docker image
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ECR 仓库来管理我们的 Docker 镜像
- en: In the first part of this chapter, we used the Docker Hub public registry. AWS
    provides a similar service to this called ECR. This allows you to keep your images
    in a private registry called a **repository**. ECR is fully compatible with the
    Docker CLI but also integrates deeply with the remaining ECS services. We are
    going to use this to store our `helloworld` images.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们使用了 Docker Hub 公共注册表。AWS 提供了一个类似的服务，叫做 ECR。这使您能够将镜像保存在一个名为 **repository**
    的私有注册表中。ECR 完全兼容 Docker CLI，并且与其他 ECS 服务深度集成。我们将使用它来存储我们的 `helloworld` 镜像。
- en: As mentioned, we will rely heavily on CloudFormation to make our changes. Unlike
    what we saw previously, because of its nature, the ECS infrastructure we are going
    to build needs to be very modular. This is because, in practice, we will want
    to share some of those components with other services. Consequently, we will create
    a number of templates and link them to one another. One good way to do that is
    to rely on CloudFormation's export ability, which allows us to do cross-stack
    referencing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将主要依赖 CloudFormation 来进行我们的更改。与之前看到的不同，由于其性质，我们将要构建的 ECS 基础设施需要非常模块化。这是因为在实际操作中，我们希望将其中一些组件与其他服务共享。因此，我们将创建多个模板，并将它们相互链接。实现这一点的一个好方法是依赖
    CloudFormation 的导出功能，这使我们能够进行跨堆栈引用。
- en: One of the added bonuses that export provides is a fail-safe mechanism. You
    can't delete or edit a stack if another stack references an exported output.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的一个附加优势是其故障保护机制。如果另一个堆栈引用了导出的输出，您就无法删除或编辑该堆栈。
- en: To generate our template, we will create a new Troposphere script. To do this,
    go to the `EffectiveDevOpsTemplates` repository and create a new script named
    `ecr-repository-cf- template.py`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们的模板，我们将创建一个新的 Troposphere 脚本。为此，进入 `EffectiveDevOpsTemplates` 仓库，并创建一个名为
    `ecr-repository-cf-template.py` 的新脚本。
- en: 'We will start by importing a number of modules, including the `Export` mentioned
    earlier and the `ecr` module, in order to create our repository. We will also
    create our template variable, `t`, as we did in previous chapters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入多个模块，包括前面提到的 `Export` 模块和 `ecr` 模块，以便创建我们的仓库。我们还将像前几章一样创建我们的模板变量 `t`：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we are going to create a number of CloudFormation templates in this chapter,
    we will add a description so that it''s easier to understand which template does
    what when looking at them in the AWS console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章中创建多个 CloudFormation 模板，因此我们将添加描述，以便在 AWS 控制台中查看这些模板时更容易理解每个模板的功能：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will create a parameter for the name of the repository so that we will be
    able to reuse that CloudFormation template for every repository we create:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为仓库名称创建一个参数，这样我们就能将此 CloudFormation 模板用于每个我们创建的仓库：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now create our repository as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按如下方式创建我们的仓库：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are keeping the code very simple here and not enforcing any particular permissions.
    If you need to restrict who can access your repository and see more complex configurations,
    you can refer to the AWS documentation and, in particular, [http://amzn.to/2j7hA2P](http://amzn.to/2j7hA2P). Lastly,
    we will output the name of the repository we created and export its value through
    a template variable `t`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的代码保持简单，并没有强制执行任何特定的权限。如果你需要限制谁可以访问你的仓库并查看更复杂的配置，可以参考 AWS 文档，特别是 [http://amzn.to/2j7hA2P](http://amzn.to/2j7hA2P)。最后，我们将输出我们创建的仓库名称，并通过模板变量
    `t` 导出其值：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can save our script now. It should look like this: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py).
    We will now generate the CloudFormation template and create our stack as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存我们的脚本。它应该像这样：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py)。接下来，我们将生成
    CloudFormation 模板并按如下方式创建我们的堆栈：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After a few minutes, our stack will be created. We can validate that the repository
    was correctly created as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们的堆栈将会创建完成。我们可以验证仓库是否正确创建，方法如下：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can see our exported output with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令查看导出的输出：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our repository can now be used to store our `helloworld` image. We will use
    the Docker CLI to do that. The first step of that process is to log in to the
    `ecr` service. You can do this with the following handy one-line command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的仓库可以用来存储我们的 `helloworld` 镜像。我们将使用 Docker CLI 来完成这一步。该过程的第一步是登录到 `ecr`
    服务。你可以通过以下简洁的一行命令来完成：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of running the preceding command can be shown as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述命令的输出结果如下所示：
- en: '![](img/805706d0-cfab-4e33-a0ae-de6edbd3a93c.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/805706d0-cfab-4e33-a0ae-de6edbd3a93c.png)'
- en: 'Back in our `helloworld` directory where the Dockerfile is, we will tag our
    image as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 `helloworld` 目录下，也就是 Dockerfile 所在的目录，我们将按如下方式标记我们的镜像：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is a common practice to use the `latest` tag to designate the most recent
    version of an image. In addition, you need to adapt the following command based
    on the output of the `aws ecr describe-repositories` output (we assume here that
    you have already built your image):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `latest` 标签来指定镜像的最新版本是一种常见的做法。此外，您需要根据 `aws ecr describe-repositories` 输出的内容调整以下命令（在这里我们假设你已经构建了镜像）：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now push that image to our registry as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式将镜像推送到我们的注册表：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see how each layer of our image is pushed in parallel to our registry.
    Once the operation completes, we can validate that the new image is present in
    our registry as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每一层镜像是如何并行推送到我们的注册表中的。一旦操作完成，我们可以验证新的镜像是否已经出现在注册表中，方法如下：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At this point, our image is now available to the rest of our infrastructure.
    We are going to move on to the next step of our process, which is the creation
    of the ECS cluster.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的镜像已经可以供其他基础设施使用。接下来，我们将进入流程的下一步，即创建 ECS 集群。
- en: Creating an ECS cluster
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ECS 集群
- en: Creating an ECS cluster is a very similar process to the one in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, when we created an Auto Scaling Group to run our
    Hello World application. The main difference is that there is one more level of
    abstraction. ECS will run a number of services called **task**s.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ECS 集群的过程与我们在 [第 6 章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml) *扩展基础设施*
    中创建自动扩展组以运行 Hello World 应用程序时非常相似。主要的区别是，多了一个抽象层。ECS 将运行多个被称为 **任务**（task）的服务。
- en: 'Each of those tasks may exist multiple times in order to handle the traffic:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务可能会多次存在，以便处理流量：
- en: '![](img/328a29f3-4714-484d-b04b-b22d0d86e9a3.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/328a29f3-4714-484d-b04b-b22d0d86e9a3.png)'
- en: In order to do that, the ECS service provides an orchestration layer. That orchestration
    layer is in charge of managing the life cycle of containers, including upgrading
    or downgrading and scaling your containers up or down. The orchestration layer
    also distributes all containers for every service across all instances of the
    cluster optimally. Finally, it also exposes a discovery mechanism that interacts
    with other services such as ALB and ELB to register and deregister containers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，ECS 服务提供了一个编排层。该编排层负责管理容器的生命周期，包括升级或降级、以及水平扩展或缩减容器。编排层还会在集群的所有实例上，优化地分配每个服务的所有容器。最后，它还提供了一种发现机制，与其他服务如
    ALB 和 ELB 进行交互，用于注册和注销容器。
- en: 'Task placement strategies:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 任务放置策略：
- en: By default, the entire orchestration system is managed by AWS. However, you
    also have the ability to customize it through the creation of a task placement
    strategy. This will let you configure the orchestration to optimize for instance
    count, for load distribution, to add constraints, and make sure that certain tasks
    are launched on the same instances.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，整个编排系统由 AWS 管理。然而，您也可以通过创建任务放置策略来对其进行自定义。这将允许您配置编排，以优化实例数量、负载分配、添加约束，并确保某些任务在相同的实例上启动。
- en: 'We will create a new script to generate our ECS cluster. The filename will
    be `ecs-cluster-cf-template.py`. This template starts almost exactly like the
    template we created in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, for the Auto Scaling Group:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的脚本来生成我们的 ECS 集群。文件名将是 `ecs-cluster-cf-template.py`。这个模板几乎与我们在[第 6 章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)中为自动扩展组创建的模板完全相同，*扩展您的基础设施*：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The only new import is the cluster one from the ECS module. Just like we did
    in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your Infrastructure*,
    we will extract our IP address in order to use it later for the SSH security group,
    create our template variable, and add a description to the stack:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要导入的是来自 ECS 模块的集群模块。就像我们在[第 6 章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)中所做的那样，*扩展您的基础设施*，我们将提取我们的
    IP 地址，以便稍后用于 SSH 安全组，创建我们的模板变量，并为堆栈添加描述：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will now proceed with adding our parameters, which are the the same parameters
    as used in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your
    Infrastructure*. This includes the SSH key-pair, the VPC ID, and its subnets:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续添加我们的参数，这些参数与在[第 6 章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)中使用的参数相同，*扩展您的基础设施*。这包括
    SSH 密钥对、VPC ID 及其子网：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will look at creating our security group resources:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的安全组资源：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There is one important difference here. In [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, we opened up port `3000` since that's what our
    application is using. Here, we are opening every port to the CIDR 1 `72.16.0.0/12`,
    which is the private IP space of our internal network. This will give our ECS
    cluster the ability to run multiple `helloworld` containers on the same hosts,
    binding different ports.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的区别。在[第 6 章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)中，*扩展您的基础设施*，我们打开了端口
    `3000`，因为那是我们的应用程序使用的端口。这里，我们将所有端口都开放到 CIDR 1 `72.16.0.0/12`，这是我们内部网络的私有 IP 地址空间。这将使我们的
    ECS 集群能够在相同的主机上运行多个 `helloworld` 容器，绑定不同的端口。
- en: 'We will now create our cluster resource. This can simply be done with the following
    command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建我们的集群资源。只需使用以下命令即可完成：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we will focus on configuring instances of the cluster, starting with
    their IAM role. Overall, this is one of the more complex resources to create in
    ECS as the cluster will need to perform a number of interactions with other AWS
    services. We can create a complete custom policy for it or import the policies
    AWS created as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于配置集群的实例，从它们的 IAM 角色开始。总体来说，这是 ECS 中创建的更复杂的资源之一，因为集群需要与其他 AWS 服务进行多次交互。我们可以为其创建一个完整的自定义策略，或者导入
    AWS 创建的策略，如下所示：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now tie our role with the instance profile as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将角色与实例配置文件关联起来，如下所示：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The next step is to create our launch configuration. The following code snippet
    shows what it looks like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的启动配置。以下代码片段展示了它的样子：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example, we don't install Ansible like we did before. Instead, we are
    using an ECS- optimized AMI (you can read more about this at [http://amzn.to/2jX0xVu](http://amzn.to/2jX0xVu))
    that lets us use the `UserData` field to configure the ECS service, and then starting
    it. Now that we have our launch configuration, we can create our Auto Scaling
    Group resources.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们不像之前那样安装Ansible。相反，我们使用一个经过ECS优化的AMI（您可以在[http://amzn.to/2jX0xVu](http://amzn.to/2jX0xVu)上查看更多信息），它允许我们使用`UserData`字段来配置ECS服务，并启动它。现在我们有了启动配置，可以创建Auto
    Scaling Group资源。
- en: 'When working with ECS, scaling is needed at two levels:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ECS时，需要在两个层级进行扩展：
- en: The containers level, as we will need to run more containers of a given service
    if the traffic spikes
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器级别，因为如果流量激增，我们需要运行更多的容器来处理指定的服务
- en: The underlying infrastructure level
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层基础设施级别
- en: 'Containers, through the intermediary of their task definitions, set a requirement
    for CPU and memory. They will require, for example, 1024 CPU units, which represents
    one core, and 256 memory units, which means 256 MB of RAM. If the ECS instances
    are close to being filled up on one of those two constraints, the ECS Auto Scaling
    Group needs to add more instances:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过任务定义，容器设置了对CPU和内存的需求。例如，它们可能需要1024 CPU单元，表示一个核心，以及256内存单元，表示256 MB的RAM。如果ECS实例的某一约束接近满载，ECS
    Auto Scaling Group需要增加更多实例：
- en: '![](img/7a4a4d06-7d7b-46d5-88f7-dfe4d3e19d6e.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a4a4d06-7d7b-46d5-88f7-dfe4d3e19d6e.png)'
- en: 'In terms of implementation, the process is very similar to what we did in [Chapter
    6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your Infrastructure*.
    Here, we first create the Auto Scaling Group resource, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，该过程与我们在[第6章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)中做的*扩展基础设施*非常相似。在这里，我们首先创建Auto
    Scaling Group资源，如下所示：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we will create scaling policies and alarms to monitor the CPU and memory
    reservation metrics. In order to accomplish that, we will take advantage of Python
    to generate our stack and create for loops as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建扩展策略和告警，以监控CPU和内存预留指标。为了实现这一点，我们将利用Python生成我们的堆栈，并创建如下的循环：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we will provide a small amount of resource information, namely the
    stack ID, the VPC ID, and the public subnets:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将提供一些资源信息，特别是堆栈ID、VPC ID和公共子网：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: CloudFormation provides a number of pseudo-parameters, such as `AWS::StackName`.
    Throughout the chapter, we will rely on it to make our template generic enough
    to be used across different environments and services. In the preceding code,
    we created an ECR repository for our `helloworld` container. The name was generated
    by the stack creation command. If required, we can reuse that exact same template
    to create another repository for another container.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation提供了许多伪参数，如`AWS::StackName`。在本章中，我们将依赖它来使我们的模板足够通用，以便在不同环境和服务中使用。在前面的代码中，我们为我们的`helloworld`容器创建了一个ECR仓库。该名称是通过堆栈创建命令生成的。如果需要，我们可以重用相同的模板为另一个容器创建另一个仓库。
- en: 'The script is now complete, and should look like the script at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在已经完成，应该与以下脚本相似：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py)。
- en: 'As before, we can now commit our script and create our stack by first generating
    our template, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在可以提交脚本并通过首先生成模板来创建我们的堆栈，如下所示：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To create our stack, we need three parameters; the key-pair, the VPC ID, and
    the subnets. In the previous chapters, we used the web interface to create those
    stacks. Here, we will look at how to get that information using the CLI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建堆栈，我们需要三个参数：密钥对、VPC ID和子网。在前几章中，我们使用Web界面来创建这些堆栈。这里，我们将介绍如何使用CLI获取这些信息。
- en: 'To get the VPC ID and the subnet IDs, we can use the following commands:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取VPC ID和子网ID，我们可以使用以下命令：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can now create our stack by combining the preceding outputs. Since ECS clusters
    can run a variety of containers and a number of applications and services, we
    will aim for one ECS cluster per environment, starting with staging. In order
    to differentiate each environment, we will rely on the stack names. Consequently,
    it is important to call your `staging-cluster` stack, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过结合前面的输出创建我们的栈。由于 ECS 集群可以运行各种容器和多个应用程序及服务，我们将为每个环境创建一个 ECS 集群，从 staging
    开始。为了区分每个环境，我们将依赖栈的名称。因此，重要的是将你的栈命名为 `staging-cluster`，如这里所示：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will now add a load balancer. In the previous chapter, we used an ELB for
    our Auto Scaling Group. Later, we also mentioned the existence of the ALB service.
    This time, we will create an ALB instance to proxy our application traffic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加一个负载均衡器。在上一章中，我们为我们的自动扩展组使用了 ELB。之后，我们也提到了 ALB 服务的存在。这次，我们将创建一个 ALB 实例来代理我们的应用流量。
- en: Creating an ALB
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ALB
- en: As mentioned previously, ECS provides an orchestrator that takes care of allocating
    the containers across our Auto Scaling Group. It also keeps track of which port
    each container uses and integrates with ALB so that our load balancer can correctly
    route the incoming traffic to all containers running a given service. ECS supports
    both the ELB and ALB services but the ALB gives more flexibility when working
    with containers. We will demonstrate how to create an ALB using CloudFormation
    through Troposphere.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ECS 提供了一个协调器，用于管理容器在自动扩展组中的分配。它还跟踪每个容器使用的端口，并与 ALB 集成，以便我们的负载均衡器能够正确地将流量路由到运行给定服务的所有容器。ECS
    支持 ELB 和 ALB 服务，但 ALB 在与容器协作时提供了更多的灵活性。我们将演示如何通过 Troposphere 使用 CloudFormation
    创建 ALB。
- en: 'We will start by creating a new file and calling it `helloworld-ecs-alb-cf-template.py`.
    We will then put our usual import, and will create our template variable and add
    a description, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新文件，并将其命名为 `helloworld-ecs-alb-cf-template.py`。然后我们将像往常一样添加导入，并创建我们的模板变量，并添加描述，如下所示：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are now going to create our security group. No surprises here; we are opening
    `TCP/3000` to the world, as we did in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, with the ELB:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要创建安全组。这里没有惊喜；我们将 `TCP/3000` 开放给全世界，就像在[第 6 章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)《*扩展你的基础设施*》中，使用
    ELB 时所做的那样：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The main difference from what we did previously is that instead of starting
    with a parameter section and requesting, yet again, to provide the VPC ID and
    public subnets, we are taking advantage of the value that we exported before.
    When we launch this stack, we will call it `staging-alb`. The block of code inside
    the `ImportValue` parameter does the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前所做的主要不同之处在于，我们不再从一个参数部分开始并再次要求提供 VPC ID 和公有子网，而是利用我们之前导出的值。当我们启动这个栈时，我们将其命名为
    `staging-alb`。`ImportValue` 参数中的代码块执行如下操作：
- en: First, we get the name of our stack. We will launch that stack under the name
    `staging-alb`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们获取栈的名称。我们将使用 `staging-alb` 作为该栈的名称。
- en: The `Split` function breaks the stack name on the character `-`, meaning that
    we end up with [`staging`, `alb`].
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Split` 函数将栈名称按字符 `-` 拆分，意味着我们最终得到 [`staging`, `alb`]。'
- en: 'The `Select` function takes the first element of the list: staging.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Select` 函数获取列表中的第一个元素：staging。'
- en: 'The `Join` function concatenates that element with the string `cluster-vpc-id`.
    In the end, we get `Import("staging-cluster-vpc-id")`, which is the name of the
    key we defined to export the VPC ID when we created our ECS cluster:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Join` 函数将该元素与字符串 `cluster-vpc-id` 连接起来。最后，我们得到 `Import("staging-cluster-vpc-id")`，这是我们在创建
    ECS 集群时定义并导出 VPC ID 的键的名称：'
- en: '![](img/c1f4d0bf-28f4-4c35-8f74-9a0faf3f1924.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1f4d0bf-28f4-4c35-8f74-9a0faf3f1924.png)'
- en: 'We will now create our ALB. ALB, being more flexible and feature-rich than
    ELB, requires a bit more effort when it comes to configuration. ALB works through
    the intermediary of three different resources. The first one is the ALB resource,
    which handles incoming connections. On the opposite side, we can find the target
    groups, which are the resources used by the ECS clusters registered to those ALBs.
    Finally, in order to tie the two, we find the listener''s resources. We will first
    define our load balancer resource, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的ALB。ALB比ELB更灵活、功能更强大，因此在配置时需要更多的工作。ALB通过三种不同的资源中介工作。第一个是ALB资源，处理传入的连接。在另一端，我们可以找到目标组，这些是ECS集群用于注册到这些ALB的资源。最后，为了将两者连接起来，我们需要监听器资源。我们将首先定义我们的负载均衡器资源，如下所示：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We use a very similar series of calls to the function to import our subnet as
    we did just before for the VPC ID.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与之前为VPC ID导入子网时非常相似的调用来导入我们的子网。
- en: 'We will now create our target group and configure our health check, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的目标组并配置健康检查，如下所示：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we will add the listener to connect our target group to our load balancer:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加监听器，将目标组连接到负载均衡器：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, we will want to create two outputs. The first output is the target
    group. We will export its value so that our application can register to the group.
    The second output is the DNS record of the ALB. This will be the entry point to
    our application:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望创建两个输出。第一个输出是目标组。我们将导出其值，以便我们的应用程序可以注册到该组。第二个输出是ALB的DNS记录。这将成为我们应用程序的入口点：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The file is now ready, and should look like the file at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py).
    We can now generate our template and create our stack, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 文件现在已经准备好，应该看起来像这个文件：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py)。我们现在可以生成我们的模板并创建堆栈，如下所示：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As mentioned, it is important to call the stack `staging-alb`, and that first
    word is used to import the VPC ID and subnets. The last stack we need is the creation
    of our container service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，重要的是将堆栈命名为`staging-alb`，并且第一个词用来导入VPC ID和子网。我们需要的最后一个堆栈是创建我们的容器服务。
- en: Creating our ECS hello world service
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的ECS Hello World服务
- en: 'We have an ECS cluster and a load balancer ready to take on traffic on one
    side and an ECR repository containing the image of our application on the other
    side. We now need to tie the two together. This is done by creating an ECS service
    resource. We will create a new file called `helloworld-ecs-service-cf-template.py`
    and start as usual with its imports, template variable creation, and template
    description:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个ECS集群和一个负载均衡器，准备好在一侧处理流量，另一侧则有一个ECR仓库，包含我们应用程序的镜像。现在，我们需要将这两者连接起来。这是通过创建一个ECS服务资源来完成的。我们将创建一个名为`helloworld-ecs-service-cf-template.py`的新文件，并像往常一样从导入、模板变量创建和模板描述开始：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Our template will take one argument, which is the tag of the image we want
    to deploy. Our repository currently only has one image tagged as the latest, but
    in the next section we will update our deployment pipeline and automatize the
    deployment of our service to ECS:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板将需要一个参数，即我们想要部署的镜像标签。我们的仓库目前只有一个标记为latest的镜像，但在接下来的章节中，我们将更新我们的部署管道，并自动化将我们的服务部署到ECS：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In ECS, applications are defined by their task definitions. This is where we
    declare which repository to use to get our image, how much CPU and memory the
    application needs, and all other system properties such as port mapping, environment
    variables, mount points, and so on. We will keep our task definition minimal;
    in order to select the proper image, we will utilize the `ImportValue` function
    (we previously exported the repository name) combined with a `Join` function to
    craft the repository URL. We will require 32 MB of RAM and one-quarter of a core
    to run our application. Finally, we will specify that port `3000` needs to be
    mapped onto the system:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECS中，应用程序由其任务定义来定义。这里是我们声明使用哪个仓库来获取我们的镜像、应用程序需要多少CPU和内存，以及所有其他系统属性（如端口映射、环境变量、挂载点等）的位置。我们将保持任务定义的最小化；为了选择合适的镜像，我们将利用`ImportValue`函数（我们之前导出了仓库名称）并结合`Join`函数来构建仓库URL。我们将需要32
    MB的RAM和四分之一的CPU核心来运行我们的应用程序。最后，我们将指定端口`3000`需要映射到系统上：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As for most of the AWS managed services, the ECS service needs a certain set
    of permissions provided by the intermediary of a role. We will create that role
    and use the vanilla policy for the ECS service role, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数AWS托管服务，ECS服务需要通过角色中介提供的特定权限。我们将创建该角色，并使用默认策略来配置ECS服务角色，步骤如下：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will complete the creation of our template with the addition of the ECS
    service resource, which ties the task definition, the ECS cluster, and the ALB
    together:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加ECS服务资源来完成模板的创建，这将任务定义、ECS集群和ALB连接在一起：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, as always, we will output the template generated by our code using
    the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像往常一样，我们将使用以下命令输出由我们的代码生成的模板：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The script is now ready and should look like the script at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在已准备就绪，并应如下所示： [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py)。
- en: 'We will now generate the template and create our stack, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将生成模板并创建堆栈，步骤如下：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After a few minutes, the stack should be created. We can circle back to the
    output of the ALB stack to get the URL of our newly deployed application and test
    its output, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，堆栈应该已创建。我们可以回到ALB堆栈的输出，获取我们新部署应用程序的URL并测试其输出，步骤如下：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This can also be confirmed from the browser, as shown in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过浏览器进行确认，如以下截图所示：
- en: '![](img/3386d1b4-0477-4392-a767-430badf63775.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3386d1b4-0477-4392-a767-430badf63775.png)'
- en: 'We have completed the creation of our staging ECS environment. At this point,
    we can easily manually deploy new code to our staging, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的临时ECS环境的创建。此时，我们可以轻松地手动将新代码部署到我们的暂存环境，步骤如下：
- en: 'Make the changes in the `helloworld` code, locally. For example, change `Hello
    World` to `Hello From Yogesh Raheja`, as shown in the following screenshot:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地修改`helloworld`代码。例如，将`Hello World`更改为`Hello From Yogesh Raheja`，如以下截图所示：
- en: '![](img/32772faa-db7f-42ee-ad93-f0b38472839f.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32772faa-db7f-42ee-ad93-f0b38472839f.png)'
- en: 'Log in to the `ecr` registry, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到`ecr`注册表，步骤如下：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Build your Docker container, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建你的Docker容器，步骤如下：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Pick a new unique tag, and use it to tag your image. For example, let''s suppose
    that your new tag is `foobar`, as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个新的唯一标签，并使用它来标记你的镜像。例如，假设你的新标签是`foobar`，如以下代码所示：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Push the image to the `ecr` repository, as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到`ecr`仓库，步骤如下：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Update the ECS service CloudFormation stack, as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新ECS服务的CloudFormation堆栈，步骤如下：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check the outputs after it updates, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后检查输出，步骤如下：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The browser output also reflects the updated image response:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器输出也反映了更新后的镜像响应：
- en: '![](img/5f8c34e6-dd67-438f-a599-6502944443a1.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f8c34e6-dd67-438f-a599-6502944443a1.png)'
- en: Using this sequence of events, we are going to automate the deployment process
    and create a new continuous integration/continuous deployment pipeline.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一事件序列，我们将自动化部署过程，并创建一个新的持续集成/持续部署（CI/CD）管道。
- en: Creating a CI/CD pipeline to deploy to ECS
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CI/CD管道以部署到ECS
- en: 'As we know, having the ability to continuously deploy code across our environments
    is a very powerful tool as it helps to break out those traditional Dev versus
    Ops silos and improve the velocity at which new code is being released. We created
    a pipeline that allows us to automatically deploy new changes from our Hello World
    application to our Auto Scaling Groups for staging and production. We will create
    a similar pipeline but, this time, it will deploy changes to ECS. Our ECS infrastructure
    will be as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，能够在我们的环境中持续部署代码是一个非常强大的工具，因为它有助于打破传统的开发与运维隔阂，并提高新代码发布的速度。我们创建了一个管道，允许我们自动将Hello
    World应用程序的更新部署到我们的自动扩展组用于暂存和生产环境。我们将创建一个类似的管道，但这次它将更新ECS。我们的ECS基础设施将如下所示：
- en: '![](img/bf0104de-f636-4398-a66e-f602ed354865.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf0104de-f636-4398-a66e-f602ed354865.png)'
- en: Reusing the CloudFormation templates produced in the previous section will create
    a production environment identical to the staging one. Note that the `ecr` repository
    is meant to be unique for a given application, and therefore will share it across
    our environments. In addition, we will follow the best practices learned in [Chapter
    3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    As Code*, and create our pipeline through a CloudFormation stack. Our first step
    will be to create an ECS cluster for production.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 重用上一部分中生成的 CloudFormation 模板，将创建一个与暂存环境相同的生产环境。请注意，`ecr` 仓库是特定于某个应用程序的，因此我们将在所有环境中共享它。此外，我们将遵循在[第
    3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)中学到的最佳实践，*将基础设施视为代码*，并通过 CloudFormation
    堆栈创建我们的管道。我们的第一步将是为生产环境创建一个 ECS 集群。
- en: Creating our production ECS cluster
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的生产 ECS 集群
- en: 'Thanks to the upfront work we did with our CloudFormation templates, adding
    a new environment will be trivial. We will start by launching a production ECS
    cluster:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们事先在 CloudFormation 模板中做的工作，添加新环境将变得非常简单。我们将首先启动一个生产 ECS 集群：
- en: '[PRE79]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to wait for the creation of the stack to complete as we need to get
    some of the exported values from the cluster creation. We can run the following
    command to get our Terminal to hang until we can create our next stack:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要等待堆栈创建完成，因为我们需要从集群创建中获取一些导出的值。我们可以运行以下命令，直到能够创建下一个堆栈为止，这样我们的终端就会暂停：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the meantime, we create our ALB and wait for the creation process to complete:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们创建我们的 ALB 并等待创建过程完成：
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we can create our service with the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下代码创建我们的服务：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'At this point, our production environment should be working. We can get its
    URL by looking at the output of the ALB stack creation, and we can CURL the endpoint
    to ensure that the application is up and running:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的生产环境应该已经正常运行。我们可以通过查看 ALB 堆栈创建的输出，获取其 URL，并且可以使用 CURL 访问端点以确保应用程序正在运行：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will be as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/2b95d0e1-3bb8-4ee5-a297-99d55463d50e.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b95d0e1-3bb8-4ee5-a297-99d55463d50e.png)'
- en: Now that our production environment is ready, we will look into automating the
    creation of containers. In order to accomplish that, we will rely on the CodeBuild
    service.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的生产环境已准备就绪，我们将着手自动化容器的创建。为了实现这一目标，我们将依赖 CodeBuild 服务。
- en: Automating the creation of containers with CodeBuild
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CodeBuild 自动化创建容器
- en: AWS CodeBuild is a managed service geared toward compiling source code. It is
    comparable to Jenkins but since it's a managed service that conforms to AWS standards,
    it presents a different set of features and benefits. In our case, using CodeBuild
    over Jenkins will allow us to create containers without needing to spin up and
    manage an extra EC2 instance. The service also integrates well with CodePipeline,
    which, as before, will drive our process.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeBuild 是一项托管服务，旨在编译源代码。它类似于 Jenkins，但由于它是符合 AWS 标准的托管服务，因此提供了一组不同的功能和优点。在我们的情况下，使用
    CodeBuild 而不是 Jenkins 将使我们能够创建容器，而无需启动和管理额外的 EC2 实例。该服务还与 CodePipeline 很好地集成，正如之前所述，它将驱动我们的流程。
- en: We will use CloudFormation through the intermediary of Troposphere to create
    our CodeBuild project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 Troposphere 作为中介使用 CloudFormation 来创建我们的 CodeBuild 项目。
- en: 'We will also create a new script and call it `helloworld-codebuild-cf-template.py`.
    We will start with our usual import, template variable creation, and description,
    shown as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个新的脚本并命名为 `helloworld-codebuild-cf-template.py`。我们将从通常的导入、模板变量创建和描述开始，如下所示：
- en: '[PRE84]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We will now define a new role to grant the proper permissions to our CodeBuild
    project. The CodeBuild project will interact with a number of AWS services such
    as ECR, CodePipeline, S3, and CloudWatch logs. To speed up the process, we will
    rely on the AWS vanilla policies to configure the permissions. This gives us the
    following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义一个新角色，以授予我们的 CodeBuild 项目适当的权限。CodeBuild 项目将与多个 AWS 服务进行交互，如 ECR、CodePipeline、S3
    和 CloudWatch 日志。为了加快过程，我们将依赖 AWS 默认策略来配置权限。这将给我们以下代码：
- en: '[PRE85]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'CodeBuild projects require defining a number of elements. The first one we
    will define is the environment. This tells CodeBuild what type of hardware and
    OS we need to build our project, and what needs to be preinstalled. It will also
    let us define extra environment variables. We will use a Docker image provided
    by AWS, which will give us everything we need to get our work done. The Docker
    image comes with the AWS and Docker CLI preinstalled and configured. We will also
    define an environment variable to find our `ecr` repository endpoint:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: CodeBuild 项目需要定义多个元素。我们首先要定义的是环境。它告诉 CodeBuild 我们需要什么类型的硬件和操作系统来构建我们的项目，以及需要预先安装哪些软件。它还允许我们定义额外的环境变量。我们将使用
    AWS 提供的 Docker 镜像，它将为我们提供完成工作所需的一切。该 Docker 镜像预装并配置了 AWS 和 Docker CLI。我们还将定义一个环境变量，以便找到我们的
    `ecr` 仓库端点：
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In CodeBuild, most of the logic is defined in a resource called a `buildspec`.
    The `buildspec` section defines the different phases of the build and what to
    run during those phases. It is very similar to the Jenkins file we created in
    Chapter 5, *Adding Continuous Integration and Continuous Deployment*. The `buildspec`
    section can be created as part of the CodeBuild project or added as a YAML file
    to the root directory of the projects that are being built. We will opt for the
    first option and define `buildspec` inside our CloudFormation template. We will
    create a variable and store a YAML string into it. Since it's going to be a multiline
    variable, we will use the Python triple quote syntax.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CodeBuild 中，大部分逻辑都定义在一个名为 `buildspec` 的资源中。`buildspec` 部分定义了构建的不同阶段以及在这些阶段中要运行的内容。它与我们在第
    5 章 *添加持续集成和持续部署* 中创建的 Jenkins 文件非常相似。`buildspec` 部分可以作为 CodeBuild 项目的一部分创建，或作为
    YAML 文件添加到正在构建的项目的根目录中。我们将选择第一种方式，并在我们的 CloudFormation 模板中定义 `buildspec`。我们将创建一个变量并将一个
    YAML 字符串存储其中。由于这是一个多行变量，我们将使用 Python 的三引号语法。
- en: 'The first key-pair we need to specify is the version of the template. The current
    version of CodeBuild templates is `0.1`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定的第一个密钥对是模板的版本。当前的 CodeBuild 模板版本是 `0.1`：
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The goal of our build process is to generate a new container image, tag it,
    and push it to the `ecr` repository. This will be done in three phases:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建过程目标是生成一个新的容器镜像，对其进行标记，并将其推送到 `ecr` 仓库。这将分三个阶段完成：
- en: '**Pre-build**: This will generate the container image tag and log in to ECR'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预构建**：这将生成容器镜像标记并登录到 ECR。'
- en: '**Build**: This will build the new container image'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：这将构建新的容器镜像。'
- en: '**Post-build**: This will push the new container image to ECR and update the
    `latest` tag to point to the new container'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建后**：这将把新的容器镜像推送到 ECR，并更新 `latest` 标签以指向新容器。'
- en: 'In order to easily understand what is in each container, we will tag them with
    the SHA of the most recent Git commit in the `helloworld` project. This will help
    in understanding what is in each container, as we will be able to run commands
    such as `git checkout <container tag>` or `git log <container tag>`. Due to how
    CodeBuild and CodePipeline are architected, getting this tag in CodeBuild requires
    a bit of work. We will need to run two complex commands as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解每个容器中包含的内容，我们将使用 `helloworld` 项目中最近 Git 提交的 SHA 对它们进行标记。这有助于理解每个容器的内容，因为我们可以运行类似
    `git checkout <container tag>` 或 `git log <container tag>` 的命令。由于 CodeBuild 和
    CodePipeline 的架构方式，要在 CodeBuild 中获取此标签需要一些工作。我们需要运行以下两个复杂的命令：
- en: The first one will extract the execution ID of the current code pipeline execution.
    This is achieved by combining the AWS CLI and the environment variables `CODEBUILD_BUILD_ID`
    and `CODEBUILD_INITIATOR`, which are defined by the CodeBuild service when a build
    starts.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个阶段将提取当前代码管道执行的执行 ID。这是通过结合使用 AWS CLI 和环境变量 `CODEBUILD_BUILD_ID` 和 `CODEBUILD_INITIATOR`
    来实现的，这些环境变量在构建开始时由 CodeBuild 服务定义。
- en: Next, we will use that execution ID to extract the artifact revision ID, which
    happens to be the commit SHA we are looking for.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用该执行 ID 提取工件修订 ID，恰好是我们要寻找的提交 SHA。
- en: 'These commands use some of the most advanced features of the `--query` filter
    option. You can read more about this at the following link: [http://amzn.to/2k7SoLE](http://amzn.to/2k7SoLE).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令使用了 `--query` 过滤选项的一些高级功能。你可以通过以下链接了解更多信息：[http://amzn.to/2k7SoLE](http://amzn.to/2k7SoLE)。
- en: In CodeBuild, each command runs in its own environment, and therefore the easiest
    way to share data across steps is to use temporary files.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CodeBuild 中，每个命令都在其自己的环境中运行，因此跨步骤共享数据的最简单方法是使用临时文件。
- en: 'Right after the `buildspec` version definition, add the following to generate
    the first part of our pre-build phase and extract the tag:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildspec`版本定义之后，添加以下内容以生成预构建阶段的第一部分并提取标签：
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Our tag is now present in the `/tmp/tag.txt` file. We now need to generate
    two files as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标签现在已出现在`/tmp/tag.txt`文件中。接下来，我们需要生成两个文件，如下所示：
- en: The first one will contain the argument for the `docker tag` command (this will
    be something like `<AWS::AccountId>.dkr.ecr.us-east-1.amazonaws.com/helloworld:<tag>`).
    To do that, we will take advantage of the environment variable defined earlier
    in our template.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个文件将包含`docker tag`命令的参数（这将类似于`<AWS::AccountId>.dkr.ecr.us-east-1.amazonaws.com/helloworld:<tag>`）。为此，我们将利用之前在模板中定义的环境变量。
- en: The second file will be a JSON file that will define a key-value pair with the
    tag. We will use that file a bit later when we work on deploying our new containers
    to ECS.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个文件将是一个JSON文件，它将定义一个包含标签的键值对。稍后我们将在将新容器部署到ECS时使用该文件。
- en: 'After the previous commands, add the following commands to generate those files:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行了前面的命令后，添加以下命令以生成这些文件：
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To conclude the `pre_build` section, we will log in to our `ecr` repository:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束`pre_build`部分，我们将登录到我们的`ecr`仓库：
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We will now define our build phase. Thanks to the `build_tag` file created
    earlier, the build phase will be straightforward. We will call the `docker build`
    command in a similar way to how we did in the first section of this chapter:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义我们的构建阶段。感谢之前创建的`build_tag`文件，构建阶段将变得非常简单。我们将以与本章第一部分类似的方式调用`docker build`命令：
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We will now add the `post_build` phase to complete the build. In this section,
    we will push the newly built container to our `ecr` repository as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加`post_build`阶段以完成构建。在这一部分，我们将把新构建的容器推送到我们的`ecr`仓库，具体如下：
- en: '[PRE92]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In addition to the phases, one of the sections that is also defined in a `buildspec`
    is the `artifacts` section. This section is used to define what needs to be uploaded
    to S3 after the build succeeds, as well as how to prepare it. We will export the
    `build.json` file and set the `discard-paths` variable to true so we don''t preserve
    the `/tmp/` directory information. Finally, we will close our triple quote string
    as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了各个阶段外，`buildspec`中还定义了一个`artifacts`部分。该部分用于定义在构建成功后需要上传到S3的内容，以及如何准备它。我们将导出`build.json`文件，并将`discard-paths`变量设置为true，以便不保留`/tmp/`目录的信息。最后，我们将关闭我们的三重引号字符串，如下所示：
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now that our `buildspec` variable is defined, we can add our CodeBuild project
    resource. Through the instantiation of the project, we will set a name for our
    project, set its environment by calling the variable previously defined, set the
    service role, and configure the source and artifact resources, which define how
    to handle the build process and its output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`buildspec`变量已定义，我们可以添加CodeBuild项目资源。通过实例化该项目，我们将为项目设置一个名称，调用之前定义的变量设置其环境，设置服务角色，并配置源和工件资源，这些资源定义了如何处理构建过程及其输出：
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As always, we will conclude the creation of the script with the following `print`
    command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将以以下`print`命令结束脚本的创建：
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Our script is now complete and should look like this: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本现在已完成，应该如下所示：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py)。
- en: 'We can save the file, add it to git, generate the CloudFormation template,
    and create our stack as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存文件，将其添加到git中，生成CloudFormation模板，并如下创建我们的堆栈：
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In a matter of minutes, our stack will be created. We will now want to take
    advantage of it. To do so, we will turn to CodePipeline once again and create
    a brand new, container-aware pipeline.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟之内，我们的堆栈就会创建完成。接下来，我们希望利用它。为此，我们将再次使用CodePipeline，创建一个全新的、容器感知的管道。
- en: Creating our deployment pipeline with CodePipeline
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建我们的部署管道
- en: 'We will use AWS CodePipeline to build a pipeline very similar to the one we
    created in Chapter 5, *Adding Continuous Integration and Continuous Deployment*:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AWS CodePipeline构建一个与第5章《*添加持续集成和持续部署*》中创建的管道非常相似的管道：
- en: '![](img/22a0888a-7630-48da-9601-20035de62882.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22a0888a-7630-48da-9601-20035de62882.png)'
- en: We will start with a Source step where we will connect to GitHub and trigger
    new pipelines that run automatically when the code changes. After this, we will
    build a new container and push it to our `ecr` repository rely upon the CodeBuild
    project we just created. We will then deploy the new container to staging. To
    do that, we will use the CloudFormation integration provided by CodePipeline,
    combined with the `build.json` file produced in the `buildspec` section of our
    CodeBuild project. You may recall that our `helloworld` service templates take
    the tag to deploy as an argument. We will trigger a stack update action and override
    the default value for that parameter with what's defined in the `build.json` file.
    After that, we will add a manual approval step before triggering the same deployment
    again, but this time for production.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个 Source 步骤开始，在此步骤中我们将连接到 GitHub，并在代码更改时自动触发新的管道。之后，我们将构建一个新的容器，并将其推送到我们的
    `ecr` 仓库，依赖于我们刚刚创建的 CodeBuild 项目。然后，我们将把新的容器部署到暂存环境。为了做到这一点，我们将使用 CodePipeline
    提供的 CloudFormation 集成功能，结合在我们的 CodeBuild 项目的 `buildspec` 部分生成的 `build.json` 文件。你可能还记得，我们的
    `helloworld` 服务模板将标签作为部署参数。我们将触发一个堆栈更新操作，并用 `build.json` 文件中定义的值覆盖该参数的默认值。之后，我们将在触发相同的部署之前添加一个手动审批步骤，但这次是部署到生产环境。
- en: Deploying and updating CloudFormation templates through CodePipeline will require
    specifying the location of the template within the inputs. In order to easily
    provide it, we will first start by adding the CloudFormation template to our source.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 CodePipeline 部署和更新 CloudFormation 模板将需要在输入中指定模板的位置。为了方便提供它，我们将首先通过将 CloudFormation
    模板添加到我们的源中来开始。
- en: Adding the CloudFormation template to our code base
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 CloudFormation 模板添加到我们的代码库中
- en: 'ECS changes are driven by the task definition present in our `helloworld-ecs-service-
    cf.template` file. So far we have only stored our Python script in GitHub. We
    will have to make a special case for that template and store the JSON output of
    it so that CodePipeline can interact with our stack. We will add this file to
    our Git repository in a new directory as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ECS 的变更由我们在 `helloworld-ecs-service-cf.template` 文件中定义的任务定义驱动。到目前为止，我们只在 GitHub
    上存储了我们的 Python 脚本。我们需要为该模板制作一个特殊情况，并存储其 JSON 输出，以便 CodePipeline 能与我们的堆栈交互。我们将把这个文件添加到我们的
    Git 仓库中，放在一个新目录下，如下所示：
- en: '[PRE97]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now that our template is present in our source, we can create our CloudFormation
    template for our pipeline.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模板已经存在于源中，我们可以为我们的管道创建 CloudFormation 模板。
- en: Creating a CloudFormation template for CodePipeline
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 CodePipeline 创建 CloudFormation 模板
- en: We will start by creating a file called `helloworld-codepipeline-cf- template.py`
    inside EffectiveDevOpsTemplates locally.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在 EffectiveDevOpsTemplates 本地创建一个名为 `helloworld-codepipeline-cf-template.py`
    的文件开始。
- en: 'We will start the script with our boilerplates:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的样板代码开始编写脚本：
- en: '[PRE98]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The first resource we will create is the S3 bucket that the pipeline will use
    to store all the artifacts produced by each stage. We will also turn on versioning
    on that bucket:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个资源是 S3 存储桶，管道将使用它来存储每个阶段生成的所有工件。我们还将开启该存储桶的版本控制：
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We will now create the IAM roles needed as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建所需的 IAM 角色，如下所示：
- en: 'The first role we are going to define will be for the CodePipeline service:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义的第一个角色将是用于 CodePipeline 服务的角色：
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The second role will be used by the deploy stages to perform CloudFormation
    changes:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个角色将由部署阶段用于执行 CloudFormation 变更：
- en: '[PRE101]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We can now create our pipeline resource. We will first configure its name and
    specify the role **Amazon Resource Name** (**ARN**) of the role we just created:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的管道资源。我们将首先配置其名称，并指定我们刚刚创建的角色的 **Amazon 资源名称**（**ARN**）：
- en: '[PRE102]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'After this, we will reference the S3 bucket created earlier so that we have
    a place to store the different artifacts produced through the pipeline execution:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将引用之前创建的 S3 存储桶，以便为通过管道执行产生的不同工件提供存储位置：
- en: '[PRE103]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We will now define each stage of the pipeline. The CloudFormation structure
    reflects what we did previously using the web interface. Each stage has a unique
    name and is composed of actions. Each action is defined by a name, a category,
    a configuration, and, optionally, input and output artifacts:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义管道的每个阶段。CloudFormation 结构反映了我们之前使用 Web 界面所做的操作。每个阶段都有一个唯一的名称，并由多个动作组成。每个动作由一个名称、一个类别、一个配置，以及可选的输入和输出工件定义：
- en: 'Our first stage will be the GitHub stage, as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个阶段将是 GitHub 阶段，如下所示：
- en: '[PRE104]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We will create a first artifact called `App` with the content of the repository.
    In order to avoid hardcoding any `OAuthToken`, we will configure the GitHub integration
    after creating the CloudFormation stack.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`App`的第一个工件，包含存储库的内容。为了避免硬编码任何`OAuthToken`，我们将在创建 CloudFormation 堆栈后配置
    GitHub 集成。
- en: 'Our next step will be to configure our build. As mentioned, we will simply
    call out to the CodeBuild stack we spawned up in the last section. We will store
    the output artifact under the name `BuildOutput`, meaning that we now have two
    artifacts: the `App` artifact and `BuildOutput`, which contains the `tag.json`
    file produced by CodeBuild:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步将是配置构建。如前所述，我们将简单地调用上一节中启动的 CodeBuild 堆栈。我们将把输出工件存储为`BuildOutput`，这意味着现在我们有两个工件：`App`工件和`BuildOutput`，后者包含由
    CodeBuild 生成的`tag.json`文件：
- en: '[PRE105]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We will now create our staging deployment. Unlike before, we won't use CodeDeploy
    but will directly update our CloudFormation template. In order to accomplish that,
    we will need to provide the location of the template to the configuration of our
    action. Since we added it to our `helloworld` GitHub repository, we can reference
    it with the help of the `App` artifact. Our template is present under `<directory
    root>/templates/helloworld-ecs-service- cf.template`, which in turn means for
    CodePipeline `App::templates/helloworld-ecs-service-cf.template`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建暂存部署。与之前不同，我们不再使用 CodeDeploy，而是直接更新 CloudFormation 模板。为了实现这一点，我们需要将模板的位置提供给我们的操作配置。由于我们将其添加到`helloworld`
    GitHub 仓库中，因此可以借助`App`工件来引用它。我们的模板位于`<directory root>/templates/helloworld-ecs-service-cf.template`，对于
    CodePipeline 来说就是`App::templates/helloworld-ecs-service-cf.template`。
- en: 'The next trick in configuring our CloudFormation action relies on the fact
    that we can override the parameters provided for the stack. CloudFormation provides
    a couple of functions to help with dynamic parameters. You can read more about
    those at [http://amzn.to/2kTgIUJ](http://amzn.to/2kTgIUJ). We will focus on a
    particular one here: `Fn::GetParam`. This function returns a value from a key-value
    pair file present in an artifact. This is where we take advantage of the file
    we created in CodeBuild, as it will contain a JSON string in the format `{ "tag":
    "<latest git commit sha>" }`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '配置 CloudFormation 操作的下一个技巧依赖于我们可以覆盖为堆栈提供的参数这一事实。CloudFormation 提供了一些函数来帮助处理动态参数。你可以在[http://amzn.to/2kTgIUJ](http://amzn.to/2kTgIUJ)了解更多关于这些函数的内容。我们在这里将重点介绍一个函数：`Fn::GetParam`。此函数从工件中存在的键值对文件中返回一个值。这就是我们利用在
    CodeBuild 中创建的文件的地方，因为该文件将包含一个 JSON 字符串，格式为 `{ "tag": "<latest git commit sha>"
    }`：'
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'After the staging deployment completes, we will request a manual approval,
    as follows:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在暂存部署完成后，我们将请求手动批准，如下所示：
- en: '[PRE107]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Finally, we will create a last stage to run the production deployment. The
    code is exactly the same here as it is for staging, except for the name of the
    stage and the stack targeted by our configuration:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建最后一个阶段来运行生产部署。此处的代码与暂存阶段完全相同，只是阶段的名称和我们的配置所针对的堆栈不同：
- en: '[PRE108]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Our pipeline resource has now been created. We can conclude the creation of
    our script by printing out our template:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的管道资源现在已经创建完毕。我们可以通过打印出我们的模板来结束脚本的创建：
- en: '[PRE109]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The script is now ready to be used. It should look like the script at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在已准备好使用。它应与以下链接中的脚本相似：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py)。
- en: We can now create our pipeline.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建我们的管道。
- en: Starting and configuring our CloudFormation stack
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动并配置我们的 CloudFormation 堆栈
- en: 'We will proceed as usual for the first part of our pipeline''s creation, as
    follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按常规步骤继续创建管道的第一部分，如下所示：
- en: '[PRE110]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We are using the `CAPABILITY_NAMED_IAM` capability in this case, as we are defining
    custom names at the IAM level.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`CAPABILITY_NAMED_IAM`功能，因为我们在 IAM 级别定义了自定义名称。
- en: 'This will create our pipeline. However, a small catch is that we didn''t specify
    the GitHub credentials in the pipeline. This is because we don''t want to store
    it in clear text in GitHub. AWS offers a service within IAM to do encryption,
    but we won''t cover that in this book. Consequently, we will simply edit the pipeline
    the first time around, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的管道。然而，有一个小问题是，我们在管道中没有指定 GitHub 凭证。这是因为我们不想在 GitHub 中以明文存储它。AWS 在 IAM
    中提供了一项加密服务，但本书不会涉及这部分内容。因此，我们将在第一次编辑管道时按如下方式进行操作：
- en: Open [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
    in your browser
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
- en: Select your newly created pipeline
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你新创建的管道
- en: Click on Edit at the top
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的编辑
- en: 'Click on the pen icon on the GitHub action:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 GitHub 操作中的铅笔图标：
- en: '![](img/506252fb-0441-4a3c-9b01-ee48aac15212.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/506252fb-0441-4a3c-9b01-ee48aac15212.png)'
- en: Click on Connect to GitHub on the right-hand-side menu and follow the steps
    to authorize AWS CodePipeline
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧菜单中的连接 GitHub，并按照步骤授权 AWS CodePipeline
- en: Select your `helloworld` project in the repository step and the master branch
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仓库步骤中选择你的`helloworld`项目和主分支
- en: Click on Update, save the pipeline changes, and finally, Save and Continue
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击更新，保存管道更改，最后，点击保存并继续
- en: 'After a few seconds, your pipeline will trigger, and you should see your first
    deployment going through. This concludes the creation of our CI/CD pipeline:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你的管道将触发，你应该能看到第一次部署正在进行。这标志着我们 CI/CD 管道的创建完成：
- en: '![](img/5852e5b1-5dc4-4346-814f-96a5c982093c.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5852e5b1-5dc4-4346-814f-96a5c982093c.png)'
- en: 'You will also be able to see all of the CloudFormation stack details on the
    AWS console with the `CREATE_COMPLETE` status, as shown in the following screenshot:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 AWS 控制台上看到所有 CloudFormation 堆栈的详细信息，状态为 `CREATE_COMPLETE`，如下所示：
- en: '![](img/fcd718ba-f6e2-4acc-90ec-f5d648d0aa71.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcd718ba-f6e2-4acc-90ec-f5d648d0aa71.png)'
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the concept of containers, using Docker and ECS.
    After exploring the basics of how Docker works, we created a container for our
    application. After running it locally, we created a new set of resources to run
    Docker containers on AWS. We did that using the DevOps best practices and used
    CloudFormation to generate our resources, treating our infrastructure as code.
    This allows us to keep those changes under source control. Resource-wise, we created
    an ECR repository to manage the different revisions of our containers. We also
    created two ECS clusters with auto scaling capabilities for staging and production,
    two ALBs to proxy the traffic to our containers, a set of tasks, and an ECS service,
    to configure and deploy our application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了容器的概念，使用 Docker 和 ECS。在了解 Docker 工作原理的基础上，我们为我们的应用程序创建了一个容器。将其在本地运行后，我们创建了一组新的资源，在
    AWS 上运行 Docker 容器。我们通过 DevOps 最佳实践来完成此操作，并使用 CloudFormation 生成资源，将基础设施视为代码。这使我们能够将这些更改保存在源代码控制中。在资源方面，我们创建了一个
    ECR 仓库来管理不同版本的容器。我们还创建了两个 ECS 集群，具备自动扩展功能，用于暂存和生产环境，两个 ALB 用于将流量代理到容器，一个任务集和一个
    ECS 服务，用于配置和部署我们的应用程序。
- en: Finally, we re-implemented a CI/CD pipeline. We did that by using CodeBuild,
    CodePipeline, and their integrations with CloudFormation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重新实现了一个 CI/CD 管道。我们通过使用 CodeBuild、CodePipeline 及其与 CloudFormation 的集成来完成这一工作。
- en: We will continue improving our systems and we will implement one of the last
    key characteristics of DevOps; measuring everything. By taking advantage of a
    number of features that are present in the different services that we use, and
    by coupling them with other AWS services (such as CloudWatch), we will be able
    to implement a monitoring strategy for our infrastructure and services.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续改进我们的系统，并实现 DevOps 最后一项关键特性之一：衡量一切。通过利用我们使用的不同服务中存在的一些功能，并结合其他 AWS 服务（例如
    CloudWatch），我们将能够为我们的基础设施和服务实施监控策略。
- en: Questions
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Docker? List the important components of Docker Engine.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Docker？列出 Docker 引擎的重要组件。
- en: Can you install and configure the latest Docker CE on any supported platform/OS
    of your choice?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能在你选择的任何支持的平台/操作系统上安装并配置最新版本的 Docker CE 吗？
- en: Can you create a Docker image and use the same image to create a web server
    container?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能创建一个 Docker 镜像并使用相同的镜像创建一个 Web 服务器容器吗？
- en: Can you create ECR and ECS using AWS webconsole to get familiar with ECS terminologies?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能通过 AWS Web 控制台创建 ECR 和 ECS，以熟悉 ECS 术语吗？
- en: Further reading
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Refer to the following links for further information:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接获取更多信息：
- en: '**Docker Documentation**: [https://docs.docker.com](https://docs.docker.com)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 文档**: [https://docs.docker.com](https://docs.docker.com)'
- en: '**Docker Hub**: [https://hub.docker.com](https://hub.docker.com)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**: [https://hub.docker.com](https://hub.docker.com)'
- en: '**AWS CodeBuild**: [https://aws.amazon.com/codebuild/](https://aws.amazon.com/codebuild/)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeBuild**: [https://aws.amazon.com/codebuild/](https://aws.amazon.com/codebuild/)'
- en: '**AWS CodePipeline**: [https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodePipeline**: [https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/)'
- en: '**AWS Elastic Container Service**: [https://aws.amazon.com/ecs/](https://aws.amazon.com/ecs/)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Elastic Container Service**: [https://aws.amazon.com/ecs/](https://aws.amazon.com/ecs/)'
