- en: Serverless Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器框架
- en: This chapter discusses serverless frameworks. What are they? What are the current
    limitations of pure serverless frameworks? How could Docker partially solve the
    limitations of serverless frameworks. We will start by taking a look at AWS Lambda,
    then Azure Functions, and Google Cloud Functions. We will touch briefly on IBM
    Cloud Functions, but actually its engine is OpenWhisk, which will be discussed
    in detail in the next couple of chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论无服务器框架。它们是什么？纯粹的无服务器框架目前有哪些限制？Docker如何部分解决无服务器框架的限制？我们将从了解AWS Lambda开始，然后是Azure
    Functions和Google Cloud Functions。我们会简要提及IBM Cloud Functions，但实际上它的引擎是OpenWhisk，接下来的几章会详细讨论它。
- en: We will also discuss serverless framework, a toolkit that helps us develop cloud-independent
    serverless applications, in the last section of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在本章最后一部分讨论无服务器框架，一个帮助我们开发云独立无服务器应用程序的工具包。
- en: AWS Lambda
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: Among serverless architectures offered by cloud providers, AWS Lambda is the
    most popular and has some advanced features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在云服务提供商提供的无服务器架构中，AWS Lambda是最受欢迎的，并且具有一些高级功能。
- en: FaaS/serverless is a natural evolution from microservices, or we may think of
    it as an extension to the microservices architecture. In many scenarios, we can
    complement our microservices architecture with functions or Lambda. If you are
    already an AWS customer, it is completely natural to move your codes from EC2
    to Lambda and save a lot of money. The following diagram illustrates a simple
    use case that uses **AWS Lambda** together with **S3 Buckets** and **DynamoDB:**
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS/无服务器是微服务的自然进化，或者我们可以把它看作是对微服务架构的扩展。在许多场景中，我们可以使用函数或Lambda来补充我们的微服务架构。如果你已经是AWS客户，将代码从EC2迁移到Lambda是完全自然的，并且能够节省大量资金。下面的图表展示了一个使用**AWS
    Lambda**与**S3存储桶**和**DynamoDB**的简单用例：
- en: '![](img/74d0ca23-fdea-4bd8-9e59-6a724c4b27cd.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74d0ca23-fdea-4bd8-9e59-6a724c4b27cd.png)'
- en: 'Figure 3.1: A simple use case of using Lambda function on AWS'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：在AWS上使用Lambda函数的简单用例
- en: In S3, there is a way to trigger the event to a specific endpoint. We put the
    endpoint of our Lambda function there. After users upload or make changes to the
    S3 bucket, it will trigger to send an invocation request to the Lambda function.
    This could be thought of as a form of WebHooks. After that, the Lambda function
    receives the event and starts to compute its application logic. After it has finished,
    the Lambda will transfer the results and store them into a DynamoDB instance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在S3中，可以触发事件到特定的端点。我们将Lambda函数的端点放在那里。当用户上传或更改S3存储桶中的内容时，它会触发一个调用请求发送到Lambda函数。这可以视为一种WebHooks的形式。之后，Lambda函数接收事件并开始计算其应用逻辑。完成后，Lambda将结果传输并存储到DynamoDB实例中。
- en: We will demonstrate a similar scenario in [Chapter 8](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml),
    *Putting Them All Together*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml)中演示一个类似的场景，*将它们全部整合起来*。
- en: Limitations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: Lambda supports several language runtimes; for example, Node.js, Go, Java, Python,
    and C#. Each AWS Lambda has a number of limitations to cap the resources it may
    use per invocation. In terms of memory, the range of RAM supported for Lambda
    is between 128 MB to 3,008 MB with 64 MB, increments. The function will be automatically
    terminated if its memory usage is exceeded.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda支持多种语言运行时；例如，Node.js、Go、Java、Python和C#。每个AWS Lambda都有一些限制，来限制每次调用所使用的资源。在内存方面，Lambda支持的RAM范围从128
    MB到3,008 MB，按64 MB的增量分配。如果内存使用超过限制，函数将自动终止。
- en: In terms of disk space, a Lambda function is allowed to use the `/tmp` directory
    up to 512 MB. This kind of disk volume is ephemeral, so it is expected to be wiped
    out after the Lambda has finished its work. Also, the number of file descriptors
    allowed in Lambda functions are limited to 1,024, while the number of processes
    and threads that could be forked within a single invocation is limited to 1,024
    as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘空间方面，Lambda函数可以使用`/tmp`目录，最多512 MB。这个磁盘卷是临时性的，因此在Lambda完成工作后，它会被清除。此外，Lambda函数中允许的文件描述符数量限制为1,024，而在单次调用中可以分叉的进程和线程数也限制为1,024。
- en: For each request, the size of the request body is capped at 6 MB for synchronous
    HTTP calls, and at 128 KB for asynchronous, event-triggered calls.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，同步HTTP调用的请求体大小限制为6 MB，而异步、事件触发调用的请求体大小限制为128 KB。
- en: The most important aspect here is *time limits*. AWS Lambda allows a function
    to run no longer than 5 minutes (or 300 seconds). If the execution time exceeds
    5 minutes, the function will be automatically killed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的方面是*时间限制*。AWS Lambda允许一个函数运行最长不超过5分钟（或300秒）。如果执行时间超过5分钟，函数将被自动终止。
- en: Lambda termination
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda终止
- en: The technology behind Lambda is actually container-based, which means it isolates
    a function from other instances. The container's sandbox provides resources specific
    to each configuration for them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda背后的技术实际上是基于容器的，这意味着它将一个函数与其他实例隔离开来。容器的沙箱为每个配置提供特定的资源。
- en: 'A Lambda function can be terminated in a number of ways:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数可以通过多种方式终止：
- en: '**Timeout**: As previously mentioned, when the 5-minute limitation is reached,
    the current execution of the function will be stopped no matter what it is doing.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：如前所述，当达到5分钟限制时，不管当前函数在做什么，都会停止执行。'
- en: '**Controlled termination**: If the function provides a callback and the callback
    is executed to invoke the `context.done()` method, the function will be terminated,
    no matter what it is doing.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受控终止**：如果函数提供了回调，并且回调被执行以调用`context.done()`方法，则无论函数正在做什么，函数都会终止。'
- en: '**Default termination**: The function ends and terminates normally. Also, there
    is no callback to invoke the `context.done()` method. This case will be considered
    as the default termination.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认终止**：函数结束并正常终止。同时，不会调用回调来触发`context.done()`方法。这种情况将被视为默认终止。'
- en: '**Function crashes** **or `process.exit()` is called**: If the function panics
    or generates segmentation faults, the function will terminate and therefore the
    container is stopped.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数崩溃** **或调用了`process.exit()`**：如果函数发生崩溃或产生了段错误，函数将终止，因此容器也会停止。'
- en: Container reuse
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器重用
- en: There is a scenario where the function container that has just terminated could
    be reused.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种情况，即刚刚终止的函数容器可以被重用。
- en: This ability to reuse a finished function container can greatly reduce the spinning
    up time, as the initialization process will be completely skipped. Also, there
    is a drawback where, if a container is reused, the file written to the `/tmp`
    directory from the previous execution may still be there.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重用已完成的函数容器的能力可以大大减少启动时间，因为初始化过程会被完全跳过。同时，如果一个容器被重用，之前执行时写入`/tmp`目录的文件可能仍然存在，这是一个缺点。
- en: Native executables
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地可执行文件
- en: Lambda is actually designed to run code in any language, as Lambda's sandbox
    is just a container. The trick is that we could use a Node.js program to execute
    any binary shipped with the ZIP file before uploading.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda实际上是为了在任何语言中运行代码而设计的，因为Lambda的沙箱只是一个容器。诀窍在于，我们可以使用一个Node.js程序在上传之前执行任何与ZIP文件一起打包的二进制文件。
- en: It is worth noting that when preparing our own binary for Lambda, it must be
    statically compiled or matched with the shared libraries provided by Amazon Linux
    (as the containers used on Lambda are all Amazon Linux-based). It is our responsibility
    to track the Amazon Linux version by ourselves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在为Lambda准备我们自己的二进制文件时，它必须是静态编译的，或者与Amazon Linux提供的共享库相匹配（因为Lambda上使用的所有容器都是基于Amazon
    Linux的）。我们有责任自己跟踪Amazon Linux的版本。
- en: A project such as LambCI ([http://github.com/lambci/docker-lambda](http://github.com/lambci/docker-lambda))
    can help to solve this problem. LambCI provides a local sandbox environment, as
    Docker containers, that mimics the AWS Lambda environment by installing the same
    software and libraries, file structure, and permissions. It also defines the same
    set of environment variables, and other behaviors. Also, the username and group
    are defined to match the Lambda, for example, `sbx_user1051`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个像LambCI这样的项目（[http://github.com/lambci/docker-lambda](http://github.com/lambci/docker-lambda)）可以帮助解决这个问题。LambCI提供了一个本地沙箱环境，作为Docker容器，通过安装相同的软件、库、文件结构和权限来模拟AWS
    Lambda环境。它还定义了相同的一组环境变量以及其他行为。此外，用户名和组也被定义为与Lambda匹配，例如`sbx_user1051`。
- en: With this local environment, we are allowed to safely test our codes inside
    this Docker container and can be sure that it will be running fine on Lambda.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个本地环境，我们可以在这个Docker容器内安全地测试我们的代码，并确保它在Lambda上运行时不会出问题。
- en: Azure Functions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Azure Functions is a serverless computing platform offered by Microsoft as a
    part of Azure Cloud. All design goals are the same as other serverless/FaaS services,
    and Azure Functions enables us to execute our application logic without managing
    our own infrastructure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 是微软提供的无服务器计算平台，作为 Azure 云的一部分。所有设计目标与其他无服务器/FaaS 服务相同，Azure
    Functions 使我们能够执行应用逻辑，而无需管理自己的基础设施。
- en: Azure Functions runs a program in the form of scripts when it is triggered by
    events. The current version of Azure Functions supports language runtimes such
    as C#, F#, PHP, Node.js or Java. It is natural for Azure to support C# and F#
    as first-class languages for their functions because they are Microsoft-owned
    programming languages. In any case, the only GA-supported languages are C#, F#,
    and JavaScript (Node.js) anyway.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 在被事件触发时，以脚本的形式运行程序。当前版本的 Azure Functions 支持如 C#、F#、PHP、Node.js
    或 Java 等语言运行时。对于 Azure 来说，支持 C# 和 F# 作为其功能的第一语言是很自然的，因为它们是微软自有的编程语言。无论如何，目前仅有
    C#、F# 和 JavaScript（Node.js）是正式支持的语言。
- en: With C#, F#, or .NET languages, Azure Functions allows us to install dependencies
    via NuGet, the infamous package manager for .NET. In case we are writing JavaScript
    with Node.js, Azure also provides access to NPM for package management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C#、F# 或 .NET 语言时，Azure Functions 允许我们通过 NuGet（.NET 的著名包管理器）安装依赖项。如果我们使用 Node.js
    编写 JavaScript，Azure 还提供了对 NPM 包管理的访问。
- en: Similar to other cloud providers, Azure Functions has an advantage when accessing
    other Azure services, for example, Azure Cosmos DB, Azure Event Hubs, Azure Storage
    and Azure Service Bus.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他云服务提供商，Azure Functions 在访问其他 Azure 服务时具有优势，例如 Azure Cosmos DB、Azure Event
    Hubs、Azure Storage 和 Azure Service Bus。
- en: It is really interesting to note that the pricing model of Azure Functions is
    somewhat different from the offering of Amazon or Google. In Azure, there are
    two kind of pricing plans that may fit different needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的一点是，Azure Functions 的定价模型与 Amazon 或 Google 的产品有所不同。在 Azure 中，有两种定价计划可以满足不同的需求。
- en: The first one is the *consumption plan*. It is a similar plan offered by other
    cloud providers, where you pay only for the time that our codes are executed.
    The second one is the *app service plan*. Functions in this context are considered
    part of the app service for other applications. If functions fall into this category,
    we do not need to incur additional cost.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是*消费计划*。这与其他云服务提供商提供的计划类似，我们只需为代码执行的时间付费。第二个是*应用服务计划*。在这种情况下，函数被视为其他应用程序的应用服务的一部分。如果函数属于这一类别，我们无需额外支付费用。
- en: An interesting feature of Azure Functions is its triggering and binding mechanism.
    Azure Functions allows a definition of how to trigger a function and how to perform
    data binding of the input and the output for each function, in a separated configuration.
    These mechanisms help to avoid hardcoding when we call functions and when we transform
    data in and out through the calling chain of functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 的一个有趣特点是它的触发和绑定机制。Azure Functions 允许定义如何触发一个函数，以及如何在每个函数的输入和输出之间进行数据绑定，这些配置是分开的。这些机制有助于避免在调用函数时进行硬编码，以及在函数调用链中进行数据的进出转换。
- en: Scaling
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展性
- en: In Azure, there is a component to monitor the number of requests made to each
    Azure Function in real time. This component is called the **scale controller**.
    It collects data and then later makes a decision to scale the number of instances
    up or down for that function. Azure has the concept of an app service. A function
    app may contain many instances of a function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，有一个组件可以实时监控每个 Azure Function 的请求数量。这个组件被称为**扩展控制器**。它收集数据，然后做出决定，来扩展或缩减该功能实例的数量。Azure
    引入了应用服务的概念，一个功能应用可能包含多个功能实例。
- en: All decision making is based on heuristic-based algorithms for different types
    of event triggers. When the function is scaled out, all resources related to that
    function will also be scaled out. The number of function instances will be automatically
    scaled down to zero, if there is no request made to the function app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有决策都是基于启发式算法来处理不同类型的事件触发器。当功能扩展时，所有与该功能相关的资源也会被扩展。如果没有请求发送到该功能应用，功能实例的数量将自动缩减为零。
- en: Limitations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: Each function instance will be limited to a memory of 1.5 GB by the host of
    the function app, a group-like semantic for multiple function instances. All functions
    within a function app share the same resources.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数实例将由函数应用的主机限制为 1.5 GB 的内存，这就像多个函数实例共享资源的一个组语义。所有函数都共享同一资源。
- en: A function app holds a maximum of 200 instances of a function at the same time.
    But there is no concurrency limitation. In practice, a function instance can accept
    one or more requests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数应用最多可以同时容纳 200 个函数实例。但没有并发限制。实际上，一个函数实例可以接受一个或多个请求。
- en: Each event trigger, for example, Azure Service Bus has its own heuristic way
    to scale the underlying function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件触发器，例如，Azure Service Bus，都有其独特的启发式方式来扩展底层函数。
- en: Durable functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化函数
- en: 'One of the most advanced extensions to the Azure Functions are **durable functions**.
    A durable function is a technique to implement stateful functions inside a serverless
    computing environment. There are additional concepts for state management, checkpoints,
    and restarts provided by this durable extension. What we get from this kind of
    function is a stateful workflow, and there will be a driver that acts as the orchestrator
    to call other functions, as shown in the following diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 最先进的扩展之一是**持久化函数**。持久化函数是一种在无服务器计算环境中实现有状态函数的技术。通过这个持久化扩展，提供了更多的状态管理、检查点和重启的概念。我们从这种函数中获得的是一个有状态的工作流，并且会有一个驱动程序作为协调者来调用其他函数，如下图所示：
- en: '![](img/76ad2f42-1a69-4442-bec0-1df67ba324e9.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76ad2f42-1a69-4442-bec0-1df67ba324e9.png)'
- en: 'Figure 3.2: An orchestrator function with the durable function extension in
    Azure'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：Azure 中使用持久化函数扩展的协调器函数
- en: When it has finished calling other functions, both in synchronous or asynchronous
    ways, the orchestrator function will be allowed to save states as local variables.
    There is also a *checkpointing technique* to continue/resume the orchestrator's
    states when the calling process has to start over, or the virtual machine running
    this orchestrator function gets rebooted.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当它完成调用其他函数后，无论是同步还是异步，协调器函数将允许将状态保存为本地变量。如果调用过程必须重新开始，或运行此协调器函数的虚拟机重新启动时，还会有一个*检查点技术*来继续/恢复协调器的状态。
- en: Google Cloud Functions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Functions
- en: The serverless computing service offered by Google Inc is called **Google Cloud
    Functions **(**GCF**).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌公司提供的无服务器计算服务被称为**Google Cloud Functions**（**GCF**）。
- en: 'We basically refer to it as GCF in this section. Like other serverless platforms,
    GCF provides both execution environment and the SDK to help us develop and manage
    the entire life cycle of our function. It provides an SDK to help us get started
    with the framework. The main language supported by GCF is JavaScript and there
    is a Node.js Docker image for us to use. With Docker, it is convenient to build
    a function. When about to deploy, it is relatively easy to deploy it with the
    Google Cloud CLI tool. It is natural that GCF will allow us to connect to other
    Google-based services efficiently:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们通常称其为 GCF。像其他无服务器平台一样，GCF 提供了执行环境和 SDK，帮助我们开发和管理整个函数生命周期。它提供了一个 SDK 帮助我们开始使用该框架。GCF
    主要支持的语言是 JavaScript，并且有一个 Node.js Docker 镜像供我们使用。通过 Docker，构建一个函数非常方便。部署时，也可以通过
    Google Cloud CLI 工具轻松部署。GCF 自然允许我们高效地连接到其他 Google 基于服务：
- en: '![](img/06039659-fd8e-42a9-a986-0d4e2c94134b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06039659-fd8e-42a9-a986-0d4e2c94134b.png)'
- en: 'Figure 3.3: A common IoT use case implemented with Google Cloud Functions'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：使用 Google Cloud Functions 实现的常见物联网用例
- en: The preceding diagram demonstrates one of the common use cases implemented on
    Google Cloud. It is an example of an IoT pipeline using all Google Cloud services.
    A Google Cloud Function is used to compute data from the message queue and divert
    it to both the big data stack and Firebase. The Firebase service acts as a **Backend
    as a Service** (**BaaS**) for mobile applications. In a later chapter, we will
    demonstrate a similar BaaS using the **Parse platform**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了一个在 Google Cloud 上实现的常见用例。它是一个使用所有 Google Cloud 服务的物联网管道示例。Google Cloud
    Function 用来计算来自消息队列的数据，并将其分发到大数据堆栈和 Firebase。Firebase 服务充当移动应用程序的**后端即服务**（**BaaS**）。在后面的章节中，我们将展示使用**Parse
    平台**实现的类似 BaaS。
- en: Overview
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The definition of a function in the FaaS or the serverless platform is that
    it should focus on only one objective. Due to the nature of the function, it should
    not be too complex. As we described in [Chapter 1](e9b10056-7288-4daf-b2e4-033682fa9185.xhtml),
    *Serverless and Docker*, serverless FaaS is actually a subset of the event-driven
    programming model. All cloud functions on GCF behave that way. Every single component
    of our application pipeline is connected by sending events to another. Also, events
    can be monitored. When we receive an event from the source, a cloud function associated
    with that mechanism will be triggered to run.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FaaS 或无服务器平台中，函数的定义是它应该专注于单一的目标。由于函数的特性，它不应该过于复杂。正如我们在[第一章](e9b10056-7288-4daf-b2e4-033682fa9185.xhtml)中描述的，*无服务器与
    Docker*，无服务器 FaaS 实际上是事件驱动编程模型的一个子集。GCF 上的所有云函数都遵循这种行为。我们应用程序流水线的每个单独组件通过将事件发送给另一个组件来连接。此外，事件是可以被监控的。当我们从源接收到一个事件时，关联的云函数将被触发并执行。
- en: The function supported by GCF must be written in JavaScript, or languages that
    are able to transpile to JavaScript. At the time of writing, the environment for
    executing functions is a Node.js v6.11.5\. Basically, developers would use any
    Node.js runtime that matches the same version. Using JavaScript and Node.js yields
    good portability and it allows developers to test the function locally. In addition,
    using Node.js allows access to the vast numbers of Node.js libraries, including
    APIs offered by the platform ([https://cloud.google.com/nodejs/apis](https://cloud.google.com/nodejs/apis)),
    that help simplify development and integration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: GCF 支持的函数必须使用 JavaScript 编写，或者使用能够转译为 JavaScript 的语言。本文写作时，执行函数的环境是 Node.js
    v6.11.5。基本上，开发人员会使用与该版本匹配的任何 Node.js 运行时。使用 JavaScript 和 Node.js 可以带来良好的可移植性，并允许开发人员在本地测试函数。此外，使用
    Node.js 可以访问大量的 Node.js 库，包括平台提供的 API（[https://cloud.google.com/nodejs/apis](https://cloud.google.com/nodejs/apis)），这些库有助于简化开发和集成。
- en: GCF is designed to be a connection or a glue layer that links services together.
    In some use cases, we use functions to extend the existing cloud services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: GCF 被设计为连接或粘合服务的层。在某些用例中，我们使用函数来扩展现有的云服务。
- en: With the event-driven model, functions can listen and wait until the file uploading
    event is triggered, when some files are put into cloud storage. We can also listen
    to log changing in a remote blockchain environment. Or maybe we subscribe to a
    Pub/Sub topics and get a notification to trigger the functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过事件驱动模型，函数可以监听并等待直到文件上传事件被触发，也就是当某些文件被放入云存储时。我们还可以监听远程区块链环境中的日志变化，或者我们订阅一个
    Pub/Sub 主题并接收通知以触发函数。
- en: We usually put some complex business logic inside a function. Cloud functions
    owned by Google have the ability to access the credential system of the GCP, therefore,
    it could authenticate with the large set of GCP services. This feature usually
    makes the cloud functions very useful on their own platform.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将一些复杂的业务逻辑放在函数内部。Google 拥有的云函数能够访问 GCP 的凭据系统，因此它可以与大量的 GCP 服务进行身份验证。这个特性通常使得云函数在其平台上非常有用。
- en: All infrastructure and the system software layers are fully managed by Google's
    platform, so we need to care only for our codes. Autoscaling is also the normal
    feature of this kind of platform. Provisioning additional computing resources
    just works automatically when the number of triggers becomes large. Deployed functions
    will autoscale to serve millions of requests without any further configuration
    from us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基础设施和系统软件层由 Google 的平台完全管理，因此我们只需关心我们的代码。自动扩展也是这种平台的常见特性。当触发次数增多时，额外的计算资源将自动进行配置。部署的函数将自动扩展以处理数百万次请求，而无需我们进一步的配置。
- en: The fine-grained concept of an FaaS function makes this kind of computing fit
    nicely to implement self-contained APIs and WebHooks (we will demonstrate this
    in later chapters). Google Cloud Functions supports many aspects of workloads,
    for example, data processing/ELT, WebHooks, implementing APIs, acting as a backend
    for mobile applications, and accepting streaming data from IoT devices.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS 函数的精细粒度概念使得这种计算非常适合实现自包含的 API 和 WebHooks（我们将在后续章节中演示）。Google Cloud Functions
    支持多种工作负载的方面，例如数据处理/ELT、WebHooks、实现 API、作为移动应用程序的后端，以及接收来自 IoT 设备的流数据。
- en: GCF supports many aspects of serverless computing. An obvious limitation at
    the moment is that it supports only Node.js as a programming language. GCF uses
    containers internally to wrap around the Node.js codes and deploy onto its internal
    orchestration FaaS system. A part of this engineering has been open sourced as
    a project called **distroless**. We can accomplish similar things with the concept
    of declarative containers, proposed in the final chapter. Using this concept allows
    us to deploy a workload containing only the application in the same way GCF does.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GCF支持无服务器计算的多个方面。目前显而易见的局限性是它仅支持Node.js作为编程语言。GCF在内部使用容器包装Node.js代码，并部署到其内部编排的FaaS系统上。这项工程的一部分已作为名为**distroless**的项目开源。我们可以通过提议的声明式容器的概念在最后一章中实现类似的功能。使用这个概念允许我们像GCF一样部署只包含应用程序的工作负载。
- en: All of these use cases allowed by GCF will be demonstrated with different approaches
    using Docker and FaaS platforms in a later chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些由GCF允许的用例将在后续章节中使用Docker和FaaS平台展示不同的方法。
- en: Execution model
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行模型
- en: Google takes care of everything for us, including the hardware level, the OS,
    networking, and the application runtimes. A function deployed there on the GCF
    will run in an automatically managed platform. Each cloud function will be executed
    separately in a container-based isolation, which is a secure execution context.
    Running independently, each function will not interfere with others while sharing
    the same host. This is the same concept used by Docker and other container implementations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Google为我们处理一切，包括硬件级别、操作系统、网络和应用程序运行时。在GCF上部署的函数将在一个自动管理的平台上运行。每个云函数将在基于容器的隔离环境中单独执行，这是一个安全的执行上下文。每个函数独立运行，不会干扰其他函数，同时共享同一主机。这与Docker和其他容器实现使用的概念相同。
- en: At the time of writing, Google Cloud Functions chooses to support only JavaScript
    running on Node.js v6.11.5; however, the document says that they will keep the
    version of Node.js updated by going closely with the **Long-Term Support** (**LTS**)
    releases, as quickly as possible. We can be confident that all patch versions
    for security and minor updates of the Node.js runtime will match the upstream
    releases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Google Cloud Functions选择仅支持运行在Node.js v6.11.5上的JavaScript；然而，文档称他们将通过尽快与**长期支持**（**LTS**）版本的发布保持Node.js版本的更新。我们可以确信，Node.js运行时的所有补丁版本和次要更新都将与上游发布匹配。
- en: 'As previously mentioned, a cloud function is also put into a container. In
    the case of Google Cloud Functions, its root filesystem is based on *Debian*.
    The base image of GCF is updated regularly and available as Docker images. It
    could be pulled from `gcr.io/google-appengine/nodejs`. Here''s the way the system
    prepares the base image by inheriting the image and installing Node.js version
    6.11.5 to it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，云函数也被放置在一个容器中。在谷歌云函数的情况下，其根文件系统基于*Debian*。 GCF的基础镜像定期更新，并作为Docker镜像提供。可以从`gcr.io/google-appengine/nodejs`拉取。以下是系统通过继承镜像并向其中安装Node.js版本6.11.5来准备基础镜像的方式：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Statelessness
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态性
- en: Stateless is the preferred model when writing a serverless FaaS function. Why?
    Because in the fully managed execution environment, which can be scaled up and
    down at anytime, we cannot expect our function state to be preserved. So it is
    best to not save anything to the function's local storage. If we need memory,
    such as global variables that may be shared across instances of the function,
    these variables must be managed explicitly by external storage services.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写无服务器FaaS函数时，无状态是首选模型。为什么？因为在完全托管的执行环境中，我们不能期望我们函数的状态被保留。因此最好不要将任何东西保存到函数的本地存储中。如果我们需要内存，例如可能跨函数实例共享的全局变量，这些变量必须由外部存储服务显式管理。
- en: In some situations, saying a function is completely stateless makes us underutilize
    the execution context of that function. As we already know, our function is actually
    running inside a container isolation. And it is completely fine for our function
    to write some things onto the local storage during execution, of course, without
    the expectation to share states outside this isolation. When saying *stateless*
    in the container's context, it is likely to be the *share-nothing* model rather
    than being *stateless*. The share-nothing model, is the better word to generally
    describe the statelessness of container-based FaaS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，说一个函数是完全无状态的，会让我们没有充分利用该函数的执行上下文。正如我们所知道的，函数实际上是在容器隔离中运行的。当然，函数在执行期间向本地存储写入一些数据是完全可以的，但不期望将状态共享到容器外部。当我们在容器的上下文中说“无状态”时，它很可能指的是“无共享”（*share-nothing*）模式，而不是“无状态”本身。无共享模型是更适合用来描述基于容器的
    FaaS 无状态性的术语。
- en: Timeout
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: In general, a serverless platform usually caps the execution time of a cloud
    function to prevent overuse of the platform's computing resources. For Google
    Cloud Functions, the default timeout is set to be 1 minute and can be extended
    to 9 minutes if the user prefers. When a function is timed out, its running codes
    are terminated. For example, if a function is scheduled to run at the 3 minutes
    after it starts, and if the timeout is set to be 2, that function will never run.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，无服务器平台通常会限制云函数的执行时间，以防止平台计算资源的过度使用。对于 Google Cloud Functions，默认的超时时间设为
    1 分钟，用户可以根据需要将其延长至 9 分钟。当函数超时，运行的代码会被终止。例如，如果一个函数被计划在启动后 3 分钟运行，而超时时间设置为 2 分钟，那么这个函数将永远不会运行。
- en: Execution guarantees
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行保证
- en: An error can occur anytime during the execution of a function. A function might
    not be executed only once if it failed. The model of execution depends on the
    type of function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数执行过程中，可能会发生错误。如果函数失败，它可能不会只执行一次。执行模型取决于函数的类型。
- en: For example, a simple synchronous HTTP request will be invoked once, at most.
    This means that the function invocation will be failed and never retried. The
    caller side is responsible for error handling and the retry strategy on its own.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的同步 HTTP 请求最多会被调用一次。这意味着函数调用将失败，并且不会重试。调用方需要自己处理错误和重试策略。
- en: While asynchronous functions will be invoked at least once, as is the nature
    of these asynchronous calls, so we need to prepare for a situation that this kind
    of function will be invoked multiple times. Also, the state to be modified by
    these functions should be idempotent and robust. For example, we may need to implement
    a state machine to control the states of the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异步函数至少会被调用一次，这是这些异步调用的特性，因此我们需要为该类型函数可能被多次调用的情况做好准备。此外，这些函数要修改的状态应该是幂等的且具备鲁棒性。例如，我们可能需要实现一个状态机来控制系统的状态。
- en: IBM Cloud Functions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM Cloud Functions
- en: IBM Cloud Functions is a service provided by IBM Cloud. It is powered by Apache
    OpenWhisk; actually, it's IBM who donated OpenWhisk to the Apache Foundation.
    We have a chapter dedicated to OpenWhisk later in this book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Cloud Functions 是 IBM Cloud 提供的一项服务，它由 Apache OpenWhisk 提供支持；实际上是 IBM 向
    Apache 基金会捐赠了 OpenWhisk。我们在本书后面有专门的章节介绍 OpenWhisk。
- en: The Cloud Functions service provided by IBM is, of course, very similar to other
    function services in terms of concepts. Functions wrap around the application
    business logic and run in the event-driven FaaS environment managed by IBM.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IBM 提供的 Cloud Functions 服务，在概念上与其他函数服务非常相似。函数围绕应用的业务逻辑进行封装，并在由 IBM 管理的事件驱动的
    FaaS 环境中运行。
- en: Functions are designed to respond to a direct HTTP invocation from other Web
    or mobile apps, or to events triggered by other supported systems, for example,
    Cloudant. IBM Cloud provides Cloudant, a commercially supported JSON data store
    built on top of CouchDB.  We can prepare a trigger in the Cloudant system, and
    let it fire events to invoke functions defined in the IBM Cloud Functions, when
    the data in Cloudant is changed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数旨在响应来自其他 Web 或移动应用的直接 HTTP 调用，或者响应由其他支持的系统触发的事件，例如 Cloudant。IBM Cloud 提供了
    Cloudant，这是一个建立在 CouchDB 之上的商业支持的 JSON 数据存储。我们可以在 Cloudant 系统中准备一个触发器，并在 Cloudant
    中的数据发生变化时触发事件来调用 IBM Cloud Functions 中定义的函数。
- en: The design goal of functions is generally the same among cloud providers. They
    provide a way for us developers to focus only on writing application business
    logic, then uploading codes to their cloud as cloud functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的设计目标在各云服务提供商之间通常是相同的。它们为我们开发者提供了一种方式，让我们只专注于编写应用的业务逻辑，然后将代码作为云函数上传到各自的云服务。
- en: To further explore the concepts behind OpenWhisk, the engine behind IBM Cloud,
    please feel free to jump to [Chapter 6](c78cb885-6836-493a-8fd9-d98e85bf40c4.xhtml),
    *OpenWhisk on Docker*, to learn more about OpenWhisk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索OpenWhisk背后的概念，该引擎是IBM Cloud的一部分，请随时跳转到[第六章](c78cb885-6836-493a-8fd9-d98e85bf40c4.xhtml)，*在Docker上运行OpenWhisk*，以了解更多关于OpenWhisk的信息。
- en: The Serverless Framework
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Serverless框架
- en: The Serverless Framework is an application development framework and tool for
    the serverless computing paradigm. The framework only shares the same name with
    serverless. Please do not be confused.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless框架是一个应用开发框架和工具，适用于无服务器计算模式。这个框架与无服务器并无直接关系，它们只是共享了相同的名字，请不要混淆。
- en: The authors of the Serverless Framework consider that a serverless application
    is the next evolution of application development in the cloud native ecosystem.
    And this kind of application needs a certain level of automation. This idea was
    the stem of the framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless框架的作者认为，无服务器应用是云原生生态系统中应用开发的下一个进化。这种应用需要一定程度的自动化，这一理念成为了框架的起源。
- en: The design idea views managed services and functions as coupled entities. To
    make an application around them, a tool should provide build, test, and deploy
    commands to make the whole development life cycle fully automated.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 设计理念将托管服务和函数视为紧密耦合的实体。为了围绕它们构建应用，工具应提供构建、测试和部署命令，以使整个开发生命周期实现完全自动化。
- en: 'There also should be a consistent way of building, testing, and deploying a
    serverless application to multiple cloud providers, while minimizing code changes.
    The framework should help configure the setting for each cloud provider based
    on the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还应有一种一致的方式来构建、测试和部署无服务器应用到多个云服务提供商，同时最小化代码变更。框架应该根据以下内容帮助配置每个云服务提供商的设置：
- en: The language runtime
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言运行时
- en: The cloud provider selected by the application developer
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由应用开发者选择的云服务提供商
- en: With this level of abstraction, the framework yields real advantages and lets
    developers focus on application business logic, rather than keep changing cloud
    configurations to match each provider.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种抽象层级，框架带来了实际的优势，使开发人员可以专注于应用的业务逻辑，而不是不断调整云配置以适应不同的云服务提供商。
- en: 'There are four benefits of the Serverless Framework described by its creators:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless框架的创始人描述了四个优点：
- en: The Serverless Framework helps speed up the development process because the
    framework contains CLI-based commands to create a project, build, and also helps
    to test applications from the same development environment. It saves time because
    the Serverless Framework is independent from any cloud providers. There is also
    a mechanism to deploy a new version to the cloud and allow rollback for the previous
    one, if it fails.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serverless框架有助于加速开发过程，因为该框架包含基于CLI的命令来创建项目、构建，并且还帮助在相同的开发环境中测试应用。它节省了时间，因为Serverless框架独立于任何云服务提供商。框架还有一个机制，可以将新版本部署到云端，并允许在失败时回滚到之前的版本。
- en: With the Serverless Framework, it allows us to develop codes independently to
    any cloud providers. So, the code with a good writing style would be migrated
    across the providers. For example, we can simply move our functions deployed as
    AWS Lambda by just changing the provider in the YAML file to Google Cloud and
    re-deploy again. But actually this is only a part of the whole problem. It is
    actually not the codes that could lock you to the vendor, it's the services provided
    by the vendor that make you stay with them. So choose the supported service wisely
    and this problem could be effectively solved.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Serverless框架，我们可以独立于任何云服务提供商开发代码。因此，具有良好编程风格的代码可以在不同的云服务提供商之间迁移。例如，我们可以通过简单地将YAML文件中的提供商从AWS
    Lambda切换为Google Cloud，然后重新部署，就能轻松迁移我们的函数。但实际上，这只是整个问题的一部分。真正让你绑定到某个供应商的不是代码，而是供应商提供的服务。因此，明智地选择支持的服务，可以有效解决这个问题。
- en: The Serverless Framework helps to enable **Infrastructure as Code** (**IaC**).
    With deployment that could be done via the set of APIs, we enable a certain level
    of automation. This makes us able to fully deploy the system as multi-cloud applications.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serverless Framework 帮助实现 **基础设施即代码** (**IaC**) 。通过可以通过一组 API 进行部署的方式，我们实现了一定程度的自动化。这使我们能够将系统完全部署为多云应用程序。
- en: Finally, the framework is widely used and has a very vibrant community. This
    is also an important key for choosing a tool. The framework extensions are actively
    developed by the community because of the base language, JavaScript on Node.js,
    that they chose for the framework. So, it is relatively easy to add a new provider
    to the framework. A notable community-based provider is Kubeless.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个框架被广泛使用，并且有一个非常活跃的社区。这也是选择工具时的一个重要因素。由于他们为框架选择了 JavaScript 和 Node.js 作为基础语言，社区积极开发框架扩展。因此，向框架中添加新的提供商相对容易。一个值得注意的社区支持的提供商是
    Kubeless。
- en: Exercise
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Let''s do some revision by trying to answer the questions without reviewing
    the contents:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过尝试回答问题来复习一下，而不回顾内容：
- en: How long is the time limitation for an AWS Lambda?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AWS Lambda 的时间限制是多久？
- en: Why do you think the cloud providers limit computational time for FaaS functions?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你为什么认为云提供商限制 FaaS 函数的计算时间？
- en: What are Azure's durable functions? Do they have any benefit?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Azure 的持久性函数？它们有什么好处？
- en: How can we test an AWS Lambda program just with Docker?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何仅使用 Docker 测试 AWS Lambda 程序？
- en: What's the engine behind IBM Cloud Functions? What do you think is the reason
    behind IBM open sourcing it?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IBM Cloud Functions 背后的引擎是什么？你认为 IBM 开源它背后的原因是什么？
- en: What is the Serverless Framework? Why is it important?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Serverless Framework？为什么它很重要？
- en: How could we make a FaaS function work across cloud providers? Do you think
    it is really possible?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使 FaaS 函数跨云提供商工作？你认为这真的可能吗？
- en: Please explain the difference between stateless and share-nothing models.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请解释无状态和“无共享”模型之间的区别。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this section, we have discussed four major serverless computing platforms,
    some of their characteristics and limitations. We have also discussed the Serverless
    Framework, a framework and tool designed to help build, test, and deploy applications
    to multiple serverless computing platforms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了四个主要的无服务器计算平台、它们的一些特性和局限性。我们还讨论了 Serverless Framework，这是一个旨在帮助构建、测试和部署应用程序到多个无服务器计算平台的框架和工具。
- en: In the next three chapters, we will see the truly different aspects of the serverless
    platforms provided by cloud providers and serverless/FaaS platforms that allow
    us to deploy them on our own with Docker technologies.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将看到云提供商提供的无服务器平台和允许我们使用 Docker 技术自行部署的无服务器/FaaS 平台的真正不同之处。
