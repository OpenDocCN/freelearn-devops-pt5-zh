- en: '*Chapter 2*'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 2 章*'
- en: Building Container Images
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: In this chapter, you will start building container images. We will look at five
    different ways you can define and build images using native Docker tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开始构建容器镜像。我们将介绍使用原生 Docker 工具定义和构建镜像的五种不同方式。
- en: We will discuss the recommended ways that you can define and build your own
    images, as well as one way that is not considered to be a best practice but does
    have its uses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论你可以用来定义和构建自己镜像的推荐方法，以及一种虽然不是最佳实践，但也有其用处的方法。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖以下主题：
- en: Introducing Dockerfiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Dockerfile
- en: Building Docker images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Let’s get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using our Docker installation to build images. Some
    of the supporting commands, which will be few and far between, may only be applicable
    to macOS and Linux-based operating systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Docker 安装来构建镜像。一些支持命令，虽然较少且间隔较远，可能仅适用于 macOS 和基于 Linux 的操作系统。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3h7oDX5](https://bit.ly/3h7oDX5)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，查看实际代码：[https://bit.ly/3h7oDX5](https://bit.ly/3h7oDX5)
- en: Tip
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: While the screenshots in this chapter will be from my preferred operating system,
    which is macOS, the Docker commands we will be running will work on all three
    operating systems we have installed Docker on so far.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章中的截图将来自我偏好的操作系统 macOS，但我们将运行的 Docker 命令将在我们已经安装 Docker 的所有三个操作系统上运行。
- en: Introducing Dockerfiles
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Dockerfile
- en: In this section, we will cover Dockerfiles in depth, along with the best practices
    when it comes to their use. So, what is a Dockerfile?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入讨论 Dockerfile，并介绍其使用中的最佳实践。那么，什么是 Dockerfile 呢？
- en: A `docker image build` command, which we will look at next, it is used to assemble
    a container image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image build` 命令，我们将接下来讨论，它用于组装容器镜像。'
- en: 'A Dockerfile looks as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Dockerfile 看起来如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, even with no explanation, it is quite easy to get an idea of
    what each step of the Dockerfile instructs the build command to do. Before we
    move on and work our way through the previous file, we should quickly touch upon
    Alpine Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使没有解释，也很容易理解 Dockerfile 中每个步骤指示构建命令做什么。在我们继续并逐步解析前面的文件之前，我们应该简要了解一下 Alpine
    Linux。
- en: '`grsecurity/PaX`, which is patched into its kernel. This port offers proactive
    protection against dozens of potential zero-day threats and other vulnerabilities.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`grsecurity/PaX`，它已经被补丁修复到内核中。这个版本提供了对多种潜在零日漏洞和其他漏洞的主动保护。'
- en: 'Alpine Linux, due to both its size and how powerful it is, has become the default
    image base for the official container images supplied by Docker. Because of this,
    we will be using it throughout this book. To give you an idea of just how small
    the official image for Alpine Linux is, let’s compare it to some of the other
    distributions available at the time of writing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其体积小巧且功能强大，Alpine Linux 已成为 Docker 官方容器镜像的默认基础镜像。因此，我们将在本书中使用它。为了让你了解官方的 Alpine
    Linux 镜像有多小，我们将其与写作时可用的其他一些发行版进行比较：
- en: '![Figure 2.1 – Comparing the size of popular base images'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 比较流行基础镜像的大小'
- en: '](img/image_00_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_001.jpg)'
- en: Figure 2.1 – Comparing the size of popular base images
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 比较流行基础镜像的大小
- en: As you can see from the preceding Terminal output, Alpine Linux weighs in at
    only 5.59 MB, as opposed to the biggest image, which is CentOS, at 237 MB. A bare-metal
    installation of Alpine Linux comes in at around 130 MB, which is still almost
    half the size of the CentOS container image.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的终端输出所示，Alpine Linux 仅重 5.59 MB，相比之下，最大的镜像 CentOS 重 237 MB。Alpine Linux 的裸机安装大约为
    130 MB，仍然几乎是 CentOS 容器镜像大小的一半。
- en: Reviewing Dockerfiles in depth
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入审查 Dockerfile
- en: 'Let’s take a look at the instructions we used in the preceding Dockerfile example.
    We will look at them in the order they appeared in:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们在前面的 Dockerfile 示例中使用的指令。我们将按照它们出现的顺序进行查看：
- en: '`FROM`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`'
- en: '`LABEL`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`'
- en: '`RUN`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`'
- en: '`COPY` and `ADD`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY` 和 `ADD`'
- en: '`EXPOSE`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`'
- en: '`ENTRYPOINT` and `CMD`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 和 `CMD`'
- en: Other Dockerfile instructions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 Dockerfile 指令
- en: FROM
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FROM
- en: The `FROM` instruction tells Docker which base you would like to use for your
    image. As we already mentioned, we are using Alpine Linux, so we simply have to
    state the name of the image and the release tag we wish to use. In our case, to
    use the latest official Alpine Linux image, we simply need to add `alpine:latest`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令告诉Docker你希望使用哪一个基础镜像。正如我们之前提到的，我们使用的是Alpine Linux，所以我们只需要声明镜像的名称以及我们希望使用的发布标签。在我们的例子中，要使用最新的官方Alpine
    Linux镜像，我们只需添加`alpine:latest`。'
- en: LABEL
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LABEL
- en: The `LABEL` instruction can be used to add extra information to the image. This
    information can be anything from a version number to a description. It’s also
    recommended that you limit the number of labels you use. A good label structure
    will help others who will use our image later on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`指令可以用来为镜像添加额外的信息。这些信息可以是版本号，也可以是描述。建议你限制使用标签的数量。一个良好的标签结构可以帮助以后使用我们镜像的其他人。'
- en: 'However, using too many labels can cause the image to become inefficient as
    well, so I would recommend using the label schema detailed at [http://label-schema.org](http://label-schema.org%20).
    You can view the containers’ labels with the following `docker inspect` command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用过多的标签也会导致镜像效率降低，因此我建议使用在[http://label-schema.org](http://label-schema.org%20)中详细介绍的标签结构。你可以通过以下`docker
    inspect`命令查看容器的标签：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can use the following command to filter just the labels:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令来仅过滤标签：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following screenshot, you can see the labels present for the CentOS
    image:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到CentOS镜像的标签：
- en: '![Figure 2.2 – Checking image label'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 检查镜像标签'
- en: '](img/image_00_002.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_002.jpg)'
- en: Figure 2.2 – Checking image label
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 检查镜像标签
- en: 'In our example Dockerfile, we have added two labels:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例Dockerfile中，我们添加了两个标签：
- en: '`maintainer=”Russ McKendrick <russ@mckendrick.io>”`: Adds a label that helps
    the end user of the image identify who is maintaining it.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`maintainer=”Russ McKendrick <russ@mckendrick.io>”`：添加一个标签，帮助镜像的最终用户识别谁在维护它。'
- en: '`description=”This example Dockerfile installs NGINX.”`: Adds a brief description
    of what the image is.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`description=”This example Dockerfile installs NGINX.”`：添加一个简短的描述，说明镜像的功能。'
- en: Generally, it is better to define your labels when you create a container from
    your image, rather than at build time, so it is best to keep labels down to just
    metadata about the image and nothing else.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，最好在你从镜像创建容器时再定义标签，而不是在构建时定义，所以最好将标签限制为仅关于镜像的元数据，其他内容不需要。
- en: RUN
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RUN
- en: 'The `RUN` instruction is where we interact with our image to install software
    and run scripts, commands, and other tasks. As you can see from the following
    `RUN` instruction, we are actually running three commands:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令是我们与镜像互动的地方，用来安装软件、运行脚本、命令和其他任务。正如下面的`RUN`指令所示，我们实际上运行了三条命令：'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first of our three commands is the equivalent of running the following
    command if we had a shell on an Alpine Linux host:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们三条命令中的第一条，相当于如果我们在Alpine Linux主机上有一个shell时运行以下命令：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command installs NGINX using Alpine Linux’s package manager.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用Alpine Linux的包管理器来安装NGINX。
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are using the `&&` operator to move on to the next command if the previous
    command was successful. This makes it more obvious which commands we are running
    in the Dockerfile. We are also using **\**, which allows us to split the command
    over multiple lines, making it even easier to read.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`&&`运算符，确保前一条命令成功执行后再执行下一条命令。这样能让我们在Dockerfile中更清晰地知道每一条命令的执行情况。我们还使用了**\**，允许我们将命令分割成多行，这使得命令更加易读。
- en: 'The following command in our chain removes any temporary files to keep the
    size of our image to a minimum:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链中的下一条命令删除了所有临时文件，以保持镜像的最小体积：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final command in our chain creates a folder with a path of `/tmp/nginx/`
    so that NGINX will start correctly when we run the container:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链中的最后一条命令会创建一个路径为`/tmp/nginx/`的文件夹，这样NGINX在我们运行容器时就能正确启动：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We could have also used the following in our Dockerfile to achieve the same
    results:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在我们的Dockerfile中使用以下内容来达到相同的效果：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, much like adding multiple labels, this is considered inefficient as
    it can add to the overall size of the image, which we should try to avoid. There
    are some valid use cases for this as some commands do not work well when they
    are stringed together using `&&`. However, for the most part, this approach to
    running commands should be avoided when your image is being built.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像添加多个标签一样，这被认为是低效的，因为它可能会增加镜像的整体大小，我们应该尽量避免这种情况。虽然有一些有效的使用场景，某些命令在通过`&&`连接时效果不好，但大部分情况下，在构建镜像时应该避免这种运行命令的方式。
- en: COPY and ADD
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COPY和ADD
- en: At first glance, `COPY` and `ADD` look like they are doing the same task in
    that they are both used to transfer files to the image. However, there are some
    important differences, which we will discuss here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，`COPY`和`ADD`似乎在执行相同的任务，都是用于将文件传输到镜像中。然而，它们之间存在一些重要的差异，我们将在这里讨论。
- en: 'The `COPY` instruction is the more straightforward of the two:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令是两者中更直接的一种：'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you have probably guessed, we are copying two files from the `files` folder
    on the host we are building our image on. The first file is `nginx.conf`, which
    is a minimal NGINX configuration file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，我们正在从我们构建镜像的主机上的`files`文件夹中复制两个文件。第一个文件是`nginx.conf`，这是一个最小化的NGINX配置文件：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will overwrite the NGINX configuration that was installed as part of the
    APK installation in the `RUN` instruction.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将覆盖在`RUN`指令中通过APK安装部分安装的NGINX配置。
- en: 'The next file, `default.conf`, is the simplest virtual host that we can configure,
    and contains the following content:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的文件`default.conf`是我们可以配置的最简单的虚拟主机，包含以下内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, this will overwrite any existing files. So far, so good! So, why might
    we use the `ADD` instruction?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这将覆盖任何现有的文件。到目前为止，一切都很好！那么，为什么我们会使用`ADD`指令呢？
- en: 'In our example Dockerfile, the `ADD` instruction looks as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例Dockerfile中，`ADD`指令如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we are adding a file called `html.tar.gz`, but we are not actually
    doing anything with the archive to uncompress it in our Dockerfile. This is because
    `ADD` automatically uploads, uncompresses, and adds the resulting folders and
    files to the path we request it to, which in our case is `/usr/share/nginx/`.
    This gives us our web root of `/usr/share/nginx/html/`, as we defined in the virtual
    host block in the `default.conf` file that we copied to the image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了一个名为`html.tar.gz`的文件，但实际上我们在Dockerfile中并没有对归档文件进行任何解压操作。这是因为`ADD`会自动上传、解压并将解压后的文件夹和文件添加到我们请求的路径中，在我们这个案例中是`/usr/share/nginx/`。这为我们提供了`/usr/share/nginx/html/`作为我们定义的Web根目录，该目录也在我们复制到镜像中的`default.conf`文件的虚拟主机块中进行了定义。
- en: 'The `ADD` instruction can also be used to add content from remote sources.
    For example, consider the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令也可以用来从远程源添加内容。例如，考虑以下内容：'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command line would download `html.tar.gz` from `https://raw.githubusercontent.com/PacktPublishing/Mastering-Docker-Fourth-Edition/master/chapter02/dockerfile-example/files/`
    and place the file in the `/usr/share/nginx/` folder on the image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令行会从`https://raw.githubusercontent.com/PacktPublishing/Mastering-Docker-Fourth-Edition/master/chapter02/dockerfile-example/files/`下载`html.tar.gz`并将文件放置在镜像中的`/usr/share/nginx/`文件夹中。
- en: Archive files from a remote source are treated as files and are not uncompressed,
    which you will have to take into account when using them. This means that the
    file will have to be added before the `RUN` instruction so that we can manually
    unarchive the folder and also remove the `html.tar.gz` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 来自远程源的归档文件被视为文件，并不会被解压，这一点在使用时需要考虑到。这意味着文件必须在`RUN`指令之前被添加，以便我们手动解压文件夹，并且还需要删除`html.tar.gz`文件。
- en: '`EXPOSE`: The `EXPOSE` instruction lets Docker know that when the image is
    executed, the port and protocol defined will be exposed at runtime. This instruction
    does not map the port to the host machine; instead, it opens the port to allow
    access to the service on the container network.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`：`EXPOSE`指令让Docker知道当镜像运行时，定义的端口和协议将在运行时暴露。这个指令不会将端口映射到主机机器，而是打开端口以允许对容器网络中的服务进行访问。'
- en: 'For example, in our Dockerfile, we are telling Docker to open port `80` every
    time the image runs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的Dockerfile中，我们告诉Docker每次运行镜像时都打开`80`端口：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The benefit of using `ENTRYPOINT` over `CMD` is that you can use them in conjunction
    with each other. `ENTRYPOINT` can be used by itself but remember that you would
    only want to use `ENTRYPOINT` by itself if you wanted your container to be executable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENTRYPOINT`而不是`CMD`的好处是，它们可以配合使用。`ENTRYPOINT`可以单独使用，但请记住，只有在你希望容器可执行时，才应单独使用`ENTRYPOINT`。
- en: For reference, if you think of some of the `CLI` commands you might use, you
    must specify more than just the `CLI` command. You might have to add extra parameters
    that you want the command to interpret. This would be the use case for using `ENTRYPOINT`
    only.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，如果你考虑一些可能使用的`CLI`命令，你必须指定的不仅仅是`CLI`命令。你可能还需要添加一些额外的参数，让命令进行解释。这就是仅使用`ENTRYPOINT`的使用场景。
- en: For example, if you want to have a default command that you want to execute
    inside a container, you could do something similar to the following example. Be
    sure to use a command that keeps the container alive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在容器内部执行一个默认命令，你可以像下面的示例一样做。请确保使用一个可以保持容器运行的命令。
- en: 'Here, we are using the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是以下内容：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What this means is that whenever we launch a container from our image, the
    NGINX binary is executed, which, as we have defined, is our entry point. Then,
    whatever we have as `CMD` is executed, giving us the equivalent of running the
    following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，每当我们从镜像启动容器时，NGINX 二进制文件就会执行，这正是我们定义的入口点。然后，我们定义的`CMD`将被执行，相当于运行以下命令：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another example of how `ENTRYPOINT` can be used is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`的另一个使用示例如下：'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This would be the equivalent of running the following command on our host:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在我们的主机上运行以下命令：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we didn’t have to tell Docker to use NGINX. Since we have the NGINX
    binary as our entry point, any command we pass overrides the `CMD` instruction
    that has been defined in the Dockerfile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们并不需要告诉 Docker 使用 NGINX。由于我们将 NGINX 二进制文件作为入口点，因此任何传递的命令都会覆盖在 Dockerfile
    中定义的`CMD`指令。
- en: This would display the version of NGINX we have installed and our container
    would stop, as the NGINX binary would only be executed to display the version
    information. We will look at this once we have built and launched a container
    using our image. Before we move on, we should look at some of the instructions
    that are not included in our Dockerfile.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示我们安装的 NGINX 版本，且容器会停止运行，因为 NGINX 二进制文件仅执行以显示版本信息。我们将在构建并启动容器后查看此效果。我们继续之前，应该先了解一下我们没有在
    Dockerfile 中包含的一些指令。
- en: Other Dockerfile instructions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 Dockerfile 指令
- en: 'There are some instructions that we have not included in our example Dockerfile.
    Let’s take a look at them here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例 Dockerfile 中没有包含一些指令。让我们在这里看看它们：
- en: '`USER`: The `USER` instruction lets you specify the username to be used when
    a command is run. The `USER` instruction can be used on the `RUN` instruction,
    the `CMD` instruction, or the `ENTRYPOINT` instruction in the Dockerfile. Also,
    the user defined in the `USER` instruction must exist, or your image will fail
    to build. Using the `USER` instruction can also introduce permission issues, not
    only on the container itself, but also if you mount volumes.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：`USER`指令让你指定在运行命令时使用的用户名。`USER`指令可以用于`RUN`、`CMD`或`ENTRYPOINT`指令中。此外，在`USER`指令中定义的用户必须存在，否则你的镜像构建将失败。使用`USER`指令还可能引入权限问题，不仅仅是容器本身，甚至在挂载卷时也会出现问题。'
- en: '`WORKDIR`: The `WORKDIR` instruction sets the working directory for the same
    set of instructions that the `USER` instruction can use (`RUN`, `CMD`, and `ENTRYPOINT`).
    It will allow you to use the `CMD` and `ADD` instructions as well.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：`WORKDIR`指令设置工作目录，用于`USER`指令可以使用的相同指令集（`RUN`、`CMD` 和 `ENTRYPOINT`）。它还允许你使用`CMD`和`ADD`指令。'
- en: '`ONBUILD`: The `ONBUILD` instruction lets you stash a set of commands to be
    used when the image is used in the future, as a base image for another container
    image. For example, if you want to give an image to developers and they all have
    a different code base that they want to test, you can use the `ONBUILD` instruction
    to lay the groundwork ahead of the fact of needing the actual code. Then, the
    developers will simply add their code to the directory you ask them to, and when
    they run a new Docker build command, it will add their code to the running image.The
    `ONBUILD` instruction can be used in conjunction with the `ADD` and `RUN` instructions,
    such as in the following example:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONBUILD`：`ONBUILD` 指令允许你将一组命令暂存起来，在将该镜像作为另一个容器镜像的基础镜像使用时执行。例如，如果你想将镜像提供给开发人员，并且他们都有不同的代码库需要测试，你可以使用
    `ONBUILD` 指令在需要实际代码之前先为其打好基础。然后，开发人员只需将他们的代码添加到你指定的目录，当他们运行新的 Docker 构建命令时，代码就会被添加到运行中的镜像中。`ONBUILD`
    指令可以与 `ADD` 和 `RUN` 指令结合使用，如以下示例所示：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would run an update and package upgrade every time our image is used as
    a base for another container image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每次我们的镜像作为基础镜像用于另一个容器镜像时，执行更新和软件包升级。
- en: '`ENV`: The `ENV` instruction sets ENVs within the image both when it is built
    and when it is executed. These variables can be overridden when you launch your
    image.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：`ENV` 指令在镜像构建和执行时设置环境变量。这些变量可以在启动镜像时被覆盖。'
- en: Dockerfiles – best practices
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile – 最佳实践
- en: 'Now that we have covered Dockerfile instructions, let’s take a look at a few
    tips that are considered best practices for writing our own Dockerfiles. Following
    these will ensure that your images are lean, consistent, and easy for others to
    follow:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Dockerfile 指令，让我们来看一下编写 Dockerfile 的一些最佳实践。遵循这些最佳实践可以确保你的镜像精简、一致，并且便于他人使用：
- en: You should try to get into the habit of using a `.dockerignore` file. We will
    cover the `.dockerignore` file in the *Building Docker images* section of this
    chapter; it will seem very familiar if you are used to using a `.gitignore` file.
    It will essentially ignore the items you specified in the file during the build
    process.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该养成使用 `.dockerignore` 文件的习惯。在本章的 *构建 Docker 镜像* 部分，我们将介绍 `.dockerignore` 文件；如果你已经习惯使用
    `.gitignore` 文件，它看起来会非常熟悉。它本质上会在构建过程中忽略你在文件中指定的项。
- en: Remember to only have one Dockerfile per folder to help you organize your containers.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得每个文件夹中只保留一个 Dockerfile，以帮助你组织容器。
- en: Use a version control system, such as Git, for your Dockerfile; just like any
    other text-based document, version control will help you move not only forward,
    but also backward, as necessary.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制系统，如 Git，来管理你的 Dockerfile；就像其他文本文件一样，版本控制将帮助你在必要时不仅向前推进，也能向后回溯。
- en: Minimize the number of packages you need to install per image. One of the biggest
    goals you want to achieve while building your images is to keep them as small
    and secure as possible. Not installing unnecessary packages will greatly help
    in achieving this goal.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化每个镜像中需要安装的包数量。构建镜像时你要实现的最大目标之一就是保持镜像尽可能小且安全。不安装不必要的包将大大帮助你实现这个目标。
- en: Make sure there is only one application process per container. Every time you
    need a new application process, it is good practice to use a new container to
    run that application in.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个容器只运行一个应用进程。每当你需要一个新的应用进程时，最好创建一个新的容器来运行该应用。
- en: Keep things simple; over-complicating your Dockerfile will add bloat and potentially
    cause you issues down the line.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简洁；过于复杂的 Dockerfile 会增加冗余，可能会在后期造成问题。
- en: Learn by example! Docker themselves have quite a detailed style guide for publishing
    the official images they host on Docker Hub. You can find a link to this in the
    *Further reading* section at the end of this chapter.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例学习！Docker 官方提供了一个非常详细的风格指南，用于发布他们在 Docker Hub 上托管的官方镜像。你可以在本章末尾的 *进一步阅读*
    部分找到该链接。
- en: Building Docker images
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: In this section, we will cover the `docker image build` command. This is where
    the rubber meets the road, as they say. It’s time for us to build the base upon
    which we will start building our future images. We will be looking at different
    ways to accomplish this goal. Consider this as a template that you may have created
    earlier with virtual machines. This will help save you time as this will complete
    the hard work for you; you will just have to create the application that needs
    to be added to the new images.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 `docker image build` 命令。正如人们所说，这就是实现目标的关键时刻。现在是我们构建基础的时刻，未来我们将基于此开始构建我们的镜像。我们将查看完成这个目标的不同方法。可以将其视为你之前使用虚拟机创建的模板。这将帮助你节省时间，因为它会为你完成繁重的工作；你只需创建需要添加到新镜像中的应用程序。
- en: 'There are a lot of switches that you can use while using the `docker build`
    command. So, let’s use the one that is always handy. Here, we will use the `--help`
    switch on the `docker image build` command to view what we can do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `docker build` 命令时，你可以使用许多开关。所以，让我们使用一个总是方便的开关。在这里，我们将使用 `docker image build`
    命令的 `--help` 开关来查看我们可以做什么：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a lot of different flags listed that you can pass when building your
    image. Now, it may seem like a lot to digest, but out of all these options, we
    only need to use `--tag`, or its shorthand, `-t`, to name our image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，你可以传递很多不同的标志。现在，虽然看起来有很多内容需要消化，但在所有这些选项中，我们只需要使用 `--tag` 或其简写 `-t` 来命名我们的镜像。
- en: You can use the other options to limit how much CPU and memory the build process
    will use. In some cases, you may not want the `build` command to take as much
    CPU or memory as it can have. The process may run a little slower, but if you
    are running it on your local machine or a production server and it’s a long build
    process, you may want to set a limit. There are also options that affect the network
    configuration of the container that was launched to build our image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其他选项来限制构建过程中 CPU 和内存的使用量。在某些情况下，你可能不希望 `build` 命令占用尽可能多的 CPU 或内存。这个过程可能会稍微慢一些，但如果你在本地机器或生产服务器上运行它，并且这是一个长时间的构建过程，你可能想要设置一个限制。还有一些选项会影响为构建镜像而启动的容器的网络配置。
- en: Typically, you don’t use the `--file` or `-f` switch since you run the `docker
    build` command from the same folder that the Dockerfile is in. Keeping the Dockerfile
    in separate folders helps sort the files and keeps the naming convention of the
    files the same.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要使用 `--file` 或 `-f` 开关，因为你会在与 Dockerfile 相同的文件夹中运行 `docker build` 命令。将
    Dockerfile 保存在单独的文件夹中有助于整理文件，并保持文件命名的一致性。
- en: It’s also worth mentioning that, while you are able to pass additional ENVs
    as arguments at build time, they are used at build time and your container image
    does not inherit them. This is useful for passing information such as proxy settings,
    which may only be applicable to your initial build/test environment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，虽然你可以在构建时将额外的环境变量（ENVs）作为参数传递，但它们仅在构建时使用，你的容器镜像不会继承它们。这对于传递诸如代理设置等信息非常有用，这些设置可能只适用于你的初始构建/测试环境。
- en: The `.dockerignore` file, as we discussed earlier, is used to exclude those
    files or folders we don’t want to be included in the Docker build since, by default,
    all the files in the same folder as the Dockerfile will be uploaded. We also discussed
    placing the Dockerfile in a separate folder, and the same applies to `.dockerignore`.
    It should go in the folder where the Dockerfile was placed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore` 文件，正如我们之前讨论的，用于排除那些我们不希望包含在 Docker 构建中的文件或文件夹，因为默认情况下，和 Dockerfile
    同一文件夹中的所有文件都会被上传。我们还讨论了将 Dockerfile 放在一个单独的文件夹中的做法，同样的做法也适用于 `.dockerignore` 文件。它应该放在与
    Dockerfile 相同的位置。'
- en: Keeping all the items you want to use in an image in the same folder will help
    you keep the number of items, if any, in the `.dockerignore` file to a minimum.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将你想要在镜像中使用的所有项目保存在同一个文件夹中，有助于将 `.dockerignore` 文件中的项目数量保持到最小。
- en: Since we have spent the last few sections of this chapter looking at Dockerfiles,
    let’s start building images using the example file we have covered here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章的最后几节已经讨论了 Dockerfile，接下来让我们使用我们在这里讨论的示例文件来开始构建镜像。
- en: Using a Dockerfile
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dockerfile
- en: The first method that we are going to look at for building our base container
    images is creating a Dockerfile. In fact, we will be using the Dockerfile from
    the previous section and then executing a `docker image build` command against
    it to get ourselves an NGINX image.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一种构建基础容器镜像的方法是创建一个 Dockerfile。事实上，我们将使用上一节的 Dockerfile，然后执行 `docker
    image build` 命令来获取一个 NGINX 镜像。
- en: 'So, let’s start off by looking at the Dockerfile once more:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们再次查看 Dockerfile：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Don’t forget that you will also need the `default.conf`, `html.tar.gz`, and
    `nginx.conf` files in the `files` folder. You can find these in the accompanying
    GitHub repository.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了你还需要 `default.conf`、`html.tar.gz` 和 `nginx.conf` 文件，这些文件位于 `files` 文件夹中。你可以在附带的
    GitHub 仓库中找到这些文件。
- en: 'So, there are two ways we can go about building our image. The first way would
    be by specifying the `--file` switch when we use the `docker image build` command.
    We will also utilize the `--tag` switch to give the new image a unique name:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以通过两种方式构建我们的镜像。第一种方式是通过在使用 `docker image build` 命令时指定 `--file` 开关。我们还将使用
    `--tag` 开关为新镜像指定一个唯一名称：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, `<REPOSITORY>` is typically the username you sign up for on Docker Hub.
    We will look at this in more detail in [*Chapter 3*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109),
    *Storing and Distributing Images*, but for now, we will be using `local`. `<TAG>`
    is a unique value that allows you to identify a container. Typically, this will
    be a version number or an other descriptor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`<REPOSITORY>` 通常是你在 Docker Hub 上注册的用户名。我们将在 [*第 3 章*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109)中详细讨论
    *存储和分发镜像*，但现在我们将使用 `local`。`<TAG>` 是一个唯一值，允许你识别一个容器。通常，这将是一个版本号或其他描述符。
- en: 'As we have a file called Dockerfile, we can also skip using the `--file` switch.
    This is the second way of building an image. The following is the code for this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个名为 Dockerfile 的文件，我们也可以跳过使用 `--file` 开关。这是构建镜像的第二种方式。以下是代码：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The most important thing to remember is the dot (or period) at the very end.
    This is to tell the `docker image build` command to build in the current folder.
    When you build your image, you should see something similar to the following Terminal
    output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要记住最后的点（或句号）。这是告诉 `docker image build` 命令在当前文件夹中构建镜像。当你构建镜像时，你应该会看到类似以下的终端输出：
- en: '![Figure 2.3 – Building an image from our Dockerfile'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 从我们的 Dockerfile 构建镜像'
- en: '](img/image_00_003.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_003.jpg)'
- en: Figure 2.3 – Building an image from our Dockerfile
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 从我们的 Dockerfile 构建镜像
- en: 'Once it’s built, you should be able to run the following command to check whether
    the image is available, as well as the size of your image:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，你应该能够运行以下命令来检查镜像是否可用，以及镜像的大小：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see from the following Terminal output, my image size is 7.15 MB:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下终端输出中可以看到，我的镜像大小是 7.15 MB：
- en: '![Figure 2.4 – Checking the size of the container image'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 检查容器镜像的大小'
- en: '](img/image_00_004.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_004.jpg)'
- en: Figure 2.4 – Checking the size of the container image
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 检查容器镜像的大小
- en: 'You can launch a container with your newly built image by running this command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来启动一个带有新构建镜像的容器：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will launch a container called `dockerfile-example`. You can check whether
    it is running by using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个名为 `dockerfile-example` 的容器。你可以通过以下命令检查它是否正在运行：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Opening your browser and going to `http://localhost:8080/` should show you
    an extremely simple web page that looks as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 `http://localhost:8080/` 应该会显示一个非常简单的网页，页面内容如下：
- en: '![Figure 2.5 – Checking the container in the browser'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 在浏览器中检查容器'
- en: '](img/image_00_005.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_005.jpg)'
- en: Figure 2.5 – Checking the container in the browser
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 在浏览器中检查容器
- en: 'Next up, we will quickly run a few of the commands we covered in the *Introducing
    Dockerfiles* section of this chapter, starting with the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将快速运行一些我们在本章的 *介绍 Dockerfiles* 部分中讲解过的命令，首先是以下命令：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see from the following Terminal output, we are currently running
    NGINX version 1.16.1:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下终端输出中可以看到，我们当前运行的是 NGINX 版本 1.16.1：
- en: '![Figure 2.6 – Checking the version of NGINX'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – 检查 NGINX 版本'
- en: '](img/image_00_006.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_006.jpg)'
- en: Figure 2.6 – Checking the version of NGINX
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 检查 NGINX 版本
- en: The next command we will look at running displays the labels that we embedded
    at build time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要运行的下一个命令会显示我们在构建时嵌入的标签。
- en: 'To view this information, run the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此信息，运行以下命令：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see from the following output, this displays the information we
    entered:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中，你可以看到我们输入的信息：
- en: '![Figure 2.7 – Checking the labels of our newly built image'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 检查我们新构建镜像的标签'
- en: '](img/image_00_007.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_007.jpg)'
- en: Figure 2.7 – Checking the labels of our newly built image
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 检查我们新构建镜像的标签
- en: 'Before we move on, you can stop and remove the containers we launched with
    the following commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你可以使用以下命令停止并删除我们启动的容器：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will go into more detail about Docker container commands in [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133),
    *Managing Containers*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)，*管理容器*中详细讨论Docker容器命令。
- en: Using an existing container
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有容器
- en: The easiest way to build a base image is to start off by using one of the official
    images from Docker Hub. Docker also keeps the Dockerfile for these official builds
    in their GitHub repositories. So, there are at least two choices you have for
    using existing images that others have already created. By using the Dockerfile,
    you can see exactly what is included in the build and add what you need. You can
    then version control that Dockerfile if you want to change or share it later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基础镜像的最简单方法是首先使用Docker Hub上的官方镜像之一。Docker还将这些官方构建的Dockerfile保存在它们的GitHub仓库中。因此，你至少有两种选择可以使用别人已经创建的现有镜像。通过使用Dockerfile，你可以清楚地看到构建中包含了哪些内容，并添加你需要的内容。如果你想稍后修改或共享，你还可以对Dockerfile进行版本控制。
- en: There is another way to achieve this; however, it is not recommended or considered
    to be good practice, and I would strongly discourage you from using it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以实现这一目标；然而，这种方法不推荐使用，也不被认为是良好的实践，我强烈不建议你使用它。
- en: Tip
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: I would only use this method during a prototyping phase to check that the commands
    you are running work as expected in an interactive shell before putting them in
    a Dockerfile. You should always use a Dockerfile.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会在原型阶段使用这种方法，检查你运行的命令是否在交互式shell中按预期工作，然后再将它们放入Dockerfile中。你应该始终使用Dockerfile。
- en: 'First, we should download the image we want to use as our base; as we did previously,
    we will be using Alpine Linux:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该下载我们想要作为基础使用的镜像；正如我们之前所做的，我们将使用Alpine Linux：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to run a container in the foreground so that we can interact
    with it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在前台运行一个容器，以便与之交互：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once the container runs, you can add the packages as necessary using the `apk`
    command, or whatever the package management commands are for your Linux flavor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器运行，你可以根据需要使用`apk`命令，或根据你的Linux版本使用相应的包管理命令来添加包。
- en: 'For example, the following commands would install NGINX:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令将安装NGINX：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After you have installed the packages you require, you need to save the container.
    The `exit` command at the end of the preceding set of commands will stop the running
    container since the shell process we are detaching ourselves from just happens
    to be the process keeping the container running in the foreground.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完你需要的包后，你需要保存容器。前面一组命令中的`exit`命令将停止正在运行的容器，因为我们要脱离的shell进程恰好是保持容器在前台运行的进程。
- en: 'You can see this in the following Terminal output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下终端输出中看到这个：
- en: '![Figure 2.8 – Checking the Terminal output'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 检查终端输出'
- en: '](img/image_00_008.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_008.jpg)'
- en: Figure 2.8 – Checking the Terminal output
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 检查终端输出
- en: Tip
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is at this point that you should really stop; I do not recommend that you
    use the preceding commands to create and distribute images, apart from the one
    use case we will discuss in a moment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这个时候，你应该真正停止；除了我们稍后讨论的一个使用案例外，我不建议你使用前面的命令来创建和分发镜像。
- en: 'So, to save our stopped container as an image, you need to do something similar
    to the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了将我们停止的容器保存为镜像，你需要执行类似以下的操作：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For example, I ran the following command to save a copy of the container we
    launched and customized:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我运行了以下命令来保存我们启动并定制的容器副本：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Noticed how I called my image `broken-container`? Since one of the use cases
    for taking this approach is that if, for some reason, you have a problem with
    a container, then it is extremely useful to save the failed container as an image,
    or even export it as a `TAR` file to share with others if you need some assistance
    in getting to the root of the problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我将我的镜像命名为`broken-container`了吗？因为采取这种方法的一个使用场景是，如果由于某种原因，你的容器出现问题，那么将失败的容器保存为镜像，甚至将其导出为`TAR`文件，以便与他人共享，帮助你找出问题的根本原因，这非常有用。
- en: 'To save the image file, simply run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存镜像文件，只需运行以下命令：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, for our example, I ran the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我们的示例中，我运行了以下命令：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This gave me a 7.9 MB file called `broken-container.tar`. Since we have this
    file, we can uncompress it and have a look around. It will have the following
    structure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我一个7.9 MB的文件，名为`broken-container.tar`。既然我们有了这个文件，我们可以解压它并查看其结构。它将具有以下结构：
- en: '![Figure 2.9 – Collection of JSON files, folders, and TAR files'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – JSON文件、文件夹和TAR文件的集合'
- en: '](img/image_00_009.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_009.jpg)'
- en: Figure 2.9 – Collection of JSON files, folders, and TAR files
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – JSON文件、文件夹和TAR文件的集合
- en: The image is made up of a collection of JSON files, folders, and other TAR files.
    All the images follow this structure, so you may be thinking to yourself, **why
    is this method so bad?**
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像由一组JSON文件、文件夹和其他TAR文件组成。所有镜像都遵循这种结构，所以你可能会在想，**为什么这种方法如此糟糕？**
- en: The biggest reason is trust (as we’ve already mentioned). Your end user will
    not be able to easily see what is in the image they are running. Would you randomly
    download a prepackaged image from an unknown source to run your workload, without
    checking how the image was built? Who knows how it was configured and what packages
    have been installed!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的原因是信任（正如我们之前提到的）。你的最终用户将无法轻松地查看他们正在运行的镜像中包含什么内容。你会从一个未知来源随机下载一个预打包的镜像来运行你的工作负载，而不检查该镜像是如何构建的吗？谁知道它是如何配置的，以及安装了哪些软件包！
- en: With a Dockerfile, you can see exactly what was executed to create the image,
    but with the method described here, you have zero visibility of this.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dockerfile，你可以清楚地看到创建镜像时执行了哪些操作，但按照这里描述的方法，你根本无法看到这些内容。
- en: Another reason is that it is difficult for you to build in a good set of defaults.
    For example, if you were to build your image this way, then you would not really
    be able to take advantage of features such as `ENTRYPOINT` and `CMD`, or even
    the most basic instructions, such as `EXPOSE`. Instead, the user would have to
    define everything required while running their `docker container run` command.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是很难为你构建一套良好的默认设置。例如，如果你按这种方式构建镜像，那么你将无法真正利用诸如`ENTRYPOINT`和`CMD`这样的功能，甚至是最基本的指令，比如`EXPOSE`。相反，用户在运行`docker
    container run`命令时必须定义所有所需的内容。
- en: In the early days of Docker, distributing images that had been prepared in this
    way was common practice. In fact, I was guilty of it myself since, coming from
    an operations background, it made perfect sense to launch a **machine**, bootstrap
    it, and then create a gold master. Luckily, over the last few years, Docker has
    extended the build functionality to the point where this option is not even considered
    anymore.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker的早期，将以这种方式准备的镜像进行分发是常见做法。事实上，我自己也犯过这个错误，因为我来自运维背景，启动一个**机器**，引导它，然后创建一个金牌主镜像，这在当时是非常有意义的。幸运的是，过去几年，Docker扩展了构建功能，现在这种选项已经不再被考虑了。
- en: Using scratch as a base
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scratch作为基础
- en: So far, we have been using prepared images from Docker Hub as our base images.
    However, it is best to avoid this altogether (sort of) and roll out your own images
    from scratch.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用来自Docker Hub的准备好镜像作为我们的基础镜像。然而，最好完全避免这种做法（有点），而是从头开始构建自己的镜像。
- en: Now, when you usually hear the phrase from scratch, it literally means that
    you start from nothing. That’s what we have here – you get absolutely nothing
    and have to build upon it. Now, this can be a benefit because it will keep the
    image size very small, but it can also be detrimental if you are fairly new to
    Docker as it can get complicated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你通常听到“从零开始”这个短语时，它的字面意思是你从无开始。我们现在就是这种情况——你得到的完全是什么都没有，必须在此基础上构建。这可能是一个好处，因为它会保持镜像文件非常小，但如果你对Docker比较陌生，这可能会变得很复杂。
- en: Docker has done some of the hard work for us already and created an empty `TAR`
    file on Docker Hub named `scratch`; you can use it in the `FROM` section of your
    Dockerfile. You can base your entire Docker build on this, and then add parts
    as needed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Docker已经为我们做了一些艰苦的工作，并在Docker Hub上创建了一个名为`scratch`的空`TAR`文件；你可以在Dockerfile的`FROM`部分使用它。你可以以此为基础进行整个Docker构建，然后根据需要添加各个部分。
- en: Again, we’ll be using Alpine Linux as our base operating system for the image.
    The reasons for doing this include not only the fact that it is distributed as
    an ISO, Docker image, and various virtual machine images, but also that the entire
    operating system is available as a compressed `TAR` file. You can find the download
    in this book’s GitHub repository, or on the Alpine Linux download page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我们将使用Alpine Linux作为镜像的基础操作系统。这样做的原因不仅是它作为ISO、Docker镜像和各种虚拟机镜像发布，而且整个操作系统都可以作为压缩的`TAR`文件提供。你可以在本书的GitHub仓库中找到下载，或者在Alpine
    Linux的下载页面找到。
- en: To download a copy, just select the appropriate download from the downloads
    page, which can be found at [https://www.alpinelinux.org/downloads/](https://www.alpinelinux.org/downloads/).
    The one I used was `x86_64` from the **MINI ROOT FILESYSTEM** section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 若要下载副本，只需从下载页面选择合适的下载，下载页面地址为[https://www.alpinelinux.org/downloads/](https://www.alpinelinux.org/downloads/)。我使用的是**MINI
    ROOT FILESYSTEM**部分的`x86_64`版本。
- en: 'Once it’s finished downloaded, you need to create a Dockerfile that uses `scratch`
    and then add the `tar.gz` file, making sure to use the correct file, as shown
    in the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载完成，你需要创建一个使用`scratch`的Dockerfile，然后添加`tar.gz`文件，确保使用正确的文件，如下所示：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You might be thinking, why did I just download the `alpine-minirootfs-3.11.3-x86_64.tar.gz`
    file? Could I have not had used `http://dl-cdn.alpinelinux.org/alpine/v3.11/releases/x86_64/alpine-minirootfs-3.11.3-x86_64.tar.gz`
    instead?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想，为什么我刚刚下载了`alpine-minirootfs-3.11.3-x86_64.tar.gz`文件？难道我不应该使用`http://dl-cdn.alpinelinux.org/alpine/v3.11/releases/x86_64/alpine-minirootfs-3.11.3-x86_64.tar.gz`吗？
- en: Remember, remote archives are treated as files and are just downloaded. Normally,
    that wouldn’t be a problem as we could just add a `RUN` command to uncompress
    the file, but since we are using `scratch`, an operating system hasn’t been installed,
    which means that there are no commands available for `RUN` to be able to execute
    anything.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，远程归档文件被视为文件并只是被下载。通常，这不是问题，因为我们可以通过添加一个`RUN`命令来解压文件，但由于我们使用的是`scratch`，操作系统尚未安装，这意味着没有可供`RUN`执行任何操作的命令。
- en: 'Now that we have our Dockerfile, we can build our image as we would have done
    on any other Docker image – by running the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Dockerfile，我们可以像构建任何其他Docker镜像一样构建我们的镜像——通过运行以下命令：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should give you the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你以下输出：
- en: '![Figure 2.10 – Building from scratch'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – 从零开始构建'
- en: '](img/image_00_010.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_010.jpg)'
- en: Figure 2.10 – Building from scratch
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 从零开始构建
- en: 'You can compare the image size to the other container images we have built
    by running the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令，将我们构建的镜像大小与其他容器镜像进行对比：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see in the following screenshot, the image I built is exactly the
    same size as the Alpine Linux image we have been using from Docker Hub:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我构建的镜像与我们一直在Docker Hub上使用的Alpine Linux镜像大小完全相同：
- en: '![Figure 2.11 – Reviewing the image sizes'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11 – 审查镜像大小'
- en: '](img/image_00_011.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_011.jpg)'
- en: Figure 2.11 – Reviewing the image sizes
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 审查镜像大小
- en: 'Now that our own image has been built, we can test it by running this command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们自己的镜像已经构建完成，我们可以通过运行以下命令来测试它：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you get an error, then you may already have a container called `alpine-test`
    created or running. Remove it by running `docker container stop alpine-test`,
    followed by `docker container rm alpine-test`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到错误，可能已经有一个名为`alpine-test`的容器正在运行或已创建。通过运行`docker container stop alpine-test`，然后运行`docker
    container rm alpine-test`来删除它。
- en: 'This should launch us into a shell on the Alpine Linux image. You can check
    this by running the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会让我们进入Alpine Linux镜像的Shell。你可以通过运行以下命令来检查：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will display information on the release the container is running. To get
    an idea of what this entire process looks like, see the following Terminal output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示容器运行的版本信息。为了了解整个过程的样子，请参见以下终端输出：
- en: '![Figure 2.12 – Running the image from scratch'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12 – 从零开始运行镜像'
- en: '](img/image_00_012.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_012.jpg)'
- en: Figure 2.12 – Running the image from scratch
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 从零开始运行镜像
- en: While everything appears straightforward, this is only thanks to the way Alpine
    Linux packages their operating system. It can start to get more complicated when
    you choose to use other distributions who package their operating systems in a
    different way.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一切看起来很简单，但这仅仅是因为 Alpine Linux 以其独特的方式打包操作系统。当你选择使用其他以不同方式打包操作系统的发行版时，情况可能会变得更加复杂。
- en: There are several tools that can be used to generate a bundle of an operating
    system. We are not going to go into any details regarding how to use any of these
    tools here because, if you must consider this approach, you probably have some
    pretty specific requirements. You can check the list of tools in the *Further
    reading* section at the end of this chapter for more details.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以用来生成操作系统的捆绑包。我们在这里不会详细讨论如何使用这些工具，因为如果你需要考虑这种方法，你可能有一些非常具体的要求。你可以在本章末尾的*进一步阅读*部分查看工具的列表，了解更多细节。
- en: So, what could those requirements be? For most people, it will be legacy applications;
    for example, what happens if you have an application that requires an operating
    system that is no longer supported or available from Docker Hub, but you need
    a more modern platform to support the application? Well, you should be able to
    spin your image and install the application there, thus allowing you to host your
    old legacy application on a modern, supportable operating system/architecture.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些要求可能是什么呢？对大多数人来说，它们是遗留应用程序；例如，如果你有一个要求操作系统的应用程序，而这个操作系统不再受支持或无法从 Docker
    Hub 获取，但你需要一个更现代的平台来支持这个应用程序，那么会发生什么呢？好吧，你应该能够构建自己的镜像并在那里安装应用程序，从而使你能够在现代且可支持的操作系统/架构上托管你的旧遗留应用程序。
- en: Using ENVs
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ENVs
- en: In this section, we will cover a very powerful set of variables known as **ENVs**
    (**ENVs**), as you will be seeing a lot of them. You can use ENVs for a lot of
    things in your Dockerfile. If you are familiar with coding, these will probably
    be familiar to you.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一组非常强大的变量，称为 **ENVs** (**ENVs**)，因为你将会看到它们很多。你可以在 Dockerfile 中使用 ENVs
    做很多事情。如果你熟悉编程，它们可能对你来说并不陌生。
- en: For others like myself, at first, they seemed intimidating, but don’t get discouraged.
    They will become a great resource once you get the hang of them. They can be used
    to set information when running the container, which means that you don’t have
    to go and update lots of the commands in your Dockerfile or in the scripts that
    you run on the server.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我这样的人，起初，它们看起来令人畏惧，但不要气馁。一旦你掌握了它们，它们将成为一个很好的资源。它们可以在运行容器时设置信息，这意味着你不必更新 Dockerfile
    中的很多命令或你在服务器上运行的脚本。
- en: 'To use ENVs in your Dockerfile, you can use the `ENV` instruction. The structure
    of the `ENV` instruction is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Dockerfile 中使用 ENVs，你可以使用 `ENV` 指令。`ENV` 指令的结构如下：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, you can always place an equals sign between the key and the
    value:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以在键和值之间放置等号：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, the question is, why are there two ways that you can define them, and what
    are the differences?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是，为什么有两种定义它们的方式，它们之间有什么区别？
- en: With the first example, you can only set one ENV per line; however, it is easy
    to read and follow.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个示例中，你每行只能设置一个 ENV；然而，它易于阅读和跟随。
- en: 'With the second ENV example, you can set multiple environmental variables on
    the same line, as shown here:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个 ENV 示例中，你可以在同一行上设置多个环境变量，如下所示：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can view which ENVs are set on an image using the `docker inspect` command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `docker inspect` 命令查看在镜像中设置了哪些 ENVs：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now that we know how they need to be set in our Dockerfile, let’s take a look
    at them in action. So far, we have been using a Dockerfile to build a simple image
    with just NGINX installed. Now, let’s look at building something a little more
    dynamic.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在 Dockerfile 中设置它们了，让我们来看看它们的实际应用。到目前为止，我们一直在使用 Dockerfile 构建一个只安装了
    NGINX 的简单镜像。现在，让我们来看看如何构建一些更具动态性的内容。
- en: 'Using Alpine Linux, we will do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Alpine Linux，我们将执行以下操作：
- en: Set an ENV to define which version of PHP we would like to install.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个 ENV 来定义我们希望安装的 PHP 版本。
- en: Install Apache2 and our chosen PHP version.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Apache2 和我们选择的 PHP 版本。
- en: Set up the image so that Apache2 starts without issues.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置镜像，使 Apache2 能够正常启动。
- en: Remove the default `index.html` file and add an `index.php` file that displays
    the results of the `phpinfo` command.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除默认的 `index.html` 文件，并添加一个 `index.php` 文件，显示 `phpinfo` 命令的结果。
- en: Expose port 80 on the container.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器上暴露端口 80。
- en: 'Set Apache so that it is the default process:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Apache，使其成为默认进程：
- en: Information
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: Please note that PHP5 is no longer supported. Because of that, we are having
    to use an older version of Alpine Linux, 3.8, as that is the last version that
    supports the PHP5 packages.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，PHP5已经不再受到支持。因此，我们不得不使用较旧版本的Alpine Linux（3.8），因为这是最后一个支持PHP5包的版本。
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, we have chosen to install PHP7; we can build the image by running
    the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们选择了安装PHP7；我们可以通过运行以下命令构建镜像：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice how we have changed the command slightly. This time, we are calling
    the `local/apache-php` image and tagging the version as `7`. The full output that
    we obtained by running the preceding command is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们稍微修改了命令。这次，我们调用的是`local/apache-php`镜像，并将版本标记为`7`。通过运行之前的命令得到的完整输出如下：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see from the preceding output, the `PHPVERSION` ENV has been set
    to the number `7`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看到，`PHPVERSION` ENV已经设置为数字`7`：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So far, we have only referred to the ENV. As shown by the following output,
    the necessary `php7` packages will start to be installed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只提到过ENV。如下所示，必要的`php7`包将开始安装：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that all the packages have been installed, the build can do some housekeeping
    and then complete:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有包已安装，构建可以进行一些清理工作，然后完成：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can check whether everything ran as expected by running the following command
    to launch a container using the image:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来检查是否一切按预期运行，启动一个使用该镜像的容器：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once it’s launched, open a browser and go to `http://localhost:8080/`. You
    should see a page showing that PHP7 is being used:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，打开浏览器并访问`http://localhost:8080/`。你应该看到一页显示正在使用PHP7：
- en: '![Figure 2.13 – Checking the PHP version'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13 – 检查PHP版本'
- en: '](img/image_00_013.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_013.jpg)'
- en: Figure 2.13 – Checking the PHP version
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 检查PHP版本
- en: Tip
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t be confused by the next part; there is no PHP6\. You can find out more
    about this at the following RFC and the results of the vote for skipping PHP6
    at https://wiki.php.net/rfc/php6.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被接下来的部分搞混了；没有PHP6。你可以通过以下RFC和关于跳过PHP6投票的结果了解更多，网址是 https://wiki.php.net/rfc/php6。
- en: 'Now, in your Dockerfile, change `PHPVERSION` from `7` to `5` and then run the
    following command to build a new image:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的Dockerfile中，将`PHPVERSION`从`7`改为`5`，然后运行以下命令构建一个新的镜像：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see from the following Terminal output, the majority of the output
    is the same, apart from the packages that are being installed:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下终端输出可以看到，大部分输出是相同的，除了正在安装的包：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we can see that `5` has been set as the value of the `PHPVERSION` ENV.
    From here, the build will continue just like the previous build did:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`5`已被设置为`PHPVERSION` ENV的值。从这里开始，构建将像之前一样继续：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is where the PHP5 packages are installed. This is the only difference
    between our two builds:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是安装PHP5包的地方。这是我们两个构建之间唯一的区别：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Again, now that the packages have been installed, the build will progress as
    it did previously until we have our complete image:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，既然包已经安装，构建将像之前一样继续，直到我们得到完整的镜像：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can launch a container, this time on port 9090, by running the following
    command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令启动一个容器，这次使用9090端口：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Opening your browser again, but this time going to `http://localhost:9090/`,
    should show that we are running PHP5:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开浏览器，但这次访问`http://localhost:9090/`，应该会显示我们正在运行PHP5：
- en: '![Figure 2.14 – Running PHP5'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14 – 运行PHP5'
- en: '](img/image_00_014.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_014.jpg)'
- en: Figure 2.14 – Running PHP5
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 运行PHP5
- en: 'Finally, you can compare the size of the images by running this command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过运行以下命令来比较镜像的大小：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see the following Terminal output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下终端输出：
- en: '![Figure 2.15 – Comparing the image sizes'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15 – 比较镜像大小'
- en: '](img/image_00_015.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_015.jpg)'
- en: Figure 2.15 – Comparing the image sizes
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 比较镜像大小
- en: This shows that the PHP7 image is a lot smaller than the PHP5 one. Let’s discuss
    what actually happened when we built the two different container images.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示PHP7镜像比PHP5镜像要小得多。我们来讨论一下在构建这两个不同的容器镜像时到底发生了什么。
- en: So, what happened? Well, when Docker launched the Alpine Linux image to create
    our image, the first thing it did was set the ENVs we defined, making them available
    to all the shells within the container.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么呢？实际上，当Docker启动Alpine Linux镜像以创建我们的镜像时，首先做的就是设置我们定义的ENVs，使其对容器内的所有shell可用。
- en: 'Luckily for us, the naming scheme for PHP in Alpine Linux simply substitutes
    the version number and maintains the same name for the packages we need to install,
    meaning that we run the following command:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Alpine Linux 中 PHP 的命名方案只需替换版本号，并保持我们需要安装的包名不变，这意味着我们运行以下命令：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But it is actually interpreted as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但它实际上会被解释为以下内容：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For PHP5, it is interpreted as the following instead:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PHP5，它会被解释为以下内容：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This means that we do not have to go through the whole Dockerfile, manually
    substituting version numbers. This approach is especially useful when installing
    packages from remote URLs, such as software release pages.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不需要逐个查看整个 Dockerfile，手动替换版本号。这种方法在从远程 URL 安装软件包时尤其有用，比如软件发布页面。
- en: 'What follows is a more advanced example: a Dockerfile that installs and configures
    Consul by *HashiCorp*. In this Dockerfile, we are using ENVs to define the version
    numbers and the SHA256 hash of the file we downloaded:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更高级的示例：一个安装和配置由 *HashiCorp* 提供的 Consul 的 Dockerfile。在这个 Dockerfile 中，我们使用环境变量（ENVs）来定义版本号和我们下载的文件的
    SHA256 哈希值：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, Dockerfiles can get quite complex, and using ENVs can help with
    maintenance. Whenever a new version of Consul is released, I simply need to update
    the `ENV` line and commit it to GitHub, which will trigger a new image being built.
    Well – it would have done if we had configured it to do so. We will look at this
    in the next chapter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Dockerfile 可能会变得非常复杂，使用环境变量（ENVs）有助于维护。每当 Consul 发布新版本时，我只需更新 `ENV` 行并提交到
    GitHub，这会触发构建一个新镜像。如果我们配置好了，它本应如此。我们将在下一章中查看这一点。
- en: You might have also noticed we are using an instruction within the Dockerfile
    that we have not covered here. Don’t worry – we will look at the `VOLUME` instruction
    in [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133), *Managing Containers*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在 Dockerfile 中使用了一个我们尚未讨论过的指令。别担心——我们将在[*第 4 章*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)，*管理容器*
    中查看 `VOLUME` 指令。
- en: Using multi-stage builds
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多阶段构建
- en: In this section, which is the final part of our journey into using Dockerfiles
    and building container images, we will look at using a relatively new method for
    building an image. In the previous sections, we looked at adding binaries directly
    to our images either via a package manager, such as Alpine Linux’s APK, or, in
    the previous example, by downloading a precompiled binary from the software vendor.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，作为我们使用 Dockerfile 和构建容器镜像旅程的最后一部分，我们将研究一种相对较新的构建镜像的方法。在之前的章节中，我们介绍了通过包管理器（如
    Alpine Linux 的 APK）直接将二进制文件添加到镜像中，或者在之前的示例中，通过从软件供应商下载预编译的二进制文件。
- en: 'What if we wanted to compile our own software as part of the build? Historically,
    we would have had to use a container image containing a full build environment,
    which can be very big. This means that we probably would have had to cobble together
    a script that ran through something like the following process:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在构建过程中编译自己的软件呢？历史上，我们不得不使用一个包含完整构建环境的容器镜像，这可能非常大。这意味着我们很可能需要拼凑出一个脚本，按照类似以下的流程运行：
- en: Download the build environment container image and start a `build` container.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载构建环境容器镜像并启动一个 `build` 容器。
- en: Copy the source code to the `build` container.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码复制到 `build` 容器中。
- en: Compile the source code on the `build` container.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build` 容器上编译源代码。
- en: Copy the compiled binary outside of the `build` container.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译后的二进制文件从 `build` 容器中复制到外部。
- en: Remove the `build` container.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `build` 容器。
- en: Use a pre-written Dockerfile to build an image and copy the binary to it.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用预编写的 Dockerfile 来构建一个镜像，并将二进制文件复制到其中。
- en: That is a lot of logic – in an ideal world, it should be part of Docker. Luckily,
    the Docker community thought so, and the functionality to achieve this, called
    a multi-stage build, was introduced in Docker 17.05.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多逻辑——在理想的世界里，它应该是 Docker 的一部分。幸运的是，Docker 社区也这么认为，名为多阶段构建的功能在 Docker 17.05
    中被引入。
- en: 'The Dockerfile contains two different build stages:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 包含两个不同的构建阶段：
- en: 'The first, named `builder`, uses the official Go container image from Docker
    Hub. Here, we are installing a prerequisite, downloading the source code directly
    from GitHub, and then compiling it into a static binary:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个阶段，名为 `builder`，使用的是 Docker Hub 上的官方 Go 容器镜像。在这里，我们安装了一个先决条件，从 GitHub 直接下载源代码，然后将其编译成静态二进制文件：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Tip
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Notice here we are using `ADD` with a URL since we want to download an uncompressed
    version of the source code rather than a zipped archive.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们使用`ADD`与一个URL，因为我们想下载源代码的未压缩版本，而不是一个压缩的存档。
- en: As our static binary has a built-in web server, we do not really need anything
    else to be present from an operating system point of view. Because of this, we
    are able to use `scratch` as the base image, meaning that all our image will contain
    is the static binary that we have copied from the builder image, and won’t contain
    any of the `builder` environment at all.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的静态二进制文件具有内置的 Web 服务器，从操作系统的角度来看，我们实际上不需要任何其他东西。因此，我们能够将`scratch`用作基础镜像，这意味着我们的整个镜像只包含我们从构建镜像复制的静态二进制文件，并且完全不包含任何`builder`环境。
- en: 'To build the image, we just need to run the following command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，我们只需要运行以下命令：
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output of the preceding command can be found in the following code block.
    The interesting bits happen between *steps 5* and *6*:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可在以下代码块中找到。有趣的部分发生在*步骤 5*和*步骤 6*之间：
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that the build environment container image has been pulled, we can prepare
    the environment to build our code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经拉取了构建环境容器镜像，我们可以准备环境来构建我们的代码：
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With the environment prepared, we can download the source code from GitHub
    and compile it:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 环境准备就绪后，我们可以从GitHub下载源代码并进行编译：
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We now have our compiled code as a single executable binary, which means that
    we can create a new build image using `scratch` and copy the binary from the previous
    build image across to the new build image:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将我们的编译代码作为单个可执行二进制文件，这意味着我们可以使用`scratch`创建一个新的构建镜像，并将二进制文件从先前的构建镜像复制到新的构建镜像中：
- en: '[PRE68]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As you can see, our binary has been compiled and the container that contains
    the build environment has been removed, leaving us with an image storing our binary.
    If you were to run the following command, you would get an idea of why it is a
    good idea not to ship an application with its build environment intact:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的二进制文件已经被编译，并且包含构建环境的容器已被删除，留下了存储我们二进制文件的镜像。如果您运行以下命令，您将了解为什么不将应用程序与其构建环境一起发布是一个好主意：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following output shows that the `golang` image is `809MB`; with our source
    code and prerequisites added, the size increases to `862MB`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示，`golang`镜像大小为`809MB`；加上我们的源代码和先决条件后，大小增加到`862MB`：
- en: '![Figure 2.16 – Checking the image sizes'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16 – 检查图像大小'
- en: '](img/image_00_016.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_016.jpg)'
- en: Figure 2.16 – Checking the image sizes
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 检查图像大小
- en: However, the final image is just `7.41MB`. I am sure you will agree that this
    is quite a dramatic amount of space that’s been saved. It also adheres to the
    best practices by only having content relevant to our application shipped within
    the image, as well as being really, really small.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但最终的镜像大小仅为`7.41MB`。我相信您会同意这节省了相当多的空间。它还遵循最佳实践，只将与我们应用程序相关的内容包含在内，并且非常非常小。
- en: 'You can test the application by launching a container with the following command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用以下命令启动一个容器来测试应用程序：
- en: '[PRE70]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The application is accessible over a browser and simply increments a counter
    each time the page is loaded. To test it on macOS and Linux, you can use the `curl`
    command, as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可通过浏览器访问，并在每次加载页面时简单地递增计数器。要在 macOS 和 Linux 上测试它，您可以使用`curl`命令，如下所示：
- en: '[PRE71]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This should give you something like the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给您类似以下的结果：
- en: '![Figure 2.17 – Running the container and calling the page using curl'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.17 – 运行容器并使用curl调用页面'
- en: '](img/image_00_017.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_017.jpg)'
- en: Figure 2.17 – Running the container and calling the page using curl
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 运行容器并使用curl调用页面
- en: 'Windows users can simply visit `http://localhost:8000/` in a browser. To stop
    and remove the running container, use the following commands:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户只需在浏览器中访问`http://localhost:8000/`。要停止并删除运行中的容器，请使用以下命令：
- en: '[PRE72]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, using a multi-stage build is a relatively simple process and
    is in keeping with the instructions that should already be starting to feel familiar
    to you.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用多阶段构建是一个相对简单的过程，并且符合您应该已经开始感到熟悉的指令。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at Dockerfiles, which I am sure you will agree are
    a straightforward way of defining you own Docker images.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了Dockerfiles，我相信您会同意它们是定义您自己的Docker镜像的一种简单直接的方式。
- en: Once we finished our in-depth look at Dockerfiles, we then looked at five ways
    in which we can build your images. We started by looking at **using a Dockerfile**
    as this is the most common way you will be building your images and we will be
    using it throughout the rest of this book.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入探讨完 Dockerfile 后，我们接着看了构建镜像的五种方法。我们首先了解了**使用 Dockerfile**，因为这是构建镜像最常见的方式，并且我们将在本书的其余部分中使用它。
- en: Then we discussed **using an existing container** as when Docker first came
    on the scene, this was the way most people originally built their images. It is
    no longer considered a best practice and should only ever be used if you need
    to create a snapshot of a running or crashed container for debug purposes.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了**使用现有容器**，因为在 Docker 刚出现时，这就是大多数人构建镜像的方式。现在它不再被视为最佳实践，只有在你需要为调试目的创建一个正在运行或崩溃容器的快照时，才应该使用。
- en: Next up we talked about **using scratch as a base.** This is probably the most
    streamlined way of creating an image as you are literally starting from zero.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论了**使用 scratch 作为基础**。这可能是创建镜像的最简化方式，因为你实际上是从零开始。
- en: We moved onto discussing **using environmental variables**. Here, we looked
    at the ways we can start to introduce variables such as version numbers into our
    Dockerfile in a way that means we don’t have to update the file in several places.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着讨论了**使用环境变量**。在这里，我们查看了如何将版本号等变量引入 Dockerfile，这样我们就不需要在多个地方更新文件。
- en: Finally, we covered `scratch` container, giving us the smallest usable images
    possible.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了`scratch`容器，提供了可能最小的可用镜像。
- en: In the next chapter, now that we know how to build images using Dockerfiles,
    we will be taking a look at Docker Hub and all of the advantages that using a
    registry service brings.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，现在我们知道如何使用 Dockerfile 构建镜像，我们将深入了解 Docker Hub 以及使用注册表服务的所有优点。
- en: We will also look at the Docker registry, which is open source, so that you
    can create and configure your own place to store images, as well as third-party
    hosted registry services, all of which can be used to distribute you own container
    images.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解 Docker 注册表，它是开源的，这样你就可以创建和配置自己的存储镜像的地方，以及第三方托管的注册表服务，所有这些都可以用来分发你自己的容器镜像。
- en: Questions
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True or false: the `LABEL` instruction tags your image once it has been built.'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：`LABEL`指令在镜像构建完成后标记你的镜像。
- en: What’s the difference between the `ENTRYPOINT` and `CMD` instructions?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`和`CMD`指令有什么区别？'
- en: 'True or false: when using the `ADD` instruction, you can’t download and automatically
    uncompress an externally hosted archive.'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：使用`ADD`指令时，不能下载并自动解压外部托管的压缩包。
- en: What is a valid use for using an existing container as the base of your image?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用现有容器作为镜像基础的有效用途是什么？
- en: What does the `EXPOSE` instruction expose?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令暴露什么？'
- en: Further reading
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can find the guidelines for the official Docker container images at [https://github.com/docker-library/official-images/](https://github.com/docker-library/official-images/).
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Docker 容器镜像的指南可以在[https://github.com/docker-library/official-images/](https://github.com/docker-library/official-images/)找到。
- en: 'Some of the tools to help you create containers from existing installations
    are as follows:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些帮助你从现有安装创建容器的工具如下：
- en: 'debootstrap: [https://wiki.debian.org/Debootstrap](https://wiki.debian.org/Debootstrap)'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: debootstrap：[https://wiki.debian.org/Debootstrap](https://wiki.debian.org/Debootstrap)
- en: 'yumbootstrap: [http://dozzie.jarowit.net/trac/wiki/yumbootstrap](http://dozzie.jarowit.net/trac/wiki/yumbootstrap)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yumbootstrap：[http://dozzie.jarowit.net/trac/wiki/yumbootstrap](http://dozzie.jarowit.net/trac/wiki/yumbootstrap)
- en: 'rinse: [https://packages.debian.org/sid/admin/rinse](https://packages.debian.org/sid/admin/rinse)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rinse：[https://packages.debian.org/sid/admin/rinse](https://packages.debian.org/sid/admin/rinse)
- en: 'Docker contrib scripts: [https://github.com/moby/moby/tree/master/contrib](https://github.com/moby/moby/tree/master/contrib)'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Docker contrib 脚本：[https://github.com/moby/moby/tree/master/contrib](https://github.com/moby/moby/tree/master/contrib)
- en: The full GitHub repository for the Go HTTP Hello World application can be found
    at [https://github.com/geetarista/go-http-hello-world](https://github.com/geetarista/go-http-hello-world).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go HTTP Hello World 应用的完整 GitHub 仓库可以在[https://github.com/geetarista/go-http-hello-world](https://github.com/geetarista/go-http-hello-world)找到。
