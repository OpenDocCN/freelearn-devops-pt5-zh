- en: Docker and Swarm Clusters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 和 Swarm 集群
- en: 'In this chapter, we will review container technology and introduce Docker and
    its orchestration engine, as well as Docker Swarm mode. We will then discuss why
    we need a Docker infrastructure to deploy and run serverless and FaaS applications.
    The topics covered in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将回顾容器技术，并介绍 Docker 及其编排引擎，以及 Docker Swarm 模式。然后，我们将讨论为什么需要 Docker 基础设施来部署和运行无服务器（serverless）和函数即服务（FaaS）应用。
    本章涵盖的主题如下：
- en: Containers and Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器与 Docker
- en: Setting up a Docker Swarm cluster
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Docker Swarm 集群
- en: Performing container networking with Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 执行容器网络操作
- en: Why Docker fits into the serverless and FaaS infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Docker 适合无服务器和 FaaS 基础设施
- en: What is a container?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Before talking about Docker, it would be better to discuss the technology behind
    the software container.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 Docker 之前，最好先了解一下软件容器背后的技术。
- en: 'Virtual machines are a common virtualization technology and have been widely
    adopted by cloud providers and enterprise companies. Actually, a software container
    (or container for short) is also a kind of virtualization technology, but there
    is something different about them. The key difference is that every container
    shares the same kernel on the host machine, while each virtual machine has its
    own kernel. Basically, a container uses virtualization techniques at the level
    of the operating system, not the *hypervisor*. The following diagram shows a comparison
    between container and VM stacks:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是一种常见的虚拟化技术，并已被云服务提供商和企业广泛采用。实际上，软件容器（简称容器）也是一种虚拟化技术，但它们与虚拟机有所不同。关键的区别在于每个容器共享主机机器的内核，而每个虚拟机都有自己独立的内核。基本上，容器在操作系统级别使用虚拟化技术，而不是*虚拟机监控程序*。下图展示了容器和虚拟机堆栈的比较：
- en: '![](img/bc35c9d4-51bf-44b9-8e41-6e1635c6142b.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc35c9d4-51bf-44b9-8e41-6e1635c6142b.png)'
- en: 'Figure 2.1: Containers versus virtual machines'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：容器与虚拟机的对比
- en: 'Linux''s container technology heavily relies on two important kernel capabilities,
    **namespace** and **cgroups**. Namespace puts a process into isolation so it has
    its own of set of global resources, such as PIDs and networks. Cgroups or control
    groups provide a mechanism for metering and limiting resources, such as CPU usage,
    memory, block I/O, and network bandwidth:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的容器技术依赖于两个重要的内核功能，**命名空间**和**控制组**（cgroups）。命名空间将一个进程隔离，使其拥有自己的一组全局资源，如进程
    ID（PID）和网络。控制组或控制组提供了一种计量和限制资源的机制，如 CPU 使用率、内存、块 I/O 和网络带宽：
- en: '![](img/ba561123-d240-45cd-9872-c528f52bd817.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba561123-d240-45cd-9872-c528f52bd817.png)'
- en: 'Figure 2.2: Linux capabilities—namespaces and cgroups used by a container'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：Linux 能力—容器使用的命名空间和控制组
- en: The core engine that uses the **namespaces** and **cgroups** capabilities of
    Linux is called **runC**. It is a tool for spawning and running containers in
    the **Open Container Initiative** (**OCI**) format. Docker plays a major role
    in drafting this spec, so the Docker container image is compatible with OCI specifications
    and therefore runnable by runC. The Docker Engine itself uses *runC* underneath
    to start each container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 的**命名空间**和**控制组**（cgroups）功能的核心引擎叫做**runC**。它是一个用于启动和运行容器的工具，采用**开放容器倡议**（**OCI**）格式。Docker
    在起草这个规范中起了重要作用，因此 Docker 容器镜像与 OCI 规范兼容，因此可以通过 runC 运行。Docker 引擎本身在底层使用*runC*来启动每个容器。
- en: What is Docker?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Docker？
- en: Containers in the past were quite difficult to manage and use. Docker is basically
    a set of technologies to help us prepare, manage, and execute containers. In the
    world of virtual machines, we need a hypervisor to take care of all VM instances.
    Similarly, in the world of containers, we use Docker as the *container engine* to
    take care of everything to do with containers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，容器的管理和使用相当困难。Docker 基本上是一套帮助我们准备、管理和执行容器的技术。在虚拟机的世界里，我们需要一个虚拟机监控程序（hypervisor）来处理所有虚拟机实例。类似地，在容器的世界里，我们使用
    Docker 作为*容器引擎*来处理与容器相关的一切事务。
- en: 'Undeniably, Docker is the most popular container engine to date. When using
    Docker, we follow the three concepts build, ship, and run, recommended by Docker
    itself:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，Docker 是目前最流行的容器引擎。使用 Docker 时，我们遵循 Docker 本身推荐的三个概念：构建（build）、运输（ship）和运行（run）。
- en: The workflow of **Build**-**Ship**-**Run** is optimized by the philosophy of
    Docker. In the **Build** step, we are allowed to build and destroy container images
    rapidly. As developers, we can include the container building steps as a part
    of our development cycle.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Build**-**Ship**-**Run**的工作流程是由Docker的理念优化的。在**Build**步骤中，我们可以快速构建和销毁容器镜像。作为开发者，我们可以将容器构建步骤作为我们开发周期的一部分。'
- en: In the **Ship** step, we ship container images to places, from our development
    laptops to the QA servers and to the staging servers. We send the container images
    to be stored in the public hub or to our private registry hub inside our company.
    Ultimately, we send our container images to run in the production environment.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Ship**步骤中，我们将容器镜像运送到不同的地方，从开发笔记本到QA服务器，再到预生产服务器。我们将容器镜像发送到公共集线器存储，或者存储到我们公司内部的私有注册中心。最终，我们将容器镜像送到生产环境中运行。
- en: 'In the **Run** step, Docker helps us prepare the production environment with
    Swarm clusters. We start containers from the container images. We may schedule
    containers to run at a specific part of the cluster with a certain set of constraints.
    We manage a container''s life cycle using Docker commands:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Run**步骤中，Docker帮助我们使用Swarm集群准备生产环境。我们从容器镜像启动容器。我们可以调度容器在集群中的特定部分运行，并设置一些特定约束。我们使用Docker命令管理容器的生命周期：
- en: '![](img/415de6bb-86cd-47ac-893e-8972cd6a4187.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/415de6bb-86cd-47ac-893e-8972cd6a4187.png)'
- en: 'Figure 2.3: Build-ship-run'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Build-ship-run
- en: Installing Docker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'Before we follow the build-ship-run steps, we need to install Docker on our
    machine. On Linux, we use the classic installation method, **Docker Community
    Edition** (**CE** or **Docker-CE**):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建-运送-运行步骤之前，我们需要在机器上安装Docker。在Linux上，我们使用经典的安装方法，**Docker社区版**（**CE**或**Docker-CE**）：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Throughout the book, we will use a Debian or Ubuntu machine to demonstrate
    Docker. On a Debian/Ubuntu machine, we will get the most stable version of Docker
    (at the time of writing) via `apt-get` Docker back to version 17.06.2\. If we
    already have a newer version of Docker, such as 17.12 or 18.03, it will be downgraded
    to 17.06.2:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们将使用Debian或Ubuntu机器来演示Docker。在Debian/Ubuntu机器上，我们将通过`apt-get`获取Docker的最稳定版本（截至写作时），并将其降级到版本17.06.2。如果我们已经有了更新版本的Docker，例如17.12或18.03，它将被降级到17.06.2：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For macOS and Windows systems, we can download Docker from the Docker website:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS和Windows系统，我们可以从Docker官网下载安装Docker：
- en: Docker for Mac: [https://www.docker.com/docker-mac](https://www.docker.com/docker-mac)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker for Mac: [https://www.docker.com/docker-mac](https://www.docker.com/docker-mac)
- en: Docker for Windows: [https://www.docker.com/docker-windows](https://www.docker.com/docker-windows)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker for Windows: [https://www.docker.com/docker-windows](https://www.docker.com/docker-windows)
- en: 'To check the installed version of Docker, we can use the `docker version` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查已安装的Docker版本，我们可以使用`docker version`命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The information printed out from the `docker version` is separated into two
    sections, client and server. The client section tells us information about the
    `docker` binary used to issue commands. The server section tells us the version
    of `dockerd`, the Docker Engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker version`打印出来的信息分为客户端和服务器两个部分。客户端部分告诉我们关于`docker`二进制文件的信息，用于发出命令。服务器部分则告诉我们`dockerd`（Docker引擎）的版本。'
- en: What we can see from the previous snippet is that both client and server are
    of version 17.06.2-ce*,* the second update of the stable 17.06 Community Edition.
    The server allows Docker client 1.12 as the minimum version to connect to. The *API
    version* tells us that `dockerd` implements remote API version 1.30.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中我们可以看到，客户端和服务器的版本都是17.06.2-ce*，即稳定版17.06 Community Edition的第二次更新。服务器允许最低版本为1.12的Docker客户端进行连接。*API版本*告诉我们，`dockerd`实现了远程API版本1.30。
- en: If we expect to use the next stable version of Docker, we should go for the
    upcoming 17.06.3, 17.09.x, or 17.12.x versions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预计将使用下一个稳定版本的Docker，我们应该选择即将发布的17.06.3、17.09.x或17.12.x版本。
- en: Building a container image
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: We use Docker to prepare our software and its execution environment by packing
    them onto a file system. We call this step building a container image. OK, let's
    do this. We will build our own version of an NGINX server on Ubuntu, `my-nginx`,
    as a Docker image. Please note that the terms container image and Docker image
    will be used interchangeably throughout this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Docker准备软件及其执行环境，将它们打包到文件系统中。我们称这个步骤为构建容器镜像。好了，让我们开始吧。我们将在Ubuntu上构建我们自己的NGINX服务器版本`my-nginx`，作为Docker镜像。请注意，容器镜像和Docker镜像在本书中会互换使用。
- en: 'We create a directory called `my-nginx` and change to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`my-nginx`的目录并切换到该目录：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we create a file named Dockerfile with the following content:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为Dockerfile的文件，内容如下：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will explain the contents of Dockerfile line by line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行解释Dockerfile的内容：
- en: First, it says that we want to use the image named `ubuntu` as our base image.
    This `ubuntu` image is stored on the Docker Hub, a central image registry server
    hosted by Docker Inc.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它表示我们希望使用名为`ubuntu`的镜像作为我们的基础镜像。这个`ubuntu`镜像存储在Docker Hub上，这是一个由Docker Inc.托管的中央镜像注册服务器。
- en: Second, it says that we want to install NGINX and related packages using the
    `apt-get` command. The trick here is that `ubuntu` is a plain Ubuntu image without
    any package information, so we need to run `apt-get update` before installing
    packages.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它表示我们希望使用`apt-get`命令安装NGINX和相关的软件包。这里的技巧是，`ubuntu`是一个普通的Ubuntu镜像，没有任何软件包信息，因此我们需要在安装软件包之前运行`apt-get
    update`。
- en: Third, we want this image to open port `80`, *inside the container*, for our
    NGINX server.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们希望这个镜像为我们的NGINX服务器在*容器内*打开端口`80`。
- en: Finally, when we start a container from this image, Docker will run the `nginx
    -g daemon off;` command inside the container for us.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当我们从这个镜像启动一个容器时，Docker将在容器内部为我们运行`nginx -g daemon off;`命令。
- en: 'We are now ready to build our first Docker image. Type the following command
    to start building an image. Please note that there is *dot* at the end of the
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好构建我们的第一个Docker镜像。输入以下命令来开始构建镜像。请注意，命令的末尾有一个*点*：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will now see something similar to the following output with different hash
    numbers, so don't worry. Steps 2 to 4 will take a couple of minutes to finish,
    as it will download and install NGINX packages into the image filesystem. Just
    make sure that there are four steps and it ends with the message `Successfully
    tagged my-nginx:latest`*:*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到类似以下内容的输出，输出中会有不同的哈希值，所以不用担心。步骤2到4会花费几分钟时间完成，因为它会将NGINX软件包下载并安装到镜像文件系统中。只需确保有四个步骤，并且最后以`Successfully
    tagged my-nginx:latest`的消息结尾*：*
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now have a Docker image called `my-nginx:latest` locally on our machine.
    We can check that the image is really there using the `docker image ls` command
    (or `docker images` for the old-style, top-level command):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在本地计算机上拥有一个名为`my-nginx:latest`的Docker镜像。我们可以使用`docker image ls`命令（或者使用旧版命令`docker
    images`）来检查该镜像是否真的存在：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Basically, this is the *build* concept of Docker. Next, we continue with shipping
    images.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这就是Docker的*构建*概念。接下来，我们继续讨论镜像发布。
- en: Shipping an image
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像发布
- en: 'We usually ship Docker images via a Docker registry. The public registry hosted
    by Docker Inc. is called **Docker Hub**. To ship a Docker image to a registry,
    we use the `docker push` command. When we start a container, its image will be
    automatically checked and downloaded to the host before running. The process of
    downloading can be explicitly done using the `docker pull` command. The following
    diagram illustrates the push/pull behavior among different environments and registries:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过Docker注册表发布Docker镜像。由Docker Inc.托管的公共注册表称为**Docker Hub**。要将Docker镜像发布到注册表中，我们使用`docker
    push`命令。当我们启动一个容器时，它的镜像会在运行之前自动检查并下载到主机上。下载过程可以通过`docker pull`命令显式完成。下图展示了不同环境和注册表之间的推送/拉取行为：
- en: '![](img/307800e2-0f55-48a1-832e-0af3bdae7871.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/307800e2-0f55-48a1-832e-0af3bdae7871.png)'
- en: 'Figure 2.4: Push and pull image workflow'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：镜像推送和拉取工作流
- en: In the previous diagram, developers pull images from the Docker public registry
    (Docker Hub) then push and pull images from their own Docker private registry.
    In the development environment, each environment will be triggered by a mechanism
    to pull images there and run them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，开发人员从Docker公共注册表（Docker Hub）拉取镜像，然后从他们自己的Docker私有注册表推送和拉取镜像。在开发环境中，每个环境会通过某种机制来触发拉取镜像并运行它们。
- en: To check that our Docker daemon is allowed to interact with a Docker registry
    insecurely over the non-encrypted HTTP, we do `docker info` then `grep` for the
    `Registries` keyword.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们的Docker守护进程是否允许通过非加密的HTTP与Docker注册表进行不安全的交互，我们可以执行`docker info`，然后用`grep`查找`Registries`关键字。
- en: Please note that the insecure Docker registry is not recommended for a production
    environment. You have been warned!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不建议在生产环境中使用不安全的Docker注册表。已经提醒过你了！
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: OK, seeing `127.0.0.0/8` means that we are allowed to do so. We will have a
    local Docker registry running at `127.0.0.1:5000`. Let's set it up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看到`127.0.0.0/8`表示我们被允许这么做。我们将会在`127.0.0.1:5000`上运行一个本地的Docker注册表。让我们来设置它。
- en: 'To have a local Docker registry running, just run it from the Docker registry
    V2 image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动本地Docker注册表，只需从Docker注册表V2镜像中运行：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should check if it is now up and running:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查它现在是否已经启动并运行：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The details of `container run` and other commands will be discussed again in
    the *Running a container* section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`container run`命令及其他相关命令将在*运行容器*部分再次讨论。'
- en: 'Recall that we have built an image named `my-nginx`. We can check if it is
    still there; this time we use `--filter reference` to select only an image name
    ending with `nginx`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们已经构建了一个名为`my-nginx`的镜像。我们可以检查它是否仍然存在，这次我们使用`--filter reference`来选择仅以`nginx`结尾的镜像名称：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can also shorten the command to `docker image ls *nginx`. It yields the same
    result.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过简化命令为`docker image ls *nginx`，它会得到相同的结果。
- en: 'Let''s tag the image. We will tag `my-nginx` to `127.0.0.1:5000/my-nginx` so
    it can be pushed into our private Docker registry. We can do this using the `docker
    image tag` command (`docker tag` for the old-style, top-level command):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为镜像打标签。我们将`my-nginx`打标签为`127.0.0.1:5000/my-nginx`，这样它就可以推送到我们的私有Docker注册表中。我们可以使用`docker
    image tag`命令（对于旧版的顶级命令是`docker tag`）来完成这项操作：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can check using `image ls` again to see that the `tag` command is done successfully:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用`image ls`检查，确认`tag`命令已经成功执行：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: OK, that looks great! We can now push the `my-nginx` image to the local repository,
    of course with `docker image push`, and the process will be very quick because
    the Docker repository is locally here on our machine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看来不错！我们现在可以将`my-nginx`镜像推送到本地仓库，当然使用`docker image push`，因为Docker仓库就在我们机器本地，整个过程非常快速。
- en: Again, you will find that the hash number is not the same as in the following
    listing when you try the commands. It is harmless; please just ignore it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现当你尝试执行命令时，哈希值与下面列出的不同。这是正常现象，请忽略它。
- en: 'Now, execute the following command to push the `my-nginx` image onto the local
    private repository:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下命令将`my-nginx`镜像推送到本地私有仓库：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The hard part has already been done beautifully. We now go back to the simple
    part: pushing an image to Docker Hub. Before we continue, please sign up for your
    Docker ID at [https://hub.docker.com/](https://hub.docker.com/) if you don''t
    have one yet.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最难的部分已经顺利完成。现在我们回到简单的部分：将镜像推送到Docker Hub。在继续之前，如果你还没有Docker ID，请先在[https://hub.docker.com/](https://hub.docker.com/)注册一个。
- en: 'To store an image there, we have to tag the image with the `<docker id>/<image
    name>` format. For pushing `my-nginx` to the Docker Hub, we will `image tag` it
    to `<docker id>/my-nginx`. I''ll use my Docker ID there. Replace `<docker id>`
    with your registered Docker ID:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要将镜像存储到那里，我们必须使用`<docker id>/<image name>`格式为镜像打标签。要将`my-nginx`推送到Docker Hub，我们需要将它打标签为`<docker
    id>/my-nginx`。我将在此使用我的Docker ID。请将`<docker id>`替换为你注册的Docker ID：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before pushing, we need to log in to the Docker Hub first using the `docker
    login` command. Please use `-u` and your Docker ID to specify the account. We
    will be asked for a password; if everything is OK, the command will say `Login
    Succeeded`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送之前，我们需要先使用`docker login`命令登录Docker Hub。请使用`-u`和你的Docker ID指定帐户。我们会被要求输入密码；如果一切正常，命令会显示`Login
    Succeeded`：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Please note that our username and password are insecurely stored in `~/.docker/config.json`,
    so please do not forget to type `docker logout` whenever possible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的用户名和密码不安全地存储在`~/.docker/config.json`中，因此请尽量不要忘记输入`docker logout`。
- en: Running a container
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'Now, let us run a container from our `my-nginx` image. We will use the `docker
    container run` command (the old, top-level command is `docker run`). This is done
    to run our container as a background process with `-d` and bind port `8080` of
    the host to port `80` of the container (`-p 8080:80`). We specified the container
    name with `--name`. If we run the container successfully, we will get a hash number,
    starting with `4382d778bcc9` in this example. It is the ID of our running container:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从`my-nginx`镜像启动一个容器。我们将使用`docker container run`命令（旧版的顶级命令是`docker run`）。这样做是为了以后台进程运行我们的容器，使用`-d`，并将主机的`8080`端口绑定到容器的`80`端口（`-p
    8080:80`）。我们通过`--name`指定容器名称。如果容器启动成功，我们将得到一个哈希值，例如`4382d778bcc9`，它是我们运行的容器的ID：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the web browser and point it to `http://localhost:8080`; we will see the
    NGINX server running:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网页浏览器并访问`http://localhost:8080`，我们将看到NGINX服务器正在运行：
- en: '![](img/e9bd1da1-2c23-42fe-b61b-75c173ba1dca.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9bd1da1-2c23-42fe-b61b-75c173ba1dca.png)'
- en: 'Figure 2.5: Example of NGINX running inside a container'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：容器内运行NGINX的示例
- en: 'Now our NGINX server is running as a background container serving on the host''s
    `8080` port. We can use the `docker container ls` command (or the old-style, top-level
    `docker ps`) to list all running containers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的NGINX服务器作为后台容器运行，并通过主机的`8080`端口提供服务。我们可以使用`docker container ls`命令（或者老式的、顶层的`docker
    ps`）来列出所有正在运行的容器：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can control the life cycle of the container using the commands `docker container
    start`, `stop`, `pause`, or `kill`, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令`docker container start`、`stop`、`pause`或`kill`等来控制容器的生命周期。
- en: 'If we would like to force removal of running containers, we can use `docker
    container rm -f <container id or name>` to do so. Let''s remove all running instances
    of `my-nginx` and the private registry before continuing to play around with a
    Docker Swarm cluster:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望强制移除正在运行的容器，可以使用`docker container rm -f <容器ID或名称>`命令。我们可以先移除所有正在运行的`my-nginx`实例和私有注册表，然后继续进行Docker
    Swarm集群的操作：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Docker Swarm clusters
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Swarm集群
- en: A cluster is a group of machines connecting together to do work. A Docker host
    is a physical or virtual machine with the Docker Engine installed. We create a
    Docker Swarm cluster by connecting many Docker hosts together. We refer to each
    Docker host as a Docker Swarm node, simply a node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是由一组机器连接在一起共同完成工作的。Docker主机是安装了Docker引擎的物理或虚拟机。我们通过将多个Docker主机连接在一起来创建Docker
    Swarm集群。我们将每个Docker主机称为Docker Swarm节点，简称节点。
- en: In version 1.12, Docker introduced Swarm mode, a new orchestration engine to
    replace the old Swarm cluster, which is now referred to as **Swarm classic**.
    The main difference between Swarm classic and Swarm mode is that Swarm classic
    uses an external service, such as Consul, etcd, or Apache ZooKeeper as its key/value
    store, but Swarm mode has this key/value built in. With this, Swarm mode keeps
    orchestration latency at a minimum, and is more robust than Swarm classic because
    it does not need to interact with an external store. The monolithic nature of
    Swarm mode is good for making changes to its algorithms. For example, one of my
    research works implemented the Ant Colony optimization to improve how Swarm placing
    containers ran on non-uniform clusters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.12中，Docker引入了Swarm模式，这是一个新的编排引擎，用以替代旧的Swarm集群，现称为**Swarm经典模式**。Swarm经典模式和Swarm模式的主要区别在于，Swarm经典模式使用外部服务，如Consul、etcd或Apache
    ZooKeeper作为其键/值存储，而Swarm模式则内置了这个键/值存储。因此，Swarm模式能够保持最小的编排延迟，并且比Swarm经典模式更加稳定，因为它不需要与外部存储进行交互。Swarm模式的单体架构有助于修改其算法。例如，我的一项研究工作实现了蚁群优化，以改进Swarm在非均匀集群上运行容器的方式。
- en: From experiments at our laboratory, we have found that Swarm classic has limitations
    when scaling to 100–200 nodes. With Swarm mode, we have done experiments with
    the Docker community to show that it can scale to at least 4,700 nodes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们实验室的实验，我们发现Swarm经典模式在扩展到100–200个节点时存在限制。而使用Swarm模式，我们与Docker社区合作进行的实验表明，它可以扩展到至少4,700个节点。
- en: The results are publicly available at project Swarm2K ([https://github.com/swarmzilla/swarm2k](https://github.com/swarmzilla/swarm2k))
    and Swarm3K ([https://github.com/swarmzilla/swarm3k](https://github.com/swarmzilla/swarm3k))
    on GitHub.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以通过项目Swarm2K ([https://github.com/swarmzilla/swarm2k](https://github.com/swarmzilla/swarm2k))
    和 Swarm3K ([https://github.com/swarmzilla/swarm3k](https://github.com/swarmzilla/swarm3k))
    在GitHub上公开获取。
- en: The key to the performance of Swarm mode is that it is built on top of the embedded
    *etcd* library. The embedded etcd library provides a mechanism for storing the
    state of a cluster in a distributed fashion. All state information is maintained
    in the Raft logs database with the Raft consensus algorithm.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm模式性能的关键在于它建立在嵌入式*etcd*库之上。嵌入式etcd库提供了一种机制，以分布式方式存储集群的状态。所有状态信息都保存在Raft日志数据库中，并采用Raft共识算法。
- en: In this section, we discuss how to set up a cluster in Swarm mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将讨论如何在Swarm模式下设置集群。
- en: Setting up a cluster
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置集群
- en: 'To create a fully functional single-node Swarm cluster, we just type the following
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个完全功能的单节点Swarm集群，我们只需输入以下命令：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We call this process Swarm cluster initialization. This process initializes
    the new cluster by preparing the `/var/lib/docker/swarm` directory to store all
    states related to the cluster. Here''s the contents of `/var/lib/docker/swarm`,
    which could be backed up if needed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个过程为Swarm集群初始化。该过程通过准备`/var/lib/docker/swarm`目录来初始化新集群，该目录用于存储与集群相关的所有状态。以下是`/var/lib/docker/swarm`的内容，如果需要，可以进行备份：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we have many network interfaces on the host, the previous command will fail
    as Docker Swarm requires us to specify an advertised address using an IP address,
    or a certain network interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机上有多个网络接口，之前的命令将失败，因为 Docker Swarm 要求我们使用 IP 地址或某个特定网络接口来指定广播地址。
- en: 'In the following example, I use my `wlan0` IP address as the advertised address
    of the cluster. This means that any machine on the Wi-Fi network can try to join
    this cluster:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我使用我的`wlan0` IP 地址作为集群的广播地址。这意味着任何在 Wi-Fi 网络上的机器都可以尝试加入这个集群：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, we may advertise using the name of a network interface, for example, `eth0`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用网络接口的名称进行广播，例如`eth0`：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Choose the style that works best for your working environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最适合你工作环境的样式。
- en: 'After initialization, we get a fully working, single-node cluster. To force
    a node to leave the current cluster, we use the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，我们获得了一个完全工作的单节点集群。为了强制某个节点离开当前集群，我们使用以下命令：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we run this command on a single-node cluster, the cluster will be destroyed.
    If you run the preceding command here, please do not forget to initialize the
    cluster again with `docker swarm init` before proceeding to the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在单节点集群上运行此命令，集群将被销毁。如果你在这里运行上述命令，请不要忘记在进入下一部分之前再次初始化集群，使用`docker swarm init`。
- en: Masters and workers
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主节点和工作节点
- en: Recall that we used the term Docker host to refer to a machine with Docker installed.
    When we join these hosts together to form a cluster, sometimes we call each of
    them a Docker node.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们曾用“Docker 主机”一词来指代安装了 Docker 的机器。当我们将这些主机组合在一起形成集群时，有时我们称它们中的每一个为 Docker
    节点。
- en: 'A Swarm cluster consists of two kinds of Docker nodes, a master and a worker.
    We say node `mg0` has the master role, and node `w01` has the worker role, for
    example. We form a cluster by joining other nodes to a master, usually the first
    master. The `docker swarm join` command requires the security tokens to be different,
    to allow a node to join as the master or as the worker. Please note that we must run
    the `docker swarm join` command on each node, not on the master node:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 集群由两种类型的 Docker 节点组成，主节点和工作节点。例如，我们说节点`mg0`具有主节点角色，节点`w01`具有工作节点角色。我们通过将其他节点加入主节点（通常是第一个主节点）来形成集群。`docker
    swarm join`命令要求安全令牌不同，以允许节点以主节点或工作节点身份加入。请注意，我们必须在每个节点上运行`docker swarm join`命令，而不是在主节点上运行：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A master node is responsible for controlling the cluster. The best practice
    recommended by Docker is that odd numbers of master nodes are the best configurations.
    We should have an odd number of master nodes starting from three. If we have three
    masters, one of them is allowed to fail and the cluster will still work.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点负责控制集群。Docker 推荐的最佳实践是，主节点的数量应为奇数，这是最佳配置。我们应该从三个主节点开始，并且主节点数量应为奇数。如果有三个主节点，允许其中一个失败，集群仍然能够正常运行。
- en: 'The following table shows the possible configurations, from one to six master
    nodes. For example, a cluster of three master nodes allows one master to fail
    and it still maintains the cluster. If two masters fail, the cluster will not
    be allowed to operate, starting or stopping services. However, in that state,
    the running containers will not die and continue to run:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了从一个到六个主节点的可能配置。例如，一个包含三个主节点的集群允许一个主节点失败，集群仍然能够保持运行。如果两个主节点失败，集群将无法操作，无法启动或停止服务。然而，在这种状态下，正在运行的容器不会停止，仍然继续运行：
- en: '| **Master nodes** | **Number of masters to maintain cluster** | **Failed masters
    allowed** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **主节点** | **维持集群所需的主节点数量** | **允许失败的主节点数** |'
- en: '| 1 | 1 | 0 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: '| 2 | 2 | 0 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 0 |'
- en: '| 3 (best) | 2 | 1 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 3 (最佳) | 2 | 1 |'
- en: '| 4 | 3 | 1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | 1 |'
- en: '| 5 (best) | 3 | 2 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 5 (最佳) | 3 | 2 |'
- en: '| 6 | 4 | 2 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 4 | 2 |'
- en: The best option to recover the cluster after losing the majority of master nodes
    is to bring the failed master nodes back online as fast as possible.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在失去大多数主节点后，恢复集群的最佳方法是尽可能快地将失败的主节点恢复上线。
- en: 'In the production cluster, we usually do not schedule running *tasks* on master
    nodes. A master node needs to have enough CPU, memory, and network bandwidth to
    properly handle node information and Raft logs. We control the cluster by commanding
    one of the master nodes. For example, we can list all nodes of a cluster by sending
    the following command to a master:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产集群中，我们通常不在主节点上调度运行的*任务*。主节点需要有足够的 CPU、内存和网络带宽来正确处理节点信息和 Raft 日志。我们通过指挥一个主节点来控制集群。例如，我们可以通过向主节点发送以下命令来列出集群中的所有节点：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What we see in the result is the list of all nodes in the current cluster. We
    can tell that the `mg0` node is a manager by looking at the `MANAGER STATUS` column.
    If a manager node is the primary manager of the cluster, `MANAGER STATUS` will
    say it is a `Leader`. If we have two more manager nodes here, the status will
    tell us they are a `Follower`. Here's how this leader/follower mechanism works.
    When we issue a command to the leader, the leader performs the command and the
    state of the cluster is changed. The cluster state is then updated by also sending
    this change to other manager nodes, that is, followers. If we issue a command
    to a follower, it will forward the command to the leader instead of doing that
    itself. Basically, all commands for the cluster will be performed by the leader,
    and the followers will update the changes to their internal Raft logs only.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中显示的是当前集群中所有节点的列表。我们可以通过查看`MANAGER STATUS`列来判断`mg0`节点是否为管理节点。如果一个管理节点是集群的主管理节点，`MANAGER
    STATUS`会显示它是`Leader`。如果这里有另外两个管理节点，状态会显示它们是`Follower`。下面是这个 leader/follower 机制的工作原理。当我们向领导节点发送命令时，领导节点会执行命令，并更改集群的状态。然后，集群状态会通过将此更改发送给其他管理节点（即
    follower）来更新。如果我们向 follower 发送命令，它不会自己执行，而是将命令转发给领导节点。基本上，集群的所有命令都由领导节点执行，follower
    只会将更改更新到它们自己的 Raft 日志中。
- en: 'If a new manager node would like to join, we require a master token for it.
    Type the `docker swarm join-token manager` command to obtain a security token
    to join a cluster in a manager role:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有新的管理节点想要加入，我们需要为其提供一个主令牌。输入`docker swarm join-token manager`命令来获取安全令牌，以便将节点加入到管理角色的集群中：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although a task as a container can be running on both kinds of nodes, we usually
    do not submit tasks to run on master nodes. We only use worker nodes to run tasks
    in production. To join worker nodes to the cluster, we pass the worker token to
    the join command. Use `docker swarm join-token worker` to obtain a worker token.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任务作为容器可以在两种类型的节点上运行，但我们通常不会将任务提交到主节点上运行。我们仅使用工作节点来运行生产中的任务。为了将工作节点加入集群，我们将工作令牌传递给加入命令。使用`docker
    swarm join-token worker`来获取工作令牌。
- en: Services and tasks
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务与任务
- en: Along with the new orchestration engine, Docker introduced the new abstraction
    of services and tasks in version 1.12\. A service may consist of many instances
    of a task. We call each instance a replica. Each instance of a task runs on a
    Docker node in the form of a container.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新调度引擎的引入，Docker 在 1.12 版本中引入了服务和任务的新抽象。一个服务可以由多个任务实例组成。我们将每个实例称为副本。每个任务实例作为容器在
    Docker 节点上运行。
- en: 'A service can be created using the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令创建服务：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This web service consists of three tasks, specified with `--replicas`. These
    tasks are submitted by the orchestration engine to run on selected nodes. The
    service's name, web, can be resolved using a virtual IP address. Other services
    on the same network, in this case maybe a reverse proxy service, can refer to
    it. We use `--name` to specify the name of the service.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该 web 服务由三个任务组成，这些任务通过`--replicas`进行指定。任务由调度引擎提交并在选定的节点上运行。服务的名称 web 可以通过虚拟
    IP 地址解析。位于同一网络上的其他服务（例如反向代理服务）可以引用它。我们使用`--name`来指定服务的名称。
- en: 'We continue the discussion of the details of this command in the following
    diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的图示中继续讨论此命令的细节：
- en: '![](img/84e841b0-684c-4ebd-bd57-9b4ebb6fcad2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84e841b0-684c-4ebd-bd57-9b4ebb6fcad2.png)'
- en: 'Figure 2.6: Swarm cluster in action'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：Swarm 集群运行示意图
- en: We assume that our cluster consists of one manager node and five worker nodes.
    There is no high availability setup for the manager; this will be left as an exercise
    for the reader.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的集群由一个管理节点和五个工作节点组成。管理节点没有高可用性设置；这将留给读者自己解决。
- en: 'We start at the manager. The manager is set to be *drained *because we do not
    want it to accept any scheduled tasks. This is the best practice, and we can drain
    a node as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从管理节点开始。由于我们不希望它接受任何计划任务，因此将管理节点设置为*drained*。这是最佳实践，我们可以通过以下方式使节点进入 drained
    状态：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This service will be published to port `80` on the routing mesh. The routing
    mesh is a mechanism to perform load balancing inside the Swarm mode. Port `80`
    will be opened on every worker node to serve this service. When a request comes
    in, the routing mesh will route the request to a certain container (a task) on
    a certain node, automatically.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务将在路由网格的`80`端口上发布。路由网格是 Swarm 模式内执行负载均衡的一种机制。每个工作节点的`80`端口将会开放，以提供此服务。当请求到达时，路由网格会自动将请求路由到某个节点的特定容器（任务）。
- en: 'The routing mesh relies on a Docker network with the overlay driver, namely
    `ingress`. We can use `docker network ls` to list all active networks:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 路由网格依赖于一个使用 overlay 驱动程序的 Docker 网络，即 `ingress`。我们可以使用 `docker network ls` 列出所有活跃的网络：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We find a network with ID `ve7fj61ifakr` which is an `overlay` network of the
    `swarm` scope. As the information implies, this kind of network is working only
    in Docker Swarm mode. To see the details of this network, we use the `docker network
    inspect ingress` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到一个 ID 为 `ve7fj61ifakr` 的网络，它是 `swarm` 范围下的一个 `overlay` 网络。正如信息所暗示的那样，这种网络仅在
    Docker Swarm 模式下工作。要查看此网络的详细信息，我们使用 `docker network inspect ingress` 命令：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see that the `ingress` network has a subnet of `10.255.0.0/16`*,* which
    means that we are allowed to use 65,536 IP addresses in this network by default.
    This number is the maximum number of tasks (containers) created by `docker service
    create -p` on a single Swarm mode cluster. This number is not affected when we
    use `docker container run -p` outside the Swarm.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`ingress` 网络的子网是 `10.255.0.0/16`，这意味着默认情况下我们可以在该网络中使用 65,536 个 IP 地址。这个数字是通过
    `docker service create -p` 在单个 Swarm 模式集群中创建的任务（容器）的最大数量。当我们在非 Swarm 环境中使用 `docker
    container run -p` 时，这个数字不会受到影响。
- en: 'To create a Swarm scoped overlay network, we use the `docker network create`
    command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Swarm 范围的 overlay 网络，我们使用 `docker network create` 命令：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can check again with the `docker network ls` command and see the `appnet`
    network with the `overlay` driver and `swarm` scope there. Your network''s ID
    will be different. To attach a service to a specific network, we can pass the
    network name to the `docker service create` command. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker network ls` 命令再次检查，看到 `appnet` 网络与 `overlay` 驱动程序和 `swarm` 范围。在这里你的网络
    ID 会有所不同。要将服务附加到特定网络，我们可以将网络名称传递给 `docker service create` 命令。例如：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding example creates the `web` service and attaches it to the `appnet`
    network. This command works if, and only if, the appnet is Swarm-scoped.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例创建了 `web` 服务并将其附加到 `appnet` 网络。只有当 `appnet` 是 Swarm 范围时，这个命令才有效。
- en: 'We can dynamically detach or re-attach net networks to the current running
    service using the `docker service update` command with `--network-add` or `--network-rm`,
    respectively.  Try the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `docker service update` 命令并配合 `--network-add` 或 `--network-rm` 选项，动态地将网络从当前正在运行的服务中移除或重新附加。请尝试以下命令：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we can observe the result with `docker inspect web`. You will find a
    chunk of JSON printed out with the last block looking as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到 `docker inspect web` 命令的结果。你会发现一段 JSON 输出，最后一块看起来如下：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It means that the service has been updated and the process of updating has
    been completed. We will now have the `web` service attaching to the `appnet` network:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着服务已经更新，并且更新过程已完成。现在，我们将看到 `web` 服务附加到 `appnet` 网络：
- en: '![](img/1ad6e3d1-fe1b-4f0f-b7c1-06c518a949c4.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ad6e3d1-fe1b-4f0f-b7c1-06c518a949c4.png)'
- en: 'Figure 2.7: The Gossip communication mechanism for Swarm-scope overlay networks'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：Swarm 范围覆盖网络的 Gossip 通信机制
- en: Overlay networks rely on the **gossip** protocol implementation over port `7946`,
    for both TCP and UDP, accompanied by Linux's VXLAN over UDP port `4789`. The overlay
    network is implemented with performance in mind. A network will cover only the
    necessary hosts and gradually expand when needed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Overlay 网络依赖于在端口 `7946` 上实现的 **gossip** 协议，支持 TCP 和 UDP，同时还使用 Linux 的 VXLAN，通过
    UDP 端口 `4789` 实现。该 overlay 网络的实现是以性能为目标的。网络将仅覆盖必要的主机，并在需要时逐步扩展。
- en: 'We can scale a service by increasing or decreasing the number of its replicas.
    Scaling the service can be done using the `docker service scale` command. For
    example, if we would like to scale the `web` service to five replicas, we could
    issue the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加或减少副本数来扩展服务。扩展服务可以使用 `docker service scale` 命令来完成。例如，如果我们希望将 `web` 服务扩展到五个副本，可以执行以下命令：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the service is scaled, and its task is scheduled on a new node, all related
    networks bound to this service will be expanded to cover the new node automatically.
    In the following diagram, we have two replicas of the app service, and we would
    like to scale it from two to three with the command `docker service scale app=3`.
    The new replica **app.3** will be scheduled on the worker node **w03**. Then the
    overlay network bound to this app service will be expanded to cover node **w03**
    too. The network-scoped gossip communication is responsible for the network expansion
    mechanism:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务扩展，并且其任务调度到新节点时，所有绑定到此服务的相关网络将自动扩展以覆盖新节点。在下图中，我们有两个应用服务副本，并且我们希望通过命令 `docker
    service scale app=3` 将其从两个扩展到三个。新的副本 **app.3** 将被调度到工作节点 **w03**。然后，绑定到此应用服务的覆盖网络也将扩展以覆盖节点
    **w03**。网络范围的 gossip 通信负责网络扩展机制：
- en: '![](img/64ed8f48-8d3e-40e3-98fd-1605048c9fb8.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64ed8f48-8d3e-40e3-98fd-1605048c9fb8.png)'
- en: 'Figure 2.8: Swarm-scoped network expansion'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：Swarm 范围的网络扩展
- en: Docker and serverless
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 与无服务器
- en: How will Docker benefit us? When dealing with application development, Docker
    can be used to simplify the development toolchain. We can pack everything we need
    to write serverless applications into a single container image and let the whole
    team use it. This ensures consistency of tool versions and ensures they will not
    mess up our development machines.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将如何对我们有所帮助？在处理应用开发时，Docker 可以用来简化开发工具链。我们可以将编写无服务器应用所需的一切打包进一个单一的容器镜像中，并让整个团队使用它。这确保了工具版本的一致性，并确保它们不会弄乱我们的开发机器。
- en: We will then use Docker to prepare our infrastructure. Actually, the term serverless
    means developers should not maintain their own infrastructure. However, in cases
    where the public cloud is not an option, we can use Docker to simplify infrastructure
    provisioning. Using the same architecture as the third-party serverless platforms
    on our company's infrastructure, we can minimize the operation and maintenance
    costs. Later chapters will discuss how we can operate our own Docker-based FaaS
    infrastructure.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用 Docker 来准备我们的基础设施。实际上，无服务器（serverless）意味着开发人员不需要维护自己的基础设施。然而，在公共云不可选的情况下，我们可以使用
    Docker 来简化基础设施的提供。使用与第三方无服务器平台相同的架构，在我们公司的基础设施上，我们可以最小化运维成本。后续章节将讨论如何操作我们自己的基于
    Docker 的 FaaS 基础设施。
- en: For the serverless application itself, we use Docker as a wrapper for serverless
    functions. We use Docker as a unit of work, so that any kind of binary can be
    integrated into our serverless platform, ranging from the legacy COBOL, C, or
    Pascal programs to the programs written in modern languages, such as Node.js,
    Kotlin, or Crystal. In the 17.06+ versions of Docker, it is also possible to form
    a Swarm cluster across multi-hardware architecture. We can even host Windows-based
    C# functions on the same cluster as mainframe-based COBOL programs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无服务器应用本身，我们使用 Docker 作为无服务器函数的封装器。我们将 Docker 作为工作单元，这样任何类型的二进制文件都可以集成到我们的无服务器平台中，从遗留的
    COBOL、C 或 Pascal 程序，到用现代语言编写的程序，如 Node.js、Kotlin 或 Crystal。在 Docker 17.06+ 版本中，还可以跨多硬件架构形成
    Swarm 集群。我们甚至可以在与主机 COBOL 程序相同的集群上托管基于 Windows 的 C# 函数。
- en: Exercises
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To help you better remember and understand the concepts and practices of Docker
    described in this chapter, try answering the following questions without going
    back to the chapter''s contents. Let''s get started:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地记住和理解本章中描述的 Docker 概念和实践，尝试在不返回章节内容的情况下回答以下问题。开始吧：
- en: What are containers? What's the key difference between containers and virtual
    machines?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是容器？容器和虚拟机之间的关键区别是什么？
- en: What are the main features inside the Linux kernel to enable container technology?
    Please name at least two of them.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用容器技术的 Linux 内核主要功能有哪些？请至少列举其中两个。
- en: What are the key concepts of the Docker workflow?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 工作流的关键概念是什么？
- en: What is a Dockerfile for? Which Docker command do you use to interact with it?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile 是做什么的？你使用哪个 Docker 命令与其交互？
- en: What is the ENTRYPOINT instruction inside a Dockerfile?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile 中的 ENTRYPOINT 指令是什么？
- en: Which command do we use to list all Docker images?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个命令来列出所有 Docker 镜像？
- en: Which command do we use to form a Docker Swarm cluster?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个命令来形成一个 Docker Swarm 集群？
- en: What is the key difference between Swarm classic and Swarm mode?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swarm classic 和 Swarm mode 之间的主要区别是什么？
- en: Please explain the relationship between services and tasks.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请解释服务与任务之间的关系。
- en: How can we create an NGINX service with five replicas?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建一个包含五个副本的 NGINX 服务？
- en: How can we scale down the number of the NGINX services to two?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将 NGINX 服务的副本数缩减到两个？
- en: What is the minimum number of nodes required to form a Swarm cluster with the
    high-availability property? Why?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 形成具有高可用性属性的 Swarm 集群所需的最小节点数是多少？为什么？
- en: What is the name for a network that is part of the routing mesh? How large is
    it?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被称为路由网格一部分的网络是什么？它有多大？
- en: Which port numbers are used by a Swarm cluster? What are they for?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swarm 集群使用哪些端口号？它们的用途是什么？
- en: What is the main benefit of network-scoped Gossip communication?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络范围的 Gossip 通信的主要优势是什么？
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started off by discussing the concepts of containers. Then we reviewed
    what Docker is, how to install it, and the Docker build, ship, and run workflow.
    We then learnt how to form a Docker Swarm cluster and Swarm master and worker
    nodes. We learnt how to properly set up a robust Swarm cluster with an odd number
    of master nodes. We then learnt the service and task concepts of Docker Swarm.
    Finally, we learnt how Docker fits into serverless application development.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先讨论了容器的概念。然后我们回顾了 Docker 是什么，如何安装它，以及 Docker 的构建、分发和运行工作流程。接着，我们学习了如何形成 Docker
    Swarm 集群及 Swarm 主节点和工作节点。我们了解了如何通过设置奇数个主节点来正确构建一个稳健的 Swarm 集群。然后我们学习了 Docker Swarm
    的服务和任务概念。最后，我们学习了 Docker 如何融入无服务器应用开发。
- en: In the next chapter, we will review serverless frameworks and platforms to understand
    the overall architecture and the limitations of them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将回顾无服务器框架和平台，以理解它们的整体架构和局限性。
