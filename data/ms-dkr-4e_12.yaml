- en: '*Chapter 12*'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第12章*'
- en: Discovering other Kubernetes options
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他 Kubernetes 选项
- en: In this chapter, we will look at alternatives to using Docker's in-built support
    for running your own local Kubernetes single-node and multi-node clusters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论使用 Docker 内建支持来运行您自己的本地 Kubernetes 单节点和多节点集群的替代方案。
- en: 'We will be discussing and looking at the following tools:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论并查看以下工具：
- en: Minikube
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube
- en: '**Kind** (**Kubernetes in Docker**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kind**（**Kubernetes in Docker**）'
- en: MicroK8s
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroK8s
- en: K3s
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K3s
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will be using one of the tools we discussed in [*Chapter 6*](B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187),
    *Docker Machine, Vagrant, and Multipass*, along with some standalone tools that
    can be used to bootstrap your own local Kubernetes installation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[*第6章*](B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187)中讨论的工具之一，*Docker
    Machine、Vagrant 和 Multipass*，以及一些可以用于引导您本地 Kubernetes 安装的独立工具。
- en: Again, the screenshots in this chapter will be from my preferred operating system,
    macOS
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，本章中的截图将来自我偏好的操作系统——macOS
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3byY104](https://bit.ly/3byY104).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码实际操作：[https://bit.ly/3byY104](https://bit.ly/3byY104)。
- en: Deploying Kubernetes using Minikube
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Minikube 部署 Kubernetes
- en: First in our list of alternative Kubernetes cluster installers is Minikube.
    It was initially released in May 2016, making it the oldest of the tools we will
    be discussing in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的所有 Kubernetes 集群安装器中，Minikube 排在第一位。它最初于 2016 年 5 月发布，是我们在本章中讨论的工具中最古老的一个。
- en: Before we look at installing Minikube, we should probably discuss why it was
    needed in the first place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论安装 Minikube 之前，或许我们应该先讨论一下为什么最初需要它。
- en: At the time of its original release, Kubernetes `1.2` had been out for a few
    months, and it was almost a year after the `1.0` release of Kubernetes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初发布时，Kubernetes `1.2`已经发布了几个月，而距离 Kubernetes `1.0` 的发布几乎已经过去了一年。
- en: While installing Kubernetes had become a lot simpler since the original release,
    it typically still boiled down to a bunch of installation scripts and step-by-step
    instructions that were designed to mostly bootstrap cloud-hosted clusters utilizing
    the cloud provider's APIs or command-line tools.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自最初发布以来，安装 Kubernetes 已变得更加简单，但它通常仍然归结为一堆安装脚本和逐步指令，这些指令大多数是为了引导使用云服务提供商 API
    或命令行工具的云托管集群而设计的。
- en: If you wanted to run an installation locally for development purposes, then
    you would have to either hack together your installer from existing scripts or
    download a Vagrant box where you would be trusting the author of the box to have
    built it using the best practices promoted by the **Cloud Native Computing Foundation**
    (**CNCF**), which was trying to ensure consistency between clusters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地进行开发目的的安装，那么您必须从现有脚本中拼凑出安装程序，或者下载一个 Vagrant box，在这种情况下，您需要信任该 box 的作者，认为他们按照**云原生计算基金会**（**CNCF**）所提倡的最佳实践来构建它，这样可以确保集群之间的一致性。
- en: Although Minikube started life as a way of creating a local Kubernetes node
    on just Linux and macOS hosts, Windows was soon introduced, and the project has
    grown to be an important part of the Kubernetes project as it is many people's
    first taste of interacting with Kubernetes and it forms part of the official Kubernetes
    documentation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Minikube 最初是作为在 Linux 和 macOS 主机上创建本地 Kubernetes 节点的方式开始的，但很快就加入了 Windows
    支持，且该项目已经发展成为 Kubernetes 项目中的一个重要组成部分，因为它是许多人第一次接触 Kubernetes 的途径，并且它是官方 Kubernetes
    文档的一部分。
- en: Now that we know a little about Minikube's background, let's look at getting
    it installed and then launching a single-node cluster.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Minikube 的背景有了一些了解，让我们看看如何安装它并启动一个单节点集群。
- en: Installing Minikube
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Minikube
- en: Minikube is designed to run a single binary, and like Kubernetes itself, it
    is written in Go, which means that it can easily be compiled to run on the three
    platforms we have been looking at in this title. To start with, let's have a look
    at how to install Minikube on macOS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 设计用于运行一个单一的二进制文件，像 Kubernetes 本身一样，它是用 Go 编写的，这意味着它可以轻松编译并在我们在本书中讨论的三个平台上运行。首先，让我们看看如何在
    macOS 上安装 Minikube。
- en: Installing Minikube on macOS
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Minikube
- en: When we have discussed installing software and tools on macOS in previous chapters,
    we have mentioned and used Homebrew.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的章节中讨论 macOS 上的软件和工具安装时，我们提到了并使用了 Homebrew。
- en: 'Installing Minikube follows this path, meaning that it can be installed using
    a single command, which as you may have already guessed, looks like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Minikube 的方式是这样的，这意味着你可以通过一个简单的命令来安装，正如你可能已经猜到的那样，命令如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, you can verify everything is working as expected by running
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过运行以下命令验证一切是否按预期工作：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will output the version of Minikube that was installed along with the commit
    ID that version was compiled from.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出已安装的 Minikube 版本以及该版本编译时的提交 ID。
- en: Installing Minikube on Windows 10
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 10 上安装 Minikube
- en: "Like Homebrew on macOS, when it comes to package managers on Windows, the \L\
    go-to is Chocolatey. If you have it installed, you can install Minikube using\
    \ the following command:"
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与 macOS 上的 Homebrew 类似，在 Windows 上谈到包管理器时，首选的是 Chocolatey。如果你已经安装了它，可以使用以下命令安装
    Minikube：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are not using Chocolatey, then you can download a Windows installer from
    [https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 Chocolatey，那么可以从 [https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe)
    下载 Windows 安装程序。
- en: 'Once you have Minikube installed, you can run the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Minikube 安装完成，你可以运行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will confirm the installed version and commit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确认已安装的版本和提交信息。
- en: Installing Minikube on Linux
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Minikube
- en: Depending on the version of Linux you are running, there are a few different
    ways to install Minikube.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你所运行的 Linux 版本，安装 Minikube 的方式有所不同。
- en: Tip
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Before running the commands that follow, check the project's release page on
    GitHub to confirm what version of Minikube to install. The page can be found at
    [https://github.com/kubernetes/minikube/releases/](https://github.com/kubernetes/minikube/releases/).
    At the time of writing, the latest release is 1.9.2-0, so the instructions will
    use that version.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行接下来的命令之前，请查看 GitHub 上的项目发布页面，确认要安装哪个版本的 Minikube。该页面可以在 [https://github.com/kubernetes/minikube/releases/](https://github.com/kubernetes/minikube/releases/)
    找到。写本文时，最新发布的版本是 1.9.2-0，因此本说明将使用该版本。
- en: 'If you are running a Debian-based system that uses an APT such as Ubuntu or
    Debian itself, then you can download and install a `.deb` using the following
    commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行基于 Debian 的系统，比如 Ubuntu 或 Debian 本身，那么你可以使用以下命令下载并安装 `.deb` 包：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are running an RPM-based system, such as CentOS or Fedora, then you
    can use the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行基于 RPM 的系统，如 CentOS 或 Fedora，你可以使用以下命令：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, if you would prefer not to use a package manager, then you can download
    the latest static binary using the following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你不想使用包管理器，你可以使用以下命令下载最新的静态二进制文件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whichever way you have chosen to install Minikube, you can run the following
    to confirm that everything is installed and working as expected:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择了哪种方式来安装 Minikube，你可以运行以下命令确认一切是否已经安装并按预期工作：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, this will confirm the installed version and the commit it was compiled
    from.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这将确认已安装的版本和它的编译提交。
- en: Minikube drivers
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minikube 驱动程序
- en: 'As we have already mentioned, Minikube is a standalone static binary that helps
    you launch a Kubernetes node on your local machine; it does this by interacting
    with several hypervisors. Before we start to use Minikube, let''s quickly look
    at the options:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Minikube 是一个独立的静态二进制文件，帮助你在本地机器上启动一个 Kubernetes 节点；它通过与多个虚拟化管理程序交互来实现这一功能。在我们开始使用
    Minikube 之前，先快速了解一下可选项：
- en: '**Docker (macOS, Windows, and Linux)**: This driver uses Docker Machine to
    launch containers that host your Kubernetes node. On Linux, it will use just containers,
    and on macOS and Windows, it will launch a small virtual machine too and deploy
    the containers there.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker (macOS、Windows 和 Linux)**：此驱动程序使用 Docker Machine 启动容器来托管 Kubernetes
    节点。在 Linux 上，它只会使用容器，而在 macOS 和 Windows 上，它也会启动一个小型虚拟机，并在其中部署容器。'
- en: '**VirtualBox (macOS, Windows, and Linux)**: This driver works across three
    operating systems and will launch a virtual machine and then configure your node.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VirtualBox (macOS、Windows 和 Linux)**：这个驱动程序适用于三种操作系统，它会启动一个虚拟机，然后配置你的节点。'
- en: '**HyperKit (macOS)**: This uses the hypervisor built into macOS to host a virtual
    machine where your node will be configured.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HyperKit (macOS)**：它使用 macOS 内置的虚拟化管理程序来托管一个虚拟机，在这个虚拟机中配置你的节点。'
- en: '**Hyper-V (Windows 10 Pro)**: This uses the native hypervisor that is built
    into Windows 10 Professional to host a virtual machine where your node will be
    launched and configured.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hyper-V (Windows 10 Pro)**：此驱动程序使用 Windows 10 专业版内置的本地虚拟化程序来托管一个虚拟机，在其中启动并配置你的节点。'
- en: '**KVM2 (Linux)**: This driver uses **(Kernel-based Virtual Machine KVM)** to
    launch a virtual machine.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KVM2 (Linux)**：此驱动程序使用 **（基于内核的虚拟机 KVM）** 启动虚拟机。'
- en: '**Podman (Linux)**: This experimental driver uses a Docker replacement called
    Podman to launch containers that make up your cluster.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Podman (Linux)**：此实验性驱动程序使用一个名为 Podman 的 Docker 替代品来启动构成集群的容器。'
- en: '**Parallels (macOS)**: Uses the macOS-only Parallels to host a virtual machine
    where your node will be launched and configured.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parallels (macOS)**：使用仅限 macOS 的 Parallels 来托管一个虚拟机，在其中启动并配置你的节点。'
- en: '**VMware (macOS)**: Uses the macOS-only VMware Fusion to host a virtual machine
    where your node will be launched and configured.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMware (macOS)**：使用仅限 macOS 的 VMware Fusion 来托管一个虚拟机，在其中启动并配置你的节点。'
- en: '**None (Linux)**: This final option does away with containers and virtual machines
    launched in your local hypervisor; it simply installs your cluster node directly
    on the host you are running.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**None (Linux)**：这个最终选项不使用在本地虚拟化程序中启动的容器和虚拟机；它直接在你运行的宿主机上安装集群节点。'
- en: If you have made it this far through the book, then you will have already installed
    the perquisites for at least one of the drivers mentioned above on your host machine.
    Minikube is intelligent enough to figure out the best driver to use on your host
    so we should be able to proceed without worrying that things won't work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这里，那么你应该已经在宿主机上安装了上述提到的至少一个驱动程序的先决条件。Minikube 足够智能，可以判断出宿主机上最适合使用的驱动程序，因此我们可以继续进行，而不用担心会出现问题。
- en: However, should you get an error because a support driver for your chosen host
    operating system is not found, then see the *Further reading* section for links
    to each of the preceding projects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果因为找不到所选宿主操作系统的支持驱动程序而导致错误，请参阅 *进一步阅读* 部分，获取每个先前项目的链接。
- en: Tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Should you find yourself without a supported driver install, I would recommend
    installing VirtualBox as it has the least requirements and complexity out of all
    of the drivers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现没有支持的驱动程序安装，我建议安装 VirtualBox，因为它比所有驱动程序的要求和复杂性都要低。
- en: Now that we have Minikube installed, and we have looked at the drivers that
    it needs to launch and configure your cluster node, we can get to work and launch
    our cluster node.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Minikube，并且了解了它需要的驱动程序来启动并配置你的集群节点，我们可以开始工作并启动我们的集群节点。
- en: Launching a cluster node using Minikube
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Minikube 启动集群节点
- en: 'It doesn''t matter what your host operating system, launching a Kubernetes
    cluster node using Minikube is a single, simple command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的宿主操作系统是什么，使用 Minikube 启动 Kubernetes 集群节点只需要一个简单的命令：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you first run the command, it may take several minutes after detecting
    your local configuration as it has to download and configure various supporting
    tools, virtual machine images, and containers (depending on the driver it is using).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行命令时，在检测到本地配置后，可能需要几分钟的时间，因为它必须下载并配置各种支持工具、虚拟机镜像和容器（取决于它使用的驱动程序）。
- en: You may also find that it asks for passwords for parts of the installation that
    require elevated privileges. These steps are a one-off and once you have launched
    your initial Kubernetes cluster node, subsequent cluster node launches should
    be a lot quicker.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会发现，它在安装过程中会要求输入密码，用于需要提升权限的部分。这个步骤是一次性的，一旦你启动了初始 Kubernetes 集群节点，之后的集群节点启动应该会更快。
- en: 'The following Terminal output shows my initial Minikube cluster node launching:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我的初始 Minikube 集群节点启动的终端输出：
- en: '![Figure 12.1 – Launching a Kubernetes cluster node on macOS'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 在 macOS 上启动 Kubernetes 集群节点'
- en: '](img/image_00_0013.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0013.jpg)'
- en: Figure 12.1 – Launching a Kubernetes cluster node on macOS
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 在 macOS 上启动 Kubernetes 集群节点
- en: Once your cluster node is up and running, you may notice a message at the bottom
    of the output highlighting that the version of `kubectl` is out of date and may
    not be compatible with the version of Kubernetes that is installed on the Minikube
    launched cluster node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群节点启动并运行，你可能会注意到输出底部的消息，提示 `kubectl` 的版本已过时，并且可能与在 Minikube 启动的集群节点上安装的 Kubernetes
    版本不兼容。
- en: 'Luckily, you can work around this by prefixing our `kubectl` commands with
    `minikube`, and adding `–` after. This will download and install a compatible
    version of `kubectl`, but it will be isolated in our Minikube workspace:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您可以通过在 `kubectl` 命令前加上 `minikube`，并在后面加上 `–` 来解决此问题。这将下载并安装与 `kubectl`
    兼容的版本，但它将在我们的 Minikube 工作空间中被隔离：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see something like the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 12.2 – Initializing a compatible version of kubectl using Minikube'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 使用 Minikube 初始化兼容版本的 kubectl'
- en: '](img/image_00_0023.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0023.jpg)'
- en: Figure 12.2 – Initializing a compatible version of kubectl using Minikube
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 使用 Minikube 初始化兼容版本的 kubectl
- en: So, why did we get this message in the first place? Well, the Docker for Mac
    installation comes bundled with a version of `kubectl` that supports the version
    of Kubernetes natively supported within Docker, which at the time of writing is
    version `1.15.5`, whereas Minikube has pulled down the latest stable release of
    Kubernetes, which is `1.18.0`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们一开始会收到这个消息呢？好吧，Mac 版 Docker 的安装包中捆绑了一个支持 Docker 本地支持的 Kubernetes 版本的
    `kubectl`，而该版本的 Kubernetes 在写作时是版本 `1.15.5`，而 Minikube 拉取的是 Kubernetes 的最新稳定版本
    `1.18.0`。
- en: One of the advantages of using Minikube over the native Docker-supported Kubernetes
    is that you can run different versions of Kubernetes and easily isolate the versions
    of the supporting tools required to interact with various versions by prefixing
    your `kubectl` commands with `minikube` and adding `--` immediately after.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Minikube 而不是本地 Docker 支持的 Kubernetes 的一个优势是，您可以运行不同版本的 Kubernetes，并通过在 `kubectl`
    命令前加上 `minikube`，并在后面加上 `--`，轻松隔离与不同版本交互所需的支持工具版本。
- en: This is great when you have to test how your applications will react when it
    is time to update your production Kubernetes clusters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要测试应用程序在更新生产 Kubernetes 集群时如何反应时，这非常有用。
- en: Interacting with your Kubernetes cluster node
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与您的 Kubernetes 集群节点交互
- en: Now that we have our cluster node up and running, we can run through some common
    commands and launch a test application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了集群节点，我们可以运行一些常见命令并启动一个测试应用程序。
- en: 'To start with, let''s get a little information about our cluster node. In [*Chapter
    11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*, Docker and Kubernetes*,
    we ran the following commands to get information on the cluster node and namespaces:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们获取一些关于集群节点的信息。在[*第11章*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*,
    Docker 和 Kubernetes*中，我们运行了以下命令来获取集群节点和命名空间的信息：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run them again, remembering to prefix `minikube` before and `--` after
    each command so that they now look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行这些命令，记得在每个命令前加上 `minikube`，并在后面加上 `--`，使其看起来像这样：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Take a look at the following Terminal output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下终端输出：
- en: '![Figure 12.3 – Getting information on the cluster node'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – 获取集群节点信息'
- en: '](img/image_00_0033.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0033.jpg)'
- en: Figure 12.3 – Getting information on the cluster node
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 获取集群节点信息
- en: The output we get when running the commands is similar to that we got when we
    executed the equivalent commands in [*Chapter 11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294),
    *Docker and Kubernetes*, although the pods listed for the `kube-system` namespace
    are different.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这些命令时，输出结果与在[*第11章*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)中执行等效命令时得到的结果类似，*Docker
    和 Kubernetes*，尽管列出的 `kube-system` 命名空间中的 pods 不同。
- en: 'Next up, we can launch a test application by running the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过运行以下命令来启动一个测试应用程序：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the deployment has been created, you can view its status and the pod involved
    by running the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 部署创建完成后，您可以运行以下命令查看其状态和相关的 pod：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see something similar to the following Terminal output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的终端输出：
- en: '![Figure 12.4 – Launching an application deployment and checking the status'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4 – 启动应用程序部署并检查状态'
- en: '](img/image_00_0043.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0043.jpg)'
- en: Figure 12.4 – Launching an application deployment and checking the status
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 启动应用程序部署并检查状态
- en: 'Now that our application deployment has been launched, we need a way of interacting
    with it. To do this, we can run the following command, which will launch a load
    balancer service on port `8080`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序部署已启动，我们需要一种与其交互的方式。为此，我们可以运行以下命令，这将启动一个位于端口 `8080` 的负载均衡器服务：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the service has been exposed, we can run the following command to get
    more information on running services:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务被暴露，我们可以运行以下命令获取更多正在运行的服务信息：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If our cluster node was hosted on a public cloud, the command will let us know
    what the external IP address of the service is, however, when we run the command,
    we get the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的集群节点托管在公共云上，命令将告诉我们服务的外部 IP 地址。然而，当我们运行命令时，得到如下输出：
- en: '![Figure 12.5 – Exposing the service on port 8080'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5 – 在 8080 端口公开服务'
- en: '](img/image_00_0053.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0053.jpg)'
- en: Figure 12.5 – Exposing the service on port 8080
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 在 8080 端口公开服务
- en: As you can see, `EXTERNAL-IP` is listed as `<pending>`, so how do we access
    the application we deployed?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`EXTERNAL-IP` 显示为 `<pending>`，那么我们如何访问我们部署的应用程序呢？
- en: 'To this, we need to use the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要使用以下命令：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This command will open the `hello-node` service in the default browser on your
    machine as well as printing the URL you can access the service on in the Terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将打开 `hello-node` 服务在您机器的默认浏览器中，并在终端中打印出您可以访问该服务的 URL：
- en: '![Figure 12.6 – Opening the hello-node service'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – 打开 hello-node 服务'
- en: '](img/image_00_0063.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0063.jpg)'
- en: Figure 12.6 – Opening the hello-node service
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 打开 hello-node 服务
- en: 'The `hello-node` application simply echoes back the headers sent by your browser:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello-node` 应用程序只是回显浏览器发送的请求头：'
- en: '![Figure 12.7 – Viewing the hello-node application in a browser'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 在浏览器中查看 hello-node 应用程序'
- en: '](img/image_00_0073.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0073.jpg)'
- en: Figure 12.7 – Viewing the hello-node application in a browser
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 在浏览器中查看 hello-node 应用程序
- en: 'Before we finish looking at Minikube, we should look at launching the cluster
    application we have been running in the previous chapters. To do this, run the
    following commands to create the deployment, expose the service, and get some
    information on the running pods and services:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对 Minikube 的查看之前，我们应该看看如何启动我们在前几章中运行的集群应用程序。为此，运行以下命令来创建部署，公开服务，并获取正在运行的
    Pod 和服务的一些信息：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once launched, we can list the URLs of all of the exposed services on our cluster
    node by running the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，我们可以通过运行以下命令列出集群节点上所有公开服务的 URL：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Opening the URL for the cluster service in a browser should show the application
    as expected:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开集群服务的 URL 应该会显示应用程序，如预期所示：
- en: '![Figure 12.8 – Viewing the cluster application in a browser'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – 在浏览器中查看集群应用程序'
- en: '](img/image_00_0083.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0083.jpg)'
- en: Figure 12.8 – Viewing the cluster application in a browser
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 在浏览器中查看集群应用程序
- en: Before we move on to the next tool, let's have a quick look at some of the other
    Minikube commands.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个工具之前，让我们快速查看一下其他一些 Minikube 命令。
- en: Managing Minikube
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 Minikube
- en: There are a few other commands we can use to manage our cluster node. The first
    of which is a command that allows you to quickly access the Kubernetes dashboard.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些其他命令来管理我们的集群节点。其中第一个命令允许您快速访问 Kubernetes 仪表盘。
- en: Minikube dashboard
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minikube 仪表盘
- en: 'Accessing the Kubernetes dashboard is a little more straight forward using
    Minikube; in fact, it is just a single command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Minikube 访问 Kubernetes 仪表盘稍微简单一点；事实上，它只需要一个命令：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will enable the dashboard, launch the proxy, and then open the dashboard
    in your default browser:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用仪表盘，启动代理，并在您的默认浏览器中打开仪表盘：
- en: '![Figure 12.9 – Viewing the Kubernetes dashboard'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.9 – 查看 Kubernetes 仪表盘'
- en: '](img/image_00_0093.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0093.jpg)'
- en: Figure 12.9 – Viewing the Kubernetes dashboard
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 查看 Kubernetes 仪表盘
- en: 'There is no additional work to configure authentication needed this time. Also,
    you can use the following command to just get the URL you need to access the dashboard:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不需要额外配置认证工作。此外，您可以使用以下命令直接获取访问仪表盘所需的 URL：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will return something like the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似如下的输出：
- en: '![Figure 12.10 – Getting the dashboard URL'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.10 – 获取仪表盘 URL'
- en: '](img/image_00_0103.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0103.jpg)'
- en: Figure 12.10 – Getting the dashboard URL
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 获取仪表盘 URL
- en: Now let's look at launching a different version of Kubernetes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何启动不同版本的 Kubernetes。
- en: Minikube start with Kubernetes version
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minikube 启动时使用的 Kubernetes 版本
- en: 'When we first launched our cluster node, I mentioned it is possible to launch
    a cluster node with a different version of Kubernetes. Using the following command,
    we can launch a second cluster node running Kubernetes `v1.15.5`, which is the
    same version currently supported by Docker for Mac:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动集群节点时，我提到过可以启动一个运行不同版本 Kubernetes 的集群节点。使用以下命令，我们可以启动一个运行 Kubernetes
    `v1.15.5` 的第二个集群节点，这也是 Docker for Mac 当前支持的版本：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command should show you something similar to the output we originally
    saw when we first launched our cluster node:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该会显示类似于我们最初启动集群节点时所看到的输出：
- en: '![Figure 12.11 – Installing Kubernetes v1.15.5 on a second cluster node'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.11 – 在第二个集群节点上安装 Kubernetes v1.15.5'
- en: '](img/image_00_0113.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0113.jpg)'
- en: Figure 12.11 – Installing Kubernetes v1.15.5 on a second cluster node
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 在第二个集群节点上安装 Kubernetes v1.15.5
- en: As you can see, the process was pretty painless, and this time we did not get
    a complaint about potential compatibility issues with the locally installed `kubectl`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个过程相当简单，这次我们没有收到关于本地安装的 `kubectl` 可能存在兼容性问题的警告。
- en: 'We can view the different cluster nodes by running the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令查看不同的集群节点：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will list the available cluster nodes. To check which one you are currently
    using, run the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出可用的集群节点。要检查当前使用的是哪个节点，请运行以下命令：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To switch to a different cluster node run this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到其他集群节点，请运行此命令：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Make sure you use the cluster node name you want to switch to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用你想要切换到的集群节点名称：
- en: '![Figure 12.12 – Switching cluster nodes'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.12 – 切换集群节点'
- en: '](img/image_00_0123.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0123.jpg)'
- en: Figure 12.12 – Switching cluster nodes
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 切换集群节点
- en: Now we can switch cluster nodes, what about accessing them?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以切换集群节点，那如何访问这些节点呢？
- en: Minikube SSH
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minikube SSH
- en: 'Although you shouldn''t need to access the cluster node itself, you can run
    this to get shell access to the currently selected cluster node:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不需要直接访问集群节点，但你可以运行这个命令以获取当前选定集群节点的 Shell 访问权限：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is useful if you are curious to see what is going on under the hood.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解背后的原理，这个命令非常有用。
- en: Minikube stop and delete
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minikube 停止并删除
- en: 'The final commands we are going to look at are the ones to stop our cluster
    nodes or remove them altogether; you may have already guessed the command to stop
    a node:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要看的最后一组命令是停止集群节点或完全移除它们的命令；你可能已经猜到，停止节点的命令是：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will stop the currently selected cluster node, and it can easily be started
    up with the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止当前选定的集群节点，可以通过以下命令轻松重新启动：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can add `-p <profile name>` to stop or start another cluster node. To remove
    the cluster node, you can run this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加 `-p <profile name>` 来停止或启动另一个集群节点。要移除集群节点，你可以运行这个命令：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will remove the currently selected cluster node. Again, you can add `-p
    <profile name>` to interact with any other cluster node. Running the following
    will delete all of the cluster nodes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除当前选定的集群节点。同样，你可以添加 `-p <profile name>` 来与其他集群节点交互。运行以下命令将删除所有集群节点：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There is no warning or "are you sure?" prompt when running the `minikube delete`
    command, so please be careful.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `minikube delete` 命令时没有警告或“确定吗？”的提示，因此请小心操作。
- en: Minikube summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Minikube 概览
- en: As I am sure you will agree, Minikube has a wealth of options and is extremely
    straightforward to use. With it being part of the Kubernetes project itself, you
    will find that it is always a more up-to-date Kubernetes experience than you would
    get enabling Kubernetes in Docker for Mac or Docker for Windows, and it also has
    Linux support.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我相信你会同意的，Minikube 选项丰富，使用起来非常简便。由于它是 Kubernetes 项目的一部分，你会发现它总是提供比在 Docker
    for Mac 或 Docker for Windows 上启用 Kubernetes 更为最新的 Kubernetes 体验，并且它还支持 Linux。
- en: Finally, you also get an environment that is a lot closer to a CNCF-compliant
    Kubernetes cluster running on a public cloud, which we'll be looking at in more
    detail in [*Chapter 13*](B15659_13_Final_JM_ePub.xhtml#_idTextAnchor626), *Running
    Kubernetes in Public Clouds*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以获得一个更接近 CNCF 兼容的 Kubernetes 集群环境，这个环境运行在公共云上，我们将在 [*第 13 章*](B15659_13_Final_JM_ePub.xhtml#_idTextAnchor626)
    中详细讲解，*在公共云中运行 Kubernetes*。
- en: Minikube takes a similar approach to Docker in that it deploys a small managed
    virtual machine to run your environment. The next tool we are going to look at
    takes a more modern, and at the time of writing, experimental approach to running
    Kubernetes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 采用类似于 Docker 的方法，通过部署一个小型托管虚拟机来运行你的环境。我们接下来要介绍的工具，采用了一种更现代的、在撰写时仍为实验性的方式来运行
    Kubernetes。
- en: Deploying Kubernetes using kind
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 kind 部署 Kubernetes
- en: The next tool we are going to look at is Kind, which is short for **Kubernetes
    in Docker**. This is exactly what you think it would be, based on the name – a
    Kubernetes cluster node condensed down into a container. Kind is a very recent
    project – so recent, in fact, that at the time of writing it is still undergoing
    a lot of active development. Because of this, we aren't going to spend too much
    time on it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要介绍的工具是Kind，**Kubernetes in Docker**的缩写。正如其名字所示，它就是将Kubernetes集群节点压缩成一个容器。Kind是一个非常新的项目——事实上，它在写作时仍在进行大量活跃的开发。因此，我们不会花太多时间在它上面。
- en: Installing Kind
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Kind
- en: Like Minikube, Kind is distributed as a single static binary – meaning its installation
    is very similar.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 和Minikube一样，Kind作为一个单独的静态二进制文件进行分发——这意味着它的安装过程非常相似。
- en: 'To install it on macOS, we need to run the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS上安装它，我们需要运行以下命令：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On Windows, run this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，运行以下命令：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, on Linux, you can run the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Linux上，你可以运行以下命令：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The release page to confirm the version number can be found at [https://github.com/kubernetes-sigs/kind/releases/](https://github.com/kubernetes-sigs/kind/releases/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/kubernetes-sigs/kind/releases/](https://github.com/kubernetes-sigs/kind/releases/)找到确认版本号的发布页面。
- en: As we already have Docker installed, we don't need to worry about drivers, hypervisors,
    or anything to run a supporting virtual machine as Kind will simply use our local
    Docker installation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了Docker，我们不需要担心驱动程序、虚拟机管理程序或任何其他支持虚拟机的内容，因为Kind将直接使用我们本地的Docker安装。
- en: Launching a Kind cluster
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Kind集群
- en: 'Once the kind binary has been installed, launching a cluster node is a very
    simple process; just run the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Kind二进制文件，启动集群节点是一个非常简单的过程；只需运行以下命令：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see from the following Terminal output, this will download the necessary
    images and take care of configuring both the cluster and creating a context on
    your local Docker host so that you can use `kubectl` to interact with the cluster
    node:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的终端输出将下载必要的镜像，并配置集群以及在本地Docker主机上创建一个上下文，以便你可以使用`kubectl`与集群节点交互：
- en: '![Figure 12.13 – Launching a cluster node with Kind'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13 – 使用Kind启动集群节点'
- en: '](img/image_00_0132.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0132.jpg)'
- en: Figure 12.13 – Launching a cluster node with Kind
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 使用Kind启动集群节点
- en: Now that we have our cluster node up and running, let's do something with it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的集群节点已经启动并运行，我们来做点什么吧。
- en: Interacting with your Kubernetes cluster node
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与你的Kubernetes集群节点交互
- en: Now that we have our cluster node up and running, we can rerun the commands
    and launch a test application as we did in the previous section of the chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的集群节点已经启动并运行，我们可以像本章前面部分那样重新运行命令并启动一个测试应用程序。
- en: 'This time, we will be using the `kubectl` command on our Docker host, rather
    than using a wrapper; however, we will be adding a context to make sure that our
    Kind Kubernetes node cluster is used. This means that the commands we need to
    run look like the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用Docker主机上的`kubectl`命令，而不是使用包装器；然而，我们会添加一个上下文，以确保使用我们的Kind Kubernetes节点集群。这意味着我们需要运行的命令如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see from the following Terminal output, we again see similar output
    to the last time we queried our nodes, namespaces, and system pods:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的终端输出中，我们再次看到与上次查询节点、命名空间和系统Pod时类似的输出：
- en: '![Figure 12.14 – Viewing the nodes, namespaces, and system pods'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14 – 查看节点、命名空间和系统Pod'
- en: '](img/image_00_0142.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0142.jpg)'
- en: Figure 12.14 – Viewing the nodes, namespaces, and system pods
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 查看节点、命名空间和系统Pod
- en: 'Next, let''s deploy the **hello-node** application again, using the following
    commands:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们再次部署**hello-node**应用程序，使用以下命令：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So far so good, you may be thinking, but unfortunately that is about as far
    as we can take the installation with the current configuration – while we can
    deploy pods and services, Kind does not come with an Ingress controller by default
    at the moment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，你可能在想，但不幸的是，使用当前配置的安装过程只能进行到这一步——虽然我们可以部署Pod和服务，但Kind目前默认并不附带Ingress控制器。
- en: 'To enable an Ingress controller, we first have to delete our cluster. To do
    that, run the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Ingress控制器，我们首先需要删除我们的集群。为此，运行以下命令：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the cluster has been deleted, we can re-launch it with the Ingress configuration
    enabled. The configuration is too long to list here, but you can find a copy of
    it in the repository that accompanies this book in the `chapter12/kind` folder.
    To launch the cluster with the config, change to the `chapter12/kind` folder in
    your Terminal and run the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群被删除，我们可以重新启动它，并启用 Ingress 配置。配置内容太长，无法在此列出，但你可以在随书附带的仓库中的 `chapter12/kind`
    文件夹中找到一份副本。要使用配置启动集群，请在终端中切换到 `chapter12/kind` 文件夹，并运行以下命令：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once launched, the next step is to enable the NGINX Ingress controller. You
    will need to execute the following command to do this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，下一步是启用 NGINX Ingress 控制器。你需要执行以下命令来完成这一步：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That will configure the cluster to use the NGINX Ingress controller. The controller
    itself take a minute or two to launch – you can check the status by running the
    following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置集群使用 NGINX Ingress 控制器。控制器本身需要一两分钟才能启动——你可以通过运行以下命令检查其状态：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once you have the `Ingress-nginx-controller` pod ready and running, you can
    then relaunch the `hello-node` application using the `hello-node.yml` file in
    the `chapter12/kind` folder with this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Ingress-nginx-controller` pod 准备好并正在运行时，你可以使用 `chapter12/kind` 文件夹中的 `hello-node.yml`
    文件重新启动 `hello-node` 应用程序，命令如下：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once launched, you should be able to access the `hello-node` application at
    [http://localhost/hello-node/](http://localhost/hello-node/) as seen in the following
    screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，你应该可以访问 `hello-node` 应用程序，网址为 [http://localhost/hello-node/](http://localhost/hello-node/)，如下图所示：
- en: '![Figure 12.15 – The output of the hello-node application'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – hello-node 应用程序的输出](img/image_00_0152.jpg)'
- en: '](img/image_00_0152.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0152.jpg)'
- en: Figure 12.15 – The output of the hello-node application
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – hello-node 应用程序的输出
- en: Once finished, you can delete the cluster with the `kind delete cluster` command.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以使用 `kind delete cluster` 命令删除集群。
- en: Kind summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kind 总结
- en: So, you may be thinking to yourself, what is the point of Kind – why on earth
    would you want to run a Kubernetes cluster in a single container? Well, its main
    use is to test Kubernetes itself; however, it could be used to test deployments
    as part of a continuous delivery or continuous deployment pipeline where you need
    to test your Kubernetes definition files are working as expected and your application
    launches without any problems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能会想，Kind 的意义何在——为什么你会想要在一个容器中运行一个 Kubernetes 集群呢？其实，它的主要用途是测试 Kubernetes
    本身；不过，它也可以用于测试部署，作为持续交付或持续部署流水线的一部分，在这里你需要测试 Kubernetes 定义文件是否按预期工作，并且你的应用程序能够无问题地启动。
- en: As it stands at the moment, Kind is probably too slow and too heavy in development
    to be used to develop on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Kind 可能在开发中过于缓慢且过于笨重，无法用于开发。
- en: Let's move onto the next tool, which takes us back to running a virtual machine
    to deploy our local Kubernetes cluster on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入下一个工具，它将我们带回到运行虚拟机来部署本地 Kubernetes 集群的场景。
- en: Deploying Kubernetes using MicroK8s
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MicroK8s 部署 Kubernetes
- en: Next up, we have MicroK8s by Canonical who, as you may remember from [*Chapter
    6*](B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187), *Docker Machine, Vagrant,
    and Multipass*, are the creators of Multipass and also the Linux distribution
    Ubuntu.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看由 Canonical 提供的 MicroK8s，正如你可能还记得的 [*第6章*](B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187)，*Docker
    Machine, Vagrant 和 Multipass*，他们是 Multipass 和 Ubuntu Linux 发行版的创始人。
- en: The mantra of the MicroK8s project is to provide a lightweight Kubernetes node
    with only a minimal number of basic services enabled by default while providing
    additional services as needed via plugins.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: MicroK8s 项目的口号是提供一个轻量级的 Kubernetes 节点，默认启用的仅是最少的基本服务，同时可以根据需要通过插件提供额外服务。
- en: Installing MicroK8s
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 MicroK8s
- en: Unlike Minikube and Kind, the standalone binary for MicroK8s only works on Linux-based
    machines. Because of this, we are going to use Multipass to launch a virtual machine
    and use that as our installation target.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Minikube 和 Kind 不同，MicroK8s 的独立二进制文件仅适用于基于 Linux 的机器。由于这个原因，我们将使用 Multipass
    启动虚拟机，并将其作为我们的安装目标。
- en: 'To launch the virtual machine, we need to run the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 启动虚拟机，我们需要运行以下命令：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the virtual machine is up and running, we can then enable and install
    MicroK8s with the following command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机启动并运行，我们可以通过以下命令启用并安装 MicroK8s：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once installed, it will take a little while for MicroK8s to start up and the
    cluster node to be ready to use. Run the following command to poll the status
    and check MicroK8s is up and running:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，MicroK8s 启动并准备好使用需要一些时间。运行以下命令来轮询状态并检查 MicroK8s 是否已启动：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next up, as MicroK8s by default is a minimal Kubernetes cluster node, we need
    to enable the `dns` and `Ingress` plugins, which will allow us to access our applications
    when we launch them:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，默认情况下 MicroK8s 是一个最小的 Kubernetes 集群节点，我们需要启用 `dns` 和 `Ingress` 插件，这将允许我们在启动应用程序时访问它们：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once enabled, the final thing we need to do is get a copy of the configuration
    on our host machine. To do this, run the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用，我们需要在主机上获取配置的最后一步。为此，请运行以下命令：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will leave us with a file called `microk8s.yml` in the current directory
    on our host machine. We can now use this configuration when we run `kubectl` to
    access our newly launched and configured MicroK8s Kubernetes cluster node.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的主机当前目录留下一个名为 `microk8s.yml` 的文件。现在，我们可以在运行 `kubectl` 时使用此配置来访问我们新启动和配置的
    MicroK8s Kubernetes 集群节点。
- en: Interacting with your Kubernetes cluster node
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与您的 Kubernetes 集群节点进行交互
- en: Now that we have our cluster node up and running, we can rerun the commands
    and launch a test application as we did in the previous section of the chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的集群节点已经启动并运行，我们可以重新运行命令并启动一个测试应用程序，就像我们在本章的前一节中所做的那样。
- en: 'As already mentioned, this time we will be using the `kubectl` command on our
    host machine and pass the flag to make sure it uses the `microk8s.yml` config
    file. This means that the commands we need to run look like the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这次我们将在主机上使用 `kubectl` 命令，并传递标志以确保它使用 `microk8s.yml` 配置文件。这意味着我们需要运行的命令如下所示：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see from the following Terminal output, we again see similar output
    to the last time we queried our nodes and namespaces until we get to the system
    pods:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从以下终端输出中可以看到的那样，我们再次看到类似于上次查询节点和命名空间直到系统 pod 的输出：
- en: '![Figure 12.16 – Viewing the nodes, namespaces, and system pods'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.16 – 查看节点、命名空间和系统 pod'
- en: '](img/image_00_0162.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0162.jpg)'
- en: Figure 12.16 – Viewing the nodes, namespaces, and system pods
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – 查看节点、命名空间和系统 pod
- en: The reason why we can't see any of the Pods outside of the `coredns` one is
    that the user attached to the configuration we downloaded doesn't have the necessary
    permissions to do so. Although, that's not a problem for us as we don't need to
    touch those pods.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以看不到 `coredns` 之外的任何 Pod 是因为我们下载的配置所附带的用户没有必要的权限。尽管如此，这对我们来说并不是问题，因为我们不需要触及那些
    pod。
- en: 'Next up, we can launch the `hello-node` application. This time, we will use
    the YAML file straight out of the GitHub repository by running the following command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以启动 `hello-node` 应用程序。这次，我们将直接从 GitHub 存储库中使用 YAML 文件，运行以下命令：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The reason we are using this file is that it has the definition for the Ingress
    controller, which means we just need to get the IP address of our MicroK8s cluster
    node and then enter that URL into our browser. To get the IP address, run the
    following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个文件的原因是它具有 Ingress 控制器的定义，这意味着我们只需获取 MicroK8s 集群节点的 IP 地址，然后在浏览器中输入该 URL。要获取
    IP 地址，请运行以下命令：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once you know the IP address, which should be listed as IPv4, open a browser
    and go to `https://<IP Address>/hello-node/`. In my case, the URL was `https://192.168.64.16/hello-node/`.
    You will note that, this time, we are using HTTPS rather than HTTP. That is because
    the Ingress controller we enabled installs a self-signed certificate and redirects
    all traffic to HTTPS. Depending on the browser settings, you may be asked to accept
    or install the certificate when going to the page.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您知道 IP 地址，应该列为 IPv4，打开浏览器并转到 `https://<IP Address>/hello-node/`。在我的情况下，URL
    是 `https://192.168.64.16/hello-node/`。您会注意到，这次我们使用的是 HTTPS 而不是 HTTP。这是因为我们启用的
    Ingress 控制器安装了自签名证书，并将所有流量重定向到 HTTPS。根据浏览器设置，可能会要求您在访问页面时接受或安装证书。
- en: Once finished, you can delete the cluster node using the `multipass delete --purge
    microk8s` command. Also, don't forget to remove the `microk8s.yml` file. Once
    you have deleted the cluster, the config file would not work if you were to relaunch
    it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以使用 `multipass delete --purge microk8s` 命令删除集群节点。还要记得删除 `microk8s.yml`
    文件。一旦删除集群，如果要重新启动它，配置文件将不起作用。
- en: MicroK8s summary
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroK8s 总结
- en: MicroK8s delivers on its promise of a small, lightweight, but still functional
    and extendable Kubernetes cluster controller. Coupled with Multipass, you are
    easily able to spin up a virtual machine and quickly bootstrap your Kubernetes
    cluster node on your local workstation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: MicroK8s兑现了它的小巧、轻量，但仍然功能强大且可扩展的Kubernetes集群控制器的承诺。结合Multipass，您可以轻松启动一个虚拟机，并快速在本地工作站引导Kubernetes集群节点。
- en: Also, Canonical has made sure that MicroK8s isn't just for local use; the cluster
    node itself can be considered to be production-ready, meaning that it is perfect
    for running Kubernetes on both edge and IoT devices – both of which traditionally
    have lower specifications and would normally run a single node.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Canonical确保了MicroK8s不仅仅是为了本地使用；集群节点本身可以被视为生产就绪，这意味着它非常适合在边缘计算和物联网设备上运行Kubernetes——这两种设备通常规格较低，通常只会运行单个节点。
- en: The final tool we are going to look at will allow us to run multiple Kubernetes
    nodes locally, taking us closer to what a production environment might look like.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的最后一个工具将允许我们在本地运行多个Kubernetes节点，让我们更接近生产环境的样子。
- en: Deploying Kubernetes using K3s
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用K3s部署Kubernetes
- en: The final tool we are going to take a look at is K3s from Rancher. Like MicroK8s,
    K3s is a lightweight Kubernetes distribution designed for edge and IoT devices.
    This again makes it perfect for local development too as K3s is also a certified
    Kubernetes distribution – as is Docker, Kind, and MicroK8s.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的最终工具是Rancher的K3s。像MicroK8s一样，K3s是一个轻量级的Kubernetes发行版，专为边缘计算和物联网设备设计。这使得它同样非常适合本地开发，因为K3s也是一个认证的Kubernetes发行版——就像Docker、Kind和MicroK8s一样。
- en: Important note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may be wondering why on earth it is called K3s. There is some logic behind
    it. As Rancher's main design aim for K3s was to produce something with half of
    the memory footprint of a typical Kubernetes distribution, they decided that as
    Kubernetes is a 10-letter word but is stylized as K8s, then their distribution
    would be half the size – 5 letters – and would, therefore, be stylized as K3s.
    However, there is no long-form for K3s and nor is there an official pronunciation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么它叫K3s。背后有一定的逻辑。Rancher设计K3s的主要目标是创造一个内存占用只有传统Kubernetes发行版一半的工具，因此他们决定既然Kubernetes是一个10个字母的词，并且以K8s样式呈现，那么他们的发行版将会缩小一半——5个字母——因此，K3s也采用了这样的命名方式。然而，K3s并没有长形式，也没有官方发音。
- en: Finally, K3s supports multi-node clusters, so we are going to look at building
    a three-node cluster. The commands we'll be using in this section of the chapter
    will cover macOS and Linux systems as we will be creating environment variables
    and using non-Windows tools to streamline the installation process as much as
    possible.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，K3s支持多节点集群，因此我们将学习如何构建一个三节点集群。本章这一部分的命令将覆盖macOS和Linux系统，因为我们将创建环境变量并使用非Windows工具，以尽可能简化安装过程。
- en: Installing K3s
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装K3s
- en: 'Like MicroK8s, we are going to be using Multipass to launch our host machines.
    To do this, run the following commands:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 像MicroK8s一样，我们将使用Multipass来启动我们的主机。为此，请运行以下命令：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once we have our three VMs up and running, we can configure the master node
    by running the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了三台虚拟机，就可以通过运行以下命令来配置主节点：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Once we have the master node up and running, we need a little information to
    be able to bootstrap the two remaining nodes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的主节点启动并运行，我们需要一些信息来引导剩余的两个节点。
- en: 'The first piece of information we need is the URL of the master node. To create
    an environment variable, we can run the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一条信息是主节点的URL。要创建环境变量，我们可以运行以下命令：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we have the URL of the master node, we need to grab the access token. To
    do that, run the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了主节点的URL，接下来我们需要获取访问令牌。为此，请运行以下命令：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we have the two bits of information needed to bootstrap the nodes, we can
    run the following two commands:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了引导节点所需的两条信息，可以运行以下两个命令：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We should now have our three nodes configured, and all that is left is to configure
    our local `kubectl` so that it can interact with the cluster nodes. The first
    thing we need to do is copy the configuration to our local machine. To do this,
    run the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该已经配置好三台节点，剩下的就是配置我们的本地`kubectl`，以便它能够与集群节点进行交互。我们需要做的第一件事是将配置复制到本地机器。为此，请运行以下命令：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we were to use the configuration file as it is, then it would fail as, by
    default, K3s is configured to communicate on the localhost, so to update that
    run the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样使用配置文件，那么它会失败，因为默认情况下，K3s 配置为仅在本地主机上通信，因此要更新这一点，运行以下命令：
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, this replaces [https://127.0.0.1:6443](https://127.0.0.1:6443)
    with the value of `${K3SMASTER}` in our local `k3s.yml` configuration file. Once
    replaced, we can configure `kubectl` to use our `k3s.yml` configuration file for
    the remainder of the Terminal session by running the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这将用我们本地 `k3s.yml` 配置文件中的 `${K3SMASTER}` 值替换 [https://127.0.0.1:6443](https://127.0.0.1:6443)。替换后，我们可以配置
    `kubectl` 使用我们的 `k3s.yml` 配置文件，以便在接下来的终端会话中运行以下命令：
- en: '[PRE56]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that our cluster is accessible using our local kubectl binary, we can launch
    our application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过我们的本地 kubectl 二进制文件访问集群后，我们可以启动我们的应用程序。
- en: Interacting with your Kubernetes cluster nodes
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与你的 Kubernetes 集群节点进行交互
- en: 'Now that we have our cluster node up and running, we can rerun the commands
    and launch a test application as we did in the previous section of the chapter.
    This time, as we have configured `kubectl` to use our `k3s.yml` configuration
    file, we can just run the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的集群节点已经启动并运行，我们可以重新运行命令，并像在本章前面的部分那样启动测试应用程序。这次，鉴于我们已经配置 `kubectl` 使用我们的
    `k3s.yml` 配置文件，我们只需运行以下命令：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will give you something like the following Terminal output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你类似以下的终端输出：
- en: '![Figure 12.17 – Viewing the nodes, namespaces, and system pods'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.17 – 查看节点、命名空间和系统 pod'
- en: '](img/image_00_0172.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0172.jpg)'
- en: Figure 12.17 – Viewing the nodes, namespaces, and system pods
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 查看节点、命名空间和系统 pod
- en: 'Next, let''s launch the `hello-node` application, this time using the following
    commands:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动 `hello-node` 应用程序，这次使用以下命令：
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This will give you the following output, as you can see, we have any `EXTERNAL-IP`
    and `PORT(S)`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你以下输出，如你所见，我们有任何`EXTERNAL-IP`和`PORT(S)`：
- en: '![Figure 12.18 – Launching and exposing the hello-node application'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.18 – 启动并暴露 hello-node 应用程序'
- en: '](img/image_00_0181.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0181.jpg)'
- en: Figure 12.18 – Launching and exposing the hello-node application
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – 启动并暴露 hello-node 应用程序
- en: Adding the IP address with the second port should give you the URL to access
    the application, for example, I went to [http://192.168.64.19:31846/](http://192.168.64.19:31846/)
    and was presented with the `hello-node` application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第二端口的 IP 地址应该会给你访问应用程序的 URL，例如，我访问了[http://192.168.64.19:31846/](http://192.168.64.19:31846/)，并展示了`hello-node`应用程序。
- en: 'Next up, let''s launch our `cluster` application with the following commands:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用以下命令启动我们的 `cluster` 应用程序：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You might notice that this time, for `EXTERNAL-IP`, it says `<pending>`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这次在 `EXTERNAL-IP` 中，它显示 `<pending>`：
- en: '![Figure 12.19 – Launching and exposing the cluster application'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.19 – 启动并暴露集群应用程序'
- en: '](img/image_00_0191.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0191.jpg)'
- en: Figure 12.19 – Launching and exposing the cluster application
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 – 启动并暴露集群应用程序
- en: You shouldn't have to worry about that; just use the second port and the external
    IP exposed for the other server. This gave me a URL of [http://192.168.64.19:32042/](http://192.168.64.19:32042/)
    to access the `cluster` application on.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必担心这个；只需使用第二端口和另一个服务器暴露的外部 IP。这给了我一个访问`cluster`应用程序的 URL，[http://192.168.64.19:32042/](http://192.168.64.19:32042/)。
- en: 'You can also scale the cluster application using the following commands:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下命令扩展集群应用程序：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you are not following along, the Terminal output for this looks like the
    following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有跟上，终端输出看起来像下面这样：
- en: '![Figure 12.20 – Scaling the cluster application'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.20 – 扩展集群应用程序'
- en: '](img/image_00_0201.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0201.jpg)'
- en: Figure 12.20 – Scaling the cluster application
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.20 – 扩展集群应用程序
- en: 'Before we finish up, as we have more nodes to explore, let''s install the Kubernetes
    dashboard. To do this, run the following commands from your host machine. The
    first thing that is needed is to get the current version of the dashboard. To
    do this, run the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，鉴于我们还有更多节点要探索，先安装 Kubernetes 仪表板。为此，从你的主机运行以下命令。首先需要获取仪表板的当前版本。为此，运行以下命令：
- en: '[PRE61]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that we have the current version as an environment variable, we can run
    the following commands to launch the dashboard, add a user, and configure the
    user''s access:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将当前版本设置为环境变量，可以运行以下命令启动仪表板，添加用户并配置用户的访问权限：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With the dashboard installed and the user configured, we can grab the access
    token we will need to log in to the dashboard by running the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了仪表板并配置了用户后，我们可以通过运行以下命令来获取登录仪表板所需的访问令牌：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Make a note of the token as we will need it in a second. The last thing we
    need to do before accessing the dashboard is to start the Kubernetes proxy service
    by running the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 记下令牌，因为我们稍后需要它。在访问仪表板之前，我们需要做的最后一件事是通过运行以下命令启动 Kubernetes 代理服务：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With the proxy server running, open [http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/)
    in your preferred browser, enter the token you made a note of, and sign in:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理服务器运行时，打开 [http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/)
    在你喜欢的浏览器中，输入你记下的令牌，然后登录：
- en: '![Figure 12.21 – Opening the Kubernetes dashboard on our K3s node cluster'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.21 – 在我们的 K3s 节点集群上打开 Kubernetes 仪表板'
- en: '](img/image_00_0211.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0211.jpg)'
- en: Figure 12.21 – Opening the Kubernetes dashboard on our K3s node cluster
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.21 – 在我们的 K3s 节点集群上打开 Kubernetes 仪表板
- en: Once you have finished with your K3s cluster, you can remove it using `the multipass
    delete --purge k3smaster k3snode1 k3snode2` command.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了 K3s 集群的使用，你可以通过 `the multipass delete --purge k3smaster k3snode1 k3snode2`
    命令删除它。
- en: One more thing – K3d
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有一件事 – K3d
- en: Finally, Rancher also provides K3d. Like Kind, this is the entire Kubernetes
    distribution in a single container, which means that not only can you use K3s
    as your local development environment but it is also straightforward to introduce
    to your CI/CD pipelines.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rancher 也提供了 K3d。像 Kind 一样，这是一个包含整个 Kubernetes 发行版的单一容器，这意味着你不仅可以将 K3s 用作本地开发环境，而且也很容易将其引入到
    CI/CD 流水线中。
- en: 'Before we summarize K3s, let''s take a very quick look at how you can get K3d
    up and running on a macOS and Linux host, starting with Linux. To install the
    `k3d` command, run the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结 K3s 之前，让我们非常快速地了解一下如何在 macOS 和 Linux 主机上启动 K3d，先从 Linux 开始。要安装 `k3d` 命令，运行以下命令：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Or, if you are using macOS, you can use Homebrew to install it using the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用的是 macOS，你可以通过 Homebrew 安装它，使用以下命令：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once K3d is installed (I installed version 1.7), there are four commands we
    are going to look at:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 K3d（我安装的是 1.7 版本），我们将要查看四个命令：
- en: '`k3d cluster create k3s-default`: This command will create a K3d-powered Kubernetes
    cluster called **k3s-default**.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k3d cluster create k3s-default`：此命令将创建一个名为 **k3s-default** 的 K3d 驱动的 Kubernetes
    集群。'
- en: '`k3d kubeconfig merge k3s-default --switch-context`: This will configure your
    local `kubectl` to talk to the **k3s-default** cluster.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k3d kubeconfig merge k3s-default --switch-context`：这将配置你的本地 `kubectl` 使其与
    **k3s-default** 集群通信。'
- en: 'Now that you have a cluster up and running, you can interact with it like any
    other Kubernetes cluster, for example, by running the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启动了一个集群，你可以像与其他 Kubernetes 集群一样与它互动，例如，通过运行以下命令：
- en: '[PRE67]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This gives us the following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '![Figure 12.22 – Running commands against our K3d cluster'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.22 – 在我们的 K3d 集群上运行命令'
- en: '](img/image_00_0221.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image_00_0221.jpg)'
- en: Figure 12.22 – Running commands against our K3d cluster
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22 – 在我们的 K3d 集群上运行命令
- en: '`k3dcluster delete k3s-default` is the final command of the four we are going
    to look at, and as you might have guessed, this deletes the cluster.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k3dcluster delete k3s-default` 是我们将要查看的四个命令中的最后一个，正如你可能猜到的，这个命令会删除集群。'
- en: 'K3d is very much in active development. In fact, a complete rewrite of the
    K3d wrapper has just been completed so if the preceding commands, which cover
    the new version 3, do not work, then try the following commands, which cover the
    old version:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: K3d 正在积极开发中。事实上，K3d 包装器的完整重写刚刚完成，所以如果前面的命令（针对新版本 3）不工作，尝试以下命令，这些命令是针对旧版本的：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For more up-to-date news on the development of K3d, see the project's GitHub
    page, which is linked in the *Further reading* section of this chapter.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 想要获取关于 K3d 开发的最新消息，可以查看项目的 GitHub 页面，链接在本章的*进一步阅读*部分中。
- en: K3s summary
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K3s 概述
- en: Like MicroK8s, K3s delivers on its promise of a lightweight Kubernetes distribution.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 像 MicroK8s 一样，K3s 实现了它作为轻量级 Kubernetes 发行版的承诺。
- en: Personally, I find K3s to be the better of the two as it feels more like a fully
    formed Kubernetes distribution than MicroK8s does.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我认为 K3s 更好，因为它比 MicroK8s 更像一个完整的 Kubernetes 发行版。
- en: The other thing K3s has going for it is that deploying a local multi-node cluster
    is a relatively painless experience. This should give your local development environment
    a much more production-like feeling, and while Minikube does allow you to launch
    a multi-node cluster, the functionality is still in its infancy and is not really
    ready for public consumption yet.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: K3s 另一个优点是，部署本地多节点集群是一种相对轻松的体验。这将使你的本地开发环境更接近生产环境，尽管 Minikube 也允许你启动多节点集群，但其功能仍处于初期阶段，尚未准备好供公众使用。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at four different tools for launching both single-node
    and multi-node Kubernetes clusters. We discovered that while the method of launching
    each of the clusters is slightly different, once they are up and running, you
    get a mostly consistent experience once you start to interact with them using
    standard Kubernetes tools like `kubectl`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了四种不同的工具，用于启动单节点和多节点的 Kubernetes 集群。我们发现，虽然启动每个集群的方法略有不同，但一旦集群启动并运行，你会发现使用标准的
    Kubernetes 工具（如 `kubectl`）与它们交互时，体验大致一致。
- en: 'At this point, I should probably confess something: two of the four tools we
    have covered in this chapter do not actually use Docker in the traditional sense
    – both MicroK8s and K3s actually use **containerd**.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我应该坦白一下：我们在本章中介绍的四个工具中的两个，实际上并没有像传统意义上的 Docker 那样使用 Docker——MicroK8s 和 K3s
    实际上使用的是 **containerd**。
- en: As you may recall from [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, **containerd** is an easily embeddable container runtime. It
    started life at Docker Inc., but the project was donated to the **Cloud Native
    Computing Foundation** (**CNCF**) – it is the container runtime of the Moby project,
    which Docker uses as its upstream project.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从 [*第一章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)《*Docker 概述*》中回忆的那样，**containerd**
    是一个易于嵌入的容器运行时。它最初由 Docker Inc. 开发，但该项目已捐赠给 **云原生计算基金会** (**CNCF**)——它是 Moby 项目的容器运行时，而
    Docker 使用 Moby 作为其上游项目。
- en: It is not only small and lightweight, but it also offers full OCI Image and
    OCI Runtime specification support, meaning that it is 100% compatible with Docker
    images and also the way that Docker runs containers.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅小巧轻便，还提供了完整的 OCI 镜像和 OCI 运行时规范支持，这意味着它与 Docker 镜像及 Docker 运行容器的方式完全兼容。
- en: In the next chapter, we are going to move away from running Kubernetes locally
    and take our clusters to the cloud.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将不再在本地运行 Kubernetes，而是将集群带入云端。
- en: Questions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True or false: Kind is recommended for production use.'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对错题：Kind 推荐用于生产环境使用吗？
- en: Name at least two tools we have looked at in this chapter that are able to run
    inside a Docker container.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举出本章中至少两个能够在 Docker 容器中运行的工具。
- en: If you had an ARM-powered IoT device, which two Kubernetes distributions that
    we have covered in this chapter could you use?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个 ARM 架构的 IoT 设备，你可以使用本章中介绍的哪两个 Kubernetes 发行版？
- en: Further reading
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Some of the Google tools, presentations, and white papers mentioned at the
    start of the chapter can be found here:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开头提到的部分 Google 工具、演示文稿和白皮书可以在这里找到：
- en: 'Minikube: [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Minikube: [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/)'
- en: 'Kind: [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kind: [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)'
- en: 'MicroK8s: [https://microk8s.io/](https://microk8s.io/)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MicroK8s: [https://microk8s.io/](https://microk8s.io/)'
- en: 'K3s: [https://k3s.io/](https://k3s.io/)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'K3s: [https://k3s.io/](https://k3s.io/)'
- en: 'K3d: [https://github.com/rancher/k3d](https://github.com/rancher/k3d)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'K3d: [https://github.com/rancher/k3d](https://github.com/rancher/k3d)'
- en: 'containerd: [https://containerd.io/](https://containerd.io/)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'containerd: [https://containerd.io/](https://containerd.io/)'
- en: 'OCI Image and Runtime Specification: [https://www.opencontainers.org/](https://www.opencontainers.org/)'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OCI 镜像和运行时规范: [https://www.opencontainers.org/](https://www.opencontainers.org/)'
- en: 'Certified Kubernetes offerings: [https://www.cncf.io/certification/software-conformance/](https://www.cncf.io/certification/software-conformance/)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '认证的 Kubernetes 发行版: [https://www.cncf.io/certification/software-conformance/](https://www.cncf.io/certification/software-conformance/)'
