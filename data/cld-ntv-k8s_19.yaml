- en: '*Chapter 15*: Stateful Workloads on Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：Kubernetes 上的有状态工作负载'
- en: This chapter details the current state of the industry when it comes to running
    stateful workloads in databases. We will discuss the use of Kubernetes (and popular
    open source projects) for running databases, storage, and queues on Kubernetes.
    Case study tutorials will include running object storage, a database, and a queue
    system on Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了当前在数据库中运行有状态工作负载的行业现状。我们将讨论使用 Kubernetes（以及流行的开源项目）在 Kubernetes 上运行数据库、存储和队列。案例研究教程将包括在
    Kubernetes 上运行对象存储、数据库和队列系统。
- en: In this chapter, we will first understand how stateful applications run on Kubernetes
    and then learn how to use Kubernetes storage for stateful applications. We will
    then learn how to run databases on Kubernetes, as well as covering messaging and
    queues. Let's start with a discussion of why stateful applications are much more
    complex than stateless applications on Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解有状态应用如何在 Kubernetes 上运行，然后学习如何为有状态应用使用 Kubernetes 存储。接下来，我们将学习如何在
    Kubernetes 上运行数据库，并讨论消息和队列。我们先从讨论为什么有状态应用比无状态应用在 Kubernetes 上更复杂开始。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding stateful applications on Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 上的有状态应用
- en: Using Kubernetes storage for stateful applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 存储进行有状态应用
- en: Running databases on Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行数据库
- en: Implementing messaging and queues on Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上实现消息和队列
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods for getting up and running with Kubernetes
    quickly, and for instructions on how to install the kubectl tool.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中详细介绍的命令，你需要一台支持 `kubectl` 命令行工具并且有一个工作的 Kubernetes 集群的计算机。请参见[*第1章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)，*与
    Kubernetes 通信*，了解几种快速启动 Kubernetes 的方法，并获得如何安装 kubectl 工具的说明。
- en: 'The code used in this chapter can be found in the book''s GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在书籍的 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15)'
- en: Understanding stateful applications on Kubernetes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 上的有状态应用
- en: Kubernetes provides excellent primitives for running both stateless and stateful
    applications, but stateful workloads have taken longer to mature on Kubernetes.
    However, in recent years, some high-profile Kubernetes-based stateful application
    frameworks and projects have proven the increasing maturity of stateful applications
    on Kubernetes. Let's review some of these first in order to set the stage for
    the rest of the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了出色的原语来运行无状态和有状态应用，但有状态工作负载在 Kubernetes 上的成熟度要花费更长时间。然而，近年来，一些高调的
    Kubernetes 基础的有状态应用框架和项目证明了有状态应用在 Kubernetes 上的逐步成熟。让我们先回顾一下其中的一些，为本章的其他部分奠定基础。
- en: Popular Kubernetes-native stateful applications
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的 Kubernetes 原生有状态应用
- en: There are many types of stateful applications. Though most applications are
    stateful, only certain components in those applications store *state* data. We
    can remove these specific stateful components from applications and focus on those
    components in our review. In this book, we'll talk about databases, queues, and
    object storage, leaving out persistent storage components such as those we reviewed
    in [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166), *Storage on
    Kubernetes*. We'll also go over a few, less generic components as honorable mentions.
    Let's start with databases!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的有状态应用。尽管大多数应用是有状态的，但只有其中某些组件存储了*状态*数据。我们可以从应用中剔除这些特定的有状态组件，专注于这些组件进行回顾。在本书中，我们将讨论数据库、队列和对象存储，排除像在[*第7章*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166)中回顾的持久存储组件，*Kubernetes
    上的存储*。我们还会提到一些较少通用的组件，作为荣誉提名。我们从数据库开始吧！
- en: Kubernetes-compatible databases
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 兼容的数据库
- en: 'In addition to typical **databases** (**DBs**) and key-value stores such as
    **Postgres**, **MySQL**, and **Redis** that can be deployed on Kubernetes with
    StatefulSets or community operators, there are some major made-for-Kubernetes
    options:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了典型的 **数据库**（**DBs**）和键值存储，如 **Postgres**、**MySQL** 和 **Redis**，这些都可以使用 StatefulSets
    或社区操作器在 Kubernetes 上进行部署外，还有一些专为 Kubernetes 设计的重要选项：
- en: '**CockroachDB**: A distributed SQL database that can be deployed seamlessly
    on Kubernetes'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CockroachDB**：一种分布式 SQL 数据库，可以无缝地在 Kubernetes 上部署'
- en: '**Vitess**: A MySQL sharding orchestrator that allows global scalability for
    MySQL, also installable on Kubernetes via an operator'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vitess**：MySQL 分片协调器，允许 MySQL 的全球可扩展性，也可以通过操作器在 Kubernetes 上安装'
- en: '**YugabyteDB**: A distributed SQL database similar to **CockroachDB** that
    also supports Cassandra-like querying'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YugabyteDB**：一种分布式 SQL 数据库，类似于 **CockroachDB**，也支持类似 Cassandra 的查询'
- en: Next, let's look at queuing and messaging on Kubernetes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下 Kubernetes 上的队列和消息传递。
- en: Queues, streaming, and messaging on Kubernetes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 上的队列、流处理和消息传递
- en: 'Again, there are industry-standard options such as **Kafka** and **RabbitMQ**
    that can be deployed on Kubernetes using community Helm charts and operators,
    in addition to some purpose-made open- and closed-source options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一些行业标准的选项，如 **Kafka** 和 **RabbitMQ**，可以使用社区 Helm charts 和操作器在 Kubernetes
    上进行部署，除此之外，还有一些专门制作的开源和闭源选项：
- en: '**NATS**: Open source messaging and streaming system'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NATS**：开源消息和流处理系统'
- en: '**KubeMQ**: Kubernetes-native message broker'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KubeMQ**：原生 Kubernetes 消息代理'
- en: Next, let's look at object storage on Kubernetes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Kubernetes 上的对象存储。
- en: Object storage on Kubernetes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 上的对象存储
- en: 'Object storage takes volume-based persistent storage from Kubernetes and adds
    on an object storage layer, similar to (and in many cases compatible with the
    API of) Amazon S3:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储从 Kubernetes 中获取基于卷的持久存储，并添加一个对象存储层，类似于（并且在许多情况下兼容）Amazon S3 的 API：
- en: '**Minio**: S3-compatible object storage built for high performance.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minio**：与 S3 兼容的对象存储，专为高性能设计。'
- en: '**Open IO**: Similar to *Minio*, this has high performance and supports S3
    and Swift storage.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Open IO**：类似于 *Minio*，具有高性能，支持 S3 和 Swift 存储。'
- en: Next, let's look at a few honorable mentions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下几项荣誉提名。
- en: Honorable mentions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 荣誉提名
- en: 'In addition to the preceding generic components, there are some more specialized
    (but still categorical) stateful applications that can be run on Kubernetes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的通用组件外，还有一些更专门（但仍然是分类性的）有状态应用程序可以在 Kubernetes 上运行：
- en: '**Key and auth management**: **Vault**, **Keycloak**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥和身份管理**：**Vault**、**Keycloak**'
- en: '**Container registries**: **Harbor**, **Dragonfly**, **Quay**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器注册表**：**Harbor**、**Dragonfly**、**Quay**'
- en: '**Workflow management**: **Apache Airflow** with a Kubernetes Operator'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流管理**：**Apache Airflow** 与 Kubernetes 操作器'
- en: Now that we've reviewed a few categories of stateful applications, let's talk
    about how these state-heavy applications are typically implemented on Kubernetes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了一些有状态应用程序的类别，让我们讨论一下这些状态密集型应用程序通常是如何在 Kubernetes 上实现的。
- en: Understanding strategies for running stateful applications on Kubernetes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解在 Kubernetes 上运行有状态应用程序的策略
- en: Though there is nothing inherently wrong with deploying a stateful application
    on Kubernetes with a ReplicaSet or Deployment, you will find that the majority
    of stateful applications on Kubernetes use StatefulSets. We talked about StatefulSets
    in [*Chapter 4*](B14790_04_Final_PG_ePub.xhtml#_idTextAnchor106), *Scaling and
    Deploying Your Application*, but why are they so useful for applications? We will
    review and answer this question in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 ReplicaSet 或 Deployment 在 Kubernetes 上部署有状态应用程序本身没有问题，但你会发现大多数在 Kubernetes
    上运行的有状态应用程序使用的是 StatefulSets。我们在[*第 4 章*](B14790_04_Final_PG_ePub.xhtml#_idTextAnchor106)《扩展和部署你的应用程序》中讨论过
    StatefulSets，但为什么它们对应用程序如此有用呢？我们将在本章中回顾并解答这个问题。
- en: The main reason is Pod identity. Many distributed stateful applications have
    their own clustering mechanism or consensus algorithm. In order to smooth over
    the process for these types of applications, StatefulSets provide static Pod naming
    based on an ordinal system, starting from `0` to `n`. This, in combination with
    a rolling update and creation method, makes it much easier for applications to
    cluster themselves, which is extremely important for cloud-native databases such
    as CockroachDB.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是 Pod 的身份。许多分布式有状态应用程序有自己的集群机制或共识算法。为了平滑处理这些类型应用程序的过程，StatefulSets 提供了基于序号系统的静态
    Pod 命名，从 `0` 到 `n`。结合滚动更新和创建方法，使得应用程序更容易自我集群化，这对于像 CockroachDB 这样的云原生数据库来说非常重要。
- en: To illustrate how and why StatefulSets can help run stateful applications on
    Kubernetes, let's look at how we might run MySQL on Kubernetes with StatefulSets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 StatefulSets 如何以及为什么能帮助在 Kubernetes 上运行有状态应用程序，让我们看看如何在 Kubernetes 上使用
    StatefulSets 运行 MySQL。
- en: Now, to be clear, running a single Pod of MySQL on Kubernetes is extremely simple.
    All we need to do is find a MySQL container image and ensure that it has the proper
    configuration and `startup` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了明确，在 Kubernetes 上运行单个 MySQL Pod 是非常简单的。我们需要做的就是找到一个 MySQL 容器镜像，并确保它具有正确的配置和
    `startup` 命令。
- en: However, when we look to scale our database, we start to run into issues. Unlike
    a simple stateless application, where we can scale our deployment without creating
    new state, MySQL (like many other DBs) has its own method of clustering and consensus.
    Each member of a MySQL cluster knows about the other members, and most importantly,
    it knows which member of the cluster is the leader. This is how databases like
    MySQL can offer consistency guarantees and **Atomicity, Consistency, Isolation,
    Durability** (**ACID**) compliance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试扩展我们的数据库时，就会遇到一些问题。与简单的无状态应用程序不同，在无状态应用程序中，我们可以在不创建新状态的情况下扩展我们的部署，而
    MySQL（像许多其他数据库一样）有自己的集群和共识方法。MySQL 集群中的每个成员都知道其他成员，最重要的是，它知道集群中的哪个成员是领导者。这就是像
    MySQL 这样的数据库能够提供一致性保证和 **原子性、一致性、隔离性、持久性**（**ACID**）合规性的方式。
- en: Therefore, since each member in a MySQL cluster needs to know about the other
    members (and most importantly, the master), we need to run our DB Pods in a way
    that means they have a common way to find and communicate with the other members
    of the DB cluster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于 MySQL 集群中的每个成员都需要了解其他成员（最重要的是主节点），我们需要以一种方式运行我们的数据库 Pod，使它们能够以一种共同的方式找到并与数据库集群中的其他成员进行通信。
- en: The way that StatefulSets offer this is, as we mentioned at the beginning of
    the section, via ordinal Pod numbering. This way, applications that need to self-cluster
    while running on Kubernetes know that a common naming scheme starting from `0`
    to `n` will be used. In addition, when a Pod at a specific ordinal restarts –
    for instance, `mysql-pod-2` – the same PersistentVolume will be mounted to the
    new Pod that starts in that ordinal spot. This allows for stateful consistency
    between restarts for a single Pod in a StatefulSet, which makes it much easier
    for applications to form a stable cluster.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets 提供这种功能的方式是，正如我们在本节开始时提到的，通过序号 Pod 编号。通过这种方式，应用程序在 Kubernetes 上运行时，如果需要自我集群化，它们知道会使用从
    `0` 到 `n` 的共同命名方案。此外，当特定序号的 Pod 重启时——例如，`mysql-pod-2`——同一个 PersistentVolume 将会挂载到在该序号位置启动的新
    Pod 上。这允许在 StatefulSet 中单个 Pod 的重启之间保持状态一致性，这使得应用程序更容易形成稳定的集群。
- en: To see how this works in practice, let's look at a StatefulSet specification
    for MySQL.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这在实践中是如何工作的，让我们看看 MySQL 的 StatefulSet 规范。
- en: Running MySQL on StatefulSets
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 StatefulSets 上运行 MySQL
- en: The following YAML spec is adapted from the Kubernetes documentation version.
    It shows how we can run MySQL clusters on StatefulSets. We will review each part
    of the YAML spec separately, so we can understand exactly how the mechanisms interact
    with StatefulSet guarantees.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 YAML 规范是根据 Kubernetes 文档版本调整的。它展示了我们如何在 StatefulSets 上运行 MySQL 集群。我们将分别回顾
    YAML 规范的每一部分，以便我们能确切理解这些机制如何与 StatefulSet 保证进行交互。
- en: 'Let''s start with the first part of the spec:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从规范的第一部分开始：
- en: statefulset-mysql.yaml
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: statefulset-mysql.yaml
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we are going to be creating a MySQL cluster with three `replicas`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将创建一个具有三个 `replicas` 的 MySQL 集群。
- en: 'There isn''t much else exciting about this piece, so let''s move onto the start
    of `initContainers`. There will be quite a few containers running in this Pod
    between `initContainers` and regular containers, so we will explain each separately.
    What follows is the first `initContainer` instance:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容没有什么其他令人兴奋的地方，所以让我们继续讲解 `initContainers` 的开头。在这个 Pod 中，`initContainers`
    和常规容器之间会有相当多的容器在运行，因此我们将分别解释每个容器。接下来是第一个 `initContainer` 实例：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This first `initContainer`, as you can see, is the MySQL container image. Now,
    this doesn't mean that we won't have the MySQL container running constantly in
    the Pod. This is a pattern you will tend to see fairly often with complex applications.
    Sometimes the same container image is used as both an `initContainer` instance
    and a normally running container in a Pod. This is because that container has
    the correct embedded scripts and tools to do common setup tasks programmatically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个 `initContainer` 是 MySQL 容器镜像。现在，这并不意味着我们不会在 Pod 中持续运行 MySQL 容器。这种模式在复杂应用中相当常见。有时同一个容器镜像会被用作
    `initContainer` 实例和常规运行容器。这是因为该容器包含了正确的嵌入式脚本和工具，能够以编程方式完成常见的设置任务。
- en: In this example, the MySQL `initContainer` creates a file, `/mnt/conf.d/server-id.cnf`,
    and adds a `server` ID, corresponding to the Pod's `ordinal` ID in the StatefulSet,
    to the file. When writing the `ordinal` ID, it adds `100` as an offset, to get
    around the reserved value in MySQL of a `server-id` ID of `0`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，MySQL 的 `initContainer` 创建了一个文件 `/mnt/conf.d/server-id.cnf`，并向文件中添加了一个
    `server` ID，值对应于 StatefulSet 中 Pod 的 `ordinal` ID。当写入 `ordinal` ID 时，它会加上 `100`
    作为偏移量，以绕过 MySQL 中保留的 `server-id` 值为 `0` 的限制。
- en: Then, depending on whether the Pod `ordinal` D is `0` or not, it copies configuration
    for either a master or slave MySQL server to the volume.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据 Pod 的 `ordinal` D 是否为 `0`，它会将 MySQL 服务器的主节点或从节点配置复制到卷中。
- en: 'Next, let''s look at the second `initContainer` in the following section (we''ve
    left out some code with volume mount information for brevity, but the full code
    is available in the GitHub repository of the book):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下下一部分中的第二个 `initContainer`（我们省略了一些与卷挂载信息相关的代码以简化内容，但完整代码可以在本书的 GitHub
    仓库中找到）：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this `initContainer` isn't MySQL at all! Instead, the container
    image is a tool called Xtra Backup. Why do we need this container?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个 `initContainer` 根本不是 MySQL！相反，容器镜像是一个名为 Xtra Backup 的工具。我们为什么需要这个容器呢？
- en: Consider a situation where a brand-new Pod, with a brand-new, empty PersistentVolume
    joins the cluster. In this scenario, the data replication processes will need
    to copy all of the data via replication from the other members in the MySQL cluster.
    With large databases, this process could be exceedingly slow.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 设想一种情况，一个全新的 Pod，搭配一个全新且空的 PersistentVolume 加入集群。在这种情况下，数据复制进程需要通过复制其他 MySQL
    集群成员的数据来填充数据。对于大型数据库，这个过程可能非常缓慢。
- en: For this reason, we have an `initContainer` instance that loads in data from
    another MySQL Pod in the StatefulSet, so that the data replication capabilities
    of MySQL have something to start with. In a case where there is already data in
    the MySQL Pod, this loading of data does not occur. The `[[ -d /var/lib/mysql/mysql
    ]] && exit 0` line is the one that checks to see whether there is existing data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个 `initContainer` 实例，它从 StatefulSet 中的另一个 MySQL Pod 加载数据，这样 MySQL 的数据复制功能就有了起始数据。如果
    MySQL Pod 中已经有数据，则不会进行数据加载。`[[ -d /var/lib/mysql/mysql ]] && exit 0` 这一行代码会检查是否已有数据。
- en: Once these two `initContainer` instances have successfully completed their tasks,
    we have all our MySQL configuration courtesy of the first `initContainer`, and
    we have a somewhat recent set of data from another member in the MySQL StatefulSet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这两个 `initContainer` 实例成功完成任务，我们就拥有了第一个 `initContainer` 提供的所有 MySQL 配置，同时也获得了来自
    MySQL StatefulSet 中另一个成员的相对较新的数据。
- en: 'Now, let''s move on to the actual containers in the StatefulSet definition,
    starting with MySQL itself:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讲解 StatefulSet 定义中的实际容器，从 MySQL 本身开始：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this MySQL container setup is fairly basic. In addition to an
    environment variable, we mount the previously created configuration. This pod
    also has some liveness and readiness probe configuration – check the GitHub repository
    of this book for those.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个 MySQL 容器的设置相当基础。除了一个环境变量外，我们还挂载了之前创建的配置文件。这个 Pod 还有一些存活性（liveness）和就绪性（readiness）探针配置——有关这些配置，请查看本书的
    GitHub 仓库。
- en: 'Now, let''s move on and check out our final container, which will look familiar
    – it''s actually another instance of Xtra Backup! Let''s see how it is configured:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续查看我们的最后一个容器，这个容器看起来应该很熟悉——它实际上是 Xtra Backup 的另一个实例！让我们看看它是如何配置的：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This container setup is a bit complex, so let's review it section by section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器设置有点复杂，所以让我们一节一节地回顾它。
- en: We know from our `initContainers` that Xtra Backup loads in data from another
    Pod in the StatefulSet in order to get the Pod somewhat ready for replicating,
    to and from other members in the StatefulSet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 `initContainers` 中我们知道，Xtra Backup 会从 StatefulSet 中的其他 Pod 加载数据，以便让该 Pod
    为复制过程做准备，以便与 StatefulSet 中的其他成员进行数据复制。
- en: The Xtra Backup container in this case is the one that actually starts that
    replication! This container will first check to see whether the Pod it is running
    on is supposed to be a slave Pod in the MySQL cluster. If so, it will start a
    data replication process from the master.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Xtra Backup 容器实际上是启动复制过程的容器！这个容器首先会检查它所在的 Pod 是否应作为 MySQL 集群中的从属 Pod。如果是，它会启动从主节点的数据复制进程。
- en: Finally, the Xtra Backup container will also open a listener on port `3307`,
    which will send a clone of the data in the Pod, if requested. This is the setup
    that sends clone data to the other Pods in the StatefulSet when they request a
    clone. Remember that the first `initContainer` looks at other Pods in the StatefulSet,
    in order to get a clone. In the end, each Pod in the StatefulSet is able to request
    clones in addition to running a process that can send data clones to other Pods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Xtra Backup 容器还将在端口 `3307` 上开启一个监听器，若有请求，它会发送 Pod 中数据的克隆。这是当 StatefulSet
    中的其他 Pod 请求克隆时，发送克隆数据的设置。记住，第一个 `initContainer` 会查看 StatefulSet 中的其他 Pod，以获取克隆数据。最终，StatefulSet
    中的每个 Pod 都能够请求克隆数据，并且能够运行一个进程，向其他 Pod 发送数据克隆。
- en: 'Finally, to wrap up our spec, let''s look at `volumeClaimTemplate`. This section
    of the spec also lists volume mounts for the previous container and the volume
    setup for the Pod (but we''ve left that out for brevity. Check the GitHub repository
    of this book for the rest):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了结束我们的配置，来看看 `volumeClaimTemplate` 部分。这个部分也列出了前一个容器的卷挂载和 Pod 的卷设置（但我们为了简洁省略了这些内容。有关其余部分，请查看本书的
    GitHub 仓库）：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, there's nothing especially interesting about the volume setup
    for the last container or the volume list. However, it's worthwhile to note the
    `volumeClaimTemplates` section, because the data will remain the same as long
    as a Pod restarts at the same ordinal spot. A new Pod added to the cluster will
    instead start with a blank PersistentVolume, which will trigger the initial data
    clone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最后一个容器的卷设置或卷列表并没有什么特别的地方。然而，值得注意的是 `volumeClaimTemplates` 部分，因为只要 Pod 在相同的序列位置重新启动，数据就会保持不变。一个新添加到集群中的
    Pod 将会从一个空的 PersistentVolume 开始，这将触发初始数据克隆。
- en: All together, these features of StatefulSets, in combination with the correct
    configuration of Pods and tooling, allow for the easy scaling of a stateful DB
    on Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，StatefulSets 的这些特性，结合 Pod 和工具的正确配置，使得在 Kubernetes 上轻松扩展有状态数据库成为可能。
- en: Now that we've talked about why stateful Kubernetes applications may use StatefulSets,
    let's go ahead and implement some to prove it! We'll start with an object storage
    application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了为什么有状态的 Kubernetes 应用可能会使用 StatefulSets，那么让我们开始实现一些示例来验证这一点！我们将从一个对象存储应用开始。
- en: Deploying object storage on Kubernetes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上部署对象存储
- en: Object storage is different from filesystem or block storage. It presents a
    higher-level abstraction that encapsulates a file, gives it an identifier, and
    often includes versioning. The file can then be accessed via its specific identifier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储与文件系统或块存储不同。它提供了更高层次的抽象，封装了一个文件，赋予它一个标识符，并通常包括版本控制。然后可以通过其特定的标识符访问该文件。
- en: The most popular object storage service is probably AWS S3, but Azure Blob Storage
    and Google Cloud Storage are similar alternatives. In addition, there are several
    self-hosted object storage technologies that can be run on Kubernetes, which we
    reviewed in the previous section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的对象存储服务可能是 AWS S3，但 Azure Blob Storage 和 Google Cloud Storage 是类似的替代方案。此外，还有几种可以在
    Kubernetes 上运行的自托管对象存储技术，我们在前一部分中已有讨论。
- en: For this book, we will review the configuration and usage of **Minio** on Kubernetes.
    Minio is an object storage engine that emphasizes high performance and can be
    deployed on Kubernetes, in addition to other orchestration technologies such as
    **Docker Swarm** and **Docker Compose**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将审查在 Kubernetes 上配置和使用**Minio**。Minio 是一个高性能的对象存储引擎，可以部署在 Kubernetes
    上，此外也支持其他编排技术，如**Docker Swarm** 和 **Docker Compose**。
- en: Minio supports Kubernetes deployments using both an operator and a Helm chart.
    In this book, we will focus on the operator, but for more information on the Helm
    chart, check out the Minio docs at [https://docs.min.io/docs](https://docs.min.io/docs).
    Let's get started with the Minio Operator, which will let us review some cool
    community extensions to kubectl.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Minio 支持使用 Operator 和 Helm chart 在 Kubernetes 上部署。在本书中，我们将重点讲解 Operator，但有关
    Helm chart 的更多信息，请查看 Minio 文档 [https://docs.min.io/docs](https://docs.min.io/docs)。让我们从
    Minio Operator 开始，这样我们就可以查看一些很酷的社区扩展功能，增强 kubectl 的功能。
- en: Installing the Minio Operator
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Minio Operator
- en: Installing the Minio Operator will be quite different from anything we have
    done so far. Minio actually provides a `kubectl` plugin in order to manage the
    installation and configuration of the operator and Minio as a whole.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Minio Operator 与我们之前做的任何操作都大不相同。Minio 实际上提供了一个 `kubectl` 插件，用于管理 Operator
    和 Minio 的安装与配置。
- en: We haven't spoken much about `kubectl` plugins in this book, but they are a
    growing part of the Kubernetes ecosystem. `kubectl` plugins can provide additional
    functionality in the form of new `kubectl` commands.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们没有详细讨论 `kubectl` 插件，但它们是 Kubernetes 生态系统中一个不断增长的部分。`kubectl` 插件可以通过新命令提供额外的功能。
- en: In order to install the `minio` kubectl plugin, we use Krew, which is a plugin
    manager for `kubectl` that makes it easy to search and add `kubectl` plugins with
    a single command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装 `minio` kubectl 插件，我们使用 Krew，Krew 是一个 `kubectl` 插件管理工具，它可以轻松地搜索和添加 `kubectl`
    插件，只需一条命令。
- en: Installing Krew and the Minio kubectl plugin
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Krew 和 Minio kubectl 插件
- en: 'So first, let''s install Krew. The installation process varies depending on
    your OS and environment, but for macOS, it looks like the following (check out
    the Krew docs at [https://krew.sigs.k8s.io/docs](https://krew.sigs.k8s.io/docs)
    for more information):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装 Krew。安装过程根据操作系统和环境的不同而有所不同，但对于 macOS，安装过程如下所示（有关更多信息，请查看 Krew 文档 [https://krew.sigs.k8s.io/docs](https://krew.sigs.k8s.io/docs)）：
- en: 'First, let''s install the Krew CLI tool with the following Terminal commands:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过以下终端命令安装 Krew CLI 工具：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can add Krew to our `PATH` variable with the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将 Krew 添加到我们的 `PATH` 环境变量中：
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To install the Minio kubectl plugin, you can run the following `krew` command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 Minio kubectl 插件，可以运行以下 `krew` 命令：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, with the Minio kubectl plugin installed, let's look at getting Minio set
    up on our cluster.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，安装了 Minio kubectl 插件后，让我们看看如何在集群上设置 Minio。
- en: Starting the Minio Operator
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Minio Operator
- en: 'First off, we need to actually install the Minio Operator on our cluster. This
    deployment will control all the Minio tasks that we need to do later:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在集群上安装 Minio Operator。这个部署将控制我们稍后需要执行的所有 Minio 任务：
- en: 'We can install the Minio Operator using the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装 Minio Operator：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will result in the following output:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To check whether the Minio Operator is ready to go, let''s check on our Pods
    with the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查 Minio Operator 是否已准备好，使用以下命令检查我们的 Pods：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the Minio Operator Pod running in the output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到 Minio Operator Pod 正在运行：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now have the Minio Operator running properly on Kubernetes. Next up, we can
    create a Minio tenant.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Kubernetes 上正确运行了 Minio Operator。接下来，我们可以创建一个 Minio 租户。
- en: Creating a Minio tenant
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Minio 租户
- en: The next step is to create a **tenant**. Since Minio is a multi-tenant system,
    each tenant has its own namespace separation for buckets and objects, in addition
    to separate PersistentVolumes. Additionally, the Minio Operator starts Minio in
    Distributed Mode with a highly available setup and data replication.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个**租户**。由于 Minio 是一个多租户系统，每个租户都有自己独立的命名空间，用于存储桶和对象的隔离，以及独立的 PersistentVolumes。此外，Minio
    Operator 会以分布式模式启动 Minio，确保高可用性和数据复制。
- en: Before creating our Minio tenant, we need to install a **Container Storage Interface**
    (**CSI**) driver for Minio. CSI is a standardized way to interface between storage
    providers and containers – and Kubernetes implements CSI in order to allow third-party
    storage providers to write their own drivers for seamless integration to Kubernetes.
    Minio recommends the Direct CSI driver in order to manage PersistentVolumes for
    Minio.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Minio 租户之前，我们需要为 Minio 安装一个 **容器存储接口**（**CSI**）驱动程序。CSI 是一种标准化的方式，用于在存储提供商和容器之间进行接口——而
    Kubernetes 实现了 CSI，允许第三方存储提供商为 Kubernetes 编写自己的驱动程序，以实现无缝集成。Minio 推荐使用 Direct
    CSI 驱动程序来管理 Minio 的 PersistentVolumes。
- en: 'To install the Direct CSI driver, we need to run a `kubectl apply` command
    with Kustomize. However, the Direct CSI driver installation requires some environment
    variables to be set in order to create the Direct CSI configuration with the proper
    configuration, as shown:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Direct CSI 驱动程序，我们需要使用 Kustomize 执行 `kubectl apply` 命令。然而，安装 Direct CSI
    驱动程序时需要设置一些环境变量，以便使用正确的配置创建 Direct CSI 配置，如下所示：
- en: 'First, let''s go ahead and create this environment file based on the Minio
    recommendations:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们根据 Minio 的建议创建这个环境文件：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this environment file determines where the Direct CSI driver
    will mount volumes.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，环境文件决定了 Direct CSI 驱动程序将在哪里挂载卷。
- en: 'Once we''ve created `default.env`, let''s load these variables into memory
    using the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了 `default.env`，让我们使用以下命令将这些变量加载到内存中：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let''s install the Direct CSI driver with the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令安装 Direct CSI 驱动程序：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should result in the following output:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before we go ahead and create our Minio tenant, let''s check to see whether
    our CSI Pods started up properly. Run the following command to check:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Minio 租户之前，让我们检查一下 CSI Pods 是否已经正确启动。运行以下命令进行检查：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see output similar to the following if the CSI Pods have started:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 CSI Pods 启动了，您应该会看到类似以下的输出：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now with our CSI driver installed, let''s create our Minio tenant – but first,
    let''s take a look at the YAML that the `kubectl minio tenant create` command
    generates:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 CSI 驱动程序已经安装完成，接下来让我们创建 Minio 租户——但首先，让我们看看 `kubectl minio tenant create`
    命令生成的 YAML 文件：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'liveness:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'liveness:'
- en: 'initialDelaySeconds: 10'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'initialDelaySeconds: 10'
- en: 'periodSeconds: 1'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'periodSeconds: 1'
- en: 'timeoutSeconds: 1'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'timeoutSeconds: 1'
- en: 'mountPath: /export'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mountPath: /export'
- en: 'requestAutoCert: true'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'requestAutoCert: true'
- en: 'zones:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'zones:'
- en: '- resources: {}'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- resources: {}'
- en: 'servers: 2'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'servers: 2'
- en: 'volumeClaimTemplate:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'volumeClaimTemplate:'
- en: 'apiVersion: v1'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiVersion: v1'
- en: 'kind: persistentvolumeclaims'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'kind: persistentvolumeclaims'
- en: 'metadata:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'creationTimestamp: null'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'creationTimestamp: null'
- en: 'spec:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'accessModes:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'accessModes:'
- en: '- ReadWriteOnce'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- ReadWriteOnce'
- en: 'resources:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'resources:'
- en: 'requests:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'requests:'
- en: 'storage: 256Mi'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'storage: 256Mi'
- en: 'status: {}'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'status: {}'
- en: 'volumesPerServer: 2'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'volumesPerServer: 2'
- en: 'status:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'status:'
- en: 'availableReplicas: 0'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'availableReplicas: 0'
- en: 'currentState: ""'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'currentState: ""'
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'zones:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'zones:'
- en: '- resources: {}'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- resources: {}'
- en: 'servers: 2'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'servers: 2'
- en: 'volumeClaimTemplate:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'volumeClaimTemplate:'
- en: 'metadata:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: data'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: data'
- en: 'spec:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'accessModes:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'accessModes:'
- en: '- ReadWriteOnce'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- ReadWriteOnce'
- en: 'resources:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'resources:'
- en: 'requests:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'requests:'
- en: 'storage: 256Mi'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'storage: 256Mi'
- en: 'storageClassName: direct.csi.min.io'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'storageClassName: direct.csi.min.io'
- en: '[PRE21]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s now go ahead and create our Minio tenant! We can do this using the following
    command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建我们的 Minio 租户！我们可以使用以下命令完成此操作：
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should result in the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, the Minio Operator will start creating the necessary resources
    for our new Minio tenant, and after a couple of minutes, you should see some Pods
    start up in addition to the operator, which will look similar to the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Minio Operator 将开始为我们的新 Minio 租户创建所需的资源，几分钟后，您应该会看到一些 Pods 启动，除了操作员外，显示的内容应该类似于以下内容：
- en: '![Figure 15.1 – Minio Pods output'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.1 – Minio Pods 输出'
- en: '](img/B14790_15_001.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14790_15_001.jpg)'
- en: Figure 15.1 – Minio Pods output
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – Minio Pods 输出
- en: We now have our Minio tenant completely up and running! Next, let's take a look
    at the Minio console to see how our tenant looks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 Minio 租户已经完全启动并运行了！接下来，让我们看看 Minio 控制台，了解一下我们的租户状况。
- en: Accessing the Minio console
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 Minio 控制台
- en: First, in order to get the login information for the console, we will need to
    fetch the content of two keys, which are kept in the autogenerated `<TENANT NAME>-console-secret`
    secret.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了获取控制台的登录信息，我们需要提取两个密钥的内容，这些密钥保存在自动生成的 `<TENANT NAME>-console-secret` 密钥中。
- en: 'To fetch the `access` key and the `secret` key (which in our case will be autogenerated)
    for the console, let''s use the two following commands. In our case, we use our
    `my-tenant` tenant to get the `access` key:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取控制台的 `access` 密钥和 `secret` 密钥（在我们的例子中将自动生成），我们使用以下两个命令。在我们的例子中，我们使用 `my-tenant`
    租户来获取 `access` 密钥：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And to get the `secret` key, we use this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `secret` 密钥时，我们使用以下命令：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, our Minio console will be available on a service, `<TENANT NAME>-console`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Minio 控制台将在服务 `<TENANT NAME>-console` 上可用。
- en: 'Let''s access this console using a `port-forward` command. In our case, this
    will be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `port-forward` 命令访问这个控制台。在我们的情况下，命令如下：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our Minio console will then be available at `https://localhost:8081` on your
    browser. You will need to accept the browser security warning since we haven't
    set up TLS certificates for the console for localhost in this example. Put in
    the `access` key and `secret` key you got from the previous steps to log in!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的 Minio 控制台将在浏览器中的 `https://localhost:8081` 可用。由于在此示例中我们没有为 localhost 设置控制台的
    TLS 证书，你将需要接受浏览器的安全警告。输入从前面的步骤中获取的 `access` 密钥和 `secret` 密钥进行登录！
- en: Now that we're logged into the console, we can start adding to our Minio tenant.
    First, let's create a bucket. To do this, click **Buckets** on the left sidebar,
    then click the **Create Bucket** button.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已登录到控制台，可以开始向我们的 Minio 租户添加内容。首先，创建一个桶。为此，点击左侧边栏中的 **Buckets**，然后点击 **Create
    Bucket** 按钮。
- en: 'In the popup, enter the name of the bucket (in our case, we will use `my-bucket`)
    and submit the form. You should see a new bucket in the list – see the following
    screenshot for an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，输入桶的名称（在我们的例子中，我们将使用 `my-bucket`）并提交表单。你应该会看到列表中的一个新桶 – 请参考以下截图作为示例：
- en: '![Figure 15.2 – Bucket](img/B14790_15_002.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – 桶](img/B14790_15_002.jpg)'
- en: Figure 15.2 – Bucket
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 桶
- en: We now have our distributed Minio setup ready, together with a bucket to upload
    to. Let's wrap this example up by uploading a file to our brand-new object storage
    system!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好分布式 Minio 设置，并且已经有了一个桶可以上传。让我们通过上传一个文件到全新的对象存储系统来完成这个示例！
- en: We're going to do this upload using the Minio CLI, which makes the process of
    interacting with S3-compatible storage such as Minio much easier. Instead of using
    the Minio CLI from our local machine, we will run a container image preloaded
    with the Minio CLI from within Kubernetes, since the TLS setup will only work
    when accessing Minio from within the cluster.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Minio CLI 进行上传，这使得与 S3 兼容的存储（如 Minio）交互的过程变得更加简单。我们将不使用本地机器上的 Minio CLI，而是在
    Kubernetes 内运行一个预加载了 Minio CLI 的容器镜像，因为 TLS 设置仅在集群内访问 Minio 时有效。
- en: 'First, we''ll need to fetch the Minio `access` key and `secret`, which are
    different from the console `access` key and `secret` we fetched earlier. To get
    these keys, run the following console commands (in our case, our tenant is `my-tenant`).
    First, get the `access` key:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取 Minio 的 `access` 密钥和 `secret`，这与之前获取的控制台 `access` 密钥和 `secret` 不同。要获取这些密钥，请运行以下控制台命令（在我们的例子中，租户是
    `my-tenant`）。首先，获取 `access` 密钥：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, get the `secret` key:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，获取 `secret` 密钥：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s start up that pod with the Minio CLI. To do this, let''s use this
    Pod spec:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动这个 Pod 并使用 Minio CLI。为此，使用以下 Pod 配置：
- en: minio-mc-pod.yaml
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: minio-mc-pod.yaml
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create this Pod using this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建这个 Pod：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, to `exec` into this `minio-mc` Pod, we run the usual `exec` command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要 `exec` 进入这个 `minio-mc` Pod，我们运行通常的 `exec` 命令：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s configure access for our newly created Minio distributed cluster
    in the Minio CLI. We can do this with the following command (the `--insecure`
    flag is required in this config):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 Minio CLI 中配置新创建的 Minio 分布式集群的访问权限。我们可以使用以下命令来实现这一点（此配置需要 `--insecure`
    标志）：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Pod IP for this command can be the IP for either of our tenant Minio Pods
    – in our case, these are `my-tenant-zone-0-0` and `my-tenant-zone-0-1`. Once you
    run this command, you will be prompted for the access key and secret key. Enter
    them, and you will see a confirmation message if successful, which will look like
    this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的 Pod IP 可以是我们任一租户 Minio Pod 的 IP – 在我们的例子中，它们是 `my-tenant-zone-0-0` 和 `my-tenant-zone-0-1`。运行此命令后，系统会提示你输入访问密钥和密钥。输入后，如果成功，你将看到一个确认消息，格式如下：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, to test that the CLI configuration is working, we can create another test
    bucket using the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试 CLI 配置是否正常工作，我们可以使用以下命令创建另一个测试桶：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should result in the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As a final test of our setup, let's upload a file to our Minio bucket!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设置的最终测试，让我们上传一个文件到我们的 Minio 桶！
- en: First, still on the `minio-mc` Pod, create a text file named `test.txt`. Fill
    the file with whatever text you'd like.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`minio-mc` Pod上创建一个名为`test.txt`的文本文件。将你想要的任何文本填入该文件。
- en: 'Now, let''s upload it to our recently created bucket using this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下命令将其上传到我们刚创建的存储桶：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You should see a loading bar with the upload, which should end with the entire
    file size as uploaded.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个上传的加载条，最终显示上传的整个文件大小。
- en: 'As one last check, go to the **Dashboard** page on the Minio console and see
    whether the object shows up, as shown in the following figure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查一下，进入Minio控制台的**Dashboard**页面，查看该对象是否显示出来，如下图所示：
- en: '![Figure 15.3 – Dashboard](img/B14790_15_003.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – Dashboard](img/B14790_15_003.jpg)'
- en: Figure 15.3 – Dashboard
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Dashboard
- en: As you can see, our file was successfully uploaded!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的文件已成功上传！
- en: That's it for Minio – there is a lot more you can do in terms of configuration,
    but that is outside the scope of this book. Check the docs at [https://docs.min.io/](https://docs.min.io/)
    for more information.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于Minio的全部内容——关于配置的内容还有很多，但超出了本书的范围。有关更多信息，请参考文档：[https://docs.min.io/](https://docs.min.io/)。
- en: Next up, let's look at running DBs on Kubernetes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看如何在Kubernetes上运行数据库。
- en: Running DBs on Kubernetes
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行数据库
- en: Now that we've taken a look at object storage workloads on Kubernetes, we can
    move on to databases. As we've discussed previously in this chapter and elsewhere
    in the book, many databases support running on Kubernetes, with varying levels
    of maturity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Kubernetes上的对象存储工作负载，接下来可以讨论数据库。正如我们在本章以及书中其他地方提到的，许多数据库都支持在Kubernetes上运行，成熟度不一。
- en: First off, there are several legacy and existing DB engines that support deploying
    to Kubernetes. Often, these engines will have supported Helm charts or operators.
    For instance, SQL databases such as PostgreSQL and MySQL have Helm charts and
    operators supported by various different organizations. NoSQL databases such as
    MongoDB also have supported ways to deploy to Kubernetes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有几种传统的和现有的数据库引擎支持部署到Kubernetes。这些引擎通常已经有支持的Helm图表或运维工具。例如，像PostgreSQL和MySQL这样的SQL数据库就有由不同组织支持的Helm图表和运维工具。像MongoDB这样的NoSQL数据库也有支持的部署到Kubernetes的方式。
- en: In addition to these previously existing database engines, container orchestrators
    such as Kubernetes have lead to the creation of a new category – the **NewSQL**
    database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些已经存在的数据库引擎外，像Kubernetes这样的容器编排器促成了一个新类别的出现——**NewSQL**数据库。
- en: These databases offer the incredible scalability of NoSQL databases in addition
    to SQL-compliant APIs. They can be thought of as a way to easily scale SQL on
    Kubernetes (and other orchestrators). CockroachDB is a popular choice here, as
    is **Vitess**, which isn't so much a replacement NewSQL database as it is a way
    to easily scale the MySQL engine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库不仅提供了NoSQL数据库的惊人可扩展性，还支持SQL兼容的API。它们可以被视为在Kubernetes（以及其他编排器）上轻松扩展SQL的一种方式。CockroachDB是一个流行的选择，**Vitess**也是一个不错的选择，它并非完全替代NewSQL数据库，而是为MySQL引擎提供了一种简单的扩展方式。
- en: In this chapter, we will focus on deploying CockroachDB, which is a modern NewSQL
    database built for distributed environments and perfect for Kubernetes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍部署CockroachDB，这是一款为分布式环境设计的现代化NewSQL数据库，非常适合Kubernetes。
- en: Running CockroachDB on Kubernetes
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行CockroachDB
- en: 'To run CockroachDB on our cluster, we will use the official CockroachDB Helm
    chart:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的集群上运行CockroachDB，我们将使用官方的CockroachDB Helm图表：
- en: 'The first thing we need to do is to add the CockroachDB Helm chart repository,
    using the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加CockroachDB Helm图表仓库，使用以下命令：
- en: '[PRE37]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should result in the following output:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE38]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before we install the chart, let''s create a custom `values.yaml` file in order
    to tweak some of the default settings for CockroachDB. Our file for this demo
    looks like the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装图表之前，让我们创建一个自定义的`values.yaml`文件，以调整CockroachDB的一些默认设置。我们的文件在本演示中如下所示：
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are specifying a PersistentVolume size of `2` GB, Pod memory
    limits and requests of `1` GB, and the contents of a configuration file for CockroachDB.
    This configuration file includes settings for `cache` and max `memory`, which
    are set to 25% of the size of the memory limits at `256` MB. This ratio is a CockroachDB
    best practice. Keep in mind that these are not all production-ready settings,
    but they will work for our demo.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们指定了`2` GB的持久卷大小，`1` GB的Pod内存限制和请求，以及CockroachDB的配置文件内容。该配置文件包括`cache`和最大`memory`的设置，分别设置为内存限制的25%（`256`
    MB）。这个比例是CockroachDB的最佳实践。请记住，这些设置并不完全适用于生产环境，但它们适用于我们的演示。
- en: 'At this point, let''s go ahead and create our CockroachDB cluster using the
    following Helm command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，让我们使用以下Helm命令创建我们的CockroachDB集群：
- en: '[PRE40]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If successful, you will see a lengthy deploy message from Helm, which we will
    not reproduce here. Let''s check to see exactly what was deployed on our cluster
    using the following command:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果成功，你将看到来自Helm的长时间部署信息，我们不会在这里重复。让我们通过以下命令检查集群上到底部署了什么：
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will see output similar to the following:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到类似以下的输出：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, we have three Pods in a StatefulSet in addition to a setup Pod
    that was used for some initialization tasks.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，除了用于一些初始化任务的设置Pod外，我们还有三个Pod在StatefulSet中。
- en: 'In order to check to see whether our cluster is functional, we can use a command
    that is handily given to us in the CockroachDB Helm chart output (it will vary
    depending on your Helm release name):'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查我们的集群是否正常工作，我们可以使用CockroachDB Helm图表输出中便捷给出的命令（具体命令会根据你的Helm发布名称有所不同）：
- en: '[PRE43]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If successful, a console will be opened with a prompt similar to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，将打开一个控制台，显示类似以下的提示：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will test CockroachDB with SQL.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将使用SQL测试CockroachDB。
- en: Testing CockroachDB with SQL
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL测试CockroachDB
- en: Now, we can run SQL commands to our new CockroachDB database!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向新的CockroachDB数据库运行SQL命令了！
- en: 'First, let''s create a database with the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令创建一个数据库：
- en: '[PRE45]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, let''s create a simple table:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简单的表：
- en: '[PRE46]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, let''s add some data with this command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令添加一些数据：
- en: '[PRE47]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, let''s confirm the data using this:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下内容来确认数据：
- en: '[PRE48]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That should give you the following output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Success!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: 'As you can see, we have a fully functional distributed SQL database. Let''s
    move on to the final stateful workload type that we will review: messaging.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个完全功能的分布式SQL数据库。让我们继续查看我们将要评审的最后一种有状态工作负载类型：消息传递。
- en: Implementing messaging and queues on Kubernetes
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上实现消息传递和队列
- en: For messaging, we will be implementing RabbitMQ, an open source message queue
    system that supports Kubernetes. Messaging systems are typically used in applications
    to decouple various components of the application in order to support the scale
    and throughput, as well as asynchronous patterns such as retries and service worker
    fleets. For instance, instead of one service calling another service directly,
    a service could place a message onto a persistent message queue, at which point
    it would be picked up by a worker container that is listening to the queue. This
    allows for easy horizontal scaling and greater tolerance of entire component downtime
    as compared to a load balancing approach.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息传递，我们将实现RabbitMQ，一个支持Kubernetes的开源消息队列系统。消息传递系统通常用于应用程序中，以解耦应用程序的各个组件，以支持规模和吞吐量，以及异步模式，如重试和服务工作者队列。例如，一个服务在调用另一个服务时，可能不会直接调用，而是将消息放入持久化的消息队列中，随后由一个监听该队列的工作容器取出处理。这种方式相比负载均衡方法，更容易进行横向扩展，并能容忍整个组件的停机。
- en: RabbitMQ is one of many options for message queues. As we mentioned in the first
    section of the chapter, RabbitMQ is an industry-standard option for message queues,
    not necessarily a queue system built for Kubernetes specifically. However, it's
    still a great choice and very easy to deploy, as we will see shortly.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ是众多消息队列选项之一。正如我们在本章的第一部分提到的，RabbitMQ是一个行业标准的消息队列选项，虽然它并不是专为Kubernetes构建的队列系统，但它仍然是一个很好的选择，而且非常容易部署，正如我们稍后将看到的那样。
- en: Let's start with implementing RabbitMQ on Kubernetes!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Kubernetes上实现RabbitMQ开始！
- en: Deploying RabbitMQ on Kubernetes
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署RabbitMQ
- en: 'Installing RabbitMQ on Kubernetes can be easily done via an operator or via
    a Helm chart. For the purposes of this tutorial, we will use the Helm chart:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上安装 RabbitMQ 可以通过操作员或 Helm 图表轻松完成。为了本教程的目的，我们将使用 Helm 图表：
- en: 'First, let''s add the proper `helm` repository (provided by **Bitnami**):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加正确的 `helm` 仓库（由**Bitnami**提供）：
- en: '[PRE50]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, let''s create a custom values file to tweak some parameters:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个自定义的值文件，以调整一些参数：
- en: '[PRE51]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, in this case, we are disabling persistence, which is great for
    a quick demo.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，在这种情况下，我们禁用了持久化，这对于快速演示非常合适。
- en: 'Then, RabbitMQ can easily be installed on the cluster using the following command:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，可以使用以下命令轻松地在集群中安装 RabbitMQ：
- en: '[PRE52]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Once successful, you will see a confirmation message from Helm. The RabbitMQ
    Helm chart also includes a management UI, so let's use that to validate that our
    installation worked.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦成功，你将看到来自 Helm 的确认消息。RabbitMQ Helm 图表还包含一个管理 UI，所以我们使用这个 UI 来验证我们的安装是否成功。
- en: 'First, let''s start a port forward to the `rabbitmq` service:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为 `rabbitmq` 服务启动端口转发：
- en: '[PRE53]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, we should be able to log in to the dashboard using the username and password
    specified in the values file. Upon login, you will see the RabbitMQ dashboard
    main view.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该能够使用在值文件中指定的用户名和密码登录仪表盘。登录后，你将看到 RabbitMQ 仪表盘的主视图。
- en: 'Importantly, you will see a list of the nodes in your RabbitMQ cluster. In
    our case, we only have a single node, which will display as follows:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是，你将看到你的 RabbitMQ 集群中的节点列表。在我们的案例中，我们只有一个单节点，显示如下：
- en: '![Figure 15.5 – RabbitMQ management console node item](img/B14790_15_005.jpg)'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 15.5 – RabbitMQ 管理控制台节点项](img/B14790_15_005.jpg)'
- en: Figure 15.5 – RabbitMQ management console node item
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.5 – RabbitMQ 管理控制台节点项
- en: For each node, you can see the name and some metadata, including memory, uptime,
    and more.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于每个节点，你可以看到其名称以及一些元数据，包括内存、运行时间等。
- en: In order to add a new queue navigate to **Queues** on the top bar, click **Add
    a new queue** toward the bottom of the screen. Fill out the form as follows, then
    click **Add queue**:![Figure 15.6 – RabbitMQ management console queue creation](img/B14790_15_006.jpg)
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加一个新队列，导航到顶部栏的**队列**，点击屏幕底部的**添加新队列**。按照以下方式填写表单，然后点击**添加队列**：![图 15.6 –
    RabbitMQ 管理控制台队列创建](img/B14790_15_006.jpg)
- en: Figure 15.6 – RabbitMQ management console queue creation
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.6 – RabbitMQ 管理控制台队列创建
- en: If successful, the screen should refresh with your new queue added to the list.
    This means our RabbitMQ setup is working properly!
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果成功，屏幕应该会刷新，并且你会看到新队列已添加到列表中。这意味着我们的 RabbitMQ 设置正常工作！
- en: Finally, now that we have a queue, we can publish a message to it. To do this,
    click on your newly created queue on the **Queues** page, then click **Publish
    Message**.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，既然我们已经有了一个队列，我们可以向其中发布消息。为此，点击你刚创建的队列，进入**队列**页面，然后点击**发布消息**。
- en: Write any text in the **Payload** text box and click **Publish Message**. You
    should see a confirmation popup telling you that your message has been published
    successfully, and the screen should refresh, showing your message on the queue,
    as shown in the following figure:![Figure 15.7 – RabbitMQ management console queue
    status](img/B14790_15_007.jpg)
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**有效负载**文本框中输入任何文本，然后点击**发布消息**。你应该会看到一个确认弹窗，告诉你消息已经成功发布，屏幕应该会刷新，显示队列中的消息，如下图所示：![图
    15.7 – RabbitMQ 管理控制台队列状态](img/B14790_15_007.jpg)
- en: Figure 15.7 – RabbitMQ management console queue status
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.7 – RabbitMQ 管理控制台队列状态
- en: Finally, to emulate fetching messages from the queue, click on **Get messages**
    near the bottom of the page, which should expand to show a new section, and then
    click the **Get Message(s)** button. You should see an output of the message you
    sent, proving that the queue system works!
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了模拟从队列中获取消息，点击页面底部附近的**获取消息**，此时会展开显示一个新区域，然后点击**获取消息**按钮。你应该能看到你发送的消息输出，证明队列系统正常工作！
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about running stateful workloads on Kubernetes.
    First, we reviewed a high-level overview of some of the types of stateful workloads
    and some examples of each. Then, we moved on to actually deploying one of these
    workloads – an object storage system – on Kubernetes. Next, we did the same with
    a NewSQL database, CockroachDB, showing you how to easily deploy a CockroachDB
    cluster on Kubernetes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何在 Kubernetes 上运行有状态工作负载。首先，我们回顾了几种有状态工作负载的高层次概述，并给出了每种类型的一些示例。接着，我们实际部署了其中一种工作负载——对象存储系统——到
    Kubernetes 上。然后，我们做了同样的操作，部署了一个 NewSQL 数据库 CockroachDB，向你展示了如何轻松地在 Kubernetes
    上部署一个 CockroachDB 集群。
- en: Finally, we showed you how to deploy the RabbitMQ message queue on Kubernetes
    using a Helm chart. The skills you used in this chapter will help you deploy and
    use popular stateful application patterns on Kubernetes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向你展示了如何使用 Helm 图表在 Kubernetes 上部署 RabbitMQ 消息队列。你在本章中使用的技巧将帮助你在 Kubernetes
    上部署和使用流行的有状态应用模式。
- en: If you've made it this far, thanks for sticking with us through all 15 chapters
    of this book! I hope that you have learned how to use a broad spectrum of Kubernetes
    functionality and that you now have all the tools you need in order to build and
    deploy complex applications on Kubernetes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这里，感谢你陪伴我们走过本书的 15 章！我希望你已经学会如何使用 Kubernetes 的广泛功能，并且现在你拥有了构建和部署复杂应用所需的所有工具。
- en: Questions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What cloud storage offering is Minio's API compatible with?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Minio 的 API 与哪个云存储服务兼容？
- en: What are the benefits of a StatefulSet for a distributed database?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: StatefulSet 对分布式数据库有哪些好处？
- en: In your words, what makes stateful applications difficult to run on Kubernetes?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话来说，是什么让有状态应用在 Kubernetes 上运行变得困难？
- en: Further reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Minio Quickstart Documentation: [https://docs.min.io/docs/minio-quickstart-guide.html](https://docs.min.io/docs/minio-quickstart-guide.html)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minio 快速入门文档：[https://docs.min.io/docs/minio-quickstart-guide.html](https://docs.min.io/docs/minio-quickstart-guide.html)
- en: 'CockroachDB Kubernetes Guide: [https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes](https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CockroachDB Kubernetes 指南：[https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes](https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes)
