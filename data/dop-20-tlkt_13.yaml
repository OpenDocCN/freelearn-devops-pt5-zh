- en: Chapter 13. Blue-Green Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 蓝绿部署
- en: Traditionally, we deploy a new release by replacing the current one. The old
    release is stopped, and the new one is brought up in its place. The problem with
    this approach is the downtime occurring from the moment the old release is stopped
    until the new one is fully operational. No matter how quickly you try to do this
    process, there will be some downtime. That might be only a millisecond, or it
    can last for minutes or, in extreme situations, even hours. Having monolithic
    applications introduces additional problems like, for example, the need to wait
    a considerable amount of time until the application is initialized. People tried
    to solve this issue in various ways, and most of them used some variation of the
    *blue-green deployment process*. The idea behind it is simple. At any time, one
    of the releases should be running meaning that, during the deployment process,
    we must deploy a new release in parallel with the old one. The new and the old
    releases are called blue and green.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们通过替换当前版本来部署新版本。旧版本被停止，新版本取而代之。这个方法的问题在于，从停止旧版本到新版本完全投入运行之间会出现停机时间。不管你多么快速地尝试执行这个过程，总会有一些停机时间。这可能只是几毫秒，也可能持续几分钟，或者在极端情况下，甚至几个小时。采用单体应用程序会引入额外的问题，例如，必须等待相当长的时间才能初始化应用程序。人们试图通过各种方式解决这个问题，其中大多数人使用了某种变种的*蓝绿部署过程*。其背后的理念很简单：在任何时候，都应该有一个版本在运行，这意味着在部署过程中，我们必须并行部署新版本和旧版本。新版本和旧版本分别称为蓝色和绿色版本。
- en: '![Blue-Green Deployment](img/B05848_13_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署](img/B05848_13_01.jpg)'
- en: Figure 13-1 – At any given moment, at least, one service release is up and running
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1 – 在任何时刻，至少有一个服务版本在运行
- en: We run one color as a current release, bring up the other color as a new release
    and, once it is fully operational, switch all the traffic from the current to
    the new release. This switch is often made with a router or a proxy service.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个版本作为当前版本运行，启动另一个版本作为新版本，一旦它完全投入运行，就将所有流量从当前版本切换到新版本。这个切换通常通过路由器或代理服务来完成。
- en: With the blue-green process, not only that we are removing the deployment downtime,
    but we are also reducing the risk the deployment might introduce. No matter how
    well we tested our software before it reached the production node(s), there is
    always a chance that something will go wrong. When that happens, we still have
    the current version to rely on. There is no real reason to switch the traffic
    to the new release until it is tested enough that any reasonable possibility of
    a failure due to some specifics of the production node is verified. That usually
    means that integration testing is performed after the deployment and before the
    "switch" is made. Even if those verifications returned false negatives and there
    is a failure after the traffic is redirected, we can quickly switch back to the
    old release and restore the system to the previous state. We can roll back much
    faster than if we'd need to restore the application from some backup or do another
    deployment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过蓝绿部署过程，我们不仅消除了部署停机时间，还减少了部署可能带来的风险。无论我们在软件到达生产节点之前进行了多么充分的测试，总是有可能出现问题。当问题发生时，我们仍然可以依赖当前版本。直到新版本经过充分测试，并且验证了生产节点的一些特定问题的合理失败可能性之前，都没有必要将流量切换到新版本。这通常意味着在部署之后、切换之前需要进行集成测试。即使这些验证返回了假阴性，并且在流量重定向后发生了故障，我们仍然可以快速切换回旧版本，将系统恢复到之前的状态。我们可以比需要从备份恢复应用程序或重新部署更快地回滚。
- en: If we combine the blue-green process with immutable deployments (through VMs
    in the past and though containers today), the result is a very powerful, secure
    and reliable deployment procedure that can be performed much more often. If architecture
    is based on microservices in conjunction with containers, we don't need two nodes
    to perform the procedure and can run both releases side by side.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将蓝绿部署过程与不可变部署结合起来（过去通过虚拟机，今天通过容器实现），那么结果将是一个非常强大、安全且可靠的部署流程，可以更频繁地执行。如果架构基于微服务并与容器结合使用，我们就不需要两个节点来执行此过程，可以并行运行两个版本。
- en: The significant challenges with this approach are databases. In many cases,
    we need to upgrade a database schema in a way that it supports both releases and
    then proceed with the deployment. The problems that might arise from this database
    upgrade are often related to the time that passes between releases. When releases
    are done often, changes to the database schema tend to be small, making it easier
    to maintain compatibility across two releases. If weeks, or months, passed between
    releases, database changes could be so big that backward compatibility might be
    impossible or not worthwhile doing. If we are aiming towards continuous delivery
    or deployment, the period between two releases should be short or, if it isn't,
    involve a relatively small amount of changes to the code base.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要挑战在于数据库。在许多情况下，我们需要以一种支持两个版本的方式升级数据库模式，然后继续进行部署。这种数据库升级可能带来的问题通常与版本之间的时间间隔有关。当版本发布频繁时，数据库模式的变化通常较小，这使得在两个版本之间保持兼容性变得容易。如果版本之间隔了几周或几个月，数据库的变化可能会非常大，以至于向后兼容性可能变得不可能或不值得做。如果我们的目标是持续交付或部署，那么两个版本之间的时间应该很短，或者如果时间较长，代码库的变化量应该相对较小。
- en: The blue-green deployment process
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝绿部署过程
- en: The blue-green deployment procedure, when applied to microservices packed as
    containers, is as follows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署过程应用于打包为容器的微服务时，步骤如下。
- en: The current release (for example blue), is running on the server. All traffic
    to that release is routed through a proxy service. Microservices are immutable
    and deployed as containers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的版本（例如蓝色）正在服务器上运行。所有流量都通过代理服务路由到该版本。微服务是不可变的，并以容器形式部署。
- en: '![The blue-green deployment process](img/B05848_13_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署过程](img/B05848_13_02.jpg)'
- en: Figure 13-2 – Immutable microservice deployed as a container
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2 – 作为容器部署的不可变微服务
- en: When a new release (for example green) is ready to be deployed, we run it in
    parallel with the current release. This way we can test the new release without
    affecting the users since all the traffic continues being sent to the current
    release.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当新版本（例如绿色）准备好部署时，我们将其与当前版本并行运行。这样，我们可以在不影响用户的情况下测试新版本，因为所有流量仍然会发送到当前版本。
- en: '![The blue-green deployment process](img/B05848_13_03.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署过程](img/B05848_13_03.jpg)'
- en: Figure 13-3 – New release of the immutable microservice deployed alongside the
    old release
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3 – 新版本的不可变微服务与旧版本并排部署
- en: Once we think that the new release is working as expected, we change the proxy
    service configuration so that the traffic is redirected to that release. Most
    proxy services will let the existing requests finish their execution using the
    old proxy configuration so that there is no interruption.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们认为新版本按预期工作，我们会更改代理服务的配置，使流量重定向到该版本。大多数代理服务会允许现有请求继续使用旧的代理配置完成执行，这样就不会中断服务。
- en: '![The blue-green deployment process](img/B05848_13_04.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署过程](img/B05848_13_04.jpg)'
- en: Figure 13-4 – Proxy is reconfigured to point to the new release
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4 – 代理已重新配置以指向新版本
- en: When all the requests sent to the old release received responses, the previous
    version of a service can be removed or, even better, stopped from running. If
    the latter option is used, rollback in case of a failure of the new release will
    be almost instantaneous since all we have to do is bring the old release back
    up.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有发往旧版本的请求都收到响应后，先前的服务版本可以被移除，或者更好的是，停止运行。如果使用后者选项，万一新版本失败，回滚几乎是瞬间的，因为我们只需将旧版本重新启动即可。
- en: '![The blue-green deployment process](img/B05848_13_05.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署过程](img/B05848_13_05.jpg)'
- en: Figure 13-5 – The old release is removed
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5 – 旧版本被移除
- en: Equipped with the basic logic behind the blue-green process, we can try setting
    it up. We'll start with manual commands and, once we're familiar with the practical
    part of the process, we'll attempt to automate the procedure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了蓝绿部署过程的基本逻辑后，我们可以尝试进行设置。我们将从手动命令开始，一旦熟悉了过程的实际操作，我们将尝试自动化这一过程。
- en: We'll need the usual two nodes (`cd` and `prod`) to be up and running so let
    us create and provision the VMs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保常规的两个节点（`cd`和`prod`）处于运行状态，因此我们需要创建并配置虚拟机（VM）。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Manually running the blue-green deployment
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动运行蓝绿部署
- en: Please note that we'll go through the whole blue-green process within the context
    of what we tried to accomplish earlier. We will not only run two releases in parallel
    but make sure that, among other things, everything is thoroughly tested during
    multiple phases. That will complicate the process more than if we follow the blue-green
    procedure assuming that everything works. Most implementations do not take into
    account the need for testing before making the change to the proxy service. We
    can, and will, do better than that. Another thing to note is that we'll explore
    manual steps for you to understand the process. Later on, we'll automate everything
    using the tools we're already familiar with. I choose this approach in order to
    be sure that you grasp the complexity behind the combination of the continuous
    deployment and the blue-green processes. By truly understanding how to do it manually,
    you will be able to make an informed decision whether benefits of tools we're
    will explore throughout the rest of the book are greater than things they are
    missing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在尝试实现之前目标的基础上进行整个蓝绿部署过程。我们不仅要并行运行两个发布版本，还要确保在多个阶段中彻底测试其中的所有内容。这将使过程比假设一切正常的蓝绿部署程序更复杂。大多数实现都没有考虑到在更改代理服务之前需要进行测试。我们可以，也将，做得更好。另一个需要注意的事情是，我们将探索手动步骤，以便你理解整个过程。之后，我们将使用已经熟悉的工具自动化所有操作。我选择这种方式是为了确保你理解持续部署和蓝绿部署结合背后的复杂性。通过真正理解如何手动执行，你将能够做出明智的决定，判断我们将在本书后续章节中探索的工具的好处是否大于它们所缺失的部分。
- en: We'll start by downloading the Docker Compose and nginx configurations that
    we used in the previous chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先下载上一章中使用的Docker Compose和nginx配置文件。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With all the configuration files available, let us deploy the first release.
    The tools we explored earlier will come in handy. We'll use Consul as the service
    registry, Registrator to register and de-register containers, nginx as a proxy
    service and Consul Template to generate configurations and reload nginx.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有配置文件准备好之后，让我们部署第一次发布。我们之前探索的工具将派上用场。我们将使用Consul作为服务注册中心，使用Registrator来注册和注销容器，使用nginx作为代理服务，使用Consul
    Template来生成配置并重新加载nginx。
- en: Deploying the blue release
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署蓝色版本
- en: Since, at this moment, we do not have the `books-ms` service up and running,
    we'll call the first release `blue`. The only thing we need to do for now is to
    make sure that the name of the container we are about to run contains the word
    `blue` so that it does not collide with the next release. We'll be using Docker
    Compose to run containers so let us take a quick look at the targets defined in
    the `docker-compose.yml` file that we just downloaded (only relevant targets are
    presented).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时我们还没有启动`books-ms`服务，我们将第一次发布命名为`blue`。目前我们唯一需要做的就是确保我们将要运行的容器名称中包含“blue”字样，以避免与下一个发布版本冲突。我们将使用Docker
    Compose来运行容器，让我们快速查看一下我们刚刚下载的`docker-compose.yml`文件中定义的目标（仅展示相关目标）。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We cannot use the `app` target directly since we'll be deploying two different
    targets (one for each color) and in that way avoid them overriding each other.
    Also, we'll want to differentiate them in Consul as well, so the `SERVICE_NAME`
    environment variable should be unique. To accomplish that, we have two new targets
    called `app-blue` and `app-green`. Those targets extend the `base` service in
    the same way the `app` target extended it in previous chapters. The only difference
    between the targets `app-blue` and `app-green` on one hand and the `base` on the
    other is (besides the name of the target) the environment variable `SERVICE_NAME`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接使用`app`目标，因为我们将部署两个不同的目标（每种颜色一个），以避免它们互相覆盖。此外，我们还希望在Consul中区分它们，因此`SERVICE_NAME`环境变量应该是唯一的。为此，我们创建了两个新目标，分别是`app-blue`和`app-green`。这些目标以与之前章节中`app`目标扩展`base`服务相同的方式扩展`base`服务。`app-blue`和`app-green`目标与`base`服务之间的唯一区别是（除了目标名称外）环境变量`SERVICE_NAME`。
- en: With those two targets defined, we can deploy the blue release.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这两个目标后，我们可以部署蓝色版本。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We pulled the latest version from the registry and brought it up as the blue
    release of the service. Just to be on the safe side, let us quickly check whether
    the service is running and is registered in Consul.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从注册中心拉取了最新版本，并将其作为服务的蓝色版本启动。为了确保安全，我们快速检查一下服务是否正在运行，并且已经在Consul中注册。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output of both commands combined is as follows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两个命令的输出合并如下。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first command showed that both the `app-blue` and the `db` containers are
    running. The second command displayed the details of the `books-ms-blue` service
    registered in Consul. Now we have the first release of our service up and running
    but still not integrated with nginx and, therefore, not accessible through the
    port 80\. We can confirm that by sending a request to the service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令显示`app-blue`和`db`容器都在运行。第二个命令显示了在 Consul 中注册的`books-ms-blue`服务的详细信息。现在，我们已经启动了服务的第一个版本，但它还没有与
    nginx 集成，因此无法通过端口 80 访问。我们可以通过向该服务发送请求来确认这一点。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output is as follows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The request response is the `404 Not Found` error message proving that we are
    yet to configure the proxy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请求响应是`404 Not Found`错误消息，证明我们还没有配置代理。
- en: '![Deploying the blue release](img/B05848_13_06.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![部署蓝色版本](img/B05848_13_06.jpg)'
- en: Figure 13-6 – The blue container is deployed
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-6 – 蓝色容器已部署
- en: Integrating the blue release
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成蓝色版本
- en: We can integrate the service in a similar way as we did before. The only difference
    is in the target of the service we registered in Consul.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似之前的方式集成该服务。唯一的区别是我们在 Consul 中注册的服务目标。
- en: Let us start by taking a look at the nginx Consul template `nginx-upstreams-blue.ctmpl`
    that we downloaded earlier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看我们之前下载的 nginx Consul 模板`nginx-upstreams-blue.ctmpl`。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The service name is `books-ms-blue` and we can proceed by running Consul Template
    that will generate the final nginx upstreams configuration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 服务名称是`books-ms-blue`，我们可以通过运行 Consul Template 来生成最终的 nginx upstream 配置。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The command run Consul Template that produced the nginx upstreams configuration
    file and reloaded the service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的命令是 Consul Template，它生成了 nginx upstream 配置文件并重新加载了服务。
- en: Let's check whether the configuration file was indeed created correctly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查配置文件是否确实已正确创建。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output is as follows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, all that's left is to copy the configuration files to the `prod` server
    and reload `nginx`. When asked, please use `vagrant` as the password.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，剩下的就是将配置文件复制到`prod`服务器并重新加载`nginx`。系统提示时，请使用`vagrant`作为密码。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We copied the two configuration files to the server and reloaded `nginx` by
    sending the `HUP` signal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个配置文件复制到服务器并通过发送`HUP`信号重新加载`nginx`。
- en: Let's check whether our service is indeed integrated with the proxy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的服务是否确实与代理集成。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output is as follows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time, the response code is `200 OK` indicating that the service indeed
    responded to the request.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，响应代码是`200 OK`，表明服务确实回应了请求。
- en: '![Integrating the blue release](img/B05848_13_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![集成蓝色版本](img/B05848_13_07.jpg)'
- en: Figure 13-7 – The blue container integrated with the proxy service
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-7 – 蓝色容器与代理服务集成
- en: We finished the simplest scenario by deploying the first (blue) release. As
    you will soon see, the process of deploying the second (green) release will not
    be much different.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了最简单的场景——部署了第一个（蓝色）版本。正如你很快将看到的，部署第二个（绿色）版本的过程不会有太大不同。
- en: Deploying the green release
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署绿色版本
- en: Deployment of the second (green) release can be done using the same steps as
    those we executed for the first (blue) release. The only difference is that this
    time we'll deploy the `books-ms-green` instead of the `books-ms-blue` target.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次（绿色）版本的部署可以通过与第一次（蓝色）版本相同的步骤进行。唯一的区别是这次我们将部署`books-ms-green`而不是`books-ms-blue`目标。
- en: Unlike the previous deployment, this time, the new release (green) will run
    in parallel with the current release (blue).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一次的部署不同，这次新版本（绿色）将与当前版本（蓝色）并行运行。
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The new release has been pulled and run. We can confirm that by running the
    `docker-compose ps` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本已被拉取并运行。我们可以通过运行`docker-compose ps`命令来确认。
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result is as follows.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output shows that the two services (blue and green) are running in parallel.
    Similarly, we can confirm that both releases are registered in Consul.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示两个服务（蓝色和绿色）并行运行。同样，我们可以确认两个版本都已在 Consul 中注册。
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output is as follows.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As before, we can also check the details of the newly deployed service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所示，我们也可以检查新部署的服务的详细信息。
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we can confirm that the old release is still accessible through the
    proxy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以确认旧版本仍然可以通过代理访问。
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output of the last command should be similar to the following (timestamps
    are removed for brevity).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命令的输出应该类似于以下内容（为了简洁，已删除时间戳）。
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Please keep in mind that the port of the service deployed on your computer might
    be different than the one from the preceding example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，部署在您计算机上的服务端口可能与前面示例中的端口不同。
- en: The output of nginx logs should display that the request we made is redirected
    to the port of the blue release. That can be observed by checking that the last
    request went to the same port as the one we made before deploying the `green`
    release.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 日志的输出应该显示我们发出的请求被重定向到蓝色版本的端口。我们可以通过检查最后一个请求是否进入了与我们在部署 `green` 版本之前相同的端口来观察这一点。
- en: '![Deploying the green release](img/B05848_13_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![部署绿色版本](img/B05848_13_08.jpg)'
- en: Figure 13-8 – The green container is deployed in parallel with the blue
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-8 – 绿色容器与蓝色容器并行部署
- en: Right now, we have two releases (blue and green) running in parallel and the
    proxy service is still redirecting all requests to the old release (blue). The
    next step should be to test the new release before we change the proxy configuration.
    We'll skip testing until we reach the automation part and dive straight into the
    integration of the green release with nginx.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有两个版本（蓝色和绿色）并行运行，代理服务仍然将所有请求重定向到旧版本（蓝色）。下一步应该是在更改代理配置之前先测试新的版本。我们将在自动化部分之前跳过测试，直接进入绿色版本与
    nginx 的集成。
- en: Integrating the green release
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成绿色版本
- en: The process to integrate the second (green) release with the proxy service is
    similar to the one we already did.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将第二个（绿色）版本与代理服务集成的过程与我们之前所做的类似。
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can send a request to the proxy and check its logs to see whether it truly
    points to the new (green) release.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向代理发送请求，并检查其日志，以查看它是否确实指向新的（绿色）版本。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The nginx logs should be similar to the following (timestamps are removed for
    brevity).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 日志应该类似于以下内容（时间戳已移除以简化显示）。
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is obvious that the last request went to a different port (`32770`) than
    those we made before (`32769`). We switched the proxy from the blue to the green
    release. There was no downtime during this process since we waited until the new
    release is fully up and running before changing the proxy. Also, nginx is intelligent
    enough not to apply the configuration change to all requests but only to those
    made after the reload. In other words, all requests started before the reload
    continued using the old release while all those initiated afterward were sent
    to the new release. We managed to accomplish zero-downtime with minimum effort
    and without resorting to any new tool. We used nginx as a proxy and Consul (together
    with Registrator and Consul Template) to store and retrieve service information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，最后一个请求进入了不同的端口（`32770`），与我们之前的请求所用的端口（`32769`）不同。我们将代理从蓝色版本切换到了绿色版本。由于我们等到新的版本完全启动并运行后才更改代理配置，因此整个过程中没有出现停机时间。此外，nginx
    足够智能，只有在重新加载后才会将配置更改应用于所有请求，而不是应用于所有请求。换句话说，所有在重新加载前发起的请求继续使用旧版本，而所有在重新加载后发起的请求则会被发送到新版本。我们通过最小的努力，使用
    nginx 作为代理和 Consul（配合 Registrator 和 Consul Template）来存储和获取服务信息，实现了零停机时间。
- en: '![Integrating the green release](img/B05848_13_09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![集成绿色版本](img/B05848_13_09.jpg)'
- en: Figure 13-9 – The green container integrated with the proxy service
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-9 – 绿色容器与代理服务集成
- en: As a result of what we did by now, the new release was deployed in parallel
    with the old one and proxy was changed to point to that new release. Now we can
    safely remove the old release.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的操作使得新的版本与旧版本并行部署，并且代理已更改为指向新的版本。现在我们可以安全地移除旧版本了。
- en: Removing the blue release
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除蓝色版本
- en: Removing a release is easy, and we did it many times before. All we have to
    do is make sure that the correct target is used when running the `stop` command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 移除版本很简单，我们之前已经做过很多次。我们只需要确保在运行 `stop` 命令时使用了正确的目标。
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first command stopped the blue release, and the second listed all processes
    specified as Docker Compose targets. The output of the command that list processes
    is as follows.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令停止了蓝色版本，第二个命令列出了所有指定为 Docker Compose 目标的进程。列出进程的命令输出如下。
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Please note that the state of the `booksms_app-blue_1` is `Exit 137`. Only the
    green release and the database containers are running.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`booksms_app-blue_1` 的状态是 `Exit 137`。只有绿色版本和数据库容器在运行。
- en: We can also confirm the same by sending a request to Consul.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过向 Consul 发送请求来确认这一点。
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Consul response is as follows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Consul 的响应如下。
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Registrator detected the removal of the blue release and removed it from Consul.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Registrator 检测到蓝色版本被移除，并从 Consul 中删除了它。
- en: We should also check that the green release is still integrated with the proxy
    service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要检查绿色版本是否仍然与代理服务集成。
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As expected, nginx is still sending all requests to the green release and our
    work is done (for now). To summarize, we deployed a new release in parallel with
    the old one, changed the proxy service to point to the new release and, once all
    requests invoked with the old release received their responses, removed the old
    release.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，nginx 仍然将所有请求发送到绿色版本，我们的工作完成了（暂时）。总结来说，我们在旧版本并行部署了新版本，修改了代理服务使其指向新版本，等到所有与旧版本关联的请求完成响应后，移除了旧版本。
- en: '![Removing the blue release](img/B05848_13_10.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![移除蓝色版本](img/B05848_13_10.jpg)'
- en: Figure 13-10 – The blue container is removed
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-10 – 蓝色容器被移除
- en: The only thing left, before we proceed with the automation, is to find a better
    way to discover which release to deploy (blue or green). While running manually,
    we can easily find that information by simply listing docker processes or services
    registered in Consul and observing which color is not running. The automated deployment
    will require a bit different approach. We should discover which release to run.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行自动化部署之前，剩下的唯一任务是找到一种更好的方法来确定要部署哪个版本（蓝色或绿色）。在手动操作时，我们可以通过简单地列出 Docker 进程或在
    Consul 中注册的服务，并观察哪个颜色没有运行，从而轻松找到这个信息。自动化部署将需要稍微不同的方法。我们需要发现应该运行哪个版本。
- en: Let us remove the containers and start over.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除容器并重新开始。
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Discovering which release to deploy and rolling back
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定要部署哪个版本并回滚
- en: One way to know which color to deploy next would be to store the deployed color
    to Consul and use that information for the next deployment. In other words, we
    should have two processes; color discovery and color registration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确定下一个要部署的颜色的一种方法是将已部署的颜色存储到 Consul 中，并在下次部署时使用该信息。换句话说，我们应该有两个过程：颜色发现和颜色注册。
- en: 'Let''s think about use cases of the color discovery. There are three possible
    combinations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下颜色发现的使用场景。有三种可能的组合：
- en: We are deploying the first release, and no color is stored in the registry.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在部署第一个版本，注册表中没有存储颜色信息。
- en: The blue release is running and stored in the registry.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝色版本正在运行，并已存储在注册表中。
- en: The green release is running and stored in the registry.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绿色版本正在运行，并已存储在注册表中。
- en: We can reduce those combinations to two. If blue color is registered, the next
    one is green. Otherwise, the next color is blue covering both the case when the
    current color is green or when no color is registered (when service has never
    been deployed). With this strategy, we can create the following bash script (please
    do not run it yet).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些组合减少为两种。如果注册了蓝色版本，下一步就是绿色。否则，下一步就是蓝色，涵盖当前颜色为绿色或未注册任何颜色（即服务从未部署过）这两种情况。通过这种策略，我们可以创建以下
    bash 脚本（请不要现在运行它）。
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since we could use the same script for many services, it accepts two arguments;
    the name of the service we are about to deploy and the destination (production)
    server. Then, we query Consul on the production server and put the result into
    the `CURR_COLOR` variable. That is followed by a simple `if…else` statement that
    sends the `green` or the `blue` string to `STDOUT`. With such a script, we can
    easily retrieve the color we should use to deploy a service.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以使用相同的脚本来处理多个服务，它接受两个参数：我们即将部署的服务名称和目标（生产）服务器。然后，我们在生产服务器上查询 Consul 并将结果存储到
    `CURR_COLOR` 变量中。接着是一个简单的 `if…else` 语句，将 `green` 或 `blue` 字符串输出到 `STDOUT`。有了这样的脚本，我们可以轻松地获取应该用于部署服务的颜色。
- en: 'Let''s create the script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建脚本：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We created the `get-color.sh` script and gave it executable permissions. Now
    we can use it to retrieve the next color and repeat the procedure we practiced
    before.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 `get-color.sh` 脚本并赋予了它可执行权限。现在我们可以使用它来获取下一个颜色，并重复之前练习过的过程。
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only difference when compared with the commands we run earlier, is that
    we're using the `NEXT_COLOR` variable instead of hard-coded values `blue` and
    `green`. As a result, we have the first release (blue) up and running.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前执行的命令唯一的不同之处在于，我们使用了 `NEXT_COLOR` 变量，而不是硬编码的 `blue` 和 `green` 值。因此，我们已经成功启动了第一个版本（蓝色）。
- en: '![Discovering which release to deploy and rolling back](img/B05848_13_11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![发现要部署哪个版本并回滚](img/B05848_13_11.jpg)'
- en: Figure 13-11 – The color of the current release is retrieved from Consul
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-11 – 当前版本的颜色从 Consul 中获取
- en: Let's use this opportunity to have a short discussion about testing. On one
    hand, we want to test as much as possible before we change the proxy to point
    to the new release. On the other hand, we still need to make one round of tests,
    after the proxy is changed, to be sure that everything (including the change of
    the proxy) is running as expected. We'll call those two types pre-integration
    tests and post-integration tests. Keep in mind that their scope should be limited
    to those cases that could not be covered with pre-deployment tests. In the case
    of the (relatively small) `books-ms` service, it should be enough if pre-integration
    tests verify that the service can communicate with the database. In such a case,
    the only thing left to check after the integration with the proxy service, is
    that nginx has been reconfigured correctly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借此机会简短讨论一下测试。 一方面，我们希望在更改代理指向新发布版本之前尽可能多地进行测试。另一方面，我们仍然需要在代理更改后进行一次测试，以确保一切（包括代理的更改）按预期运行。我们将这两种类型的测试称为预集成测试和后集成测试。请记住，它们的范围应仅限于那些无法通过预部署测试覆盖的情况。对于（相对较小的）`books-ms`服务来说，如果预集成测试验证服务能够与数据库通信，那么这就足够了。在这种情况下，集成后唯一需要检查的就是nginx是否已正确重新配置。
- en: Let's start with pre-integration tests. We'll simulate testing using `curl`.
    Since the proxy is still not changed to point to the newly deployed service, we
    need to find out what the port the newly released service is. We can find the
    port from Consul and create a script similar to the `get-color.sh`. The script
    can be created with the following command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从预集成测试开始。我们将使用`curl`模拟测试。由于代理尚未更改为指向新部署的服务，我们需要找出新发布服务的端口。我们可以从Consul中找到端口，并创建一个类似于`get-color.sh`的脚本。可以使用以下命令创建脚本。
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This time, we created the script named `get-port.sh` with three arguments; the
    name of the service, the address of the production server, and the color. With
    those three arguments, we are querying the information from Consul and sending
    the result to STDOUT.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们创建了一个名为`get-port.sh`的脚本，包含三个参数：服务名称、生产服务器地址和颜色。通过这三个参数，我们从Consul查询信息并将结果发送到STDOUT。
- en: Let's try it out.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下。
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The output will vary from case to case depending on the random port Docker assigned
    to our service. With the port stored inside the variable, we can test the service
    before integrating it with the proxy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会因Docker随机分配给我们的服务的端口不同而有所不同。通过将端口存储在变量中，我们可以在将服务与代理集成之前进行测试。
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Service returned the status code `200 OK` so we can proceed with the integration
    in a similar way we did before. When asked, please use `vagrant` as the password.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 服务返回了状态码`200 OK`，所以我们可以按照之前的方式继续进行集成。当需要时，请使用`vagrant`作为密码。
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With the service integrated, we can test it again but this time without the
    port.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 服务集成后，我们可以再次进行测试，但这次不需要使用端口。
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we should stop one of the containers. Which one should be stopped depends
    on the testing results. If pre-integration tests failed, we should stop the new
    release. There is no need to do anything with the proxy since, at this time, it
    is still sending all requests to the old release. On the other hand, if post-integration
    tests failed, not only that the new release should be stopped, but we should also
    revert changes to the proxy service so that all traffic goes back to the old release.
    At this moment we won't go through all the paths we might need to take in case
    of tests failures. That will be reserved for the automation that we will explore
    soon. For now, we'll put the color to Consul registry and stop the old release.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该停止其中一个容器。停止哪一个容器取决于测试结果。如果预集成测试失败，我们应该停止新的发布版本。此时，代理不需要做任何操作，因为它仍然将所有请求发送到旧版本。另一方面，如果集成后测试失败，不仅需要停止新的发布版本，还应该将代理服务的更改回滚，以便所有流量返回到旧版本。此时，我们不会逐一列举所有可能需要采取的路径。这些内容会留待我们稍后探索的自动化部分。现在，我们将颜色信息放入Consul注册表，并停止旧版本。
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This set of commands put the new color to the registry, obtained the next color
    that should be equivalent to the color of the old release, and, finally, stopped
    the old release. Since we started over and this is the first release, there was
    no old release to be stopped. Never the less, the next time we run the process,
    the old release will indeed be stopped.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列命令将新颜色加入注册表，获取下一个应该与旧版本颜色相同的颜色，最后停止旧版本。由于我们重新开始并且这是第一次发布，因此没有旧版本需要停止。然而，下次运行该过程时，旧版本将会被停止。
- en: '![Discovering which release to deploy and rolling back](img/B05848_13_12.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![发现要部署的版本并回滚](img/B05848_13_12.jpg)'
- en: Figure 13-12 – The color of the current release is sent to Consul
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-12 – 当前版本的颜色被发送到Consul
- en: With this, we concluded the manual process of blue-green deployment. It is done
    in a way that it can easily be automated. Before we move forward, let's run all
    those commands few more times and observe that the color changes from blue to
    green, from green to blue and so on. All the commands grouped together are as
    follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了蓝绿部署的手动过程。它的实现方式使得这一过程可以轻松自动化。在继续之前，让我们再运行几次这些命令，并观察颜色从蓝色变为绿色，再从绿色变为蓝色，依此类推。所有命令汇总如下。
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The last command showed Docker processes. You will see that, after the first
    run, the green release will be running, and the blue will be in Exited state,
    and then, after the next run, the blue release will be running, and the green
    will be in the Exited state, and so on. We managed to deploy new releases without
    any downtime. The only exception is if post-integration tests fail, which is very
    unlikely to happen since the only cause for that would be a failure of the proxy
    service itself due to the wrong configuration. Since the process will soon be
    fully automated, such a thing is indeed very unlikely to happen. Another reason
    for post-integration tests to fail would be if proxy service itself fails. The
    only way to remove this possibility is to have multiple instances of the proxy
    service (out of the scope of this book).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命令显示了Docker进程。你会看到，在第一次运行之后，绿色版本会在运行状态，而蓝色版本则处于“已退出”状态；接着，在下一次运行后，蓝色版本会处于运行状态，绿色版本则会进入“已退出”状态，依此类推。我们成功地在没有任何停机时间的情况下部署了新版本。唯一的例外是如果集成后测试失败，这种情况发生的可能性非常小，因为唯一的原因可能是代理服务本身由于配置错误导致的故障。由于这个过程将很快完全自动化，这种情况发生的可能性非常小。集成后测试失败的另一个原因是代理服务本身的故障。要消除这种可能性，唯一的办法是拥有多个代理服务实例（此书范围外）。
- en: That being said, let's see the nginx logs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来看一下nginx日志。
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You'll notice that each request we made was sent to a different port meaning
    that a new container was indeed deployed and running on a new port.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们每次发送的请求都被发送到不同的端口，这意味着一个新的容器确实已经被部署，并在新的端口上运行。
- en: Now, after all those commands and experiments, we are ready to start working
    on the automation of the blue-green deployment procedure.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在完成所有命令和实验后，我们已经准备好开始蓝绿部署过程的自动化工作。
- en: We'll destroy the virtual machines and start over to be sure that everything
    works correctly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将销毁虚拟机并重新开始，以确保一切正常运行。
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Automating the blue-green deployment with Jenkins workflow
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jenkins工作流自动化蓝绿部署
- en: We'll start by creating the VMs, provisioning the `prod` node, and bringing
    up Jenkins, our deployment tool of choice.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建虚拟机开始，配置`prod`节点，并启动Jenkins——我们选择的部署工具。
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since it will take a couple of minutes until everything is set, let us discuss
    what should be automated and how. We are already familiar with the Jenkins Workflow.
    It served us well, so there is no real reason to change the tool at this time.
    We'll use it to automate the blue-green deployment procedure. The flow will have
    quite a lot of steps so we'll break them into functions to digest the process
    more easily and, at the same time, to extend our workflow utilities script. More
    detailed discussion and implementation of those functions follow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于还需要几分钟时间才能完成设置，我们来讨论一下应该自动化什么以及如何自动化。我们已经熟悉了Jenkins工作流。它为我们提供了很好的支持，所以目前没有理由更换工具。我们将使用它来自动化蓝绿部署过程。这个流程将包含很多步骤，因此我们将把它们分解成多个函数，以便更容易理解，同时也能扩展我们的工作流工具脚本。接下来将详细讨论和实现这些函数。
- en: '![Automating the blue-green deployment with Jenkins workflow](img/B05848_13_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jenkins工作流自动化蓝绿部署](img/B05848_13_13.jpg)'
- en: Figure 13-13 – Blue-green deployment automation flow
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-13 – 蓝绿部署自动化流程
- en: Blue-green deployment role
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署角色
- en: We'll use the *Multibranch Workflow* Jenkins job `books-ms-blue-green`. It filters
    branches of the `vfarcic/books-ms` repository so that only those containing `blue-green`
    in their names are included.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *Multibranch Workflow* Jenkins 作业 `books-ms-blue-green`。它筛选 `vfarcic/books-ms`
    仓库的分支，仅包含名称中含有 `blue-green` 的分支。
- en: Since the first run might take a considerable amount of time, let's index branches
    so that Jenkins can run the subprojects while we explore the script.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一次运行可能需要相当长的时间，我们先对分支进行索引，这样 Jenkins 就可以在我们探索脚本的同时运行子项目。
- en: Please open the Jenkins Multibranch Workflow job `books-ms-blue-green`, click
    the **Branch Indexing** and, then, **Run Now** links from the left-hand menu.
    Once branches are indexed, Jenkins will find that the `blue-green` branch matches
    the filter set inside the job, create the subproject with the same name and start
    running it. The indexing status can be seen in the `master` node executor located
    in the bottom-left part of the screen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请打开 Jenkins Multibranch Workflow 作业 `books-ms-blue-green`，点击左侧菜单中的 **Branch
    Indexing** 和 **Run Now** 链接。分支索引完成后，Jenkins 会发现 `blue-green` 分支符合作业中设置的筛选条件，创建一个相同名称的子项目并开始运行。索引状态可以在屏幕左下角的
    `master` 节点执行器中查看。
- en: '![Blue-green deployment role](img/B05848_13_14.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署角色](img/B05848_13_14.jpg)'
- en: Figure 13-14 – The Jenkins Multibranch Workflow job books-ms-blue-green with
    the blue-green subproject
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-14 – Jenkins Multibranch Workflow 作业 `books-ms-blue-green` 和蓝绿子项目
- en: We'll leave Jenkins running the build and explore the `Jenkinsfile` inside the
    `blue-green` branch.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让 Jenkins 继续运行构建并探索 `blue-green` 分支中的 `Jenkinsfile`。
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The file starts with the declaration of a few variables followed by the load
    of the `workflow-util.groovy` script. That is followed with invocations of the
    functions that provision the environments, build and run tests, and build the
    service. Up until now, the script is the same as the one we explored in the previous
    chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 文件以声明一些变量开始，然后加载 `workflow-util.groovy` 脚本。接下来是调用一些函数来配置环境、构建并运行测试，以及构建服务。直到这一点为止，脚本与我们在上一章中探索的脚本相同。
- en: The first new additions are invocations of the utilities functions `getCurrentColor`
    and `getNextColor` and assignment of values they return to the `currentColor`
    and the `nextColor` variables. The functions are as follows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新增的内容是调用实用函数 `getCurrentColor` 和 `getNextColor`，并将它们返回的值赋给 `currentColor`
    和 `nextColor` 变量。以下是这些函数的代码。
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, those functions follow the same logic as the one we practiced
    with manual commands but, this time, translated to Groovy. The current color is
    retrieved from Consul and used to deduce the next color we should deploy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些函数遵循与我们使用手动命令练习时相同的逻辑，只不过这次是翻译成 Groovy 语言。当前颜色从 Consul 获取，并用于推断我们应该部署的下一个颜色。
- en: Now that we know what the currently running color is as well as what the next
    color should be, we can deploy the new release using the `deployBG`. The function
    is as follows.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道当前运行的颜色以及下一个应该部署的颜色，我们可以使用 `deployBG` 部署新版本。该函数如下所示。
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We created the `DOCKER_HOST` environment variable pointing to Docker CLI running
    on the production node. The variable scope is limited to the commands within its
    curly braces. Inside them, we are pulling the latest release and running it through
    Docker Compose. The only important difference when, compared with the `Jenkinsfile`
    script we explored in the previous chapter, is the dynamic generation of the target
    through the `color` variable. The target that will be used depends on the actual
    value of the `nextColor` used to invoke this function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了指向生产节点上 Docker CLI 的 `DOCKER_HOST` 环境变量。该变量的作用范围仅限于花括号内的命令。在这些命令中，我们拉取最新版本并通过
    Docker Compose 运行。与我们在上一章中探索的 `Jenkinsfile` 脚本相比，唯一重要的不同之处是通过 `color` 变量动态生成目标。将使用的目标取决于用于调用该函数的
    `nextColor` 的实际值。
- en: At this point in the script, a new release is deployed but still not integrated
    with the proxy service. The users of our service would still be using the old
    release thus giving us the opportunity to test the newly deployed version before
    making it publicly available. We'll call them pre-integration tests. They are
    run by invoking the utility function `runBGPreIntegrationTests` located in the
    `workflow-util.groovy` script.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的这一部分，一个新版本被部署，但尚未与代理服务集成。我们的服务用户仍然会使用旧版本，从而为我们提供了在公开发布之前测试新部署版本的机会。我们称之为预集成测试。它们通过调用位于
    `workflow-util.groovy` 脚本中的实用函数 `runBGPreIntegrationTests` 来运行。
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The function starts by retrieving the address of the newly deployed service
    from Consul. This retrieval is accomplished through invocation of the `getAddress`
    function. Please consult the details of the function by examining the `workflow-util.groovy`
    script. Next, we run the tests inside a `try…catch` block. Since the new release
    is still not integrated with nginx and, therefore, not accessible through the
    port `80`, we are passing the `address` of the release as an environment variable
    `DOMAIN`. If the execution of tests fails, the script will jump to the `catch`
    block and call the `stopBG` function that will stop the new release. Since our
    servers are running [Registrator], once the new release is stopped, its data will
    be removed from Consul. There's nothing else to be done. Proxy service will continue
    pointing to the old release, and, through it, our users will continue using the
    old version of our service that is proven to work correctly. Please consult the
    `workflow-util.groovy` script to see details of the `stopBG` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先通过调用`getAddress`函数从Consul获取新部署服务的地址。请通过查看`workflow-util.groovy`脚本来了解该函数的详细信息。接下来，我们在`try…catch`块中运行测试。由于新版本仍未与nginx集成，因此无法通过端口`80`访问，我们将新版本的`address`作为环境变量`DOMAIN`传递。如果测试执行失败，脚本将跳转到`catch`块，并调用`stopBG`函数来停止新版本的服务。由于我们的服务器运行着[Registrator]，一旦新版本停止，它的数据将从Consul中删除。没有其他操作需要执行。代理服务将继续指向旧版本，用户将通过它继续使用经过验证的旧版本服务。请查看`workflow-util.groovy`脚本以了解`stopBG`函数的详细信息。
- en: If the pre-integration tests passed, we are invoking the `updateBGProxy` function
    that updates the proxy service thus making our new release available to our users.
    The function is as follows.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预集成测试通过，我们将调用`updateBGProxy`函数来更新代理服务，从而使新版本可以对用户可用。该函数如下所示。
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The major difference, when compared with the `updateProxy` function we used
    in the previous chapter, is the usage of `nginx-upstreams-${color}.ctmpl` as the
    name of the template. Depending on the value we pass to the function, `nginx-upstreams-blue.ctmpl`,
    or `nginx-upstreams-green.ctmpl` will be used. As an additional instruction, we
    are sending a request to Consul to store the color related to the newly deployed
    release. The rest of this function is the same as the `updateProxy`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章节中使用的`updateProxy`函数相比，主要的区别在于模板名称的使用，即`nginx-upstreams-${color}.ctmpl`。根据我们传递给函数的值，`nginx-upstreams-blue.ctmpl`或`nginx-upstreams-green.ctmpl`将被使用。作为额外的指令，我们向Consul发送请求，以存储与新部署版本相关的颜色信息。该函数的其他部分与`updateProxy`函数相同。
- en: Finally, now that the new release is deployed, and the proxy service has been
    reconfigured, we are doing another round of testing to confirm that the integration
    with the proxy was indeed correct. We're doing that by invoking the `runBGPostIntegrationTests`
    function located in the `workflow-util.groovy` script.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，现在新版本已经部署完成，并且代理服务已重新配置，我们正在进行另一轮测试，以确认与代理的集成是否确实正确。我们通过调用位于`workflow-util.groovy`脚本中的`runBGPostIntegrationTests`函数来进行测试。
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We start by running integration tests that are, this time, using the public
    domain that points to the proxy. If tests fail, we are reverting the changes to
    the proxy service by invoking the `updateBGProxy` function. By passing the `currentColor`
    as the variable, `updateBGProxy` will reconfigure nginx to work with the old release
    of the service. The second instruction in case of a failure of tests is to stop
    the new release by invoking the `stopBG` function with `nextColor`. On the other
    hand, if all tests passed, we are stopping the old release.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先运行集成测试，这次使用指向代理的公共域名。如果测试失败，我们将通过调用`updateBGProxy`函数来恢复代理服务的更改。通过传递`currentColor`作为变量，`updateBGProxy`将重新配置nginx以与旧版本服务配合使用。如果测试失败的第二个指令是通过调用`stopBG`函数并传入`nextColor`来停止新版本。另一方面，如果所有测试都通过，我们将停止旧版本。
- en: If you are new to Groovy, this script might have been overwhelming. However,
    with a little bit of practice, you'll see that, for our purposes, Groovy is very
    simple and with the addition of Jenkins Workflow DSL, many things are made even
    easier.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Groovy的新手，这个脚本可能会让你感到不知所措。然而，只要稍加练习，你会发现，对于我们的目的来说，Groovy是非常简单的，并且借助Jenkins
    Workflow DSL，许多事情变得更加容易。
- en: It is worth noting that the Workflow plugin is restrictive. For security reasons,
    invocation of some Groovy classes and functions needs to be approved. I already
    did that for you as part of the provisioning and configuration process defined
    through the `jenkins.yml` Ansible playbook. If you'd like to see the end result
    or would need to make new approvals, please open **In-process Script Approval**
    screen located inside **Manage Jenkins**. At first, those security restrictions
    might seem over-the-top, but the reasoning behind them is essential. Since Workflow
    scripts can access almost any part of the Jenkins platform, letting anything run
    inside it might have very severe consequences. For that reason, some instructions
    are allowed by default while others need to be approved. If a Workflow script
    fails due to this restriction, you'll see a new entry in the **In-process Script
    Approval** screen waiting for your approval (or disapproval). The XML behind those
    approvals is located in the `/data/jenkins/scri` `ptApproval.xml` file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Workflow插件是有限制的。出于安全原因，某些Groovy类和函数的调用需要获得批准。我已经在通过`jenkins.yml` Ansible
    playbook定义的供应和配置过程中为你完成了这项操作。如果你想查看最终结果或需要做出新的批准，请打开**正在处理的脚本审批**屏幕，该屏幕位于**管理Jenkins**中。刚开始时，这些安全限制可能显得过于严苛，但它们背后的理由是至关重要的。由于Workflow脚本可以访问Jenkins平台的几乎任何部分，让任何内容在其中运行可能会带来严重后果。因此，某些指令默认被允许，而其他的则需要批准。如果由于这个限制，Workflow脚本失败，你将在**正在处理的脚本审批**屏幕中看到一个新的条目，等待你的批准（或拒绝）。这些批准背后的XML文件位于`/data/jenkins/scri`
    `ptApproval.xml`文件中。
- en: Running the blue-green deployment
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行蓝绿部署
- en: Hopefully, by this time, the subproject finished running. You can monitor the
    process by opening blue-green subproject Console screen. Once the first run of
    the subproject is finished, we can manually confirm that everything run correctly.
    We'll use this opportunity to showcase few `ps` arguments we haven't used. The
    first one will be `--filter` that can be used to (you guessed it) filter containers
    returned with the `ps` command. The second one is `--format`. Since the standard
    output of the `ps` command can be very long, we'll use it to retrieve only names
    of the containers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到这个时候，子项目已经完成运行。你可以通过打开蓝绿子项目控制台屏幕来监控该进程。一旦子项目的第一次运行完成，我们可以手动确认一切是否正确运行。我们将利用这个机会展示一些我们尚未使用的`ps`参数。第一个是`--filter`，它可以用来（你猜对了）过滤通过`ps`命令返回的容器。第二个是`--format`。由于`ps`命令的标准输出可能非常长，我们将使用它来只获取容器的名称。
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The output of the `ps` command is as follows.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令的输出如下。'
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can see that the `blue` release has been deployed together with the linked
    database. We can also confirm that the service has been stored in Consul.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`blue`版本已经与数据库一起部署。我们还可以确认该服务已存储在Consul中。
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The combined output of the two requests to Consul is as follows.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 两个请求对Consul的合并输出如下。
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `books-ms-blue` has been registered as a service besides the `dockerui`
    and `consul`. The second output shows all the details of the service.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`books-ms-blue`已经注册为一个服务，除了`dockerui`和`consul`之外。第二个输出显示了服务的所有详细信息。'
- en: Finally, we should verify that the color has been stored in Consul and that
    the service itself is indeed integrated with nginx.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该验证颜色已经存储在Consul中，并且服务本身确实与nginx集成。
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first command returned `blue`, and the status of the request to the service
    through the proxy is `200 OK`. Everything seems to be working correctly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令返回了`blue`，通过代理请求到服务的状态是`200 OK`。一切似乎都在正常运行。
- en: Please run the job a couple of more times by opening the `books-ms-blue-green`
    job and clicking the **Schedule a build for blue-green** icon located on the right-hand
    side.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过打开`books-ms-blue-green`作业并点击位于右侧的**安排蓝绿构建**图标，再运行几次作业。
- en: You can monitor the process by opening the blue-green subproject Console screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开蓝绿子项目控制台屏幕来监控该进程。
- en: '![Running the blue-green deployment](img/B05848_13_15.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Running the blue-green deployment](img/B05848_13_15.jpg)'
- en: Figure 13-15 – The Jenkins blue-green subproject Console screen
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-15 – Jenkins蓝绿子项目控制台屏幕
- en: If you repeat the manual verifications, you'll notice that the second time the
    `green` release will be running, and the `blue` will be stopped. The third run
    will invert colors and the `blue` release will be running while the `green` will
    be stopped. The correct color will be stored in Consul, proxy service will always
    redirect requests to the latest release, and there will be no downtime during
    the deployment process.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重复手动验证，你会注意到第二次时，`green` 版本会运行，而 `blue` 版本会停止。第三次运行时，颜色会反转，`blue` 版本会运行，而
    `green` 版本会停止。正确的颜色会存储在 Consul 中，代理服务会始终将请求重定向到最新的版本，并且在部署过程中不会出现停机时间。
- en: Even though we are reaching the end of this chapter, we are not finished practicing
    the blue-green deployment. Even though we will change the way we are running the
    procedure, it will be the integral part of a couple of more practices we'll explore
    throughout the rest of this book. We accomplished zero-downtime deployments, but
    there is still a lot of work left before we reach zero-downtime system. The fact
    that our current process does not produce downtime during deployments does not
    mean that the whole system is fault tolerant.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们即将结束本章内容，我们仍未完成蓝绿部署的练习。虽然我们将改变运行程序的方式，但它将是我们接下来在本书中探讨的几个实践的核心部分。我们实现了零停机时间的部署，但在达到零停机时间的系统之前，还有很多工作要做。我们当前的过程虽然在部署期间不会产生停机时间，但这并不意味着整个系统是容错的。
- en: We reached a significant milestone, yet there are still a lot of obstacles left
    to overcome. One of them is clustering and scaling. The solution we have works
    well on a single server. We could easily extend it to support a few more, maybe
    even ten. However, the bigger the number of our servers, the greater the need
    to look for a better way to manage clustering and scaling. That will be the subject
    of the next chapter. Until then, let us destroy the environments we've been using
    so that we can start fresh.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了一个重要的里程碑，但仍然有许多障碍需要克服。其中之一就是集群和扩展。我们现有的解决方案在单台服务器上运行良好。我们可以很容易地将其扩展，以支持更多的服务器，可能是几台，甚至十台。然而，服务器的数量越多，就越需要寻找一种更好的方式来管理集群和扩展。这将是下一章的主题。在那之前，让我们销毁我们一直在使用的环境，以便重新开始。
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
