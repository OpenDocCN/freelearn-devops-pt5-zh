- en: Automating Continuous Deployment Flow with Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '使用Jenkins自动化持续部署流程  '
- en: The most powerful tool we have as developers is automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '作为开发人员，我们最强大的工具就是自动化。  '
- en: -Scott Hanselman
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '-Scott Hanselman  '
- en: We already have all the commands required for a fully automated Continuous Deployment
    flow. Now we need a tool that will monitor changes in our code repository and
    trigger those commands every time a commit is detected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经拥有了实现完全自动化持续部署流程所需的所有命令。现在我们需要一个工具，它可以监控代码库的变化，并在每次检测到提交时触发这些命令。  '
- en: There is a plethora of CI/CD tools on the market. We'll choose Jenkins. That
    does not mean that it is the only choice nor that it is the best one for all use
    cases. I won't compare different tools nor provide more details behind the decision
    to use Jenkins. That would require a chapter on its own or even a whole book.
    Instead, we'll start by discussing Jenkins architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '市场上有大量的CI/CD工具。我们选择Jenkins。并不意味着它是唯一的选择，也不是在所有使用场景中最好的选择。我不会对不同的工具进行比较，也不会提供更多的使用Jenkins的决策背后的细节。这将需要一个单独的章节，甚至是一本书。相反，我们将从讨论Jenkins的架构开始。  '
- en: Jenkins architecture
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Jenkins架构  '
- en: Jenkins is a monolithic application based on a combination of a master and agents.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jenkins是一个基于主节点和代理的组合的单体应用程序。  '
- en: Jenkins master can be described as an orchestrator. It monitors sources, triggers
    jobs when predefined conditions are met, stores logs and artifacts, and performs
    a myriad of other tasks related to CI/CD orchestration. It does not run actual
    tasks but makes sure that they are executed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jenkins的主节点可以被描述为一个协调者。它监控源代码，当满足预定条件时触发任务，存储日志和工件，并执行与CI/CD协调相关的许多其他任务。它不执行实际任务，而是确保任务被执行。  '
- en: Jenkins agent, on the other hand, does the actual work. When master triggers
    a job execution, the actual work is performed by an agent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，Jenkins代理执行实际的工作。当主节点触发任务执行时，实际的工作是由代理执行的。  '
- en: We cannot scale Jenkins master. At least not in the same way as we scaled the
    `go-demo` service. We can create multiple Jenkins masters, but they cannot share
    the same file systems. Since Jenkins uses files to store its state, creating multiple
    instances would result in completely separate applications. Since the main reasons
    behind scaling are fault tolerance and performance benefits, none of those goals
    would be accomplished by scaling Jenkins master.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法扩展Jenkins主节点。至少不能像我们扩展`go-demo`服务那样扩展它。我们可以创建多个Jenkins主节点，但它们不能共享相同的文件系统。由于Jenkins使用文件来存储其状态，创建多个实例会导致完全独立的应用程序。由于扩展的主要原因是容错性和性能收益，通过扩展Jenkins主节点无法实现这些目标。
- en: If Jenkins cannot be scaled, how do we meet performance requirements? We increase
    the capacity by adding agents. A single master can handle many agents. In most
    cases, an agent is a whole server (physical or virtual). It is not uncommon for
    a single master to have tens or even hundreds of agents (servers). In turn, each
    of those agents runs multiple executors that run tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '如果Jenkins无法扩展，我们如何满足性能要求呢？我们通过添加代理来增加容量。一个主节点可以处理许多代理。在大多数情况下，一个代理是一个完整的服务器（物理或虚拟）。一个主节点拥有几十个甚至几百个代理（服务器）并不罕见。反过来，每个代理会运行多个执行器来运行任务。  '
- en: Traditionally, Jenkins master and agents would run on a dedicated server. That,
    in itself, poses a few problems. If Jenkins is running on a dedicated server,
    what happens when it fails? Remember, everything fails sooner or later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '传统上，Jenkins的主节点和代理会运行在专用服务器上。这本身就会带来一些问题。如果Jenkins运行在专用服务器上，当服务器出现故障时会发生什么？记住，一切都会有故障的时候。  '
- en: For many organizations, Jenkins is mission critical. If it's not operational,
    new releases are not made, scheduled tasks are not run, software is not deployed,
    and so on. Typically, Jenkins failure would be fixed by moving the software together
    with the files that form its state to a healthy server. If that is done manually,
    and it usually is, the downtime can be substantial.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '对于许多组织来说，Jenkins是至关重要的。如果它不可用，就无法发布新版本，无法执行计划任务，无法部署软件，等等。通常，Jenkins的故障会通过将软件及其状态文件移动到健康的服务器来修复。如果这是手动完成的，而且通常是手动的，那么停机时间可能会非常长。  '
- en: Throughout this chapter, we'll leverage the knowledge we obtained by now and
    try to make Jenkins fault tolerant. We might not be able to accomplish zero-downtime
    but, at least, we'll do our best to reduce it as much as possible. We'll also
    explore ways to apply what we learned to create a master and Jenkins agents in
    (almost) fully automated way. We'll try to make the master fault tolerant and
    agents scalable and dynamic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用到目前为止获得的知识，尝试让 Jenkins 具备容错能力。我们可能无法实现零停机，但至少会尽力将停机时间缩短到最低。我们还将探讨如何应用所学知识，以几乎完全自动化的方式创建
    Jenkins 主节点和代理。我们将尽力让主节点具备容错能力，代理则具备可扩展性和动态性。
- en: Enough talk! Let's move towards more practical parts of the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，别再说了！让我们进入本章更实际的部分。
- en: Production environment setup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境设置
- en: We'll start by recreating the production cluster we used in the previous chapters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从重新创建上一章使用的生产集群开始。
- en: 'All the commands from this chapter are available in the `06-jenkins.sh` ([https://gist.github.com/vfarcic/9f9995f90c6b8ce136376e38afb14588](https://gist.github.com/vfarcic/9f9995f90c6b8ce136376e38afb14588))
    Gist:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有命令都可以在 `06-jenkins.sh`  ([https://gist.github.com/vfarcic/9f9995f90c6b8ce136376e38afb14588](https://gist.github.com/vfarcic/9f9995f90c6b8ce136376e38afb14588))
    Gist 中找到：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We entered the `cloud-provisioning` repository we cloned earlier and pulled
    the latest code. Then we executed the `scripts/dm-swarm.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm.sh))
    script that created the production cluster. It is the same script we used in the
    previous chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了之前克隆的 `cloud-provisioning` 仓库并拉取了最新的代码。然后执行了创建生产集群的 `scripts/dm-swarm.sh`
     ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm.sh))
    脚本。这是我们在上一章中使用的相同脚本。
- en: 'Let''s confirm that the cluster was indeed created correctly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认集群确实已正确创建：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the `node ls` command is as follows (IDs are removed for brevity):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`node ls` 命令的输出如下（为了简洁，ID已删除）：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that the production cluster is up and running, we can create the Jenkins
    service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生产集群已经启动并运行，我们可以创建 Jenkins 服务了。
- en: Jenkins service
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins 服务
- en: Traditionally, we would run Jenkins in its own server. Even if we'd choose to
    share server's resources with other applications, the Deployment would still be
    static. We'd run a Jenkins instance (with or without Docker) and hope that it
    never fails. The problem with this approach is in the fact that every application
    fails sooner or later. Either the process will stop, or the whole node will die.
    Either way, Jenkins, like any other application, will stop working at some moment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们会在自己的服务器上运行 Jenkins。即使我们选择与其他应用程序共享服务器资源，部署仍然是静态的。我们会运行一个 Jenkins 实例（无论是否使用
    Docker），并希望它永不失败。这个方法的问题在于，每个应用程序迟早都会失败。要么进程会停止，要么整个节点会崩溃。不管怎样，Jenkins 和其他任何应用程序一样，都会在某个时刻停止工作。
- en: The problem is that Jenkins has become a critical application in many organizations.
    If we move the execution or, to be more precise, triggering of all automation
    into Jenkins, we create a strong dependency. If Jenkins is not running, our code
    is not built, it is not tested, and it is not deployed. Sure, when it fails, you
    can bring it up again. If the server on which it is running stops working, you
    can deploy it somewhere else. The downtime, assuming it happens during working
    hours, will not be long. An hour, maybe two, or even more time will pass since
    the moment it stops working, someone finds out, notifies someone else, that someone
    restarts the application or provisions a new server. Is that a long time? It depends
    on the size of your organization. The more people depend on something, the bigger
    the cost when that something doesn't work. Even if such a downtime and the cost
    it produces is not critical, we already have all the knowledge and the tools to
    avoid it. All we have to do is create another service and let Swarm take care
    of the rest.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，Jenkins 已经成为许多组织中的关键应用。如果我们将所有自动化的执行或更准确地说，触发过程移到 Jenkins 上，我们就创建了一个强依赖关系。如果
    Jenkins 没有运行，我们的代码就不能构建、不能测试、不能部署。当然，当它失败时，你可以重新启动它。如果它运行的服务器停止工作，你可以将其部署到其他地方。假设停机发生在工作时间内，停机时间不会太长。从它停止工作到有人发现、通知其他人、有人重启应用程序或配置一个新服务器，可能会过去一个小时，也许两个小时，甚至更长时间。这算长时间吗？这取决于你的组织规模。依赖某个东西的人越多，那东西出现问题时的成本就越大。即使这样的停机时间及其带来的成本并不至关重要，我们已经掌握了所有知识和工具来避免这种情况。我们要做的只是创建另一个服务，让
    Swarm 处理其余部分。
- en: '**A note to Windows users**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户请注意**'
- en: 'Git Bash has a habit of altering file system paths. To stop this, execute the
    following before running the code block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash 有改变文件系统路径的习惯。在运行代码块之前，请执行以下命令以防止这种情况：
- en: '`export MSYS_NO_PATHCONV=1`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`export MSYS_NO_PATHCONV=1`'
- en: 'Let''s create a Jenkins service. Run the following commands from within the
    `cloud-provisioning` directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Jenkins 服务。从 `cloud-provisioning` 目录中运行以下命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**A note to Linux (example: Ubuntu) users**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux（例如：Ubuntu）用户请注意**'
- en: Docker Machine mounts users directory from the host inside the VMs it creates.
    That allows us to share the files. However, that feature does not work in Docker
    Machine running on Linux. The easiest workaround is, for now, to remove the `--mount`
    argument. Later on, when we reach persistent storage, you'll see how to mount
    volumes more effectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine 会将主机的用户目录挂载到它创建的虚拟机中。这使我们能够共享文件。然而，这个功能在运行 Linux 的 Docker Machine
    中无法使用。目前最简单的解决方法是去掉 `--mount` 参数。稍后，当我们达到持久存储时，你将看到如何更有效地挂载卷。
- en: 'The good news is that the problem will be fixed soon. Please see the *issue
    #1376* ([https://g](https://github.com/docker/machine/issues/1376)[ithub.com/docker/machine/issues/1376](https://github.com/docker/machine/issues/1376))
    for the discussion. Once the *pull request #2122* ([https://github.com/docker/machine/pull/2122](https://github.com/docker/machine/pull/2122))
    is merged, you will be able to use automatic mounting on Linux.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '好消息是这个问题很快就会解决。请参阅 *issue #1376* ([https://g](https://github.com/docker/machine/issues/1376)[ithub.com/docker/machine/issues/1376](https://github.com/docker/machine/issues/1376))
    以了解讨论情况。一旦 *pull request #2122* ([https://github.com/docker/machine/pull/2122](https://github.com/docker/machine/pull/2122))
    被合并，你将能够在 Linux 上使用自动挂载功能。'
- en: Jenkins stores its state in the file system. Therefore, we started by creating
    a directory `mkdir` on the host. It will be used as Jenkins home. Since we are
    inside one of the subdirectories of our host's user, the `docker/jenkins` directory
    is mounted on all the machines we created.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 将其状态存储在文件系统中。因此，我们首先在主机上创建了一个目录 `mkdir`。它将用作 Jenkins 的主目录。由于我们位于主机用户的子目录之一，`docker/jenkins`
    目录被挂载到我们创建的所有机器上。
- en: Next, we created the service. It exposes the internal port `8080` as `8082`
    as well as the port `50000`. The first one is used to access Jenkins UI and the
    second for master/agent communication. We also defined the URL prefix `as/jenkins`
    and mounted the `jenkins` home directory. Finally, we reserved `300m` of memory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了服务。它将内部端口 `8080` 映射为 `8082`，并且映射端口 `50000`。第一个端口用于访问 Jenkins UI，第二个用于主节点与代理节点的通信。我们还定义了
    URL 前缀 `as/jenkins` 并挂载了 `jenkins` 主目录。最后，我们保留了 `300m` 的内存。
- en: 'Once the image is downloaded, the output of the `service ps` command is as
    follows (IDs are removed for brevity):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像下载完成，`service ps` 命令的输出如下（为了简洁，删除了 ID）：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/cd-environment-jenkins-only.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd-environment-jenkins-only.png)'
- en: 'Figure 6-1: Production cluster with the Jenkins service'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：带有 Jenkins 服务的生产集群
- en: Jenkins 2 changed the setup process. While the previous versions allowed us
    to run it without any mandatory configuration, the new Jenkins forces us to go
    through some steps manually. Unfortunately, at the time of this writing, there
    is no good API to help us automate the process. While there are some *tricks*
    we could use, the benefits are not high enough when compared with the additional
    complexity they introduce. After all, we'll setup Jenkins only once, so there
    is no big incentive to automate the process (at least until a configuration API
    is created).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 2 改变了设置流程。以前的版本允许我们在没有任何强制配置的情况下运行，但新版 Jenkins 强制我们手动执行一些步骤。不幸的是，在撰写本文时，尚无好的
    API 来帮助我们自动化这个过程。尽管有一些 *技巧* 可以使用，但与它们带来的额外复杂性相比，得到的好处并不高。毕竟，我们只会设置 Jenkins 一次，所以没有很大的动力去自动化这个过程（至少在创建配置
    API 之前）。
- en: 'Let''s open the UI:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 UI：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**A note to Windows users**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户注意**'
- en: 'Git Bash might not be able to use the open command. If that''s the case, execute `docker-machine
    ip <SERVER_NAME>` to find out the IP of the machine and open the URL directly
    in your browser of choice. For example, the command above should be replaced with
    the command that follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash 可能无法使用 open 命令。如果是这种情况，可以执行 `docker-machine ip <SERVER_NAME>` 来找出机器的
    IP 地址，并直接在你选择的浏览器中打开该 URL。例如，上述命令应该替换为以下命令：
- en: '`docker-machine ip swarm-1`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine ip swarm-1`'
- en: If the output would be `1.2.3.4`, you should open `http://1.2.3.4:8082/jenkins`
    in your browser.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出是 `1.2.3.4`，你应该在浏览器中打开 `http://1.2.3.4:8082/jenkins`。
- en: The first thing you will notice is that you are required to introduce the Administrator
    password. Quite a few enterprise users requested security hardening. As a result,
    Jenkins cannot be accessed, anymore, without initializing a session. If you are
    new to Jenkins, or, at least, *version 2*, you might wonder what the password
    is. It is output to logs (in our case `stdout`) as well as to the file `secrets/initialAdminPassword`,
    which will be removed at the end of the setup process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，系统要求你输入管理员密码。许多企业用户要求增强安全性。因此，Jenkins 不再允许在没有初始化会话的情况下访问。如果你是 Jenkins
    新手，或者至少是 *版本 2* 的用户，你可能会想知道密码是什么。它会输出到日志中（在我们的案例中是 `stdout`），也会输出到文件 `secrets/initialAdminPassword`
    中，该文件会在设置过程结束时被删除。
- en: 'Let''s see the content of the `secrets/initialAdminPassword` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看 `secrets/initialAdminPassword` 文件的内容：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output will be a `long` string that represents the temporary password.
    Please copy it, go back to the UI, paste it to the Administrator password field,
    and click the Continue button:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个表示临时密码的 `long` 字符串。请复制它，返回到 UI，粘贴到管理员密码字段中，然后点击继续按钮：
- en: '![](img/jenkins-setup-password.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-setup-password.png)'
- en: 'Figure 6-2: Unlock Jenkins screen'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：解锁 Jenkins 界面
- en: Once you unlock Jenkins, you will be presented with a choice to Install suggested
    plugins or select those that fit your needs. The recommended plugins fit most
    commonly used scenarios so we'll go with that option.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁 Jenkins 后，你将看到一个选项，可以安装建议的插件或选择符合你需求的插件。推荐的插件适用于大多数常用场景，因此我们选择该选项。
- en: Please click the Install suggested plugins button.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请点击安装建议插件按钮。
- en: 'Once the plugins are downloaded and installed, we are presented with a screen
    that allows us to Create the first admin user. Please use `admin` as both the
    Username and the Password. Fill free to fill the rest of the fields with any value.
    Once you''re done, click the `Save and Finish` button:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件被下载并安装，我们将看到一个界面，允许我们创建第一个管理员用户。请将 `admin` 用作用户名和密码。可以自由填写其余字段的任何值。完成后，点击
    `Save and Finish` 按钮：
- en: '![](img/jenkins-setup-admin-user.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-setup-admin-user.png)'
- en: 'Figure 6-3: Create First Admin User screen'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：创建第一个管理员用户界面
- en: Jenkins is ready. All that's left, for now, is to click the `Start using Jenkins`
    button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 已经准备好了。现在剩下的，就是点击 `Start using Jenkins` 按钮。
- en: Now we can test whether Jenkins failover works.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试 Jenkins 的故障转移是否有效。
- en: Jenkins failover
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins 故障转移
- en: 'Let''s stop the service and observe Swarm in action. To do that, we need to
    find out the node it is running in, point our Docker client to it, and remove
    the container:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止服务并观察 Swarm 的运行情况。为此，我们需要找出它运行的节点，将 Docker 客户端指向该节点，然后删除容器：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We listed Jenkins processes and applied the filter that will return only the
    one with the desired state running `docker service ps -f desired-state=running
    jenkins`. The output was piped to the tail command that removed the header `tail
    -n +2` and, later on, piped again to the `awk` command that limited the output
    to the fourth column `awk '{print $4}'` that contains the node the process is
    running in. The final result was stored in the `NODE` variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出了 Jenkins 进程并应用了过滤器，返回状态为运行的进程 `docker service ps -f desired-state=running
    jenkins`。输出通过 `tail` 命令进行管道处理，去除了头部 `tail -n +2`，然后再次通过 `awk` 命令将输出限制为第四列 `awk
    '{print $4}'`，该列包含进程运行的节点。最终结果存储在 `NODE` 变量中。
- en: Later on, we used the eval command to create environment variables that will
    be used by our Docker client to operate the remote engine. Finally, we retrieved
    the image ID and removed the container with the combination of the `ps` and `rm`
    commands.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们使用了 `eval` 命令来创建环境变量，这些变量将由我们的 Docker 客户端用于操作远程引擎。最后，我们通过 `ps` 和 `rm` 命令的组合来获取镜像
    ID 并删除容器。
- en: As we already learned in the previous chapters, if a container fails, Swarm
    will run it again somewhere inside the cluster. When we created the service, we
    told Swarm that the desired state is to have one instance running and Swarm is
    doing its best to make sure our expectations are fulfilled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中已经学到的，如果一个容器失败，Swarm 会在集群内的某个地方重新启动它。当我们创建服务时，我们告诉 Swarm 期望的状态是运行一个实例，Swarm
    正在尽最大努力确保我们的期望得到满足。
- en: 'Let us confirm that the service is, indeed, running:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认服务确实正在运行：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If Swarm decided to re-run Jenkins on a different node, it might take a few
    moments until the image is pulled. After a while, the output of the `service ps`
    command should be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Swarm 决定在另一个节点上重新运行 Jenkins，可能需要一些时间来拉取镜像。稍等片刻后，`service ps` 命令的输出应如下所示：
- en: '![](img/error.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/error.png)'
- en: 'We can do a final confirmation by reopening the the UI:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新打开 UI 来做最终确认：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**A note to Windows users**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户注意事项**'
- en: 'Git Bash might not be able to use the open command. If that''s the case, execute `docker-machine
    ip <SERVER_NAME>` to find out the IP of the machine and open the URL directly
    in your browser of choice. For example, the command above should be replaced with
    the command that follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash 可能无法使用 `open` 命令。如果是这种情况，请执行 `docker-machine ip <SERVER_NAME>` 来查找机器的
    IP 地址，并直接在您选择的浏览器中打开 URL。例如，上面的命令应替换为以下命令：
- en: '`docker-machine ip swarm-1`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine ip swarm-1`'
- en: If the output would be `1.2.3.4`, you should open `http://1.2.3.4:8082/jenkins`
    in your browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出是 `1.2.3.4`，您应该在浏览器中打开 `http://1.2.3.4:8082/jenkins`。
- en: Since Jenkins does not allow unauthenticated users, you'll have to login. Please
    use `admin` as both the User and the Password.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jenkins 不允许未经身份验证的用户访问，您需要登录。请使用 `admin` 作为用户名和密码。
- en: You'll notice that, this time, we did not have to repeat the setup process.
    Even though a fresh new Jenkins image is run on a different node, the state is
    still preserved thanks to the host directory we mounted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，这次我们不需要重复设置过程。尽管在另一个节点上运行了一个全新的 Jenkins 镜像，但由于我们挂载的主机目录，状态仍然得以保留。
- en: We managed to make Jenkins fault tolerant, but we did not manage to make it
    run without any downtime. Due to its architecture, Jenkins master cannot be scaled.
    As a result, when we simulated a failure by removing the container, there was
    no second instance to absorb the traffic. Even though Swarm re-scheduled it on
    a different node, there was some downtime. During a short period, the service
    was not accessible. While that is not a perfect situation, we managed to reduce
    downtime to a minimum. We made it fault tolerant, but could not make it run without
    downtime. Considering its architecture, we did the best we could.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地使 Jenkins 容错，但未能使其在没有任何停机时间的情况下运行。由于其架构，Jenkins 主节点无法扩展。因此，当我们通过删除容器来模拟故障时，并没有第二个实例来吸收流量。即使
    Swarm 将其重新调度到另一个节点，也会有一些停机时间。在短时间内，服务无法访问。虽然这不是一个完美的情况，但我们尽量将停机时间降到了最低。我们使其具有容错能力，但无法实现零停机运行。考虑到其架构，我们已经尽了最大努力。
- en: Now is the time to hook up Jenkins agents that will run our Continuous Deployment
    flow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候连接运行我们持续部署流程的 Jenkins 代理了。
- en: Jenkins agent
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins 代理
- en: There are quite a few ways to run Jenkins agents. The problem with most of them
    is that they force us to add agents separately through Jenkins UI. Instead of
    adding agents one by one, we'll try to leverage Docker Swarms ability to scale
    services.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Jenkins 代理的方式有很多种。大多数方法的问题在于它们迫使我们通过 Jenkins UI 单独添加代理。我们将不再逐个添加代理，而是尝试利用
    Docker Swarm 的能力来扩展服务。
- en: One way we can accomplish the quest for making scalable agents is the Jenkins
    Swarm Plugin ([https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin)).
    Before you start making wrong conclusions, I must state that this plugin has nothing
    to do with Docker Swarm. The only thing they share is the word Swarm.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可扩展代理的一个方法是 Jenkins Swarm 插件 ([https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin))。在你开始得出错误结论之前，我必须声明，这个插件与
    Docker Swarm 没有任何关系。它们唯一的共同点就是名字中都包含 "Swarm"。
- en: The Jenkins Swarm Plugin ([https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin))
    allows us to auto-discover nearby masters and join them automatically. We'll use
    it only for the second feature. We'll create a Docker Swarm service that will
    act as a Jenkins agent and join the master automatically.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins Swarm 插件 ([https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin))
    允许我们自动发现附近的主节点并自动加入它们。我们将仅用于第二个功能。我们将创建一个 Docker Swarm 服务，作为 Jenkins 代理并自动加入主节点。
- en: First things first. We need to install the plugin.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装插件。
- en: 'Please open the Plugin Manager screen as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下代码所示打开插件管理器页面：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**A note to Windows users**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户须知**'
- en: 'Git Bash might not be able to use the open command. If that''s the case, execute `docker-machine
    ip <SERVER_NAME>` to find out the IP of the machine and open the URL directly
    in your browser of choice. For example, the command above should be replaced with
    the command that follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash 可能无法使用 open 命令。如果是这种情况，请执行 `docker-machine ip <SERVER_NAME>` 来查找机器的
    IP，并直接在你选择的浏览器中打开该 URL。例如，以上命令应替换为以下命令：
- en: '`docker-machine ip swarm-1`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine ip swarm-1`'
- en: If the output would be `1.2.3.4`, you should open `http://1.2.3.4:8082/jenkins/pluginManager/available`
    in your browser.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出是 `1.2.3.4`，你应该在浏览器中打开 `http://1.2.3.4:8082/jenkins/pluginManager/available`。
- en: Next, we need to search for the *Self-Organizing Swarm Plug-in Modules plugin*.
    The easiest way to do that is by typing the plugin name inside the Filter field
    located in the top-right corner of the screen. Once you locate the plugin, please
    select it and click the `Install without restart` button.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要搜索 *Self-Organizing Swarm Plug-in Modules 插件*。最简单的方法是将插件名称输入到屏幕右上角的筛选框中。一旦找到该插件，请选择它并点击
    `Install without restart` 按钮。
- en: Now that the plugin is installed, we can set up our second cluster that will
    consist of three nodes. As before, we'll call it `swarm-test`. We'll use the script
    `scripts/dm-test-swarm-2.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-2.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-2.sh))
    to run all the commands required to create the machines and join them into the
    cluster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已安装，我们可以设置第二个集群，它将由三个节点组成。如前所述，我们将其命名为 `swarm-test`。我们将使用脚本 `scripts/dm-test-swarm-2.sh`
    （[https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-2.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-2.sh)）运行所有创建机器并将其加入集群所需的命令。
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the `node ls` command is as follows (IDs are removed for brevity):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`node ls` 命令的输出如下（为了简洁，ID 已被移除）：'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only significant difference between the script we just ran and the one we
    used before `dm-test-swarm.sh` is that this one adds a few labels. The first node
    is labeled `jenkins-agent`, while the other two are labeled `prod-like`. The reason
    behind those labels is that we're trying to differentiate nodes that will be used
    to run tasks like building and testing `jenkins-agent` from those that will be
    used to run services in the environment that simulate production `prod-like`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才运行的脚本和之前使用的 `dm-test-swarm.sh` 脚本之间的主要区别在于，这个脚本添加了一些标签。第一个节点被标记为 `jenkins-agent`，而其他两个节点则标记为
    `prod-like`。这些标签的目的是区分用于运行诸如构建和测试 `jenkins-agent` 等任务的节点和用于运行模拟生产环境服务的节点 `prod-like`。
- en: 'Let''s inspect the `swarm-test-1` node:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 `swarm-test-1` 节点：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, this node has the label with the key `env` and the value `jenkins-agent`.
    If you inspect the other two nodes, you will see that they are also labeled but,
    this time, with the value `prod-like`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个节点有一个标签，键为`env`，值为`jenkins-agent`。如果你检查其他两个节点，你会看到它们也有标签，但这次值为`prod-like`：
- en: '![](img/cd-environment-jenkins-both-clusters.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd-environment-jenkins-both-clusters.png)'
- en: 'Figure 6-4: Create First Admin User screen'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：创建第一个管理员用户界面
- en: 'Now that the `swarm-test` cluster is set up, we are ready to create the Jenkins
    agent service. However, before we do that, let''s take a quick look at the definition
    of the image we are going to use. The `vfarcic/jenkins-swarm-agent Dockerfile`
    ([https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/Dockerfile](https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/Dockerfile))
    is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`swarm-test`集群已经设置好，我们准备创建Jenkins代理服务。但是，在此之前，让我们快速查看一下我们将要使用的镜像定义。`vfarcic/jenkins-swarm-agent
    Dockerfile`（[https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/Dockerfile](https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/Dockerfile)）如下：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It uses `docker` as the base image followed by a few environment variables that
    define versions of the software that will be installed. Since Jenkins runs as
    a `jenkins user`, we added it as well. That is followed by the installation of
    OpenJDK, Python, and pip. JDK is required for the Jenkins Swarm client and the
    rest for Docker Compose. With all the prerequisites set, we download the Swarm
    JAR and use pip to install Docker Compose.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它以`docker`作为基础镜像，接着定义了一些环境变量，指定将安装的软件版本。由于Jenkins作为`jenkins user`运行，我们也添加了它。然后是OpenJDK、Python和pip的安装。JDK是Jenkins
    Swarm客户端所需的，其它的则是为了支持Docker Compose。所有先决条件设置完毕后，我们下载Swarm JAR文件，并使用pip安装Docker
    Compose。
- en: Finally, we copy the `run.sh` ([https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/run.sh](https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/run.sh))
    script, set its permissions to execute, and define the runtime command to run
    it. The script uses Java to run the Jenkins Swarm client.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们复制了`run.sh`脚本（[https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/run.sh](https://github.com/vfarcic/docker-jenkins-slave-dind/blob/master/run.sh)），设置其可执行权限，并定义运行命令来执行它。该脚本使用Java来运行Jenkins
    Swarm客户端。
- en: 'Before we proceed with the Jenkins agents service, we''ll need to create the
    `/workspace` directory in each of the hosts where the agents will run. At the
    moment, that is only the `swarm-test-1` node. Soon you''ll see why we need this
    directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续Jenkins代理服务之前，我们需要在每个代理将运行的主机上创建`/workspace`目录。目前，只有`swarm-test-1`节点符合条件。很快你就会明白为什么我们需要这个目录：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We entered the node `swarm-test-1`, created the directory, gave it full permissions,
    and exited the machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了节点`swarm-test-1`，创建了目录，赋予它完全权限，然后退出了机器。
- en: 'Equipped with the understanding of the `vfarcic/jenkins-swarm-agent` image
    (or, at least, what it contains), we can move on and create the service:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了`vfarcic/jenkins-swarm-agent`镜像（或者至少知道它包含什么）后，我们可以继续创建服务：
- en: '**A note to Windows users**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户注意事项**'
- en: 'For mounts used in the next command to work, you have to stop Git Bash from
    altering file system paths. Set this environment variable as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使接下来的命令中的挂载工作，你需要停止Git Bash修改文件系统路径。按如下方式设置这个环境变量：
- en: '`export MSYS_NO_PATHCONV=1`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`export MSYS_NO_PATHCONV=1`'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `service create` command is, this time, a bit longer than what we're used
    to. The `COMMAND_OPTIONS` environment variable contains all the information the
    agent needs to connect to the master. We specified the address of the `master
    -master http://$(docker-machine ip swarm-1):8082/jenkins`, defined the `username`
    and `password` `-username $USER -password $PASSWORD`, labeled the agent `-labels
    'docker'`, and set the number of executors `-executors 5`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的`service create`命令比我们通常使用的要长一些。`COMMAND_OPTIONS`环境变量包含了代理连接到主节点所需的所有信息。我们指定了`master
    -master http://$(docker-machine ip swarm-1):8082/jenkins`的地址，定义了`username`和`password`
    `-username $USER -password $PASSWORD`，为代理打上了`docker`标签 `-labels 'docker'`，并设置了执行器数量
    `-executors 5`。
- en: Further on, we declared the service to be global and constrained it to the `jenkins-agent`
    nodes. That means that it will run on every node that has the matching label.
    At the moment, that is only one server. Soon we'll see the benefits such a setup
    provides.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将服务声明为全局并限制在`jenkins-agent`节点上运行。这意味着它将运行在每个具有匹配标签的节点上。目前，只有一台服务器符合条件。很快我们就会看到这种设置所带来的好处。
- en: We mounted Docker socket. As a result, any command sent to the Docker client
    running inside the container will run against Docker Engine on the host (in this
    case Docker Machine). As a result, we'll avoid pitfalls that could be created
    by running `Docker inside Docker`  or  `DinD`. For more information, please read
    the article Using Docker-in-Docker for your CI or testing environment? Think twice
    ([http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)[docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们挂载了 Docker 套接字。结果，发送到容器内运行的 Docker 客户端的任何命令将会对主机上的 Docker 引擎（在此情况下为 Docker
    Machine）执行。这样，我们就可以避免运行 `Docker inside Docker` 或 `DinD` 可能带来的陷阱。欲了解更多信息，请阅读文章《使用
    Docker-in-Docker 作为 CI 或测试环境？三思而后行》([http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)[docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/))。
- en: 'We also mounted the host (laptop) directory that contains the keys. That will
    allow us to send requests to engines running inside the other cluster. The final
    mount exposes the host directory `/workspace` inside the container. All builds
    running inside Jenkins agents will use that directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还挂载了包含密钥的主机（笔记本电脑）目录。这样，我们就可以向运行在另一个集群中的引擎发送请求。最终挂载将主机目录 `/workspace` 映射到容器内。所有在
    Jenkins 代理中运行的构建将使用该目录：
- en: '![](img/cd-environment-jenkins-agent.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd-environment-jenkins-agent.png)'
- en: 'Figure 6-5: Jenkins agent run as a global service'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5：作为全局服务运行的 Jenkins 代理
- en: 'Let''s take a look at the service processes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下服务进程：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows (IDs are removed for brevity):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（为简洁起见，已移除 ID）：
- en: '![](img/output1.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/output1.png)'
- en: As you can see, the service is global, so the desired state is for it to run
    on every node. However, since we restricted it to the nodes with the label `jenkins-agent`,
    containers are running only inside those that have the matching label. In other
    words, the service is running only on `jenkins-agent` nodes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务是全局性的，因此期望的状态是它在每个节点上运行。然而，由于我们将其限制到带有 `jenkins-agent` 标签的节点，因此容器仅在那些具有匹配标签的节点中运行。换句话说，服务仅在
    `jenkins-agent` 节点上运行。
- en: 'Let''s open the Jenkins screen that displays registered agents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开显示已注册代理的 Jenkins 界面：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**A note to Windows users**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户注意事项**'
- en: 'Git Bash might not be able to use the open command. If that’s the case, execute `docker-machine
    ip <SERVER_NAME>` to find out the IP of the machine and open the URL directly
    in your browser of choice. For example, the command above should be replaced with
    the command that follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash 可能无法使用 `open` 命令。如果是这种情况，执行 `docker-machine ip <SERVER_NAME>` 来查找机器的
    IP 地址，并直接在您选择的浏览器中打开该 URL。例如，上面的命令应替换为以下命令：
- en: '`docker-machine ip swarm-1`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine ip swarm-1`'
- en: If the output would be `1.2.3.4`, you should open `http://1.2.3.4:8082/jenkins/computer`
    in your browser.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出为 `1.2.3.4`，则应该在浏览器中打开 `http://1.2.3.4:8082/jenkins/computer`。
- en: 'As you can see, two agents are registered. The master agent is running by default
    with every Jenkins instance. On my machine, the agent running as the `jenkins-agent`
    service is identified as `e0961f7c1801-d9bf7835`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已经注册了两个代理。主代理默认与每个 Jenkins 实例一起运行。在我的机器上，作为 `jenkins-agent` 服务运行的代理被标识为
    `e0961f7c1801-d9bf7835`：
- en: '![](img/jenkins-agent.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-agent.png)'
- en: 'Figure 6-6: Jenkins Swarm agent added to the master'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：Jenkins Swarm 代理添加到主节点
- en: Since we used labels to restrict the service to the `swarm-test-1` node, at
    the moment we have only one agent registered (besides the master that, in most
    cases, should not be used).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用标签将服务限制到 `swarm-test-1` 节点，目前只有一个代理被注册（除了主节点，在大多数情况下不应使用它）。
- en: The agent is configured to use five executors. That means that five builds can
    be executed in parallel. Please note that, in this case, the number of executors
    is artificially high. Each machine has only one CPU. Without any additional information,
    I would probably set the number of executors to be the same as the number of CPUs.
    That would be only the basic calculation that would change with time. If the tasks
    we're running through those executors are CPU demanding, we might lower the number
    of executors. However, for the purpose of this exercise, five executors should
    be *OK*. We have only one service, so we won't run builds in parallel.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代理配置为使用五个执行器。这意味着可以并行执行五个构建。请注意，在这种情况下，执行器的数量被人为设定得很高。每台机器只有一个CPU。如果没有其他信息，我可能会将执行器的数量设置为与CPU数量相同。这只是基本的计算，随时间变化而改变。如果我们通过这些执行器运行的任务需要大量CPU，我们可能会降低执行器的数量。但是，对于本练习来说，五个执行器应该*可以*。我们只有一个服务，所以我们不会并行运行构建。
- en: Let's imagine that this is the real system with more builds running in parallel
    than the number of executors. In such a situation, some would be queued waiting
    for an executor to finish and free its resources. If this was a temporary case,
    we wouldn't need to do anything. The executing builds would end, free the resources,
    and run the queued builds. However, if this is a reoccurring situation, the number
    of queued builds would probably start increasing and everything would slow down.
    Since we already established that the speed is the critical element of Continuous
    Integration, Delivery, and Deployment processes, when things start to get in the
    way, we need to do something. In this case, that something is the increase of
    available executors and, consequently, the number of agents.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是一个真实系统，有更多构建并行运行比执行器数量多的情况。在这种情况下，一些构建将排队等待执行器完成并释放资源。如果这是一个暂时的情况，我们不需要做任何事情。正在执行的构建将结束，释放资源，并运行排队的构建。然而，如果这是一个经常发生的情况，排队构建的数量可能会开始增加，并且一切都会放慢。既然我们已经确定速度是持续集成、交付和部署过程中的关键因素，当事情开始变得阻碍时，我们需要采取措施。在这种情况下，这种措施就是增加可用的执行器，从而增加代理的数量。
- en: 'Let''s imagine that we hit the limit and need to increase the number of agents.
    Knowing how global Swarm services work, all we have to do is create a new node:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们达到了限制并且需要增加代理的数量。了解全局Swarm服务的工作原理，我们只需创建一个新节点：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We created the `swarm-test-4` node and, inside it, the `/workspace` directory.
    Then we got the token and joined the newly created service to the cluster as a
    worker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`swarm-test-4`节点，并在其中创建了`/workspace`目录。然后我们获取了令牌并将新创建的服务加入集群作为工作节点。
- en: 'Let''s confirm that the new node is, indeed, added to the cluster:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认新节点确实已添加到集群中：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the `node ls` command is as follows (IDs are removed for brevity):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`node ls`命令的输出如下（为简洁起见已删除ID）：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Is the Jenkins agent running inside the newly created node? Let’s take a look:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins代理是否正在新创建的节点内运行？让我们来看看：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the `service ps` command is as follows (IDs are removed for brevity):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`service ps`命令的输出如下（为简洁起见已删除ID）：'
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the node is not labeled as `jenkins-agent`, the agent is not running inside
    the `swarm-test-4` server.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节点未标记为`jenkins-agent`，因此代理未在`swarm-test-4`服务器内运行。
- en: 'Let''s add the label:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加标签：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This time, the output is a bit different (IDs are removed for brevity):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这次输出略有不同（为简洁起见已删除ID）：
- en: '![](img/output4-1.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/output4-1.png)'
- en: Swarm detected the new label, run the container, and changed the state to running.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm检测到新标签，运行容器，并将状态更改为运行中。
- en: 'Let''s go back to the Jenkins screen that lists the connected agents:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到列出连接代理的Jenkins界面：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**A note to Windows users**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户注意**'
- en: 'Git Bash might not be able to use the open command. If that''s the case, execute
                         `docker-machine ip <SERVER_NAME>` to find out the IP of the
    machine and open the URL directly in your browser of choice. For example, the
    command above should be replaced with the command that follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash可能无法使用打开命令。如果是这样，请执行以下命令来查找机器的IP并直接在您选择的浏览器中打开URL。例如，上面的命令应替换为以下命令：
- en: '`docker-machine ip swarm-1`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine ip swarm-1`'
- en: If the output would be `1.2.3.4`, you should open `http://1.2.3.4:8082/jenkins/computer`
    in your browser.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出为`1.2.3.4`，您应在浏览器中打开`http://1.2.3.4:8082/jenkins/computer`。
- en: 'As you can see, the new agent b76e943ffe6c-d9bf7835 was added to the list:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，新代理b76e943ffe6c-d9bf7835已添加到列表中：
- en: '![](img/jenkins-agents.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-agents.png)'
- en: 'Figure 6-7: The second Jenkins Swarm agent added to the master'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：第二个 Jenkins Swarm 代理已添加到主节点
- en: This was very easy, wasn't it? Usually, we'd need not only to create a new server
    but also to run the agent and add it to Jenkins configuration through the UI.
    By combining *Jenkins Swarm* plugin and *Docker Swarm* global services, we managed
    to automate most of the steps. All we have to do is create a new node and add
    it to the Swarm cluster.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？通常我们不仅需要创建一个新服务器，还需要运行代理并通过 UI 将其添加到 Jenkins 配置中。通过结合 *Jenkins Swarm*
    插件和 *Docker Swarm* 全局服务，我们成功地自动化了大多数步骤。我们需要做的就是创建一个新节点，并将其添加到 Swarm 集群中。
- en: Before we proceed and automate the Continuous Deployment flow through Jenkins,
    we should create the services in production and production-like environments.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续并通过 Jenkins 自动化持续部署流程之前，我们应该在生产和类生产环境中创建服务。
- en: Creating services in production and production-like environments
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产和类生产环境中创建服务
- en: Since a service is created only once and updated whenever some of its aspects
    change (example:new image with the new release), there is no strong incentive
    to add service creation to the Continuous Deployment flow. All we'd get is increased
    complexity without any tangible benefit. Therefore, we'll create all the services
    manually and, later on, discuss how to automate the flow that will be triggered
    with each new release.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务仅在首次创建时添加，并且每当其某些方面发生变化（例如：新的镜像与新版本一起发布）时才会更新，因此没有强烈的动力将服务创建加入到持续部署流中。我们得到的只是增加复杂性而没有实际的好处。因此，我们将手动创建所有服务，之后再讨论如何在每次新版本发布时自动触发该流程。
- en: 'We already created `go-demo`, `go-demo-db`, `proxy`, `jenkins`, and `registry`
    services quite a few times so we''ll skip the explanation and run `scripts/dm-swarm-services-2.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services-2.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services-2.sh))
    that will recreate the situation we had in the previous chapters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `go-demo`、`go-demo-db`、`proxy`、`jenkins` 和 `registry` 服务很多次，因此我们将跳过解释并运行
    `scripts/dm-swarm-services-2.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services-2.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services-2.sh))，该脚本将重新创建我们在前几章中遇到的情况：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the `service ls` command is as follows (IDs are removed for brevity):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`service ls` 命令的输出如下（为了简洁，已移除 ID）：'
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All the services are running. The only difference between the script we ran
    now and the one we used before `scripts/dm-swarm-services.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services.sh))
    is that, this time, we added `registry` to the mix.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都在运行。我们现在运行的脚本与之前使用的脚本 `scripts/dm-swarm-services.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-services.sh))
    唯一的不同之处是，这次我们加入了 `registry`。
- en: Now that the production environment is up and running, let's create the same
    set of services inside the `swarm-test` cluster. Since this cluster is shared
    between services running in the production-like environment as well as Jenkins
    agents, we'll constrain services to `prod-like` nodes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生产环境已经启动并运行，我们来在 `swarm-test` 集群中创建相同的服务集。由于这个集群在生产环境类环境中与 Jenkins 代理共享，我们将把服务限制在
    `prod-like` 节点上。
- en: 'As with the production cluster, we''ll run the services through a script. This
    time we''ll use `scripts/dm-test-swarm-services-2.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-services-2.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-services-2.sh)):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与生产集群一样，我们将通过脚本来运行这些服务。这次我们将使用 `scripts/dm-test-swarm-services-2.sh` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-services-2.sh](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-test-swarm-services-2.sh))：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the `service ls` command is as follows (IDs are removed for brevity):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`service ls` 命令的输出如下（为了简洁，已移除 ID）：'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that the services are running in both the production and production-like
    environments, we can proceed with the discussion about the approach we'll take
    for the CD flow automation with Jenkins.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务已经在生产环境和类生产环境中运行，我们可以继续讨论我们将如何通过 Jenkins 实现 CD 流程自动化的方法。
- en: Automating Continuous Deployment flow with Jenkins
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 自动化持续部署流程
- en: Jenkins is based on plugins. Almost every feature is a plugin. If we need to
    use Git, there is a plugin for it. If we want to use Active Directory for authentication,
    there is a plugin. You get the point. Almost everything is a plugin. Moreover,
    most plugins were created and are maintained by the community. When we are in
    doubt how to accomplish something, the *plugins directory* ([https://wiki.jenkins-ci.org/display/JENKINS/Plugins](https://wiki.jenkins-ci.org/display/JENKINS/Plugins)) is
    usually the first place we start looking.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 基于插件。几乎每个功能都是一个插件。如果我们需要使用 Git，有一个插件。如果我们想使用 Active Directory 进行身份验证，也有一个插件。你明白了，几乎所有东西都是插件。而且，大多数插件是由社区创建并维护的。当我们不确定如何完成某个任务时，*插件目录*（[https://wiki.jenkins-ci.org/display/JENKINS/Plugins](https://wiki.jenkins-ci.org/display/JENKINS/Plugins)）通常是我们开始查找的第一个地方。
- en: With more than `1200` plugins available, it's no wonder that, given such a huge
    variety, most users are compelled to use a plugin for almost any type of task.
    Jenkins old-timers would create a Freestyle job that, for example, clones the
    code and builds the binaries. It would be followed by another job that would run
    unit tests, another for running functional tests, and so on. All those Freestyle
    jobs would be connected. When the first is finished, it would invoke the second,
    the second would call the third, and so on. Freestyle jobs foment heavy plugins
    usage.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过 `1200` 个插件可供选择，难怪在如此多样化的插件面前，大多数用户都不得不使用插件来完成几乎所有类型的任务。Jenkins 的老手们会创建一个
    Freestyle 作业，举个例子，它会克隆代码并构建二进制文件。然后是另一个作业来运行单元测试，再一个来运行功能测试，依此类推。所有这些 Freestyle
    作业都会连接起来。当第一个完成时，它会调用第二个，第二个会调用第三个，以此类推。Freestyle 作业促使了大量插件的使用。
- en: We would choose one appropriate for a given task, fill in some fields, and click
    save. Such an approach allows us to automate the steps without the need for the
    knowledge of how different tools work. Need to execute some Gradle tasks? Just
    choose the Gradle plugin, fill in a few fields, and off you go.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会选择一个适合特定任务的插件，填写一些字段，然后点击保存。这样的做法使我们能够自动化步骤，而无需了解不同工具的工作原理。需要执行一些 Gradle
    任务？只需选择 Gradle 插件，填写几个字段，然后开始吧。
- en: Such an approach based on heavy usage of plugins can be disastrous. Understanding
    automation and the tools behind it is essential. Moreover, the usage of *Freestyle*
    jobs breaks one of the fundamental principles in our industry. Everything should
    be stored in a code repository, be prone to code reviews, versioned, and so on.
    There is no good reason why coding practices should not apply to the automation
    code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于大量使用插件的方法可能会带来灾难。理解自动化及其背后的工具至关重要。此外，使用 *Freestyle* 作业违背了我们行业中的一个基本原则。所有内容都应该存储在代码仓库中，经过代码审查、版本控制，等等。没有充分的理由说明编码实践不适用于自动化代码。
- en: We'll take a different approach.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取一种不同的方法。
- en: I am a huge believer that the steps that form a CI/CD Pipeline should be specified
    outside the tools like Jenkins. We should be able to define all the commands without
    CI/CD tools and, once we’re comfortable that everything works as expected, proceed
    by translating those commands to the CI/CD friendly format. In other words, automation
    comes first, and CI/CD tools later.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信，形成 CI/CD Pipeline 的步骤应该在像 Jenkins 这样的工具之外进行指定。我们应该能够在没有 CI/CD 工具的情况下定义所有命令，并且一旦我们确信一切按预期工作，就可以将这些命令转化为
    CI/CD 友好的格式。换句话说，自动化是第一步，CI/CD 工具是后续的。
- en: Fortunately, not long ago, Jenkins introduced a new concept called *Jenkins
    Pipeline*. Unlike *Freestyle* jobs that were defined through Jenkins UI, *Pipeline*
    allows us to define CD flow as code. Since we already have a well-defined set
    of commands, converting them into *Jenkins Pipeline* should be relatively straightforward.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，最近 Jenkins 引入了一个新的概念——*Jenkins Pipeline*。与通过 Jenkins UI 定义的 *Freestyle*
    作业不同，*Pipeline* 允许我们将 CD 流程定义为代码。由于我们已经有了一套良好定义的命令，转换为 *Jenkins Pipeline* 应该是相对简单的。
- en: Let's give it a try.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试试看。
- en: Creating Jenkins Pipeline jobs
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Jenkins Pipeline 作业
- en: We’ll start by defining a few environment variables. The reason behind declaring
    those variables is that we want to have a single place where critical information
    is stored. That way, when something changes (example:entry point to the cluster)
    we can modify a variable or two, and the changes will be propagated throughout
    all jobs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义一些环境变量开始。声明这些变量的原因是，我们希望有一个集中存储关键信息的地方。这样，当某些内容发生变化时（例如：集群入口点），我们只需修改一个或两个变量，变化就会传递到所有作业中。
- en: 'Off we go. First, we need to open Jenkins global configuration screen:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧。首先，我们需要打开Jenkins的全局配置页面：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**A note to Windows users:**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户注意：**'
- en: 'Git Bash might not be able to use the open command. If that''s the case, execute `docker-machine
    ip <SERVER_NAME>` to find out the IP of the machine and open the URL directly
    in your browser of choice. For example, the command above should be replaced with
    the command that follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash可能无法使用open命令。如果是这种情况，请执行 `docker-machine ip <SERVER_NAME>` 来找出机器的IP，并直接在你选择的浏览器中打开该URL。例如，前面的命令应替换为以下命令：
- en: '`docker-machine ip swarm-1` If the output would be `1.2.3.4`, you should open
    `http://1.2.3.4:8082/jenkins/configure` in your browser.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine ip swarm-1` 如果输出是 `1.2.3.4`，你应该在浏览器中打开 `http://1.2.3.4:8082/jenkins/configure`。'
- en: Once inside the configuration screen, please click the Environment variables
    checkbox followed with the Add button. You will be presented with the fields Name
    and Value. The first variable we'll add will hold the production IP. However,
    before we type it, we need to find it out. The routing mesh redirects requests
    from any node to the destination service or, to be more precise, to the service
    that exposes the same port as the request. Therefore, we can use any server in
    the production cluster `swarm` as our entry point.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 进入配置页面后，请勾选“Environment variables”复选框，然后点击“Add”按钮。你将看到Name和Value字段。我们将首先添加一个变量来存储生产IP。但在输入之前，我们需要先查找它。路由网格将请求从任何节点重定向到目标服务，或者更确切地说，重定向到暴露与请求相同端口的服务。因此，我们可以使用生产集群`swarm`中的任何服务器作为我们的入口点。
- en: 'To get the IP of one of the nodes, we can use the `docker-machine ip` command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取某个节点的IP，我们可以使用 `docker-machine ip` 命令：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result will differ from one case to another. On my laptop, the output is
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会因情况而异。在我的笔记本电脑上，输出如下：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please copy the IP and go back to the Jenkins configuration screen. Type `PROD_IP`
    as Name and paste the IP into the Value field. It is worth noting that we just
    introduced a single point of failure. If the `swarm-1` node fails, all our jobs
    that use this variable will fail as well. The good news is that we can fix that
    quickly by changing the value of this environment variable. The bad news is that
    we can do better, but not with Docker machines. If, for example, we were to use
    AWS, we'd be able to utilize Elastic IP. However, we have not reached the AWS
    chapter yet, so changing the variable is our best option.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请复制IP并返回Jenkins配置页面。在Name字段中输入`PROD_IP`，并将IP粘贴到Value字段中。值得注意的是，我们刚刚引入了单点故障。如果`swarm-1`节点出现故障，所有使用该变量的作业也会失败。好消息是，我们可以通过更改这个环境变量的值来快速修复它。坏消息是，我们能做得更好，但不能通过Docker机器做到。如果我们使用AWS，例如，我们可以利用弹性IP。然而，我们还没有进入AWS章节，所以目前更改变量是最好的选择。
- en: Next, we should add another variable that will represent the name of the production
    node. We'll see the usage of this variable later. For now, please create a new
    variable with `PROD_NAME` as Name and swarm-1 as value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应添加另一个变量，表示生产节点的名称。我们稍后将看到这个变量的使用。现在，请创建一个新变量，Name为`PROD_NAME`，Value为`swarm-1`。
- en: 'We''ll need similar variables for our production-like cluster `swarm-test`.
    Please enter variables `PROD_LIKE_IP` with the IP of the `swarm-test-1` node `docker-machine
    ip swarm-test-1` and `PROD_LIKE_NAME` with the value `swarm-test-1`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为生产类集群`swarm-test`创建类似的变量。请分别输入变量`PROD_LIKE_IP`，值为`swarm-test-1`节点的IP（`docker-machine
    ip swarm-test-1`），以及`PROD_LIKE_NAME`，值为`swarm-test-1`：
- en: '![](img/jenkins-configuration-variables.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-configuration-variables.png)'
- en: 'Figure 6-8: Jenkins global configuration screen with defined environment variables'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：配置了环境变量的Jenkins全局配置页面
- en: Once done with the Environment variables, please click the Save button.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成环境变量的设置后，请点击“Save”按钮。
- en: Now that the environment variables are defined, we can proceed and create a
    Jenkins Pipeline job that will automate the execution of the CD steps we practiced.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在环境变量已经定义完成，我们可以继续创建一个Jenkins Pipeline作业，用于自动化执行我们练习过的CD步骤。
- en: To create the new job, please click the New Item link located in the left-hand
    menu. Type `go-demo` as the item name, select Pipeline, and click the OK button.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建新的作业，请点击左侧菜单中的“New Item”链接，输入`go-demo`作为项目名称，选择Pipeline，然后点击OK按钮。
- en: A Jenkins Pipeline definition contains three primary levels; node, stage, and
    step. We'll define the go-demo Pipeline code by going through these levels one
    by one.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Jenkins Pipeline定义包含三个主要层次：node、stage和step。我们将通过逐一讲解这些层次来定义go-demo Pipeline代码。
- en: Defining Pipeline nodes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Pipeline节点
- en: In the Jenkins Pipeline DSL, a *node* is a step that does two things, typically
    by enlisting help from available executors on agents.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins Pipeline DSL 中，*node* 是一个步骤，它通常通过请求代理上的可用执行器来完成两项任务。
- en: A node schedules the steps contained within it by adding them to the Jenkins
    build queue. That way, as soon as an executor slot is free on a node, the appropriate
    steps will be run.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 节点通过将其中包含的步骤添加到 Jenkins 构建队列中来调度这些步骤。这样，当节点上的执行器槽位空闲时，相应的步骤就会被执行。
- en: It also creates a workspace, meaning a file directory specific to a particular
    job, where resource-intensive processing can occur without negatively impacting
    your Pipeline performance. Workspaces created by a node are automatically removed
    after all the steps contained inside the node declaration finish executing. It
    is a best practice to do all material work, such as building or running shell
    scripts, within nodes, because node blocks in a stage tell Jenkins that the steps
    within them are resource-intensive enough to be scheduled, request help from the
    agent pool, and lock a workspace only as long as they need it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它还创建了一个工作空间，意味着一个特定于某个作业的文件目录，在这个目录中，资源密集型处理可以发生，而不会对你的 Pipeline 性能产生负面影响。节点创建的工作空间在节点声明中的所有步骤执行完成后会自动被删除。最佳实践是将所有实际工作（如构建或运行
    shell 脚本）都放在节点内进行，因为阶段中的节点块告诉 Jenkins 其中的步骤是资源密集型的，足以进行调度，向代理池请求帮助，并仅在需要时锁定工作空间。
- en: If that definition of the node confuses you, think of it as a location where
    the steps will run. It specifies a server (agent) that will execute tasks. That
    specification can be the name of the server (generally a bad idea, due to tight
    coupling of node configuration to agent), or a set of labels that must match those
    set inside an agent. If you recall the command we used to start the Jenkins Swarm
    agent service, you'll remember that we used `-labels docker` as one of the command
    options. Since Docker Engine and Compose are the only executables we need, that
    was the only label we needed as our node specification.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点的定义让你感到困惑，可以把它理解为执行步骤的地方。它指定了一个服务器（代理），该服务器将执行任务。这个指定可以是服务器的名称（通常不是一个好主意，因为节点配置与代理的紧密耦合），也可以是一组标签，这些标签必须与代理中设置的标签匹配。如果你还记得我们用来启动
    Jenkins Swarm 代理服务的命令，你会记得我们使用了`-labels docker`作为命令选项之一。由于 Docker 引擎和 Compose
    是我们需要的唯一可执行文件，所以这就是我们作为节点规范所需的唯一标签。
- en: 'Please type the following code into the Pipeline script field of the go-demo
    job configuration and press the Save button:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请将以下代码输入到 go-demo 作业配置的 Pipeline 脚本字段中，并按下保存按钮：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We just wrote the first iteration of the Pipeline. Let's run it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写了 Pipeline 的第一次迭代。现在让我们运行它。
- en: Please click the Build Now button.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请点击 "立即构建" 按钮。
- en: 'The job started running and displayed the message stating that This Pipeline
    has run successfully, but does not define any stages*.* We''ll correct that in
    a moment. For now, let''s take a look at the logs:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作业开始运行并显示了消息，表示该 Pipeline 已成功运行，但没有定义任何阶段*。* 我们马上会更正这一点。现在，让我们看一下日志：
- en: '![](img/jenkins-pipeline-build-node.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-pipeline-build-node.png)'
- en: 'Figure 6-9: The first build of the Jenkins Pipeline job'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-9：Jenkins Pipeline 作业的第一次构建
- en: You can access the logs by clicking the icon in the shape of a ball next to
    the build number in this case *#1*. Builds can be accessed from the *Build History*
    widget located in the left-hand side of the screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击构建号旁边的球形图标访问日志，在这种情况下是 *#1*。你也可以从位于屏幕左侧的 *构建历史* 小部件中访问构建记录。
- en: 'The output is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Not much happened in this build. Jenkins parsed the node definition and decided
    to use the agent `be61529c010a-d9bf7835` (one of the two Jenkins Swarm service
    instances) and run the steps inside the directory `/workspace/go-demo`. The directory
    structure is simple. All files generated by a build are located in a directory
    that matches the job name. In this case, the directory is `go-demo`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次构建中，变化不大。Jenkins 解析了节点定义，并决定使用代理`be61529c010a-d9bf7835`（两个 Jenkins Swarm
    服务实例之一），并在 `/workspace/go-demo` 目录中运行步骤。目录结构很简单。所有由构建生成的文件都位于一个与作业名称匹配的目录中。在本例中，目录名为
    `go-demo`。
- en: Since we did not specify any step inside the node, the Pipeline finished executing
    almost immediately and the result was a success. Let's spice it up a bit with
    stages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在节点内部指定任何步骤，Pipeline 几乎立即完成执行，结果是成功的。让我们通过添加阶段来稍微增加一点复杂度。
- en: Defining Pipeline stages
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Pipeline 阶段
- en: A **stage** is a logically distinct part of the execution of any task, with
    parameters for locking, ordering, and labeling its part of a process relative
    to other parts of the same process. Pipeline syntax is often comprised of stages.
    Each stage step can have one or more build steps within it. It is a best practice
    to work within stages because they help with organization by lending logical divisions
    to Pipelines, and because the Jenkins Pipeline visualization feature displays
    stages as unique segments of the Pipeline.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段**是执行任何任务的逻辑上不同部分，具有用于锁定、排序和标记其所属流程的参数。流水线语法通常由阶段组成。每个阶段步骤可以包含一个或多个构建步骤。在阶段内工作是一种最佳实践，因为它们通过为流水线提供逻辑划分来帮助组织工作，并且因为Jenkins流水线可视化功能将阶段显示为流水线的独特部分。'
- en: 'What would be the stages of the flow we practiced with manual commands? We
    could divide the commands we defined into the following groups:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用手动命令练习的流程阶段是什么？我们可以将定义的命令分成以下几组：
- en: Pull the latest code from the repository.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从仓库拉取最新代码。
- en: Run unit tests and build the service and Docker images.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行单元测试并构建服务和Docker镜像。
- en: Deploy to staging environment and run tests.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到预备环境并运行测试。
- en: Tag Docker images and push them to the registry.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Docker镜像打标签并将其推送到注册表。
- en: Use the latest image to update the service running in production-like environment
    and run tests.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最新镜像更新运行在类生产环境中的服务并运行测试。
- en: Use the latest image to update the service running in production environment
    and run tests.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最新镜像更新运行在生产环境中的服务并运行测试。
- en: 'When those groups of tasks are translated into Pipeline stages, the code inside
    the node is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些任务组被转换为流水线阶段时，节点内的代码如下：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We should combine the node we defined earlier with those stages. To be more
    precise, they should all be defined inside the node block.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将之前定义的节点与这些阶段结合起来。更确切地说，它们都应该在节点块内定义。
- en: Please replace the existing Pipeline definition by copying and pasting the code
    from `scripts/go-demo-stages.groovy` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-stages.groovy](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-stages.groovy)).
    You can access the job configuration by clicking the go-demo link inside breadcrumbs
    located in the top part of the screen. Once inside the main job page, please click
    the Configure button located in the left-hand menu. Once you are done writing
    or pasting the new Pipeline definition, save it and re-run the job by clicking
    the Build Now button.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过复制并粘贴来替换现有的流水线定义，从`scripts/go-demo-stages.groovy` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-stages.groovy](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-stages.groovy))
    中访问作业配置，您可以通过位于屏幕顶部的面包屑内的go-demo链接访问主作业页面。一旦进入主作业页面，请点击左侧菜单中的“配置”按钮。完成编写或粘贴新的流水线定义后，请保存并通过点击“立即构建”按钮重新运行作业。
- en: 'We still do not execute any actions. However, this time, the Stage View screen
    is much more informative. It displays the stages we defined earlier:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有执行任何操作。但是，这次，阶段视图屏幕更加详细。它显示了我们之前定义的阶段：
- en: '![](img/jenkins-pipeline-stage-view.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-pipeline-stage-view.png)'
- en: 'Figure 6-10: The Jenkins Pipeline Stage View screen'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：Jenkins流水线阶段视图屏幕
- en: Now we are ready to define the steps that will be executed inside each of the
    stages.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备定义将在每个阶段内执行的步骤。
- en: Defining Pipeline steps
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义流水线步骤
- en: Before we start writing the steps, I must, briefly, mention that there are a
    couple of different approaches people use to define Jenkins jobs. Some prefer
    to utilize Jenkins plugins to their maximum. When taken to an extreme, such approach
    results in every action being executed through a plugin. Do you need to run some
    Gradle tasks? There is a Gradle plugin (or two). Do you need to do something with
    Docker? There are roughly a dozen Docker plugins. How about configuration management
    with Ansible? There is a plugin as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写步骤之前，我必须简要提到人们用于定义Jenkins作业的几种不同方法。有些人喜欢充分利用Jenkins插件。当这种方法被推向极致时，每个操作都通过插件执行。需要运行一些Gradle任务吗？有一个Gradle插件（或两个）。需要使用Docker做些什么？大约有十几个Docker插件。用Ansible进行配置管理呢？也有一个插件。
- en: I do not think that heavy reliance on plugins is a good thing. I believe that
    we should be capable of creating most, if not all the automation without Jenkins.
    After all, does it even make sense to use a plugin that would save us from writing
    a single line of command? I don't believe it does. That doesn't mean that we should
    not use plugins. We should, but only when they bring a real and tangible additional
    value. An example would be the Git plugin. It evaluates whether the code should
    be cloned or pulled. It manages authentication. It provides a few auto-populated
    environment variables we can use in conjunction with other steps.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认为过度依赖插件是件好事。我相信我们应该能够在没有 Jenkins 的情况下完成大部分甚至全部自动化。毕竟，使用一个插件来避免我们写一行命令，合理吗？我不认为这是必要的。这并不意味着我们不应该使用插件。我们应该使用插件，但只在它们带来了实际且可触及的附加价值时。例如
    Git 插件。它判断代码是需要克隆还是拉取。它管理身份验证。它提供了一些可以与其他步骤结合使用的自动填充环境变量。
- en: 'Should we use the Git plugin always? We shouldn''t. Let''s say that all we
    have to do is perform a simple pull inside an already cloned repository, that
    we do not need authentication, and that there will be no usage of some of the
    pull information in later steps (example: commit ID). In such a case, the simplest
    solution possible might be the best choice. What is the easiest way to pull the
    code from a Git repository? Most likely that''s git `pull` command executed through
    Shell.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否总是应该使用 Git 插件？我们不应该。假设我们只需要在已经克隆的仓库中执行一个简单的拉取操作，且不需要身份验证，并且在后续步骤中不会使用一些拉取信息（例如：提交
    ID）。在这种情况下，最简单的解决方案可能是最好的选择。从 Git 仓库中拉取代码的最简单方法是什么？最有可能的就是通过 Shell 执行 `git pull`
    命令。
- en: Only once we know what we're doing and the process is done in a CI/CD tool agnostic
    way, we should proceed and tie it all together through Jenkins (or whatever is
    your tool of choice). That way we understand the process and have a firm handle
    on what should be done, not only from a pure automation perspective, but also
    as a choice of tools, processes, and architecture as well. All pieces need to
    work together in an organic and efficient way. If we manage to accomplish that,
    Jenkins acts as glue that ties it all together, and not as a base we start with.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们了解自己在做什么，并且该过程是以与 CI/CD 工具无关的方式完成时，我们才应该继续并通过 Jenkins（或者您选择的任何工具）将其整合在一起。这样，我们不仅从纯自动化的角度理解过程，还能在工具、过程和架构的选择上把握清楚。所有部分需要以有机且高效的方式协同工作。如果我们能够做到这一点，那么
    Jenkins 就像是把所有部分结合起来的胶水，而不是我们开始时的基础。
- en: Let's define the steps required for the first stage. The objective is very simple.
    Get the code from the Git repository. To make things slightly more complicated,
    we might need to clone or pull the code. The first build will have nothing so
    we must clone. All consecutive builds should only perform a pull into the already
    cloned code. While writing a script that performs that logic is relatively straightforward,
    this will be a good case of using a Jenkins plugin. To be more precise, we'll
    use Jenkins Pipeline step git that uses one of the Git plugins in the background.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义第一阶段所需的步骤。目标非常简单，就是从 Git 仓库中获取代码。为了稍微增加一些复杂度，我们可能需要克隆或拉取代码。第一次构建时没有任何内容，所以我们必须进行克隆。所有后续的构建只应当执行拉取操作，拉取已经克隆的代码。虽然编写一个执行该逻辑的脚本相对简单，但这是一个很好的使用
    Jenkins 插件的案例。更具体地说，我们将使用 Jenkins Pipeline 步骤 git，它在后台使用了其中一个 Git 插件。
- en: 'The `Pull` stage stage of the Pipeline is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline 中的 `Pull` 阶段如下所示：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The git step is one of the many available through Pipelines **Domain Specific
    Language** (**DSL**). It clones the code. If that action was already done, the
    code will be pulled instead. You can find more information in the *Pipeline Steps
    Reference* ([https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/))
    page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: git 步骤是通过 Pipeline **领域特定语言** (**DSL**) 提供的众多步骤之一。它会克隆代码。如果该操作已经完成，代码将会被拉取。您可以在
    *Pipeline 步骤参考* 页面（[https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/)）中找到更多信息。
- en: Please note that in the real world situation we would create a webhook inside
    the code repository. It would trigger this job whenever a new commit is made.
    For now, we'll simulate a web hook by triggering the job execution manually.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实际情况中，我们会在代码仓库中创建一个 webhook。当有新的提交时，它会触发此作业。现在，我们将通过手动触发作业执行来模拟一个 webhook。
- en: Feel free to replace the existing Pipeline definition by copying and pasting
    the code from `scripts/go-demo-pull.groovy` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-pull.groovy](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-pull.groovy)).
    Once you're done, please run the job and observe the build log.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意通过复制并粘贴来自 `scripts/go-demo-pull.groovy` ([https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-pull.groovy](https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/go-demo-pull.groovy))
    的代码来替换现有的流水线定义。完成后，请运行作业并观察构建日志。
- en: Let's move on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进。
- en: 'The code that follows is the translation of the commands we used in the previous
    chapters to run unit tests and build a new Docker image:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们在前几章中用于运行单元测试并构建新 Docker 镜像的命令翻译：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We enveloped the whole stage inside the `withEnv` block that defines the `COMPOSE_FILE`
    variable. That way, we won't need to repeat the `-f docker-compose-test-local.yml`
    argument every time we execute `docker-compose`. Please note that all the other
    stages we'll define soon should also be inside the `withEnv` block.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个阶段包含在 `withEnv` 块中，定义了 `COMPOSE_FILE` 变量。这样，我们就不需要每次执行 `docker-compose`
    时都重复 `-f docker-compose-test-local.yml` 参数。请注意，我们稍后定义的所有其他阶段也应该包含在 `withEnv` 块中。
- en: The steps inside the Unit stage are the same as those we practiced while we
    run the flow manually. The only difference is that, this time, we put the commands
    inside the `sh DSL` step. It's purpose is simple. It runs a shell command.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 单元阶段中的步骤与我们手动运行流程时练习的步骤相同。唯一的不同是，这次我们将命令放入了`sh DSL`步骤中。其目的很简单，就是运行一个 shell 命令。
- en: 'We''ll skip running the job and proceed to the next stage:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过运行作业，直接进入下一阶段：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The Staging stage is a bit more complex. The commands are inside the `try/catch/finally`
    block. The reasons for such an approach is in the way Jenkins behaves when something
    fails. If one of the steps in the previous stage Unit should fail, the whole Pipeline
    build would be aborted. That suits us well when there are no additional actions
    to perform. However, in the case of the Staging steps, we want to remove all the
    dependency containers and free the resources for something else. In other words,
    `docker-compose down` should be executed no matter the outcome of the Staging
    tests. If you are a programmer, you probably already know that the finally statement
    is always executed regardless of whether the try statement produced an error or
    not. In our case, the finally statement will bring down all the containers that
    constitute this Docker Compose project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Staging 阶段稍微复杂一些。命令位于 `try/catch/finally` 块中。这样做的原因是由于 Jenkins 在出现故障时的行为。如果前一个单元阶段中的某个步骤失败，整个流水线构建将会中止。这对于没有额外操作要执行的情况很适合。但是，在
    Staging 阶段，我们希望删除所有的依赖容器并释放资源供其他用途。换句话说，无论 Staging 测试的结果如何，都应该执行 `docker-compose
    down`。如果你是程序员，可能已经知道 `finally` 语句会在 `try` 语句是否产生错误时都被执行。在我们的情况下，`finally` 语句将关闭所有构成此
    Docker Compose 项目的容器。
- en: 'Off we go to the `Publish` stage:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `发布` 阶段：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There's no mystery around this stage. We are repeating the same commands we
    executed in previous chapters. The image is tagged and pushed to the registry.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段没有什么神秘的。我们重复在前几章中执行的相同命令。镜像被标记并推送到注册表。
- en: Please note that we are using `BUILD_NUMBER` to provide a unique release number
    to the tag. It is one of Jenkins built-in environment variables that holds the
    value of the currently executing build ID.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用 `BUILD_NUMBER` 为标签提供唯一的发布号。它是 Jenkins 内置的环境变量之一，保存当前正在执行的构建 ID 的值。
- en: 'The `Prod-like` stage will introduce an additional caveat. It is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`生产环境类似` 阶段会带来一个额外的注意事项。具体如下：'
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we are using rolling updates to replace the old with the new release,
    we have to run tests throughout the whole process. We could create a script that
    would verify whether all instances are updated but I wanted to keep it simple
    (this time). Instead, we are running the tests ten times. You might need to tweak
    it a bit for your needs depending on the average duration of your tests and the
    time required to update all instances. For demonstration purposes, ten rounds
    of testing in the `production-like` environment should be enough.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用滚动更新来将旧版本替换为新版本，因此必须在整个过程中运行测试。我们可以创建一个脚本来验证所有实例是否已更新，但我想保持简单（这次）。相反，我们将测试运行十次。根据测试的平均时长和更新所有实例所需的时间，你可能需要根据实际情况做一些调整。为了演示的目的，在`生产环境类似`的环境中进行十轮测试应该足够了。
- en: To summarize, in this stage we are updating the service with the new release
    and running ten rounds of tests during the update process.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在这一阶段，我们正在使用新版本更新服务，并在更新过程中运行十轮测试。
- en: Please note that we declared a few more environment variables. Specifically,
    we defined all those required for the Docker client to connect to the Docker Engine
    running on a remote host.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们声明了一些额外的环境变量。具体来说，我们定义了所有连接到远程主机上运行的Docker引擎所需的环境变量。
- en: We're almost done. Now that the service is tested in the `production-like` environment,
    we can deploy it to the production cluster.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了。现在服务已经在`production-like`环境中进行了测试，我们可以将其部署到生产集群中。
- en: 'The `Prod` stage is almost the same as `Prod-like`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prod`阶段几乎与`Prod-like`相同：'
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The only difference is that, this time, the `DOCKER_HOST` and `PROD_IP` variables
    point to one of the servers of the production cluster. The rest is the same as
    the `Prod-like` stage.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，这次，`DOCKER_HOST`和`PROD_IP`变量指向生产集群中的一台服务器。其余部分与`Prod-like`阶段相同。
- en: Feel free to replace the existing Pipeline definition with the code from `scripts/go-demo.groovy`.
    Once you're done, please run the job and observe the build log.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 随意用`scripts/go-demo.groovy`中的代码替换现有的Pipeline定义。完成后，请运行作业并查看构建日志。
- en: 'After a short while, the job will finish executing, and the new release will
    be running in the production cluster:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，作业将完成执行，新的版本将在生产集群中运行：
- en: '![](img/jenkins-pipeline-stage-view-2.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jenkins-pipeline-stage-view-2.png)'
- en: 'Figure 6-11: The Jenkins Pipeline Stage View screen'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11：Jenkins Pipeline阶段视图屏幕
- en: 'We can confirm that the service update with the new release was indeed successful
    by executing the `service ps` command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`service ps`命令来确认使用新版本的服务更新确实成功：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of the `service ps` command is as follows (IDs are removed for brevity):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`service ps`命令的输出如下（为简洁起见，ID已被移除）：'
- en: '![](img/ID-removed.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ID-removed.png)'
- en: That's it! We have a full Continuous Deployment Pipeline alive and kicking.
    If we'd add a webhook to the GitHub repository that hosts the code, the Pipeline
    would run every time a new commit is made. As a result, the new release would
    be deployed to production unless one of the steps in the Pipeline fails.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经拥有了一个完整的持续部署Pipeline，运行顺利。如果我们为托管代码的GitHub仓库添加一个Webhook，Pipeline将在每次提交新代码时运行。因此，新的版本将被部署到生产环境，除非Pipeline中的某个步骤失败。
- en: What now?
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在怎么办？
- en: The ability to use the code to define the steps of a Continuous Deployment flow
    gives us more flexibility than we had before with *Freestyle* jobs. Docker Compose
    allowed us to run any type of tasks without the need to set up any special infrastructure.
    Anything can run as long as it is inside a container. Finally, Docker Swarm simplified
    the Deployment to production-like and production environments considerably.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码定义持续部署流程步骤的能力，比之前使用*Freestyle*作业时给我们带来了更多的灵活性。Docker Compose让我们可以运行任何类型的任务，而无需设置任何特殊的基础设施。只要在容器内，任何东西都能运行。最后，Docker
    Swarm大大简化了生产环境和类似生产环境的部署。
- en: We only scratched the surface of using Jenkins Pipeline to automate our Continuous
    Deployment flow. There are quite a few improvements we could do. For example,
    we might use the *Pipeline Shared Groovy Libraries Plugin* ([https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Shared+Groovy+Libraries+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Shared+Groovy+Libraries+Plugin))
    and move steps, or even whole stages into functions and reduce code repetition.
    We could also create a *Jenkinsfile* ([https://jenkins.io/doc/book/pipeline/jenkinsfile/](https://jenkins.io/doc/book/pipeline/jenkinsfile/))
    that would move the Pipeline definition from Jenkins into the service repository
    thus keeping everything related to a single service in one place. We could, also,
    run production tests continuously (not only when making a new release) and ensure
    that we are notified if a service is not working or if it does not perform as
    expected.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅触及了使用Jenkins Pipeline来自动化持续部署流程的表面。我们还可以做出相当多的改进。例如，我们可以使用*Pipeline Shared
    Groovy Libraries Plugin* ([https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Shared+Groovy+Libraries+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Shared+Groovy+Libraries+Plugin))，将步骤，甚至整个阶段移动到函数中，从而减少代码重复。我们还可以创建一个*Jenkinsfile* ([https://jenkins.io/doc/book/pipeline/jenkinsfile/](https://jenkins.io/doc/book/pipeline/jenkinsfile/))，将Pipeline定义从Jenkins移动到服务仓库中，从而将与单个服务相关的所有内容保存在一个地方。我们还可以持续运行生产测试（不仅仅是在发布新版本时），确保在服务无法正常工作或表现不符合预期时收到通知。
- en: We'll leave those and other possible improvements for some other time. While
    not perfect nor optimum, the go-demo Pipeline should be good enough for now.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些以及其他可能的改进留到以后再做。虽然它不是完美的，也不是最优的，但go-demo流水线现在应该足够用了。
- en: 'It is the time to take a break before diving into the next chapter. As before,
    we''ll destroy the machines we created and start fresh:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入下一章之前，是时候休息一下了。如同之前一样，我们将销毁已创建的机器并重新开始：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
