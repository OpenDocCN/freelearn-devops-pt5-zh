- en: Chapter 2. The Implementation Breakthrough – Continuous Deployment, Microservices,
    and Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 实现突破——持续部署、微服务和容器
- en: On the first look **continuous deployment** (**CD**), **microservices** (**MS**)
    and *containers* might seem like three unrelated subjects. After all, *DevOps*
    movement does not stipulate that microservices are necessary for continuous deployment,
    nor microservices need to be packaged into containers. However, when those three
    are combined, new doors open waiting for us to step through. Recent developments
    in the area of containers and the concept of immutable deployments enable us to
    overcome many of the problems microservices had before. They, on the other hand,
    allow us to gain flexibility and speed without which CD is not possible or cost
    effective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，**持续部署**（**CD**）、**微服务**（**MS**）和*容器*似乎是三个不相关的主题。毕竟，*DevOps*运动并未规定微服务是持续部署所必需的，也没有要求将微服务打包成容器。然而，当这三者结合时，新的大门打开了，等待我们迈步而入。容器领域的最新发展和不可变部署的概念使我们能够克服微服务之前所面临的许多问题。另一方面，它们使我们能够获得灵活性和速度，而没有这些，持续部署将不可能实现，也无法在成本上做到高效。
- en: Before we move forward with this line of thinking, we'll try to define correctly
    each of those terms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入这个思路之前，我们将尝试正确地定义每一个术语。
- en: Continuous Integration
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: To understand continuous deployment we should first define its predecessors;
    continuous integration and continuous delivery.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解持续部署，我们首先需要定义它的前身——持续集成和持续交付。
- en: Integration phase of a project development tended to be one of the most painful
    stages in software development life-cycle. We would spend weeks, months or even
    years working in separate teams dedicated to separate applications and services.
    Each of those teams would have their set of requirements and tried their best
    to meet them. While it wasn't hard to periodically verify each of those applications
    and services in isolation, we all dreaded the moment when team leads would decide
    that the time has come to integrate them into a unique delivery. Armed with the
    experience from previous projects, we knew that integration will be problematic.
    We knew that we will discover problems, unmet dependencies, interfaces that do
    not communicate with each others correctly and that managers will get disappointed,
    frustrated, and nervous. It was not uncommon to spend weeks or even months in
    this phase. The worse part of all that was that a bug found during the integration
    phase could mean going back and redoing days or weeks worth of work. If someone
    asked me how a feel about integration I'd say that it was closest I could get
    to becoming permanently depressed. Those were different times. We thought that
    was the "right" way to develop applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 项目开发的集成阶段往往是软件开发生命周期中最痛苦的阶段之一。我们会花费数周、数月甚至数年时间，在各自的团队中为不同的应用程序和服务而工作。每个团队都有他们自己的需求，并尽力满足它们。虽然定期验证每个应用程序和服务的独立性并不困难，但我们都害怕团队领导决定该是时候将它们集成到一个统一交付物中了。凭借从前期项目中积累的经验，我们知道集成将会遇到问题。我们知道，我们将发现问题、未满足的依赖关系、接口无法正确通信，而管理层将感到失望、沮丧和焦虑。通常情况下，这一阶段可能会花费数周甚至数月时间。最糟糕的是，在集成阶段发现的一个bug可能意味着我们需要回去重新做掉几天甚至几周的工作。如果有人问我对集成的看法，我会说这是我能体验到的最接近长期沮丧的感受。那时的情况不同，我们曾认为那是开发应用程序的“正确”方式。
- en: A lot changed since then. **Extreme Programming** (**XP**) and other agile methodologies
    become familiar, automated testing become frequent, and continuous integration
    started to take ground. Today we know that the way we developed software back
    then was wrong. The industry moved a long way since then.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，很多事情发生了变化。**极限编程**（**XP**）和其他敏捷方法变得广为人知，自动化测试变得频繁，持续集成开始占据重要地位。今天我们知道，当时我们开发软件的方式是错误的。自那时以来，行业已经走了很长一段路。
- en: '**Continuous integration** (**CI**) usually refers to integrating, building,
    and testing code within the development environment. It requires developers to
    integrate code into a shared repository often. How often is often can be interpreted
    in many ways and it depends on the size of the team, the size of the project and
    the number of hours we dedicate to coding. In most cases it means that coders
    either push directly to the shared repository or merge their code with it. No
    matter whether we''re pushing or merging, those actions should, in most cases,
    be done at least a couple of times a day. Getting code to the shared repository
    is not enough and we need to have a pipeline that, as a minimum, checks out the
    code and runs all the tests related, directly or indirectly, to the code corresponding
    to the repository. The result of the execution of the pipeline can be either *red*
    or *green*. Something failed, or everything was run without any problems. In the
    former case, minimum action would be to notify the person who committed the code.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）通常是指在开发环境中集成、构建和测试代码。它要求开发者频繁地将代码集成到共享代码库中。到底“频繁”是指多久，这可以有很多解释，取决于团队的大小、项目的规模以及我们投入的编程时间。在大多数情况下，这意味着开发者要么直接推送代码到共享代码库，要么将自己的代码合并到其中。无论是推送还是合并，这些操作在大多数情况下应该至少每天做几次。将代码推送到共享代码库本身还不够，我们还需要有一个管道，至少要检查代码并运行所有与该代码相关的测试，无论是直接还是间接的。管道执行的结果可以是*红色*或*绿色*。如果是前者，说明某些操作失败了；如果是后者，则说明所有操作都顺利执行。如果出现前者，最小的反应是通知提交代码的人。'
- en: The continuous integration pipeline should run on every commit or push. Unlike
    continuous delivery, continuous integration does not have a clearly defined goal
    of that pipeline. Saying that one application integrates with others does not
    tell us a lot about its production readiness. We do not know how much more work
    is required to get to the stage when the code can be delivered to production.
    All we are truly striving for is the knowledge that a commit did not break any
    of the existing tests. Never the less, CI is a huge improvement when done right.
    In many cases, it is a very hard practice to implement, but once everyone is comfortable
    with it, the results are often very impressive.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成管道应该在每次提交或推送时运行。与持续交付不同，持续集成没有明确的目标来定义该管道。仅仅说一个应用程序与其他应用程序集成并不能告诉我们它的生产准备情况。我们不知道还需要多少工作才能将代码交付到生产环境。我们真正追求的目标只是知道一次提交没有破坏任何现有的测试。尽管如此，正确实施持续集成（CI）仍然是一个巨大的进步。在许多情况下，这是一项非常难以实施的实践，但一旦大家都适应了，结果通常会令人印象深刻。
- en: Integration tests need to be committed together with the implementation code,
    if not before. To gain maximum benefits, we should write tests in **test-driven
    development** (**TDD**) fashion. That way, not only that tests are ready for commit
    together with implementation, but we know that they are not faulty and would not
    pass no matter what we do. There are many other benefits TDD brings to the table
    and, if you haven't already, I strongly recommend to adopt it. You might want
    to consult the [https://technologyconversations.com/category/test-driven-development/](https://technologyconversations.com/category/test-driven-development/)
    blog.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试需要与实现代码一起提交，或者至少在其之前提交。为了获得最大的效益，我们应该采用**测试驱动开发**（**TDD**）的方式编写测试。这样，不仅测试可以与实现代码一起提交，而且我们知道这些测试是没有缺陷的，不管我们做什么，它们都不会通过测试。TDD带来了许多其他好处，如果你还没有采用它，我强烈推荐你去使用。你可以参考[https://technologyconversations.com/category/test-driven-development/](https://technologyconversations.com/category/test-driven-development/)
    这个博客。
- en: Tests are not the only CI prerequisite. One of the most important rules is that
    when the pipeline fails, fixing the problem has higher priority than any other
    task. If this action is postponed, next executions of the pipeline will fail as
    well. People will start ignoring the failure notifications and, slowly, CI process
    will begin losing its purpose. The sooner we fix the problem discovered during
    the execution of the CI pipeline, the better we are. If corrective action is taken
    immediately, knowledge about the potential cause of the problem is still fresh
    (after all, it's been only a few minutes between the commit and the failure notification)
    and fixing it should be trivial.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并不是唯一的持续集成（CI）前提条件。最重要的一条规则是，当管道失败时，修复问题的优先级要高于任何其他任务。如果这个修复行动被推迟，管道的后续执行也会失败。人们会开始忽略失败通知，渐渐地，CI过程会失去它的意义。我们越早修复在CI管道执行过程中发现的问题，就越好。如果立即采取纠正措施，那么问题的潜在原因仍然鲜明（毕竟，提交与失败通知之间的时间只有几分钟），修复问题应该是轻而易举的。
- en: 'So how does it work? Details depend on tools, programming language, project,
    and many other factors. The most common flow is the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是如何工作的呢？具体细节取决于工具、编程语言、项目以及许多其他因素。最常见的流程如下：
- en: Pushing to the code repository
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送到代码仓库
- en: Static analysis
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析
- en: Pre-deployment testing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署前测试
- en: Packaging and deployment to the test environment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包并部署到测试环境
- en: Post-deployment testing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署后测试
- en: Pushing to the Code repository
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送到代码仓库
- en: 'Developers work on features in separate branches. Once they feel comfortable
    that their work is stable, the branch they''ve been working on is merged with
    the mainline (or trunk). More advanced teams may skip feature branches altogether
    and commit directly to the mainline. The crucial point is that the mainline branch
    (or trunk) needs to receive commits often (either through merges or direct pushes).
    If days or weeks pass, changes accumulate and benefits of using continuous integration
    diminish. In that case, there is no fast feedback since the integration with other
    people''s code is postponed. On the other hand, CI tools (we''ll talk about them
    later) are monitoring the code repository, and whenever a commit is detected,
    the code is checked out (or cloned) and the CI pipeline is run. The pipeline itself
    consists of a set of automated tasks run in parallel or sequentially. The result
    of the pipeline is either a failure in one of its steps or a promotion. As a minimum,
    failure should result in some form of a notification sent to the developer that
    pushed the commit that resulted in a failed pipeline. It should be his responsibility
    to fix the problem (after all, he knows best how to fix a problem created by him
    only minutes ago) and do another commit to the repository that, in turn, will
    trigger another execution of the pipeline. This developer should consider fixing
    the problem his highest priority task so that the pipeline continues being "green"
    and avoid failures that would be produced by commits from other developers. Try
    to keep a number of people who receive the failure notification to a minimum.
    The whole process from detecting a problem until it is fixed should be as fast
    as possible. The more people are involved, the more administrative work tends
    to happen and the more time is spent until the fix is committed. If, on the other
    hand, the pipeline runs successfully throughout all its tasks, the package produced
    throughout the process is promoted to the next stage and, in most cases, given
    to testers for manual verifications. Due to the difference in speed between the
    pipeline (minutes) and manual testing (hours or days), not every pipeline execution
    is taken by QAs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在单独的分支上开发功能。一旦他们觉得自己的工作稳定，所开发的分支就会与主干（或 trunk）合并。更高级的团队可能完全跳过功能分支，直接提交到主干。关键点是主干分支（或
    trunk）需要经常接收提交（无论是通过合并还是直接推送）。如果几天或几周过去，变化会积累，使用持续集成的好处会减少。在这种情况下，没有快速反馈，因为与其他人的代码集成被推迟了。另一方面，CI
    工具（我们稍后会讨论）正在监控代码库，每当检测到提交时，代码会被检出（或克隆），然后 CI 管道会运行。管道本身由一组自动化任务组成，这些任务可以并行或顺序执行。管道的结果要么是其中某个步骤的失败，要么是成功的提升。至少，失败应该导致某种形式的通知，发送给推送了导致管道失败的提交的开发人员。开发人员应该负责修复问题（毕竟，他最清楚如何修复几分钟前他自己造成的问题），并重新提交代码库，这反过来将触发管道的再次执行。这个开发人员应该把修复问题当作最优先任务，以便保持管道始终为“绿色”，并避免其他开发人员的提交导致失败。尽量将收到失败通知的人员数量保持在最低。整个从发现问题到修复问题的过程应该尽可能快。涉及人员越多，管理工作就越多，直到修复提交的时间就越长。另一方面，如果管道在所有任务中都成功运行，整个过程中生成的包将被提升到下一个阶段，并在大多数情况下交给测试人员进行手动验证。由于管道（几分钟）和手动测试（几小时或几天）之间的速度差异，并非每次管道执行都由
    QA 执行：
- en: '![Pushing to the Code repository](img/B05848_02_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![推送到代码库](img/B05848_02_01.jpg)'
- en: Figure 2-1 – Continuous integration process
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1 – 持续集成过程
- en: The first step in the continuous integration pipeline is often static analysis.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成管道的第一步通常是静态分析。
- en: Static analysis
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: '*Static analysis* is the analysis of computer software that is performed without
    actually executing programs. Like its opposite, the analysis performed while executing
    programs is known as *dynamic analysis*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态分析* 是在不执行程序的情况下对计算机软件进行的分析。与其相反的是，执行程序时进行的分析被称为 *动态分析*。'
- en: The static analysis goals vary from highlighting possible coding errors to making
    sure that agreed formatting is followed. While benefits of using static analysis
    are questionable, the effort required to implement it is so small that there is
    no real reason not to use it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析的目标从突出可能的编码错误到确保遵循约定的格式不等。虽然使用静态分析的好处值得商榷，但实施它所需的努力非常小，因此没有真正的理由不使用它。
- en: I won't provide a comprehensive list of tools since they vary from one programming
    language to another. `CheckStyle` and `FindBugs` for Java, `JSLint` and `JSHint`
    for JavaScript, and `PMD` for a variety of languages, are only a few examples.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供工具的全面列表，因为它们因编程语言而异。`CheckStyle` 和 `FindBugs` 适用于 Java，`JSLint` 和 `JSHint`
    适用于 JavaScript，`PMD` 适用于多种语言，这只是几个例子。
- en: 'Static analysis is often the first step in the pipeline for the simple reason
    that its execution tends to be very fast and in most cases faster than any other
    step we have in the pipeline. All we have to do is choose the tools and often
    spend a little up-front time in setting up the rules we want them to use. From
    there on, the cost of the maintenance effort is close to nothing. Since it should
    not take more than few seconds to run this step, the cost in time is also negligible:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析通常是流水线中的第一步，原因很简单，它的执行速度通常非常快，在大多数情况下比流水线中的任何其他步骤都要快。我们需要做的就是选择工具，并通常花一些时间设置我们希望它们使用的规则。从那以后，维护的成本几乎为零。由于执行此步骤不应该超过几秒钟，因此时间成本也微不足道：
- en: '![Static analysis](img/B05848_02_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![静态分析](img/B05848_02_02.jpg)'
- en: 'Figure 2-2 – Continuous integration pipeline: static analysis'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2 – 持续集成流水线：静态分析
- en: With the static analysis set up, our pipeline just started, and we can move
    to pre-deployment testing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好静态分析后，我们的流水线已经启动，可以进入部署前测试阶段。
- en: Pre-Deployment testing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署前测试
- en: Unlike (optional) static analysis, *pre-deployment* tests should be mandatory.
    I intentionally avoided more specific name for those tests because it depends
    on the architecture, programming language, and frameworks. As a rule of thumb,
    all types of tests that do not require code to be deployed to a server should
    be run in this phase. *Unit tests* always fall into this category and with few
    others that might be run as well. If, for example, you can execute *functional
    tests* without deploying the code, run them now.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与（可选的）静态分析不同，*部署前*测试应该是强制性的。我故意避免使用更具体的名称来描述这些测试，因为它们依赖于架构、编程语言和框架。一般来说，所有不需要将代码部署到服务器的测试类型都应该在这个阶段运行。*单元测试*总是属于这个类别，可能还会有其他几种测试。如果，例如，你可以在不部署代码的情况下执行*功能测试*，那么就现在执行它们。
- en: 'Pre-deployment testing is probably the most critical phase in *continuous integration
    pipeline*. While it does not provide all the certainty that we need, and it does
    not substitute *post-deployment testing*, tests run in this phase are relatively
    easy to write, should be very fast to execute and they tend to provide much bigger
    code coverage than other types of tests (for example integration and performance):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 部署前测试可能是*持续集成流水线*中最关键的阶段。虽然它不能提供我们所需要的所有确定性，也不能替代*部署后测试*，但在这个阶段运行的测试相对容易编写，执行速度非常快，而且它们通常能提供比其他类型的测试（例如集成测试和性能测试）更大的代码覆盖率：
- en: '![Pre-Deployment testing](img/B05848_02_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![部署前测试](img/B05848_02_03.jpg)'
- en: 'Figure 2-3 – Continuous integration pipeline: pre-deployment testing'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3 – 持续集成流水线：部署前测试
- en: Packaging and Deployment to the Test environment
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包与部署到测试环境
- en: Once we did all types of verifications that could be done without actually deploying
    the application, it is time to package it. The method to do it would depend on
    framework and programming language. In the Java world we would create JAR or WAR
    files, for JavaScript we would minimize the code and maybe send it to the CDN
    server, and so on and so forth. Some programming languages do not require us to
    do anything in this phase except possibly compress all the files into a ZIP or
    TAR a file for easier transfer to servers. An optional, but in the case of this
    book mandatory, step is to create a container that contains not only the package
    but also all other dependencies our application might need like libraries, runtime
    environment, application server, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有可以在不实际部署应用程序的情况下进行的验证，就该开始打包了。打包的方法取决于框架和编程语言。在 Java 环境中，我们会创建 JAR
    或 WAR 文件，对于 JavaScript，我们会最小化代码，并可能将其发送到 CDN 服务器，等等。有些编程语言在此阶段不需要我们做任何事情，除了可能将所有文件压缩成
    ZIP 或 TAR 文件，以便更方便地传输到服务器。一个可选的步骤，但在本书中是必须的，就是创建一个容器，其中不仅包含应用程序包，还包含应用程序可能需要的所有其他依赖项，比如库、运行时环境、应用服务器等。
- en: 'Once the deployment package is created, we can proceed to deploy it to a test
    environment. Depending on the capacity of the servers you might need to deploy
    to multiple boxes with, for example, one being dedicated to performance testing
    and the other for all the rest of tests that require deployment:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署包创建完成，我们可以继续将其部署到测试环境中。根据服务器的容量，你可能需要将其部署到多个机器上，例如，一个机器专门用于性能测试，另一个机器则用于其他所有需要部署的测试：
- en: '![Packaging and Deployment to the Test environment](img/B05848_02_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![打包和部署到测试环境](img/B05848_02_04.jpg)'
- en: 'Figure 2-4 – The continuous integration pipeline: packaging and deployment'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4 – 持续集成流水线：打包和部署
- en: Post-Deployment testing
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署后测试
- en: Once deployed to a test environment, we can execute the rest of the tests; those
    that could not be run without deploying the application or a service as well as
    those that prove that the integration was successful. Again, types of tests that
    can be run in this phase depend on frameworks and programming language but, as
    a general rule, they include functional, integration and performance tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署到测试环境中，我们就可以执行其余的测试；这些测试是那些无法在不部署应用程序或服务的情况下运行的测试，以及那些验证集成是否成功的测试。同样，能够在此阶段执行的测试类型取决于框架和编程语言，但作为一般规则，它们包括功能测试、集成测试和性能测试。
- en: Exact tools and technologies used to write and run those tests will depend on
    many aspects. My personal preference is to use *behavior-driven development* for
    all functional tests that, at the same time, act as acceptance criteria and **Gatling**
    for performance tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编写和运行这些测试的具体工具和技术将取决于许多方面。我个人的偏好是使用*行为驱动开发*进行所有功能测试，这些测试同时也作为验收标准，**Gatling**用于性能测试。
- en: 'Once the execution of post-deployment tests is finished successfully, the continuous
    integration pipeline is typically completed as well. Packages or artifacts we
    generated during the *packaging* and *deployment to test environment* are waiting
    for further, usually manual, verifications. Later on, one of the builds of the
    pipeline will be elected to be deployed to production. Means and details of additional
    checks and deployment to production are not part of continuous integration. Every
    build that passed the whole pipeline is considered integrated and ready for whatever
    comes next:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署后测试的执行成功完成，持续集成流水线通常也会完成。我们在*打包*和*部署到测试环境*过程中生成的包或工件，将等待进一步的验证，通常是手动验证。之后，流水线中的某个构建将被选中部署到生产环境。额外检查和部署到生产环境的方式和细节并不属于持续集成的范畴。每个通过整个流水线的构建都被视为已集成，准备好迎接接下来的任务：
- en: '![Post-Deployment testing](img/B05848_02_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![部署后测试](img/B05848_02_05.jpg)'
- en: 'Figure 2-5 – Continuous integration pipeline: post-deployment testing'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5 – 持续集成流水线：部署后测试
- en: Many other things could be done in the pipeline. The pipeline presented here
    is a very general one and often varies from case to case. For example, you might
    choose to measure code coverage and fail when a certain percentage is not reached.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线中还可以做很多其他事情。这里展示的流水线是一个非常通用的示例，通常会因案例而异。例如，你可能会选择测量代码覆盖率，并在未达到某个百分比时失败。
- en: We're not going into details right now but trying to get a general overview
    of the process so let us move into continuous delivery and deployment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不深入细节，而是尝试对这个过程进行总体概述，接下来我们将进入持续交付和部署。
- en: Continuous Delivery and Deployment
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付与部署
- en: 'The continuous delivery pipeline is in most cases the same as the one we would
    use for CI. The major difference is in the confidence we have in the process and
    lack of actions to be taken after the execution of the pipeline. While CI assumes
    that there are (mostly manual) validations to be performed afterward, successful
    implementation of the CD pipeline results in packages or artifacts being ready
    to be deployed to production. In other words, every successful run of the pipeline
    can be deployed to production, no questions asked. Whether it will be deployed
    or not depends more on political than technical decisions. The marketing department
    might want to wait until a certain date, or they might want to go live with a
    group of features deployed together. No matter the decision which build to deploy
    and when, from the technical perspective, the code of every successful build is
    fully finished. The only difference between the continuous integration and continuous
    delivery processes is that the latter does not have the manual testing phase that
    is performed after the package is promoted through the pipeline. Simply put, the
    pipeline itself provides enough confidence that there is no need for manual actions.
    With it, we are technically capable of deploying every promoted build. Which one
    of those will be deployed to production is a decision often based on business
    or marketing criteria where the company decides the right time to release a set
    of features:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 连续交付流水线在大多数情况下与我们用于持续集成（CI）的流水线相同。主要区别在于我们对该过程的信心，以及在流水线执行后无需采取任何后续行动。持续集成假设在之后需要进行（大多是手动）验证，而成功实施连续交付（CD）流水线则意味着包或工件已经准备好进行生产部署。换句话说，每次成功运行的流水线都可以部署到生产环境中，毫无疑问。是否进行部署则更多取决于政治而非技术决策。市场部门可能希望等到某个特定日期，或者他们可能希望将一组功能一起发布。无论选择部署哪个版本以及何时部署，从技术角度来看，每个成功构建的代码都是完全完成的。持续集成与持续交付过程之间的唯一区别在于后者没有在包通过流水线之后进行的手动测试阶段。简而言之，流水线本身提供了足够的信心，认为无需手动操作。借助它，我们在技术上有能力部署每个已推广的构建。至于哪些构建将被部署到生产环境，这通常是基于业务或市场标准的决策，企业决定何时发布一组功能：
- en: '![Continuous Delivery and Deployment](img/B05848_02_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![连续交付与部署](img/B05848_02_06.jpg)'
- en: Figure 2-6 – Continuous delivery process
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6 – 连续交付过程
- en: Keep in mind that we continued using *CI tool* in the continuous delivery process
    diagram. The reason for this is a lack of any substantial difference between CI
    and CD tools. This does not mean that there are no products being marketed as
    CD tools - there are many. However, in my experience, this is more of a marketing
    stunt as both processes are almost the same assuming that processes rely on a
    high level of automation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在持续交付过程图中继续使用了*CI工具*。之所以如此，是因为CI和CD工具之间没有任何实质性差异。这并不意味着没有被市场化的CD工具——其实有很多。然而，根据我的经验，这更像是一种市场营销手段，因为假设流程依赖于高度自动化，两者几乎是相同的。
- en: Regarding the pipeline process, there is also no substantial difference between
    continuous integration and continuous delivery. Both go through the same phases.
    The real difference is in the confidence we have in the process. As a result,
    the continuous delivery process does not have the manual QA phase. It's up to
    us to make a decision which one of the promoted packages will be deployed to production.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于流水线过程，持续集成和持续交付之间也没有实质性区别。两者都经历相同的阶段。真正的区别在于我们对该过程的信心。因此，持续交付过程没有手动质量保证（QA）阶段。决定哪个已推广的包将部署到生产环境是我们的任务。
- en: 'The continuous deployment pipeline goes a step further and automatically deploys
    every build that passed all verifications. It is a fully automated process that
    starts with a commit to the code repository and ends with the application or the
    service being deployed to production. There is no human intervention, nothing
    to decide and nothing to do but to start coding the next feature while results
    of your work are finding their way to the users. In cases when packages are deployed
    to QA server before being deployed to production, post-deployment testing is done
    twice (or as many times are the number of servers we deploy to). In such a case,
    we might choose to run different subsets of post-deployment tests. For example,
    we might run all of them on the software deployed to QA server and only integration
    tests after deploying to production. Depending on the result of post-deployment
    tests, we might choose to roll-back or enable the release to the general public.
    When a proxy service is used to make a new release visible to the public, there
    is usually no need to roll-back since the newly released application was not made
    visible before the problem was detected:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署流水线更进一步，自动部署每一个通过所有验证的构建。它是一个完全自动化的过程，始于代码库的提交，终于应用或服务被部署到生产环境。没有人工干预，没什么需要决定的，也没有什么需要做的，只需开始编写下一个功能，而你的工作成果正在向用户传递。当包被部署到
    QA 服务器上，才会部署到生产环境时，部署后测试会进行两次（或根据部署到的服务器数量进行多次）。在这种情况下，我们可能选择运行不同子集的部署后测试。例如，我们可能在部署到
    QA 服务器的软件上运行所有测试，而只在部署到生产环境后运行集成测试。根据部署后测试的结果，我们可能选择回滚或将发布版本开放给公众。当使用代理服务让新的发布对公众可见时，通常不需要回滚，因为新发布的应用程序在问题被检测到之前并未对外公开：
- en: '![Continuous Delivery and Deployment](img/B05848_02_07.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![持续交付和部署](img/B05848_02_07.jpg)'
- en: Figure 2-7 – Continuous deployment pipeline
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7 – 持续部署流水线
- en: We need to pay particular attention to databases (especially when they are relational)
    and ensure that changes we are making from one release to another are backward
    compatible and can work with both releases (at least for some time).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要特别关注数据库（特别是关系型数据库），并确保从一个版本到另一个版本的更改是向后兼容的，并且能够在两个版本之间正常工作（至少在一段时间内）。
- en: While continuous integration welcomes, but does not necessarily require, deployed
    software to be tested in production, continuous delivery and deployment have production
    (mostly integration) testing as an absolute necessity and, in the case of continuous
    deployment, part of the fully automated pipeline. Since there are no manual verifications,
    we need to be as sure as possible that whatever was deployed to production is
    working as expected. That does not mean that all the automated tests need to be
    repeated. It means that we need to run tests that prove that the deployed software
    is integrated with the rest of the system. The fact that we run, possibly same,
    integration tests in other environments does not mean that due to some differences,
    software deployed to production continues to "play nicely" with the rest of the
    system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然持续集成欢迎但不一定要求在生产环境中测试已部署的软件，持续交付和部署则将生产环境中的（主要是集成）测试视为绝对必要，且在持续部署的情况下，这部分测试是完全自动化流水线的一部分。由于没有人工验证，我们需要尽可能确保部署到生产环境中的软件按预期工作。这并不意味着所有的自动化测试都需要重复进行。这意味着我们需要运行能证明部署软件与系统其余部分集成良好的测试。我们可能在其他环境中运行相同的集成测试，但这并不意味着由于某些差异，部署到生产环境的软件就能够继续与系统的其余部分“友好合作”。
- en: Another very useful technique in the context of continuous deployment is feature
    toggles. Since every build is deployed to production, we can use them to disable
    some features temporarily. For example, we might have the login screen fully developed
    but without the registration. It would not make sense to let the visitors know
    about a feature that requires another still not deployed feature. Continuous delivery
    solves that problem by manually approving which build is deployed to production
    and would choose to wait. Since, in the case of continuous deployment that decision-making
    it not available, feature toggles are a must or we would need to delay merging
    with the mainline until all related features are finished. However, we already
    discussed the importance of constant merging with the mainline and such delays
    are against the logic behind CI/CD. While there are other ways to solve this problem,
    I find feature toggles to be indispensable to all those who choose to apply continuous
    deployment. We won't go into feature toggles details. For those interested obtaining
    more info, please visit the [https://technologyconversations.com/2014/08/26/feature-toggles-feature-switches-or-feature-flags-vs-feature-branches/](https://technologyconversations.com/2014/08/26/feature-toggles-feature-switches-or-feature-flags-vs-feature-branches/)
    article.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续部署的背景下，另一个非常有用的技术是功能切换。由于每个构建都会部署到生产环境，我们可以使用功能切换来暂时禁用某些功能。例如，我们可能已经完全开发了登录界面，但没有注册功能。如果没有注册功能，向访客展示一个功能不完整的界面就没有意义。持续交付通过手动批准哪些构建部署到生产环境来解决这个问题，并选择等待。然而，在持续部署的情况下，这个决策过程不可用，因此功能切换是必须的，否则我们就需要延迟与主干的合并，直到所有相关功能完成。然而，我们已经讨论过与主干不断合并的重要性，这种延迟与CI/CD的逻辑背道而驰。虽然有其他方法可以解决这个问题，但我认为功能切换是所有选择应用持续部署的团队不可或缺的工具。我们不会深入讨论功能切换的细节。有兴趣了解更多信息的朋友，可以访问[https://technologyconversations.com/2014/08/26/feature-toggles-feature-switches-or-feature-flags-vs-feature-branches/](https://technologyconversations.com/2014/08/26/feature-toggles-feature-switches-or-feature-flags-vs-feature-branches/)
    文章。
- en: Most teams start with continuous integration and slowly move towards delivery
    and deployment since former are prerequisites for later. In this book, we'll practice
    continuous deployment. Don't be scared. Everything we'll do can be easily modified
    so that there are pauses and manual interventions. For example, we will be deploying
    containers directly to production (actually to VMs that imitate production) without
    passing through test environments. When applying techniques from this book, you
    can easily choose to add a testing environment in between.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数团队从持续集成开始，逐渐向交付和部署过渡，因为前者是后者的前提条件。在本书中，我们将实践持续部署。不要害怕，我们所做的一切都可以轻松修改，以便进行暂停和手动干预。例如，我们将直接将容器部署到生产环境（实际上是模拟生产环境的虚拟机），而不经过测试环境。当应用本书中的技术时，你可以轻松选择在中间添加一个测试环境。
- en: The important thing to note is that the pipeline phases that we discussed are
    performed in particular order. That order is not only logical (for example, we
    cannot deploy before compiling) but also in order of the execution time. Things
    that take less to run are run first. For example, as a general rule, pre-deployment
    tests tend to run much faster than those we'll run as post-deployment. The same
    rule should be followed within each phase. If, for example, you have different
    types of tests within the pre-deployment phase, run those that are faster first.
    The reason for this quest for speed is time until we get feedback. The sooner
    we find out that there is something wrong with the commit, the better. Ideally,
    we should get that feedback before we move to the next development task. Do the
    commit, have a quick coffee, check your inbox and if there is no angry email stating
    that something failed, move to the next task.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，我们讨论的流水线阶段是按特定顺序执行的。这个顺序不仅是逻辑上的（例如，我们不能在编译之前进行部署），而且是根据执行时间的顺序来安排的。执行时间较短的任务会先执行。例如，作为一般规则，部署前的测试通常比部署后的测试运行得要快。这个规则也应该在每个阶段内遵循。例如，如果你在部署前阶段有不同类型的测试，那么先运行那些较快的测试。追求速度的原因是为了尽早获得反馈。我们越早发现提交中有问题，越好。理想情况下，我们应该在开始下一个开发任务之前就得到反馈。提交代码，喝一杯快速的咖啡，检查你的收件箱，如果没有收到任何愤怒的邮件说明某些事情失败了，就可以继续下一个任务。
- en: Later on, throughout this book, you'll see that some of the phases and details
    of the presented pipeline are a bit different due to advantages brought by microservices
    and containers. For example, packaging will finish with immutable (unchangeable)
    containers, deployment to a test environment might not be required at all, we
    might choose to perform testing directly to the production environment using the
    blue/green technique, and so on. However, I am ahead of myself. Everything will
    come in due time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续内容中，你会发现，由于微服务和容器带来的优势，所呈现的管道中的一些阶段和细节有所不同。例如，打包过程最终将以不可变（无法更改）容器的形式完成，可能完全不需要部署到测试环境，我们可能选择直接在生产环境中进行测试，使用蓝绿部署技术，等等。不过，我有点超前了，所有内容都会在适当的时机讲解。
- en: With CI/CD out of the way (for now), it is time to discuss microservices.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在目前处理完CI/CD后（暂时），是时候讨论微服务了。
- en: Microservices
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: We already spoke about speed in the context of continuous deployment. This speed
    refers to the time from conception of the idea for new functionality until it
    is fully operational and deployed to production. We want to be able to move fast
    and provide the shortest possible time to market. If a new functionality can be
    delivered in a matter of hours or days, business will start seeing benefits much
    faster than if it takes weeks or months.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在持续部署的背景下讨论过速度。这里的速度是指从新功能的构思到它完全投入使用并部署到生产环境所花的时间。我们希望能够快速行动，并提供最短的上市时间。如果新功能能够在几个小时或几天内交付，业务就能比需要几周或几个月的交付时间更快看到收益。
- en: Speed can be accomplished in multiple ways. For example, we want the pipeline
    to be as fast as possible both in order to provide quick feedback in case of a
    failure as well as to liberate resources for other queued jobs. We should aim
    at spending minutes instead of hours from checking out the code to having it deployed
    to production. Microservices can help accomplishing this timing. Running the whole
    pipeline for a huge monolithic application is often slow. Same applies to testing,
    packaging, and deployment. On the other hand, microservices are much faster for
    the simple reason that they are far smaller. There is less code to test, less
    code to package and less code to deploy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 速度可以通过多种方式实现。例如，我们希望管道尽可能快，这不仅是为了在发生故障时提供快速反馈，还能释放资源供其他排队的任务使用。我们应该目标是在几分钟内，而不是几小时内，从代码检查到部署到生产环境。微服务有助于实现这个时间目标。对于一个庞大的单体应用来说，整个管道的运行通常比较慢。测试、打包和部署也是如此。另一方面，微服务由于更小，通常要快得多。测试的代码更少，打包的代码更少，部署的代码也更少。
- en: We would not be switching to microservices if that were be the only reason.
    Later on, there will be a whole chapter dedicated to a much deeper examination
    of microservices. For now, the important thing to note is that due to the goals
    today's competition sets in front of us (flexibility, speed, and so on), microservices
    are probably the best type of architecture we can apply.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅仅是这个原因，我们是不会切换到微服务架构的。稍后会有整整一章内容深入探讨微服务。目前需要注意的是，由于今天的竞争目标（如灵活性、速度等），微服务可能是我们可以应用的最佳架构类型。
- en: Containers
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: Before containers became common, microservices were painful to deploy. In comparison,
    monolithic applications are relatively simple to handle. We would, for example,
    create a single artifact (JAR, WAR, DLL, and so on), deploy it to the server and
    make sure that all required executables and libraries (for example JDKs) are present.
    This process was most of the time standardized, and had relatively few things
    to think about. One microservice is equally simple, but when their number multiplies
    with ten, hundred or even thousand, things start getting complicated. They might
    use different versions of dependencies, different frameworks, various application
    servers, and so on. The number of stuff we have to think about starts rising exponentially.
    After all, one of the reasons behind microservices is the ability to choose the
    best tool for the job. One might be better off if it's written in GoLang while
    the other would be a better fit for NodeJS. One could use JDK 7, while the other
    might need JDK 8\. Installing and maintaining all that might quickly turn servers
    into garbage cans and make people in charge of them go crazy. The most common
    solution applied back then was standardizing as much as possible. Everyone must
    use only JDK 7 for the back-end. All front-end has to be done with JSP. The common
    code should be placed in shared libraries. In other words, people tried to solve
    problems related to microservices deployment applying the same logic they learned
    during years of development, maintenance, and deployment of monolithic applications.
    Kill the innovation for the sake of standardization. And we could not blame them.
    The only alternative were immutable VMs and that only changed one set of problems
    for another. That is, until containers become popular and, more importantly, accessible
    to masses.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器普及之前，微服务的部署是非常痛苦的。相比之下，单体应用程序的处理相对简单。例如，我们会创建一个单一的工件（JAR、WAR、DLL 等），将其部署到服务器并确保所有必需的可执行文件和库（例如
    JDK）都已经到位。这个过程大多数时候是标准化的，考虑的事情相对较少。一个微服务同样简单，但当它们的数量增加到十个、百个甚至千个时，事情就开始变得复杂了。它们可能使用不同版本的依赖、不同的框架、各种应用服务器等等。我们需要考虑的事项开始呈指数级上升。毕竟，微服务的其中一个原因就是能够为每项工作选择最合适的工具。有的可能在
    GoLang 中写得更好，而另一些则更适合 NodeJS。一个可能使用 JDK 7，而另一个可能需要 JDK 8。安装和维护这些内容可能会很快让服务器变成垃圾堆，让负责管理的人抓狂。那个时候最常用的解决方案是尽可能标准化。每个人的后端都必须使用
    JDK 7。所有前端必须使用 JSP。共有代码应该放在共享库中。换句话说，人们试图用他们多年来在开发、维护和部署单体应用程序中学到的逻辑来解决微服务部署的问题。为了标准化而扼杀创新。而我们不能怪他们。当时唯一的替代方案是不可变虚拟机，但这仅仅是将一组问题替换成另一组问题。直到容器变得流行，且更重要的是，变得大众可用。
- en: Docker made it possible to work with containers without suffering in the process.
    They made containers accessible and easy to use to everyone.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使得我们能够在不受苦的情况下使用容器。它们让容器变得可访问且易于使用，适用于每个人。
- en: What are containers? The definition of the word container is an object for holding
    or transporting something. Most people associate containers with *shipping containers*.
    They should have strength suitable to withstand shipment, storage, and handling.
    You can see them being transported in a variety of ways, most common one of them
    being by ship. In big shipyards, you can find hundreds or even thousands of them
    stacked one besides the other and one on top of the other. Almost all merchandise
    is shipped through containers for a reason. They are standardized, easy to stack
    and hard to damage. Most involved with shipping do not know what's inside them.
    Nobody cares (except customs) because what is inside is irrelevant. The only important
    thing is to know where to pick them and where to deliver them. It is a clear separation
    of concerns. We know how to handle them from outside while their content is known
    only to those who packed them in the first place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是容器？容器一词的定义是用于容纳或运输某物的物体。大多数人将容器与*集装箱*联系在一起。它们应具备足够的强度，以承受运输、存储和搬运。你可以看到它们通过各种方式进行运输，其中最常见的是通过船只。在大型船厂，你可以看到数百甚至数千个集装箱堆叠在一起，既横向排布，也纵向叠放。几乎所有的商品都是通过集装箱运输的，这是有原因的。它们是标准化的，易于堆叠且不易损坏。大多数参与运输的人并不知道集装箱里装的是什么。没有人关心（除了海关），因为里面的内容并不重要。唯一重要的是知道在哪儿取货，在哪里交货。这是一个明确的关注点分离。我们知道如何从外部处理它们，而里面的内容只有最初打包的人知道。
- en: The idea behind "software" containers is similar. They are *isolated* and *immutable*
    images that provide designed functionality in most cases accessible only through
    their APIs. They are a solution to make our software run reliably and on (almost)
    any environment. No matter where they are running (developer's laptop, testing
    or production server, data center, and so on), the result should always be the
    same. Finally, we can avoid conversations like the following.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “软件”容器背后的理念是相似的。它们是*隔离*和*不可变*的镜像，提供设计好的功能，在大多数情况下只能通过其API进行访问。它们是让我们的软件在（几乎）任何环境中可靠运行的解决方案。无论它们运行在哪里（开发者的笔记本电脑、测试或生产服务器、数据中心等），结果应该始终是相同的。最后，我们可以避免如下对话。
- en: 'QA: There is a problem with the login screen.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: QA：登录屏幕存在问题。
- en: 'Developer: It works on my computer!'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者：在我的电脑上可以正常工作！
- en: The reason such a conversation is obsolete with containers is that they behave
    in the same way no matter the environment they're running on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使这种对话变得过时的原因是，无论它们运行在何种环境中，容器的行为都是一样的。
- en: The way for containers to accomplish this feat is through *self-sufficiency*
    and *immutability*. Traditional deployments would put an artifact into an existing
    node expecting that everything else is in place; the application server, configuration
    files, dependencies, and so on. Containers, on the other hand, contain everything
    our software needs. The result is a set of images stacked into a container that
    contains everything from binaries, application server and configurations all the
    way down to runtime dependencies and OS packages. This description leads to the
    question about differences between a container and a VM. After all, all that we
    described by now is equally valid for both.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 容器实现这一壮举的方式是通过*自给自足*和*不可变性*。传统的部署方法会将一个工件放入现有的节点，期待其他所有东西都已就绪；例如应用服务器、配置文件、依赖项等等。而容器则包含了我们软件所需的一切。其结果是，一组镜像堆叠成一个容器，包含从二进制文件、应用服务器和配置到运行时依赖和操作系统包的所有内容。这一描述引出了容器与虚拟机之间的差异问题。毕竟，到目前为止，我们所描述的内容对两者来说都是有效的。
- en: 'For example, a physical server running five virtual machines would have five
    operating systems in addition to a *hypervisor* that is more resource demanding
    than *lxc*. Five containers, on the other hand, share the operating system of
    the physical server and, where appropriate, binaries and libraries. As a result,
    containers are much more lightweight than VMs. With monolithic applications this
    is not so big of a difference, especially in cases when a single one would occupy
    the whole server. With microservices however, this gain in resource utilization
    is critical considering that we might have tens or hundreds of them on a single
    physical server. Put in other words, a single physical server can host more containers
    than virtual machines:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一台物理服务器运行五个虚拟机时，除了*虚拟化管理程序*外，还需要五个操作系统，而虚拟化管理程序比*lxc*更占用资源。另一方面，五个容器共享物理服务器的操作系统，并在适当时共享二进制文件和库。因此，容器比虚拟机轻量得多。对于单体应用来说，这种差别不大，特别是当单个应用就占据整个服务器时。然而对于微服务来说，考虑到可能在单台物理服务器上有数十个甚至数百个容器，这种资源利用上的优势至关重要。换句话说，一台物理服务器可以托管更多的容器，而非虚拟机：
- en: '![Containers](img/B05848_02_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![容器](img/B05848_02_08.jpg)'
- en: Figure 2-8 – Virtual machines and containers resources utilization comparison
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-8 —— 虚拟机与容器资源利用比较
- en: The Three Musketeers – Synergy of Continuous Deployment, Microservices, and
    Containers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三剑客——持续部署、微服务与容器的协同作用
- en: Continuous deployment, microservices, and containers are a match made in heaven.
    They are like the three musketeers, each capable of great deeds but when joined,
    capable of so much more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署、微服务和容器是天作之合。它们就像三剑客，每个都能做出伟大的成就，但当它们联合在一起时，能做到更多。
- en: With continuous deployment, we can provide continuous and automatic feedback
    of our applications readiness and deployment to production, thus increasing the
    quality of what we deliver and decreasing the time to reach the market.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续部署，我们可以提供持续的、自动的反馈，告知应用的准备情况以及部署到生产环境的状态，从而提高交付质量并减少到达市场的时间。
- en: Microservices provide us with more freedom to make better decisions, faster
    development and, as we'll see very soon, easier scaling of our services.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务为我们提供了更多的自由，使我们能够做出更好的决策，加快开发进度，并且，正如我们很快将看到的那样，更容易扩展我们的服务。
- en: Finally, containers provide the solution to many of deployment problems; in
    general and especially when working with microservices. They also increase reliability
    due to their immutability.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，容器为许多部署问题提供了解决方案；一般来说，特别是在处理微服务时，它们也提高了可靠性，因为它们是不可变的。
- en: Together, they can combine all that and do so much more. Throughout this book,
    we'll be on a quest to deploy often and fast, be fully automatic, accomplish zero-downtime,
    have the ability to rollback, provide constant reliability across environments,
    be able to scale effortlessly, and create self-healing systems able to recuperate
    from failures. Any of those goals is worth a lot. Can we accomplish all of them?
    Yes! Practices and tools we have at our disposal can provide all that, and we
    just need to combine them correctly. The journey ahead is long but exciting. There
    are a lot of things to cover and explore and we need to start from the beginning;
    we'll discuss the architecture of the system we are about to start building.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以将所有这些结合起来，并做更多的事情。在本书中，我们将以快速和频繁部署为目标，完全自动化，实现零停机时间，具备回滚能力，提供跨环境的一致性可靠性，能够轻松扩展，并创建能够从故障中恢复的自愈系统。这些目标中的任何一个都非常有价值。我们能否实现所有这些目标？可以！我们手头的实践和工具可以提供这一切，我们只需要正确地将它们结合起来。前方的旅程漫长而充满激情。有很多内容需要涵盖和探索，我们需要从头开始；接下来我们将讨论我们即将开始构建的系统架构。
- en: '|   | *Knowing is not enough; we must apply. Willing is not enough; we must
    do.* |   |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|   | *知道还不够；我们必须应用。愿意还不够；我们必须行动。* |   |'
- en: '|   | --*Johann Wolfgang von Goethe* |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|   | --**约翰·沃尔夫冈·冯·歌德** |'
