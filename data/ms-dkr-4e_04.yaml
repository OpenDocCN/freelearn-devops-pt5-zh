- en: '*Chapter 4*'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 4 章*'
- en: Managing Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器
- en: So far, we have been concentrating on how to build, store, and distribute our
    Docker images. Now we are going to look at how we can launch containers, and also
    how we can use the Docker command-line client to manage and interact with them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在关注如何构建、存储和分发 Docker 镜像。现在，我们将看看如何启动容器，以及如何使用 Docker 命令行客户端来管理和与其交互。
- en: We will be revisiting the commands we used in [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, by going into a lot more detail, before delving deeper into
    the commands that are available. Once we are familiar with the container commands,
    we will look at Docker networks and Docker volumes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 1 章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)《Docker 概述》中使用的命令上，进行更多的细节讲解，然后深入了解可用的其他命令。一旦我们熟悉了容器命令，就会进一步探讨
    Docker 网络和 Docker 卷。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Docker container commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 容器命令
- en: Docker networking and volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 网络和卷
- en: Docker Desktop Dashboard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop 仪表盘
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will continue to use our local Docker installation. The
    screenshots in this chapter will be from my preferred operating system, macOS,
    but the Docker commands we will be running will work on all three of the operating
    systems on which we have installed Docker so far; however, some of the supporting
    commands, which will be few and far between, may only be applicable to macOS-
    and Linux-based operating systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用本地的 Docker 安装。本章中的截图将来自我偏好的操作系统 macOS，但我们将运行的 Docker 命令将在我们迄今已安装
    Docker 的三种操作系统上都能运行；不过，一些辅助命令（虽然极少）可能仅适用于基于 macOS 和 Linux 的操作系统。
- en: Check out the following video to see the Code in Action:[https://bit.ly/3m1Wtk4](https://bit.ly/3m1Wtk4)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码演示：[https://bit.ly/3m1Wtk4](https://bit.ly/3m1Wtk4)
- en: Understanding Docker container commands
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Docker 容器命令
- en: Before we dive into the more complex Docker commands, let's review and go into
    a little more detail on the commands we have used in previous chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入学习更复杂的 Docker 命令之前，让我们回顾一下并更详细地了解我们在前几章中使用的命令。
- en: The basics
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'In [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046), *Docker Overview*,
    we launched the most basic container of all, the `hello-world` container, using
    the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)，《Docker 概述》中，我们启动了最基本的容器——`hello-world`容器，使用以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you may recall, this command pulls a `1.84` KB image from the Docker Hub.
    You can find the Docker Hub page for the image at [https://hub.docker.com/images/hello-world/](https://hub.docker.com/images/hello-world/),
    and, as per the following `Dockerfile`, it runs an executable called `hello:`
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，这个命令从 Docker Hub 拉取了一个`1.84` KB的镜像。你可以在[https://hub.docker.com/images/hello-world/](https://hub.docker.com/images/hello-world/)找到该镜像的
    Docker Hub 页面，正如以下`Dockerfile`所示，它运行一个名为`hello`的可执行文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `hello` executable prints the `Hello from Docker!` text to the Terminal,
    and then the process exits. As you can see from the full message text in the following
    Terminal output, the `hello` binary also lets you know exactly what steps have
    just occurred:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello`可执行文件将`Hello from Docker!`文本打印到终端，然后进程退出。正如从以下终端输出的完整信息中可以看到的，`hello`二进制文件还会准确告诉你刚刚发生了哪些步骤：'
- en: '![Figure 4.1 – Running hello-world'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 运行 hello-world'
- en: '](img/Figure_4.01_B15659.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.01_B15659.jpg)'
- en: Figure 4.1 – Running hello-world
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 运行 hello-world
- en: 'As the process exits, our container also stops. This can be seen by running
    the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程退出时，我们的容器也会停止。可以通过运行以下命令来查看：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Figure 4.2 – Listing our containers'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 列出我们的容器'
- en: '](img/Figure_4.02_B15659.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B15659.jpg)'
- en: Figure 4.2 – Listing our containers
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 列出我们的容器
- en: You may notice in the Terminal output that I first ran `docker container ls`
    with and without the `-a` flag. This is shorthand for `--all`, as running it without
    the flag does not show any exited containers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在终端输出中，我首先运行了带有和不带`-a`标志的`docker container ls`命令。`-a`是`--all`的简写，因为不带此标志运行时不会显示任何已退出的容器。
- en: You may have noticed that we didn't have to name our container. This is because
    it wasn't going to be around long enough for us to care what it was called. Docker
    automatically assigns names for containers, though, and in my case, you can see
    that it was called `awesome_jackson`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们不需要给容器命名。这是因为它不会存在得足够长，让我们在意它叫什么。不过，Docker会自动为容器分配名称，在我的情况下，你可以看到它被命名为`awesome_jackson`。
- en: 'You will notice throughout your use of Docker that it comes up with some really
    interesting names for your containers if you choose to let it generate them for
    you. It created the name from a wordlist for the left-hand word, and for the right-hand
    word, from the names of notable scientists and hackers. Although this is slightly
    off topic, the code to generate the names can be found in `names-generator.go`.
    Right at the end of the source code, it has the following `if` statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Docker时，你会注意到，如果你选择让它为容器自动生成名称，它会为你起一些非常有趣的名字。它为左边的词从一个单词列表中选取，而右边的词则来自著名科学家和黑客的名字。虽然这有点偏题，但生成这些名称的代码可以在`names-generator.go`中找到。在源代码的最后，它有如下的`if`语句：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means there will never be a container called boring_wozniak (and quite
    rightly, too).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着永远不会有一个名为boring_wozniak的容器（而且这也完全合理）。
- en: 'Information:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：
- en: Steve Wozniak is an inventor, electronics engineer, programmer, and entrepreneur
    who co-founded Apple Inc. with Steve Jobs. He is known as a pioneer of the personal
    computer revolution of the 70s and 80s, and is definitely not boring!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫·沃兹尼亚克（Steve Wozniak）是发明家、电子工程师、程序员和企业家，他与史蒂夫·乔布斯共同创办了苹果公司。他被誉为70年代和80年代个人计算机革命的先驱，绝对不无聊！
- en: 'We can remove the container with a status of `exited` by running the following
    command, making sure that you replace the name of the container with your own
    container name:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来删除一个状态为`exited`的容器，确保你将容器名称替换为你自己的容器名称：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, at the end of [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, we launched a container using the official NGINX image by using
    the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在[*第1章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)，“*Docker概述*”的结尾，我们通过以下命令使用官方的NGINX镜像启动了一个容器：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you may remember, this downloads the image and runs it, mapping port `8080`
    on our host machine to port `80` on the container, and calls it `nginx-test`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，这将下载镜像并运行它，将主机上的端口`8080`映射到容器中的端口`80`，并将其命名为`nginx-test`：
- en: '![Figure 4.3 – Running an NGINX container'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 运行一个NGINX容器'
- en: '](img/Figure_4.03_B15659.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.03_B15659.jpg)'
- en: Figure 4.3 – Running an NGINX container
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 运行一个NGINX容器
- en: 'As you can see, running the Docker image `ls` shows us that we now have two
    images downloaded and also running. The following command shows us that we have
    a running container:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，运行Docker镜像的`ls`命令显示我们现在有两个已下载并运行的镜像。以下命令向我们展示了一个正在运行的容器：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following Terminal output shows that mine had been up for 5 minutes when
    I ran the command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下终端输出显示，当我运行命令时，我的容器已经运行了5分钟：
- en: '![Figure 4.4 – Viewing the running containers'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 查看正在运行的容器'
- en: '](img/Figure_4.04_B15659.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.04_B15659.jpg)'
- en: Figure 4.4 – Viewing the running containers
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 查看正在运行的容器
- en: As you can see from our `docker container run` command, we introduced three
    flags. One of them was `-d`, which is shorthand for `--detach`. If we hadn't added
    this flag, then our container would have executed in the foreground, which means
    that our Terminal would have been frozen until we passed the process an escape
    command by pressing *Ctrl + C*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`docker container run`命令可以看出，我们引入了三个标志。其中一个是`-d`，它是`--detach`的简写。如果我们没有添加这个标志，容器将会在前台执行，这意味着我们的终端将会被锁住，直到我们按下*Ctrl
    + C*来发送中断命令。
- en: 'We can see this in action by running the following command to launch a second
    NGINX container to run alongside the container we have already launched:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来启动第二个NGINX容器，使其与我们已经启动的容器并行运行，从而看到其实际效果：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once launched, open a browser and enter `http://localhost:9090/`. As you load
    the page, you will notice that your page visit is printed to the screen. Hitting
    refresh in your browser will display more hits, until you press *Ctrl + C* back
    in the Terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，打开浏览器并输入`http://localhost:9090/`。当你加载页面时，你会注意到页面访问的记录会打印到屏幕上。在浏览器中点击刷新会显示更多的访问记录，直到你在终端中按下*Ctrl
    + C*：
- en: '![Figure 4.5 – Viewing the output of running the container in the foreground'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 查看容器在前台运行时的输出'
- en: '](img/Figure_4.05_B15659.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B15659.jpg)'
- en: Figure 4.5 – Viewing the output of running the container in the foreground
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 在前台运行容器时查看输出
- en: 'Running `docker container ls -a` shows that you have two containers, one of
    which has exited:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container ls -a`显示你有两个容器，其中一个已经退出：
- en: '![Figure 4.6 – Listing the running containers'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 列出正在运行的容器'
- en: '](img/Figure_4.06_B15659.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.06_B15659.jpg)'
- en: Figure 4.6 – Listing the running containers
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 列出正在运行的容器
- en: So, what happened? When we removed the `detach` flag, Docker connected us to
    the NGINX process directly within the container, meaning that we had visibility
    of **stdin**, **stdout**, and **stderr** for that process. When we used *Ctrl
    + C*, we actually sent an instruction to the NGINX process to terminate it. As
    that was the process that was keeping our container running, the container exited
    immediately once there was no longer a running process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么呢？当我们移除`detach`标志时，Docker直接将我们连接到容器中的NGINX进程，这意味着我们可以查看该进程的**stdin**、**stdout**和**stderr**。当我们按下*Ctrl
    + C*时，我们实际上是向NGINX进程发送了一个终止指令。由于该进程是保持容器运行的进程，一旦没有了正在运行的进程，容器也就立即退出了。
- en: Important note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Standard input** (**stdin**) is the handle that our process reads to get
    information from the end user. **Standard output** (**stdout**) is where the process
    writes normal information. **Standard error** (**stderr**) is where the process
    writes error messages.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准输入** (**stdin**) 是我们的进程读取以获取来自最终用户信息的句柄。**标准输出** (**stdout**) 是进程写入正常信息的地方。**标准错误**
    (**stderr**) 是进程写入错误信息的地方。'
- en: Another thing you may have noticed when we launched the `nginx-foreground` container
    is that we gave it a different name using the `--name` flag.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，在启动`nginx-foreground`容器时，我们使用`--name`标志给它起了一个不同的名字。
- en: 'This is because you cannot have two containers with the same name, since Docker
    gives you the option of interacting with your containers using both the `CONTAINER
    ID or NAME` values. This is the reason the name generator function exists: to
    assign a random name to containers you do not wish to name yourself, and also
    to ensure that we never call Steve Wozniak boring.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为不能有两个容器使用相同的名称，Docker提供了通过`CONTAINER ID 或 NAME`值与容器交互的选项。这就是名称生成器功能存在的原因：为你不想自己命名的容器分配一个随机名称，并且确保我们永远不会称Steve
    Wozniak为无聊。
- en: 'The final thing to mention is that when we launched `nginx-foreground`, we
    asked Docker to map port `9090` to port `80` on the container. This was because
    we cannot assign more than one process to a port on a host machine, so if we attempted
    to launch our second container with the same port as the first, we would have
    received an error message:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要提到的是，当我们启动`nginx-foreground`时，我们要求Docker将容器上的端口`9090`映射到主机的端口`80`。这是因为我们不能为主机上的一个端口分配多个进程，所以如果我们试图启动第二个容器并使用与第一个容器相同的端口，就会收到错误消息：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, since we are running the container in the foreground, you may receive
    an error from the NGINX process, as it failed to start:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们在前台运行容器，NGINX进程可能会因启动失败而返回错误。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, you may also notice that we are mapping to port `80` on the container
    – why no error there?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能还会注意到我们正在将端口`80`映射到容器上——为什么没有错误呢？
- en: Well, as explained in [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, the containers themselves are isolated resources, which means
    that we can launch as many containers as we like with port `80` remapped, and
    they will never clash with other containers; we only run into problems when we
    want to route to the exposed container port from our Docker host.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[*第1章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)中解释的那样，*Docker概述*，容器本身是隔离的资源，这意味着我们可以启动任意数量的容器并重新映射端口`80`，它们之间不会发生冲突；只有当我们希望从Docker主机路由到暴露的容器端口时，才会遇到问题。
- en: Let's keep our NGINX container running for the next section, where we will explore
    more ways of interacting with the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让NGINX容器继续运行，直到下一个章节，我们将探索更多与容器交互的方法。
- en: Interacting with your containers
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与容器交互
- en: 'So far, our containers have been running a single process. Docker provides
    you with a few tools that enable you to both fork additional processes and interact
    with them, and we will be covering those tools in the following sections:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的容器只运行了一个进程。Docker为你提供了一些工具，能够让你既能分叉更多的进程，又能与它们进行交互，我们将在接下来的章节中介绍这些工具：
- en: attach
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: attach
- en: 'The first way of interacting with your running container is to attach to the
    running process. We still have our `nginx-test` container running, so let''s connect
    to that by running this command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与正在运行的容器交互的第一种方式是附加到运行中的进程。我们仍然有`nginx-test`容器在运行，因此我们可以通过运行以下命令来连接到它：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Opening your browser and going to `http://localhost:8080/` will print the NGINX
    access logs to the screen, just like when we launched the `nginx-foreground` container.
    Pressing *Ctrl + C* will terminate the process and return your Terminal to normal.
    However, as before, we would have terminated the process that was keeping the
    container running:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`http://localhost:8080/`将会打印 NGINX 访问日志到屏幕上，就像我们启动`nginx-foreground`容器时一样。按下*Ctrl
    + C*将终止进程并将终端恢复到正常状态。然而，和之前一样，我们会终止保持容器运行的进程：
- en: '![Figure 4.7 – Attaching to our container'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 附加到我们的容器'
- en: '](img/Figure_4.07_B15659.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.07_B15659.jpg)'
- en: Figure 4.7 – Attaching to our container
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 附加到我们的容器
- en: 'We can start our container back up by running the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令重新启动我们的容器：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will start the container back up in the detached state, meaning that it
    is running in the background again, as this was the state that the container was
    originally launched in. Going to `http://localhost:8080/` will show you the NGINX
    welcome page again.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使容器重新启动为分离模式，意味着它再次在后台运行，因为这是容器最初启动时的状态。访问`http://localhost:8080/`将再次显示 NGINX
    欢迎页面。
- en: 'Let''s reattach to our process, but this time with an additional option:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新附加到我们的进程，但这次添加一个额外的选项：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Hitting the container''s URL a few times and then pressing *Ctrl + C* will
    detach us from the NGINX process, but this time, rather than terminating the NGINX
    process, it will just return us to our Terminal, leaving the container in a detached
    state that can be seen by running docker container ls:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 多次访问容器的 URL 然后按下*Ctrl + C*将使我们与 NGINX 进程断开连接，但这次，不是终止 NGINX 进程，而是将我们返回到终端，容器保持在分离状态，通过运行
    docker container ls 可以查看：
- en: '![Figure 4.8 – Disconnecting from our container'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 从容器断开连接'
- en: '](img/Figure_4.08_B15659.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08_B15659.jpg)'
- en: Figure 4.8 – Disconnecting from our container
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 从容器断开连接
- en: This is a great way of quickly attaching to a running container to debug issues
    while keeping the container's main process up and running.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是快速附加到运行中的容器以调试问题，同时保持容器主进程运行的好方法。
- en: exec
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exec
- en: The `attach` command is useful if you need to connect to the process your container
    is running, but what if you need something that is a little more interactive?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`命令如果你需要连接到容器正在运行的进程很有用，但如果你需要一些更具交互性的操作呢？'
- en: 'You can use the `exec` command. This spawns a second process within the container
    that you can interact with. For example, to see the contents of the `/etc/debian_version`
    file, we can run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`exec`命令。这会在容器内启动一个第二个进程，允许你与之交互。例如，要查看`/etc/debian_version`文件的内容，我们可以运行以下命令：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will spawn a second process, the `cat` command in this case, which prints
    the contents of `/etc/debianversion to stdout`. The second process will then terminate,
    leaving our container as it was before the `exec` command was executed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动第二个进程，在这种情况下是`cat`命令，它将`/etc/debianversion`的内容打印到标准输出（stdout）。第二个进程将终止，容器将恢复到执行`exec`命令之前的状态：
- en: '![Figure 4.9 – Executing a command against our container'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 对容器执行命令'
- en: '](img/Figure_4.09_B15659.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.09_B15659.jpg)'
- en: Figure 4.9 – Executing a command against our container
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 对容器执行命令
- en: 'We can take this one step further by running the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步执行此操作，运行以下命令：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time, we are forking a bash process and using the `-i` and `-t` flags to
    keep open console access to our container. The `-i` flag is shorthand for `--interactive`,
    which instructs Docker to keep `stdin` open so that we can send commands to the
    process. The `-t` flag is short for `–tty` and allocates a pseudo-TTY to the session.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将分叉一个 bash 进程，并使用`-i`和`-t`标志保持对容器的控制台访问。`-i`标志是`--interactive`的简写，它指示 Docker
    保持`stdin`打开，以便我们可以向进程发送命令。`-t`标志是`–tty`的简写，它为会话分配一个伪终端（pseudo-TTY）。
- en: Important note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Early user terminals connected to computers were called **teletypewriters**.
    While these devices are no longer used today, the acronym TTY has continued to
    be used to described text-only consoles in modern computing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 早期连接到计算机的用户终端被称为 **电传打字机**。虽然这些设备今天已不再使用，但缩写 TTY 仍然被用来描述现代计算中的仅文本控制台。
- en: 'What this means is that you will be able to interact with the container as
    if you had a remote Terminal session, like SSH:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以像使用 SSH 一样与容器进行交互，仿佛你拥有一个远程终端会话：
- en: '![Figure 4.10 – Opening an interactive session to our container'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 打开与容器的交互式会话'
- en: '](img/Figure_4.10_B15659.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B15659.jpg)'
- en: Figure 4.10 – Opening an interactive session to our container
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 打开与容器的交互式会话
- en: While this is extremely useful, as you can interact with the container as if
    it were a virtual machine, I do not recommend making any changes to your containers
    as they are running using the pseudo-TTY. It is more than likely that those changes
    will not persist and will be lost when your container is removed. We will go into
    the thinking behind this in more detail in [*Chapter 15*](B15659_15_Final_JM_ePub.xhtml#_idTextAnchor823),
    *Docker Workflows*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这非常有用，因为你可以像操作虚拟机一样与容器进行交互，但我不建议在使用伪 TTY 时对容器进行任何更改。很可能这些更改不会持久化，并且在容器被删除时会丢失。我们将在
    [*第 15 章*](B15659_15_Final_JM_ePub.xhtml#_idTextAnchor823)，《*Docker 工作流*》中更详细地讨论这一点。
- en: Now that we have covered the various methods you can connect to and interact
    with your containers, we are going to look at some of the tools provided by Docker
    that mean you shouldn't have to.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何连接和与容器交互的各种方法，接下来我们将了解 Docker 提供的一些工具，这些工具可以让你不必手动执行这些操作。
- en: Logs and process information
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和进程信息
- en: So far, we have been attaching to either the process in our container, or to
    the container itself, in order to view information. Docker provides the commands
    that we are going to cover in this section that allow you to view information
    about your containers without having to use either the `attach` or `exec` commands.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在连接到容器中的进程或容器本身，以查看信息。Docker 提供了我们将在本节中介绍的命令，这些命令允许你在不使用 `attach`
    或 `exec` 命令的情况下查看容器的信息。
- en: Let's start by looking at how you c view the output being generated by the process
    within the container without having to run it in the foreground.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来看一下如何在不需要将其置于前台运行的情况下，查看容器内进程生成的输出。
- en: logs
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: 'The `logs` command is pretty self-explanatory. It allows you to interact with
    the `stdout` stream of your containers, which Docker is keeping track of in the
    background. For example, to view the last entries written to `stdout` for our
    `nginx-test` container, you just need to use the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`logs` 命令是相当直观的。它允许你与容器的 `stdout` 流进行交互，而 Docker 会在后台跟踪这些流。例如，要查看我们 `nginx-test`
    容器写入的最后几条 `stdout` 条目，只需使用以下命令：'
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the command is shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![Figure 4.11 – Tailing the logs'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 跟踪日志'
- en: '](img/Figure_4.11_B15659.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B15659.jpg)'
- en: Figure 4.11 – Tailing the logs
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 跟踪日志
- en: 'To view the logs in real time, I simply need to run the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要实时查看日志，我只需运行以下命令：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `-f` flag is shorthand for `--follow`. I can also, for example, view everything
    that has been logged since a certain time by running the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 标志是 `--follow` 的简写。例如，我还可以通过运行以下命令查看从某个时间点以来记录的所有内容：'
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the command is shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![Figure 4.12 – Checking the logs after a certain time'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 检查某个时间点之后的日志'
- en: '](img/Figure_4.12_B15659.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B15659.jpg)'
- en: Figure 4.12 – Checking the logs after a certain time
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 检查某个时间点之后的日志
- en: If you notice that the timestamp in the access log is different to that which
    you are searching for, that is due to the logs command that shows the timestamps
    of stdout as recorded by Docker, and not the time within the container. An example
    of this would be the hours' time difference between the host machine and the container
    due to **British Summer Time (BST)**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到访问日志中的时间戳与你搜索的时间不同，那是因为 `logs` 命令显示的是 Docker 记录的 `stdout` 时间戳，而不是容器内部的时间。一个例子是，由于
    **英国夏令时（BST）**，主机与容器之间可能存在数小时的时间差。
- en: 'Luckily, to save confusion, you can add `-t` to your `logs` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为了避免混淆，你可以在 `logs` 命令中添加 `-t` 参数：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `-t` flag is short for `--timestamp`; this option prepends the time the
    output was captured by Docker:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志是 `--timestamp` 的简写；此选项会在输出前添加 Docker 捕获时间：'
- en: '![Figure 4.13 – Viewing the logs and with the time the entry was logged'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 查看日志以及记录条目的时间'
- en: '](img/Figure_4.13_B15659.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B15659.jpg)'
- en: Figure 4.13 – Viewing the logs and with the time the entry was logged
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 查看日志以及记录条目的时间
- en: Now what we have looked at the ways we can view the output of the processes
    running in our containers, let's examine how we get more detail on the process
    itself.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经查看了如何查看容器中运行的进程的输出，我们来看看如何获得关于进程本身的更多细节。
- en: top
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: top
- en: 'The `top` command is quite a simple one; it lists the processes running within
    the container that you specify, and is used as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 命令是一个非常简单的命令；它列出了指定容器中正在运行的进程，使用方法如下：'
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the command is shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![Figure 4.14 – Running the top command'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 运行 top 命令'
- en: '](img/Figure_4.14_B15659.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B15659.jpg)'
- en: Figure 4.14 – Running the top command
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 运行 top 命令
- en: As you can see from the following Terminal output, we have two processes running,
    both of which are NGINX, which is to be expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，我们有两个进程在运行，都是 NGINX，这是预期的结果。
- en: stats
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stats
- en: 'The `stats` command provides real-time information on either the specified
    container or, if you don''t pass a `NAME` or `ID` container, on all running containers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats` 命令提供了关于指定容器的实时信息，或者如果没有传递 `NAME` 或 `ID` 参数，则提供所有正在运行的容器的信息：'
- en: '![Figure 4.15 – Viewing the real-time stats of a single container'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – 查看单个容器的实时统计信息'
- en: '](img/Figure_4.15_B15659.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B15659.jpg)'
- en: Figure 4.15 – Viewing the real-time stats of a single container
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 查看单个容器的实时统计信息
- en: 'As you can see from the following Terminal output, we are given information
    on `CPU`, `RAM`, `NETWORK`, `DISK IO`, and `PIDS` for the specified container:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，我们可以看到指定容器的 `CPU`、`RAM`、`NETWORK`、`DISK IO` 和 `PIDS` 信息：
- en: '![Figure 4.16 – Viewing the real-time stats of all running containers'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – 查看所有正在运行的容器的实时统计信息'
- en: '](img/Figure_4.16_B15659.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B15659.jpg)'
- en: Figure 4.16 – Viewing the real-time stats of all running containers
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 查看所有正在运行的容器的实时统计信息
- en: However, as you can see from the preceding output, if the container isn't running,
    there aren't any resources being utilized, so it doesn't really add any value,
    other than giving you a visual representation of how many containers you have
    running and where the resources are being used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你从前面的输出中看到的，如果容器没有运行，那么没有资源被使用，因此它除了提供容器数量和资源使用情况的可视化表示外，并不会提供太多价值。
- en: It is also worth pointing out that the information displayed by the `stats`
    command is real time only; Docker does not record the resource utilization and
    make it available in the same way that the `logs` command does. We will be looking
    at more long-term storage options for resource utilization in later chapters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同时值得指出的是，`stats` 命令显示的信息仅为实时数据；Docker 并不会像 `logs` 命令那样记录资源利用情况并进行存储。我们将在后续章节中探讨更多关于资源利用的长期存储选项。
- en: Resource limits
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源限制
- en: The `stats` command we ran showed us the resource utilization of our containers.
    By default, when launched, a container will be allowed to consume all the available
    resources on the host machine if it so requires. We can put limits on the resources
    our containers can consume. Let's start by updating the resource allowances of
    our nginx-test container.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的 `stats` 命令显示了容器的资源利用情况。默认情况下，当容器启动时，如果需要，它将被允许消耗主机上所有可用的资源。我们可以为容器消耗的资源设置限制。让我们从更新
    nginx-test 容器的资源限制开始。
- en: 'Typically, we would have set the limits when we launched our container using
    the `run` command; for example, to halve the CPU priority and set a memory limit
    of `128M`, we would have used the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们会在启动容器时使用 `run` 命令设置限制；例如，要将 CPU 优先级减半并设置 `128M` 的内存限制，我们可以使用以下命令：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, we didn''t launch our nginx-test container with any resource limits,
    meaning that we need to update our already running container. To do this, we can
    use the `update` command. Now, you may have thought that this should just entail
    running the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并没有为 nginx-test 容器启动时设置任何资源限制，这意味着我们需要更新已经运行的容器。为此，我们可以使用 `update` 命令。现在，你可能会认为这只是运行以下命令：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But actually, running the preceding command will produce an error:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，运行前述命令会导致错误：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, what is the `memoryswap` limit currently set to? To find this out, we can
    use the `inspect` command to display all of the configuration data for our running
    container; just run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`memoryswap`限制当前设置为何？为了找出这个信息，我们可以使用`inspect`命令来显示我们正在运行的容器的所有配置数据；只需运行以下命令：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you are following along, then you will see that running the preceding command,
    there is a lot of configuration data that will be displayed, too much to display
    here. When I ran the command, a `199` `line JSON` array was returned. Let''s use
    the `grep` command to filter out just the lines that contain the word `memory`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随操作，你会发现运行前述命令时，会显示大量的配置数据，这里无法显示所有内容。当我运行此命令时，返回了一个`199`行的`JSON`数组。我们可以使用`grep`命令仅过滤出包含`memory`的行：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This returns the following configuration data:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下配置数据：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Everything is set to `0`, so how can `128M` be smaller than 0?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置为`0`，那怎么`128M`会比0小呢？
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the context of the configuration of the resources, `0` is actually the default
    value and means that there are no limits. Notice the lack of `M` after each numerical
    value. This means that our `update` command should actually read as the preceding
    command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源配置的上下文中，`0`实际上是默认值，表示没有限制。请注意，每个数值后面没有`M`，这意味着我们的`update`命令应当按前述命令进行操作。
- en: Important note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '**Paging** is a memory management scheme in which the kernel stores and retrieves,
    or swaps, data from secondary storage for use in the main memory. This allows
    processes to exceed the size of physical memory available.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**分页**是一种内存管理方案，内核将数据从二级存储中存储和检索，或者交换到主内存中使用。这使得进程可以超出物理内存的大小。'
- en: 'By default, when you set `--memory` as part of the `run` command, Docker will
    set `--memory-swap size` to be twice that of `--memory`. If you run `docker container
    stats nginx-test` now, you should see our limits in place:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你在`run`命令中设置`--memory`时，Docker会将`--memory-swap size`设置为`--memory`的两倍。如果你现在运行`docker
    container stats nginx-test`，你应该会看到我们设置的限制：
- en: '![Figure 4.17 – Using stats to view the limits'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – 使用统计数据查看限制'
- en: '](img/Figure_4.17_B15659.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B15659.jpg)'
- en: Figure 4.17 – Using stats to view the limits
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 使用统计数据查看限制
- en: 'Also, re-running `docker container inspect nginx-test | grep -i memory` will
    show the changes as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重新运行`docker container inspect nginx-test | grep -i memory`将显示以下变化：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will notice that while we defined the values in MB, they are displayed here
    in bytes, so they are correct.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，虽然我们定义了以MB为单位的数值，但在这里它们以字节显示，所以是正确的。
- en: Tip
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The values when running `docker container inspect` are all shown in bytes rather
    than megabytes (MB).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container inspect`时显示的值是以字节为单位，而不是兆字节（MB）。
- en: Container states and miscellaneous commands
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器状态和杂项命令
- en: For the final part of this section, we are going to look at the various states
    your containers could be in, along with the few remaining commands we have yet
    to cover as part of the `docker container` command.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后部分，我们将查看容器可能的各种状态，以及我们尚未覆盖的`docker container`命令的一些剩余命令。
- en: 'Running `docker container ls -a` should show something similar to the following
    Terminal output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container ls -a`应该会显示类似以下的终端输出：
- en: '![Figure 4.18 – Listing all of the containers, including those that have exited'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – 列出所有容器，包括已退出的容器'
- en: '](img/Figure_4.18_B15659.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B15659.jpg)'
- en: Figure 4.18 – Listing all of the containers, including those that have exited
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 列出所有容器，包括已退出的容器
- en: 'As you can see, we have two containers; one has the status of `Up` and the
    other has `Exited`. Before we continue, let''s launch five more containers. To
    do this quickly, run the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有两个容器，一个状态为`Up`，另一个为`Exited`。在继续之前，让我们再启动五个容器。要快速完成此操作，运行以下命令：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see something like the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下类似的输出：
- en: '![Figure 4.19 – Launching five containers quickly'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – 快速启动五个容器'
- en: '](img/Figure_4.19_B15659.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B15659.jpg)'
- en: Figure 4.19 – Launching five containers quickly
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 快速启动五个容器
- en: 'When running `docker container ls -a`, you should see your five new containers,
    named `nginx1` through to `nginx5`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`docker container ls -a`时，你应该会看到五个新容器，命名为`nginx1`至`nginx5`：
- en: '![Figure 4.20 – Viewing our five new containers'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 – 查看我们的五个新容器'
- en: '](img/Figure_4.20_B15659.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B15659.jpg)'
- en: Figure 4.20 – Viewing our five new containers
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 查看我们的五个新容器
- en: Now that we have the additional containers up and running, let's look at how
    we can their states.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启动了额外的容器，让我们来看看如何查看它们的状态。
- en: pause and unpause
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂停和恢复
- en: 'Let''s look at pausing `nginx1`. To do this, simply run the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何暂停 `nginx1`。只需运行以下命令：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running `docker container ls` will show that the container has a status of
    `Up`, but it also says `Paused`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker container ls` 会显示容器的状态为 `Up`，但也会显示为 `Paused`：
- en: '![Figure 4.21 – Pausing a container'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.21 – 暂停容器'
- en: '](img/Figure_4.21_B15659.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B15659.jpg)'
- en: Figure 4.21 – Pausing a container
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 暂停容器
- en: Note that we didn't have to use the `-a` flag to see information about the container
    as the process has not been terminated; instead, it has been suspended using the
    `cgroups` freezer. With the `cgroups` freezer, the process is unaware it has been
    suspended, meaning that it can be resumed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无需使用 `-a` 标志来查看容器的信息，因为该进程尚未终止；相反，它是通过 `cgroups` 冷冻机制被挂起的。使用 `cgroups`
    冷冻机制时，进程并不知道它已被挂起，这意味着它可以被恢复。
- en: 'As you will have probably already guessed, you can resume a paused container
    using the `unpause` command, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，你可以使用 `unpause` 命令恢复暂停的容器，命令如下：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command is useful if you need to freeze the state of a container; for example,
    maybe one of your containers is going haywire and you need to do some investigation
    later, but don't want it to have a negative impact on your other running containers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令很有用，特别是当你需要冻结一个容器的状态时；例如，可能有一个容器出现异常，你需要稍后进行调查，但又不希望它对其他运行中的容器造成负面影响。
- en: Now, let's look at how you can properly stop and remove containers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何正确地停止和删除容器。
- en: stop, start, restart, and kill
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止、启动、重启和终止
- en: Next up, we have the `stop`, `start`, `restart`, and `kill` commands. We have
    already used the `start` command to resume a container with a status of `Exited`.
    The `stop` command works exactly the same way as when we used *Ctrl + C* to detach
    from your container running in the foreground.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 `stop`、`start`、`restart` 和 `kill` 命令。我们已经使用过 `start` 命令来恢复一个状态为 `Exited`
    的容器。`stop` 命令的工作方式与我们之前使用 *Ctrl + C* 从前台分离容器的方式完全相同。
- en: 'Run the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this, a request is sent to the process for it to terminate, called `SIGTERM`.
    If the process has not terminated itself within a grace period, then a kill signal,
    called `SIGKILL`, is sent. This will immediately terminate the process, not giving
    it any time to finish whatever is causing the delay; for example, committing the
    results of a database query to disk.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此操作，向进程发送终止请求，称为 `SIGTERM`。如果进程在宽限期内未自行终止，则会发送一个终止信号，称为 `SIGKILL`。这将立即终止进程，不给它任何时间完成可能导致延迟的操作；例如，将数据库查询结果提交到磁盘。
- en: 'Because this could be bad, Docker gives you the option of overriding the default
    grace period, which is 10 seconds, by using the `-t` flag; this is short for `--time`.
    For example, running the following command will wait up to 60 seconds before sending
    a `SIGKILL` command, in the event that it needs to be sent to kill the process:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能导致问题，Docker 允许你通过使用 `-t` 标志来覆盖默认的宽限期（10秒）；这代表 `--time`。例如，运行以下命令将在发送 `SIGKILL`
    命令之前等待最多 60 秒，万一需要终止进程：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `start` command, as we have already seen, will start the process back up;
    however, unlike the `pause` and `unpause` commands, the process, in this case,
    starts from scratch using the flags that originally launched it, rather than starting
    from where it left off:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`start` 命令会重新启动进程；然而，与 `pause` 和 `unpause` 命令不同，进程在这种情况下会从头开始，使用最初启动它时的标志，而不是从暂停的位置继续：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `restart` command is a combination of the following two commands; it stops
    and then starts the `ID` or `NAME` container you pass it. Also, as with `stop`,
    you can pass the `-t` flag:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart` 命令是以下两个命令的组合；它先停止然后启动你传递给它的 `ID` 或 `NAME` 容器。此外，和 `stop` 命令一样，你可以使用
    `-t` 标志：'
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, you also have the option of sending a `SIGKILL` command immediately
    to the container by running the `kill` command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以选择通过运行 `kill` 命令立即向容器发送 `SIGKILL` 命令：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is one more thing need to cover, and that is removing the containers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要讲解，那就是删除容器。
- en: Removing containers
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'Let''s check the status of containers we have been using by the `docker container
    ls -a` command. When I run the command, I can see that I have two containers with
    an `Exited` status and all of the others are running:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`docker container ls -a`命令检查我们使用过的容器的状态。当我运行该命令时，我看到有两个容器的状态为`Exited`，其他的都在运行中：
- en: '![Figure 4.22 – Viewing the state of all of our containers'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.22 – 查看所有容器的状态'
- en: '](img/Figure_4.22_B15659.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B15659.jpg)'
- en: Figure 4.22 – Viewing the state of all of our containers
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.22 – 查看所有容器的状态
- en: 'To remove the two exited containers, I can simply run the `prune` command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除这两个已退出的容器，我可以简单地运行`prune`命令：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When doing so, a warning pops up asking you to confirm whether you are really
    sure, as seen in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，会弹出一个警告，询问你是否确定，如下图所示：
- en: '![Figure 4.23 – Pruning the containers'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.23 – 修剪容器'
- en: '](img/Figure_4.23_B15659.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B15659.jpg)'
- en: Figure 4.23 – Pruning the containers
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.23 – 修剪容器
- en: 'You can choose which container you want to remove using the `rm` command, an
    example of which is shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`rm`命令选择要删除的容器，下面是一个示例：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another alternative would be to string the `stop` and `rm` commands together:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将`stop`和`rm`命令连接在一起：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, given that you can use the `prune` command now, this is probably way
    too much effort, especially as you are trying to remove the containers and probably
    don't care too much how gracefully the process is terminated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，鉴于现在可以使用`prune`命令，这可能是一个过于繁琐的过程，尤其是当你正在尝试删除容器并且可能不太关心该过程是如何优雅地终止时。
- en: Feel free to remove the remainder of your containers using whichever method
    you like.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用你喜欢的任何方法删除剩余的容器。
- en: Before we wrap up this section of the chapter, we are going to look at a few
    more useful commands that can't be really grouped together.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章这一部分之前，我们还将查看一些不能真正归类在一起的有用命令。
- en: Miscellaneous commands
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项命令
- en: 'For the final part of this section, we are going to look at a few commands
    that you probably won''t use too much during your day-to-day use of Docker. The
    first of these is `create`. The `create` command is pretty similar to the `run`
    command, except that it does not start the container, but instead prepares and
    configures one:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后部分，我们将查看一些你在日常使用Docker时可能不会过多使用的命令。第一个是`create`命令。`create`命令与`run`命令非常相似，区别在于它不会启动容器，而是准备和配置容器：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can check the status of your created container by running `docker container
    ls -a`, and then starting the container with `docker container start nginx-test`,
    before checking the status again:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`docker container ls -a`命令检查已创建容器的状态，然后使用`docker container start nginx-test`启动容器，再次检查状态：
- en: '![Figure 4.24 – Creating and then running a container'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.24 – 创建并运行容器'
- en: '](img/Figure_4.24_B15659.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B15659.jpg)'
- en: Figure 4.24 – Creating and then running a container
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.24 – 创建并运行容器
- en: 'The next command we are going to quickly look at is the `port` command; this
    displays the `port` number along with any port mappings for the container:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将快速查看`port`命令；该命令会显示容器的`port`号以及所有端口映射：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It should return the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下内容：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We already know this, as it is what we configured. Also, the ports are listed
    in the `docker container ls` output.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了这一点，因为这是我们所配置的内容。此外，端口会在`docker container ls`输出中列出。
- en: The next command we are going to look at quickly is the `diff` command. This
    command prints a list of all of the files that have been added (`A`) or changed
    (`C`) since the container was started – so basically, a list of the differences
    in the filesystem between the original image we used to launch the container and
    what files are present now.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将快速查看的命令是`diff`命令。这个命令列出自容器启动以来所有已添加（`A`）或已更改（`C`）的文件——基本上，这是一个列出原始镜像和当前容器文件系统之间差异的文件清单。
- en: 'Before we run the command, let''s create a blank file within the `nginx-test`
    container using the `exec` command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行命令之前，先使用`exec`命令在`nginx-test`容器内创建一个空白文件：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have a file called `testing` in `/tmp`, we can view the differences
    between the original image and the running container using the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`/tmp`目录下有一个名为`testing`的文件，我们可以使用以下命令查看原始镜像和正在运行的容器之间的差异：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will return a list of files. As you can see from the following list, our
    testing file is there, along with the files that were created when NGINX started:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个文件列表。从以下列表中可以看到，我们的测试文件已经在那里，同时还有 NGINX 启动时创建的文件：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is worth pointing out that once we stop and remove the container, these files
    will be lost. In the next section of this chapter, we will look at Docker volumes
    and learn how we can persist data. Before we move on though, let's get a copy
    of the file we just created using the `cp` command.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一旦我们停止并移除容器，这些文件将会丢失。在本章的下一节中，我们将学习 Docker 卷，并了解如何持久化数据。不过，在继续之前，让我们使用`cp`命令获取我们刚刚创建的文件的副本。
- en: 'To do this, we can run the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以运行以下命令：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see from the command, we are providing the container name followed
    by `:` and the full path to the file we want to copy. What follows is the local
    path. Here, you can see that we are simply calling the file `testing` and it will
    be copied to the current folder:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令可以看到，我们提供了容器名称，后面跟着 `:` 和我们想要复制的文件的完整路径。接下来是本地路径。在这里，你可以看到我们只是简单地将文件命名为`testing`，并且它将被复制到当前文件夹：
- en: '![Figure 4.25 – Copying a file to a container'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.25 – 将文件复制到容器](img/Figure_4.25_B15659.jpg)'
- en: '](img/Figure_4.25_B15659.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B15659.jpg)'
- en: Figure 4.25 – Copying a file to a container
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 将文件复制到容器
- en: 'As the file does not contain any data, lets add some and then copy it back
    to the container:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件中没有数据，让我们添加一些数据，然后将其复制回容器：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that in the second command, we are swapping the paths around. This time,
    we are providing the path of the local file and the container name and path:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第二个命令中，我们交换了路径的位置。这次，我们提供的是本地文件的路径以及容器名称和路径：
- en: '![Figure 4.26 – Copying a file with contents to the container'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.26 – 将文件及其内容复制到容器](img/Figure_4.26_B15659.jpg)'
- en: '](img/Figure_4.26_B15659.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B15659.jpg)'
- en: Figure 4.26 – Copying a file with contents to the container
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – 将文件及其内容复制到容器
- en: The other thing of note is that while we are overwriting an existing file, Docker
    did not warn us or give an option to back out of the command – it went ahead and
    overwrote the file immediately, so please be careful when using `docker container
    cp`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的地方是，尽管我们正在覆盖一个现有文件，但 Docker 并没有警告我们或提供回退的选项——它直接覆盖了该文件，因此在使用`docker
    container cp`时请小心。
- en: If you are following along, you should remove any running containers launched
    during this section using the command of your choice before moving on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在跟随操作，请在继续之前使用你选择的命令移除本节中启动的任何运行中的容器。
- en: Docker networking and volumes
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络与卷
- en: Next up, we are going to take a look at the basics of Docker networking and
    Docker volumes using the default drivers. Let's take a look at networking first.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用默认驱动程序来了解 Docker 网络和 Docker 卷的基础知识。首先，我们来看一下网络。
- en: Docker networking
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 网络
- en: So far, we have been launching our containers on a single flat shared network.
    Although we have not talked about it yet, this means the containers we have been
    launching would have been able to communicate with each other without having to
    use any of the host networking.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在一个单一的扁平共享网络上启动容器。虽然我们还没有讨论过这个问题，但这意味着我们启动的容器之间可以互相通信，而无需使用任何主机网络。
- en: Rather than going into detail now, let's work through an example. We are going
    to be running a two-container application; the first container will be running
    Redis, and the second, our application, which uses the Redis container to store
    a system state.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不打算详细讲解，而是通过一个示例来演示。我们将运行一个包含两个容器的应用程序；第一个容器运行 Redis，第二个容器运行我们的应用程序，它使用
    Redis 容器来存储系统状态。
- en: Important note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Redis is an in-memory data structure store that can be used as a database, cache,
    or message broker. It supports different levels of on-disk persistence.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个内存数据结构存储，可以用作数据库、缓存或消息代理。它支持不同级别的磁盘持久化。
- en: 'Before we launch our application, let''s download the container images we will
    be using, and also create the network:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，让我们先下载我们将使用的容器镜像，并创建网络：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see something similar to the following Terminal output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于以下的终端输出：
- en: '![Figure 4.27 – Pulling the images we need and creating the network'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.27 – 拉取我们需要的镜像并创建网络](img/Figure_4.27_B15659.jpg)'
- en: '](img/Figure_4.27_B15659.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B15659.jpg)'
- en: Figure 4.27 – Pulling the images we need and creating the network
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – 拉取我们需要的镜像并创建网络
- en: 'Now that we have our images pulled and our network created, we can launch our
    containers, starting with the Redis one:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拉取了镜像并创建了网络，可以启动我们的容器，从Redis容器开始：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, we used the `--network` flag to define the network that our
    container was launched in. Now that the Redis container is launched, we can launch
    the application container by running the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用`--network`标志来定义我们启动容器时使用的网络。现在Redis容器已经启动，我们可以通过运行以下命令启动应用程序容器：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Again, we launched the container on the `moby-counter` network. This time,
    we mapped port `8080` to port `80` on the container. Note that we did not need
    to worry about exposing any ports of the Redis container. That is because the
    Redis image comes with some defaults that expose the default port, which is `6379`
    for us. This can be seen by running `docker container ls`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我们在`moby-counter`网络上启动了容器。这一次，我们将端口`8080`映射到容器上的端口`80`。请注意，我们不需要担心暴露Redis容器的任何端口。这是因为Redis镜像自带一些默认设置，暴露了默认端口，对我们来说是`6379`。通过运行`docker
    container ls`可以看到这一点：
- en: '![Figure 4.28 – Listing the containers needed for our application'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.28 – 列出我们应用程序所需的容器'
- en: '](img/Figure_4.28_B15659.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.28_B15659.jpg)'
- en: Figure 4.28 – Listing the containers needed for our application
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – 列出我们应用程序所需的容器
- en: 'All that remains now is to access the application. To do this, open your browser
    and go to `http://localhost:8080/`. You should be greeted by a mostly blank page,
    with the message **Click to add logos…**:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是访问应用程序了。为此，请打开浏览器并访问`http://localhost:8080/`。你应该看到一个大致空白的页面，并显示**点击以添加徽标…**的消息：
- en: '![Figure 4.29 – Our application is ready to go'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 我们的应用程序已准备就绪'
- en: '](img/Figure_4.29_B15659.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.29_B15659.jpg)'
- en: Figure 4.29 – Our application is ready to go
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 我们的应用程序已准备就绪
- en: 'Clicking anywhere on the page will add Docker logos, so click away:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 点击页面上的任何地方都会添加Docker徽标，所以尽管点击：
- en: '![Figure 4.30 – Adding some logos to the page'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.30 – 向页面添加一些徽标'
- en: '](img/Figure_4.30_B15659.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B15659.jpg)'
- en: Figure 4.30 – Adding some logos to the page
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – 向页面添加一些徽标
- en: So, what is happening? The application that is being served from the `moby-counter`
    container is making a connection to the `redis` container, and using the service
    to store the onscreen coordinates of each of the logos that you place on the screen
    by clicking.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？来自`moby-counter`容器的应用程序正在连接到`redis`容器，并使用该服务来存储你通过点击屏幕上每个徽标的坐标。
- en: 'How is the `moby-counter` application connecting to the `redis` container?
    Well, in the `server.js` file, the following default values are being set:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`moby-counter`应用程序是如何连接到`redis`容器的？嗯，在`server.js`文件中，设置了以下默认值：'
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This means that the `moby-counter` application is looking to connect to a host
    called `redis` on port `6379`. Let''s try using the `exec` command to ping the
    `redis` container from the `moby-counter` application and see what we get:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`moby-counter`应用程序正在尝试连接到名为`redis`的主机，端口为`6379`。让我们尝试使用`exec`命令从`moby-counter`应用程序ping
    `redis`容器，看看会得到什么结果：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should see something similar to the following output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于以下输出的内容：
- en: '![Figure 4.31 – Pinging the redis container using the container name'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.31 – 使用容器名称ping Redis容器'
- en: '](img/Figure_4.31_B15659.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.31_B15659.jpg)'
- en: Figure 4.31 – Pinging the redis container using the container name
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – 使用容器名称ping Redis容器
- en: 'As you can see, the `moby-counter` container resolves `redis` to the IP address
    of the `redis` container, which is `172.18.0.2`. You may be thinking that the
    application''s host file contains an entry for the `redis` container; let''s take
    a look using the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`moby-counter`容器将`redis`解析为`redis`容器的IP地址，即`172.18.0.2`。你可能会想，应用程序的主机文件中是否包含了`redis`容器的条目；让我们通过以下命令来查看：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This returns the content of `/etc/hosts`, which, in my case, looks like the
    following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`/etc/hosts`的内容，在我的案例中，内容如下所示：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Other than the entry at the end, which is actually the IP address resolving
    to the hostname of the local container, `e7335ca1830d` is the ID of the container;
    there is no sign of an entry for `redis`. Next, let''s check `/etc/resolv.conf`
    by running the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 除了末尾的条目，它实际上是解析到本地容器主机名的IP地址，`e7335ca1830d`是容器的ID；没有找到`redis`的条目。接下来，让我们通过运行以下命令检查`/etc/resolv.conf`：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This returns what we are looking for. As you can see, we are using a local
    `nameserver`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了我们需要的内容。如你所见，我们正在使用一个本地的`nameserver`：
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s perform a DNS lookup on `redis` against `127.0.0.11` using the following
    command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `redis` 执行 DNS 查找，目标是 `127.0.0.11`，使用以下命令：
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This returns the IP address of the `redis` container:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `redis` 容器的 IP 地址：
- en: '[PRE57]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s create a second network and launch another application container:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个第二个网络并启动另一个应用程序容器：
- en: '[PRE58]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that we have the second application container up and running, let''s try
    pinging the `redis` container from it:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了第二个应用程序容器，让我们尝试从它向 `redis` 容器发送 ping 请求：
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In my case, I get the following error:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我遇到了以下错误：
- en: '![Figure 4.32 – Isolating our applications in different networks'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.32 – 在不同网络中隔离我们的应用程序'
- en: '](img/Figure_4.32_B15659.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.32_B15659.jpg)'
- en: Figure 4.32 – Isolating our applications in different networks
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – 在不同网络中隔离我们的应用程序
- en: 'Let''s check the `resolv.conf` file to see whether the same `nameserver` is
    being used already, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `resolv.conf` 文件，看看是否已经在使用相同的 `nameserver`，如下所示：
- en: '[PRE60]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see from the following output, the `nameserver` is indeed in use
    already:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出可以看出，`nameserver` 确实已经在使用：
- en: '[PRE61]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As we have launched the `moby-counter2` container in a different network to
    that where the container named `redis` is running, we cannot resolve the hostname
    of the container:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将 `moby-counter2` 容器启动在一个与 `redis` 容器所在的网络不同的网络中，因此我们无法解析容器的主机名：
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, it returns a bad address error:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它返回了一个错误地址：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Let's look at launching a second Redis server in our second network. As we have
    already discussed, we cannot have two containers with the same name, so let's
    creatively name it `redis2`. As our application is configured to connect to a
    container that resolves to `redis`, does this mean we will have to make changes
    to our application container? No, Docker has you covered.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何在第二个网络中启动第二个 Redis 服务器。正如我们之前讨论的，我们不能有两个相同名称的容器，因此我们可以创造性地命名它为`redis2`。由于我们的应用程序配置为连接到一个解析为`redis`的容器，这是否意味着我们需要对应用程序容器做出更改？不，Docker
    已经帮我们解决了这个问题。
- en: 'While you cannot have two containers with the same name, as we have already
    discovered, our second network is running completely isolated from our first network,
    meaning that we can still use the DNS name of `redis`. To do this, we need to
    add the `-network-alias` flag as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能有两个相同名称的容器，正如我们之前发现的那样，我们的第二个网络与第一个网络完全隔离，这意味着我们仍然可以使用 `redis` 的 DNS 名称。为了做到这一点，我们需要添加
    `-network-alias` 标志，如下所示：
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, we have named the container `redis2`, but set `--network-alias`
    to be `redis`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将容器命名为 `redis2`，但将 `--network-alias` 设置为 `redis`：
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This means that when we perform the lookup, we see the correct IP address returned:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们进行查找时，会看到返回正确的 IP 地址：
- en: '[PRE66]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, `redis` is actually an alias for `redis2.moby-counter2`, which
    then resolves to `172.19.0.3`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`redis` 实际上是 `redis2.moby-counter2` 的别名，随后解析为 `172.19.0.3`。
- en: 'Now we should have two applications running side by side in their own isolated
    networks on your local Docker host, accessible at `http://localhost:8080/` and
    `http://localhost:9090/`. Running `docker network ls` will display all of the
    networks configured on your Docker host, including the default networks:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该有两个应用程序在本地 Docker 主机上并排运行，分别在 `http://localhost:8080/` 和 `http://localhost:9090/`
    可访问。运行 `docker network ls` 将显示所有在 Docker 主机上配置的网络，包括默认网络：
- en: '![Figure 4.33 – Listing our networks'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.33 – 列出我们的网络'
- en: '](img/Figure_4.33_B15659.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.33_B15659.jpg)'
- en: Figure 4.33 – Listing our networks
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – 列出我们的网络
- en: 'You can find out more information about the configuration of the networks by
    running the following `inspect` command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下 `inspect` 命令来了解更多关于网络配置的信息：
- en: '[PRE67]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Running the preceding command returns the following JSON array. It starts by
    giving us some general information on the network:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令会返回以下 JSON 数组。它首先提供网络的一些一般信息：
- en: '[PRE68]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next up is the configuration used by the IP Address Management system. It shows
    the subnet range and gateway IP address:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 IP 地址管理系统使用的配置。它显示了子网范围和网关 IP 地址：
- en: '[PRE69]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'What follows next is the remainder of the general configuration:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是剩余的通用配置：
- en: '[PRE70]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we have details pertaining to the containers, which are attached to the
    network. This is where we can find the IP address and MAC address of each container:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获得了关于附加到网络的容器的详细信息。这里我们可以找到每个容器的 IP 地址和 MAC 地址：
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, we have the last bit of the configuration:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了配置的最后部分：
- en: '[PRE72]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, it contains information on the network address being used in
    the IPAM section, along with details on each of the two containers running in
    the network.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它包含了关于网络地址的信息，这些信息位于IPAM部分，以及关于在该网络中运行的两个容器的详细信息。
- en: Important note
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`IPAM` has both `DNS` and `DHCP` services, so each service is notified of changes
    in the other. For example, `DHCP` assigns an address to `container2`. The `DNS`
    service is then updated to return the IP address assigned by `DHCP` whenever a
    lookup is made against `container2`.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPAM`同时提供`DNS`和`DHCP`服务，因此每个服务都能通知对方的变化。例如，`DHCP`会为`container2`分配地址，随后`DNS`服务会更新，以便在对`container2`进行查找时返回`DHCP`分配的IP地址。'
- en: 'Before we progress to the next section, we should remove one of the applications
    and associated networks. To do this, run the following commands:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，我们应该删除其中一个应用程序及其关联的网络。要执行此操作，请运行以下命令：
- en: '[PRE73]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'These will remove the containers and network, as shown in the following screenshot:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作将删除容器和网络，如下图所示：
- en: '![Figure 4.34 – Removing unused networks with the prune command'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34 – 使用清理命令删除未使用的网络](img/Figure_4.34_B15659.jpg)'
- en: '](img/Figure_4.34_B15659.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.34_B15659.jpg)'
- en: Figure 4.34 – Removing unused networks with the prune command
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34 – 使用清理命令删除未使用的网络
- en: As mentioned at the start of this section, this is only the default network
    driver, meaning that we are restricted to our networks being available only on
    a single Docker host. In later chapters, we will look at how we can expand our
    Docker network across multiple hosts and even providers.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开始时提到的，这仅仅是默认的网络驱动程序，这意味着我们只能在单个Docker主机上使用网络。 在后面的章节中，我们将学习如何在多个主机甚至提供商之间扩展我们的Docker网络。
- en: Now that we know the basics around Docker networking, let's take a look at how
    we can work with additional storage for our containers.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Docker网络的基础知识，接下来让我们看看如何为容器提供额外的存储。
- en: Docker volumes
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker卷
- en: 'If you have been following along with the network example from the previous
    section, you should have two containers running, as shown in the following screenshot:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随了上一节的网络示例，你应该会看到两个容器正在运行，如下图所示：
- en: '![Figure 4.35 – Listing the running containers'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35 – 列出正在运行的容器](img/Figure_4.35_B15659.jpg)'
- en: '](img/Figure_4.35_B15659.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.35_B15659.jpg)'
- en: Figure 4.35 – Listing the running containers
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35 – 列出正在运行的容器
- en: 'When you go to the application in a browser (at `http://localhost:8080/`),
    you will probably see that there already are Docker logos on screen. Let''s stop
    and then remove the Redis container and see what happens. To do this, run the
    following commands:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中访问应用程序（`http://localhost:8080/`）时，你可能会看到屏幕上已经出现了Docker图标。让我们停止并删除Redis容器，然后看看会发生什么。为此，请运行以下命令：
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you have your browser open, you may notice that the Docker icons have faded
    into the background and there is an animated loader in the center of the screen.
    This is basically to show that the application is waiting for the connection to
    the Redis container to be re-established:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开了浏览器，你可能会注意到Docker图标已经渐隐到背景中，屏幕中央出现了一个动画加载器。这基本上表示应用程序正在等待与Redis容器的连接重新建立：
- en: '![Figure 4.36 – The application can no longer connect to Redis'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.36 – 应用程序无法再连接到Redis](img/Figure_4.36_B15659.jpg)'
- en: '](img/Figure_4.36_B15659.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.36_B15659.jpg)'
- en: Figure 4.36 – The application can no longer connect to Redis
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36 – 应用程序无法再连接到Redis
- en: 'Relaunch the Redis container using the following command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重新启动Redis容器：
- en: '[PRE75]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This restores connectivity. However, when you start to interact with the application,
    your previous icons disappear and you are left with a clean slate. Quickly add
    some more logos to the screen, this time placed in a different pattern, as I have
    done here:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这恢复了连接。然而，当你开始与应用程序交互时，之前的图标消失了，你将看到一个空白界面。快速地在屏幕上再添加一些图标，这次它们的位置与之前不同，就像我这里所做的那样：
- en: '![Figure 4.37 – Adding more logos'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.37 – 添加更多的logo](img/Figure_4.37_B15659.jpg)'
- en: '](img/Figure_4.37_B15659.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.37_B15659.jpg)'
- en: Figure 4.37 – Adding more logos
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37 – 添加更多的logo
- en: 'Once you have a pattern, let''s remove the Redis container again by running
    the following commands:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个模式，接下来我们再通过运行以下命令删除Redis容器：
- en: '[PRE76]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As we discussed earlier in the chapter, losing the data in the container is
    to be expected. However, as we used the official Redis image, we haven't, in fact,
    lost any of our data.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章之前讨论的，丢失容器中的数据是可以预期的。然而，由于我们使用的是官方的Redis镜像，实际上我们并没有丢失任何数据。
- en: 'The Dockerfile for the official Redis image that we used looks like the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的官方Redis镜像的Dockerfile如下所示：
- en: '[PRE77]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The preceding steps prepare the container by adding a group and user, installing
    a few packages, and setting some environment variables. The following steps install
    the prerequisites needed to run Redis:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤通过添加用户组、安装一些软件包并设置环境变量来准备容器。接下来的步骤安装运行Redis所需的先决条件：
- en: '[PRE78]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, the Redis source code is downloaded and copied to the right place on the
    image:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Redis的源代码已下载并复制到镜像中的正确位置：
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now that the source for Redis is in the image, the configuration is applied:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Redis的源代码已进入镜像，并应用了配置：
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, Redis is compiled and tested:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Redis已经编译并测试完成：
- en: '[PRE81]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `build` directory is then removed and the packages that are no longer needed
    are removed:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然后移除`build`目录，并删除不再需要的软件包：
- en: '[PRE82]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that Redis is built and the packages and build artifacts tided up, a final
    test is run. If it fails here, the build will also fail:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Redis已经构建，软件包和构建产物已整理好，进行最终测试。如果在这里失败，构建也会失败：
- en: '[PRE83]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'With everything installed, the final set of image configuration can take place:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内容安装完毕后，最后的镜像配置就可以进行：
- en: '[PRE84]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If you notice, during the last part of the file, there are the `VOLUME` and
    `WORKDIR` directives declared; this means that when our container was launched,
    Docker actually created a volume and then run `redis-server` from within the volume.
    We can see this by running the following command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，在文件的最后部分，声明了`VOLUME`和`WORKDIR`指令；这意味着，当我们的容器启动时，Docker实际上创建了一个卷，并从该卷中运行了`redis-server`。我们可以通过运行以下命令来验证：
- en: '[PRE85]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This should show at least two volumes, as seen in the following screenshot:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该至少显示两个卷，如下图所示：
- en: '![Figure 4.38 – Listing the volumes'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.38 – 列出卷'
- en: '](img/Figure_4.38_B15659.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.38_B15659.jpg)'
- en: Figure 4.38 – Listing the volumes
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.38 – 列出卷
- en: As you can see, the volume name is not very friendly at all. In fact, it is
    the unique ID of the volume. So how can we use the volume when we launch our Redis
    container? We know from the Dockerfile that the volume was mounted at `/data`
    within the container, so all we have to do is tell Docker which volume to use
    and where it should be mounted at runtime.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，卷的名称并不友好。实际上，它是卷的唯一ID。那么，我们如何在启动Redis容器时使用该卷呢？从Dockerfile中我们知道，卷被挂载到了容器内的`/data`路径，所以我们只需要告诉Docker在运行时使用哪个卷，并将其挂载到指定位置。
- en: 'To do this, run the following command, making sure you replace the volume ID
    with that of your own:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，运行以下命令，确保用你自己的卷ID替换：
- en: '[PRE86]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If your application page looks like it is still trying to reconnect to the Redis
    container once you have launched your Redis container, then you may need to refresh
    your browser. Failing that, restarting the application container by running `docker
    container restart moby-counter` and then refreshing your browser again should
    work.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启动Redis容器后，你的应用页面仍然显示它正在尝试重新连接到Redis容器，你可能需要刷新浏览器。如果不行，可以通过运行`docker container
    restart moby-counter`重启应用容器，再刷新浏览器应该能解决问题。
- en: 'You can view the contents of the volume by running the following command to
    attach the container and list the files in `/data`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令查看卷的内容，附加到容器并列出`/data`中的文件：
- en: '[PRE87]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This will return something that looks like the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似如下的内容：
- en: '[PRE88]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can also remove your running container and relaunch it, but this time using
    the ID of the second volume. As you can see from the application in your browser,
    the two different patterns you originally created are intact.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以移除正在运行的容器并重新启动它，不过这次使用第二个卷的ID。正如你从浏览器中的应用程序所看到的，最初创建的两种不同模式仍然完好无损。
- en: 'Let''s remove the `Redis` container again:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次移除`Redis`容器：
- en: '[PRE89]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, you can override the volume with your own. To create a volume, we
    need to use the `volume` command:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以用你自己的卷来覆盖默认的卷。要创建卷，我们需要使用`volume`命令：
- en: '[PRE90]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once created, we will be able to use the `redis_data` volume to store our `Redis`
    by running the following command after removing the `redis` container, which is
    probably already running:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，我们将能够使用`redis_data`卷来存储我们的`Redis`，方法是移除当前正在运行的`redis`容器后运行以下命令：
- en: '[PRE91]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can then reuse the volume as needed. The following screen shows the volume
    being created, attached to a container that is then removed and finally reattached
    to a new container:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以根据需要重新使用该卷。以下屏幕展示了卷的创建，附加到容器，然后容器被移除，最后重新附加到一个新容器：
- en: '![Figure 4.39 – Creating a volume and attaching it to a container'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.39 – 创建卷并将其附加到容器](img/Figure_4.39_B15659.jpg)'
- en: '](img/Figure_4.39_B15659.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.39_B15659.jpg)'
- en: Figure 4.39 – Creating a volume and attaching it to a container
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.39 – 创建卷并将其附加到容器
- en: 'Like the `network` command, we can view more information on the volume using
    the `inspect` command, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `network` 命令，我们可以使用 `inspect` 命令查看更多关于卷的信息，如下所示：
- en: '[PRE92]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding command will produce something like the following output:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将产生如下输出：
- en: '[PRE93]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can see that there is not much to a volume when using the local driver.
    One interesting thing to note is that the path to where the data is stored on
    the Docker host machine is `/var/lib/docker/volumes/redis_data/_data`. If you
    are using Docker for Mac or Docker for Windows, then this path will be your Docker
    host virtual machine, and not your local machine, meaning that you do not have
    direct access to the data inside the volume.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地驱动程序时，您会发现卷的体积并不大。值得注意的一点是，数据存储在 Docker 主机上的路径是`/var/lib/docker/volumes/redis_data/_data`。如果您使用的是
    Docker for Mac 或 Docker for Windows，那么这个路径将指向您的 Docker 主机虚拟机，而不是您的本地机器，意味着您无法直接访问卷内的数据。
- en: Don't worry though; we will be looking at Docker volumes and how you can interact
    with data in later chapters. Before we tidy up our containers, networks, and volume,
    if you are running Docker Desktop, then we should take a look at the Docker Desktop
    Dashboard.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心；我们将在后续章节中讨论 Docker 卷及如何与其中的数据进行交互。在整理容器、网络和卷之前，如果您正在运行 Docker Desktop，那么我们应该先看看
    Docker Desktop 仪表盘。
- en: Docker Desktop Dashboard
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Desktop 仪表盘
- en: 'If you are running either Docker for Mac or Docker for Windows, then there
    is an option within the main menu to open a dashboard that will display information
    on your running containers:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行 Docker for Mac 或 Docker for Windows，那么主菜单中有一个选项可以打开仪表盘，显示正在运行的容器的信息：
- en: '![Figure 4.40 – Opening the Docker Desktop Dashboard'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.40 – 打开 Docker Desktop 仪表盘](img/Figure_4.40_B15659.jpg)'
- en: '](img/Figure_4.40_B15659.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.40_B15659.jpg)'
- en: Figure 4.40 – Opening the Docker Desktop Dashboard
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.40 – 打开 Docker Desktop 仪表盘
- en: 'Once open, you should see something like the following screen. As you can see,
    we have our `redis` and `moby-counter` containers listed:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 打开后，您应该会看到如下屏幕。正如您所见，我们列出了 `redis` 和 `moby-counter` 容器：
- en: '![Figure 4.41 – Viewing the running containers'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.41 – 查看正在运行的容器](img/Figure_4.41_B15659.jpg)'
- en: '](img/Figure_4.41_B15659.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.41_B15659.jpg)'
- en: Figure 4.41 – Viewing the running containers
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.41 – 查看正在运行的容器
- en: 'Selecting the `redis` container will take you to an overview screen that defaults
    to the `Logs` output:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `redis` 容器后，您将进入一个概览屏幕，默认显示 `Logs` 输出：
- en: '![Figure 4.42 – Overview screen of the Logs output'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.42 – `Logs` 输出的概览屏幕](img/Figure_4.42_B15659.jpg)'
- en: '](img/Figure_4.42_B15659.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.42_B15659.jpg)'
- en: Figure 4.42 – Overview screen of the Logs output
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.42 – `Logs` 输出的概览屏幕
- en: 'Let''s start at the top of the screen. To the right here, you can see four
    blue icons; these are as follows, from left to right:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从屏幕顶部开始。右侧可以看到四个蓝色图标，它们从左到右分别是：
- en: '**Connect to container**: This will open your default Terminal application
    and connect to the currently selected container.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接到容器**：这将打开您的默认终端应用程序，并连接到当前选中的容器。'
- en: '**Stop the currently connected container**: When stopped, the icon will change
    to a **Start** icon.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止当前连接的容器**：停止后，图标将变为**启动**图标。'
- en: Next, we have the **Restart icon**. Clicking this will, well you guessed it
    right?! It will restart the currently selected container.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是**重启图标**。点击它，您猜得没错？！它将重启当前选中的容器。
- en: The final **Trash icon** will terminate the currently selected container.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的**垃圾桶图标**将终止当前选中的容器。
- en: 'Next, we have the menu items on the left-hand side of the screen. We have already
    seen the **Logs** output; this is updated in real time and you also have the option
    of searching through the log output. Below that we have **Inspect**; this displays
    some basic information about the container:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下屏幕左侧的菜单项。我们已经看过了 **Logs** 输出，它会实时更新，您也可以选择搜索日志输出。下面是 **Inspect**；它显示有关容器的一些基本信息：
- en: '![Figure 4.43 – Getting information on the container using inspect'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.43 – 使用 inspect 获取容器信息](img/Figure_4.43_B15659.jpg)'
- en: '](img/Figure_4.43_B15659.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.43_B15659.jpg)'
- en: Figure 4.43 – Getting information on the container using inspect
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.43 – 使用 inspect 获取容器信息
- en: 'The final item is `Stats`; this – as you may have already figured out, gives
    us the same output as the `docker container stats redis` command:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项是`Stats`；正如你可能已经猜到的，这会给我们与`docker container stats redis`命令相同的输出：
- en: '![Figure 4.44 – Viewing the real-time stats'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.44 – 查看实时统计信息'
- en: '](img/Figure_4.44_B15659.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.44_B15659.jpg)'
- en: Figure 4.44 – Viewing the real-time stats
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.44 – 查看实时统计信息
- en: 'Going to the `moby-counter` container adds an additional icon to the start
    of the top menu:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`moby-counter`容器会在顶部菜单开始处添加一个额外的图标：
- en: '![Figure 4.45 – Viewing the additional icon'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.45 – 查看额外的图标'
- en: '](img/Figure_4.45_B15659.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.45_B15659.jpg)'
- en: Figure 4.45 – Viewing the additional icon
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.45 – 查看额外的图标
- en: This will open your default browser and take you to the externally exposed port,
    which in this case is [http://localhost:8080](http://localhost:8080).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开你的默认浏览器，并带你到外部暴露的端口，在这种情况下是[http://localhost:8080](http://localhost:8080)。
- en: You have noticed that there are some features, such as the ability to create
    containers, in the dashboard. However, as new versions are released, I am sure
    that more management features will be added.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经注意到，仪表板中有一些功能，比如创建容器的能力。然而，随着新版本的发布，我相信会有更多的管理功能被添加进来。
- en: 'Now, we should tidy up. First of all, remove the two containers and network:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该整理一下。首先，移除两个容器和网络：
- en: '[PRE94]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, we can remove the volumes by running the following command:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过运行以下命令来移除卷：
- en: '[PRE95]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You should see something similar to the following Terminal output:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的终端输出：
- en: '![Figure 4.46 – Removing everything we have launched'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.46 – 删除我们启动的所有内容'
- en: '](img/Figure_4.46_B15659.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.46_B15659.jpg)'
- en: Figure 4.46 – Removing everything we have launched
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.46 – 删除我们启动的所有内容
- en: We are now back to having a clean slate, so we can progress to the next chapter.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经恢复了干净的状态，可以进入下一个章节。
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we looked at how you can use the Docker command-line client
    to both manage individual containers and launch multi-container applications in
    their own isolated Docker networks. We also discussed how we can persist data
    on the filesystem using Docker volumes. So far, in this and previous chapters,
    we have covered in detail the majority of the available commands that we will
    use in the following sections:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Docker 命令行客户端管理单个容器，并启动在自己隔离的 Docker 网络中的多容器应用程序。我们还讨论了如何使用 Docker
    卷在文件系统上持久化数据。到目前为止，在本章和前几章中，我们已经详细介绍了将来我们将在以下部分使用的大部分可用命令：
- en: '[PRE96]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now that we have covered the four main areas of using Docker locally, we can
    start to look at how to create more complex applications. In the next chapter,
    we will take a look at another core Docker tool, called **Docker Compose**.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了本地使用 Docker 的四个主要领域，我们可以开始学习如何创建更复杂的应用程序。在下一章中，我们将看看另一个核心 Docker 工具，称为**Docker
    Compose**。
- en: Questions
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which flag do you have to append to `docker container ls` to view all the containers,
    both running and stopped?
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有容器（包括正在运行的和已停止的容器），你需要在`docker container ls`命令后加上哪个标志？
- en: 'True or false: the `-p 8080:80` flag will map port `80` on the container to
    port `8080` on the host.'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：`-p 8080:80`标志会将容器上的端口`80`映射到主机上的端口`8080`。
- en: Explain the difference between what happens when you use *Ctrl + C* to exit
    a container you have attached, compared to using the `attach` command with `--sig-proxy=false`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释使用*Ctrl + C*退出已附加的容器与使用`attach`命令并加上`--sig-proxy=false`时的区别。
- en: 'True or false: The `exec` command attaches you to the running process.'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：`exec`命令将你附加到正在运行的进程。
- en: Which flag would you use to add an alias to a container so that it responds
    to DNS requests, when you already have a container running with the same DNS name
    in another network?
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经有一个在另一个网络中运行的容器，并且该容器使用相同的 DNS 名称，应该使用哪个标志来给容器添加别名，使其响应 DNS 请求？
- en: Which command would you use to find out details on a Docker volume?
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪个命令可以查看 Docker 卷的详细信息？
- en: Further reading
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at the following links:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解更多关于我们在本章中讨论的一些话题：
- en: 'The names generator code: [https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称生成器代码：[https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)
- en: 'The `cgroups` freezer function: [https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx)t'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgroups` 冻结功能: [https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx)'
- en: 'Redis: [https://redis.io/](https://redis.io/)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redis: [https://redis.io/](https://redis.io/)'
