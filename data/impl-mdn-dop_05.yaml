- en: Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: In the previous chapters, we demonstrated how the new cloud data centers can
    help us create online resources (virtual machines, Docker repositories, cryptographic
    keys) in a very easy way, shortening the hardware provisioning cycle from weeks
    (buying, shipping, and installing new computers) to seconds. We have also seen
    that there are different providers in the market that can offer us very similar
    features with different strong points that we can take advantage of when building
    our systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们展示了新一代云数据中心如何帮助我们非常轻松地创建在线资源（虚拟机、Docker 仓库、加密密钥），将硬件配置周期从几周（购买、运输和安装新计算机）缩短到几秒钟。我们还看到了市场上有不同的供应商可以提供类似的功能，并且具有各自不同的优势，我们可以在构建系统时加以利用。
- en: You learned how to create resources through the web interface that they offer,
    but how scalable is that? Creating resources manually prevents us from keeping
    an automated inventory of resources that can be used for security purposes as
    well as manage our infrastructure as if it were software components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何通过他们提供的网页界面创建资源，但这种方式的可扩展性如何呢？手动创建资源阻止了我们保持自动化的资源清单，这对于安全目的以及像管理软件组件一样管理我们的基础设施是必要的。
- en: 'In this chapter, you are going to learn how to build resources in the cloud
    first, through the SDK provided by the cloud data center vendor and then by a
    software component called **Terraform**, which is an industry standard for managing
    online resources. We are going to focus on **Google Cloud Platform** for several
    reasons:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先学习如何通过云数据中心供应商提供的 SDK 来构建云中的资源，然后通过一个叫做**Terraform**的软件组件来构建，**Terraform**是一个管理在线资源的行业标准。我们将专注于**Google
    Cloud Platform**，原因有几个：
- en: The command-line interface, in my opinion, is easier to use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为，命令行界面更易于使用。
- en: The Google Cloud Platform trial covers a good bunch of resources that you can
    use to experiment with throughout this book as you can create pretty much any
    resource in the full set of products.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Platform 的试用版涵盖了大量资源，你可以在本书中使用这些资源进行实验，因为你几乎可以在全套产品中创建任何资源。
- en: At the time of writing this (April 2017), Google Cloud Platform is the best
    value for money when it comes to cloud data centers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时（2017年4月），在云数据中心方面，Google Cloud Platform 提供了最具性价比的服务。
- en: That said, AWS, Azure or any other provider also offer a very interesting range
    of trial accounts, but unfortunately, we cannot cover everything in a single book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，AWS、Azure 或任何其他供应商也提供了非常有趣的试用账户，但遗憾的是，我们不能在一本书中涵盖所有内容。
- en: Google Cloud Platform SDK -  gcloud
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Platform SDK -  gcloud
- en: Google offers us a very comprehensive SDK that can be used for operating Google
    Cloud Platform as well as  installing software components related to cloud operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Google 为我们提供了一个非常全面的 SDK，它可以用于操作 Google Cloud Platform 以及安装与云操作相关的软件组件。
- en: The first thing we need to do is install `gcloud`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装`gcloud`。
- en: There are installers for Windows but, in general, for Unix-based systems (Linux
    and Mac mainly), we have an interactive installer that can be executed from the
    command line and the unattended mode (for automatic provisioning).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有 Windows 版安装程序，但通常来说，对于基于 Unix 的系统（主要是 Linux 和 Mac），我们有一个可以从命令行执行的交互式安装程序，并且有一个无人值守模式（用于自动配置）。
- en: The different options can be found at [https://cloud.google.com/sdk/downloads](https://cloud.google.com/sdk/downloads).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的选项可以在[https://cloud.google.com/sdk/downloads](https://cloud.google.com/sdk/downloads)找到。
- en: 'In order to install it (in my case, on Mac), the first thing we need to do
    is run the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装它（在我的例子中是在 Mac 上），我们需要做的第一件事是运行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will initiate the interactive installed in the online mode: we will be
    asked a number of questions during the installation process.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动在线模式下的交互式安装程序：在安装过程中，我们会被问到一系列问题。
- en: The first one is the installation directory. By default, this is the home of
    the user, but you can change it to the folder of your choice. Once you have selected
    the folder, it will start downloading and installing the required base components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是安装目录。默认情况下，这是用户的主目录，但你可以将其更改为你选择的文件夹。选择文件夹后，它将开始下载并安装所需的基础组件。
- en: The question is whether you want to help improve the Google Cloud SDK through
    the collection of anonymized data. Just answer as per your preferences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，你是否愿意通过收集匿名数据来帮助改进 Google Cloud SDK。请根据你的偏好作答。
- en: Now, Google Cloud SDK will start installing the core components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Google Cloud SDK 将开始安装核心组件。
- en: '![](img/13becb56-24c0-43c8-9d40-e14659b503b0.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13becb56-24c0-43c8-9d40-e14659b503b0.png)'
- en: As you can see in the preceding figure, Google SDK installs few packages that
    will be used to operate the basic services on Google Cloud Platform. Once it is
    finished (no need to do anything), it will ask you whether you want to modify
    the `PATH` variable of your system or not. Just reply `Y` and press *Enter* so
    that the `gcloud` command is available from the console. It will ask you in which
    file you want to modify the `PATH` variable. Usually, the default option that
    the installer provides you with is good enough. Before changing the file, the
    Google Cloud SDK installer will create a backup of the file with the same name
    with the `.backup` extension so you can revert the changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Google SDK 安装了一些用于操作 Google Cloud Platform 上基本服务的软件包。安装完成后（无需执行任何操作），它会询问你是否要修改系统的
    `PATH` 变量。只需回复 `Y` 并按 *Enter* 键，这样 `gcloud` 命令就可以在控制台中使用了。它会询问你要在哪个文件中修改 `PATH`
    变量。通常，安装程序提供的默认选项已经足够好。在修改文件之前，Google Cloud SDK 安装程序会创建一个备份文件，文件名与原文件相同，扩展名为 `.backup`，这样你可以还原更改。
- en: And we are done. It will ask you to start a new shell for the changes to take
    effect. Close your Terminal and open it again to check whether the `gcloud` command
    is available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完成了。它会提示你启动一个新的 shell 来使更改生效。关闭终端并重新打开，检查 `gcloud` 命令是否可用。
- en: 'Now that we have installed Google Cloud SDK, it is time to configure the authentication.
    Execute the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Google Cloud SDK，是时候配置认证了。执行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It will ask you to log in, so reply yes, which will open a browser window asking
    you to enter your Google credentials. Enter the ones associated with your trial
    account (if you didn't sign for the trial, do it before configuring your credentials).
    If you had a project already created in the Google Cloud Platform, it will ask
    you in the console to choose which one to use. In my case, I had one configured
    from [Chapter 2](6b4e8014-1c44-495b-b22b-e84fb1b944b8.xhtml), *Cloud Data Centers
    – The New Reality,* so I selected the one called `implementing-modern-devops`
    in my case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它会要求你登录，因此请选择“是”，这将打开一个浏览器窗口，要求你输入 Google 凭证。输入与你的试用账户相关联的凭证（如果你没有注册试用版，请在配置凭证之前进行注册）。如果你在
    Google Cloud Platform 上已经创建了项目，它会要求你在控制台中选择要使用的项目。在我的例子中，我已经在[第 2 章](6b4e8014-1c44-495b-b22b-e84fb1b944b8.xhtml)中配置了一个项目，*云数据中心——新现实*，所以我选择了名为
    `implementing-modern-devops` 的项目。
- en: The next topic is configuring the Google Compute Engine. Reply yes and select
    your availability zone. In my case, anywhere in Europe will work for me.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的主题是配置 Google Compute Engine。请选择“是”并选择你的可用性区域。在我的情况下，欧洲的任何地方都适合我。
- en: After this step, we are done. The prompt will tell us that we have a configuration
    called 'default' created. This means that the Google Cloud SDK can work with multiple
    credentials but, in this case, we are going to work with just one set of credentials
    and a single project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们就完成了。提示符会告诉我们已经创建了一个名为“default”的配置。这意味着 Google Cloud SDK 可以使用多个凭证，但在本例中，我们将只使用一组凭证和一个项目。
- en: Creating resources with Google Cloud SDK
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Cloud SDK 创建资源
- en: Once we are set up, it is time to start creating resources. As you can guess,
    the commands for creating resources can be quite complicated or extremely simple
    depending on your requirements. Luckily,  Google engineers have thought about
    it when creating the interface for Google Cloud Platform.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好，就该开始创建资源了。正如你所猜测的，创建资源的命令可能会非常复杂，也可能非常简单，取决于你的需求。幸运的是，Google 工程师在创建
    Google Cloud Platform 的界面时已经考虑到了这一点。
- en: 'The first thing you need to do is log in to your Google Cloud Platform account.
    Once you are there, go to  Compute Engine and fill the form to create a new resource.
    Enter the name of the instance, choose your closest region (Europe in my case),
    machine type (the default one will do), API access (we don''t need that but the
    default is OK) and Allow HTTP traffic and Allow HTTPS traffic. Before clicking
    on create, take a look at the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要登录到你的 Google Cloud Platform 账户。登录后，进入 Compute Engine 并填写表单以创建新的资源。输入实例名称，选择离你最近的区域（在我这里是欧洲），选择机器类型（默认即可），API
    访问（我们不需要这个，但默认设置可以），并勾选允许 HTTP 流量和允许 HTTPS 流量。在点击创建之前，请查看以下截图：
- en: '![](img/a670c321-1e61-48ca-a059-276d7a0236ad.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a670c321-1e61-48ca-a059-276d7a0236ad.png)'
- en: 'If you take a look at the very bottom, below the Create button, there are two
    links:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看最底部，在“创建”按钮下面，有两个链接：
- en: REST equivalent
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST等效
- en: Command line
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行
- en: 'For now, we are going to focus on the command line link. Click on it and you
    should get a window with a few commands. Let''s explain them:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重点关注命令行链接。点击它，你应该会看到一个带有一些命令的窗口。让我们解释一下它们：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first command creates the VM. As you can see, no one can expect to learn
    to create this command easily, but luckily, Google Cloud Platform provides it
    to you for every single resource that will be created for you so you can use the
    UI to generate the commands. That said, the preceding command sets every single
    potential setting that **Google Cloud** provides, so in other words, we will be
    able to run the preceding command with the same results no matter what settings
    we change in our cloud account.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建了虚拟机。如你所见，没有人能够轻松学会如何创建这个命令，但幸运的是，Google Cloud Platform为你提供了每个将要创建的资源的命令，因此你可以使用UI来生成这些命令。也就是说，前面的命令设置了**Google
    Cloud**提供的每一个潜在设置，换句话说，我们能够运行前面的命令，得到相同的结果，无论我们在云账户中更改了什么设置。
- en: 'There is a shorter version:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更简短的版本：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command does exactly the same as the very long command from earlier but
    assuming that the settings are the default (remember, you have already chosen
    some parameters, such as the default zone).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与之前那个非常长的命令完全相同，但假设设置是默认的（记住，你已经选择了一些参数，比如默认区域）。
- en: 'The other two commands are simpler:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个命令更简单：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Take a look at this too:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也看看这个：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can guess, these commands allow the HTTP and the HTTPS traffic into our
    host as described in the UI form.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所猜测的，这些命令允许HTTP和HTTPS流量进入我们的主机，正如UI表单中所描述的那样。
- en: These are the basics of infrastructure as code. We could potentially write those
    commands on a bash script and off we go; our infrastructure is created automatically
    for us. In the same way, if we don't want to depend on Google Cloud SDK, we could
    choose the REST option that will show us the list of HTTP requests that we need
    to issue to Google Cloud in order to create the same resources. If you are familiar
    with languages such as Python, JavaScript (Node.js), and others, you know how
    easy is to issue HTTP requests in order to create the resources so you could manage
    your infrastructure as if it were code following the same life cycle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基础的基础设施即代码。我们可以将这些命令写入bash脚本中，然后就可以开始了；我们的基础设施将会自动为我们创建。以同样的方式，如果我们不想依赖Google
    Cloud SDK，我们可以选择REST选项，它将向我们展示需要向Google Cloud发出的HTTP请求列表，以便创建相同的资源。如果你熟悉像Python、JavaScript（Node.js）等编程语言，你就会知道发出HTTP请求以创建资源是多么简单，这样你就能像管理代码一样管理基础设施，遵循相同的生命周期。
- en: 'This is a massive step forward in managing resources on the cloud, but it is
    still incomplete. Imagine this situation: you work in a company with a fairly
    complex setup, say, a few machines across different time zones and a fairly entangled
    network setup. How can you know at first glance which machines are running and
    what are the firewall rules are?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理云端资源的一大步，但它仍然不完整。想象一下这个情况：你在一家拥有相当复杂设置的公司工作，比如在不同的时区有几台机器，并且网络配置相当复杂。你怎么能一眼看出哪些机器在运行，防火墙规则是什么呢？
- en: 'The answer is simple: it is not possible with what we know today. In the next
    section, you are going to learn how to use something called **Terraform** from
    HashiCorp in order to manage not only the creation, but also the complete life
    cycle of online resources on different cloud providers.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：根据我们今天所知道的，这种方式不可行。在下一部分，你将学习如何使用来自HashiCorp的**Terraform**来管理不仅是资源的创建，还有不同云提供商上在线资源的完整生命周期。
- en: Terraform
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform
- en: '**Terraform** is a product developed by **HashiCorp**. HashiCorp is a company
    with a strong focus on DevOps tools such as Consul, a highly available distributed
    key value storage, or Vagrant, a tool to reproduce development environments using
    the same provisioners as production.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform**是**HashiCorp**开发的一款产品。HashiCorp是一家专注于DevOps工具的公司，例如Consul，一个高度可用的分布式键值存储，或Vagrant，一个使用与生产环境相同的提供程序来重现开发环境的工具。'
- en: 'Terraform, as the name hints, allows you to create infrastructure in cloud
    data centers in a declarative way, keeping track of what was created where, allowing
    you to apply changes to the infrastructure from the code perspective: your infrastructure
    is described as the code and, as such, it can follow its life cycle.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform，顾名思义，允许你以声明式的方式在云数据中心创建基础设施，跟踪哪些内容在何处被创建，并允许你从代码角度应用更改：你的基础设施作为代码进行描述，因此，它可以遵循其生命周期。
- en: The first thing we need to do is download and install Terraform. Just open the
    [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)
    URL in a browser and select your platform, in my case, Mac. Terraform is a single
    binary compressed in a ZIP file (as far as I am aware, it is the same for every
    platform) that I unzip and place somewhere in my path, in my case, `in /usr/local/bin/terraform`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是下载并安装Terraform。只需在浏览器中打开[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)网址并选择你的平台，在我这里是Mac。Terraform是一个压缩成ZIP文件的单一二进制文件（据我所知，所有平台都是如此），我解压并将其放在我的路径中，在我的情况下，是`/usr/local/bin/terraform`。
- en: Be careful as some OSX setups do not include `/usr/local/bin/` in the PATH environment
    variable, so you might need to do it before being able to execute Terraform from
    any path.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心，某些OSX配置并不包含`/usr/local/bin/`在`PATH`环境变量中，因此你可能需要在能够从任何路径执行Terraform之前，手动添加它。
- en: 'Once it is installed and the `PATH` variable includes `/usr/local/bin/` as
    one of the values separated by semi colons, we can check whether everything works
    as expected:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，并且`PATH`变量中包含`/usr/local/bin/`作为以分号分隔的值之一，我们可以检查一切是否按预期工作：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should return the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下输出：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This confirms that everything is correct. Also, be aware that DevOps tools
    move very quickly nowadays as they are required to do more things day by day.
    We are going to use the latest available version, 0.9.4, but by the time you are
    reading this book, a newer version might be available with new features and even
    some breaking changes. Luckily, Terraform comes with a very powerful documentation
    embedded in it. Let''s look at all the available commands. Just execute this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了一切都正确无误。另请注意，现如今DevOps工具更新非常迅速，它们需要一天比一天做更多的事情。我们将使用最新的版本0.9.4，但当你读到这本书时，可能会有一个更新的版本，带有新特性甚至可能有一些不兼容的更改。幸运的是，Terraform附带了一个非常强大的文档。让我们查看所有可用的命令。只需执行这个：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should output something similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出类似以下的内容：
- en: '![](img/bd0e57a8-c830-4445-8c86-11004c148b2f.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd0e57a8-c830-4445-8c86-11004c148b2f.png)'
- en: 'Now, in order to display the help dialog on any of the commands, we just need
    to execute the command with the flag `-h`. For example, let''s display the help
    for `apply`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了显示任何命令的帮助对话框，我们只需要在命令后加上标志`-h`。例如，我们来查看`apply`命令的帮助：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It will output the list of all the options available for the command in the
    prompt.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出该命令在命令提示符下的所有可用选项列表。
- en: Creating resources
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建资源
- en: 'Now that we have all the requirements installed, we are going to create our
    first resource in order to help us to understand how Terraform works and how powerful
    it is. Create a folder called `implementing-modern-devops` somewhere in your computer
    and add a file called `resources.tf` with the following content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有要求的软件包，我们将创建我们的第一个资源，帮助我们理解Terraform是如何工作的以及它的强大功能。请在你的计算机上创建一个名为`implementing-modern-devops`的文件夹，并添加一个名为`resources.tf`的文件，文件内容如下：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the preceding snipped is very similar to JSON but it is actually
    called HCL: HashiCorp Configuration Language. Let''s explain what the code is
    doing.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的片段与JSON非常相似，但它实际上被称为HCL：HashiCorp配置语言。我们来解释一下这段代码的作用。
- en: 'The first section is where we configure our credentials. As you can see, Terraform
    is expecting a file called `xxx.json`, which we don''t have at the moment. If
    we check the official documentation of Terraform for Google Cloud Platform, it
    specifies that we need to create a Service account from the API Manager section
    of the Google Cloud Platform, as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是我们配置凭据的地方。如你所见，Terraform期望有一个名为`xxx.json`的文件，而我们现在没有该文件。如果我们查看Google Cloud
    Platform的Terraform官方文档，它指出我们需要从Google Cloud Platform的API管理器部分创建一个服务帐户，如下图所示：
- en: '![](img/4bbdb6ed-997e-4caa-a022-cd899ba70420.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bbdb6ed-997e-4caa-a022-cd899ba70420.png)'
- en: Once we create it by choosing JSON as a format, a file will automatically be
    saved on our computer, containing the credentials that we need in order to operate
    Google Cloud Platform.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择 JSON 格式创建它，文件将自动保存在我们的计算机上，包含我们操作 Google Cloud Platform 所需的凭证。
- en: Be careful. If you leak these credentials, someone could create or destroy resources
    on your behalf, which may lead to significant charges or data loss.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心。如果泄露了这些凭证，别人可能会代表你创建或销毁资源，这可能会导致重大费用或数据丢失。
- en: Copy the file to the previously created folder *(*`implementing-modern-devops`)
    and rename it to `xxx.json` so it matches our configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件复制到之前创建的文件夹 *(*`implementing-modern-devops`)，并将其重命名为 `xxx.json`，使其与我们的配置匹配。
- en: The second section is the description of our virtual machine, the instance to
    be created in Google Cloud. In this case, we are creating a resource called `my-first-instance`
    of the type `google_compute_instance`. We did not specify any configuration on
    purpose as I want to show you how to troubleshoot problems with Terraform, which,
    due to the high-quality error logs produced, is rather simple.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是我们虚拟机的描述，即将在 Google Cloud 中创建的实例。在这种情况下，我们创建了一个名为 `my-first-instance` 的资源，类型为
    `google_compute_instance`。我们故意没有指定任何配置，因为我想展示如何使用 Terraform 排查问题，鉴于其高质量的错误日志，排查过程非常简单。
- en: 'Let''s see what happens. From the root of our project, the `implementing-modern-devops`
    folder, we run the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看发生了什么。从我们项目的根目录，即 `implementing-modern-devops` 文件夹中，运行以下命令：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command will describe the steps required to create our infrastructure in
    Google Cloud. In this case, it is rather simple as we have only one machine, but
    it is going to be helpful to learn about Terraform.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将描述在 Google Cloud 中创建基础设施所需的步骤。在这种情况下，它相当简单，因为我们只有一台机器，但这对于学习 Terraform
    会非常有帮助。
- en: 'Let''s look at what happened and and how it has been explained in the output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下发生了什么，以及在输出中是如何解释的：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding command failed. Basically, our compute instance requires four
    fields that we did not specify: `machine_type`, `name`, `zone`, and `disk`. In
    this case, we can specify them, but if you need to check extra parameters, all
    the documentation for the resource `google_compute_instance` can be found at [https://www.terraform.io/docs/providers/google/r/compute_instance.html](https://www.terraform.io/docs/providers/google/r/compute_instance.html).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令失败了。基本上，我们的计算实例需要四个字段，而我们没有指定：`machine_type`、`name`、`zone` 和 `disk`。在这种情况下，我们可以指定这些字段，但如果你需要检查额外的参数，关于资源
    `google_compute_instance` 的所有文档可以在 [https://www.terraform.io/docs/providers/google/r/compute_instance.html](https://www.terraform.io/docs/providers/google/r/compute_instance.html)
    查阅。
- en: Visit it and read around to get familiar with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 访问它并阅读内容，以便熟悉它。
- en: We are also going to specify the network interface (basically the network we
    want to connect to our machine) as it will fail later on in the `apply` command
    if we don't do it now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将指定网络接口（基本上是我们想要连接到机器的网络），因为如果现在不这样做，稍后的 `apply` 命令将会失败。
- en: 'Now, we are going to fix the problems that we found on the first run. Replace
    the `google_compute_instance` block with the following one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解决第一次运行时发现的问题。用以下内容替换 `google_compute_instance` 块：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Go back to the Terminal and execute `terraform` plan'' again. The output will
    be similar to this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 返回终端并再次执行 `terraform plan`。输出将类似于以下内容：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For space reasons, I have omitted an explanatory text that comes before the
    resource explanation but basically tells us that we can save this plan in a file
    in order to pass it as a parameter to the apply the command that we are going
    to run next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 出于空间考虑，我省略了资源说明之前的解释性文本，但基本上它告诉我们可以将此计划保存在文件中，以便将其作为参数传递给接下来我们将要运行的 `apply`
    命令。
- en: This enables us to ensure that what is executed is what we have seen in the
    plan just in case someone else has modified the online infrastructure before calculating
    what needs to change, Terraform syncs the configuration in the resources files
    with the existing infrastructure in Google Cloud. So, it might be the case that
    we can execute `terraform plan`  and someone changes our cloud infrastructure
    (with another Terraform script or manually) and then our `terraform apply` command
    differs from the plan calculated.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够确保执行的内容与我们在计划中看到的相符，以防别人已经在计算需要更改的内容之前修改了在线基础设施，Terraform 会将资源文件中的配置与
    Google Cloud 中现有的基础设施进行同步。因此，可能会发生这种情况：我们执行 `terraform plan` 时，别人通过另一个 Terraform
    脚本或手动修改了我们的云基础设施，然后我们的 `terraform apply` 命令与计算出的计划不同。
- en: 'Now once we have verified that our Terraform plan is to create a VM, execute
    the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认我们的 Terraform 计划是创建一台虚拟机，执行以下命令：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After a few seconds, the script should finish presenting the output of what
    was created, changed, or destroyed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，脚本应该会完成并展示出已创建、已更改或已销毁的内容：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If everything went as per plan, we should have a file called `terraform.tfstate`
    in our folder which is the state of our virtual infrastructure created in the
    cloud. We also have the same file with the extension `backup`, which is the status
    of our infrastructure before running our last `apply` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，我们的文件夹中应该会有一个名为 `terraform.tfstate` 的文件，它是我们在云端创建的虚拟基础设施的状态。我们还会有一个扩展名为
    `backup` 的相同文件，它是我们在执行最后一次 `apply` 命令之前基础设施的状态。
- en: This file is important. Terraform is able to refresh it with changes made on
    the cloud, but it is not able to rebuild it. Some people keep this file alongside
    the Terraform scripts and some other people prefer to use a backend to store this
    file and manage the Terraform state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件非常重要。Terraform 可以根据云端的变更来刷新它，但无法重新构建它。有些人将此文件与 Terraform 脚本一起保存，而其他人则更倾向于使用后端存储此文件并管理
    Terraform 状态。
- en: Remote state management
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程状态管理
- en: 'A backend is a system that is going to store our status in a shared environment
    where everyone using the same configuration can quickly access it. Let''s look
    at how is this done using **Google Cloud Storage**. Just execute the following
    command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是一种存储我们状态的系统，它将状态存储在一个共享环境中，所有使用相同配置的人都可以快速访问。让我们看看如何使用 **Google Cloud Storage**
    来实现这一点。只需执行以下命令：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are a few considerations: we need to create a bucket called `my-terraform`
    in the Google Cloud Storage interface and we need to configure Application default
    credentials for Google Cloud. The easiest way to do this is by setting an environment
    variable called `GOOGLE_APPLICATION_CREDENTIALS` to the path where the `xxx.json`
    file that we have used to authenticate against GCP when running our infrastructure
    is. If you are in the same folder, just run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些注意事项：我们需要在 Google Cloud Storage 界面中创建一个名为 `my-terraform` 的存储桶，并且需要为 Google
    Cloud 配置应用程序默认凭证。最简单的方法是通过设置名为 `GOOGLE_APPLICATION_CREDENTIALS` 的环境变量，将其路径指向我们用来在运行基础设施时进行
    GCP 认证的 `xxx.json` 文件。如果你在同一文件夹下，只需运行以下命令：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once this is done and the Terraform command succeeds, if we check our bucket
    in Google Cloud Storage, we have a new item with the content of `terraform.tfstate`
    that we had in our local file system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成并且 Terraform 命令执行成功，如果我们检查 Google Cloud Storage 中的存储桶，我们会发现一个新项，它包含我们在本地文件系统中使用的
    `terraform.tfstate` 文件的内容。
- en: Now we can test that it works by altering our infrastructure and seeing how
    this is reflected in our bucket on Google Cloud Storage. You can do this easily
    by running `terraform destroy` and checking what happens to our remote state in
    Google Cloud.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过改变基础设施并查看如何在 Google Cloud Storage 中的存储桶中反映这些变化来测试它是否正常工作。你可以通过运行 `terraform
    destroy` 并检查远程状态在 Google Cloud 中的变化来轻松做到这一点。
- en: Be careful with the state files. They have very valuable information about your
    company's infrastructure and can be used as an attack vector.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 小心处理状态文件。它们包含关于你公司基础设施的非常重要的信息，可能会被用作攻击的切入点。
- en: 'This feature is used to share configuration across a team of engineers, and
    it is fully managed by Terraform: you don''t need to pull or push state files
    as Terraform will do it for you.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能用于在工程团队中共享配置，它由 Terraform 完全管理：你无需手动拉取或推送状态文件，因为 Terraform 会为你处理这些操作。
- en: Modifying your infrastructure
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改你的基础设施
- en: Up until now, we have only created resources and stored the state of or cloud
    data center in an online bucket. Now you are going to learn how to modify the
    existing infrastructure from a project such as the one we built earlier on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了资源并将云数据中心的状态存储在在线存储桶中。接下来你将学习如何修改已有的基础设施，就像我们之前创建的项目一样。
- en: 'As you can see, we started from a very simple example: create a single virtual
    machine with an ephemeral IP address (the default one assigned by Google, not
    fixed).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们从一个非常简单的示例开始：创建一台带有临时 IP 地址的虚拟机（由 Google 分配的默认 IP 地址，非固定）。
- en: 'Now, we are going to create a static IP and assign it to our machine so it
    always uses the same IP. The way of doing this through Terraform is creating a
    resource of the type `google_compute_address`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个静态 IP 并将其分配给我们的虚拟机，以确保它始终使用相同的 IP 地址。通过 Terraform 来实现这一点的方法是创建一个类型为
    `google_compute_address` 的资源，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can execute `terraform plan` to see what will change if we apply the
    infrastructure change. As you can see in your new execution plan, Terraform identifies
    that we need to create a new resource of type `google_compute_address`, but...
    how do we attach this IP to our VM? Let''s revisit the configuration of our VM:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行 `terraform plan` 来查看如果应用基础设施更改，哪些内容会发生变化。正如你在新的执行计划中看到的那样，Terraform
    识别出我们需要创建一个新的 `google_compute_address` 类型的资源，但是……我们如何将这个 IP 地址附加到我们的虚拟机呢？让我们重新检查虚拟机的配置：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the highlighted line of the code, you can see how simple it is to associate
    our VM with the new address that we are going to create: our created resource,
    the address, will have computed attributes (attributes calculated at runtime)
    that can be used in other resources. In Terraform, the syntax for interpolating
    values is `${}` with the value of the attribute to interpolate between the brackets,
    in this case, the IP address of the resource called `my-first-ip`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的高亮行中，你可以看到将我们的虚拟机与我们将要创建的新地址关联是多么简单：我们创建的资源，即地址，将具有计算属性（在运行时计算的属性），这些属性可以在其他资源中使用。在
    Terraform 中，插值值的语法是 `${}`，其中括号中的值为要插值的属性值，在本例中是名为 `my-first-ip` 的资源的 IP 地址。
- en: 'If you head to the Google Cloud Console and open the external IP''s section,
    you can see something similar to what is shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你前往 Google Cloud 控制台并打开外部 IP 部分，你会看到类似于以下屏幕截图的内容：
- en: '![](img/d9b35cc2-225e-44b6-b738-fd528e8d8d00.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b35cc2-225e-44b6-b738-fd528e8d8d00.png)'
- en: The IP was associated with our VM, as expected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址已按预期与我们的虚拟机关联。
- en: Terraform variables
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 变量
- en: 'One thing we did not mention earlier is the fact that Terraform can work with
    variables. Take a look at the following definition:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有提到的一点是 Terraform 可以与变量一起使用。请看以下定义：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the configuration of our provider. There are few strings that, quite
    likely, are going to be used in other places, such as the region or the name of
    the project. Terraform has the concept of variable, which is a value that is susceptible
    to change so we can extract it into a separated file. Up until now, we have created
    a file called `resources.tf`. Let''s create a file called `vars.tf` with the following
    content:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们提供程序的配置。有些字符串很可能会在其他地方使用，比如区域或项目名称。Terraform 有变量的概念，变量是一个可能会变化的值，因此我们可以将其提取到一个单独的文件中。到目前为止，我们已经创建了一个名为
    `resources.tf` 的文件。现在，让我们创建一个名为 `vars.tf` 的文件，内容如下：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we are going to use these variables in our files. By default, Terraform
    will look into all the files with the extension `.tf` in our current folder, build
    the knowledge base of all the facts that have been described, and start creating
    our infrastructure as appropriated (internally building a graph of dependencies
    that can be checked with the `terraform graph` command). This means that we don''t
    need to do anything special for Terraform to pick up our variables file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把这些变量应用到我们的文件中。默认情况下，Terraform 会查看当前文件夹中所有扩展名为 `.tf` 的文件，构建所有已描述事实的知识库，并开始根据需要创建我们的基础设施（内部构建一个依赖关系图，可以使用
    `terraform graph` 命令进行检查）。这意味着我们不需要做任何特别的操作，Terraform 就能识别我们的变量文件：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can use variables pretty much anywhere to facilitate our infrastructure creation.
    As you can see, the syntax is the same as the syntax used for interpolation; in
    fact, it is an interpolation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几乎任何地方使用变量，以便更轻松地创建我们的基础设施。如你所见，语法与插值时使用的语法相同；实际上，这就是插值。
- en: 'In the variables file, we have specified the default values for the variables,
    but it is possible that we want to change them depending on the environment or
    even for tweaking the configuration. Terraform also allows you to override variables
    in three ways:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量文件中，我们已经为这些变量指定了默认值，但我们也可能根据环境或调整配置时需要更改这些值。Terraform 还允许你通过三种方式来覆盖变量：
- en: On the command line
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中
- en: With a file called `terraform.tfvars`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名为 `terraform.tfvars` 的文件
- en: With environment variables
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: 'The first way is as easy as passing extra flags to the `terraform` commands.
    For example, if we want to change `project_name` when applying the changes to
    our infrastructure, we just need to pass an extra flag with the value of the variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式就是简单地在 `terraform` 命令中添加额外的标志。例如，如果我们想在应用基础设施更改时修改 `project_name`，只需传递一个额外的标志，并指定变量的值：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And that's it. You can experiment by changing the project name or the zone and
    see how `terraform plan` creates new resources (as they don't exist in a different
    project).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。你可以通过更改项目名称或区域来进行实验，看看`terraform plan`如何创建新的资源（因为它们在不同的项目中不存在）。
- en: 'The second method is using a file with the variable definitions. In order to
    test it, create a file called `terraform.tfvars` in the root of your project with
    the following content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用包含变量定义的文件。为了测试它，在你的项目根目录下创建一个名为`terraform.tfvars`的文件，并填入以下内容：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, if you run `terraform plan`, you will see how Terraform plans to create
    new resources as they don't exist in a project called `my-new-project-name`. The
    filename does not need to be `terrafrom.tfvars`, but if you create it with a different
    name, Terraform won't pick it up by default and you will need to pass the flag
    -var-file in order to load it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行`terraform plan`，你将看到Terraform计划创建新资源，因为它们在名为`my-new-project-name`的项目中不存在。文件名不一定是`terrafrom.tfvars`，但如果你使用不同的名称创建它，Terraform默认不会加载它，你需要传递`-var-file`标志来加载它。
- en: Don't forget to remove the `terraform.tfvars` file before continuing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，别忘了移除`terraform.tfvars`文件。
- en: 'The third way of overriding variables is via environment variables. This is
    particularly interesting as it easily allows you to manage the configuration of
    different environments by external factors. The convention is to define an environment
    variable with the same name as the variable in Terraform but prefixing it with
    `TF_VAR_`. For example, for the variable `project_name`, we would execute the
    following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖变量的第三种方法是通过环境变量。这种方法特别有趣，因为它可以轻松地通过外部因素来管理不同环境的配置。约定是定义一个与Terraform中的变量同名的环境变量，但前缀加上`TF_VAR_`。例如，对于变量`project_name`，我们可以执行以下命令：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Terraform outputs
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform outputs
- en: Up until now, we have worked with Terraform to create our infrastructure but
    we have little to no insight on what is going on in our cloud, in this case, on
    Google Cloud Platform. The engineers from HashiCorp have also thought about this,
    and they have created an element called output that allows us to print values
    of the resources created by our scripts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Terraform来创建我们的基础设施，但我们对我们的云环境（在本例中是Google Cloud Platform）几乎没有任何了解。HashiCorp的工程师们也考虑到了这一点，并创建了一个名为输出（output）的元素，允许我们打印脚本创建的资源的值。
- en: 'So far, we have two files:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两个文件：
- en: '`resources.tf`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.tf`'
- en: '`variables.tf`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.tf`'
- en: Before proceeding, make sure that your online infrastructure is created by running
    `terraform apply` as we did earlier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经通过运行`terraform apply`创建了在线基础设施，就像我们之前所做的那样。
- en: Now, we are going to create another file called `outputs.tf`. This is not coincidental.
    In Terraform, this is the recommended layout for your projects as it facilitates
    the code readability as well as segregates responsibilities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另一个文件，名为`outputs.tf`。这并非偶然。在Terraform中，这是推荐的项目布局方式，它有助于代码的可读性，并且能够分隔职责。
- en: 'Add the following content to the `outputs.tf` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`outputs.tf`文件中：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will come back to this command later, but now, we need to rerun the apply
    command in order to let Terraform create the output for us. Something has changed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到这个命令，但现在我们需要重新运行apply命令，以便让Terraform为我们创建输出。某些内容已经发生了变化：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Terraform apply needs to be run for your outputs for it to become available
    even if you did not change the infrastructure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有更改基础设施，`Terraform apply`也需要运行，才能使你的输出可用。
- en: 'Now we can see a new section called outputs, which contain the values that
    we have defined in the outputs file. If you want to see it again at any time,
    just run the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到一个新的部分，叫做outputs，它包含了我们在outputs文件中定义的值。如果你想随时查看它，只需运行以下命令：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, simply run this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，直接运行以下命令：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first one will show only the IP of the instance (this is particularly handy
    for using it as input for other commands). The second one shows all the outputs
    defined in your Terraform scripts.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将只显示实例的IP（这对于作为其他命令的输入特别有用）。第二个则显示你在Terraform脚本中定义的所有输出。
- en: 'Now, let''s explain how the outputs work. In this case, we have used the following
    string to identify what we want to output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释一下输出是如何工作的。在这个例子中，我们使用了以下字符串来识别我们想要输出的内容：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first two keys (separated by dots) are clear: the type and the name of
    our resource. Then, the IP belongs to `network_interface` in the `acccess_config`
    section and the value is stored in `nat_ip`*,* but what are those 0ses in there?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个键（由点分隔）很明确：我们的资源类型和名称。然后，IP属于`network_interface`中的`acccess_config`部分，值存储在`nat_ip`中，但那里的0是怎么回事呢？
- en: 'Easy; we can define more than one network interface by repeating the `network_interface`
    block as many times as you need: the first one in the code will be `0`, the second
    one will be `1`, and so on...'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单；我们可以通过重复`network_interface`块多次来定义多个网络接口：代码中的第一个接口是`0`，第二个是`1`，依此类推...
- en: 'This attribute path can be tricky to calculate sometimes, although the majority
    of the time is quite obvious from the configuration file. If you experience problems
    finding what you want to output, here is a shortcut: When you run `terraform apply`,
    in the output, you will see something similar to this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性路径有时可能很难计算，尽管大多数情况下从配置文件中是相当明显的。如果你在寻找想要输出的内容时遇到问题，下面有一个快捷方式：当你运行`terraform
    apply`时，在输出中你会看到类似这样的内容：
- en: '![](img/c5112bd1-3f03-4a48-9966-e10f8b3912ce.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5112bd1-3f03-4a48-9966-e10f8b3912ce.png)'
- en: 'This is the list of all the attributes that you can show in your outputs; the
    key is the column on the left-hand side. For example, if we want to show the zone
    where our VM is created, it is as simple as this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以在输出中显示的所有属性的列表；键是左侧的列。例如，如果我们想显示创建VM的区域，就像这样简单：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the interpolation also works here, letting you mix strings with
    values of the Terraform resources.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里的插值也起作用，允许你将字符串与Terraform资源的值混合在一起。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Terraform is the basic tool that every DevOps engineer needs to master in order
    to work efficiently with cloud providers such as Google Cloud Platform or AWS
    as it allows you to manage the infrastructure as if code was, with a lifecycle
    the ability to deploy infrastructure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是每个DevOps工程师必须掌握的基本工具，它允许你像管理代码一样管理基础设施，可以与Google Cloud Platform或AWS等云服务提供商高效工作，具有生命周期管理和部署基础设施的能力。
- en: In this chapter, we saw the most important aspects of Terraform regarding the
    creation of virtual infrastructure. You learned enough to be able to, with the
    help of the online documentation, create resources and connect them in order to
    create much bigger projects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Terraform在创建虚拟基础设施方面的最重要内容。你已经学到了足够的知识，可以借助在线文档，创建资源并将它们连接起来，从而创建更大的项目。
- en: Even though the examples that we followed through this chapter were pretty basic,
    in the next chapter, we will create a more complex infrastructure and install
    the required software to run it in an automated fashion.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在本章中遵循的示例相当基础，在下一章中，我们将创建更复杂的基础设施并安装所需的软件，以便以自动化方式运行它。
- en: We will also use more advanced Terraform capabilities such as modules to create
    highly reusable components that can be shared with different teams or even as
    open source components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用更高级的Terraform功能，例如模块，以创建高度可重用的组件，这些组件可以与不同的团队共享，甚至作为开源组件。
