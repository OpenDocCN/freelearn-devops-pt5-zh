- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating and Managing Container Images
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理容器镜像
- en: In the previous chapter, we learned what containers are and how to run, stop,
    remove, list, and inspect them. We extracted the logging information of some containers,
    ran other processes inside an already running container, and finally, we dived
    deep into the anatomy of containers. Whenever we ran a container, we created it
    using a container image. In this chapter, we will familiarize ourselves with these
    container images. We will learn what they are, how to create them, and how to
    distribute them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了什么是容器，以及如何运行、停止、删除、列出和检查容器。我们提取了一些容器的日志信息，运行了其他进程在已经运行的容器内，最后我们深入了解了容器的结构。每次我们运行容器时，都会使用容器镜像来创建它。在本章中，我们将熟悉这些容器镜像。我们将学习它们是什么，如何创建它们，以及如何分发它们。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are images?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: Creating images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镜像
- en: Lift and shift – containerizing a legacy app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升与迁移 —— 将传统应用程序容器化
- en: Sharing or shipping images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享或运输镜像
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做到以下几点：
- en: Name three of the most important characteristics of a container image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举容器镜像的三个最重要特征
- en: Create a custom image by interactively changing the container layer and committing
    it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交互式更改容器层并提交它来创建自定义镜像
- en: Author a simple Dockerfile to generate a custom image
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的Dockerfile来生成自定义镜像
- en: Export an existing image using `docker image save` and import it into another
    Docker host using `docker` `image load`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker image save`导出现有镜像，并使用`docker image load`将其导入到另一个Docker主机中
- en: Write a two-step Dockerfile that minimizes the size of the resulting image by
    only including the resulting artifacts in the final image
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个两步的Dockerfile，通过仅将最终结果包含在最终镜像中，来最小化生成镜像的大小
- en: What are images?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: In Linux, everything is a file. The whole operating system is a filesystem with
    files and folders stored on the local disk. This is an important fact to remember
    when looking at what container images are. As we will see, an image is a big tarball
    containing a filesystem. More specifically, it contains a layered filesystem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，一切皆文件。整个操作系统是一个包含文件和文件夹的文件系统，这些文件存储在本地磁盘上。在查看容器镜像时，记住这一点非常重要。正如我们将看到的，镜像是一个包含文件系统的大tar包。更具体地说，它包含一个分层文件系统。
- en: Tarball
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: tar包
- en: A tarball (also known as a `.tar` archive) is a single file that contains multiple
    files or directories. It is a common archive format that is used to distribute
    software packages and other collections of files. The `.tar` archive is usually
    compressed using gzip or another compression format to reduce its size. Tarballs
    are commonly used in Unix-like operating systems, including Linux and macOS, and
    can be unpacked using the `tar` command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: tar包（也称为`.tar`归档文件）是一个包含多个文件或目录的单一文件。它是一种常见的归档格式，用于分发软件包和其他文件集合。`.tar`归档文件通常使用gzip或其他压缩格式进行压缩，以减小文件大小。tar包广泛应用于类Unix操作系统，包括Linux和macOS，并可以通过`tar`命令解压。
- en: The layered filesystem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层文件系统
- en: 'Container images are templates from which containers are created. These images
    are not made up of just one monolithic block but are composed of many layers.
    The first layer in the image is also called the **base layer**. We can see this
    in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是创建容器的模板。这些镜像不仅仅由一个单一的块组成，而是由许多层次构成。镜像中的第一层也称为**基础层**。我们可以在下图中看到这一点：
- en: '![Figure 4.1 – The image as a stack of layers](img/B19199_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 镜像作为层叠堆栈](img/B19199_04_01.jpg)'
- en: Figure 4.1 – The image as a stack of layers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 镜像作为层叠堆栈
- en: Each layer contains files and folders. Each layer only contains the changes
    to the filesystem concerning the underlying layers. Docker uses a Union filesystem
    – as discussed in [*Chapter 3*](B19199_03.xhtml#_idTextAnchor057), *Mastering
    Containers* – to create a virtual filesystem out of the set of layers. A storage
    driver handles the details regarding the way these layers interact with each other.
    Different storage drivers are available that have advantages and disadvantages
    in different situations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都包含文件和文件夹。每一层只包含相对于底层的文件系统的变化。Docker使用联合文件系统——如在[*第3章*](B19199_03.xhtml#_idTextAnchor057)《容器基础》一书中所讨论的——从一组层中创建一个虚拟文件系统。存储驱动程序处理这些层之间相互作用的细节。不同的存储驱动程序在不同情况下有各自的优缺点。
- en: The layers of a container image are all immutable. Immutable means that once
    generated, the layer cannot ever be changed. The only possible operation affecting
    the layer is its physical deletion. This immutability of layers is important because
    it opens up a tremendous number of opportunities, as we will see.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的各个层都是不可变的。不可变意味着一旦生成，该层就无法更改。唯一可能影响层的操作是其物理删除。层的这种不可变性非常重要，因为它打开了大量的机会，正如我们将要看到的。
- en: 'In the following figure, we can see what a custom image for a web application,
    using Nginx as a web server, could look like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到一个自定义的 Web 应用程序的图片，使用 Nginx 作为 Web 服务器：
- en: '![Figure 4.2 – A sample custom image based on Alpine and Nginx](img/B19199_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 基于 Alpine 和 Nginx 的示例自定义镜像](img/B19199_04_02.jpg)'
- en: Figure 4.2 – A sample custom image based on Alpine and Nginx
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 基于 Alpine 和 Nginx 的示例自定义镜像
- en: Our base layer here consists of the Alpine Linux distribution. Then, on top
    of that, we have an **Add Nginx** layer where Nginx is added on top of Alpine.
    Finally, the third layer contains all the files that make up the web application,
    such as HTML, CSS, and JavaScript files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的基础层是 Alpine Linux 发行版。然后，在其上，我们有一个**添加 Nginx**层，在 Alpine 的基础上添加了 Nginx。最后，第三层包含构成
    Web 应用程序的所有文件，例如 HTML、CSS 和 JavaScript 文件。
- en: As has been said previously, each image starts with a base image. Typically,
    this base image is one of the official images found on Docker Hub, such as a Linux
    distro, Alpine, Ubuntu, or CentOS. However, it is also possible to create an image
    from scratch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，每个镜像都从一个基础镜像开始。通常，这个基础镜像是 Docker Hub 上找到的官方镜像之一，如 Linux 发行版 Alpine、Ubuntu
    或 CentOS。然而，也可以从零开始创建一个镜像。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Docker Hub is a public registry for container images. It is a central hub ideally
    suited for sharing public container images. The registry can be found here: [https://hub.docker.com/](https://hub.docker.com/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是一个公共的容器镜像注册表。它是一个理想的中央枢纽，非常适合分享公共容器镜像。该注册表可以在这里找到：[https://hub.docker.com/](https://hub.docker.com/)。
- en: Each layer only contains the delta of changes regarding the previous set of
    layers. The content of each layer is mapped to a special folder on the host system,
    which is usually a subfolder of `/var/lib/docker/`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层只包含相对于前一组层的更改增量。每个层的内容都映射到主机系统上的一个特殊文件夹中，通常是 `/var/lib/docker/` 的子文件夹。
- en: Since layers are immutable, they can be cached without ever becoming stale.
    This is a big advantage, as we will see.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于层是不可变的，它们可以被缓存而永远不会过期。这是一个巨大的优势，正如我们将要看到的。
- en: The writable container layer
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可写的容器层
- en: 'As we have discussed, a container image is made of a stack of immutable or
    read-only layers. When Docker Engine creates a container from such an image, it
    adds a writable container layer on top of this stack of immutable layers. Our
    stack now looks as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，容器镜像由一堆不可变或只读的层组成。当 Docker 引擎从这样的镜像创建容器时，它在这堆不可变层的顶部添加一个可写的容器层。我们的堆栈现在如下所示：
- en: '![Figure 4.3 – The writable container layer](img/B19199_04_03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 可写的容器层](img/B19199_04_03.png)'
- en: Figure 4.3 – The writable container layer
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 可写的容器层
- en: 'The container layer is marked as **read/write** (**r/w**). Another advantage
    of the immutability of image layers is that they can be shared among many containers
    created from this image. All that is needed is a thin, writable container layer
    for each container, as shown in the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器层被标记为**读/写** (**r/w**)。镜像层的不可变性的另一个优点是，它们可以在从该镜像创建的许多容器之间共享。所需的只是为每个容器创建一个薄薄的可写容器层，如下图所示：
- en: '![Figure 4.4 – Multiple containers sharing the same image layers](img/B19199_04_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 多个容器共享相同的镜像层](img/B19199_04_04.jpg)'
- en: Figure 4.4 – Multiple containers sharing the same image layers
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 多个容器共享相同的镜像层
- en: This technique, of course, results in a tremendous reduction in the resources
    that are consumed. Furthermore, this helps decrease the loading time of a container
    since only a thin container layer has to be created once the image layers have
    been loaded into memory, which only happens for the first container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种技术极大地减少了消耗的资源。此外，这有助于减少容器的加载时间，因为只有在将镜像层加载到内存中后才需要创建薄薄的容器层，而这仅在第一个容器中发生。
- en: Copy-on-write
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写时复制
- en: 'Docker uses the copy-on-write technique when dealing with images. Copy-on-write
    is a strategy for sharing and copying files for maximum efficiency. If a layer
    uses a file or folder that is available in one of the low-lying layers, then it
    just uses it. If, on the other hand, a layer wants to modify, say, a file from
    a low-lying layer, then it first copies this file up to the target layer and then
    modifies it. In the following figure, we can see what this means:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在处理镜像时使用写时复制技术。写时复制是一种共享和复制文件的高效策略。如果某一层使用了低层中的某个文件或文件夹，那么它会直接使用该文件。如果某一层想要修改低层中的某个文件，那么它首先会将该文件复制到目标层，然后再进行修改。在下图中，我们可以看到这意味着什么：
- en: '![Figure 4.5 – Docker image using copy-on-write](img/B19199_04_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 使用写时复制的 Docker 镜像](img/B19199_04_05.jpg)'
- en: Figure 4.5 – Docker image using copy-on-write
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 使用写时复制的 Docker 镜像
- en: The second layer wants to modify **File 2**, which is present in the base layer.
    Thus, it copies it up and then modifies it. Now, let’s say that we’re sitting
    in the top layer of the preceding graphic. This layer will use **File 1** from
    the base layer and **File 2** and **File 3** from the second layer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层需要修改基础层中的**文件 2**。因此，它将文件复制到当前层并进行修改。现在，假设我们站在前面图示中的顶层。这个层将使用基础层中的**文件 1**以及第二层中的**文件
    2**和**文件 3**。
- en: Graph drivers
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形驱动程序
- en: Graph drivers are what enable the Union filesystem. Graph drivers are also called
    storage drivers and are used when dealing with layered container images. A graph
    driver consolidates multiple image layers into a root filesystem for the mount
    namespace of the container. Or, put differently, the driver controls how images
    and containers are stored and managed on the Docker host.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图形驱动程序是实现联合文件系统的关键。图形驱动程序也称为存储驱动程序，用于处理分层容器镜像。图形驱动程序将多个镜像层合并为容器的挂载命名空间的根文件系统。换句话说，驱动程序控制镜像和容器在
    Docker 主机上的存储和管理方式。
- en: Docker supports several different graph drivers using a pluggable architecture.
    The preferred driver is **overlay2,** followed by **overlay.**
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 支持多种不同的图形驱动程序，采用可插拔架构。首选的驱动程序是**overlay2**，其次是**overlay**。
- en: Now that we understand what images are, we will learn how we can create a Docker
    image ourselves.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了镜像是什么，我们将学习如何自己创建 Docker 镜像。
- en: Creating Docker images
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: There are three ways to create a new container image on your system. The first
    one is by interactively building a container that contains all the additions and
    changes you desire, and then committing those changes into a new image. The second,
    and most important, way is to use a Dockerfile to describe what’s in the new image,
    and then build the image using that Dockerfile as a manifest. Finally, the third
    way of creating an image is by importing it into the system from a tarball.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上创建新的容器镜像有三种方式。第一种是通过交互式地构建一个容器，容器中包含你想要的所有修改和新增内容，然后将这些更改提交到一个新的镜像中。第二种，也是最重要的方式，是使用
    Dockerfile 描述新镜像的内容，然后利用该 Dockerfile 作为清单来构建镜像。最后，第三种创建镜像的方式是通过从 tarball 导入镜像到系统中。
- en: Now, let’s look at these three ways in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解这三种方式。
- en: Interactive image creation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式镜像创建
- en: 'The first way we can create a custom image is by interactively building a container.
    That is, we start with a base image that we want to use as a template and run
    a container of it interactively. Let’s say that this is the Alpine image:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建自定义镜像的第一种方式是通过交互式构建一个容器。也就是说，我们从想要作为模板的基础镜像开始，并交互式地运行该容器。假设我们使用的是 Alpine
    镜像：
- en: 'The command to run the container would be as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行该容器的命令如下：
- en: '[PRE0]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command runs a container based on the `alpine:3.17` image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令基于 `alpine:3.17` 镜像运行一个容器。
- en: We run the container interactively with an attached `-it` parameter, name it
    `sample` with the `--name` parameter, and finally run a shell inside the container
    using `/bin/sh`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过附加 `-it` 参数以交互模式运行容器，通过 `--name` 参数将其命名为 `sample`，最后在容器内运行一个 shell，命令是 `/bin/sh`。
- en: 'In the Terminal window where you ran the preceding command, you should see
    something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行上述命令的终端窗口中，应该能看到类似以下内容：
- en: '![Figure 4.6 – Alpine container in interactive mode](img/B19199_04_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 交互模式下的 Alpine 容器](img/B19199_04_06.jpg)'
- en: Figure 4.6 – Alpine container in interactive mode
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 交互模式下的 Alpine 容器
- en: By default, the Alpine container does not have the `curl` tool installed. Let’s
    assume we want to create a new custom image that has `curl` installed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Alpine 容器没有安装`curl`工具。假设我们想创建一个新的自定义镜像，其中安装了`curl`。
- en: 'Inside the container, we can then run the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内，我们可以运行以下命令：
- en: '[PRE1]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command first updates the Alpine package manager, `apk`, and
    then it installs the `curl` tool. The output of the preceding command should look
    approximately like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令首先更新了 Alpine 包管理器`apk`，然后安装了`curl`工具。该命令的输出应该大致如下：
- en: '![Figure 4.7 – Installing curl on Alpine](img/B19199_04_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 在 Alpine 上安装 curl](img/B19199_04_07.jpg)'
- en: Figure 4.7 – Installing curl on Alpine
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 在 Alpine 上安装 curl
- en: 'Now, we can indeed use `curl`, as the following code snippet shows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们确实可以使用`curl`，如下所示的代码片段所示：
- en: '![Figure 4.8 – Using curl from within the container](img/B19199_04_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 在容器内使用 curl](img/B19199_04_08.jpg)'
- en: Figure 4.8 – Using curl from within the container
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 在容器内使用 curl
- en: With the preceding command, we have contacted the Google home page, and with
    the `-I` parameter, we have told `curl` to only output the response headers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述命令，我们已访问了 Google 首页，并通过`-I`参数告诉`curl`只输出响应头。
- en: Once we have finished our customization, we can quit the container by typing
    `exit` at the prompt or hitting Ctrl + D.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了自定义配置，可以通过在提示符下输入`exit`或按 Ctrl + D 来退出容器。
- en: 'Now, if we list all containers with the `docker container ls -a` command, we
    will see that our sample container has a status of `Exited`, but still exists
    on the system, as shown in the following code block:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们使用`docker container ls -a`命令列出所有容器，我们会看到我们的示例容器的状态为`Exited`，但仍然存在于系统中，如下所示的代码块所示：
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should output something similar to this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该输出类似于以下内容的内容：
- en: '[PRE3]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to see what has changed in our container concerning the base image,
    we can use the `docker container diff` command, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想查看相对于基础镜像我们的容器发生了哪些变化，可以使用`docker container diff`命令，如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should present a list of all modifications done on the filesystem
    of the container, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应展示在容器文件系统上所做的所有修改列表，如下所示：
- en: '![Figure 4.9 – Output of the docker diff command (truncated)](img/B19199_04_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – docker diff 命令的输出（截断）](img/B19199_04_09.jpg)'
- en: Figure 4.9 – Output of the docker diff command (truncated)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – docker diff 命令的输出（截断）
- en: We have shortened the preceding output for better readability. In the list,
    `A` stands for added, and `C` stands for changed. If we had any deleted files,
    then those would be prefixed with `D`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将前述输出进行了简化，以提高可读性。在列表中，`A`代表添加，`C`代表更改。如果有任何删除的文件，它们会以`D`为前缀。
- en: 'We can now use the `docker container commit` command to persist our modifications
    and create a new image from them, like this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`docker container commit`命令来保存我们的修改，并从中创建一个新镜像，如下所示：
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output generated by the preceding command on the author’s computer is as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令在作者计算机上生成的输出如下：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the preceding command, we have specified that the new image will be called
    `my-alpine`. The output generated by the preceding command corresponds to the
    ID of the newly generated image.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述命令时，我们指定了新镜像的名称为`my-alpine`。前述命令生成的输出对应于新生成镜像的 ID。
- en: 'We can verify this by listing all the images on our system, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过列出系统上的所有镜像来验证这一点，如下所示：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see this image ID as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下所示查看该镜像的 ID：
- en: '![Figure 4.10 – Listing all Docker images](img/B19199_04_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 列出所有 Docker 镜像](img/B19199_04_10.jpg)'
- en: Figure 4.10 – Listing all Docker images
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 列出所有 Docker 镜像
- en: We can see that the image named `my-alpine` has the expected ID of `5287bccbb301`
    (corresponding to the first part of the full hash code) and automatically got
    a tag of `latest` assigned. This happened since we did not explicitly define a
    tag ourselves. In this case, Docker always defaults to the `latest` tag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到名为`my-alpine`的镜像具有预期的 ID `5287bccbb301`（对应完整哈希码的前半部分），并自动获得了`latest`标签，因为我们没有显式地定义标签。在这种情况下，Docker
    总是默认为`latest`标签。
- en: 'If we want to see how our custom image has been built, we can use the `history`
    command, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想查看自定义镜像的构建过程，可以使用`history`命令，如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will print a list of the layers our image consists of, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出我们镜像所包含的所有层，具体如下：
- en: '![Figure 4.11 – History of the my-alpine Docker image](img/B19199_04_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – my-alpine Docker 镜像的历史记录](img/B19199_04_11.jpg)'
- en: Figure 4.11 – History of the my-alpine Docker image
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – my-alpine Docker 镜像的历史
- en: The top layer – marked in red – in the preceding output is the one that we just
    created by adding the `curl` package. The other two lines stem from the original
    build of the Alpine 3.17 Docker image. It was created and uploaded 4 days ago.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上面输出中的顶层 —— 用红色标记 —— 就是我们刚刚通过添加 `curl` 包所创建的层。其他两行来自原始构建的 Alpine 3.17 Docker
    镜像。它是在 4 天前创建并上传的。
- en: Now that we have seen how we can interactively create a Docker image, let’s
    look into how we can do the same declaratively using a Dockerfile.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何交互式地创建 Docker 镜像，让我们看看如何使用 Dockerfile 以声明式的方式做到这一点。
- en: Using Dockerfiles
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dockerfiles
- en: 'Manually creating custom images, as shown in the previous section of this chapter,
    is very helpful when doing exploration, creating prototypes, or authoring feasibility
    studies. But it has a serious drawback: it is a manual process and thus is not
    repeatable or scalable. It is also error-prone, just like any other task executed
    manually by humans. There must be a better way.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建自定义镜像，如本章前面所示，在进行探索、创建原型或编写可行性研究时非常有用。但它有一个严重的缺点：这是一个手动过程，因此不可重复或不可扩展。它也容易出错，就像任何其他由人类手动执行的任务一样。一定有更好的方法。
- en: This is where the so-called Dockerfile comes into play. A `Dockerfile` is a
    text file that, by default, is called `Dockerfile`. It contains instructions on
    how to build a custom container image. It is a declarative way of building images.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的 Dockerfile 发挥作用的地方。`Dockerfile` 是一个文本文件，默认名称为 `Dockerfile`。它包含了构建自定义容器镜像的指令。这是一种声明式的镜像构建方式。
- en: Declarative versus imperative
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式与命令式
- en: In computer science in general, and with Docker specifically, you often use
    a declarative way of defining a task. You describe the expected outcome and let
    the system figure out how to achieve this goal, rather than giving step-by-step
    instructions to the system on how to achieve this desired outcome. The latter
    is an imperative approach.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在计算机科学中，尤其是在 Docker 中，你通常使用声明式的方式来定义任务。你描述预期的结果，并让系统去决定如何实现这个目标，而不是一步步地给系统提供实现该目标的指令。后者是命令式方法。
- en: 'Let’s look at a sample Dockerfile, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例 Dockerfile，如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a Dockerfile as it is used to containerize a Python 3.12 application.
    As we can see, the file has six lines, each starting with a keyword such as `FROM`,
    `RUN`, or `COPY`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Dockerfile，用于将 Python 3.12 应用程序容器化。如我们所见，文件有六行，每一行都以 `FROM`、`RUN` 或 `COPY`
    等关键字开头。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is a convention to write the keywords in all caps, but that is not a must.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常约定将关键字写成大写字母，但这并不是强制要求。
- en: 'Each line of the Dockerfile results in a layer in the resulting image. In the
    following figure, the image is drawn upside down compared to the previous figures
    in this chapter, showing an image as a stack of layers. Here, the base layer is
    shown on top. Don’t let yourself be confused by this. In reality, the base layer
    is always the lowest in the stack:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 的每一行都会在生成的镜像中产生一个层。在下图中，镜像的展示方式与本章前面的图有所不同，显示为一个层叠的镜像堆栈。这里，基础层显示在顶部。不要被这个图形弄混淆。实际上，基础层总是在堆栈中位于最底部：
- en: '![Figure 4.12 – The relationship between a Dockerfile and the layers in an
    image](img/B19199_04_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – Dockerfile 与镜像中的层之间的关系](img/B19199_04_12.jpg)'
- en: Figure 4.12 – The relationship between a Dockerfile and the layers in an image
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – Dockerfile 与镜像中的层之间的关系
- en: Now, let’s look at the individual keywords in more detail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看每个关键字。
- en: The FROM keyword
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FROM 关键字
- en: 'Every Dockerfile starts with the `FROM` keyword. With it, we define which base
    image we want to start building our custom image from. If we want to build starting
    with CentOS 7, for example, we would have the following line in the Dockerfile:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Dockerfile 都以 `FROM` 关键字开头。通过它，我们定义了从哪个基础镜像开始构建我们的自定义镜像。例如，如果我们想从 CentOS
    7 开始构建，我们会在 Dockerfile 中加入以下这一行：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On Docker Hub, there are curated or official images for all major Linux distros,
    as well as for all important development frameworks or languages, such as Python,
    Node.js, Ruby, Go, and many more. Depending on our needs, we should select the
    most appropriate base image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Hub 上，所有主要的 Linux 发行版都有经过精心挑选或官方发布的镜像，此外，还有很多重要的开发框架或语言的镜像，如 Python、Node.js、Ruby、Go
    等等。根据我们的需求，我们应该选择最合适的基础镜像。
- en: For example, if I want to containerize a Python 3.12 application, I might want
    to select the relevant official `python:3.12` image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想将一个Python 3.12应用程序容器化，我可能会选择相关的官方`python:3.12`镜像。
- en: 'If we want to start from scratch, we can also use the following statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从头开始，也可以使用以下语句：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is useful in the context of building super-minimal images that only –
    for example – contain a single binary: the actual statically linked executable,
    such as `Hello-World`. The scratch image is an empty base image.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建超简小镜像时非常有用，这些镜像仅包含一个二进制文件——例如——实际的静态链接可执行文件，如`Hello-World`。`scratch`镜像是一个空的基础镜像。
- en: '`FROM scratch`, in reality, is a no-op in the Dockerfile, and as such does
    not generate a layer in the resulting container image.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM scratch`实际上在Dockerfile中是一个无操作命令，因此不会在最终的容器镜像中生成层。'
- en: The RUN keyword
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RUN关键字
- en: 'The next important keyword is `RUN`. The argument for `RUN` is any valid Linux
    command, such as the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的关键字是`RUN`。`RUN`的参数是任何有效的Linux命令，例如以下内容：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding command is using the `yum` CentOS package manager to install
    the `wget` package into the running container. This assumes that our base image
    is CentOS or **Red Hat Enterprise Linux** (**RHEL**). If we had Ubuntu as our
    base image, then the command would look similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用`yum` CentOS包管理器将`wget`包安装到正在运行的容器中。假设我们的基础镜像是CentOS或**红帽企业Linux**（**RHEL**）。如果我们的基础镜像是Ubuntu，那么命令会类似如下：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It would look like this because Ubuntu uses `apt-get` as a package manager.
    Similarly, we could define a line with `RUN`, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它会像这样，因为Ubuntu使用`apt-get`作为包管理器。同样，我们也可以使用`RUN`定义一个类似的命令，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We could also do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样做：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, the former creates an `/app` folder in the container and navigates to
    it, and the latter un-tars a file to a given location. It is completely fine,
    and even recommended, for you to format a Linux command using more than one physical
    line, such as this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，前者在容器中创建一个`/app`文件夹并切换到该目录，后者将一个文件解包到指定位置。完全可以，并且推荐你使用多行物理行来格式化Linux命令，例如这样：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we use more than one line, we need to put a backslash (`\`) at the end of
    the lines to indicate to the shell that the command continues on the next line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用多行命令，我们需要在行末加上反斜杠（`\`），以指示shell命令将在下一行继续。
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Try to find out what the preceding command does.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出前面的命令在做什么。
- en: The COPY and ADD keywords
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: COPY和ADD关键字
- en: The `COPY` and `ADD` keywords are very important since, in the end, we want
    to add some content to an existing base image to make it a custom image. Most
    of the time, these are a few source files of – say – a web application, or a few
    binaries of a compiled application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`和`ADD`关键字非常重要，因为最终我们想在现有的基础镜像上添加一些内容，使其成为一个自定义镜像。通常，这些内容可能是一些源文件——比如说——一个Web应用程序，或者一些已编译应用程序的二进制文件。'
- en: These two keywords are used to copy files and folders from the host into the
    image that we’re building. The two keywords are very similar, with the exception
    that the `ADD` keyword also lets us copy and unpack `TAR` files, as well as provide
    an URI as a source for the files and folders to copy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个关键字用于将文件和文件夹从主机复制到我们正在构建的镜像中。两个关键字非常相似，唯一的区别是`ADD`关键字还允许我们复制并解包`TAR`文件，并可以提供URI作为复制文件和文件夹的源。
- en: 'Let’s look at a few examples of how these two keywords can be used, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些这两个关键字使用的示例，如下所示：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding lines of code, the following applies:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，以下内容适用：
- en: The first line copies all files and folders from the current directory recursively
    to the `app` folder inside the container image
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将当前目录中的所有文件和文件夹递归地复制到容器镜像中的`app`文件夹。
- en: The second line copies everything in the `web` subfolder to the target folder,
    `/app/web`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行将`web`子文件夹中的所有内容复制到目标文件夹`/app/web`。
- en: The third line copies a single file, `sample.txt`, into the target folder, `/data`,
    and at the same time, renames it `my-sample.txt`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行将单个文件`sample.txt`复制到目标文件夹`/data`，同时将其重命名为`my-sample.txt`。
- en: The fourth statement unpacks the `sample.tar` file into the target folder, `/app/bin`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四条语句将`sample.tar`文件解包到目标文件夹`/app/bin`。
- en: Finally, the last statement copies the remote file, `sample.txt`, into the target
    file, `/data`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一条语句将远程文件`sample.txt`复制到目标文件`/data`。
- en: 'Wildcards are allowed in the source path. For example, the following statement
    copies all files starting with `sample` to the `mydir` folder inside the image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在源路径中允许使用通配符。例如，下面的语句将所有以`sample`开头的文件复制到镜像中的`mydir`文件夹：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From a security perspective, it is important to know that, by default, all
    files and folders inside the image will have a `ADD` and `COPY`, we can change
    the ownership that the files will have inside the image using the optional `--chown`
    flag, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，重要的是要知道，默认情况下，镜像中的所有文件和文件夹都会执行`ADD`和`COPY`，我们可以使用可选的`--chown`标志来更改文件在镜像中的所有权，如下所示：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding statement will copy all files starting with `web` and put them
    into the `/app/data` folder in the image, and at the same time assign user 11
    and group 22 to these files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将复制所有以`web`开头的文件，并将它们放入镜像中的`/app/data`文件夹，同时将用户11和组22赋予这些文件。
- en: Instead of numbers, we could also use names for the user and group, but then
    these entities would have to be already defined in the root filesystem of the
    image at `/etc/passwd` and `/etc/group`, respectively; otherwise, the build of
    the image would fail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以使用数字，也可以使用用户名和组名，但这些实体必须已经在镜像的根文件系统中的`/etc/passwd`和`/etc/group`中定义；否则，镜像的构建将失败。
- en: The WORKDIR keyword
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`WORKDIR`关键字'
- en: 'The `WORKDIR` keyword defines the working directory or context that is used
    when a container is run from our custom image. So, if I want to set the context
    to the `/app/bin` folder inside the image, my expression in the Dockerfile would
    have to look as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`关键字定义了当从我们的自定义镜像运行容器时使用的工作目录或上下文。所以，如果我想将上下文设置为镜像中的`/app/bin`文件夹，我在Dockerfile中的表达式应该如下所示：'
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All activity that happens inside the image after the preceding line will use
    this directory as the working directory. It is very important to note that the
    following two snippets from a Dockerfile are not the same:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行之后，镜像内发生的所有活动都将使用这个目录作为工作目录。需要特别注意的是，下面两段来自Dockerfile的代码并不相同：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compare the preceding code with the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码与以下代码进行对比：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The former will create the file in the root of the image filesystem, while the
    latter will create the file at the expected location in the `/app/bin` folder.
    Only the `WORKDIR` keyword sets the context across the layers of the image. The
    `cd` command alone is not persisted across layers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前者将在镜像文件系统的根目录创建文件，而后者将在预期位置`/app/bin`文件夹中创建文件。只有`WORKDIR`关键字会在镜像的各个层之间设置上下文。单独使用`cd`命令不会在层之间持久化。
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is completely fine to change the current working directory multiple times
    in a Dockerfile.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中多次更改当前工作目录是完全可以的。
- en: The CMD and ENTRYPOINT keywords
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`CMD`和`ENTRYPOINT`关键字'
- en: The `CMD` and `ENTRYPOINT` keywords are special. While all other keywords defined
    for a Dockerfile are executed at the time the image is built by the Docker builder,
    these two are definitions of what will happen when a container is started from
    the image we define. When the container runtime starts a container, it needs to
    know what the process or application will be that has to run inside that container.
    That is exactly what `CMD` and `ENTRYPOINT` are used for – to tell Docker what
    the start process is and how to start that process.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`和`ENTRYPOINT`关键字是特殊的。其他所有Dockerfile中定义的关键字都是在Docker构建器构建镜像时执行的，而这两个关键字定义的是当容器从我们定义的镜像启动时将发生的操作。当容器运行时，它需要知道容器内将运行的进程或应用程序。这正是`CMD`和`ENTRYPOINT`的用途——告诉Docker启动进程是什么，以及如何启动该进程。'
- en: Now, the differences between `CMD` and `ENTRYPOINT` are subtle, and honestly,
    most users don’t fully understand them or use them in the intended way. Luckily,
    in most cases, this is not a problem and the container will run anyway; it’s just
    handling it that is not as straightforward as it could be.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`CMD`和`ENTRYPOINT`之间的区别非常微妙，说实话，大多数用户并不完全理解它们或以预期的方式使用它们。幸运的是，在大多数情况下，这不是问题，容器仍然会运行；只是处理起来没有想象中的那么直接。
- en: 'To better understand how to use these two keywords, let’s analyze what a typical
    Linux command or expression looks like. Let’s take the `ping` utility as an example,
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用这两个关键字，让我们分析一下一个典型的Linux命令或表达式是什么样的。我们以`ping`工具为例，如下所示：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding expression, `ping` is the command, and `-c 3 8.8.8.8` are
    the parameters of this com[mand. Let’s look at another expression](http://example.com/downloads/script.sh)
    here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，`ping` 是命令，`-c 3 8.8.8.8` 是该命令的参数。我们在这里看另一个表达式：[点击这里查看](http://example.com/downloads/script.sh)：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, in the preceding expression, `wget` is the command, and `-O - http://example.com/downloads/script.sh`
    are the parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，`wget` 是命令，`-O - http://example.com/downloads/script.sh` 是参数。
- en: 'Now that we have dealt with this, we can get back to `CMD` and `ENTRYPOINT`.
    `ENTRYPOINT` is used to define the command of the expression, while `CMD` is used
    to define the parameters for the command. Thus, a Dockerfile using Alpine as the
    base image and defining `ping` as the process to run in the container could look
    like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这个之后，我们可以回到 `CMD` 和 `ENTRYPOINT`。`ENTRYPOINT` 用于定义表达式的命令，而 `CMD` 用于定义命令的参数。因此，一个使用
    Alpine 作为基础镜像并将 `ping` 定义为容器中运行的进程的 Dockerfile 可能如下所示：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For both `ENTRYPOINT` and `CMD`, the values are formatted as a JSON array of
    strings, where the individual items correspond to the tokens of the expression
    that are separated by whitespace. This is the preferred way of defining `CMD`
    and `ENTRYPOINT`. It is also called the exec form.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ENTRYPOINT` 和 `CMD`，其值格式化为一个字符串的 JSON 数组，其中每个项对应于通过空格分隔的表达式中的各个令牌。这是定义 `CMD`
    和 `ENTRYPOINT` 的推荐方式，也称为 exec 形式。
- en: 'Alternatively, we can use what’s called the shell form, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用所谓的 shell 形式，如下所示：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now build an image called `pinger` from the preceding Dockerfile, as
    follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以根据前面的 Dockerfile 构建一个名为 `pinger` 的镜像，如下所示：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is the output generated by the preceeding command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面命令生成的输出：
- en: '![Figure 4.13 – Building the pinger Docker image](img/B19199_04_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 构建 pinger Docker 镜像](img/B19199_04_13.jpg)'
- en: Figure 4.13 – Building the pinger Docker image
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 构建 pinger Docker 镜像
- en: 'Then, we can run a container from the pinger image we just created, like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从刚才创建的 pinger 镜像中运行一个容器，像这样：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure 4.14 – Output of the pinger container](img/B19199_04_14.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – pinger 容器的输出](img/B19199_04_14.jpg)'
- en: Figure 4.14 – Output of the pinger container
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – pinger 容器的输出
- en: In the preceding command, we are using the `--rm` parameter, which defines that
    the container is automatically removed once the applications inside the container
    end.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了 `--rm` 参数，定义了容器在其中的应用程序结束后会自动删除。
- en: 'The beauty of this is that I can now override the CMD part that I have defined
    in the Dockerfile (remember, it was `["-c", "3","8.8.8.8"]`) when I create a new
    container by adding the new values at the end of the `docker container run` expression,
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，现在我可以在创建新容器时，通过在 `docker container run` 表达式的末尾添加新值来覆盖我在 Dockerfile 中定义的
    CMD 部分（记住，它是 `["-c", "3","8.8.8.8"]`），像这样：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will cause the container to ping the loopback IP address (`127.0.0.1`)
    for 5 seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使容器对回环 IP 地址（`127.0.0.1`）进行 5 秒的 ping 操作。
- en: 'If we want to override what’s defined in `ENTRYPOINT` in the Dockerfile, we
    need to use the `--entrypoint` parameter in the `docker container run` expression.
    Let’s say we want to execute a shell in the container instead of the `ping` command.
    We could do so by using the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想覆盖 Dockerfile 中 `ENTRYPOINT` 定义的内容，我们需要在 `docker container run` 表达式中使用
    `--entrypoint` 参数。假设我们想在容器中执行一个 shell，而不是 `ping` 命令。我们可以使用以下命令：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will then find ourselves inside the container. Type `exit` or press *Ctrl
    + D* to leave the container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将进入容器内。输入 `exit` 或按 *Ctrl + D* 退出容器。
- en: 'As I already mentioned, we do not necessarily have to follow best practices
    and define the command through `ENTRYPOINT` and the parameters through `CMD`;
    instead, we can enter the whole expression as a value of `CMD` and it will work,
    as shown in the following code block:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们不一定要遵循最佳实践，通过 `ENTRYPOINT` 定义命令，通过 `CMD` 定义参数；相反，我们可以将整个表达式作为 `CMD`
    的值，它也能正常工作，如以下代码块所示：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, I have even used the shell form to define CMD. But what happens in this
    situation if `ENTRYPOINT` is undefined? If you leave `ENTRYPOINT` undefined, then
    it will have the default value of `/bin/sh -c`, and whatever the value of `CMD`
    is will be passed as a string to the shell command. The preceding definition would
    thereby result in entering the following code to run the process inside the container:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我甚至使用了 shell 形式来定义 CMD。但如果 `ENTRYPOINT` 未定义，发生什么情况呢？如果你不定义 `ENTRYPOINT`，它将默认为
    `/bin/sh -c`，无论 `CMD` 的值是什么，它都会作为字符串传递给 shell 命令。前面的定义因此会导致进入以下代码来在容器内运行该进程：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Consequently, `/bin/sh` is the main process running inside the container, and
    it will start a new child process to run the `wget` utility.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`/bin/sh` 是容器内运行的主进程，它将启动一个新的子进程来运行 `wget` 工具。
- en: A complex Dockerfile
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个复杂的 Dockerfile
- en: 'So far, we have discussed the most important keywords commonly used in Dockerfiles.
    Now, let’s look at a realistic and somewhat complex example of a Dockerfile. Those
    of you who are interested might note that it looks very similar to the first Dockerfile
    that we presented in this chapter. Here is its content:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了在 Dockerfile 中常用的最重要的关键字。现在，让我们看一个现实且稍微复杂的 Dockerfile 示例。对感兴趣的朋友来说，可能会注意到它看起来与我们在本章中展示的第一个
    Dockerfile 非常相似。以下是它的内容：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: OK; so, what is happening here? This is a Dockerfile that is used to build an
    image for a Node.js application; we can deduce this from the fact that the `node:19-buster-slim`
    base image is used. Then, the second line is an instruction to create an `/app`
    folder in the filesystem of the image. The third line defines the working directory
    or context in the image to be this new `/app` folder. Then, on line four, we copy
    a `package.json` file into the `/app` folder inside the image. After this, on
    line five, we execute the `npm install` command inside the container; remember,
    our context is the `/app` folder, so `npm` will find the `package.json` file there
    that we copied on line four.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么这里到底发生了什么？这是一个用于构建 Node.js 应用程序镜像的 Dockerfile；我们可以从使用的基础镜像 `node:19-buster-slim`
    推断出这一点。接着，第二行是一个指令，用于在镜像的文件系统中创建一个 `/app` 文件夹。第三行定义了镜像中的工作目录或上下文为这个新的 `/app` 文件夹。然后，在第四行，我们将一个
    `package.json` 文件复制到镜像中的 `/app` 文件夹内。此后，在第五行，我们在容器内执行 `npm install` 命令；记住，我们的上下文是
    `/app` 文件夹，所以 `npm` 会在那里找到我们在第四行复制的 `package.json` 文件。
- en: Once all the Node.js dependencies have been installed, we copy the rest of the
    application files from the current folder of the host into the `/app` folder of
    the image.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有的 Node.js 依赖项安装完毕，我们将从主机的当前文件夹中复制其余的应用程序文件到镜像的 `/app` 文件夹内。
- en: Finally, in the last two lines, we define what the startup command will be when
    a container is run from this image. In our case, it is `npm start`, which will
    start the Node.js application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后两行中，我们定义了从这个镜像运行容器时的启动命令。在我们的例子中，它是 `npm start`，将启动 Node.js 应用程序。
- en: Building an image
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Let’s look at a concrete example and build a simple Docker image, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的示例并构建一个简单的 Docker 镜像，如下所示：
- en: 'Navigate to the sample code repository. Normally, this should be located in
    your home folder:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到示例代码库。通常它应该位于你的主文件夹中：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new subfolder for [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083)
    and navigate to it:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[*第 4 章*](B19199_04.xhtml#_idTextAnchor083)创建一个新的子文件夹并进入：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding folder, create a `sample1` subfolder and navigate to it, like
    this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的文件夹中，创建一个 `sample1` 子文件夹并进入，如下所示：
- en: '[PRE36]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use your favorite editor to create a file called `Dockerfile` inside this sample
    folder, with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器在这个示例文件夹中创建一个名为 `Dockerfile` 的文件，内容如下：
- en: '[PRE37]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save the file and exit your editor.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出编辑器。
- en: 'Back in the Terminal window, we can now build a new container image using the
    preceding Dockerfile as a manifest or construction plan, like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端窗口，我们现在可以使用前面的 Dockerfile 作为清单或构建计划来构建一个新的容器镜像，如下所示：
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Please note that there is a period (`.`) at the end of the preceding command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令末尾有一个句点（`.`）：
- en: '![Figure 4.15 – Building our first custom image from CentOS](img/B19199_04_15.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 从 CentOS 构建我们的第一个自定义镜像](img/B19199_04_15.jpg)'
- en: Figure 4.15 – Building our first custom image from CentOS
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 从 CentOS 构建我们的第一个自定义镜像
- en: 'The previous command means that the Docker builder creates a new image called
    `my-centos` using the Dockerfile that is present in the current directory. Here,
    the period at the end of the command specifies the current directory. We could
    also write the preceding command as follows, with the same result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的意思是 Docker 构建器使用当前目录中的 Dockerfile 创建一个名为 `my-centos` 的新镜像。这里，命令末尾的句点指定了当前目录。我们也可以将前面的命令写成以下形式，结果是一样的：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we can omit the `-f` parameter since the builder assumes that the Dockerfile
    is called `Dockerfile`. We only ever need the `-f` parameter if our Dockerfile
    has a different name or is not located in the current directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以省略 `-f` 参数，因为构建器假定 Dockerfile 的文件名就是 `Dockerfile`。只有当我们的 Dockerfile
    名称不同或不在当前目录时，才需要使用 `-f` 参数。
- en: 'Let’s analyze the output shown in *Figure 4**.15*. This output is created by
    the Docker build kit:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下在 *图 4.15* 中显示的输出。这些输出是由 Docker 构建工具生成的：
- en: 'First, we have the following line:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有以下一行：
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This line is generated at the end of the build process, although it appears
    as the first line. It tells us that the building took approximately 22 seconds
    and was executed in 7 steps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是在构建过程结束时生成的，尽管它看起来是第一行。它告诉我们构建大约花费了 22 秒，并且执行了 7 个步骤。
- en: 'Now, let’s skip the next few lines until we reach this one:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们跳过接下来的几行，直到我们到达这一行：
- en: '[PRE41]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This line tells us which line of the Dockerfile the builder is currently executing
    (1 of 2). We can see that this is the `FROM centos:7` statement in our Dockerfile.
    This is the declaration of the base image, on top of which we want to build our
    custom image. What the builder then does is pull this image from Docker Hub, if
    it is not already available in the local cache.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉我们构建器当前正在执行 Dockerfile 的哪一行（第 1 行，共 2 行）。我们可以看到这就是 Dockerfile 中的 `FROM
    centos:7` 语句。这是声明基础镜像，我们希望在其上构建我们的自定义镜像。接下来，构建器会从 Docker Hub 拉取该镜像，如果它在本地缓存中尚不存在的话。
- en: 'Now, follow the next step. I have shortened it even more than the preceding
    one to concentrate on the essential part:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续执行下一步。我已经将它缩短得比前一步还要简洁，专注于最关键的部分：
- en: '[PRE42]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is our second line in the Dockerfile, where we want to use the `yum` package
    manager to install the `wget` utility.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 Dockerfile 中的第二行，我们希望使用 `yum` 包管理器来安装 `wget` 工具。
- en: 'The last few lines are as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后几行如下所示：
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the builder finalizes building the image and provides the image with the
    `sha256` code of `8eb6daefac9...`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，构建器完成了镜像的构建，并提供了该镜像的 `sha256` 代码 `8eb6daefac9...`。
- en: This tells us that the resulting custom image has been given an ID of `8eb6daefac9...`
    and has been tagged with `my-centos:latest`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，生成的自定义镜像已被赋予 ID `8eb6daefac9...`，并且已标记为 `my-centos:latest`。
- en: Now that we have analyzed how the build process of a Docker image works and
    what steps are involved, let’s talk about how to further improve this by introducing
    multi-step builds.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了 Docker 镜像构建过程的工作原理以及涉及的步骤，让我们谈谈如何通过引入多步骤构建来进一步优化这个过程。
- en: Multi-step builds
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多步骤构建
- en: 'To demonstrate why a Dockerfile with multiple build steps is useful, let’s
    make an example Dockerfile. Let’s take a Hello World application written in C:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示为什么一个包含多个构建步骤的 Dockerfile 有用，让我们做一个示例 Dockerfile。让我们以一个用 C 语言编写的 Hello World
    应用程序为例：
- en: 'Open a new Terminal window and navigate to this chapter’s folder:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并导航到本章的文件夹：
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a new folder called `multi-step-build` in your chapter folder:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的章节文件夹中创建一个名为 `multi-step-build` 的新文件夹：
- en: '[PRE45]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open VS Code for this folder:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 来处理这个文件夹：
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a file called `hello.c` in this folder and add the following code to
    it:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中创建一个名为 `hello.c` 的文件，并添加以下代码：
- en: '[PRE47]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we want to containerize this application and write a Dockerfile with this
    content:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们要将这个应用程序容器化，并编写一个包含以下内容的 Dockerfile：
- en: '[PRE48]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, let’s build this image:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建这个镜像：
- en: '[PRE49]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This gives us a fairly long output since the builder has to install the Alpine
    **Software Development Kit** (**SDK**), which, among other tools, contains the
    C++ compiler we need to build the application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建器需要安装 Alpine **软件开发工具包**（**SDK**），其中包括我们需要的 C++ 编译器来构建应用程序，因此这会产生相当长的输出。
- en: 'Once the build is done, we can list the image and see the size that’s been
    shown, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以列出镜像并查看显示的大小，如下所示：
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the author’s case, the output is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的情况下，输出如下所示：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With a size of 215 MB, the resulting image is way too big. In the end, it is
    just a Hello World application. The reason for it being so big is that the image
    not only contains the Hello World binary but also all the tools to compile and
    link the application from the source code. But this is not desirable when running
    the application, say, in production. Ideally, we only want to have the resulting
    binary in the image and not a whole SDK.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的镜像大小为 215 MB，显然太大了。最终，它只是一个 Hello World 应用程序。镜像之所以如此之大，是因为它不仅包含了 Hello World
    的二进制文件，还包括了所有编译和链接应用程序所需的工具。但是在生产环境中运行应用程序时，这种做法并不理想。理想情况下，我们只希望镜像中包含最终的二进制文件，而不是整个
    SDK。
- en: 'It is precisely for this reason that we should define Dockerfiles as multi-stage.
    We have some stages that are used to build the final artifacts, and then a final
    stage, where we use the minimal necessary base image and copy the artifacts into
    it. This results in very small Docker images. Let’s do this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为如此，我们应该将 Dockerfile 定义为多阶段构建。我们有一些阶段用于构建最终的工件，然后在最终阶段中，我们使用最小必要的基础镜像并将工件复制到其中。这将生成非常小的
    Docker 镜像。让我们来做一下：
- en: 'Create a new Dockerfile to your folder called `Dockerfile.multi-step` with
    this content:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件夹中创建一个新的 Dockerfile，命名为 `Dockerfile.multi-step`，并添加以下内容：
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have the first stage with an alias called `build`, which is used to
    compile the application; then, the second stage uses the same `alpine:3.12` base
    image but does not install the SDK, and only copies the binary from the `build`
    stage, using the `--from` parameter, into this final image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有第一个阶段，别名为 `build`，用于编译应用程序；然后，第二个阶段使用相同的 `alpine:3.12` 基础镜像，但没有安装 SDK，只是从
    `build` 阶段复制二进制文件，使用 `--from` 参数，将其复制到最终的镜像中。
- en: 'Let’s build the image again, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照如下方式再次构建镜像：
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s compare the sizes of the images with this command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过以下命令来比较镜像的大小：
- en: '[PRE54]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we get the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了以下输出：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have been able to reduce the size from 215 MB down to 5.34 MB. This is a
    reduction in size by a factor of approximately 40\. A smaller image has many advantages,
    such as a smaller attack surface area for hackers, reduced memory and disk consumption,
    faster startup times for the corresponding containers, and a reduction of the
    bandwidth needed to download the image from a registry, such as Docker Hub.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将镜像的大小从 215 MB 降到了 5.34 MB。这相当于减少了约 40 倍的大小。更小的镜像有许多优势，比如为黑客提供更小的攻击面、更低的内存和磁盘消耗、更快的容器启动时间，以及减少从镜像仓库（如
    Docker Hub）下载镜像所需的带宽。
- en: Dockerfile best practices
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dockerfile 最佳实践
- en: 'There are a few recommended best practices to consider when authoring a Dockerfile,
    which are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Dockerfile 时，有一些推荐的最佳实践需要考虑，具体如下：
- en: First and foremost, we need to consider that containers are meant to be ephemeral.
    By ephemeral, we mean that a container can be stopped and destroyed, and a new
    one built and put in place with the absolute minimum setup and configuration.
    That means that we should try hard to keep the time that is needed to initialize
    the application running inside the container at a minimum, as well as the time
    needed to terminate or clean up the application.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑的是，容器本身是暂时性的。所谓暂时性，是指容器可以被停止和销毁，接着可以构建一个新的容器并用最少的设置和配置投入使用。这意味着我们应该尽量减少初始化容器内应用程序所需的时间，以及终止或清理应用程序所需的时间。
- en: The next best practice tells us that we should order the individual commands
    in the Dockerfile so that we leverage caching as much as possible. Building a
    layer of an image can take a considerable amount of time – sometimes many seconds,
    or even minutes. While developing an application, we will have to build the container
    image for our application multiple times. We want to keep the build times at a
    minimum.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个最佳实践告诉我们，我们应该按照一定顺序排列 Dockerfile 中的各个命令，以便尽可能利用缓存。构建镜像的一个层可能会花费相当长的时间——有时需要几秒钟，甚至几分钟。在开发应用程序时，我们需要多次构建应用程序的容器镜像。我们希望将构建时间保持在最短。
- en: 'When we’re rebuilding a previously built image, the only layers that are rebuilt
    are the ones that have changed, but if one layer needs to be rebuilt, all subsequent
    layers also need to be rebuilt. This is very important to remember. Consider the
    following example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新构建一个先前构建的镜像时，只有那些发生变化的层才会重新构建，但如果某一层需要重新构建，那么所有后续的层也需要重新构建。这一点非常重要，请记住。考虑以下示例：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In this example, the `npm install` command on line five of the Dockerfile usually
    takes the longest. A classical Node.js application has many external dependencies,
    and those are all downloaded and installed in this step. It can take minutes until
    it is done. Therefore, we want to avoid running `npm install` each time we rebuild
    the image, but a developer changes their source code all the time during the development
    of an application. That means that line four, the result of the `COPY` command,
    changes every time, and thus this layer has to be rebuilt. But as we discussed
    previously, that also means that all subsequent layers have to be rebuilt, which
    – in this case – includes the `npm install` command. To avoid this, we can slightly
    modify the Dockerfile and have the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Dockerfile中第五行的`npm install`命令通常需要较长的时间。一个经典的Node.js应用程序有许多外部依赖，这些依赖都在此步骤中下载并安装。完成这个步骤可能需要几分钟。因此，我们希望避免每次重建镜像时都运行`npm
    install`，但开发人员在应用程序开发过程中会经常更改源代码。这意味着第四行的`COPY`命令每次都会发生变化，因此这个层必须重新构建。但正如我们之前讨论的，这也意味着所有后续层必须重新构建，其中包括`npm
    install`命令。为避免这种情况，我们可以稍微修改Dockerfile，得到如下内容：
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, on line four, we only copied the single file that the `npm install` command
    needs as a source, which is the `package.json` file. This file rarely changes
    in a typical development process. As a consequence, the `npm install` command
    also has to be executed only when the `package.json` file changes. All the remaining
    frequently changed content is added to the image after the `npm` `install` command.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，我们仅复制了`npm install`命令需要的单个文件作为源文件，即`package.json`文件。在典型的开发过程中，这个文件很少发生变化。因此，`npm
    install`命令也只在`package.json`文件变化时执行。所有其他频繁变化的内容都会在执行`npm install`命令之后添加到镜像中。
- en: A further best practice is to keep the number of layers that make up your image
    relatively small. The more layers an image has, the more the graph driver needs
    to work to consolidate the layers into a single root filesystem for the corresponding
    container. Of course, this takes time, and thus the fewer layers an image has,
    the faster the startup time for the container can be.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是保持构成镜像的层数相对较小。镜像的层数越多，图形驱动程序需要处理的工作就越多，必须将这些层合并成一个根文件系统，供相应的容器使用。当然，这会耗费时间，因此，镜像的层数越少，容器的启动时间就越快。
- en: 'But how can we keep our number of layers low? Remember that in a Dockerfile,
    each line that starts with a keyword such as `FROM`, `COPY`, or `RUN` creates
    a new layer. The easiest way to reduce the number of layers is to combine multiple
    individual `RUN` commands into a single one. For example, say that we had the
    following in a Dockerfile:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何保持层数较低呢？记住，在Dockerfile中，每个以`FROM`、`COPY`或`RUN`等关键字开头的行都会创建一个新层。减少层数的最简单方法是将多个独立的`RUN`命令合并为一个。例如，假设我们的Dockerfile中有如下内容：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We could combine these into a single concatenated expression, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它们合并成一个单一的连接表达式，如下所示：
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The former will generate three layers in the resulting image, while the latter
    will only create a single layer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前者将在生成的镜像中产生三个层，而后者只会创建一个层。
- en: 'The next three best practices all result in smaller images. Why is this important?
    Smaller images reduce the time and bandwidth needed to download the image from
    a registry. They also reduce the amount of disk space needed to store a copy locally
    on the Docker host and the memory needed to load the image. Finally, smaller images
    also mean a smaller attack surface for hackers. Here are the best practices mentioned:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三条最佳实践都会导致更小的镜像。这为什么很重要呢？较小的镜像减少了从注册表下载镜像所需的时间和带宽。它们还减少了在Docker主机上本地存储镜像副本所需的磁盘空间以及加载镜像所需的内存。最后，更小的镜像也意味着更小的攻击面，降低了黑客攻击的风险。以下是提到的最佳实践：
- en: The first best practice that helps reduce the image size is to use a `.dockerignore`
    file. We want to avoid copying unnecessary files and folders into an image, to
    keep it as lean as possible. A `.dockerignore` file works in the same way as a
    `.gitignore` file, for those who are familiar with Git. In a `.dockerignore` file,
    we can configure patterns to exclude certain files or folders from being included
    in the context when building the image.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于减小镜像大小的第一个最佳实践是使用`.dockerignore`文件。我们希望避免将不必要的文件和文件夹复制到镜像中，保持镜像尽可能精简。`.dockerignore`文件的作用与`.gitignore`文件类似，熟悉Git的人会很容易理解。在`.dockerignore`文件中，我们可以配置模式，排除某些文件或文件夹在构建镜像时被包含在上下文中。
- en: The next best practice is to avoid installing unnecessary packages into the
    filesystem of the image. Once again, this is to keep the image as lean as possible.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一项最佳实践是避免向镜像的文件系统中安装不必要的软件包。再次强调，这是为了保持镜像尽可能精简。
- en: Last but not least, it is recommended that you use multi-stage builds so that
    the resulting image is as small as possible and only contains the absolute minimum
    needed to run your application or application service.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，建议使用多阶段构建，这样生成的镜像会尽可能小，并且只包含运行应用程序或应用服务所需的最基本内容。
- en: In the next section, we are going to learn how to create a Docker image from
    a previously saved image. In fact, it may look like restoring an image.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何从先前保存的镜像创建 Docker 镜像。实际上，这可能看起来像是在恢复一个镜像。
- en: Saving and loading images
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载镜像
- en: 'The third way to create a new container image is by importing or loading it
    from a file. A container image is nothing more than a tarball. To demonstrate
    this, we can use the `docker image save` command to export an existing image to
    a tarball, like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新容器镜像的第三种方式是通过从文件导入或加载它。容器镜像不过是一个 tarball。为了演示这一点，我们可以使用 `docker image save`
    命令将现有镜像导出为 tarball，像这样：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding command takes our `my-alpine` image that we previously built
    and exports it into a file called `./backup/my-alpine.tar`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会将我们之前构建的 `my-alpine` 镜像导出到名为 `./backup/my-alpine.tar` 的文件中：
- en: '![Figure 4.16 – Exporting an image as a tarball](img/B19199_04_16.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 将镜像导出为 tarball](img/B19199_04_16.jpg)'
- en: Figure 4.16 – Exporting an image as a tarball
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 将镜像导出为 tarball
- en: 'If, on the other hand, we have an existing tarball and want to import it as
    an image into our system, we can use the `docker image load` command, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们已经有一个现有的 tarball 并希望将其导入系统作为镜像，我们可以使用 `docker image load` 命令，如下所示：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of the preceding command should be as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出应如下所示：
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With this, we have learned how to build a Docker image in three different ways.
    We can do so interactively, by defining a Dockerfile, or by importing it into
    our system from a tarball.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些内容，我们已经学会了三种不同的构建 Docker 镜像的方法。我们可以通过交互方式、通过定义 Dockerfile，或者通过从 tarball
    导入到我们的系统中来实现。
- en: In the next section, we will discuss how we can create Docker images for existing
    legacy applications, and thus run them in a container and profit from this.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何为现有的传统应用程序创建 Docker 镜像，从而在容器中运行它们，并从中受益。
- en: Lift and shift – containerizing a legacy app
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升与迁移 – 将传统应用容器化
- en: We can’t always start from scratch and develop a brand-new application. More
    often than not, we find ourselves with a huge portfolio of traditional applications
    that are up and running in production and provide mission-critical value to the
    company or the customers of the company. Often, those applications are organically
    grown and very complex. Documentation is sparse, and nobody wants to touch such
    an application. Often, the saying “*Never touch a running system”* applies. Yet,
    the market needs change, and with that arises the need to update or rewrite those
    apps. Often, a complete rewrite is not possible due to the lack of resources and
    time, or due to the excessive cost. What are we going to do about those applications?
    Could we possibly Dockerize them and profit from the benefits introduced by containers?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不总是能从头开始开发一个全新的应用程序。更多时候，我们会面临一个巨大的传统应用程序组合，这些应用程序已经在生产环境中运行，并且为公司或公司客户提供关键价值。这些应用程序通常是有机发展起来的，结构非常复杂。文档稀缺，没人愿意去触碰这样的应用程序。常常，“*永远不要碰一个正在运行的系统*”这句话适用。然而，市场需求发生变化，因此需要更新或重写这些应用程序。由于资源和时间的限制，或者因为成本过高，完全重写往往不可行。我们该如何处理这些应用程序呢？我们是否可以将它们
    Docker 化，并从容器带来的好处中受益？
- en: It turns out we can. In 2017, Docker introduced a program called **Modernize
    Traditional Apps** (**MTA**) to their enterprise customers, which in essence promised
    to help those customers take their existing or traditional Java and .NET applications
    and containerize them, without the need to change a single line of code. The focus
    of MTA was on Java and .NET applications since those made up the lion’s share
    of the traditional applications in a typical enterprise. But it can also be used
    for any application that was written in – say – C, C++, Python, Node.js, Ruby,
    PHP, or Go, to name just a few other languages and platforms.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明我们可以做到。在2017年，Docker向其企业客户推出了一款名为**现代化传统应用**（**MTA**）的程序，本质上承诺帮助客户将他们现有的或传统的Java和.NET应用程序容器化，而无需更改一行代码。MTA的重点是Java和.NET应用程序，因为它们在典型企业中的传统应用程序占据了大部分份额。但它也可以用于任何用其他语言和平台编写的应用程序，例如C、C++、Python、Node.js、Ruby、PHP或Go等等。
- en: Let’s imagine such a legacy application for a moment. Let’s assume we have an
    old Java application that was written 10 years ago and that was continuously updated
    during the following 5 years. The application is based on Java SE 6, which came
    out in December 2006\. It uses environment variables and property files for configuration.
    Secrets such as usernames and passwords used in the database connection strings
    are pulled from a secrets keystore, such as HashiCorp Vault.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一下这样的遗留应用程序。假设我们有一个10年前编写的旧Java应用程序，并且在接下来的5年中不断进行更新。该应用程序基于2006年12月发布的Java
    SE 6。它使用环境变量和属性文件进行配置。像用户名和密码这样的机密信息，通常通过一个机密库（例如HashiCorp Vault）来提取，用于数据库连接字符串中。
- en: Now, let’s describe each of the required steps to lift and shift a legacy application
    in more detail.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地描述一下提升和迁移遗留应用程序的每个必要步骤。
- en: Analyzing external dependencies
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析外部依赖
- en: 'One of the first steps in the modernization process is to discover and list
    all external dependencies of the legacy application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化过程的第一步之一是发现并列出遗留应用程序的所有外部依赖：
- en: Does it use a database? If so, which one? What does the connection string look
    like?
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用数据库吗？如果使用，是什么数据库？连接字符串是什么样子的？
- en: Does it use external APIs such as credit card approval or geo-mapping APIs?
    What are the API keys and key secrets?
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否使用外部API，如信用卡审批或地理定位API？API密钥和密钥密码是什么？
- en: Is it consuming from or publishing to an **Enterprise Service** **Bus** (**ESB**)?
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是从**企业服务总线**（**ESB**）消费数据，还是向其发布数据？
- en: These are just a few possible dependencies that come to mind. Many more exist.
    These are the seams of the application to the outer world, and we need to be aware
    of them and create an inventory.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是想到的几个可能的依赖项，实际上还有很多其他依赖。这些是应用程序与外部世界的连接点，我们需要意识到它们并创建一个清单。
- en: Source code and build instructions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码和构建指令
- en: The next step is to locate all the source code and other assets, such as images
    and CSS and HTML files that are part of the application. Ideally, they should
    be located in a single folder. This folder will be the root of our project and
    can have as many subfolders as needed. This project root folder will be the context
    during the build of the container image we want to create for our legacy application.
    Remember, the Docker builder only includes files in the build that are part of
    that context; in our case, that is the root project folder.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定位所有源代码和其他资产，例如图像、CSS和HTML文件，这些文件都是应用程序的一部分。理想情况下，它们应该位于一个文件夹中。这个文件夹将成为我们的项目根目录，并且可以根据需要包含多个子文件夹。这个项目根目录将在我们为遗留应用程序创建容器镜像时作为上下文。请记住，Docker构建器只会包括属于该上下文的文件；在我们的例子中，根项目文件夹就是上下文。
- en: There is, though, an option to download or copy files during the build from
    different locations, using the `COPY` or `ADD` commands. Please refer to the online
    documentation for the exact details on how to use these two commands. This option
    is useful if the sources for your legacy application cannot be easily contained
    in a single, local folder.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，确实有一个选项，可以在构建过程中从不同位置下载或复制文件，使用`COPY`或`ADD`命令。请参考在线文档，了解如何使用这两个命令的详细信息。如果遗留应用程序的源代码无法轻松包含在一个本地文件夹中，则此选项非常有用。
- en: Once we are aware of all the parts that contribute to the final application,
    we need to investigate how the application is built and packaged. In our case,
    this is most probably done by using `make` would most likely be used.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了所有组成最终应用程序的部分，我们需要调查应用程序是如何构建和打包的。在我们的案例中，这很可能是通过使用`make`来完成的。
- en: Once again, let’s extend our inventory and write down the exact build commands
    used. We will need this information later on when authoring the Dockerfile.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，让我们扩展我们的清单并记录下使用的确切构建命令。当我们编写Dockerfile时，需要使用这些信息。
- en: Configuration
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Applications need to be configured. Information provided during configuration
    could be – for example – the type of application logging to use, connection strings
    to databases, and hostnames to services such as ESBs or URIs to external APIs,
    to name just a few.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要进行配置。在配置过程中提供的信息可能包括——例如——使用的应用程序日志类型、连接数据库的连接字符串，以及服务的主机名，例如企业服务总线（ESBs）或外部API的URI，仅举几例。
- en: 'We can differentiate a few types of configurations, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分几种配置类型，如下所示：
- en: '**Build time**: This is the information needed during the build of the application
    and/or its Docker image. It needs to be available when we create the Docker images.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时**：这是在构建应用程序及/或其Docker镜像时需要的信息。在创建Docker镜像时必须提供这些信息。'
- en: '`DEVELOPMENT` versus `STAGING` or `PRODUCTION`. This kind of configuration
    is applied to the application when a container with the app starts – for example,
    in production.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`开发`与`预发布`或`生产`。这种配置在启动容器时应用于应用程序——例如，在生产环境中。'
- en: '**Runtime**: This is information that the application retrieves during runtime,
    such as secrets to access an external API.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：这是应用程序在运行时检索到的信息，例如访问外部API的机密信息。'
- en: Secrets
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密信息
- en: Every mission-critical enterprise application needs to deal with secrets in
    some form or another. The most familiar secrets are part of the connection information
    needed to access databases that are used to persist the data produced by or used
    by the application. Other secrets include the credentials needed to access external
    APIs, such as a credit score lookup API. It is important to note that, here, we
    are talking about secrets that have to be provided by the application itself to
    the service providers the application uses or depends on, and not secrets provided
    by the users of the application. The actor here is our application, which needs
    to be authenticated and authorized by external authorities and service providers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键任务的企业应用程序都需要以某种形式处理机密信息。最常见的机密信息是访问数据库所需的连接信息，这些数据库用于持久化应用程序生成或使用的数据。其他机密信息包括访问外部API所需的凭证，例如信用评分查询API。需要注意的是，在这里我们谈论的是应用程序本身需要向其使用或依赖的服务提供商提供的机密，而不是由应用程序用户提供的机密。此处的行动者是我们的应用程序，它需要经过外部权威和服务提供商的身份验证和授权。
- en: There are various ways traditional applications got their secrets. The worst
    and most insecure way of providing secrets is by hardcoding them or reading them
    from configuration files or environment variables, where they are available in
    cleartext. A much better way is to read the secrets during runtime from a special
    secret store that persists the secrets encrypted and provides them to the application
    over a secure connection, such as **Transport Layer** **Security** (**TLS**).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序获取机密信息的方式有多种。最差且最不安全的提供机密信息的方式是硬编码机密或从配置文件或环境变量中读取机密信息，在这些地方它们是明文可见的。更好的方式是在运行时从一个专门的机密存储读取这些机密，该存储会加密机密信息并通过安全连接提供给应用程序，例如**传输层**
    **安全性**（**TLS**）。
- en: 'Once again, we need to create an inventory of all the secrets that our application
    uses and the way it procures them. Thus, we need to ask ourselves where we can
    get our secrets from: is it through environment variables or configuration files,
    or is it by accessing an external keystore, such as HashiCorp Vault, AWS Secrets
    Manager, or Azure Key Vault?'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们需要创建一个清单，列出我们的应用程序使用的所有机密信息以及它们的获取方式。因此，我们需要问自己：我们的机密信息从哪里来？是通过环境变量或配置文件，还是通过访问外部密钥存储，如HashiCorp
    Vault、AWS Secrets Manager或Azure Key Vault？
- en: Authoring the Dockerfile
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Dockerfile
- en: 'Once we have a complete inventory of all the items we discussed in the previous
    few sections, we are ready to author our Dockerfile. But I want to warn you: don’t
    expect this to be a one-shot-and-go task. You may need several iterations until
    you have crafted your final Dockerfile. The Dockerfile may be rather long and
    ugly-looking, but that’s not a problem, so long as we get a working Docker image.
    We can always fine-tune the Dockerfile once we have a working version.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了前几节讨论的所有项目的完整清单，我们就准备编写Dockerfile了。但我想提醒你：不要期望这是一项一次性完成的任务。你可能需要几轮修改，直到最终制作出你的Dockerfile。Dockerfile可能会很长且看起来不太美观，但这不是问题，只要我们能够得到一个有效的Docker镜像。等我们有了一个可工作的版本后，随时可以对Dockerfile进行微调。
- en: The base image
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础镜像
- en: Let’s start by identifying the base image we want to use and build our image
    from. Is there an official Java image available that is compatible with our requirements?
    Remember that our application is based on Java SE 6\. If such a base image is
    available, then we should use that one. Otherwise, we will want to start with
    a Linux distro such as Red Hat, Oracle, or Ubuntu. In the latter case, we will
    use the appropriate package manager of the distro (`yum`, `apt`, or another) to
    install the desired versions of Java and Maven. For this, we can use the `RUN`
    keyword in the Dockerfile. Remember, `RUN` allows us to execute any valid Linux
    command in the image during the build process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从确定想要使用的基础镜像开始，并从中构建我们的镜像。是否有一个符合我们要求的官方Java镜像？记住，我们的应用程序基于Java SE 6。如果有这样的基础镜像，那么我们应该使用它。否则，我们将希望从一个Linux发行版开始，比如Red
    Hat、Oracle或Ubuntu。在后者的情况下，我们将使用该发行版的合适包管理器（`yum`、`apt`或其他）来安装所需版本的Java和Maven。为此，我们可以在Dockerfile中使用`RUN`关键字。记住，`RUN`允许我们在构建过程中执行镜像中的任何有效Linux命令。
- en: Assembling the sources
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇总源代码
- en: 'In this step, we make sure all the source files and other artifacts needed
    to successfully build the application are part of the image. Here, we mainly use
    the two keywords of the Dockerfile: `COPY` and `ADD`. Initially, the structure
    of the source inside the image should look the same as on the host, to avoid any
    build problems. Ideally, you would have a single `COPY` command that copies all
    of the root project folders from the host into the image. The corresponding Dockerfile
    snippet could then look as simple as this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们确保所有成功构建应用程序所需的源文件和其他工件都成为镜像的一部分。这里，我们主要使用Dockerfile中的两个关键字：`COPY`和`ADD`。最初，镜像内部源文件的结构应该与主机上的结构相同，以避免任何构建问题。理想情况下，你应该有一个`COPY`命令，它将主机上的所有根项目文件夹复制到镜像中。对应的Dockerfile代码片段可以像这样简单：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t forget to also provide a `.dockerignore` file, which is located in the
    project root folder, which lists all the files and (sub)folders of the project
    root folder that should not be part of the build context.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了提供一个`.dockerignore`文件，该文件位于项目的根文件夹，列出了所有不应成为构建上下文一部分的项目根文件夹中的文件和（子）文件夹。
- en: 'As mentioned earlier, you can also use the `ADD` keyword to download sources
    and other artifacts into the Docker image that are not located in the build context
    but somewhere reachable by a URI, as shown here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你也可以使用`ADD`关键字将源代码和其他工件下载到Docker镜像中，这些源文件和工件不在构建上下文中，而是位于一个通过URI可以访问的地方，如下所示：
- en: '[PRE64]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This would create a `foobar` folder in the image’s working folder and copy all
    the contents from the URI.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在镜像的工作目录中创建一个`foobar`文件夹，并从URI中复制所有内容。
- en: Building the application
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: 'In this step, we make sure to create the final artifacts that make up our executable
    legacy application. Often, this is a `JAR` or `WAR` file, with or without some
    satellite JARs. This part of the Dockerfile should mimic the way you traditionally
    used to build an application before containerizing it. Thus, if you’re using Maven
    as your build automation tool, the corresponding snippet of the Dockerfile could
    look as simple as this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们确保创建最终的工件，这些工件构成我们可执行的遗留应用程序。通常，这个工件是一个`JAR`或`WAR`文件，可能包含一些附加的JAR文件，也可能不包含。Dockerfile的这一部分应模仿你在容器化之前传统的构建应用程序方式。因此，如果你使用的是Maven作为构建自动化工具，那么对应的Dockerfile代码片段可能看起来像这样简单：
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this step, we may also want to list the environment variables the application
    uses and provide sensible defaults. But never provide default values for environment
    variables that provide secrets to the application, such as the database connection
    string! Use the `ENV` keyword to define your variables, like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们可能还希望列出应用使用的环境变量，并提供合理的默认值。但绝不要为提供给应用的机密环境变量（例如数据库连接字符串）设置默认值！使用`ENV`关键字定义你的变量，像这样：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Also, declare all ports that the application is listening on and that need
    to be accessible from outside of the container via the `EXPOSE` keyword, like
    this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，声明应用正在监听的所有端口，并且这些端口需要通过`EXPOSE`关键字从容器外部访问，像这样：
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, we will explain the `start` command.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释`start`命令。
- en: Defining the start command
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义启动命令
- en: 'Usually, a Java application is started with a command such as `java -jar <mainapplication
    jar>` if it is a standalone application. If it is a WAR file, then the `start`
    command may look a bit different. Therefore, we can either define `ENTRYPOINT`
    or `CMD` to use this command. Thus, the final statement in our Dockerfile could
    look like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果是独立应用，Java应用会使用类似`java -jar <mainapplication jar>`的命令启动。如果是WAR文件，那么`start`命令可能会有所不同。因此，我们可以定义`ENTRYPOINT`或`CMD`来使用此命令。最终的Dockerfile中的语句可能如下所示：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Often, though, this is too simplistic, and we need to execute a few pre-run
    tasks. In this case, we can craft a script file that contains the series of commands
    that need to be executed to prepare the environment and run the application. Such
    a file is often called `docker-entrypoint``.sh`, but you are free to name it however
    you want. Make sure the file is executable – for example, run the following command
    on the host:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常情况下，这种做法过于简单，我们需要执行一些预先运行的任务。在这种情况下，我们可以编写一个脚本文件，包含需要执行的一系列命令，用来准备环境并运行应用。这样的文件通常叫做`docker-entrypoint.sh`，但你可以根据自己的需要自由命名。确保文件是可执行的——例如，在主机上运行以下命令：
- en: '[PRE69]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The last line of the Dockerfile would then look like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的最后一行将如下所示：
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that you have been given hints on how to containerize a legacy application,
    it is time to recap and ask ourselves, is it worth the effort?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经得到了关于如何容器化遗留应用的提示，那么现在是时候总结一下，问问自己，值得付出这番努力吗？
- en: Why bother?
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要费劲？
- en: 'At this point, I can see you scratching your head and asking yourself: why
    bother? Why should you take on this seemingly huge effort just to containerize
    a legacy application? What are the benefits?'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我能看到你正在挠头，心里想：为什么要费劲呢？为什么要花这么大的力气去容器化一个遗留应用呢？这样做有什么好处？
- en: 'It turns out that the **return on investment** (**ROI**) is huge. Enterprise
    customers of Docker have publicly disclosed at conferences such as DockerCon 2018
    and 2019 that they are seeing these two main benefits of Dockerizing traditional
    applications:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 原来，**投资回报率**（**ROI**）是巨大的。Docker的企业客户在2018年和2019年的DockerCon等会议上公开披露，他们在容器化传统应用时看到了以下两个主要的好处：
- en: More than a 50% saving in maintenance costs
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护成本节省超过50%
- en: Up to a 90% reduction in the time between the deployments of new releases
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新版本部署之间的时间减少最多可达90%
- en: The costs saved by reducing the maintenance overhead can be directly reinvested
    and used to develop new features and products. The time saved during new releases
    of traditional applications makes a business more agile and able to react to changing
    customer or market needs more quickly.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少维护开销节省的成本可以直接再投资，用于开发新特性和新产品。在传统应用的新版本发布过程中节省的时间使得企业变得更加灵活，能够更快速地响应不断变化的客户需求或市场需求。
- en: Now that we have discussed how to build Docker images at length, it is time
    to learn how we can ship those images through the various stages of the software
    delivery pipeline.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细讨论了如何构建Docker镜像，是时候学习如何通过软件交付管道的各个阶段来传输这些镜像了。
- en: Sharing or shipping images
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享或传输镜像
- en: To be able to ship our custom image to other environments, we need to give it
    a globally unique name. This action is often called **tagging an image**. We then
    need to publish the image to a central location from which other interested or
    entitled parties can pull it. These central locations are called **image registries**.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将我们自定义的镜像传输到其他环境，我们需要给它一个全局唯一的名称。这个操作通常称为**镜像标签**。然后，我们需要将镜像发布到一个中央位置，其他感兴趣或有权限的方可以从该位置拉取镜像。这些中央位置称为**镜像注册表**。
- en: In the following sections, we will describe how this works in more detail.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地描述这一过程是如何工作的。
- en: Tagging an image
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像标记
- en: 'Each image has a so-called tag. A tag is often used to version images, but
    it has a broader reach than just being a version number. If we do not explicitly
    specify a tag when working with images, then Docker automatically assumes we’re
    referring to the latest tag. This is relevant when pulling an image from Docker
    Hub, as shown in the following example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都有一个所谓的标签。标签通常用于为镜像版本化，但它的用途远不止版本号。如果我们在操作镜像时没有明确指定标签，那么 Docker 会默认使用最新标签。这在从
    Docker Hub 拉取镜像时非常重要，如以下示例所示：
- en: '[PRE71]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding command will pull the `alpine:latest` image from Docker Hub.
    If we want to explicitly specify a tag, we can do so like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将从 Docker Hub 拉取`alpine:latest`镜像。如果我们想明确指定标签，可以这样做：
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will pull the Alpine image that has been tagged with `3.5`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拉取带有标签`3.5`的 Alpine 镜像。
- en: Demystifying image namespaces
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密镜像命名空间
- en: So far, we have pulled various images and haven’t worried so much about where
    those images originated from. Your Docker environment is configured so that, by
    default, all images are pulled from Docker Hub. We also only pulled so-called
    official images from Docker Hub, such as `alpine` or `busybox`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拉取了各种镜像，并没有太多关心这些镜像的来源。你的 Docker 环境已配置好，默认情况下，所有镜像都从 Docker Hub 拉取。我们也只是从
    Docker Hub 拉取了所谓的官方镜像，例如 `alpine` 或 `busybox`。
- en: 'Now, it is time to widen our horizons a bit and learn about how images are
    namespaced. The most generic way to define an image is by its fully qualified
    name, which looks as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候拓宽视野，学习如何命名镜像的命名空间了。定义镜像的最通用方法是使用其完全限定名，格式如下：
- en: '[PRE73]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s look at this in a bit more detail:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下：
- en: '| **Namespace part** | **Description** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间部分** | **描述** |'
- en: '| `<``registry URL>` | This is the URL to the registry from which we want to
    pull the image. By default, this is `docker.io`. More generally, this could be
    [https://registry.acme.com](https://registry.acme.com).Other than Docker Hub,
    there are quite a few public registries out there that you could pull images from.
    The following is a list of some of them, in no particular order:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '| `<``registry URL>` | 这是我们希望从中拉取镜像的注册表的 URL。默认情况下，这是`docker.io`。更一般来说，这可以是[https://registry.acme.com](https://registry.acme.com)。除了
    Docker Hub，还有许多公共注册表可以从中拉取镜像。以下是一些示例，顺序不分先后：'
- en: Google, at [https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google，网址为[https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
- en: Amazon AWS Amazon **Elastic Container Registry** (**ECR**), at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon AWS Amazon **弹性容器注册表**（**ECR**），网址为[https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
- en: Microsoft Azure, at [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure，网址为[https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
- en: Red Hat, at [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat，网址为[https://access.redhat.com/containers/](https://access.redhat.com/containers/)
- en: Artifactory, at [https://jfrog.com/integration/artifactorydocker-registry/](https://jfrog.com/integration/artifactorydocker-registry/)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifactory，网址为[https://jfrog.com/integration/artifactorydocker-registry/](https://jfrog.com/integration/artifactorydocker-registry/)
- en: '|'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `<User>` or `<Org>` | This is the private Docker ID of either an individual
    or an organization defined on Docker Hub – or any other registry, for that matter,
    such as `microsoft` or `oracle`. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `<User>` 或 `<Org>` | 这是在 Docker Hub 上定义的个人或组织的私有 Docker ID —— 或者在任何其他注册表上，例如
    `microsoft` 或 `oracle`。 |'
- en: '| `<``name>` | This is the name of the image, which is often also called a
    repository. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `<``name>` | 这是镜像的名称，通常也称为仓库。 |'
- en: '| `<``tag>` | This is the tag of the image. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `<``tag>` | 这是镜像的标记。 |'
- en: 'Let’s look at an example, as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，如下所示：
- en: '[PRE74]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we have an image, `web-app`, that is tagged with version `1.0` and belongs
    to the `engineering` organization on the private registry at `https://registry.acme.com`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个镜像 `web-app`，它被标记为版本 `1.0`，并属于 `engineering` 组织，存储在私有注册表 `https://registry.acme.com`
    上。
- en: 'Now, there are some special conventions:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一些特殊的约定：
- en: If we omit the registry URL, then Docker Hub is automatically taken
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们省略注册表 URL，Docker Hub 会被自动采用
- en: If we omit the tag, then the `latest` tag is taken
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们省略标签，则会自动使用 `latest` 标签
- en: If it is an official image on Docker Hub, then no user or organization namespace
    is needed
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是 Docker Hub 上的官方镜像，则无需用户或组织命名空间
- en: 'Here are a few samples in tabular form:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些表格形式的示例：
- en: '| **Image** | **Description** |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **镜像** | **描述** |'
- en: '| `alpine` | The official `alpine` image on Docker Hub with the `latest` tag.
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `alpine` | Docker Hub 上的官方 `alpine` 镜像，标签为 `latest`。 |'
- en: '| `ubuntu:22.04` | The official `ubuntu` image on Docker Hub with the `22.04`
    tag or version. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `ubuntu:22.04` | Docker Hub 上的官方 `ubuntu` 镜像，标签或版本为 `22.04`。 |'
- en: '| `hashicorp/vault` | The `vault` image of an organization called `hashicorp`
    on Docker Hub with the `latest` tag. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `hashicorp/vault` | Docker Hub 上一个名为 `hashicorp` 的组织的 `vault` 镜像，标签为 `latest`。
    |'
- en: '| `acme/web-api:12.0` | The `web-api` image version of `12.0` that’s associated
    with the `acme` org. The image is on Docker Hub. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `acme/web-api:12.0` | 与 `acme` 组织关联的 `web-api` 镜像版本 `12.0`，该镜像位于 Docker Hub
    上。 |'
- en: '| `gcr.io/jdoe/sample-app:1.1` | The `sample-app` image with the `1.1` tag
    belonging to an individual with the `jdoe` ID in Google’s container registry.
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `gcr.io/jdoe/sample-app:1.1` | Google 容器注册表中属于 ID 为 `jdoe` 的个人的 `sample-app`
    镜像，标签为 `1.1`。 |'
- en: Now that we know how the fully qualified name of a Docker image is defined and
    what its parts are, let’s talk about some special images we can find on Docker
    Hub.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 Docker 镜像的完全限定名称是如何定义的，以及它的各个部分，那么接下来我们来讨论一些我们可以在 Docker Hub 上找到的特殊镜像。
- en: Explaining official images
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释官方镜像
- en: In the preceding table, we mentioned “official image” a few times. This needs
    an explanation.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，我们提到了“官方镜像”几次。这个需要做一下解释。
- en: Images are stored in repositories on the Docker Hub registry. Official repositories
    are a set of repositories hosted on Docker Hub that are curated by individuals
    or organizations that are also responsible for the software packaged inside the
    image. Let’s look at an example of what that means. There is an official organization
    behind the Ubuntu Linux distro. This team also provides official versions of Docker
    images that contain their Ubuntu distros.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像存储在 Docker Hub 注册表的仓库中。官方仓库是一组托管在 Docker Hub 上的仓库，这些仓库由个人或组织策划，这些个人或组织同时也负责镜像中打包的软件。我们来看看这个意味着什么。Ubuntu
    Linux 发行版背后有一个官方组织。这个团队还提供包含他们的 Ubuntu 发行版的官方 Docker 镜像版本。
- en: Official images are meant to provide essential base OS repositories, images
    for popular programming language runtimes, frequently used data storage, and other
    important services.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 官方镜像旨在提供基本的操作系统仓库、流行编程语言运行时镜像、常用数据存储和其他重要服务的镜像。
- en: Docker sponsors a team whose task is to review and publish all those curated
    images in public repositories on Docker Hub. Furthermore, Docker scans all official
    images for vulnerabilities.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 赞助了一个团队，负责审核并发布所有在 Docker Hub 公共仓库中策划的镜像。此外，Docker 还会扫描所有官方镜像的漏洞。
- en: Pushing images to a registry
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将镜像推送到注册表
- en: Creating custom images is all well and good, but at some point, we want to share
    or ship our images to a target environment, such as a test, **quality assurance**
    (**QA**), or production system. For this, we typically use a container registry.
    One of the most popular public registries out there is Docker Hub. It is configured
    as a default registry in your Docker environment, and it is the registry from
    which we have pulled all our images so far.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义镜像是完全没问题的，但总有那么一刻，我们希望将镜像共享或部署到目标环境中，比如测试、**质量保证**（**QA**）或生产系统。为此，我们通常会使用容器注册表。最流行的公共注册表之一是
    Docker Hub。它是你 Docker 环境中的默认注册表，也是我们迄今为止拉取所有镜像的注册表。
- en: In a registry, we can usually create personal or organizational accounts. For
    example, the author’s account at Docker Hub is `gnschenker`. Personal accounts
    are good for personal use. If we want to use the registry professionally, then
    we’ll probably want to create an organizational account, such as `acme`, on Docker
    Hub. The advantage of the latter is that organizations can have multiple teams.
    Teams can have differing permissions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册表中，我们通常可以创建个人或组织账户。例如，作者在 Docker Hub 上的账户是 `gnschenker`。个人账户适合个人使用。如果我们想要专业使用这个注册表，可能会想要在
    Docker Hub 上创建一个组织账户，比如 `acme`。后者的优势在于，组织可以有多个团队，并且各个团队可以拥有不同的权限。
- en: 'To be able to push an image to my account on Docker Hub, I need to tag it accordingly.
    Let’s say I want to push the latest version of the Alpine image to my account
    and give it a tag of `1.0`. I can do this in the following way:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将镜像推送到我在 Docker Hub 上的账户，我需要相应地给它打标签。假设我想将最新版本的 Alpine 镜像推送到我的账户，并为其添加标签
    `1.0`。我可以按照以下方式操作：
- en: 'Tag the existing image, `alpine:latest`, with this command:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为现有镜像 `alpine:latest` 打标签：
- en: '[PRE75]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, Docker does not create a new image but creates a new reference to the
    existing image, `alpine:latest`, and names it `gnschenker/alpine:1.0`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Docker不会创建一个新镜像，而是创建对现有镜像`alpine:latest`的新引用，并将其命名为`gnschenker/alpine:1.0`。
- en: 'Now, to be able to push the image, I have to log in to my account, as follows:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了能够推送镜像，我需要按照如下方式登录我的账户：
- en: '[PRE76]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Make sure to replace `gnschenker` with your own Docker Hub username and `<my
    secret password>` with your password.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`gnschenker`替换为你自己的Docker Hub用户名，并将`<my secret password>`替换为你的密码。
- en: 'After a successful login, I can then push the image, like this:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录成功后，我可以像这样推送镜像：
- en: '[PRE77]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'I will see something similar to this in the Terminal window:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在终端窗口中看到类似这样的输出：
- en: '[PRE78]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: For each image that we push to Docker Hub, we automatically create a repository.
    A repository can be private or public. Everyone can pull an image from a public
    repository. From a private repository, an image can only be pulled if you are
    logged in to the registry and have the necessary permissions configured.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个我们推送到Docker Hub的镜像，系统会自动创建一个仓库。一个仓库可以是私有的也可以是公开的。任何人都可以从公开仓库拉取镜像。而从私有仓库拉取镜像，只有在你登录到注册表并且拥有必要权限的情况下，才能进行拉取。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed what container images are and how we can build
    and ship them. As we have seen, there are three different ways that an image can
    be created – either manually, automatically, or by importing a tarball into the
    system. We also learned some of the best practices commonly used when building
    custom images. Finally, we got a quick introduction to how to share or ship custom
    images by uploading them to a container image registry such as Docker Hub.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了什么是容器镜像，以及我们如何构建和发布它们。正如我们所看到的，镜像可以通过三种不同的方式创建——手动创建、自动创建，或者通过将tarball导入系统。我们还学习了构建自定义镜像时常用的一些最佳实践。最后，我们简要介绍了如何通过将镜像上传到容器镜像注册表（如Docker
    Hub）来分享或发布自定义镜像。
- en: In the next chapter, we’re going to introduce Docker volumes, which can be used
    to persist the state of a container. We’ll also show you how to define individual
    environment variables for the application running inside the container, as well
    as how to use files containing whole sets of configuration settings.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Docker卷，它们可以用于持久化容器的状态。我们还将展示如何为容器内运行的应用程序定义单独的环境变量，以及如何使用包含整个配置设置的文件。
- en: Questions
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题以评估你的学习进度：
- en: How would you create a Dockerfile that inherits from Ubuntu version 22.04, and
    that installs `ping` and runs `ping` when a container starts? The default address
    used to ping should be `127.0.0.1`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个从Ubuntu版本22.04继承的Dockerfile，并且安装`ping`并在容器启动时运行`ping`？默认的ping地址应为`127.0.0.1`。
- en: How would you create a new container image that uses `alpine:latest` as a base
    image and installs `curl` on top of it? Name the new image `my-alpine:1.0`.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个新的容器镜像，使用`alpine:latest`作为基础镜像，并在其上安装`curl`？将新镜像命名为`my-alpine:1.0`。
- en: Create a Dockerfile that uses multiple steps to create an image of a Hello World
    app of minimal size, written in C or Go.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Dockerfile，使用多个步骤来创建一个最小大小的Hello World应用镜像，使用C或Go编写。
- en: Name three essential characteristics of a Docker container image.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列出Docker容器镜像的三个基本特征。
- en: You want to push an image named `foo:1.0` to your `jdoe` personal account on
    Docker Hub. Which of the following is the right solution?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想将名为`foo:1.0`的镜像推送到你的`jdoe`个人账户上的Docker Hub。以下哪个解决方案是正确的？
- en: '`$ docker container` `push foo:1.0`'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker container` `push foo:1.0`'
- en: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker image` `push jdoe/foo:1.0`'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker image` `push jdoe/foo:1.0`'
- en: '`$ docker login -u jdoe -p <``your password>`'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker login -u jdoe -p <``your password>`'
- en: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker image` `push jdoe/foo:1.0`'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker image` `push jdoe/foo:1.0`'
- en: '`$ docker login -u jdoe -p <``your password>`'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker login -u jdoe -p <``your password>`'
- en: '`$ docker container tag` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker container tag` `foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker container` `push jdoe/foo:1.0`'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker container` `push jdoe/foo:1.0`'
- en: '`$ docker login -u jdoe -p <``your password>`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker login -u jdoe -p <``your password>`'
- en: '`$ docker image push` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ docker image push` `foo:1.0 jdoe/foo:1.0`'
- en: Answers
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are possible answers to this chapter’s questions:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的可能答案：
- en: 'The Dockerfile could look like this:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile可能如下所示：
- en: '[PRE79]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that in Ubuntu, the `ping` tool is part of the `iputils-ping` package.
    You can build the image called pinger – for example – with the following command:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Ubuntu 中，`ping` 工具是 `iputils-ping` 包的一部分。你可以使用以下命令构建名为 pinger 的镜像——例如：
- en: '[PRE80]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The Dockerfile could look like this:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile 可能是这样的：
- en: '[PRE81]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Build the image with the following command:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建镜像：
- en: '[PRE82]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The Dockerfile for a Go application could look like this:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 Go 应用的 Dockerfile 可能是这样的：
- en: '[PRE83]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can find the full solution in the `~/The-Ultimate-Docker-Container-Book/sample-solutions/ch04/answer03`
    folder.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `~/The-Ultimate-Docker-Container-Book/sample-solutions/ch04/answer03` 文件夹中找到完整的解决方案。
- en: 'A Docker image has the following characteristics:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 Docker 镜像具有以下特性：
- en: It is immutable
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是不可变的
- en: It consists of one-to-many layers
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由一个或多个层组成
- en: It contains the files and folders needed for the packaged application to run
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含运行打包应用所需的文件和文件夹
- en: The correct answer is *C*. First, you need to log in to Docker Hub; then, you
    must tag your image correctly with the username. Finally, you must push the image.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案是 *C*。首先，你需要登录到 Docker Hub；然后，你必须使用用户名正确地标记镜像。最后，你必须推送镜像。
