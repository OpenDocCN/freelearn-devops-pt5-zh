- en: '*Chapter 3*: Sharing Containers Using Docker Hub'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用Docker Hub共享容器'
- en: In the previous chapter, we learned how to build a container and run it on our
    workstation using Docker. We used a Debian image as our starting point, but where
    did that image come from? The answer is that it came from Docker Hub. Docker Hub
    is the official container image library for Docker, run by the same folk who brought
    us Docker itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何构建一个容器并在工作站上运行它。我们使用了一个Debian镜像作为起点，但这个镜像来自哪里呢？答案是，它来自Docker Hub。Docker
    Hub是Docker的官方容器镜像库，由为我们带来Docker本身的团队运营。
- en: The container library contains the official images for numerous programs, servers,
    services, and so on that you might install within your own containers. For example,
    there are official images for various Linux distributions, versions of [Node.js](http://Node.js),
    versions of MySQL and MongoDB, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 容器库包含了许多程序、服务器、服务等的官方镜像，这些程序你可以安装到自己的容器中。例如，有各种Linux发行版的官方镜像，版本的[Node.js](http://Node.js)、MySQL和MongoDB等。
- en: You can think of Docker Hub as being like GitHub. You can explore existing organizations
    and pre-made containers, as well as upload your own containers and create your
    own organizations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Docker Hub视为类似GitHub。你可以浏览现有的组织和预制容器，还可以上传自己的容器并创建自己的组织。
- en: We will demonstrate how to use the Docker Hub website to search and get information
    for third-party containers that you can use in your applications. We will also
    demonstrate how to use third-party containers from Docker Hub using the command
    line. We will use the official MongoDB container from Docker Hub, which is published
    by MongoDB, Inc.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何使用Docker Hub网站搜索并获取第三方容器的信息，以便在你的应用程序中使用。我们还将演示如何通过命令行使用Docker Hub中的第三方容器。我们将使用Docker
    Hub上的官方MongoDB容器，该容器由MongoDB, Inc.发布。
- en: Entire backend applications can be implemented as a combination of multiple
    Docker containers working together. This application structure allows each of
    our custom container implementations to be simple and minimal. We'll apply microservices
    architecture to build a simple application. This demonstrates how containers can
    work together to create a complete working application. Lastly, we'll see how
    you can share your ready-for-production containers with third parties and your
    development team using Docker Hub.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 整个后端应用程序可以通过多个Docker容器协作来实现。这种应用程序结构允许每个自定义容器的实现保持简单和最小化。我们将应用微服务架构来构建一个简单的应用程序。这展示了容器如何协同工作来创建一个完整的工作应用程序。最后，我们将看到如何使用Docker
    Hub与第三方和开发团队共享你已经准备好的生产环境容器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing Docker Hub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Docker Hub
- en: Implementing a MongoDB container for our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们的应用程序的MongoDB容器
- en: Introducing the microservices architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务架构
- en: Implementing a sample microservices application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个示例微服务应用程序
- en: Sharing your containers on Docker Hub
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Hub上共享你的容器
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The only technical requirements are to have Docker installed on your host, and
    a browser, such as Google Chrome, Firefox, or Microsoft Edge. This is one of the
    best parts of Docker—you don't have to install the complex servers/services on
    your host; we install them in Docker containers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的技术要求是主机上安装了Docker，以及一个浏览器，如Google Chrome、Firefox或Microsoft Edge。这是Docker的最佳部分之一——你不需要在主机上安装复杂的服务器/服务；我们将它们安装在Docker容器中。
- en: We have prepared examples that you can use directly without modification in
    a public GitHub repository, which can be found at [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好可以直接使用而无需修改的示例，这些示例存放在一个公共的GitHub仓库中，可以在[https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)找到。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何在实际中运作的：
- en: '[https://bit.ly/2PTADjH](https://bit.ly/2PTADjH)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2PTADjH](https://bit.ly/2PTADjH)'
- en: Introducing Docker Hub
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker Hub
- en: You will typically interact with Docker Hub from the command line or in Dockerfiles,
    but you can use the Docker Hub website ([https://hub.docker.com](https://hub.docker.com))
    to search for any pre-built containers that you know you want to use. You can
    also use the website to discover pre-built containers that might be of interest
    to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会通过命令行或 Dockerfile 与 Docker Hub 进行交互，但你也可以通过 Docker Hub 网站（[https://hub.docker.com](https://hub.docker.com)）来搜索任何你知道需要使用的预构建容器。你还可以利用该网站发现一些可能对你有用的预构建容器。
- en: In general, you will inherit from some pre-built Docker containers on Docker
    Hub to create your own custom containers. For example, you might inherit from
    a Linux distribution container and install the software you want for your project
    within that inherited/custom container.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你会从 Docker Hub 上的一些预构建 Docker 容器继承，以创建你自己的自定义容器。例如，你可能会从一个 Linux 发行版容器继承，并在该继承的/自定义容器中安装你项目所需的软件。
- en: When you inherit from the Linux distribution, some of that distribution's base
    software packages are installed. If you inherit from a Debian-flavor Linux container,
    you will be able to use the `apt` package manager within the container to install
    software as if you were running that Debian-flavor Linux container on a dedicated
    or virtual machine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 Linux 发行版继承时，该发行版的一些基础软件包将会被安装。如果你从 Debian 系列的 Linux 容器继承，你将能够在容器内使用 `apt`
    包管理器来安装软件，就像你在专用机或虚拟机上运行该 Debian 系列 Linux 容器一样。
- en: Some pre-built containers inherit from a Linux flavor and provide pre-installed
    packages that are specific to the offering. When you inherit from a [Node.js](http://Node.js)
    container, that [Node.js](http://Node.js) container might inherit from a Linux
    distribution container and will have [Node.js](http://Node.js), `npm`, and `yarn`
    already installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些预构建容器继承自某种 Linux 发行版，并提供与该产品特定的软件包。比如，当你从 [Node.js](http://Node.js) 容器继承时，该
    [Node.js](http://Node.js) 容器可能继承自某个 Linux 发行版容器，并且已经安装了 [Node.js](http://Node.js)、`npm`
    和 `yarn`。
- en: Interacting with Docker Hub from the command line
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行与 Docker Hub 交互
- en: 'The easiest way to see Docker Hub and Docker working together is to run the
    official `hello-world` container. The command to run a container from Docker Hub
    is `docker run name-of-container`; we''ll type `docker run hello-world`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Docker Hub 和 Docker 协同工作最简单的方法就是运行官方的 `hello-world` 容器。从 Docker Hub 运行容器的命令是
    `docker run name-of-container`；我们可以输入 `docker run hello-world`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Docker did not find the container in its local container cache, so it automatically
    downloaded it and then ran it within the Docker engine. This code in the container
    is simple—it just prints the preceding messages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 没有在本地容器缓存中找到该容器，所以它会自动下载并在 Docker 引擎中运行。容器中的代码很简单——它只是打印出前面的消息。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can run any container you find on the Docker Hub website in the same way!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式运行在 Docker Hub 网站上找到的任何容器！
- en: If your output does not resemble the preceding output, you either have an issue
    with your Docker installation or the Docker Hub servers are not accessible from
    your host. One possible problem may be that your installation of Docker requires
    you to run the `docker` commands as root or an administrator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的输出结果与前面的输出不一致，那可能是你的 Docker 安装存在问题，或者从你的主机无法访问 Docker Hub 服务器。一个可能的问题是你的
    Docker 安装要求你以 root 或管理员身份运行 `docker` 命令。
- en: The installation instructions can be found at [https://docs.docker.com/install/](https://docs.docker.com/install/),
    while the post-installation instructions for Docker can be found at [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/).
    These post-installation instructions explain how to set up Docker so that you
    can manage it as a non-root user.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明可以在 [https://docs.docker.com/install/](https://docs.docker.com/install/)
    找到，而 Docker 的安装后说明可以在 [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/)
    找到。这些安装后说明解释了如何设置 Docker，以便你可以作为非 root 用户管理它。
- en: Using the Docker Hub website
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker Hub 网站
- en: 'Let''s go find the `hello-world` container page in Docker Hub—[https://hub.docker.com/_/hello-world](https://hub.docker.com/_/hello-world).
    The page will look something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去 Docker Hub 找找 `hello-world` 容器页面—[https://hub.docker.com/_/hello-world](https://hub.docker.com/_/hello-world)。页面大概会是这个样子：
- en: '![Figure 3.1 – The hello-world image page on Docker Hub](img/B11641_03_001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Docker Hub 上的 hello-world 镜像页面](img/B11641_03_001.jpg)'
- en: Figure 3.1 – The hello-world image page on Docker Hub
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Docker Hub 上的 hello-world 镜像页面
- en: This is typical of what you'll see for most containers shared on Docker Hub.
    Specific software packages encapsulated in a container, such as MongoDB, offer
    official images for various versions of the software. This allows you to deal
    with software that depends on a specific version of a Docker Hub package.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是你在Docker Hub上看到的大多数共享容器的典型情况。像MongoDB这样的特定软件包被封装在容器中，提供了各种版本的软件镜像。这使得你能够处理依赖于特定版本Docker
    Hub包的软件。
- en: The MongoDB page on Docker Hub is [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).
    To find it, simply type `mongodb` into the search box at the top of the **hello-world**
    (or any other package) page and select it from the search results page. You can
    use the search box to find any shared images for whatever software you might want.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在Docker Hub上的页面是[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)。要找到它，只需在**hello-world**（或其他任何包）页面顶部的搜索框中输入`mongodb`，然后从搜索结果页面中选择它。你可以使用搜索框查找任何你需要的共享镜像。
- en: Of interest are the **Simple Tags** and **Shared Tags** sections of the page.
    The various version images of MongoDB are tagged with simple tags and shared tags.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 页面中的**简单标签**和**共享标签**部分是重点。MongoDB的各个版本镜像都使用了简单标签和共享标签进行标记。
- en: For example, the **3.4-xenial** simple tag means there is an image for version
    3.4 of MongoDB running in an Ubuntu Xenial container.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**3.4-xenial**简单标签意味着MongoDB 3.4版本的镜像运行在Ubuntu Xenial容器中。
- en: The **3.4** shared tag means there are images of version 3.4 of MongoDB that
    run on more than one host operating system—typically, Windows Server, Linux, or
    macOS. The Docker daemon will choose the appropriate image for the host operating
    system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.4**共享标签意味着有适用于多个主机操作系统（通常是Windows Server、Linux或macOS）的MongoDB 3.4版本的镜像。Docker守护进程会选择适合主机操作系统的镜像。'
- en: 'As of the time of writing, there are images for the MongoDB 3.4, 3.6, 4.0,
    and 4.2 major versions, as well as minor point versions of these major versions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，已有MongoDB 3.4、3.6、4.0和4.2的主要版本镜像，以及这些主要版本的次要点版本镜像：
- en: '![Figure 3.2 – Simple tags and shared tags for hello-world](img/B11641_03_002.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – hello-world的简单标签和共享标签](img/B11641_03_002.jpg)'
- en: Figure 3.2 – Simple tags and shared tags for hello-world
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – hello-world的简单标签和共享标签
- en: The process for finding the available pre-built third-party containers is the
    same. You can search for Redis, for example, and you will get a similar page with
    details about the available Redis containers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查找可用的第三方预构建容器的过程是相同的。例如，您可以搜索Redis，您将得到一个类似的页面，其中包含有关可用Redis容器的详细信息。
- en: Implementing a MongoDB container for our application
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用实现MongoDB容器
- en: We can explore using pre-built containers from Docker Hub by implementing a
    MongoDB container. We'll use this container later as part of a demo application
    that is made up of several containers that work together.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现MongoDB容器，探索使用Docker Hub上预构建的容器。稍后我们将把这个容器作为演示应用程序的一部分，这个应用程序由多个容器组成，并且它们协同工作。
- en: We will use the official Docker image for MongoDB, found on the Docker Hub website
    at [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo). We will create
    a `.sh` script to start running our image within Docker so that the startup process
    is easy and repeatable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MongoDB的官方Docker镜像，可以在Docker Hub网站上找到，网址是[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)。我们将创建一个`.sh`脚本，在Docker中启动我们的镜像，以便启动过程简便且可重复。
- en: We learned in [*Chapter 2*](B11641_02_Final_NM_ePub.xhtml#_idTextAnchor028),
    *Using VirtualBox and Docker Containers for Development*, that we can expose a
    container's network ports to the host. That means we can run this MongoDB container
    image in Docker and access the running MongoDB server within that container by
    accessing the MongoDB port on the host.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B11641_02_Final_NM_ePub.xhtml#_idTextAnchor028)《使用VirtualBox和Docker容器进行开发》中了解到，我们可以将容器的网络端口暴露给主机。这意味着我们可以在Docker中运行MongoDB容器镜像，并通过访问主机上的MongoDB端口，访问容器内正在运行的MongoDB服务器。
- en: 'In the GitHub repository ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers))
    for this book, there is a `chapter3/` directory, which is a companion for this
    chapter. Within that directory is a shell script, [start-mongodb.sh](http://start-mongodb.sh).
    This script is a bit more elaborate than the simple ones we used in the previous
    chapter. We''re going to use environment variables to configure MongoDB, and we''re
    going to use a directory on the host for MongoDB''s data files—this makes backing
    up the data as easy as copying those files to back-up media:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的 GitHub 仓库中 ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers))，有一个
    `chapter3/` 目录，它是本章的配套内容。在这个目录中有一个 shell 脚本，[start-mongodb.sh](http://start-mongodb.sh)。这个脚本比我们在上一章中使用的简单脚本稍微复杂一点。我们将使用环境变量来配置
    MongoDB，并且我们将使用主机上的一个目录来存储 MongoDB 的数据文件—这样备份数据就像将这些文件复制到备份介质上一样简单：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You do need a Dockerfile to create a container image. However, if you are using
    a pre-made container image from Docker Hub that is standalone, such as MongoDB,
    you won't need one. The developers at MongoDB use Dockerfiles to generate the
    images before uploading them to Docker Hub.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你确实需要一个 Dockerfile 来创建容器镜像。然而，如果你使用的是来自 Docker Hub 的预构建容器镜像（如 MongoDB）并且是独立的，那么你就不需要
    Dockerfile。MongoDB 的开发者们在将镜像上传到 Docker Hub 之前，会使用 Dockerfile 来生成这些镜像。
- en: In fact, you can see from the **Supported tags** section of the MongoDB page
    in Docker Hub that they produce and support quite a few images, including different
    versions—some for Windows OS, some for Linux, and so on. The MongoDB developers
    must have quite a few Dockerfiles—one for each image!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以从 MongoDB 在 Docker Hub 页面中的 **Supported tags** 部分看到，他们生产并支持了不少镜像，包括不同版本的镜像—有些是
    Windows 操作系统版的，有些是 Linux 版的，等等。MongoDB 的开发者们肯定有很多 Dockerfile—每个镜像一个！
- en: 'We must provide one environment variable to [start-mongodb.sh:](http://start-mongodb.sh:)
    `MONGO_DATADIR`, which is an existing directory on your workstation where you
    want MongoDB in the container to store its data files. There are a few ways to
    set this variable:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为 [start-mongodb.sh](http://start-mongodb.sh) 提供一个环境变量：`MONGO_DATADIR`，这是你工作站上一个现有的目录，用于存储
    MongoDB 在容器中的数据文件。设置这个变量有几种方法：
- en: You can add `export MONGODB_DATADIR=/path/to/data/dir` to your shell startup
    file (`.zshrc`, `.bashrc`, and so on).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将 `export MONGODB_DATADIR=/path/to/data/dir` 添加到你的 shell 启动文件中（如 `.zshrc`、`.bashrc`
    等）。
- en: You can do the `export` (environment variable) operation by hand in the shell
    before running the script.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在运行脚本之前手动在终端中进行 `export`（环境变量）操作。
- en: 'You can set the value of the environment variable when using the command line
    to run the [start-mongodb.sh](http://start-mongodb.sh) script: `# MONGODB_DATADIR=~/data
    ./`[start-mongodb.sh](http://start-mongodb.sh).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在命令行中运行 [start-mongodb.sh](http://start-mongodb.sh) 脚本时设置环境变量的值：`# MONGODB_DATADIR=~/data
    ./`[start-mongodb.sh](http://start-mongodb.sh)。
- en: You can uncomment the line that sets `MONGO_DATADIR` in the [start-mongodb.sh](http://start-mongodb.sh)
    script file and edit it to set it to your desired data directory each time you
    run the script.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以取消注释 [start-mongodb.sh](http://start-mongodb.sh) 脚本文件中设置 `MONGO_DATADIR`
    的那一行，并编辑它，将其设置为每次运行脚本时你希望使用的数据目录。
- en: 'The last line in the [start-mongodb.sh](http://start-mongodb.sh) script is
    a single command line. The backslash (`\`) character at the end of the line signifies
    that the line is being continued or joined with the next line. This command is
    the one that starts the container. As you can imagine, if you had to type in this
    long command every time to start your MongoDB container, it would be painful.
    The `.sh` script makes it rather painless:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[start-mongodb.sh](http://start-mongodb.sh) 脚本中的最后一行是一个单独的命令行。行末的反斜杠（`\`）字符表示该行正在继续或与下一行连接。这个命令是启动容器的命令。可以想象，如果每次都必须输入这么长的命令来启动
    MongoDB 容器，那会非常麻烦。`.sh` 脚本让这个过程变得相当轻松：'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take a look at the different parts of the preceding command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下前面命令的不同部分：
- en: The `docker run` command names the `mongodb` running container.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run` 命令为正在运行的 `mongodb` 容器命名。'
- en: The `-d` switch runs the container in detached mode. The container will automatically
    start when your workstation is rebooted.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 开关将容器以分离模式运行。容器将在工作站重启时自动启动。'
- en: The `-e` switch allows you to pass environment variables to the container; in
    this case, we pass the `TITLE=mongodb` environment variable. You can have multiple
    `-e` switches if you want to pass more than one variable.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e` 开关允许你将环境变量传递给容器；在这种情况下，我们传递了 `TITLE=mongodb` 环境变量。如果你想传递多个变量，可以使用多个 `-e`
    开关。'
- en: The `-p` switch exposes port `27017` in the container to port `27017` on the
    host. You can remap an exposed port in the container to a different port number
    on the host. You would do this if you have a MongoDB server already running in
    a container or on your host. However, Docker provides us the flexibility to always
    run MongoDB within a container, so we'll never have to install it on our host.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 开关将容器中的端口 `27017` 映射到主机上的端口 `27017`。你可以将容器中的暴露端口重新映射到主机上的不同端口号。如果你已经在容器或主机上运行
    MongoDB 服务器，你会这样做。然而，Docker 使我们能够灵活地始终在容器中运行 MongoDB，因此我们永远不必在主机上安装它。'
- en: We might want to install MongoDB client programs on the host so that we can
    access MongoDB using the MongoDB REPL/shell. Once port `27017` is exposed on the
    host, any program can access the MongoDB database, using it as if it were running
    on the host.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可能希望在主机上安装 MongoDB 客户端程序，以便使用 MongoDB REPL/shell 访问 MongoDB。一旦主机上暴露了端口 `27017`，任何程序都可以访问
    MongoDB 数据库，就像它在主机上运行一样。
- en: The `-v` switch maps a directory on the host to the directory in the container
    where MongoDB will manage its database and other files.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 开关将主机上的一个目录映射到容器中 MongoDB 将管理其数据库和其他文件的目录。'
- en: We choose to download and run `mongo:3.4` (tag/version 3.4) from Docker Hub.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择从 Docker Hub 下载并运行 `mongo:3.4`（标签/版本 3.4）。
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `docker run` command only downloads the container from Docker Hub if it
    doesn't exist on your workstation yet or if the container image on Docker Hub
    is newer.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`docker run` 命令仅在容器尚未存在于你的工作站中，或者如果 Docker Hub 上的容器镜像较新时，才会从 Docker Hub 下载容器。'
- en: You can run any container you find on Docker Hub in the same way!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用相同的方式运行你在 Docker Hub 上找到的任何容器！
- en: 'Let''s run the script by using the following commands:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令来运行脚本：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following output contains a few warnings about not being able to stop an
    already-running container named `mongodb` (this is expected):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出包含一些关于无法停止名为 `mongodb` 的已运行容器的警告（这是预期的）：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Docker pulled the proper MongoDB image and ran it in the background in the
    Docker engine. You can observe the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 拉取了正确的 MongoDB 镜像，并在 Docker 引擎中后台运行。你可以观察到以下内容：
- en: The MongoDB image consists of several layers that were downloaded (`Pull complete`).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 镜像由几个已经下载的层组成（`Pull complete`）。
- en: There was already an existing (but older) image on the workstation (`Downloaded
    newer image…`).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上已经有一个现存的（但较旧的）镜像（`Downloaded newer image…`）。
- en: The container is running via the `docker ps` command.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是通过 `docker ps` 命令运行的。
- en: If the container encounters errors, it may exit and print diagnostic messages
    in the output. You can run a shell in the container to perform forensic diagnosis.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器遇到错误，可能会退出并在输出中打印诊断信息。你可以在容器中运行一个 shell 以进行取证诊断。
- en: Running a shell within a container
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器中运行 shell
- en: Generally, you would run a shell within the container so that you can discover
    more about the container's environment. For example, you may have a bug in your
    Dockerfile—such as forgetting to copy a file into the container. You can run a
    shell in the container and list directories and you will see that the file is
    missing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在容器中运行一个 shell，以便你可以进一步了解容器的环境。例如，可能在你的 Dockerfile 中存在 bug——比如忘记将某个文件复制到容器中。你可以在容器中运行一个
    shell，列出目录，你会发现文件缺失。
- en: 'In the case of the MongoDB container, you might want to run the MongoDB client
    commands from within the container. The Docker Hub page for the MongoDB container
    says we can run the client commands by simply attaching to the running container
    ([https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)). The command
    from the MongoDB Docker Hub page is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 容器的情况下，你可能希望在容器内部运行 MongoDB 客户端命令。MongoDB 容器的 Docker Hub 页面说明我们可以通过简单地连接到正在运行的容器来运行客户端命令（[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)）。来自
    MongoDB Docker Hub 页面的命令如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The different parts of this command are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的不同部分如下：
- en: '`docker exec` runs a command in a running container ([https://docs.docker.com/engine/reference/commandline/exec/](https://docs.docker.com/engine/reference/commandline/exec/)).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec` 在运行中的容器中执行命令（[https://docs.docker.com/engine/reference/commandline/exec/](https://docs.docker.com/engine/reference/commandline/exec/)）。'
- en: The `-it` switches specify that Docker is to run the container interactively—this
    means it gets input from the keyboard and sends output to the Terminal window.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-it`选项指定 Docker 以交互模式运行容器——这意味着它从键盘获取输入并将输出发送到终端窗口。'
- en: 'Within the container, we can list directories using the `ls` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内，我们可以使用`ls`命令列出目录：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that the Docker containers are running using the `ps` command within
    the container:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在容器内使用`ps`命令查看 Docker 容器是否正在运行：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can run the command-line MongoDB tools inside the container. We did not
    have to install these on our workstation! Here, we run the MongoDB command and
    then run the `show collections` and `show databases` commands within the Mongo
    REPL:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在容器内运行命令行 MongoDB 工具。我们不需要在工作站上安装这些工具！在这里，我们运行 MongoDB 命令，然后在 Mongo REPL
    内运行`show collections`和`show databases`命令：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re all set to go—MongoDB is running and we were able to use the REPL. The
    `show collections` command returned no collections because we haven''t created
    any. The `show databases` command shows that MongoDB has, by default, two databases:
    `admin` and `local`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪——MongoDB 正在运行，我们可以使用 REPL。`show collections`命令没有返回任何集合，因为我们还没有创建任何集合。`show
    databases`命令显示 MongoDB 默认有两个数据库：`admin` 和 `local`。
- en: 'The `docker logs` command shows us the `stdout` and `stderr` output of the
    container:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs`命令显示容器的`stdout`和`stderr`输出：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will likely use the `docker logs` command to see the debugging output from
    your containers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会使用`docker logs`命令查看容器的调试输出。
- en: What we see in our preceding logs is that MongoDB seems to be running just fine
    within the container. There are no error messages printed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的日志中可以看到，MongoDB 似乎在容器内运行得很好。没有打印任何错误信息。
- en: You can have the `docker logs` command follow the log file using the `-f` command-line
    switch. When the command is in follow mode, any new lines written to the log as
    the application is running will be appended to the display on the screen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`docker logs`命令加上`-f`命令行选项来跟踪日志文件。当命令处于跟踪模式时，应用程序运行时写入日志的任何新行都会追加到屏幕显示中。
- en: Up to point, we have explored using Docker to run a complex server application
    (MongoDB) without having to install MongoDB on our workstation. Using Docker,
    we have access to MongoDB.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了如何使用 Docker 运行复杂的服务器应用程序（MongoDB），而无需在工作站上安装 MongoDB。通过 Docker，我们可以访问
    MongoDB。
- en: We can start MongoDB using our `.sh` script, and we can also stop it—we can
    do this at will so that we don't have to always have MongoDB running in the background.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`.sh`脚本启动 MongoDB，也可以停止它——我们可以随时这样做，这样就不必始终让 MongoDB 在后台运行。
- en: Now that we know how to run a Docker container, let's have a look at how to
    work with multiple containers that work together.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何运行 Docker 容器，让我们来看一下如何处理多个协同工作的容器。
- en: Introducing the microservices architecture
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务架构
- en: Docker and Docker Hub enable development using the microservices architecture.
    This architecture emphasizes building and running containers that focus on a single
    aspect of the overall application. When all the containers are running, you have
    your complete backend application. The containers can be complex, such as a full-blown
    database server, or simple, such as a short shell script. Ideally, the containers
    you implement for your application will be simple, short, and focused. Each microservice
    you write should be simple to debug since you don't need many lines of code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Docker Hub 支持使用微服务架构进行开发。该架构强调构建和运行专注于应用程序整体单一方面的容器。当所有容器都在运行时，你就有了完整的后端应用程序。这些容器可以很复杂，比如一个完整的数据库服务器，或者很简单，比如一个简短的
    shell 脚本。理想情况下，你为应用程序实现的容器应该是简单的、短小的并且专注的。你编写的每个微服务应该易于调试，因为你不需要很多行代码。
- en: Suppose we want to develop a backend application that uses MongoDB and Redis
    and whose application code is written using [Node.js](http://Node.js). We have
    the option to create a Dockerfile and start with the MongoDB image. We would then
    add Redis by installing it using `apt`, and then add our program to it as we did
    with the Debian image in [*Chapter 2*](B11641_02_Final_NM_ePub.xhtml#_idTextAnchor028),
    *Using VirtualBox and Docker Containers for Development*. The problem with creating
    the application using this method is that when you stop the container for development
    reasons, you're also stopping the running MongoDB and Redis servers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想开发一个使用 MongoDB 和 Redis 的后端应用程序，并且其应用代码是使用 [Node.js](http://Node.js) 编写的。我们可以选择创建一个
    Dockerfile，并从 MongoDB 镜像开始。然后通过使用 `apt` 安装 Redis，并将我们的程序添加到其中，就像我们在 [*第2章*](B11641_02_Final_NM_ePub.xhtml#_idTextAnchor028)
    中做的那样，*使用 VirtualBox 和 Docker 容器进行开发*。使用这种方法创建应用程序的问题是，当你因开发原因停止容器时，也会停止正在运行的
    MongoDB 和 Redis 服务器。
- en: Instead of a monolithic container with everything installed, you can run MongoDB,
    Redis, and your custom application containers separately. You can even divide
    your custom application into multiple containers. All you need is a mechanism
    to communicate between your application containers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用一个包含所有安装内容的单体容器，你可以分别运行 MongoDB、Redis 和自定义应用程序容器。你甚至可以将你的自定义应用程序分成多个容器。你所需要的只是一个机制来实现应用程序容器之间的通信。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is far better to avoid using monolithic containers in your design! While
    it might seem that a large and complex program such as MongoDB is a monolithic
    sort of thing, it's just one dedicated service you can use as a microservice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的设计中，最好避免使用单体容器！虽然看起来像 MongoDB 这样的大型复杂程序可能是单体的，但它实际上只是一个你可以作为微服务使用的专用服务。
- en: Now that we have a brief understanding of microservices architecture, we can
    examine some of the benefits and requirements of containers as microservices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对微服务架构有了简要的了解，我们可以检查容器作为微服务的一些好处和要求。
- en: Scalability
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Scalability is almost always a huge consideration for backend implementations.
    For example, a simple HTTP/WWW (web page) server can grind to a halt if enough
    people are trying to fetch our pages from it at the same time. For this reason,
    server farms exist so that you can deploy two or more of these HTTP/WWW servers
    that duplicate the functionality of serving our pages. For a two-server farm,
    you basically get double the number of people fetching your pages from it than
    for a single server. As traffic grows—for example, if the site gains in popularity—you
    can add a third server, then a fourth server, and so on. The capability of the
    backend to serve pages grows as you need it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性几乎总是后端实现中的一个重要考虑因素。例如，如果有足够多的人同时尝试从一个简单的 HTTP/WWW（网页）服务器上获取我们的页面，它可能会停止响应。因此，服务器农场的存在是为了你可以部署两个或更多这样的
    HTTP/WWW 服务器，复制我们的页面服务功能。对于一个双服务器农场，你基本上能得到比单个服务器更多的用户在同时访问页面。随着流量的增长——例如，如果网站变得更受欢迎——你可以增加第三台服务器，然后是第四台服务器，以此类推。后端提供页面的能力会随着你的需求增长。
- en: In a microservices architecture, we achieve a similar means of scalability.
    We can run multiple instances of our MongoDB container to achieve more capacity
    for database operations. The only trick is to configure MongoDB as a cluster or
    as shards and the application containers to use this database setup.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，我们实现类似的可扩展性方式。我们可以运行多个 MongoDB 容器实例，以提高数据库操作的容量。唯一的诀窍是将 MongoDB 配置为集群或分片，并使应用程序容器使用这种数据库配置。
- en: Inter-container communication
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器间通信
- en: 'Inter-container communication usually involves some technology that allows
    messages to be sent from one container to another and for responses or statuses
    to be sent in return. Being able to communicate between running containers can
    be done via a few technologies, including the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 容器间通信通常涉及一些技术，允许消息从一个容器发送到另一个容器，并将响应或状态返回。能够在运行的容器之间进行通信可以通过几种技术实现，包括以下几种：
- en: Sockets
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: The filesystem
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统
- en: Database records
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库记录
- en: HTTP
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP
- en: MQTT
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MQTT
- en: Let's discuss each of them now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来讨论一下它们。
- en: Using sockets
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用套接字
- en: Using sockets is a non-trivial way to communicate between containers. If you
    have five containers, you might have five sockets per container to provide communication
    paths between them all. As you scale, more sockets need to be created in each
    container, and you really want to automate this. There's quite a bit of business
    logic involved.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字是容器之间通信的一种复杂方法。如果您有五个容器，您可能需要为每个容器创建五个套接字，以提供容器间的通信路径。当您进行扩展时，每个容器需要创建更多的套接字，您实际上希望能够自动化这个过程。这涉及到相当多的业务逻辑。
- en: Using the filesystem
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用文件系统
- en: Using the filesystem involves sharing something such as a network drive among
    all the containers. To send a message, a container writes to a file in the filesystem.
    To receive a message, the container reads from a file in the filesystem. The receiver
    needs to poll, or repeatedly check, the filesystem to detect when the file is
    written to. This is not ideal because we don't really want to share a network
    drive like this—the performance is going to be on the slow side.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件系统的方法涉及在所有容器之间共享某些内容，例如网络驱动器。要发送消息，容器将消息写入文件系统中的文件。要接收消息，容器从文件系统中的文件读取消息。接收方需要轮询或反复检查文件系统，以检测文件是否已被写入。这种方法并不理想，因为我们并不希望以这种方式共享网络驱动器——性能会较慢。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Polling is a programming technique where you continuously check the status of
    a machine state (such as whether a file has changed).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询是一种编程技术，指的是持续检查机器状态（例如文件是否发生了变化）。
- en: Using database records
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据库记录
- en: Using database records is similar to the filesystem method, except the messages
    to be sent are simply written to records in the database and the receivers only
    need to poll the database records for changes. Some databases provide a notification
    mechanism to tell a client (receiver) that the database has changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库记录的方法类似于文件系统方法，不同之处在于要发送的消息仅仅是写入到数据库中的记录，接收方只需轮询数据库记录的变化。一些数据库提供通知机制，告知客户端（接收方）数据库已发生变化。
- en: Both filesystem and database schemes require a good amount of business logic
    and debugging. You have to consider the order of messages sent and received and
    avoid missing a message because an older message is overwritten in the database
    or filesystem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统和数据库方案都需要相当多的业务逻辑和调试。您必须考虑发送和接收消息的顺序，并避免由于旧消息被数据库或文件系统中的新消息覆盖而导致丢失消息。
- en: Using HTTP
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用HTTP
- en: HTTP is a stateless protocol, so you don't have to maintain a mesh of open sockets
    for communication. The protocol is well-defined and human-readable (for example,
    in text). To send a message, you send an HTTP request to the container you want
    to communicate with and wait for the response. You can close or persist the connection
    (keep it alive) as the HTTP protocol permits. Additionally, to avoid having to
    poll for messages or state change via HTTP, you can use WebSockets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种无状态协议，因此您不需要维护一组开放的套接字来进行通信。该协议定义明确，且可供人类阅读（例如文本格式）。要发送消息，您只需向您希望通信的容器发送一个HTTP请求，并等待响应。您可以根据HTTP协议的规定关闭或保持连接（保持活跃）。此外，为了避免通过HTTP轮询消息或状态变化，您可以使用WebSockets。
- en: Using MQTT
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MQTT
- en: MQTT is a well-designed message bus. It works much like IRC or Slack in that
    you have rooms (topics) and people in rooms (subscribers). Messages sent to a
    room (topic) are received by the people (subscribers). The people (subscribers)
    can join multiple rooms (topics) and they receive the messages for those rooms
    (topics).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是一个设计良好的消息总线。它的工作方式类似于IRC或Slack，您有房间（主题）和在房间中的人（订阅者）。发送到房间（主题）的消息会被房间中的人（订阅者）接收。人们（订阅者）可以加入多个房间（主题），并接收那些房间（主题）的消息。
- en: For an MQTT application, there must be one MQTT server (broker) container that
    is accessible from the other containers. The other containers do not have to know
    about one another, only the address of the MQTT broker.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个MQTT应用，必须有一个可以从其他容器访问的MQTT服务器（代理）容器。其他容器无需彼此了解，只需要知道MQTT代理的地址。
- en: The MQTT broker accepts connections from one or more clients. The clients can
    subscribe to one or more topics. The topics are as arbitrary as the channel/room
    names are in IRC or Slack; they are typically strings. When a message is sent
    to the MQTT broker for a specific topic, the broker sends the message to all the
    clients who are subscribed to that topic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT代理接受来自一个或多个客户端的连接。客户端可以订阅一个或多个主题。主题就像IRC或Slack中的频道/房间名称一样是任意的，通常是字符串。当向MQTT代理发送某个特定主题的消息时，代理会将该消息发送给所有订阅了该主题的客户端。
- en: Mosca ([https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca))
    is an MQTT broker written in JavaScript. You can run it in a container, as you
    do with MongoDB or Redis.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Mosca（[https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)）是一个用JavaScript编写的MQTT代理。你可以像运行MongoDB或Redis一样在容器中运行它。
- en: There are several other MQTT brokers to choose from, as well—you can find them
    on Docker Hub.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个其他的MQTT代理可供选择，你可以在Docker Hub上找到它们。
- en: HTTP versus MQTT
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP与MQTT
- en: MQTT is a protocol specifically designed for passing messages of key/value pairs.
    Its strength is in its broadcast capability. Each client is responsible for asking
    for modifications to values based on the specific keys it cares about. Each client
    can be assured that their updates are received by any and all other interested
    clients. MQTT also has the capability to retain specific key/value pairs, so when
    a new client subscribes, it can be notified of the current key/value pair (the
    most recently sent one).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是一种专门为传递键/值对消息设计的协议。它的优势在于其广播能力。每个客户端都负责根据其关心的特定键请求修改值。每个客户端可以确保它们的更新会被任何其他感兴趣的客户端接收。MQTT还具有保留特定键/值对的功能，因此当新客户端订阅时，它可以收到当前的键/值对（最近发送的那个）。
- en: MQTT does not provide a request/response protocol, although it is simple to
    implement one. The downside of using MQTT for request/response-type transactions
    is that the response is not guaranteed to happen as soon as possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT并没有提供请求/响应协议，尽管实现一个很简单。使用MQTT进行请求/响应类型事务的缺点是，响应不能保证尽快发生。
- en: HTTP requires custom programming to provide the message-passing services that
    MQTT provides. You could implement a message bus sort of system that mimics MQTT's
    functionality, but that means more programming work for you and additional maintenance
    costs down the line. HTTP's strength is that it is a request/response protocol,
    so you can typically expect a response right away. The downside is that if the
    server is maintaining a set of key/value pairs, you would be required to poll
    the server from the clients to see whether the values have changed and post to
    the server to update the values. Polling causes the server to burn CPU, even when
    values haven't changed, and this can add up in a way that grinds your server to
    a halt if enough clients are polling frequently enough. You could use WebSockets,
    but in the end, you've reinvented MQTT.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP需要自定义编程才能提供MQTT所提供的消息传递服务。你可以实现一个类似消息总线的系统来模拟MQTT的功能，但这意味着你需要更多的编程工作，并且未来还会增加维护成本。HTTP的优势在于它是一个请求/响应协议，因此你通常可以立刻收到响应。缺点是，如果服务器正在维护一组键/值对，你将需要从客户端轮询服务器，查看值是否发生了变化，并将更新的值提交给服务器。轮询会导致服务器消耗CPU，即使值没有变化，这可能会导致服务器在足够多的客户端频繁轮询时崩溃。你可以使用WebSockets，但最终你重新发明了MQTT。
- en: HTTP is a good choice if you need more than what MQTT provides. Certainly, HTTP
    supports PHP or [Node.js](http://Node.js) (and others) backend services.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要比MQTT提供的更多功能，HTTP是一个不错的选择。当然，HTTP支持PHP或[Node.js](http://Node.js)（以及其他语言）后端服务。
- en: It's possible to combine HTTP and MQTT. Use HTTP for request/response-type transactions
    and MQTT for state updates.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP和MQTT是可以结合使用的。使用HTTP进行请求/响应类型事务，使用MQTT进行状态更新。
- en: MQTT is a good choice for our purposes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT对于我们的需求来说是一个不错的选择。
- en: The `chapter3/` directory in the companion GitHub repository contains a simple
    microservices-based backend demonstration application. It uses MongoDB, Redis,
    and MQTT, along with some publisher and subscriber applications that you can find
    in the GitHub repository for this book ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)).
    Later in this chapter, we'll learn how to share our subscriber and publisher containers
    via Docker Hub.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 附带的GitHub仓库中的`chapter3/`目录包含一个简单的基于微服务的后端演示应用。它使用MongoDB、Redis和MQTT，并包括一些发布者和订阅者应用程序，你可以在本书的GitHub仓库中找到它们（[https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)）。在本章的后面，我们将学习如何通过Docker
    Hub共享我们的订阅者和发布者容器。
- en: Implementing a sample microservices application
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个示例的微服务应用
- en: 'We can use the Mosca, MongoDB, and Redis containers, along with a couple of
    custom containers, to implement a simple but complete application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Mosca、MongoDB和Redis容器，结合一些自定义容器，来实现一个简单但完整的应用：
- en: '![Figure 3.3 – Diagram of our sample microservices application](img/B11641_03_003.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 我们的示例微服务应用图示](img/B11641_03_003.jpg)'
- en: Figure 3.3 – Diagram of our sample microservices application
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 我们的示例微服务应用程序图
- en: The publisher and subscriber will communicate with each other using MQTT. The
    subscriber will listen for a handful of MQTT topics that direct it to operate
    on or retrieve information from the MongoDB and Redis databases. The publisher
    will send these MQTT topics and print the responses.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者将通过 MQTT 进行通信。订阅者将监听若干 MQTT 主题，指示它操作或从 MongoDB 和 Redis 数据库中检索信息。发布者将发送这些
    MQTT 主题并打印响应。
- en: The publisher will be based on [Node.js](http://Node.js) version 11 and the
    subscriber will be based on [Node.js](http://Node.js) version 12\. Without Docker
    or a virtual machine, running two [Node.js](http://Node.js) versions on the same
    machine concurrently requires the use of **Node Version Manager** (**nvm**) and
    having multiple versions of [Node.js](http://Node.js) installed on your workstation.
    Docker containers make it simple to use as many versions as you need and to package
    the version, along with the app that uses it, in a nice package (a container).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者将基于 [Node.js](http://Node.js) 版本 11，订阅者将基于 [Node.js](http://Node.js) 版本 12。没有
    Docker 或虚拟机的情况下，在同一台机器上并行运行两个 [Node.js](http://Node.js) 版本需要使用 **Node 版本管理器**（**nvm**）并在工作站上安装多个版本的
    [Node.js](http://Node.js)。Docker 容器使得使用所需的多个版本变得简单，并将版本与使用该版本的应用程序一起打包成一个便捷的包（容器）。
- en: The publisher and subscriber apps are in their own `publisher/` and `subscriber/`
    subdirectories of `chapter3/` in the companion repository. These programs each
    need their own Dockerfile so that we can build the two separate containers. They
    also have their own helper `.sh` scripts ([debug.sh](http://debug.sh), [run.sh](http://run.sh),
    [build.sh](http://build.sh), and so on). The publisher app only needs to have
    an MQTT library. The subscriber app needs the MQTT library and a MongoDB library
    and a Redis library. These libraries will be installed using `np`m (the [Node.js](http://Node.js)
    package manager) within the containers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者应用程序位于伴随仓库中 `chapter3/` 目录下各自的 `publisher/` 和 `subscriber/` 子目录中。这些程序各自需要一个
    Dockerfile，以便我们可以构建两个独立的容器。它们还各自有自己的辅助 `.sh` 脚本（[debug.sh](http://debug.sh)，[run.sh](http://run.sh)，[build.sh](http://build.sh)
    等）。发布者应用只需要一个 MQTT 库。订阅者应用需要 MQTT 库、MongoDB 库和 Redis 库。这些库将通过 `npm`（[Node.js](http://Node.js)
    包管理器）在容器内安装。
- en: The publisher and subscriber apps demonstrate how a microservices architecture
    works, using multiple Docker containers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者应用程序演示了微服务架构如何工作，使用多个 Docker 容器。
- en: The subscriber connects to the MongoDB and Redis containers using [Node.js](http://Node.js)
    packages/libraries, which are installed in the container with `npm`. The subscriber
    provides basic **Create, Read, Update, and Delete** (**CRUD**) functions for adding,
    listing, removing, and retrieving count of records in each of the MongoDB and
    Redis databases. The publisher sends MQTT messages to the subscriber to invoke
    this functionality.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者通过 [Node.js](http://Node.js) 包/库连接到 MongoDB 和 Redis 容器，这些包/库通过 `npm` 在容器中安装。订阅者提供基本的
    **创建、读取、更新和删除**（**CRUD**）功能，用于在 MongoDB 和 Redis 数据库中添加、列出、删除和获取记录数量。发布者通过 MQTT
    消息向订阅者发送请求，以调用这些功能。
- en: 'Our topics are strings that are derived from a pattern: container/command.
    If we want to communicate with the subscriber, the pattern is subscriber/command.
    If we want to communicate with the publisher, the pattern is publisher/command.
    This convention makes it obvious which topics each microservice would want to
    subscribe or publish to.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主题是基于一种模式派生的字符串：container/command。如果我们想与订阅者通信，模式是 subscriber/command。如果我们想与发布者通信，模式是
    publisher/command。这个约定使得每个微服务希望订阅或发布的主题一目了然。
- en: 'The MQTT topics and messages are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT 主题和消息如下：
- en: '`subscriber/mongo-count`: Responds with the count of records in the MongoDB
    database.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/mongo-count`：返回 MongoDB 数据库中记录的数量。'
- en: '`subscriber/mongo-add`: Adds the message content to the MongoDB database.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/mongo-add`：将消息内容添加到 MongoDB 数据库。'
- en: '`subscriber/mongo-list`: Returns a JSON object that contains a list of records
    in the MongoDB database. If the message is a non-zero length string, it is used
    to filter the list of records returned.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/mongo-list`：返回一个包含 MongoDB 数据库中记录列表的 JSON 对象。如果消息是一个非零长度的字符串，则用于过滤返回的记录列表。'
- en: '`subscriber/mongo-remove`: Removes a record from the MongoDB database.  The
    message may contain a string or an object (JSON) suitable for passing to MongoDB''s
    `collection.deleteOne()` method.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/mongo-remove`：从MongoDB数据库中删除一条记录。消息可以是适合传递给MongoDB的`collection.deleteOne()`方法的字符串或对象（JSON）。'
- en: '`subscriber/mongo-removeall`: Deletes all records from the MongoDB database.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/mongo-removeall`：删除MongoDB数据库中的所有记录。'
- en: '`subscriber/redis-count`: Responds with the count of records in the Redis database.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/redis-count`：返回Redis数据库中记录的数量。'
- en: '`subscriber/redis-flushall`: Removes all the records from the Redis database.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/redis-flushall`：删除Redis数据库中的所有记录。'
- en: '`subscriber/redis-set`: Adds a record to the Redis database; the message is
    of the `key=value` form.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/redis-set`：向Redis数据库添加一条记录；消息是`key=value`形式。'
- en: '`subscriber/redis-list`: Lists all the records in the Redis database and returns
    a JSON array of records.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/redis-list`：列出Redis数据库中的所有记录，并返回一个记录的JSON数组。'
- en: '`subscriber/redis-del`: Deletes a record from the Redis database.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/redis-del`：从Redis数据库中删除一条记录。'
- en: '`subscriber/commands`: Returns a list of available commands (MQTT topics).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/commands`：返回可用命令（MQTT主题）的列表。'
- en: There are shell scripts in the root of the `chapter3/` directory that individually
    start Redis ([start-redis.sh](http://start-redis.sh)), MongoDB ([start-mongodb.sh](http://start-mongodb.sh)),
    and the Mosca MQTT broker ([start-mosca.sh](http://start-mosca.sh)), as well as
    a script, [start-all.sh](http://start-all.sh) that starts all three.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter3/`目录的根目录下有一些Shell脚本，分别启动Redis（[start-redis.sh](http://start-redis.sh)）、MongoDB（[start-mongodb.sh](http://start-mongodb.sh)）和Mosca
    MQTT代理（[start-mosca.sh](http://start-mosca.sh)），还有一个脚本[start-all.sh](http://start-all.sh)，可以启动所有三个服务。
- en: We've already detailed the workings of the [start-mongodb.sh](http://start-mongodb.sh)
    script earlier. The [start-redis.sh](http://start-redis.sh) and [start-mosca.sh](http://start-mosca.sh)
    scripts are roughly the same; just the names of the programs that are started
    (Redis and Mosca) are changed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经详细介绍了[start-mongodb.sh](http://start-mongodb.sh)脚本的工作原理。[start-redis.sh](http://start-redis.sh)和[start-mosca.sh](http://start-mosca.sh)脚本大致相同；只是启动的程序（Redis和Mosca）名称有所不同。
- en: It is important to note that the [start-mongodb.sh](http://start-mongodb.sh)
    script connects the host's port `27017` to the container's port `27017`. This
    is so that other containers can reach MongoDB via the default port. The [start-mosca.sh](http://start-mosca.sh)
    script connects ports `1883` and `80` to the host so that MQTT and MQTT, over
    WebSocket, can be used from any of the containers. The [start-redis.sh](http://start-redis.sh)
    script connects port `6379` to the host so that Redis can be accessed from the
    containers via the default Redis port. Of course, the host can access any of the
    containers as well.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，[start-mongodb.sh](http://start-mongodb.sh)脚本将主机的端口`27017`连接到容器的端口`27017`。这样，其他容器可以通过默认端口访问MongoDB。[start-mosca.sh](http://start-mosca.sh)脚本将端口`1883`和`80`连接到主机，以便可以从任意容器使用MQTT和WebSocket上的MQTT。[start-redis.sh](http://start-redis.sh)脚本将端口`6379`连接到主机，以便容器通过Redis的默认端口访问Redis。当然，主机也可以访问任何容器。
- en: The subscriber/start-subscriber.sh and [publisher-start-publisher.sh](http://publisher-start-publisher.sh)
    scripts both run the applications locally on the host, not in containers.  This
    allows host native debugging functionality, using WebStorm or another IDE or [Node.js](http://Node.js)
    debugger. Developing and debugging our publisher and subscriber entirely within
    Docker containers is covered in the next chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriber/start-subscriber.sh`和[publisher-start-publisher.sh](http://publisher-start-publisher.sh)脚本都在主机上本地运行应用程序，而不是在容器中运行。这允许使用WebStorm或其他IDE，或[Node.js](http://Node.js)调试器进行主机本地调试功能。在下一章中，将详细介绍如何在Docker容器内完全开发和调试发布者和订阅者。'
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To use the [start-subscriber.sh](http://start-subscriber.sh) and [start-publisher.sh](http://start-publisher.sh)
    scripts, you will need to install [Node.js](http://Node.js) and `yarn` on your
    development workstation. Ensure that you run `yarn install` in both `subscriber/`
    and `publisher/` directories.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用[start-subscriber.sh](http://start-subscriber.sh)和[start-publisher.sh](http://start-publisher.sh)脚本，您需要在开发工作站上安装[Node.js](http://Node.js)和`yarn`。确保在`subscriber/`和`publisher/`目录下分别运行`yarn
    install`。
- en: 'This is what [start-subscriber.sh](http://start-subscriber.sh) looks like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是[start-subscriber.sh](http://start-subscriber.sh)的样子：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The [start-publisher.sh](http://start-publisher.sh) script is identical to the
    [start-subscriber.sh](http://start-subscriber.sh) script.  The `package.json`
    file in the publisher directory signals `yarn start` to launch the publisher program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[start-publisher.sh](http://start-publisher.sh)脚本与[start-subscriber.sh](http://start-subscriber.sh)脚本完全相同。发布者目录中的`package.json`文件指示`yarn
    start`来启动发布者程序。'
- en: The `HOSTIP` variable must be set to your host machine's IP, available to our
    publisher and subscriber, and is used by our Node.js programs to address the MQTT
    broker, MongoDB server, and Redis server when connecting.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`HOSTIP`变量必须设置为主机机器的IP地址，这个地址对我们的发布者和订阅者可见，并且在我们的Node.js程序中用于连接MQTT代理、MongoDB服务器和Redis服务器。'
- en: 'To find your IP on macOS (assuming you use `192.168.*.*` as your home network
    IP address range):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上查找IP地址（假设你使用`192.168.*.*`作为家庭网络IP地址范围）：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The IP of the host is `192.168.0.19`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此主机的IP地址是`192.168.0.19`。
- en: 'To find your IP on Linux, use the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上查找IP地址，使用以下命令：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The IP of this host is `192.168.0.21`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此主机的IP地址是`192.168.0.21`。
- en: 'You will run the `start-publisher.sh` script using the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用以下命令运行`start-publisher.sh`脚本：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To run the `start-subscriber.sh` script use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`start-subscriber.sh`脚本，使用以下命令：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The publisher program is relatively simple. It connects to the MQTT broker and
    listens for topics starting with `publisher/`. The topics and messages received
    are then converted into the `subscriber/` format topics and published to MQTT.
    The subscriber responds with the `publisher` topic and the response message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者程序相对简单。它连接到MQTT代理并监听以`publisher/`开头的主题。接收到的主题和消息会被转换成`subscriber/`格式的主题，并发布到MQTT。订阅者会响应`publisher`主题和响应消息。
- en: With both the publisher and subscriber running, we use the MQTT command-line
    tool to send messages to the publisher. In the following screenshot, you can see
    how we exercise a few of the subscriber commands.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布者和订阅者都运行的情况下，我们使用MQTT命令行工具向发布者发送消息。在以下截图中，你可以看到我们如何执行一些订阅者命令。
- en: These two scripts assume that we have Mosca installed on our host. We don't
    need to install it for the MQTT broker, but for the command-line tools. Being
    able to send MQTT topics/commands from the command line on the host, in `.sh`
    scripts on the host, and in crontabs on the host is very useful. You can also
    use Mosca as a library to implement a broker in your own [Node.js](http://Node.js)
    code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个脚本假设我们已经在主机上安装了Mosca。我们不需要为MQTT代理安装它，但需要它来使用命令行工具。从主机的命令行、`.sh`脚本或主机上的crontab中发送MQTT主题/命令非常有用。你也可以将Mosca作为库来实现你自己的[Node.js](http://Node.js)代码中的代理。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For curious readers, the screenshot is of a Terminal window running tmux with
    three panes. **tmux** is a **terminal multiplexer**: it enables several terminals
    to be created, accessed, and controlled from a single screen. The tmux GitHub
    repository can be found at [https://github.com/tmux/tmux](https://github.com/tmux/tmux).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有好奇心的读者，截图显示的是运行tmux的终端窗口，分为三个窗格。**tmux**是一个**终端复用器**：它允许在一个屏幕上创建、访问和控制多个终端。tmux的GitHub仓库可以在[https://github.com/tmux/tmux](https://github.com/tmux/tmux)找到。
- en: 'In the following screenshot, you can see how we exercise a few of the subscriber
    commands:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到我们如何执行一些订阅者命令：
- en: '![Figure 3.4 – Three shells demonstrating the publisher and subscriber working
    together](img/B11641_03_004.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 三个终端展示发布者和订阅者的协同工作](img/B11641_03_004.jpg)'
- en: Figure 3.4 – Three shells demonstrating the publisher and subscriber working
    together
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 三个终端展示发布者和订阅者的协同工作
- en: As we can see, the publisher and subscriber work as expected, as do the database
    queries between containers and the host. We can edit and debug the publisher and
    subscriber programs to get them working to our satisfaction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，发布者和订阅者按预期工作，容器与主机之间的数据库查询也正常。我们可以编辑和调试发布者和订阅者程序，直到它们按我们的需求正常工作。
- en: Now that we have these working publisher and subscriber containers, we want
    to share them with the rest of the development team.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了正常工作的发布者和订阅者容器，接下来我们希望将它们与开发团队的其他成员共享。
- en: Sharing your containers on Docker Hub
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker Hub上共享你的容器
- en: To share our containers, we'll use Docker Hub and publish the two containers.
    The rest of the team can pull the pre-built containers from Docker Hub and use
    them without having to deal with the source code repository at all. They are just
    microservices to them, just as we don't need the source to Mosca, MongoDB, or
    Redis with those containers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了共享我们的容器，我们将使用 Docker Hub 并发布这两个容器。团队的其他成员可以从 Docker Hub 拉取预构建的容器并使用它们，而无需处理源代码库。他们对这些容器来说只是微服务，就像我们使用
    Mosca、MongoDB 或 Redis 容器时并不需要源代码一样。
- en: Of course, the development team is going to have to run them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发团队需要运行这些脚本。
- en: We have created an organization on Docker Hub, `dockerfordevelopers`, which
    we will use to publish the containers for this book. You won't be able to push
    to it, but we can. In order to publish to Docker Hub, you will need to use the
    `docker login` command, and you must have already created an account on [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Docker Hub 上创建了一个名为 `dockerfordevelopers` 的组织，我们将用它来发布本书的容器。你无法推送到该组织，但我们可以。为了向
    Docker Hub 发布，你需要使用 `docker login` 命令，并且必须已经在 [https://hub.docker.com/](https://hub.docker.com/)
    上创建了帐户。
- en: You can also create your own organization on Docker Hub where you can share
    your own containers. If you want to use the examples in the GitHub repository
    for this chapter, you will have to edit the scripts to replace `dockerfordevelopers`
    with your own organization name.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Docker Hub 上创建自己的组织，以便共享你自己的容器。如果你想使用本章 GitHub 仓库中的示例，你需要编辑脚本，将 `dockerfordevelopers`
    替换为你自己的组织名称。
- en: Since we are creating our own custom containers, we will need some `.sh` scripts
    for each container, as explained in the previous chapter. There are a set of `.sh`
    scripts for the publisher and the subscriber.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建自己的自定义容器，我们需要为每个容器准备一些 `.sh` 脚本，正如上一章所述。发布者和订阅者各自有一套 `.sh` 脚本。
- en: 'The Dockerfile used to build the container for the publisher is almost identical
    to the one used in the previous chapter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建发布者容器的 Dockerfile 与上一章使用的几乎完全相同：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The major difference in this Dockerfile and the one in the previous chapter
    is that we are not installing Apache and PHP, but we are inheriting from `node:12`
    and installing our [Node.js](http://Node.js) program's required packages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 与上一章中的一个主要区别是，我们没有安装 Apache 和 PHP，而是从 `node:12` 继承并安装了我们 [Node.js](http://Node.js)
    程序所需的包。
- en: We are inheriting from `node:12` in this Dockerfile for the publisher. The Dockerfile
    for the subscriber is identical, except that it inherits from `node:13`. This
    illustrates how you can have containers with different base software versions
    on the same host; this would be unpleasant to deal with on a host without containers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个发布者的 Dockerfile 中，我们从 `node:12` 继承。订阅者的 Dockerfile 完全相同，只不过它是从 `node:13`
    继承。这说明了你如何在同一主机上运行使用不同基础软件版本的容器；如果没有容器，这将是非常不便的。
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `node:12` and `node:13` containers are pulled from Docker Hub and updated
    each time we build the containers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`node:12` 和 `node:13` 容器是从 Docker Hub 拉取并在每次构建容器时进行更新的。'
- en: 'The following is the [build.sh](http://build.sh) script that is used to build
    the publisher:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于构建发布者的 [build.sh](http://build.sh) 脚本：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The [build.sh](http://build.sh) script is very short and only really consists
    of the line, a single command. It is easier to type `./`[build.sh](http://build.sh)
    instead of the whole `docker build -t dockerfordevelopers/publisher .` command.
    This also makes the process less error-prone and you don't have to memorize the
    command-line switches and format.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[build.sh](http://build.sh) 脚本非常简短，实际上只包含一行命令。输入 `./`[build.sh](http://build.sh)
    比完整输入 `docker build -t dockerfordevelopers/publisher .` 命令要容易。这也使得整个过程更不容易出错，而且你不必记住命令行选项和格式。'
- en: 'There is a nearly identical [build.sh](http://build.sh) script for the subscriber,
    too. Only the name of the container built is different: `dockerfordevelopers/subscriber`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于订阅者，亦有一个几乎相同的 [build.sh](http://build.sh) 脚本。唯一不同的是构建的容器名称：`dockerfordevelopers/subscriber`。
- en: 'The output of the [build.sh](http://build.sh) script for the publisher is as
    follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者的 [build.sh](http://build.sh) 脚本输出如下：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that the `1/9`, `2/9`, `3/9`, and so on steps map one to one to
    the lines in our Dockerfile. The first line in our Dockerfile reads `From Node:12`
    and the `Step 1/1` line reads `From Node:12`. Similarly, `Step 2/2` is the second
    line in the Dockerfile. The build process follows the Dockerfile as a series of
    steps to build the final container image.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`1/9`、`2/9`、`3/9` 等步骤与我们的 Dockerfile 中的每一行一一对应。我们 Dockerfile 中的第一行是 `From
    Node:12`，而 `Step 1/1` 行也是 `From Node:12`。类似地，`Step 2/2` 是 Dockerfile 中的第二行。构建过程按
    Dockerfile 中的步骤依次执行，最终构建出容器镜像。
- en: The last line in the output tells us that the name of the container is `dockerfordevelopers/publisher:latest`.
    We use this name to push our build container to Docker Hub.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的最后一行告诉我们容器的名称是 `dockerfordevelopers/publisher:latest`。我们使用这个名称将构建的容器推送到
    Docker Hub。
- en: 'We use the [push.sh](http://push.sh) script to perform the commands to push
    the publisher container to the organization on Docker Hub:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 [push.sh](http://push.sh) 脚本来执行将发布者容器推送到 Docker Hub 组织的命令：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is another one-line `.sh` script for our convenience.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个方便我们的单行 `.sh` 脚本。
- en: 'The following is the output of the [push.sh](http://push.sh) script for the
    publisher:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是发布者的 [push.sh](http://push.sh) 脚本的输出：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have a sort of template or pattern for working with custom containers in
    our microservices architecture project:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在微服务架构项目中，有一种用于与自定义容器协作的模板或模式：
- en: We edit and debug the code for our container.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编辑并调试我们的容器代码。
- en: We run the [build.sh](http://build.sh) script to build a container image.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行 [build.sh](http://build.sh) 脚本来构建容器镜像。
- en: We run the [push.sh](http://push.sh) script to push the container to Docker
    Hub.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行 [push.sh](http://push.sh) 脚本将容器推送到 Docker Hub。
- en: 'Your fellow developers can now run the publisher image. This is run on a second
    machine, such as a developer''s workstation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的同事们可以运行发布者镜像。这是在第二台机器上运行的，例如开发者的工作站：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Of course, on this second machine, the developer has installed and run the
    required microservices: Mosca, MongoDB, and Redis. The application will not run
    without all the microservices running within Docker.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这第二台机器上，开发者已经安装并运行了所需的微服务：Mosca、MongoDB 和 Redis。如果没有所有微服务在 Docker 中运行，应用程序将无法启动。
- en: Pushing to Docker Hub on your development host and pulling from Docker Hub on
    a production host is a simple way to deploy containers for production. It is not
    very robust, however. We will cover better schemes for deployment in later chapters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发主机上推送到 Docker Hub，并在生产主机上从 Docker Hub 拉取，是一种简单的生产环境容器部署方式。然而，这并不太健壮。我们将在后面的章节中讨论更好的部署方案。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to break up an application that would normally
    be run in a virtual machine with multiple services (MongoDB, Redis, and Mosca)
    into a microservices-based architecture run as containers within Docker.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了如何将一个通常会在虚拟机中运行并包含多个服务（MongoDB、Redis 和 Mosca）的应用程序，拆分为基于微服务的架构，并在
    Docker 容器中运行。
- en: We learned how to navigate the Docker Hub website and find useful pre-made Docker
    containers that you simply download and run.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何浏览 Docker Hub 网站，并找到一些有用的预制 Docker 容器，只需下载并运行它们。
- en: We also learned how to package our own microservices as Docker containers and
    how we can push them to Docker Hub for the public or development team members
    to use.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何将自己的微服务打包为 Docker 容器，并将它们推送到 Docker Hub，以便公共用户或开发团队成员使用。
- en: Several containers were used to launch the complete application as microservices
    communicated through ports mapped to the host's ports. This is not ideal, especially
    if you already have a WWW server running on port `80`; Mosca uses port `80`, too.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 多个容器被用来启动完整的应用程序，作为通过端口与主机端口映射的微服务进行通信。这并不理想，特别是当你已经在 `80` 端口上运行 WWW 服务器时；Mosca
    也使用 `80` 端口。
- en: In the next chapter, we will discuss how we can use the Docker Compose tool
    to design complete microservice architecture applications and run them so that
    they have a private internal network and so host ports are not required.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何使用 Docker Compose 工具设计完整的微服务架构应用程序并运行它们，以便它们拥有一个私有的内部网络，从而不再需要主机端口。
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下链接，了解本章中涉及的更多内容：
- en: 'The official Docker documentation: [https://docs.docker.com](https://docs.docker.com)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Docker 文档：[https://docs.docker.com](https://docs.docker.com)
- en: 'The Dockerfile reference: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dockerfile 参考文档: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
- en: 'The Docker Hub site: [https://hub.docker.com/](https://hub.docker.com/)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker Hub 网站: [https://hub.docker.com/](https://hub.docker.com/)'
- en: 'The documentation for Docker Hub: [https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker Hub 的文档: [https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/)'
- en: 'The documentation for the Node.js containers on Docker Hub: [https://hub.docker.com/_/node](https://hub.docker.com/_/node)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Node.js 容器在 Docker Hub 上的文档: [https://hub.docker.com/_/node](https://hub.docker.com/_/node)'
- en: 'The documentation for the Redis containers on Docker Hub: [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redis 容器在 Docker Hub 上的文档: [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)'
- en: 'The documentation for the MongoDB containers on Docker Hub: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MongoDB 容器在 Docker Hub 上的文档: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)'
- en: 'The documentation for the Mosca containers on Docker Hub: [https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mosca 容器在 Docker Hub 上的文档: [https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)'
