- en: '*Chapter 2*: Using VirtualBox and Docker Containers for Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：使用VirtualBox和Docker容器进行开发'
- en: In the previous chapter, we introduced virtualization and containerization.
    In this chapter, we'll demonstrate how you can use software such as VirtualBox
    to create virtual machines and we'll use Docker to create containers. The focus
    of this chapter will be on using these technologies for development on your workstation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了虚拟化和容器化。在本章中，我们将演示如何使用软件，如VirtualBox，创建虚拟机，并使用Docker创建容器。本章的重点是如何在工作站上使用这些技术进行开发。
- en: A common problem among developers who work on multiple projects is that, over
    time, they end up with a lot of software installed on their workstations that
    they don't currently use. This can be so problematic that the developer might
    reformat their workstation's hard drive and reinstall the operating system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在处理多个项目时，一个常见的问题是，随着时间的推移，他们会在工作站上安装大量目前不使用的软件。这可能会变得非常麻烦，甚至让开发人员不得不重装工作站的硬盘和操作系统。
- en: Both VirtualBox and Docker containers can be used to resolve this problem. The
    software you install stays within either the **virtual machine's** or the container's
    filesystem and is separate from the workstation's native filesystem. If you delete
    a virtual machine or container, all the files installed therein are removed –
    including any applications or development software that was installed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox和Docker容器都可以用来解决这个问题。你安装的软件会保留在**虚拟机**或容器的文件系统中，与工作站的本地文件系统分开。如果你删除虚拟机或容器，其中安装的所有文件都会被删除——包括任何已安装的应用程序或开发软件。
- en: Another problem that arises for developers is the version of software required
    to work on a specific project. If the developer is working on one project that
    uses Node.js v12 and another that uses Node.js v10, they can't really run both
    projects on the workstation at the same time and switching between versions of
    Node.js is doable, but ugly. This is a non-issue with virtual machines or containers
    – you can have one virtual machine with Node.js v12 and another with Node.js v10
    and run both virtual machines at the same time. It is similar with two containers,
    one for each version of Node.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员面临的另一个问题是，工作在特定项目上时需要使用的软件版本。如果开发人员在一个使用Node.js v12的项目上工作，而另一个项目使用Node.js
    v10，他们就无法在同一工作站上同时运行这两个项目，虽然切换Node.js的版本是可行的，但操作起来不太方便。使用虚拟机或容器就没有这个问题——你可以有一个运行Node.js
    v12的虚拟机，另一个运行Node.js v10，并且同时运行这两个虚拟机。容器也类似，每个版本的Node.js可以对应一个容器。
- en: Virtualization is very useful when you need to model an entire machine. If your
    production systems are virtual machines or physical machines, a virtual machine
    is a good way to emulate that environment. Virtualization is terrific for running
    a complete alternate operating system on the workstation; that is, you can run
    Windows 10 in a virtual machine on a macOS or Linux workstation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要模拟整个机器时，虚拟化非常有用。如果你的生产系统是虚拟机或物理机，虚拟机是一个很好的方式来模拟该环境。虚拟化非常适合在工作站上运行完整的替代操作系统；也就是说，你可以在macOS或Linux工作站上通过虚拟机运行Windows
    10。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Host filesystem pollution problem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机文件系统污染问题
- en: Using VirtualBox for virtual machines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VirtualBox进行虚拟机操作
- en: Using Docker containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be downloaded from: [https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2](https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以从以下链接下载：[https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2](https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际应用：
- en: '[https://bit.ly/3gX9dFE](https://bit.ly/3gX9dFE)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3gX9dFE](https://bit.ly/3gX9dFE)'
- en: Host filesystem pollution problem
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机文件系统污染问题
- en: Both virtualization and containerization solve certain problems developers face.
    There's no real point in installing server-style software systems on your workstation
    – that kind of software can be installed in a virtual machine or a Docker container.
    Using this strategy means you don't have to pollute your workstation's filesystem,
    you won't have software version conflicts, and you can run a different operating
    system than the one your workstation runs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化和容器化解决了开发人员面临的某些问题。将服务器类软件系统安装到工作站上没有太大意义——这种软件可以安装在虚拟机或 Docker 容器中。使用这种策略意味着你不必污染工作站的文件系统，不会出现软件版本冲突，并且你可以运行与工作站操作系统不同的操作系统。
- en: The pollution problem is a real concern for developers – they end up with a
    lot of cruft, or installed software, that they don't use day to day, but that
    take up system resources. We will learn to use virtualization or containerization
    to install that software in a way that isn't installed on your host's filesystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 污染问题是开发人员的一个实际关注点——他们最终会得到很多不常用的软件或安装的软件，这些软件占用了系统资源。我们将学习使用虚拟化或容器化的方式来安装这些软件，而不是直接安装到宿主的文件系统上。
- en: Using VirtualBox for virtual machines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VirtualBox 进行虚拟机操作
- en: There are several options for running virtual machines on your workstation.
    These include Parallels (for macOS), KVM/QEMU (for Linux), VMware (commercial
    for several host operating systems), and VirtualBox (an Oracle product). We'll
    use VirtualBox because it is open source and free to use. It's also portable in
    the sense that you can run VirtualBox and your virtual machines on Linux, Windows,
    macOS, and other host operating systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作站上运行虚拟机有几个选项。包括 Parallels（适用于 macOS）、KVM/QEMU（适用于 Linux）、VMware（商业版本，支持多个宿主操作系统）和
    VirtualBox（一个 Oracle 产品）。我们将使用 VirtualBox，因为它是开源的，且可以免费使用。它还具有跨平台特性，你可以在 Linux、Windows、macOS
    和其他宿主操作系统上运行 VirtualBox 和虚拟机。
- en: Introduction to virtualization
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化简介
- en: Virtualization uses special instructions and features of your workstation's
    CPU to run a generic pseudo-computer system (virtual machine) on your host. Within
    this virtual machine, you can install a wide range of operating systems, including
    various versions of Windows Server, Linux, BSD, and so on. The operating system
    running in a virtual machine is called the guest operating system; the operating
    system running on your workstation is called the host operating system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化利用工作站 CPU 的特殊指令和功能，在宿主机上运行一个通用的伪计算机系统（虚拟机）。在这个虚拟机内，你可以安装各种操作系统，包括不同版本的 Windows
    Server、Linux、BSD 等等。在虚拟机中运行的操作系统称为来宾操作系统；在工作站上运行的操作系统称为宿主操作系统。
- en: As the guest operating system executes code, it will be required to perform
    disk and network access, execute privileged CPU instructions, and otherwise access
    shared resources with the host. The virtualization software effectively traps
    these guest operating system accesses and translates them into host operating
    system calls. Thus, code running in the virtual machine is mostly running at full
    native CPU speed until these shared access traps are executed – then there is
    some overhead for the translation to host accesses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当来宾操作系统执行代码时，它需要进行磁盘和网络访问，执行特权 CPU 指令，并且访问与宿主机共享的资源。虚拟化软件有效地拦截这些来宾操作系统的访问，并将它们转换为宿主操作系统的调用。因此，虚拟机中运行的代码大部分时间都能以全速本地
    CPU 速度运行，直到执行这些共享访问的拦截——然后就会有一些额外的开销用于转换为宿主访问。
- en: The guest virtual machines may be configured before you install an operating
    system within. You can set how much RAM to use, one or more virtual disks, one
    or more Ethernet controllers, a graphics card, an ISO file (installation media)
    to insert in the virtual CD-ROM drive, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装操作系统之前，可以配置来宾虚拟机。你可以设置使用多少 RAM、一个或多个虚拟磁盘、一个或多个以太网控制器、显卡、要插入虚拟光驱的 ISO 文件（安装介质）等。
- en: You typically set RAM, disk space, and the number of virtual CPU cores to appropriate
    values for your guest operating system and the apps you intend to use within the
    guest. For example, if you are going to run Windows in a virtual machine, you
    might want to give it at least 2 virtual CPU cores and 8 gigabytes of RAM and
    32 gigabytes of disk space. If you are going to run an application in the virtual
    machine that needs more than 8 gigabytes of memory, you would want to assign more
    RAM; if the app needs a lot of disk space, you would assign more disk space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要为你的来宾操作系统以及你计划在来宾系统内使用的应用程序，设置适当的RAM、磁盘空间和虚拟CPU核心数。例如，如果你要在虚拟机中运行Windows，你可能希望分配至少2个虚拟CPU核心、8GB的RAM和32GB的磁盘空间。如果你计划在虚拟机中运行一个需要超过8GB内存的应用程序，你需要分配更多的RAM；如果该应用程序需要大量的磁盘空间，你则需要分配更多的磁盘空间。
- en: Creating a virtual machine
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建虚拟机
- en: To boot the virtual machine, use the VirtualBox program (user interface). When
    the virtual machine boots, it acts just like a physical PC – as far as the installer
    on the installation media is concerned, it is a physical PC. The installer will
    work as if you were installing on a new PC or reinstalling on your PC.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动虚拟机，请使用VirtualBox程序（用户界面）。当虚拟机启动时，它的表现就像一台物理PC——对于安装媒体上的安装程序而言，它就是一台物理PC。安装程序将像在新PC上安装或重新安装操作系统一样工作。
- en: A virtual machine may present its console or desktop within a window on your
    workstation's desktop, or it can be **headless**. A headless virtual machine is
    similar to a server machine – you access it via FTP, SSH, and so on. You would
    use a headless virtual machine when you have no use for the operating system console
    or graphical interface. The headless machine provides all the services of a server
    you would remotely access.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机可以在工作站的桌面上以窗口的形式展示其控制台或桌面，或者它可以是**无头**的。无头虚拟机类似于服务器机器——你通过FTP、SSH等方式访问它。你在不需要操作系统控制台或图形界面的情况下，使用无头虚拟机。无头机器提供你可以远程访问的所有服务器服务。
- en: 'You start a headless virtual machine from the command line instead of the VirtualBox
    user interface program. This is done via the `VBoxManage` command, which is documented
    here: [https://www.virtualbox.org/manual/ch08.html](https://www.virtualbox.org/manual/ch08.html).
    It is more likely that you will be using a guest operating system with a graphical
    user interface, though.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你从命令行启动无头虚拟机，而不是通过VirtualBox用户界面程序。这是通过`VBoxManage`命令来完成的，相关文档可以在这里找到：[https://www.virtualbox.org/manual/ch08.html](https://www.virtualbox.org/manual/ch08.html)。不过，你更有可能使用带图形用户界面的来宾操作系统。
- en: A typical headless virtual machine might be used to run a **LAMP** application—**Linux,
    Apache, MySQL, and PHP** all contained neatly within the virtual machine and not
    within the filesystem of your workstation. You can model a scalable LAMP application
    by starting a headless virtual machine that runs MySQL and two headless virtual
    machines that run the HTTP server and the PHP code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的无头虚拟机可能会用于运行**LAMP**应用程序——**Linux, Apache, MySQL和PHP**都被整齐地包含在虚拟机内，而不是工作站的文件系统中。你可以通过启动一个无头虚拟机来运行MySQL，然后启动两个无头虚拟机，分别运行HTTP服务器和PHP代码，从而模拟一个可扩展的LAMP应用程序。
- en: A typical graphics/desktop virtual machine might be used to run Windows in a
    window on your Mac computer, to run Linux in a window on your Mac computer, to
    run Linux in a window on your Windows machine, and so on. If you like to use Linux,
    but you need to run Windows programs, doing it in a virtual machine is a good
    way to go.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的图形/桌面虚拟机可能会被用来在你的Mac电脑上以窗口形式运行Windows，在Mac电脑上以窗口形式运行Linux，或在Windows机器上以窗口形式运行Linux，等等。如果你喜欢使用Linux，但需要运行Windows程序，使用虚拟机是一个不错的选择。
- en: A non-headless install will have a few display options. The entire desktop can
    be displayed in a window on your host's desktop. This is the default display mode.
    The window can be resized like any other window on the desktop. However, within
    the interior of the window, the guest's desktop will not resize to fit until you
    install the VirtualBox guest additions in the guest.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 非无头安装将提供一些显示选项。整个桌面可以在主机的桌面上以窗口形式显示。这是默认的显示模式。该窗口可以像桌面上的其他窗口一样调整大小。然而，在窗口内部，来宾系统的桌面不会自动调整大小，直到你在来宾系统中安装VirtualBox增强功能。
- en: The guest window can be made full screen. This makes the guest look like it's
    the operating system running native on the workstation. If you are running macOS,
    you can switch desktops using the macOS gestures and go back and forth between
    full-screen Windows and full-screen macOS desktops.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 来宾窗口可以设置为全屏模式。这样，来宾操作系统看起来就像是原生运行在工作站上一样。如果你正在运行 macOS，你可以使用 macOS 手势切换桌面，并在全屏的
    Windows 和全屏的 macOS 桌面之间来回切换。
- en: For some host operating systems, the guest can be put into seamless mode, where
    the desktop is not displayed at all, but any applications running in the virtual
    machine render their windows on top of the host desktop.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些主机操作系统，来宾操作系统可以进入无缝模式，在这种模式下，桌面完全不显示，但虚拟机中运行的任何应用程序会将其窗口显示在主机桌面之上。
- en: 'The result is a mixture of virtual machine application windows and your host
    operating system application menus on your desktop, as shown in the following
    screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是虚拟机应用程序窗口和主机操作系统应用程序菜单混合显示在桌面上，如下图所示：
- en: '![Figure 2.1 – Microsoft Windows 10 running fullscreen in VirtualBox on a Linux
    host](img/B11641_02_001.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 在 Linux 主机上的 VirtualBox 中全屏运行 Microsoft Windows 10](img/B11641_02_001.jpg)'
- en: Figure 2.1 – Microsoft Windows 10 running fullscreen in VirtualBox on a Linux
    host
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 在 Linux 主机上的 VirtualBox 中全屏运行 Microsoft Windows 10
- en: As you can see, you may run and manage a full Windows installation on your workstation
    within a virtual machine. You can access the files and directories on your host
    if you set up Samba for file sharing on the host.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以在虚拟机中运行并管理完整的 Windows 安装，并可以访问主机上的文件和目录，如果你为主机设置了 Samba 文件共享。
- en: Incidentally, portions of this book were written using Microsoft Word 365, running
    in a Windows 10 virtual machine on a Linux host. The Docker examples that follow
    were executed on the Linux host. This is a great example of why you would run
    a virtual machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，本书的部分内容是使用 Microsoft Word 365 编写的，该程序在 Linux 主机上的 Windows 10 虚拟机中运行。接下来的
    Docker 示例是在 Linux 主机上执行的。这是一个很好的例子，说明为什么要运行虚拟机。
- en: 'Note:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Microsoft allows you to buy a Windows 10 license and use it to activate Windows
    10 within a virtual machine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微软允许你购买 Windows 10 许可证，并使用它在虚拟机中激活 Windows 10。
- en: Apple only allows macOS to be run in a virtual machine on Apple hardware. It
    is a violation of their licensing terms to run macOS within a virtual machine
    on a PC running Windows or Linux.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果只允许在苹果硬件上运行 macOS 虚拟机。在运行 Windows 或 Linux 的 PC 上运行 macOS 虚拟机违反了它们的许可条款。
- en: Linux and most BSD variants are generally free to use on a PC or within a virtual
    machine on a PC.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和大多数 BSD 变种通常可以在 PC 或虚拟机中免费使用。
- en: Guest additions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来宾增强功能
- en: 'For Windows and Linux guest operating systems, you can install drivers that
    fully integrate the guest and host operating systems. These drivers are known
    as guest additions and you can download these from the VirtualBox site: [https://virtualbox.org](https://virtualbox.org).
    They are installed within the virtual machine as any program you install for Windows
    or Linux. The integration with the host is quite useful.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 和 Linux 来宾操作系统，你可以安装驱动程序，完全将来宾操作系统与主机操作系统集成。这些驱动程序被称为来宾增强功能，你可以从
    VirtualBox 网站下载：[https://virtualbox.org](https://virtualbox.org)。它们会像你为 Windows
    或 Linux 安装的任何程序一样，安装在虚拟机中。与主机的集成非常有用。
- en: The guest additions display drivers that allow you to use the full resolution
    of the host's screen and, if you're running in windowed mode (guest desktop in
    a host desktop window), resizing the window will cause the guest desktop to resize
    to fit the new window size. If you want to use the seamless windows feature, you
    are required to install the guest display drivers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 来宾增强功能中的显示驱动程序允许你使用主机屏幕的完整分辨率，并且如果你以窗口模式运行（来宾桌面在主机桌面窗口中），调整窗口大小会导致来宾桌面自动调整大小以适应新窗口大小。如果你想使用无缝窗口功能，则必须安装来宾显示驱动程序。
- en: The additions provide mouse pointer integration. This allows you to freely move
    the cursor between physical screens, from guest windows to host windows. Otherwise,
    the mouse would be captured by the virtual machine so that it can manage pointer
    events.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些增强功能提供了鼠标指针集成功能。这样你可以自由地在物理屏幕之间移动光标，从来宾窗口切换到主机窗口。否则，鼠标会被虚拟机捕获，以便管理指针事件。
- en: The guest additions also share the host and guest clipboards as if they were
    one clipboard. You can select and copy text in a macOS host application and then
    paste that copied text into a Windows application running in the virtual machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端附加功能还可以像共享一个剪贴板一样，分享主机和客户机的剪贴板。你可以在 macOS 主机应用程序中选择并复制文本，然后将复制的文本粘贴到虚拟机中运行的
    Windows 应用程序里。
- en: For Linux guests, the additions allow you to share host filesystem directories
    and files. This is particularly useful because you can use the host operating
    system tools and software to develop files seen by the host. For example, you
    create a shared folder on your macOS machine for your project's working directory.
    You can use your macOS editors to edit files in the project and, in the virtual
    machine, you can run Linux native compilers or tools to execute your project.
    Let's now begin by installing VirtualBox.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 客户机，附加功能允许你共享主机的文件系统目录和文件。这尤其有用，因为你可以使用主机操作系统的工具和软件来开发主机可见的文件。例如，你可以在
    macOS 机器上为你的项目工作目录创建一个共享文件夹。你可以使用 macOS 编辑器来编辑项目中的文件，而在虚拟机中，你可以运行 Linux 本地编译器或工具来执行你的项目。现在我们开始安装
    VirtualBox。
- en: Installing VirtualBox
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 VirtualBox
- en: The URL for VirtualBox is [https://www.virtualbox.org/](https://www.virtualbox.org/).
    There, you can find documentation and downloads for the various host platforms
    (workstation operating systems), add-ons, see screenshots, see recommended third-party
    software that works with VirtualBox, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 的网址是 [https://www.virtualbox.org/](https://www.virtualbox.org/)。在这里，你可以找到不同主机平台（工作站操作系统）的文档和下载内容，附加组件，查看截图，查看与
    VirtualBox 兼容的推荐第三方软件等。
- en: Windows installation instructions
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 安装说明
- en: To install the Windows installation, go to the downloads page at the VirtualBox
    site, download the installer for the latest version, and then, when the download
    is complete, double-click on it. Then, follow the onscreen instructions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Windows 版本，前往 VirtualBox 网站的下载页面，下载最新版本的安装程序，然后在下载完成后双击它。接着，按照屏幕上的指示操作。
- en: macOS installation instructions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS 安装说明
- en: 'For macOS installation, you can use Homebrew or download the installer `.dmg`
    file from the VirtualBox site and install from that. To use Homebrew, you only
    need to enter one command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 安装，你可以使用 Homebrew 或从 VirtualBox 网站下载 `.dmg` 安装文件并从中安装。使用 Homebrew，你只需输入一条命令：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Homebrew ([https://brew.sh/](https://brew.sh/)) is the missing package manager
    for macOS. It is a command-line system for installing software from Homebrew's
    repositories. It is a terrific tool for augmenting the software shipped with macOS.
    The software in those repositories is updated far more frequently than the Apple
    software updates.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew ([https://brew.sh/](https://brew.sh/)) 是 macOS 缺失的包管理器。它是一个命令行系统，用于从
    Homebrew 的仓库中安装软件。它是一个极好的工具，可以增强 macOS 随附的应用软件。这些仓库中的软件更新频率远高于苹果的软件更新。
- en: Linux installation instructions
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 安装说明
- en: The installation instructions for VirtualBox on Linux varies depending on the
    Linux distribution that you use on your workstation. Since there are so many different
    distributions, we'll cover Ubuntu to give you an idea of what to do and provide
    you with helpful pointers for installing VirtualBox on other distributions (Arch
    Linux, Fedora, and suchlike).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 VirtualBox 的说明会根据你在工作站上使用的 Linux 发行版而有所不同。由于有很多不同的发行版，我们将以 Ubuntu
    为例，给你一个大致的安装步骤，并为你提供安装 VirtualBox 的其他发行版（如 Arch Linux、Fedora 等）的有用提示。
- en: 'For Ubuntu, you can install VirtualBox from the Ubuntu Software Center, download
    a `.deb` file from the VirtualBox site, or use `apt`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ubuntu，你可以从 Ubuntu 软件中心安装 VirtualBox，或者从 VirtualBox 网站下载 `.deb` 文件，或使用 `apt`：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For Arch Linux and its variants, you can follow the instructions on the terrific
    Arch wiki at [https://wiki.archlinux.org/index.php/VirtualBox](https://wiki.archlinux.org/index.php/VirtualBox).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Arch Linux 及其变种，你可以按照 Arch 维基网站上的说明操作：[https://wiki.archlinux.org/index.php/VirtualBox](https://wiki.archlinux.org/index.php/VirtualBox)。
- en: 'For Fedora or other RPM-based Linux distributions, follow the instructions
    at the VirtualBox site: [https://virtualbox.org](https://virtualbox.org). Let''s
    now learn how to use Docker containers.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Fedora 或其他基于 RPM 的 Linux 发行版，请按照 VirtualBox 网站上的说明操作：[https://virtualbox.org](https://virtualbox.org)。现在我们来了解如何使用
    Docker 容器。
- en: Using Docker containers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器
- en: Docker is generally used to create containers, which run your application as
    if in a headless virtual machine. In fact, on host operating systems that are
    not Linux-based, Docker effectively runs Linux in a virtual machine and runs your
    containers within that virtual machine. This is done transparently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 通常用于创建容器，这些容器运行你的应用程序，就像在无头虚拟机中一样。实际上，在非 Linux 系统上，Docker 实际上是在虚拟机中运行
    Linux，并在该虚拟机中运行你的容器。这是透明进行的。
- en: 'Note:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: You don't have to install VirtualBox yourself. Docker is packaged in such a
    way that it will install or use any already-existing virtualization technology
    (for example, a hypervisor) for your operating system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必自己安装 VirtualBox。Docker 的打包方式使得它能够安装或使用操作系统中已经存在的虚拟化技术（例如虚拟机监控器）。
- en: Introduction to containers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器简介
- en: Earlier versions of Docker installed VirtualBox to create its virtual machine,
    but more recent virtualization technology implemented within the operating systems
    allows Docker to use those technologies instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的早期版本安装了 VirtualBox 来创建虚拟机，但操作系统中实现的更新虚拟化技术使得 Docker 可以使用这些技术，而不必依赖 VirtualBox。
- en: Docker for Linux containers expects the host operating system or the virtual
    machine to be running Linux. The containers share the Linux kernel with the host.
    Docker can be used to run Windows native containers, in a similar manner to Linux
    containers. The Windows kernel is shared among the host and guests. For discussion
    purposes, we'll focus on the Linux host and guests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为 Linux 容器而设计，期望宿主操作系统或虚拟机运行 Linux。容器与宿主共享 Linux 内核。Docker 也可以用于运行 Windows
    原生容器，方式与 Linux 容器类似。Windows 内核在宿主和客户端之间共享。为了讨论方便，我们将重点讨论 Linux 宿主和客户端。
- en: 'Docker containers are typically used to implement something like headless virtual
    machines. The use of virtual machines for each application you might create a
    container for is expensive – you must reserve a fixed amount of RAM and disk space
    for the virtual machine. On a 16 gigabyte RAM MacBook Pro, you can roughly fit
    three 4 gigabyte RAM virtual machines running at the same time. You do need to
    have some RAM for the host operating system to run. Starving the host or guest
    virtual machines of RAM will cause them to swap, which crushes performance:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器通常用于实现类似无头虚拟机的功能。每个应用程序可能创建一个容器，而使用虚拟机的成本较高——你必须为虚拟机保留固定的 RAM 和磁盘空间。在一台
    16GB RAM 的 MacBook Pro 上，你大致可以同时运行三个 4GB RAM 的虚拟机。但你还是需要为宿主操作系统保留一些内存。给宿主或虚拟机分配不足的内存会导致它们交换数据，这会极大地降低性能：
- en: '![Figure 2.2 – Docker containers illustrated](img/B11641_02_002.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Docker 容器示意图](img/B11641_02_002.jpg)'
- en: Figure 2.2 – Docker containers illustrated
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Docker 容器示意图
- en: Containers are separated from the host operating system using host operating
    system features. The containers use the Linux kernel's namespaces feature ([https://manpages.debian.org/stretch/manpages/namespaces.7.en.html](https://manpages.debian.org/stretch/manpages/namespaces.7.en.html))
    to separate the code running in containers from one another, and cgroups (see
    [https://manpages.debian.org/stretch/manpages/cgroups.7.en.html](https://manpages.debian.org/stretch/manpages/cgroups.7.en.html))
    to limit the resources that a container may use (including RAM and CPU). Containers
    also use the Linux `unionfs` ([https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html](https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html))
    filesystem to implement the layered filesystem our containers see when running
    under Docker.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过宿主操作系统的特性与宿主操作系统分隔开。容器使用 Linux 内核的命名空间功能 ([https://manpages.debian.org/stretch/manpages/namespaces.7.en.html](https://manpages.debian.org/stretch/manpages/namespaces.7.en.html))
    来将容器内的代码相互隔离，并使用 cgroups（参见 [https://manpages.debian.org/stretch/manpages/cgroups.7.en.html](https://manpages.debian.org/stretch/manpages/cgroups.7.en.html)）来限制容器可以使用的资源（包括
    RAM 和 CPU）。容器还使用 Linux 的 `unionfs` ([https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html](https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html))
    文件系统来实现容器在 Docker 下运行时看到的分层文件系统。
- en: From the applications running within the container's point of view, the container
    is a whole and dedicated computer; there is no direct communication with the host
    operating system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器内部运行的应用程序的角度来看，容器是一个完整且专用的计算机；它与宿主操作系统没有直接的通信。
- en: Containers do not require the number of virtual CPUs or a dedicated block of
    RAM per container.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不需要为每个容器指定虚拟 CPU 数量或专用的 RAM 块。
- en: You are only limited by how much RAM the containers need and how much RAM the
    host has.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你的限制仅在于容器所需的 RAM 和主机的 RAM 大小。
- en: Containers share the host's Linux kernel, while virtual machines must have a
    whole operating system installed!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 容器共享主机的 Linux 内核，而虚拟机则必须安装完整的操作系统！
- en: You may choose to limit the resources used by a container instance, but this
    is not required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择限制容器实例使用的资源，但这不是必须的。
- en: Host resources may be shared with the guest containers. The host's networking
    can be shared with any container, but this is only really needed for containers
    running applications that require this. For example, to use the host's Bonjour
    networking functionality, the guest would use the host's networking.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 主机资源可以与客容器共享。主机的网络可以与任何容器共享，但这仅对运行需要此功能的应用程序的容器有用。例如，要使用主机的 Bonjour 网络功能，客容器会使用主机的网络。
- en: The guest containers may expose ports to the host and any computers that can
    access the host. For example, a container running an HTTP server might expose
    port 80 and, when the host is accessed at port 80, the container responds.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 客户容器可能会将端口暴露给主机和任何可以访问主机的计算机。例如，运行 HTTP 服务器的容器可能会暴露端口 80，当访问主机的端口 80 时，容器会作出响应。
- en: Containers have driven the concept of microservices. An application using microservice
    architecture implements a collection of services that communicate among themselves
    and the host. These services are meant to be trivial to implement – only the specific
    code required to support the service needs to be included in the program. It's
    not uncommon for microservices to be implemented in a single source code file
    with just a few lines of code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器推动了微服务的概念。使用微服务架构的应用程序实现了一组可以相互通信并与主机通信的服务。这些服务的实现非常简单——仅需要包含支持服务所需的特定代码。微服务通常在一个源代码文件中实现，代码行数很少。
- en: Container architecture is quite scalable. You can run multiple containers running
    the same application (horizontal scaling) and you can dedicate more host resources
    to the container system (vertical scaling). For example, you might create a container
    running an HTTP server; you can create a server farm by instantiating as many
    of these containers as you desire.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 容器架构具有很高的可扩展性。你可以运行多个容器来运行相同的应用程序（横向扩展），还可以为容器系统分配更多的主机资源（纵向扩展）。例如，你可以创建一个运行
    HTTP 服务器的容器；你可以通过实例化任意数量的这些容器来创建一个服务器农场。
- en: Using Docker for development
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 进行开发
- en: A great reason to use Docker for development is that you don't have to install
    any programs, other than Docker itself, on your host to enable development. For
    example, you can run Apache in a container without installing it on your workstation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 进行开发的一个重要理由是，你不需要在主机上安装除了 Docker 本身以外的任何程序来启用开发。例如，你可以在容器中运行 Apache，而无需在工作站上安装它。
- en: You can also mix and match software versions within your containers. A microservices
    architecture might require one container to use Node.js version 8 and another
    container to use Node.js version 10\. This is obviously problematic on a single
    host, but is straightforward when using Docker. One container installs and runs
    version 8, and another container installs and runs version 10.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在容器中混合和匹配不同的软件版本。例如，一个微服务架构可能需要一个容器使用 Node.js 版本 8，另一个容器使用 Node.js 版本 10。这在单个主机上显然是有问题的，但在使用
    Docker 时非常简单。一个容器安装并运行版本 8，另一个容器安装并运行版本 10。
- en: During development, you can share your project's development files with the
    container so that when you edit these files, the container sees that the files
    have changed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可以将项目的开发文件与容器共享，这样当你编辑这些文件时，容器就会看到文件的变化。
- en: Each container has its own set of global environment variables. It's typical
    to configure the application using environment variables, rather than in source
    code or configuration files within the container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都有自己的一组全局环境变量。通常的做法是使用环境变量来配置应用程序，而不是在容器内的源代码或配置文件中进行配置。
- en: When you are ready to deploy or publish a container, you can push it to a container
    hosting service, such as Docker Hub. In fact, Docker Hub is a terrific source
    for already-existing containers that may aid you in your project development.
    There are pre-made container images for MongoDB, Node.js (various versions), Apache,
    and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备部署或发布一个容器时，可以将其推送到容器托管服务，如 Docker Hub。事实上，Docker Hub 是一个非常好的资源，里面有许多现成的容器，可以帮助你进行项目开发。比如
    MongoDB、Node.js（多个版本）、Apache 等等，都有预先制作好的容器镜像。
- en: Container construction is effectively object-oriented. You inherit from a base
    container and add the functionality you need to that. You can create a Node.js
    application in a container that starts with a ready-made Node.js container, install
    `npm` packages in the container, and run your custom code in the container.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 容器构建实际上是面向对象的。你从一个基础容器继承，并在其上添加所需的功能。你可以在一个从现成的 Node.js 容器开始的容器中创建 Node.js 应用程序，在容器中安装
    `npm` 包，并运行你自定义的代码。
- en: You can always develop your own base containers. For these, you can start with
    ready-made packages for a flavor of Linux. The Alpine Linux base container is
    popular because it is one of the most lightweight images to start from. There
    are base containers for Fedora, Ubuntu, Arch Linux, and more. Whichever of these
    Linux containers you start from, you can use that operating system's installation
    tools to add packages from the official repositories for that operating system;
    that is, `apt` for Ubuntu, `yum` for Fedora, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终可以开发自己的基础容器。对于这些容器，你可以从现成的 Linux 发行版包开始。Alpine Linux 基础容器很受欢迎，因为它是最轻量级的起始镜像之一。Fedora、Ubuntu、Arch
    Linux 等都有基础容器。无论你从哪个 Linux 容器开始，你都可以使用该操作系统的安装工具，从该操作系统的官方仓库中添加包；也就是说，Ubuntu 使用
    `apt`，Fedora 使用 `yum`，等等。
- en: It's a good idea to Dockerize an existing application that wasn't designed to
    run in a container. You can choose a flavor and version of Linux for the container
    that is compatible with the application, and you can split up the application
    into multiple container images to afford future scalability.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个原本没有设计为在容器中运行的现有应用程序 Docker 化是一个好主意。你可以为容器选择一个与应用程序兼容的 Linux 发行版和版本，并将应用程序拆分成多个容器镜像，以便未来可以扩展。
- en: For example, you might have an older LAMP application that requires specific
    versions of PHP, MySQL, and Apache, as well as an older version of Ubuntu. You
    would break this up into a distinct MySQL container, and a distinct Apache plus
    PHP container. You would want your Apache+PHP containers to use a shared volume
    so that they're all running the same and latest PHP source code. You can set up
    the MySQL container to use master-slave replication. You can set up a load balancer
    in another container that balances between as many Apache and PHP container instances
    as you choose.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个旧版的 LAMP 应用程序，需要特定版本的 PHP、MySQL 和 Apache，以及较旧版本的 Ubuntu。你可以将其拆分为一个独立的
    MySQL 容器和一个独立的 Apache 加 PHP 容器。你希望你的 Apache+PHP 容器使用共享卷，以便它们都运行相同的最新 PHP 源代码。你可以设置
    MySQL 容器使用主从复制。你还可以在另一个容器中设置负载均衡器，将请求平衡到任意数量的 Apache 和 PHP 容器实例上。
- en: Time for a hands-on example, using Docker for development.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行一个实践示例，使用 Docker 进行开发了。
- en: Getting started with Docker
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Docker
- en: We have created a GitHub repository to share code examples for this book. The
    repository can be found at [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers).
    You should fork this repository, and then clone it to your host. Creating the
    fork means you can manage your copy of the repository as you see fit without requiring
    permissions. The code of interest for this section is in the `chapter2/` directory.
    The code here implements a small Apache+PHP application that is designed to run
    in a container. There are `sh` scripts to perform the Docker command lines, so
    you don't have to keep typing in a long string of command-line arguments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 GitHub 仓库来共享本书的代码示例。你可以在 [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)
    找到该仓库。你应该 fork 这个仓库，然后将其克隆到你的主机上。创建 fork 后，你可以根据自己的需要管理你复制的仓库，无需权限。此部分的相关代码位于
    `chapter2/` 目录下。这里的代码实现了一个小型的 Apache+PHP 应用程序，旨在容器中运行。这里有一些 `sh` 脚本，用于执行 Docker
    命令行，你无需不断输入长串的命令行参数。
- en: 'Before we get into the code, let''s make sure that Docker is installed properly.
    The `docker ps` command prints a list of all running Docker containers. We can
    see we have no containers running and there is an actual `docker` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，先确保 Docker 正确安装。`docker ps` 命令会列出所有正在运行的 Docker 容器。我们可以看到目前没有容器在运行，并且确实可以使用
    `docker` 命令：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A Dockerfile is a text file that defines how to build a Docker container image.
    The container is not started; it is just created on disk. Once built, you can
    start as many instances as you wish.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个文本文件，用于定义如何构建 Docker 容器镜像。容器本身并不会启动；它只是被创建在磁盘上。构建完成后，你可以启动任意多个容器实例。
- en: Automating Docker commands via sh scripts
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 sh 脚本自动化 Docker 命令
- en: 'We''re going to make heavy use of the `docker cli` command and `sh` scripts
    to automate command-line use. The use of `sh` script files has a few advantages.
    Once the script file is created, you don''t have to remember what all the command-line
    switches to the command are. Once the script is correct, you won''t have any issues
    due to typos or improper command-line switches. Typing the script filename is
    much shorter and your shell should autocomplete it when you type the first few
    characters of the name and hit the *Tab* key. Finally, the names of the scripts
    are mnemonic: `build.sh` means build the container, `run.sh` means run the container,
    and so on.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大量使用 `docker cli` 命令和 `sh` 脚本来自动化命令行操作。使用 `sh` 脚本文件有几个优点。一旦脚本文件创建完成，你不必记住所有命令行参数。脚本正确后，你就不会因为拼写错误或命令行参数不正确而遇到问题。输入脚本文件名更简短，且当你输入文件名的前几个字符并按下
    *Tab* 键时，Shell 会自动补全文件名。最后，脚本的命名具有助记性：`build.sh` 表示构建容器，`run.sh` 表示运行容器，等等。
- en: 'The `sh` scripts we provide are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的 `sh` 脚本如下：
- en: '`./build.sh`: This builds the container from the Dockerfile. You will want
    to run this script whenever you edit the Dockerfile, or if the container otherwise
    needs to be built.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./build.sh`：此脚本用于根据 Dockerfile 构建容器。每当你编辑 Dockerfile 或容器需要重新构建时，应该运行此脚本。'
- en: '`./debug.sh`: This runs the container in debug mode. In debug mode, Apache
    is run in foreground mode and you can hit `^C` to stop the container.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./debug.sh`：此脚本以调试模式运行容器。在调试模式下，Apache 会在前台模式运行，你可以按 `^C` 停止容器。'
- en: '`./run.sh`: This runs the container as a daemon. Unlike the `./debug.sh` script,
    you will be returned to the command-line prompt, with the container running in
    Docker. You will use this script to run the container locally, as if in production,
    so that you can test production behavior.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./run.sh`：此脚本以守护进程模式运行容器。与 `./debug.sh` 脚本不同，容器将在 Docker 中运行，同时你会返回到命令行提示符。你可以使用此脚本在本地运行容器，模拟生产环境，以测试生产环境下的行为。'
- en: '`./stop.sh`: When you have your container running in the background, this script
    can be used to stop it.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./stop.sh`：当容器在后台运行时，可以使用此脚本停止容器。'
- en: '`./shell.sh`: Sometimes, when creating your container and editing the Dockerfile,
    things do not work as expected. You can use this script to get a Bash command
    line running within the container. From this command line, you can inspect and
    diagnose the problems.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./shell.sh`：有时在创建容器和编辑 Dockerfile 时，可能会出现预期之外的问题。你可以使用此脚本在容器内启动 Bash 命令行。通过此命令行，你可以检查并诊断问题。'
- en: '`./persist.sh`: This script demonstrates using a named volume to persist the
    application state within the container. That is, with a named volume, you can
    stop and restart the container and the contents of the volume are persisted. The
    volume is mounted in the container as if it were a disk.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./persist.sh`：此脚本演示如何使用命名卷在容器内持久化应用程序状态。也就是说，使用命名卷后，你可以停止并重启容器，而卷的内容会被持久化。该卷会作为磁盘挂载到容器中。'
- en: 'To demonstrate how building a container using a Dockerfile works, we''ve created
    one in the GitHub repository, in the `chapter2/` directory (file named `Dockerfile`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用 Dockerfile 构建容器，我们在 GitHub 仓库的 `chapter2/` 目录下创建了一个文件（文件名为 `Dockerfile`）：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s look at what the Dockerfile does, step by step:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步看看 Dockerfile 是如何工作的：
- en: The Dockerfile inherits from the Debian image on Docker Hub.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile 继承自 Docker Hub 上的 Debian 镜像。
- en: We set the time zone for the container to match the time zone of the host; in
    other words, ensure that the timestamps of files inside the container and on the
    host match. This is important when mapping host directories to the container's
    filesystem.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将容器的时区设置为与主机的时区匹配；换句话说，确保容器内文件和主机上的文件时间戳一致。这在将主机目录映射到容器的文件系统时非常重要。
- en: We then install Apache and PHP 7.3\. These are installed in the container's
    filesystem and not on the host's filesystem. We have avoided the pollution problem
    of having a version of both installed on the host that later become unused when
    not working on this project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们安装 Apache 和 PHP 7.3。这些安装在容器的文件系统中，而不是主机的文件系统中。我们避免了安装版本混乱的问题，这样在不进行该项目工作时，主机上的版本不会变得冗余。
- en: We also installed some command-line utilities that allow us to examine the state
    of the built container from a Bash shell running within the container.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还安装了一些命令行工具，允许我们通过容器内运行的 Bash shell 检查构建容器的状态。
- en: By default, the user and group that will be running the project in the container
    is `root`. In order to provide some typical Unix/Linux security, we want to run
    as an actual user; in our case, the username is `app`. So we add the user to the
    container's environment with `useradd`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，在容器中运行项目的用户和组是 `root`。为了提供一些典型的 Unix/Linux 安全性，我们希望以实际用户身份运行；在我们的案例中，用户名是
    `app`。因此，我们通过 `useradd` 将该用户添加到容器的环境中。
- en: We are going to put our PHP scripts in `/home/app`, with the ability to map
    our working directory with our PHP scripts on the host over `/home/app`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把我们的 PHP 脚本放在 `/home/app` 目录，并能够将我们的工作目录与主机上的 PHP 脚本映射到 `/home/app`。
- en: Our demo app writes its state to `/data`, so we need to create it and ensure
    that the PHP script running as a user app can read and write files there.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的演示应用程序将其状态写入 `/data`，因此我们需要创建该目录并确保作为用户应用运行的 PHP 脚本可以在其中读写文件。
- en: We created a custom PHP configuration file that we want to use within the container,
    so we copy it to the container in the correct location in the filesystem.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的 PHP 配置文件，想要在容器内使用，因此我们将其复制到容器的正确文件系统位置。
- en: We need to enable the `userdir` and `php7.3` modules. This allows us to run
    PHP scripts from Apache as well as have our PHP scripts in `/home/app/public_html`
    accessed via a URL such as `http://localhost/~app/index.php`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要启用 `userdir` 和 `php7.3` 模块。这使我们能够通过 Apache 运行 PHP 脚本，并且可以通过如 `http://localhost/~app/index.php`
    这样的 URL 访问我们位于 `/home/app/public_html` 的 PHP 脚本。
- en: When the container is started, it needs to run some program or script within
    the container. We use an `sh` script named `entrypoint.sh` in the `/home/app`
    directory to start the application. We can edit this file to suit our needs during
    development.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器启动时，它需要在容器内运行一些程序或脚本。我们使用一个名为 `entrypoint.sh` 的 `sh` 脚本，位于 `/home/app` 目录中来启动应用程序。我们可以在开发过程中根据需要编辑这个文件。
- en: We could have chosen from a variety of Linux flavors from which to start. We
    chose Debian here because the configuration commands should be familiar to most
    readers. If you install Debian in a virtual machine, you'd use the same commands
    to install and maintain your system. Debian isn't the smallest or most lightweight
    of Linux images to start from; Alpine is a great choice if you want to make your
    container use fewer resources. If you choose to use Alpine, be sure to read up
    on how to install packages and maintain the system using Alpine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以从多种 Linux 发行版中选择作为起点。我们在这里选择 Debian，因为配置命令对大多数读者来说应该比较熟悉。如果你在虚拟机中安装 Debian，你将使用相同的命令来安装和维护系统。Debian
    并不是最小或最轻量的 Linux 镜像；如果你希望容器使用更少的资源，Alpine 是一个不错的选择。如果你选择使用 Alpine，务必阅读如何在 Alpine
    中安装包和维护系统。
- en: Note that whichever Linux image you start from, it's sharing the Linux kernel
    with your host machine. Only within the container is it Debian – your host operating
    system can be some other Linux distribution. What you install inside the container
    is not installed on your workstation, only within the container. Obviously, you
    shouldn't mix, say, Debian commands and installed packages directly on an Arch
    Linux workstation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论你从哪个 Linux 镜像开始，它都与主机共享 Linux 内核。在容器内，它才是 Debian —— 你的主机操作系统可能是其他的 Linux
    发行版。你在容器内安装的内容不会安装到你的工作站上，只会安装在容器内。显然，你不应该直接在 Arch Linux 工作站上混用，例如 Debian 命令和已安装的包。
- en: When you install Apache on an actual host or virtual machine, you configure
    it by using the `a2enmod` and `a2dismod` commands, as well as by editing the various
    configuration files in `/etc/apache2`. What we do here is edit the configuration
    file locally on our workstation, and then we copy that configuration file to the
    container.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实际主机或虚拟机上安装 Apache 时，你会使用 `a2enmod` 和 `a2dismod` 命令进行配置，并通过编辑 `/etc/apache2`
    中的各种配置文件来完成配置。我们在这里所做的是在工作站上本地编辑配置文件，然后将该配置文件复制到容器中。
- en: The Dockerfile installs a few Debian applications within the container using
    `apt-get`. The `RUN` command that spawns `apt-get` within the container uses the
    `-y` switch to answer `yes` to any questions `apt-get` might ask, the `-qq` switch
    to make the `apt-get` command less verbose, and the `>/dev/null` redirection of
    `stdio` to make the Docker build (`build.sh`) output compact. Without the `-qq`
    and `stdout` redirection, the build output would contain every package and dependency
    downloaded, along with all the installation commands for all these packages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 在容器内使用 `apt-get` 安装了一些 Debian 应用程序。容器内启动 `apt-get` 的 `RUN` 命令使用了
    `-y` 开关来自动回答 `apt-get` 可能提出的任何问题，使用 `-qq` 开关让 `apt-get` 命令输出更简洁，同时使用 `>/dev/null`
    重定向 `stdio` 以使 Docker 构建（`build.sh`）的输出更加简洁。如果没有 `-qq` 和 `stdout` 重定向，构建输出将包含下载的每个包和依赖项，以及所有这些包的安装命令。
- en: Note that the final line in the Dockerfile is a CMD, the command to run when
    the container is instantiated. In our case, we use an array with one item, `entrypoint.sh`.
    The array makes it so that you can hit *Ctrl* + *C* to stop the container. The
    `entrypoint.sh` script runs Apache in the container after performing the necessary
    initialization. Also note that we enabled both the `userdir` and `php7.3` modules
    in the Dockerfile.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Dockerfile 中的最后一行是 CMD，即容器实例化时运行的命令。在我们的案例中，我们使用一个包含单个项 `entrypoint.sh`
    的数组。该数组使得你可以按 *Ctrl* + *C* 停止容器。`entrypoint.sh` 脚本在容器内执行必要的初始化后运行 Apache。还要注意，我们在
    Dockerfile 中启用了 `userdir` 和 `php7.3` 模块。
- en: Now that we have a Dockerfile, we need to be able to build the container so
    that we can then use it. This is where the first of our `.sh` scripts comes into
    play.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 Dockerfile，我们需要能够构建容器，这样我们才能使用它。这时，第一个 `.sh` 脚本就发挥作用了。
- en: Understanding build.sh
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 build.sh
- en: 'The `build.sh` script is used to build the container. You will need to build
    the container at least once so that we can edit files on the host and see the
    changes in action within the container. You will need to rebuild the container
    each time you want to try the container in production mode and have the latest
    versions of the files:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sh` 脚本用于构建容器。你需要至少构建一次容器，这样我们才能编辑主机上的文件，并在容器内看到这些变化。如果你想在生产模式下尝试容器并获得最新版本的文件，你将需要重新构建容器：'
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-t` flag says to name the container `chapter 2`. The Dockerfile is found
    in the current directory. The output of the `build.sh` script is lengthy, so it
    is omitted here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志表示将容器命名为 `chapter 2`。Dockerfile 位于当前目录。`build.sh` 脚本的输出非常长，这里省略了。'
- en: 'You can see that each step printed in the output while building the container
    corresponds to a line in the Dockerfile:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在构建容器时输出中打印的每一步都对应 Dockerfile 中的一行：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The container is incrementally built, as described by the Dockerfile. Each step
    is built in an image layer denoted with a hash value – those are the hex hash
    values printed. When you build the container again, Docker can start from the
    state of any of those layers' `/` hash values, reducing the need to constantly
    rebuild the container from scratch. Each layer is simply a diff (difference) between
    the current layer's requirements and the state of the previous layer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是按增量构建的，如 Dockerfile 所描述的那样。每个步骤都在一个图像层中构建，该层通过哈希值来表示——这些就是打印的十六进制哈希值。当你再次构建容器时，Docker
    可以从这些层的 `/` 哈希值的状态开始，从而减少了每次都从头开始构建容器的需要。每一层仅仅是当前层要求与前一层状态之间的差异。
- en: The first layer is the Debian image. The next layer is an intermediate image,
    the diff between the result of the `ENV` command in the Dockerfile and the original
    Debian image. The next layer is the diff between this previous intermediate image
    and the result of the `apt-get` installed packages. Note that we use `&&` to pack
    a few `apt-get` commands into one layer in the container. This greatly speeds
    up the build process. The layering continues as each command in the Dockerfile
    is processed by the Docker build command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个层是 Debian 镜像。接下来的层是一个中间层，它是 `ENV` 命令在 Dockerfile 中执行后的结果与原始 Debian 镜像之间的差异。接下来的层是前一个中间层和
    `apt-get` 安装的包之间的差异。注意，我们使用 `&&` 将一些 `apt-get` 命令打包成一个层，从而加快了构建过程。随着 Dockerfile
    中每个命令的处理，层级继续。
- en: Docker is smart about how it caches and works with the layers. It doesn't have
    to download the Debian image each time you build; it can start building from a
    previous intermediate stage if it knows the previous steps have not changed the
    state of the container to that point.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在缓存和处理层的方式上非常智能。它不需要每次构建时都下载 Debian 镜像；如果它知道之前的步骤没有改变容器到那一点的状态，它可以从之前的中间阶段开始构建。
- en: Whenever we need to build the container, because we've made changes to the Dockerfile,
    we use the `build.sh` script. Once we have the container built, we have a few
    ways to use it. The `debug.sh` script is probably the most common script you'll
    use during development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要构建容器时，因为我们对 Dockerfile 做了更改，我们就使用 `build.sh` 脚本。一旦容器构建完成，我们可以通过几种方式来使用它。`debug.sh`
    脚本可能是你在开发过程中最常用的脚本。
- en: Understanding debug.sh
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 debug.sh
- en: 'The `debug.sh` script runs the container image that is not in daemon mode.
    You can hit *Ctrl* + *C* to stop the program:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug.sh` 脚本运行的容器镜像不是以守护进程模式运行的。你可以按 *Ctrl* + *C* 来停止程序：'
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `docker run` command takes many optional arguments that are too numerous
    to detail here. For more complete information on all of the possible command-line
    arguments to `docker run`, refer to the `docker run` documentation on the Docker
    site: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
    We''ll only cover the ones used in our scripts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令有许多可选参数，数量太多，无法在这里一一详述。有关 `docker run` 的所有可能命令行参数的完整信息，请参阅 Docker
    网站上的 `docker run` 文档：[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)。我们只会讲解在脚本中使用的参数。'
- en: Here, we use `–rm`, which tells Docker to clean up when the container exits,
    removing the container and filesystem for the container.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `–rm`，它告诉 Docker 在容器退出时进行清理，删除容器和容器的文件系统。
- en: The `-p` flag tells Docker to map port `80` from the container (HTTP) to port
    `8086` on the host; you can access the HTTP server in the container by using port
    `8086` on the host.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 标志告诉 Docker 将容器的端口 `80`（HTTP）映射到主机的端口 `8086`；你可以通过主机的 `8086` 端口访问容器中的
    HTTP 服务器。'
- en: The `–name` argument names the running container; if you don't provide a name,
    you'll have to use `docker ps` to get the hash that identifies the container to
    stop it using `docker stop`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–name` 参数为运行中的容器命名；如果不提供名称，你需要使用 `docker ps` 获取容器的哈希值，然后使用 `docker stop` 停止容器。'
- en: The `-v` switch mounts volumes in the container. A volume can be a directory
    of a file on the host, a named volume that Docker manages for you. If you want
    to stop and restart the container and retain data that is written to the filesystem
    by the container, you must mount a volume and the container must write to this
    volume. You can mount multiple volumes, if you like. In our `debug.sh` script,
    we mount the current directory with the sources over `/home/app`, so we can modify
    the sources and the container programs see that the files are changed (because
    the file timestamps are newer) as if they were inside the container, too. For
    this demo, you can edit the `index.php` script and reload the page, and you'll
    see the change in action. If you don't mount this volume, then the container will
    access the files copied to `/home/app` by the Dockerfile and the `build.sh` script;
    this is what you want for production.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 开关将挂载容器中的卷。卷可以是主机上的目录或文件，也可以是 Docker 为你管理的命名卷。如果你想停止并重启容器，同时保留容器写入文件系统的数据，你必须挂载一个卷，并且容器必须将数据写入该卷。你可以根据需要挂载多个卷。在我们的
    `debug.sh` 脚本中，我们将当前目录与源代码挂载到 `/home/app`，这样我们可以修改源代码，并且容器中的程序会看到文件发生了变化（因为文件时间戳更新了），就像它们位于容器内部一样。对于这个演示，你可以编辑
    `index.php` 脚本并重新加载页面，看到更改效果。如果不挂载此卷，容器将访问通过 Dockerfile 和 `build.sh` 脚本复制到 `/home/app`
    中的文件；这就是你在生产环境中希望的行为。'
- en: The last argument to `docker run` is the name of the container to start – in
    our case, it's `chapter2`, the container image we created using the `build.sh`
    script.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run` 的最后一个参数是要启动的容器名称——在我们这个例子中，它是 `chapter2`，即我们使用 `build.sh` 脚本创建的容器镜像。'
- en: 'Note:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：
- en: We do not persist `/data` in the container. We can do this by adding the `-v`
    switch to map a Docker volume to `/data`, which we will do in the `persist.sh`
    script.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会在容器中持久化 `/data`。我们可以通过添加 `-v` 开关，将 Docker 卷映射到 `/data`，这将在 `persist.sh`
    脚本中完成。
- en: Running our chapter2 container with debug.sh
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 debug.sh 运行我们的 chapter2 容器
- en: 'Let''s see the container in action. We run the `build.sh` script and see that
    it succeeds. Then, we use the `debug.sh` script to launch the container in `debug/foreground`
    mode. Note that we did not do any configuration of the hostname for the container,
    so there is a warning message printed by Apache:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看容器的运行情况。我们运行 `build.sh` 脚本并看到它成功执行。接着，我们使用 `debug.sh` 脚本以 `debug/foreground`
    模式启动容器。注意，我们并未对容器的主机名进行任何配置，因此 Apache 打印了一个警告信息：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the host, we can use a browser to fetch `http://localhost:8086/~app/index.php`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，我们可以用浏览器访问 `http://localhost:8086/~app/index.php`。
- en: Remember, we mapped port `8086` to port `80` of the container, we enabled the
    `userdir` module, and, in the Dockerfile, we copied the `index.php` script to
    `/home/app/public_html` (the `userdir` module).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将端口 `8086` 映射到了容器的端口 `80`，并启用了 `userdir` 模块；在 Dockerfile 中，我们将 `index.php`
    脚本复制到了 `/home/app/public_html`（`userdir` 模块）。
- en: 'We could have configured Apache with a default host and copied our files to
    `/var/www` in the Dockerfile and build process. This would have given us a cleaner
    URL, and this is what you would want to do for an actual production site. For
    our purposes, it''s good to see the Apache modules enabled and working within
    the container:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在 Dockerfile 和构建过程中配置 Apache 的默认主机，并将文件复制到 `/var/www`，这会给我们一个更干净的 URL，并且这是你在实际生产站点中应该做的事情。对于我们的目的，看到
    Apache 模块已启用并在容器内正常工作就足够了：
- en: '![Figure 2.3 – Browser showing the output of our program](img/B11641_02_003.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 浏览器显示我们程序的输出](img/B11641_02_003.jpg)'
- en: Figure 2.3 – Browser showing the output of our program
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 浏览器显示我们程序的输出
- en: 'When we reload the page in the browser a few times, we can see that the counter
    is being properly maintained:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中重新加载页面几次后，可以看到计数器得到了正确的维护：
- en: '![Figure 2.4 – Page after we reload](img/B11641_02_004.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 页面在我们重新加载后](img/B11641_02_004.jpg)'
- en: Figure 2.4 – Page after we reload
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 页面在我们重新加载后
- en: Note that we aren't generating any HTML (yet). If you're trying this yourself,
    you can now edit the `index.php` file, change `Counterx:` to `Counter:` and reload
    the page, and you will see that the page prints `Counter:` now.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有生成任何 HTML（尚未）。如果你自己尝试，可以现在编辑 `index.php` 文件，将 `Counterx:` 改为 `Counter:`
    并重新加载页面，你将看到页面现在打印了 `Counter:`。
- en: We are now set up for PHP development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为 PHP 开发做好了准备。
- en: If we want to add, say, MySQL support, we'll have to modify the Dockerfile to
    install the PHP MySQL module, and enable it as we did with `userdir` and `php`.
    If we want to add a PHP framework, we either need to install it within the container
    via the Dockerfile, or add it to the `chapter2/` directory that is copied to the
    container's `/home/app` directory and, for development, mounted/bound in the container
    by replacing `/home/app`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加 MySQL 支持，我们需要修改 Dockerfile 来安装 PHP MySQL 模块，并像配置 `userdir` 和 `php` 一样启用它。如果我们想添加一个
    PHP 框架，我们要么需要通过 Dockerfile 在容器内安装它，要么将其添加到 `chapter2/` 目录中，然后复制到容器的 `/home/app`
    目录，或者在开发时通过替换 `/home/app` 来挂载/绑定到容器中。
- en: 'We can check to see that the container is running by using the `docker ps`
    command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker ps` 命令检查容器是否正在运行：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can exit or kill the container by pressing *Ctrl* + *C* in the window where
    we started it with `debug.sh`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在启动容器的窗口中按下 *Ctrl* + *C* 来退出或终止容器。
- en: 'When we run the container with the `run.sh` script, we don''t see any output
    from the container, not even the Apache warning:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 `run.sh` 脚本运行容器时，容器没有输出任何内容，甚至没有 Apache 的警告信息：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, we use `docker ps` to see that it is running:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `docker ps` 查看容器是否正在运行：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Loading the same URL in the browser, we see that the counter is again `1`. Reloading
    a few times, we see the counter increments as we designed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载相同的 URL，我们看到计数器又回到 `1`。重新加载几次后，我们看到计数器按设计正常递增。
- en: 'We can restart the container using `docker restart`. Note that the container
    was first instantiated 3 minutes ago, but since we restarted it, the status is
    `Up 1 second`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker restart` 来重启容器。请注意，容器首次启动是在 3 分钟前，但由于我们重启了它，状态现在是 `Up 1 second`：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since the container was only restarted, its filesystem remains intact. Reloading
    the URL in our browser, we see that the counter continues to increment. We can
    stop the container using `docker stop`, or the `stop.sh` script. The `docker ps`
    command shows no containers running. Then we start it up again:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器只是重新启动过，它的文件系统保持不变。重新加载浏览器中的 URL，我们看到计数器继续递增。我们可以使用 `docker stop` 或 `stop.sh`
    脚本停止容器。`docker ps` 命令显示没有容器在运行。然后我们再次启动它：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when we reload in our browser, the counter is reset to `1`. This is because
    we are writing to the container's filesystem. The filesystem goes away when the
    container exits.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在浏览器中重新加载时，计数器被重置为 `1`。这是因为我们正在写入容器的文件系统，而容器退出时文件系统会消失。
- en: If we want the counter to persist between container start/restart, we'd have
    to write it to a volume that is mounted on the container.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望计数器在容器启动/重启之间保持持续性，我们必须将其写入挂载到容器上的卷中。
- en: 'We write to `/data/container.txt`, so we can do the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写入 `/data/container.txt`，所以我们可以执行以下操作：
- en: Mount our own `container.txt` on the host to `/data/container.txt` on the guest.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们自己的 `container.txt` 从主机挂载到容器中的 `/data/container.txt`。
- en: Mount a directory on the host as `/data` on the guest.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主机上的目录挂载为容器中的 `/data`。
- en: Have Docker create and maintain a named or anonymous volume for us.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 Docker 为我们创建并维护一个命名或匿名卷。
- en: Since the advent of named volumes, they are the better choice. A named volume
    is created and maintained using the `-v` switch to `docker run` with just the
    name of the directory on the guest; for example, `-v name:/data`. We have a script,
    `persist.sh`, designed to make using the named volume easy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 自从命名卷的出现以来，它们已成为更好的选择。命名卷是使用 `docker run` 的 `-v` 开关与仅包含容器中目录名称一起创建和维护的。例如，`-v
    name:/data`。我们有一个脚本 `persist.sh`，它旨在简化命名卷的使用。
- en: persist.sh
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: persist.sh
- en: 'The `persist.sh` script does the same thing as the `debug.sh` script, except
    that it adds the `-v name:/data` switch to the `docker run` command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`persist.sh` 脚本做的事情与 `debug.sh` 脚本相同，不同之处在于它向 `docker run` 命令添加了 `-v name:/data`
    开关：'
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we run it and point our browser at `http://localhost:8086/~app/index.php`,
    we see that the counter works, even if we stop and restart the container.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行并在浏览器中输入 `http://localhost:8086/~app/index.php` 时，我们可以看到计数器正常工作，即使我们停止并重启容器。
- en: run.sh
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: run.sh
- en: 'The `run.sh` script runs the container in daemon mode – you won''t be able
    to see the application''s output without using the `docker log` command. It also
    does not mount the host directory as a volume in the container. This simulates
    the production environment:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`run.sh` 脚本以守护进程模式运行容器——你无法看到应用程序的输出，除非使用 `docker log` 命令。它也不会将主机目录作为卷挂载到容器中。这模拟了生产环境：'
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are using the `docker run` command, once again, but with slightly different
    arguments:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`docker run`命令，但参数略有不同：
- en: The `–detach` flag to Docker Run is what causes the container to run in the
    background.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–detach` 标志用于 Docker Run，它会使容器在后台运行。'
- en: The named volume is used, so the data is persisted between starting and stopping
    the container.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名卷，因此数据在容器启动和停止之间得以持久化。
- en: The development working directory is mounted on `/home/app` within the container.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发工作目录被挂载到容器内的 `/home/app`。
- en: The `–restart` switch always tells Docker to restart the container when the
    system is rebooted. This is handy since you won't have to figure out some way
    to automatically start your container(s) when the operating system starts.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–restart` 开关始终告诉 Docker 在系统重启时重新启动容器。这非常方便，因为你不需要在操作系统启动时手动启动容器。'
- en: The container is only able to run using the files copied to it using the Dockerfile
    and `build.sh`. If you edit files on your host, you will not see the changes within
    the running container, as with `persist.sh`. You will need to run the `build.sh`
    script every time you edit files and want them changed within the container for
    the purposes of `run.sh`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 容器只能使用通过 Dockerfile 和 `build.sh` 脚本复制到其中的文件运行。如果你在主机上编辑文件，你在运行的容器中将看不到这些更改，就像使用
    `persist.sh` 时一样。每次编辑文件并希望在容器中应用这些更改时，你都需要运行 `build.sh` 脚本，以便在 `run.sh` 中使用。
- en: We'll need a way to stop our running container. This is where `stop.sh` comes
    in.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来停止正在运行的容器。这时 `stop.sh` 就派上用场了。
- en: stop.sh
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stop.sh
- en: 'The `stop.sh` script will stop your `chapter2` container. This is particularly
    useful when you''ve used the `run.sh` script to launch your container in the background:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop.sh` 脚本将停止你的 `chapter2` 容器。这在你使用 `run.sh` 脚本将容器启动到后台时特别有用：'
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s see `run.sh` and `stop.sh` in action:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `run.sh` 和 `stop.sh` 的实际效果：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `shell.sh` script runs the container and starts the Bash shell so that
    you can use command-line programs to diagnose issues with the container as it''s
    built:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell.sh` 脚本运行容器并启动 Bash shell，这样你可以使用命令行程序来诊断容器在构建时出现的问题：'
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code snippet shows the `shell.sh` script in action:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 `shell.sh` 脚本的作用：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that `/data` was created and has world write permissions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `/data` 被创建并且具有全局写权限。
- en: These few `sh` scripts are enough to get you developing and using your own containers.
    As you work with Docker, you'll likely come up with additional scripts of your
    own! However,  we will see in [*Chapter 4*](B11641_04_Final_NM_ePub.xhtml#_idTextAnchor059),
    *Composing Systems Using Containers*, a way to work with Docker without the `sh`
    scripts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这几段 `sh` 脚本足以让你开始开发并使用你自己的容器。随着你使用 Docker，你可能会编写更多自己的脚本！然而，我们将在 [*第 4 章*](B11641_04_Final_NM_ePub.xhtml#_idTextAnchor059)《*使用容器构建系统*》中看到一种无需
    `sh` 脚本即可与 Docker 配合使用的方法。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about how VirtualBox can be used to create
    virtual machines on your workstation and how you can use it to run Windows (or
    Linux or other operating systems) in a virtual machine. We also learned enough
    about Docker to use it to build our first application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何使用 VirtualBox 在工作站上创建虚拟机，以及如何利用它在虚拟机中运行 Windows（或 Linux 或其他操作系统）。我们还学习了足够的
    Docker 知识，能够用它构建我们的第一个应用程序。
- en: This chapter was written using Windows 10 running within a VirtualBox virtual
    machine, running on an Arch Linux host. Microsoft Word was used within Windows,
    while the Docker commands and scripts were run and edited on the Arch Linux host.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是在 Windows 10 操作系统下编写的，运行在 VirtualBox 虚拟机中，并且该虚拟机运行在 Arch Linux 主机上。Windows
    中使用了 Microsoft Word，而 Docker 命令和脚本则在 Arch Linux 主机上运行和编辑。
- en: We demonstrated how we can build a LAMP-style application, without MySQL, and
    containerize it. We can mount our source code directory from the host to the container
    so that we can edit files and see the changes immediately in the container. We
    learned how to persist data, meaning that stopping and starting the container
    would retain important files and state.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了如何构建一个类似 LAMP 的应用程序，虽然没有 MySQL，并且如何将其容器化。我们可以将源代码目录从主机挂载到容器中，这样我们可以编辑文件并在容器中即时查看更改。我们还学习了如何持久化数据，这意味着停止和启动容器时，重要文件和状态会被保留。
- en: In the next chapter, we'll explore Docker Hub and build a more complex application
    that requires more than one container.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索 Docker Hub，并构建一个需要多个容器的更复杂的应用程序。
- en: Further reading
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: This URL is for the official Docker documentation:[https://docs.docker.com](https://docs.docker.com)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是官方的 Docker 文档：[https://docs.docker.com](https://docs.docker.com)
- en: This URL is for the Dockerfile reference:[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是关于 Dockerfile 参考资料的：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
- en: This URL is for the documentation for the Docker `ps` command:[https://docs.docker.com/engine/reference/commandline/ps/](https://docs.docker.com/engine/reference/commandline/ps/)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是关于 Docker `ps` 命令文档的：[https://docs.docker.com/engine/reference/commandline/ps/](https://docs.docker.com/engine/reference/commandline/ps/)
- en: This URL is for the documentation pertaining to volumes and storage in Docker:[https://docs.docker.com/storage](https://docs.docker.com/storage)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是关于 Docker 中卷和存储的文档：[https://docs.docker.com/storage](https://docs.docker.com/storage)
- en: This URL is for the documentation pertaining to the Docker `run` command:[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是关于 Docker `run` 命令文档的：[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
- en: This URL is for the documentation pertaining to the Docker `restart` command:[https://docs.docker.com/engine/reference/commandline/restart/](https://docs.docker.com/engine/reference/commandline/restart/)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是关于 Docker `restart` 命令文档的：[https://docs.docker.com/engine/reference/commandline/restart/](https://docs.docker.com/engine/reference/commandline/restart/)
- en: This URL is for the documentation pertaining to the Docker `stop` command:[https://docs.docker.com/engine/reference/commandline/stop/](https://docs.docker.com/engine/reference/commandline/stop/)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 URL 是关于 Docker `stop` 命令文档的：[https://docs.docker.com/engine/reference/commandline/stop/](https://docs.docker.com/engine/reference/commandline/stop/)
