- en: '*Chapter 2*: Introducing Docker'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 2 章*：介绍 Docker'
- en: In this chapter, we will discuss how the modern **continuous delivery** (**CD**)
    process looks by introducing Docker, the technology that changed the **information
    technology** (**IT**) industry and the way servers are used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论现代 **持续交付**（**CD**）过程是如何通过引入 Docker 来实现的，Docker 是改变了 **信息技术**（**IT**）行业及服务器使用方式的技术。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: What is Docker?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Docker？
- en: Installing Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Running Docker hello-world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Docker hello-world
- en: Docker components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 组件
- en: Docker applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 应用
- en: Building Docker images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Docker container states
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器状态
- en: Docker networking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 网络
- en: Using Docker volumes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 卷
- en: Using names in Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 中使用名称
- en: Docker cleanup
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 清理
- en: Docker commands overview
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 命令概述
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you''ll need to meet the following hardware/software
    requirements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容，你需要满足以下硬件/软件要求：
- en: At least 4 **gigabytes** (**GB**) of **random-access memory** (**RAM**)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要 4 **千兆字节**（**GB**）的 **随机存取存储器**（**RAM**）
- en: macOS 10.15+, Windows 10/11 Pro 64-bit, Ubuntu 20.04+, or other Linux operating
    systems
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 10.15+、Windows 10/11 Pro 64 位、Ubuntu 20.04+ 或其他 Linux 操作系统
- en: All the examples and solutions to the exercises can be found at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter02).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例和练习的解决方案可以在 [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter02)
    找到。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3LJv1n6](https://bit.ly/3LJv1n6).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的《代码实战》视频可以在 [https://bit.ly/3LJv1n6](https://bit.ly/3LJv1n6) 上观看。
- en: What is Docker?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Docker？
- en: Docker is an open source project designed to help with application deployment
    using software containers. This approach means running applications together with
    the complete environment (files, code libraries, tools, and so on). Therefore,
    Docker—similar to virtualization—allows an application to be packaged into an
    image that can be run everywhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个开源项目，旨在通过使用软件容器来帮助应用程序部署。这种方法意味着将应用程序与完整的环境（文件、代码库、工具等）一起运行。因此，Docker
    —— 类似于虚拟化 —— 允许将应用程序打包成一个可以在任何地方运行的镜像。
- en: Containerization versus virtualization
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化与虚拟化
- en: Without Docker, isolation and other benefits can be achieved with the use of hardware virtualization,
    often called **virtual machines** (**VMs**). The most popular solutions are VirtualBox,
    VMware, and parallels. A VM emulates a computer architecture and provides the
    functionality of a physical computer. We can achieve complete isolation of applications
    if each of them is delivered and run as a separate VM image.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 Docker，隔离和其他好处可以通过使用硬件虚拟化来实现，这通常被称为 **虚拟机**（**VMs**）。最受欢迎的解决方案有 VirtualBox、VMware
    和 Parallels。虚拟机仿真计算机架构，并提供物理计算机的功能。如果将每个应用程序作为独立的虚拟机镜像交付并运行，则可以实现完全的应用隔离。
- en: 'The following diagram presents the concept of virtualization:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了虚拟化的概念：
- en: '![Figure 2.1 – Virtualization'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 虚拟化'
- en: '](img/B18223_02_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_01.png)'
- en: Figure 2.1 – Virtualization
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 虚拟化
- en: 'Each application is launched as a separate image with all dependencies and
    a guest operating system. Images are run by the **hypervisor**, which emulates
    the physical computer architecture. This method of deployment is widely supported
    by many tools (such as Vagrant) and dedicated to development and testing environments.
    Virtualization, however, has three significant drawbacks, as outlined here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都作为一个包含所有依赖项和客操作系统的独立镜像启动。这些镜像由 **虚拟机管理程序**（**hypervisor**）运行，虚拟机管理程序仿真物理计算机架构。这种部署方法得到了许多工具（如
    Vagrant）的广泛支持，并且专为开发和测试环境而设计。然而，虚拟化有三个显著的缺点，如下所述：
- en: '**Low performance**: The VM emulates the whole computer architecture to run
    the guest operating system, so there is a significant overhead associated with
    executing each operation.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低性能**：虚拟机仿真整个计算机架构以运行客操作系统，因此执行每个操作时都有显著的开销。'
- en: '**High resource consumption**: Emulation requires a lot of resources and has
    to be done separately for each application. This is why, on a standard desktop
    machine, only a few applications can be run simultaneously.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高资源消耗**：仿真需要大量资源，并且必须为每个应用单独执行。这就是为什么在标准桌面机器上，只有少数应用可以同时运行。'
- en: '**Large image size**: Each application is delivered with a full operating system,
    so deployment on a server implies sending and storing a large amount of data.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大图像大小**：每个应用程序都配备了完整的操作系统，因此在服务器上部署意味着需要传输和存储大量数据。'
- en: 'The concept of containerization presents a different solution, as we can see
    here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的概念提供了一种不同的解决方案，正如我们在这里看到的：
- en: '![Figure 2.2 – Containerization'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 容器化'
- en: '](img/B18223_02_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_02.jpg)'
- en: Figure 2.2 – Containerization
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 容器化
- en: Each application is delivered together with its dependencies, but without the
    operating system. Applications interface directly with the host operating system,
    so there is no additional layer of the guest operating system. This results in
    better performance and no wasted resources. Moreover, shipped Docker images are
    significantly smaller.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序与其依赖项一起交付，但不包括操作系统。应用程序直接与主机操作系统接口，因此没有额外的来宾操作系统层。这带来了更好的性能，并且没有浪费资源。此外，发布的
    Docker 镜像要小得多。
- en: Notice that, in the case of containerization, isolation happens at the level
    of the host operating system's processes. This doesn't mean, however, that the
    containers share their dependencies. Each of them has its own libraries in the
    right version, and if any of them is updated, it has no impact on the others.
    To achieve this, Docker Engine creates a set of Linux namespaces and control groups
    for the container. This is why Docker security is based on Linux kernel process
    isolation. This solution, although mature enough, could be considered slightly
    less secure than the complete operating system-based isolation offered by VMs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在容器化的情况下，隔离发生在主机操作系统的进程级别。然而，这并不意味着容器共享它们的依赖项。每个容器都有自己的库，并且版本正确，如果其中任何一个库被更新，其他容器不会受到影响。为了实现这一点，Docker
    引擎为容器创建了一组 Linux 名称空间和控制组。这就是 Docker 安全性基于 Linux 内核进程隔离的原因。尽管这种解决方案已经足够成熟，但可能会被认为比虚拟机提供的基于操作系统的完全隔离稍微不那么安全。
- en: The need for Docker
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 的需求
- en: Docker containerization solves a number of problems seen in traditional software
    delivery. Let's take a closer look.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器化解决了传统软件交付中出现的许多问题。让我们仔细看看。
- en: Environment
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境
- en: Installing and running software is complex. You need to make decisions about
    the operating system, resources, libraries, services, permissions, other software,
    and everything your application depends on. Then, you need to know how to install
    it. What's more, there may be some conflicting dependencies. *What do you do then?* *What
    if your software needs an upgrade of a library, but the other resources do not?* In
    some companies, such issues are solved by having *classes of applications*, and
    each class is served by a dedicated server, such as a server for web services
    with Java 7, and another one for batch jobs with Java 8\. This solution, however,
    is not balanced in terms of resources and requires an army of IT operations teams
    to take care of all the production and test servers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和运行软件是复杂的。你需要关于操作系统、资源、库、服务、权限、其他软件以及应用程序所依赖的一切做出决策。然后，你需要知道如何安装它。更重要的是，可能会存在一些冲突的依赖关系。*那该怎么办呢？*
    *如果你的软件需要升级某个库，而其他资源不需要怎么办？* 在一些公司中，这类问题通过设立*应用程序类别*来解决，每个类别由专用服务器提供支持，例如，使用 Java
    7 的 Web 服务服务器和使用 Java 8 的批处理作业服务器。然而，这种解决方案在资源分配方面并不平衡，并且需要大量 IT 运维团队来管理所有生产和测试服务器。
- en: Another problem with the environment's complexity is that it often requires
    a specialist to run an application. A less technical person may have a hard time
    setting up MySQL, **Open Database Connectivity** (**ODBC**), or any other slightly
    more sophisticated tool. This is particularly true for applications not delivered
    as an operating system-specific binary but that require source code compilation
    or any other environment-specific configuration.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 环境复杂性的另一个问题是，它通常需要专业人员来运行应用程序。一个技术能力较弱的人可能很难设置 MySQL、**开放数据库连接**（**ODBC**）或任何其他稍微复杂的工具。对于那些不是以特定操作系统二进制文件形式交付的应用程序，尤其如此，这些应用程序需要源代码编译或其他特定于环境的配置。
- en: Isolation
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离
- en: Keep the workspace tidy. One application can change the behavior of another
    one. Imagine what could happen. Applications share one filesystem, so if application
    *A* writes something to the wrong directory, application *B* reads the incorrect
    data. They share resources, so if there is a memory leak in application *A*, it
    can freeze not only itself but also application *B*. They share network interfaces,
    so if applications *A* and *B* both use port `8080`, one of them will crash. Isolation
    concerns the security aspects, too. Running a buggy application or malicious software
    can cause damage to other applications. This is why it is a much safer approach
    to keep each application inside a separate sandbox, which limits the scope of
    possible damage to the application itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保持工作区整洁。一个应用程序可以改变另一个应用程序的行为。想象一下可能发生什么。应用程序共享一个文件系统，如果应用程序*A*将数据写入错误的目录，应用程序*B*就会读取到错误的数据。它们共享资源，因此，如果应用程序*A*有内存泄漏，它不仅会冻结自己，还可能冻结应用程序*B*。它们共享网络接口，因此如果应用程序*A*和*B*都使用端口`8080`，其中一个就会崩溃。隔离还涉及到安全性方面。如果运行一个有缺陷的应用程序或恶意软件，可能会对其他应用程序造成损害。这就是为什么将每个应用程序保存在一个独立的沙箱中是一个更安全的做法，它限制了可能对应用程序本身造成的损害范围。
- en: Organizing applications
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组织应用程序
- en: Servers often end up looking messy, with a ton of running applications nobody
    knows anything about. *How will you check which applications are running on the
    server and which dependencies each of them is using?* They could depend on libraries,
    other applications, or tools. Without the exhaustive documentation, all we can
    do is look at the running processes and start guessing. Docker keeps things organized
    by having each application as a separate container that can be listed, searched,
    and monitored.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通常最终看起来很杂乱，有大量正在运行的应用程序，没人知道它们的任何情况。*你将如何检查哪些应用程序正在服务器上运行，并且它们各自依赖了哪些库？*
    它们可能依赖于库、其他应用程序或工具。如果没有详尽的文档，我们能做的就是查看正在运行的进程并开始猜测。Docker通过将每个应用程序作为独立的容器来保持事物的有序，这样就可以列出、搜索和监控它们。
- en: Portability
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植性
- en: '*Write once, run anywhere*, said the slogan while advertising the earliest
    versions of Java. Indeed, Java addresses the portability issue quite well. However,
    I can still think of a few cases where it fails; for example, the incompatible
    native dependencies or the older version of the Java Runtime. Moreover, not all
    software is written in Java.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次编写，处处运行*，这是早期Java版本广告中的口号。的确，Java很好地解决了可移植性问题。然而，我仍然能想到一些失败的情况；例如，不兼容的本地依赖项或旧版的Java运行时环境。此外，并非所有软件都是用Java编写的。'
- en: Docker moves the concept of portability one level higher; if the Docker version
    is compatible, the shipped software works correctly, regardless of the programming
    language, operating system, or environment configuration. Docker, then, can be
    expressed by the following slogan: *Ship the entire environment instead of just
    code*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将可移植性的概念提升了一个层次；如果Docker版本兼容，那么无论编程语言、操作系统还是环境配置如何，运送的软件都能正常工作。因此，Docker可以用以下口号来表达：*运送整个环境，而不仅仅是代码*。
- en: Kittens and cattle
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小猫与牲畜
- en: The difference between traditional software deployment and Docker-based deployment
    is often expressed with an analogy of kittens and cattle. Everybody likes kittens.
    Kittens are unique. Each has its own name and needs special treatment. Kittens
    are treated with emotion. We cry when they die. On the contrary, cattle exist
    only to satisfy our needs. Even the form *cattle* is singular since it's just
    a pack of animals treated together—no naming, no uniqueness. Surely, they are
    unique (the same as each server is unique), but this is irrelevant. This is why
    the most straightforward explanation of the idea behind Docker is *treat your
    servers like cattle, not pets*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 传统软件部署和基于Docker的部署之间的区别，常用小猫与牲畜的类比来表达。每个人都喜欢小猫。小猫是独一无二的。每只小猫都有自己的名字并需要特别照顾。小猫是带有感情的。当它们死去时，我们会哭泣。相反，牲畜的存在仅仅是为了满足我们的需求。甚至“牲畜”这个词是单数的，因为它只是一群被一起对待的动物——没有名字，没有独特性。当然，它们是独一无二的（就像每台服务器都是独特的），但这并不重要。这就是为什么Docker背后的思想最直观的解释是：*把你的服务器当作牲畜对待，而不是宠物*。
- en: Alternative containerization technologies
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代的容器化技术
- en: Docker is not the only containerization system available on the market. Actually,
    the first versions of Docker were based on the open source **Linux Containers** (**LXC**)
    system, which is an alternative platform for containers. Other known solutions
    are **Windows Server containers**, **OpenVZ**, and **Linux Server**. Docker, however,
    overtook all other systems because of its simplicity, good marketing, and startup
    approach. It works under most operating systems, allows you to do something useful
    in less than 15 minutes, and has a lot of simple-to-use features, good tutorials,
    a great community, and probably the best logo in the IT industry!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 并不是市场上唯一的容器化系统。实际上，Docker 的早期版本基于开源的**Linux Containers**（**LXC**）系统，这是一个替代性的容器平台。其他知名的解决方案有**Windows
    Server containers**、**OpenVZ** 和**Linux Server**。然而，Docker 由于其简便性、良好的市场营销和创业方式，超越了所有其他系统。它能在大多数操作系统上运行，允许你在不到
    15 分钟的时间内做一些有用的事情，并且拥有很多易用的功能、优秀的教程、一个强大的社区，可能还有 IT 行业中最棒的 logo！
- en: 'We already understand the idea of Docker, so let''s move on to the practical
    part and start from the beginning: Docker installation.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了 Docker 的基本概念，接下来让我们进入实际部分，从头开始：Docker 安装。
- en: Installing Docker
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Docker's installation process is quick and simple. Currently, it's supported
    on most Linux operating systems, and a wide range of them have dedicated binaries
    provided. macOS and Windows are also well supported with native applications.
    However, it's important to understand that Docker is internally based on the Linux
    kernel and its specifics, and this is why, in the case of macOS and Windows, it
    uses VMs (HyperKit for macOS and Hyper-V for Windows) to run the Docker Engine
    environment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的安装过程既快速又简单。目前，它支持大多数 Linux 操作系统，并且为多个操作系统提供了专用的二进制文件。macOS 和 Windows
    也通过原生应用得到很好的支持。然而，重要的是要理解 Docker 内部是基于 Linux 内核及其特性，这也是为什么在 macOS 和 Windows 上它使用虚拟机（macOS
    使用 HyperKit，Windows 使用 Hyper-V）来运行 Docker Engine 环境。
- en: Prerequisites for Docker
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 的先决条件
- en: 'The Docker Community Edition requirements are specific for each operating system,
    as outlined here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Community Edition 的系统要求因操作系统不同而有所不同，具体如下：
- en: '**macOS**:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**：'
- en: macOS 10.15 or newer
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 10.15 或更新版本
- en: At least 4 GB of RAM
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 4 GB 内存
- en: No VirtualBox prior to version 4.3.30 installed
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装前没有 VirtualBox 版本 4.3.30 或更高版本
- en: '**Windows**:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**：'
- en: 64-bit Windows 10/11
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64 位 Windows 10/11
- en: The Hyper-V package enabled
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已启用 Hyper-V 包
- en: At least 4 GB of RAM
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 4 GB 内存
- en: '**Linux**:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**：'
- en: 64-bit architecture
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64 位架构
- en: Linux kernel 3.10 or later
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 内核 3.10 或更高版本
- en: If your machine does not meet these requirements, the solution is to use **VirtualBox** with
    the Ubuntu operating system installed. This workaround, even though it sounds
    complicated, is not necessarily the worst method, especially considering that
    the Docker Engine environment is virtualized anyway in the case of macOS and Windows.
    Furthermore, Ubuntu is one of the best-supported systems for using Docker.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器不满足这些要求，解决方案是使用**VirtualBox**并安装 Ubuntu 操作系统。这个变通方法虽然听起来很复杂，但不一定是最糟糕的选择，特别是考虑到在
    macOS 和 Windows 上 Docker Engine 环境本身就是虚拟化的。而且，Ubuntu 是使用 Docker 的最佳支持系统之一。
- en: Information
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: All examples in this book have been tested on the Ubuntu 20.04 operating system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都已在 Ubuntu 20.04 操作系统上进行过测试。
- en: Installing on a local machine
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地机器上安装
- en: 'The Docker installation process is straightforward and is described in detail
    on its official page: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 安装过程非常简单，详细步骤可以参考官方页面：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。
- en: Docker Desktop
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: 'The simplest way to use Docker in your local environment is to install Docker
    Desktop. This way, in just a few minutes, you have a complete Docker development
    environment all set up and running. For Windows and macOS users, Docker Desktop
    provides a native application that hides all the setup difficulties behind the
    scenes. Technically, Docker Engine is installed inside a VM because Docker requires
    the Linux kernel to operate. Nevertheless, as a user, you don''t even need to
    think about this—you install Docker Desktop and you are ready to start using the
    `docker` command. You can see an overview of Docker Desktop in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地环境中使用 Docker 的最简单方法是安装 Docker Desktop。通过这种方式，只需几分钟，你就可以拥有一个完整的 Docker 开发环境并运行起来。对于
    Windows 和 macOS 用户，Docker Desktop 提供了一个本地应用程序，隐藏了所有设置的复杂性。技术上，Docker 引擎安装在一个虚拟机内，因为
    Docker 需要 Linux 内核才能运行。然而，作为用户，你根本不需要考虑这一点——只需安装 Docker Desktop，就可以开始使用 `docker`
    命令。你可以在下图中看到 Docker Desktop 的概览：
- en: '![Figure 2.3 – Docker Desktop'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – Docker Desktop'
- en: '](img/B18223_02_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_03.jpg)'
- en: Figure 2.3 – Docker Desktop
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Docker Desktop
- en: 'Apart from Docker Engine, Docker Desktop provides a number of additional features,
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Docker 引擎外，Docker Desktop 还提供了以下一些附加功能：
- en: A **user interface** (**UI**) to display images, containers, and volumes
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **用户界面** (**UI**) 用于显示镜像、容器和卷
- en: A local Kubernetes cluster
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 Kubernetes 集群
- en: Automatic Docker updates
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动 Docker 更新
- en: Volume mounting with the local filesystem integration
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与本地文件系统集成的卷挂载
- en: (Windows) Support for Windows containers
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Windows）支持 Windows 容器
- en: (Windows) Integration with **Windows Subsystem for Linux** (**WSL**)/**WSL version
    2** (**WSL2**)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Windows）与 **Windows 子系统 Linux** (**WSL**)/**WSL 版本 2** (**WSL2**) 的集成
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Please visit [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    for Docker Desktop installation guides.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请访问 [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    获取 Docker Desktop 安装指南。
- en: Docker for Ubuntu
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker for Ubuntu
- en: Visit [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/) to
    find a guide on how to install Docker on an Ubuntu machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)
    查找如何在 Ubuntu 机器上安装 Docker 的指南。
- en: 'In the case of Ubuntu 20.04, I''ve executed the following commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 20.04 上，我执行了以下命令：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After all operations are completed, Docker should be installed. However, at
    the moment, the only user allowed to use Docker commands is `root`. This means
    that the `sudo` keyword must precede every Docker command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有操作后，Docker 应该已经安装。但此时，只有 `root` 用户被允许使用 Docker 命令。这意味着每个 Docker 命令前都必须加上
    `sudo` 关键字。
- en: 'We can enable other users to use Docker by adding them to the `docker` group,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其他用户添加到 `docker` 组来允许他们使用 Docker，方法如下：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After a successful logout, everything is set up. With the latest command, however,
    we need to take some precautions not to give the Docker permissions to an unwanted
    user and thereby create a vulnerability in the Docker Engine environment. This
    is particularly important in the case of installation on the server machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 成功注销后，一切设置完成。然而，对于最新的命令，我们需要采取一些预防措施，以避免将 Docker 权限赋予不必要的用户，从而在 Docker 引擎环境中创建漏洞。在服务器机器上安装时尤其需要注意这一点。
- en: Docker for other Linux distributions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker for 其他 Linux 发行版
- en: Docker supports most Linux distributions and architectures. For details, please
    check the official page at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 支持大多数 Linux 发行版和架构。详情请查看官方页面 [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)。
- en: Testing the Docker installation
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 Docker 安装
- en: 'No matter which installation you''ve chosen (macOS, Windows, Ubuntu, Linux,
    or something else), Docker should be set up and ready. The best way to test it
    is to run the `docker info` command. The output message should be similar to the
    following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择了哪种安装方式（macOS、Windows、Ubuntu、Linux 或其他），Docker 应该已经设置好并准备就绪。测试的最佳方法是运行
    `docker info` 命令。输出信息应该类似于以下内容：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing on a server
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器上安装
- en: In order to use Docker over the network, it's possible to either take advantage
    of cloud platform providers or manually install Docker on a dedicated server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过网络使用 Docker，可以利用云平台提供商，或者手动在专用服务器上安装 Docker。
- en: In the first case, the Docker configuration differs from one platform to another,
    but it is always very well described in dedicated tutorials. Most cloud platforms
    enable Docker hosts to be created through user-friendly web interfaces or describe
    exact commands to execute on their servers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，Docker 配置在不同平台间有所不同，但通常在专门的教程中都有详细描述。大多数云平台都允许通过用户友好的网页界面创建 Docker 主机，或提供执行命令的具体描述。
- en: The second case (installing Docker manually) does require a few words, however.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况（手动安装 Docker）确实需要简要说明一下。
- en: Dedicated server
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专用服务器
- en: Installing Docker manually on a server does not differ much from the local installation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 手动在服务器上安装 Docker 与本地安装并没有太大区别。
- en: 'Two additional steps are required, which include setting the Docker daemon
    to listen on the network socket and setting security certificates. These steps
    are described in more detail here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要两个额外的步骤，其中包括让 Docker 守护进程监听网络套接字和设置安全证书。更多细节请参见这里：
- en: 'By default, due to security reasons, Docker runs through a non-networked Unix
    socket that only allows local communication. It''s necessary to add listening
    on the chosen network interface socket so that external clients can connect. In
    the case of Ubuntu, the Docker daemon is configured by `systemd`, so, in order
    to change the configuration of how it''s started, we need to modify one line in
    the `/lib/systemd/system/docker.service` file, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，出于安全考虑，Docker 通过一个非网络化的 Unix 套接字运行，只允许本地通信。需要在所选的网络接口套接字上开启监听，以便外部客户端能够连接。在
    Ubuntu 系统中，Docker 守护进程是由 `systemd` 配置的，因此，要修改其启动配置，我们需要修改`/lib/systemd/system/docker.service`
    文件中的一行，如下所示：
- en: '[PRE3]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By changing this line, we enabled access to the Docker daemon through the specified
    `systemd` configuration can be found at [https://docs.docker.com/config/daemon/systemd/](https://docs.docker.com/config/daemon/systemd/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改这一行，我们启用了通过指定的 `systemd` 配置访问 Docker 守护进程，相关的配置可以在 [https://docs.docker.com/config/daemon/systemd/](https://docs.docker.com/config/daemon/systemd/)
    中找到。
- en: This step of server configuration concerns Docker security certificates. This
    enables only clients authenticated by a certificate to access the server. A comprehensive
    description of the Docker certificate configuration can be found at [https://docs.docker.com/engine/security/protect-access/](https://docs.docker.com/engine/security/protect-access/).
    This step isn't strictly required; however, unless your Docker daemon server is
    inside a firewalled network, it is essential.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步是关于服务器配置的 Docker 安全证书。这只允许通过证书认证的客户端访问服务器。Docker 证书配置的详细描述可以在 [https://docs.docker.com/engine/security/protect-access/](https://docs.docker.com/engine/security/protect-access/)
    中找到。这一步不是强制性的；然而，除非你的 Docker 守护进程服务器位于有防火墙的网络中，否则它是必需的。
- en: Information
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: If your Docker daemon is run inside a corporate network, you have to configure
    the **HyperText Transfer Protocol** (**HTTP**) proxy. A detailed description can
    be found at [https://docs.docker.com/config/daemon/systemd/](https://docs.docker.com/config/daemon/systemd/).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的 Docker 守护进程运行在公司网络中，你需要配置 **超文本传输协议** (**HTTP**) 代理。详细描述可以在 [https://docs.docker.com/config/daemon/systemd/](https://docs.docker.com/config/daemon/systemd/)
    中找到。
- en: The Docker environment is set up and ready, so we can start the first example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 环境已设置完毕并准备好，因此我们可以开始第一个示例。
- en: Running Docker hello-world
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Docker hello-world
- en: 'Enter the following command into your console:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Congratulations! You''ve just run your first Docker container. I hope you can
    already see how simple Docker is. Let''s examine what happened under the hood,
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚运行了第一个 Docker 容器。我希望你已经能看出 Docker 是多么简单。让我们来看看在幕后发生了什么，如下所示：
- en: You ran the Docker client with the `run` command.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用 `run` 命令运行了 Docker 客户端。
- en: The Docker client contacted the Docker daemon and asked to create a container
    from the image called `hello-world`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 客户端联系 Docker 守护进程，并请求从名为 `hello-world` 的镜像创建一个容器。
- en: The Docker daemon checked whether it contained the `hello-world` image locally
    and, since it didn't, requested the `hello-world` image from the remote Docker
    Hub registry.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程检查本地是否存在`hello-world`镜像，如果没有，则从远程 Docker Hub 仓库请求 `hello-world` 镜像。
- en: The Docker Hub registry contained the `hello-world` image, so it was pulled into
    the Docker daemon.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Hub 仓库包含了`hello-world`镜像，因此它被拉取到 Docker 守护进程中。
- en: The Docker daemon created a new container from the `hello-world` image that
    started the executable producing the output.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程从 `hello-world` 镜像创建了一个新容器，启动了可执行文件并产生了输出。
- en: The Docker daemon streamed this output to the Docker client.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护进程将此输出流式传输到Docker客户端。
- en: The Docker client sent it to your Terminal.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker客户端将其发送到你的终端。
- en: 'The projected flow is represented in the following diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 预计的流程如以下图所示：
- en: '![Figure 2.4 – Steps of the docker run command execution'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – docker run命令执行步骤'
- en: '](img/B18223_02_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_04.jpg)'
- en: Figure 2.4 – Steps of the docker run command execution
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – docker run命令执行步骤
- en: Let's now look at each Docker component that was illustrated in this section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下本节中展示的每个Docker组件。
- en: Docker components
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker组件
- en: Docker is actually an ecosystem that includes a number of components. Let's
    describe all of them, starting with a closer look at the Docker client-server
    architecture.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker实际上是一个包含多个组件的生态系统。让我们从仔细了解Docker客户端-服务器架构开始，描述所有这些组件。
- en: Docker client and server
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker客户端和服务器
- en: 'Let''s look at the following diagram, which presents the Docker Engine architecture:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表，它展示了Docker引擎的架构：
- en: '![Figure 2.5 – Docker client-server architecture'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – Docker客户端-服务器架构'
- en: '](img/B18223_02_05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_05.jpg)'
- en: Figure 2.5 – Docker client-server architecture
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – Docker客户端-服务器架构
- en: 'Docker Engine consists of the following three components:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎由以下三个组件组成：
- en: A **Docker daemon** (server) running in the background
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台运行的**Docker守护进程**（服务器）
- en: A **Docker Client** running as a command tool
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为命令工具运行的**Docker客户端**
- en: A **Docker REpresentational State Transfer (REST) application programming interface
    (API)**
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker表述性状态转移（REST）应用程序编程接口（API）**'
- en: Installing Docker means installing all the components so that the Docker daemon
    runs on our computer all the time as a service. In the case of the `hello-world` example,
    we used the Docker client to interact with the Docker daemon; however, we could
    do exactly the same thing using the REST API. Also, in the case of the `hello-world` example,
    we connected to the local Docker daemon. However, we could use the same client
    to interact with the Docker daemon running on a remote machine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker意味着安装所有组件，以便Docker守护进程始终作为服务在我们的计算机上运行。在`hello-world`示例中，我们使用Docker客户端与Docker守护进程交互；然而，我们也可以通过REST
    API做完全相同的事情。此外，在`hello-world`示例中，我们连接到了本地Docker守护进程，但我们也可以使用相同的客户端与运行在远程机器上的Docker守护进程进行交互。
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To run the Docker container on a remote machine, you can use the `-H` option: `docker
    -H <server_ip>:2375 run hello-world`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程机器上运行Docker容器，可以使用`-H`选项：`docker -H <server_ip>:2375 run hello-world`。
- en: Docker images and containers
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker镜像和容器
- en: An **image** is a stateless building block in the Docker world. You can think
    of an image as a collection of all the files necessary to run your application,
    together with the recipe on how to run it. An image is stateless, so you can send
    it over the network, store it in the registry, name it, version it, and save it
    as a file. Images are layered, which means that you can build an image on top
    of another image.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**镜像**是Docker世界中的一个无状态构建块。你可以把镜像看作是运行你的应用程序所需的所有文件的集合，以及如何运行它的配方。镜像是无状态的，因此你可以通过网络传输它，存储到注册表中，给它命名，进行版本管理，并将其保存为文件。镜像是分层的，这意味着你可以在另一个镜像的基础上构建镜像。'
- en: A container is a running instance of an image. We can create many containers
    from the same image if we want to have many instances of the same application.
    Since containers are stateful, this means we can interact with them and make changes
    to their states.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的一个运行实例。如果我们想要有多个相同应用程序的实例，我们可以从同一个镜像创建多个容器。由于容器是有状态的，这意味着我们可以与它们交互并对其状态进行更改。
- en: 'Let''s look at the following example of a **container** and **image** layered
    structure:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个**容器**和**镜像**分层结构的示例：
- en: '![Figure 2.6 – Layered structure of Docker images'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – Docker镜像的分层结构'
- en: '](img/B18223_02_06.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_06.jpg)'
- en: Figure 2.6 – Layered structure of Docker images
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – Docker镜像的分层结构
- en: At the bottom, there is always the base image. In most cases, this represents
    an operating system, and we build our images on top of the existing base images.
    It's technically possible to create your own base images; however, this is rarely
    needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在最底部，总是有一个基础镜像。在大多数情况下，这代表了一个操作系统，我们在现有的基础镜像上构建我们的镜像。从技术上讲，可以创建你自己的基础镜像；然而，这种需求很少。
- en: In our example, the `ubuntu` base image provides all the capabilities of the
    Ubuntu operating system. The `add git` image adds the Git toolkit. Then, there
    is an image that adds the `add JDK` image. Such a container is able, for example,
    to download a Java project from the GitHub repository and compile it to a **Java
    ARchive** (**JAR**) file. As a result, we can use this container to compile and
    run Java projects without installing any tools on our operating system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`ubuntu` 基础镜像提供了 Ubuntu 操作系统的所有功能。`add git` 镜像添加了 Git 工具集。接着，有一个镜像添加了
    `add JDK` 镜像。这样的容器可以，例如，从 GitHub 仓库下载一个 Java 项目并将其编译为 **Java ARchive**（**JAR**）文件。结果是，我们可以使用这个容器来编译和运行
    Java 项目，而无需在操作系统上安装任何工具。
- en: 'It is important to note that layering is a very smart mechanism to save bandwidth
    and storage. Imagine that we have the following application that is also based
    on Ubuntu:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，分层是一种非常聪明的机制，用于节省带宽和存储空间。假设我们有一个以下基于 Ubuntu 的应用程序：
- en: '![Figure 2.7 – Reusing layers of Docker images'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – 重用 Docker 镜像的层'
- en: '](img/B18223_02_07.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_07.jpg)'
- en: Figure 2.7 – Reusing layers of Docker images
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 重用 Docker 镜像的层
- en: This time, we files will use the Python interpreter. While installing the `add
    python` image, the Docker daemon will note that the `ubuntu` image is already
    installed, and what it needs to do is only to add the Python layer, which is very
    small. So, the `ubuntu` image is a dependency that is reused. The same applies
    if we would like to deploy our image in the network. When we deploy the Git and
    JDK application, we need to send the whole `ubuntu` image. However, while subsequently
    deploying the Python application, we need to send just the small `add python` layer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将使用 Python 解释器。当安装 `add python` 镜像时，Docker 守护进程会注意到 `ubuntu` 镜像已经安装，所需要做的只是添加一个非常小的
    Python 层。因此，`ubuntu` 镜像是一个被重用的依赖项。如果我们想在网络中部署我们的镜像，同样适用。当我们部署 Git 和 JDK 应用程序时，需要传输整个
    `ubuntu` 镜像。然而，在随后部署 Python 应用程序时，我们只需要传输小的 `add python` 层。
- en: Now that we understand what the Docker ecosystem consists of, let's describe
    how we can run applications packaged as Docker images.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Docker 生态系统的组成，让我们描述一下如何运行打包为 Docker 镜像的应用程序。
- en: Docker applications
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 应用程序
- en: 'A lot of applications are provided in the form of Docker images that can be
    downloaded from the internet. If we know the image name, it would be enough to
    run it in the same way we did with the hello-world example. *How can we find the
    desired application image on Docker Hub?* Let''s take **MongoDB** as an example.
    These are the steps we need to follow:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 很多应用程序以 Docker 镜像的形式提供，可以从互联网上下载。如果我们知道镜像名称，那么就像运行 hello-world 示例一样，只需要运行它就可以了。*我们如何在
    Docker Hub 上找到所需的应用程序镜像？* 以 **MongoDB** 为例。以下是我们需要遵循的步骤：
- en: If we want to find it on Docker Hub, we have two options, a[s follows:](https://hub.docker.com/search/)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在 Docker Hub 上找到它，我们有两种选择，具体如下：](https://hub.docker.com/search/)
- en: '[Search on the Docke](https://hub.docker.com/search/)r Hub `docker search` command.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 Docker Hub 上搜索](https://hub.docker.com/search/) `docker search` 命令。'
- en: 'In the second case, we can perform the following operation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们可以执行以下操作：
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are many interesting options. *How do we choose the best image?* Usually,
    the most appealing one is the one without any prefix, since it means that it''s
    an official Docker Hub image and should therefore be stable and maintained. The
    images with prefixes are unofficial, usually maintained as open source projects.
    In our case, the best choice seems to be `mongo`, so in order to run the MongoDB
    server, we can run the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有许多有趣的选项。*我们如何选择最佳镜像？* 通常，最吸引人的是没有任何前缀的镜像，因为这意味着它是官方的 Docker Hub 镜像，因此应该是稳定和维护的。带有前缀的镜像是非官方的，通常作为开源项目维护。在我们的例子中，最佳选择似乎是
    `mongo`，因此为了运行 MongoDB 服务器，我们可以执行以下命令：
- en: '[PRE6]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's all we need to do. MongoDB has started. Running applications as Docker
    containers is that simple because we don't need to think of any dependencies;
    they are all delivered together with the image. Docker can be treated as a useful
    tool to run applications; however, the real power lies in building your own Docker
    images that wrap the programs together with the environment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的。MongoDB 已经启动。作为 Docker 容器运行应用程序就是这么简单，因为我们不需要考虑任何依赖项；它们都与镜像一起提供。Docker
    可以作为一个运行应用程序的有用工具，但真正的强大之处在于构建你自己的 Docker 镜像，将程序与环境一起打包。
- en: Information
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: On the Docker Hub service, you can find a lot of applications; they store millions
    of different images.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Hub 服务上，你可以找到很多应用程序，它们存储了成千上万种不同的镜像。
- en: Building Docker images
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'In this section, we will see how to build Docker images using two different
    methods: the `docker` `commit` command and a Dockerfile automated build.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将展示如何使用两种不同的方式构建 Docker 镜像：`docker`的`commit`命令和 Dockerfile 自动化构建。
- en: docker commit
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker commit
- en: 'Let''s start with an example and prepare an image with the Git and JDK toolkits.
    We will use Ubuntu 20.04 as a base image. There is no need to create it; most
    base images are available in the Docker Hub registry. Proceed as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个示例开始，准备一个包含 Git 和 JDK 工具包的镜像。我们将使用 Ubuntu 20.04 作为基础镜像。无需自己创建，绝大多数基础镜像都可以在
    Docker Hub 仓库中找到。操作步骤如下：
- en: 'Run a container from `ubuntu:20.04` and connect it to its command line, like
    this:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ubuntu:20.04`运行一个容器，并将其连接到命令行，如下所示：
- en: '[PRE7]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've pulled the `ubuntu:20.04` image, run it as a container, and then called
    the `/bin/bash` command in an interactive way (`-i` flag). You should see the
    Terminal of the container. Since containers are stateful and writable, we can
    do anything we want in its Terminal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拉取了`ubuntu:20.04`镜像，将其作为容器运行，并以交互方式（`-i`标志）调用了`/bin/bash`命令。你应该能够看到容器的终端。由于容器是有状态且可写的，我们可以在它的终端中做任何我们想做的事情。
- en: 'Install the Git toolkit, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Git 工具包，如下所示：
- en: '[PRE8]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check whether the Git toolkit is installed by running the following command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查是否安装了 Git 工具包：
- en: '[PRE9]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Exit the container, like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出容器，如下所示：
- en: '[PRE10]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check what has changed in the container by comparing its unique container `ubuntu` image,
    as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过比较容器的唯一`ubuntu`镜像，检查容器中发生了什么变化，如下所示：
- en: '[PRE11]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command should print a list of all files changed in the container.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应打印容器中所有更改的文件列表。
- en: 'Commit the container to the image, like this:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器提交为镜像，如下所示：
- en: '[PRE12]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve just created our first Docker image. Let''s list all the images of our
    Docker host to see whether the image is present, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了第一个 Docker 镜像。现在让我们列出所有 Docker 主机上的镜像，查看该镜像是否存在，如下所示：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As expected, we see `hello-world`, `mongo` (installed before), `ubuntu` (the
    base image pulled from Docker Hub), and the freshly built `ubuntu_with_git` image.
    By the way, we can observe that the size of each image corresponds to what we've
    installed on the image.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们看到了`hello-world`、`mongo`（之前安装过）、`ubuntu`（从 Docker Hub 拉取的基础镜像）以及新建的`ubuntu_with_git`镜像。顺便提一下，我们可以观察到每个镜像的大小与我们在镜像上安装的内容相对应。
- en: 'Now, if we create a container from the image, it will have the Git tool installed,
    as illustrated in the following code snippet:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从该镜像创建一个容器，它将安装 Git 工具，如下所示的代码片段所示：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Dockerfile
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Creating each Docker image manually with the `commit` command could be laborious,
    especially in the case of build automation and the CD process. Luckily, there
    is a built-in language to specify all the instructions that should be executed
    to build a Docker image.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`commit`命令手动创建每个 Docker 镜像可能会很繁琐，尤其是在构建自动化和持续交付过程中。幸运的是，Docker 提供了一种内建语言，可以指定构建
    Docker 镜像时需要执行的所有指令。
- en: 'Let''s start with an example similar to the one with Git. This time, we will
    prepare an `ubuntu_with_python` image, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个与 Git 类似的示例开始。这次，我们将准备一个`ubuntu_with_python`镜像，如下所示：
- en: 'Create a new directory and a file called `Dockerfile` with the following content:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新目录，并在其中创建一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE15]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the following command to create an `ubuntu_with_python` image:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建`ubuntu_with_python`镜像：
- en: '[PRE16]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check that the image was created by running the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，检查镜像是否已创建：
- en: '[PRE17]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now create a container from the image and check that the Python interpreter
    exists in exactly the same way we did after executing the `docker commit` command.
    Note that the `ubuntu` image is listed only once even though it's the base image
    for both `ubuntu_with_git` and `ubuntu_with_python`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从镜像中创建一个容器，并检查 Python 解释器是否存在，方法与执行`docker commit`命令后一样。请注意，尽管`ubuntu`镜像是`ubuntu_with_git`和`ubuntu_with_python`的基础镜像，但它只列出了一次。
- en: 'In this example, we used the first two Dockerfile instructions, as outlined
    here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们使用了前两个 Dockerfile 指令，如下所示：
- en: '`FROM` defines an image on top of which the new image will be built'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`定义了在其上构建新镜像的基础镜像。'
- en: '`RUN` specifies the commands to run inside the container.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`指定了在容器内执行的命令。'
- en: The other widely used instructions are detailed as follows:.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 其他广泛使用的指令详细说明如下：
- en: '`COPY/ADD` copies a file or a directory into the filesystem of the image.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY/ADD` 将文件或目录复制到镜像的文件系统中。'
- en: '`ENTRYPOINT` defines which application should be run in the executable container.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 定义了在可执行容器中应该运行的应用程序。'
- en: A complete guide of all Dockerfile instructions can be found on the official
    Docker page at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Dockerfile 指令的完整指南可以在官方 Docker 页面找到，网址是 [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: Complete Docker application
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的 Docker 应用程序
- en: We already have all the information necessary to build a fully working application
    as a Docker image. As an example, we will prepare, step by step, a simple Python
    `hello-world` program. The steps are always the same, no matter which environment
    or programming language we use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有构建一个完全可工作的应用程序作为 Docker 镜像所需的所有信息。作为示例，我们将一步一步地准备一个简单的 Python `hello-world`
    程序。无论我们使用哪种环境或编程语言，步骤始终相同。
- en: Writing the application
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写应用程序
- en: 'Create a new directory and, inside this directory, create a `hello.py` file
    with the following content:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新目录，并在此目录中创建一个名为 `hello.py` 的文件，内容如下：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Close the file. This is the source code of our application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件。这就是我们应用程序的源代码。
- en: Preparing the environment
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备环境
- en: 'Our environment will be expressed in the Dockerfile. We need instructions to
    define the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境将在 Dockerfile 中表示。我们需要指令来定义以下内容：
- en: Which base image should be used
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应使用哪个基础镜像
- en: How to install the Python interpreter
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装 Python 解释器
- en: How to include `hello.py` in the image
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 `hello.py` 包含到镜像中
- en: How to start the application
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启动应用程序
- en: 'In the same directory, create the Dockerfile, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中创建 Dockerfile，方法如下：
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Building the image
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Now, we can build the image exactly the same way we did before, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以与之前完全相同的方式构建镜像，如下所示：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running the application
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'We run the application by running the container, like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行容器来启动应用程序，方法如下：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should see a friendly **Hello World from Python!** message. The most interesting
    thing in this example is that we are able to run the application written in Python
    without having the Python interpreter installed in our host system. This is possible
    because the application packed as an image has the environment already included.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个友好的 **Hello World from Python!** 消息。这个示例中最有趣的地方是，我们能够运行用 Python 编写的应用程序，而无需在主机系统中安装
    Python 解释器。这是因为打包成镜像的应用程序已经包含了所需的环境。
- en: Tip
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An image with the Python interpreter already exists in the Docker Hub service,
    so in a real-life scenario, it would be enough to use it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 服务中已经存在带有 Python 解释器的镜像，因此在实际场景中，使用该镜像就足够了。
- en: Environment variables
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: We've run our first homemade Docker application. However, *what if the execution
    of the application depends on some conditions?*
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经运行了第一个自制的 Docker 应用程序。然而，*如果应用程序的执行依赖于某些条件怎么办？*
- en: 'For example, in the case of the production server, we would like to print `Hello` to
    the logs, not to the console, or we may want to have different dependent services
    during the testing phase and the production phase. One solution would be to prepare
    a separate Dockerfile for each case; however, there is a better way: environment
    variables.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在生产服务器的情况下，我们希望将 `Hello` 打印到日志中，而不是打印到控制台，或者我们可能希望在测试阶段和生产阶段有不同的依赖服务。一种解决方案是为每种情况准备一个单独的
    Dockerfile；但是，还有一种更好的方法：环境变量。
- en: 'Let''s change our `hello-world` application to print `Hello World from <name_passed_as_environment_variable>
    !`. In order to do this, we need to proceed with the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `hello-world` 应用程序修改为打印 `Hello World from <name_passed_as_environment_variable>
    !`。为了实现这一点，我们需要按照以下步骤操作：
- en: 'Change the `hello.py` Python script to use the environment variable, as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改 `hello.py` Python 脚本以使用环境变量，如下所示：
- en: '[PRE22]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build the image, like this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像，方法如下：
- en: '[PRE23]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the container passing the environment variable, like this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行容器并传递环境变量，方法如下：
- en: '[PRE24]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, we can define an environment variable value in Dockerfile, such
    as the following:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以在 Dockerfile 中定义一个环境变量值，如下所示：
- en: '[PRE25]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the container without specifying the `-e` option, as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以不指定 `-e` 选项的方式运行容器，如下所示：
- en: '[PRE26]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Environment variables are especially useful when we need to have different versions
    of the Docker container depending on its purpose; for example, to have separate
    profiles for production and testing servers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量在我们需要根据 Docker 容器的用途拥有不同版本时特别有用；例如，为生产和测试服务器提供单独的配置文件。
- en: Information
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: If an environment variable is defined both in the Dockerfile and as a flag,
    then the flag takes precedence.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境变量同时在 Dockerfile 和作为标志中定义，则标志优先。
- en: Docker container states
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 容器状态
- en: Every application we've run so far was supposed to do some work and stop—for
    example, we've printed `Hello from Docker!` and exited. There are, however, applications
    that should run continuously, such as services.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们运行的每个应用程序都应该执行某些工作然后停止——例如，我们打印了`Hello from Docker!`并退出。然而，有些应用程序应该持续运行，比如服务。
- en: 'To run a container in the background, we can use the `-d` (`--detach`) option.
    Let''s try it with the `ubuntu` image, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在后台运行容器，我们可以使用`-d`（`--detach`）选项。我们可以尝试使用`ubuntu`镜像，如下所示：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command started the Ubuntu container but did not attach the console to
    it. We can see that it''s running by using the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动了 Ubuntu 容器，但并没有将控制台附加到它。我们可以使用以下命令查看它是否正在运行：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command prints all containers that are in a **running** state. *What about
    our old, already exited containers?* We can find them by printing all containers,
    like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打印所有处于**运行中**状态的容器。*那么我们的旧容器，它们已经退出了呢？* 我们可以通过打印所有容器来找到它们，如下所示：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that all the old containers are in an **exited** state. There are two more
    states we haven't observed yet: **paused** and **restarting**.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有旧的容器都处于**退出**状态。我们还有两个状态尚未观察到：**暂停**和**重启**。
- en: 'All of the states and the transitions between them are presented in the following
    diagram:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所有状态及其之间的转换展示在以下图表中：
- en: '![Figure 2.8 – Docker container states'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – Docker 容器状态'
- en: '](img/B18223_02_08.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_08.jpg)'
- en: Figure 2.8 – Docker container states
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – Docker 容器状态
- en: Pausing Docker containers is very rare, and technically, it's done by freezing
    the processes using the `SIGSTOP` signal. Restarting is a temporary state when
    the container is run with the `--restart` option to define a restarting strategy
    (the Docker daemon is able to automatically restart the container in case of failure).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停 Docker 容器是非常罕见的，技术上它是通过使用`SIGSTOP`信号冻结进程来实现的。重启是当容器使用`--restart`选项运行时的一种临时状态，用于定义重启策略（Docker
    守护进程能够在失败时自动重启容器）。
- en: The preceding diagram also shows the Docker commands used to change the Docker
    container state from one state to another.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上图还显示了用于将 Docker 容器状态从一个状态转换到另一个状态的 Docker 命令。
- en: 'For example, we can stop running the Ubuntu container, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以停止运行 Ubuntu 容器，如下所示：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Information
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We've always used the `docker run` command to create and start a container.
    However, it's possible to just create a container without starting it (with `docker
    create`).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用`docker run`命令来创建并启动容器。然而，也可以仅创建一个容器而不启动它（使用`docker create`）。
- en: Having grasped the details of Docker states, let's describe the networking basics
    within the Docker world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了 Docker 状态的细节后，让我们描述一下 Docker 世界中的网络基础知识。
- en: Docker networking
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络
- en: Most applications these days do not run in isolation; they need to communicate
    with other systems over the network. If we want to run a website, web service,
    database, or cache server inside a Docker container, we need to first understand
    how to run a service and expose its port to other applications.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的大多数应用程序都不是孤立运行的；它们需要通过网络与其他系统进行通信。如果我们想在 Docker 容器内运行网站、Web 服务、数据库或缓存服务器，我们需要首先了解如何运行服务并将其端口暴露给其他应用程序。
- en: Running services
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行服务
- en: 'Let''s start with a simple example and run a Tomcat server directly from Docker
    Hub, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的示例开始，并直接从 Docker Hub 运行一个 Tomcat 服务器，如下所示：
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tomcat is a web application server whose UI can be accessed by port `8080`.
    Therefore, if we installed Tomcat on our machine, we could browse it at `http://localhost:8080`.
    In our case, however, Tomcat is running inside the Docker container.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat 是一个 Web 应用服务器，其用户界面可以通过端口`8080`访问。因此，如果我们在机器上安装了 Tomcat，我们可以在`http://localhost:8080`访问它。然而，在我们的案例中，Tomcat
    是在 Docker 容器内运行的。
- en: 'We started it the same way we did with the first `Hello World` example. We
    can see that it''s running, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与第一个`Hello World`示例相同的方式启动它。我们可以看到它正在运行，如下所示：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since it''s run as a daemon (with the `-d` option), we don''t see the logs
    in the console right away. We can, however, access it by executing the following
    code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是以守护进程方式运行（使用 `-d` 选项），所以我们不会立即在控制台看到日志。然而，我们可以通过执行以下代码来访问它：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If there are no errors, we should see a lot of logs, which indicates that Tomcat
    has been started and is accessible through port `8080`. We can try going to `http://localhost:8080`,
    but we won't be able to connect. This is because Tomcat has been started inside
    the container and we're trying to reach it from the outside. In other words, we
    can reach it only if we connect with the command to the console in the container
    and check it there. *How do we make running Tomcat accessible from outside?*
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，我们应该看到很多日志，这表明 Tomcat 已经启动并且可以通过端口 `8080` 访问。我们可以尝试访问 `http://localhost:8080`，但无法连接。这是因为
    Tomcat 已经在容器内启动，我们正在尝试从外部连接。换句话说，只有在通过命令连接到容器的控制台并在那里检查时，我们才能访问它。*我们如何使运行中的 Tomcat
    从外部可访问呢？*
- en: 'We need to start the container, specifying the port mapping with the `-p` (`--publish`)
    flag, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启动容器，并指定端口映射，使用 `-p`（`--publish`）标志，如下所示：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, let''s first stop the running container and start a new one, like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们首先停止运行中的容器并启动一个新容器，如下所示：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After waiting a few seconds, Tomcat should have started, and we should be able
    to open its page—`http://localhost:8080`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟后，Tomcat 应该已经启动，我们应该能够打开其页面——`http://localhost:8080`。
- en: 'The following screenshot illustrates how Docker container ports are published:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了如何发布 Docker 容器端口：
- en: '![Figure 2.9 – Publishing Docker container ports'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 发布 Docker 容器端口'
- en: '](img/B18223_02_09.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_09.jpg)'
- en: Figure 2.9 – Publishing Docker container ports
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 发布 Docker 容器端口
- en: Such a simple port mapping command is sufficient in most common Docker use cases.
    We are able to deploy (micro) services as Docker containers and expose their ports
    to facilitate communication. However, let's dive a little deeper into what happened
    under the hood.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个简单的端口映射命令在大多数常见的 Docker 用例中就足够了。我们能够将（微型）服务作为 Docker 容器部署并暴露它们的端口以促进通信。然而，让我们深入探讨一下背后发生了什么。
- en: Information
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Docker also allows us to publish to the specific host network interface with `-p
    <ip>:<host_port>:<container_port>`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 还允许我们使用 `-p <ip>:<host_port>:<container_port>` 来发布到特定的主机网络接口。
- en: Container networks
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络
- en: We have connected to the application that is running inside the container. In
    fact, the connection is two-way because, if you remember from our previous examples,
    we executed the `apt-get install` commands from inside and the packages were downloaded
    from the internet. *How is this possible?*
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经连接到运行在容器内的应用程序。实际上，连接是双向的，因为如果你记得我们之前的示例，我们从内部执行了 `apt-get install` 命令，包是从互联网下载的。*这是怎么可能的？*
- en: 'If you check the network interfaces on your machine, you can see that one of
    the interfaces is called `docker0`, as illustrated here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查你机器上的网络接口，你会看到其中一个接口叫做 `docker0`，如下所示：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `docker0` interface is created by the Docker daemon in order to connect
    with the Docker container. Now, we can see which interfaces are created inside
    the Tomcat Docker container created with the `docker inspect` command, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker0` 接口是 Docker 守护进程创建的，用于与 Docker 容器连接。现在，我们可以看到通过 `docker inspect` 命令查看到的
    Tomcat Docker 容器内创建了哪些接口，如下所示：'
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This prints all the information about the container configuration in **JavaScript
    Object Notation** (**JSON**) format. Among other things, we can find the part
    related to the network settings, as illustrated in the following code snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这会以 **JavaScript 对象表示法** (**JSON**) 格式打印出关于容器配置的所有信息。其中，我们可以找到与网络设置相关的部分，如下所示的代码片段：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Information
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In order to filter the `docker inspect` response, we can use the `--format` option—for
    example, `docker inspect --format '{{ .NetworkSettings.IPAddress }}' <container_id>`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤 `docker inspect` 的响应，我们可以使用 `--format` 选项——例如，`docker inspect --format
    '{{ .NetworkSettings.IPAddress }}' <container_id>`。
- en: We can observe that the Docker container has an IP address of `172.17.0.2` and
    it communicates with the Docker host with an IP address of `172.17.0.1`. This
    means that in our previous example, we could access the Tomcat server even without
    the port forwarding, using `http://172.17.0.2:8080`. Nevertheless, in most cases,
    we run the Docker container on a server machine and want to expose it outside,
    so we need to use the `-p` option.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到 Docker 容器的 IP 地址是 `172.17.0.2`，它与 Docker 主机的 IP 地址 `172.17.0.1` 进行通信。这意味着，在我们之前的示例中，即使没有端口转发，使用
    `http://172.17.0.2:8080` 也可以访问 Tomcat 服务器。然而，在大多数情况下，我们是在服务器机器上运行 Docker 容器，并希望将其暴露到外部，因此我们需要使用
    `-p` 选项。
- en: 'Note that, by default, the containers don''t open any routes from external
    systems. We can change this default behavior by playing with the `--network` flag
    and setting it as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，容器不会从外部系统打开任何路由。我们可以通过调整 `--network` 标志来更改这种默认行为，并按如下方式设置：
- en: '`bridge` (default): Network through the default Docker bridge'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge`（默认）：通过默认的 Docker 桥接网络'
- en: '`none`: No network'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：无网络'
- en: '`container`: Network joined with the other (specified) container'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container`：与其他（指定的）容器共同加入的网络'
- en: '`host`: Host''s network stack'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：主机的网络堆栈'
- en: '`NETWORK`: User-created network (using the `docker network create` command)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NETWORK`：用户创建的网络（使用 `docker network create` 命令）'
- en: 'The different networks can be listed and managed by the `docker network` command,
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `docker network` 命令列出并管理不同的网络，具体如下：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we specify `none` as the network, we will not be able to connect to the container,
    and vice versa; the container has no network access to the external world. The `host` option
    makes the `bridge`) because it lets us define explicitly which ports should be
    published and is both secure and accessible.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定 `none` 作为网络，就无法连接到容器，反之亦然；容器也没有网络访问外部世界的能力。`host` 选项使得 `bridge`）成为可用，因为它让我们明确指定应该发布哪些端口，并且既安全又可访问。
- en: Exposing container ports
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露容器端口
- en: 'We mentioned a few times that the container exposes the port. In fact, if we
    dig deeper into the Tomcat image on GitHub ([https://github.com/docker-library/tomcat](https://github.com/docker-library/tomcat)),
    we can see the following line in the Dockerfile:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾多次提到容器暴露端口。事实上，如果我们深入 GitHub 上的 Tomcat 镜像（[https://github.com/docker-library/tomcat](https://github.com/docker-library/tomcat)），可以看到
    Dockerfile 中有以下一行：
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This Dockerfile instruction stipulates that port `8080` should be exposed from
    the container. However, as we have already seen, this doesn't mean that the port
    is automatically published. The `EXPOSE` instruction only informs users which
    ports they should publish.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该 Dockerfile 指令规定应该从容器中暴露端口 `8080`。然而，正如我们已经看到的，这并不意味着端口会自动发布。`EXPOSE` 指令只是通知用户应该发布哪些端口。
- en: Automatic port assignment
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动端口分配
- en: 'Let''s try to run the second Tomcat container without stopping the first one,
    as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在不停止第一个 Tomcat 容器的情况下运行第二个 Tomcat 容器，如下所示：
- en: '[PRE41]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This error may be common. In such cases, we have to either take care of the
    uniqueness of the ports on our own or let Docker assign the ports automatically
    using one of the following versions of the `publish` command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误可能是常见的。在这种情况下，我们必须自己处理端口的唯一性，或者让 Docker 自动分配端口，可以使用以下任一版本的 `publish` 命令：
- en: '`-p <container_port>`: Publishes the container port to the unused host port'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p <container_port>`：将容器端口发布到未使用的主机端口'
- en: '`-p` (`--publish-all`): Publishes all ports exposed by the container to the
    unused host ports, as follows:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`（`--publish-all`）：将容器暴露的所有端口发布到未使用的主机端口，具体如下：'
- en: '[PRE42]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see that the second Tomcat instance has been published to port `32772`,
    so it can be browsed at `http://localhost:32772`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到第二个 Tomcat 实例已发布到端口 `32772`，因此可以通过 `http://localhost:32772` 访问。
- en: After understanding Docker network basics, let's see how to provide a persistence
    layer for Docker containers using Docker volumes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了 Docker 网络基础知识后，让我们看看如何使用 Docker 卷为 Docker 容器提供持久层。
- en: Using Docker volumes
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 卷
- en: Imagine that you would like to run a database as a container. You can start
    such a container and enter data. *Where is it stored?* *What happens when you
    stop the container or remove it?* You can start a new one, but the database will
    be empty again. Unless it's your testing environment, you'd expect to have your
    data persisted permanently.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将一个数据库作为容器运行。你可以启动这样的容器并输入数据。*数据存储在哪里？* *当你停止或移除容器时会发生什么？* 你可以重新启动一个新的容器，但数据库会再次为空。除非这是你的测试环境，否则你期望数据能够永久保存。
- en: 'A Docker volume is the Docker host''s directory mounted inside the container.
    It allows the container to write to the host''s filesystem as if it were writing
    to its own. The mechanism is presented in the following diagram:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷是 Docker 主机的目录，挂载在容器内。它允许容器像写入自己的文件系统一样写入主机的文件系统。这个机制在下图中展示：
- en: '![Figure 2.10 – Using a Docker volume'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – 使用 Docker 卷'
- en: '](img/B18223_02_10.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_02_10.jpg)'
- en: Figure 2.10 – Using a Docker volume
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 使用 Docker 卷
- en: 'Docker volumes enable the persistence and sharing of a container''s data. Volumes
    also clearly separate the processing from the data. Let''s start with the following
    example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷使得容器的数据得以持久化和共享。卷也清晰地将处理过程与数据分开。让我们从以下示例开始：
- en: 'Specify a volume with the `-v <host_path>:<container_path>` option and then
    connect to the container, as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v <host_path>:<container_path>`选项指定卷，然后连接到容器，方法如下：
- en: '[PRE43]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create an empty file in `host_directory` in the container, like this:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中的`host_directory`创建一个空文件，方法如下：
- en: '[PRE44]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Check whether the file was created in the Docker host''s filesystem by running
    the following command:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查文件是否在 Docker 主机的文件系统中创建：
- en: '[PRE45]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can see that the filesystem was shared and the data was therefore persisted
    permanently. Stop the container and run a new one to see if our file will still
    be there, as follows:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到文件系统已共享，因此数据得以永久保存。停止容器并运行一个新的容器，看看我们的文件是否还在，方法如下：
- en: '[PRE46]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of specifying a volume with the `-v` flag, it''s possible to specify
    it as an instruction in the Dockerfile, as in the following example:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用`-v`标志来指定卷，而是可以在 Dockerfile 中将其作为指令指定，如以下示例所示：
- en: '[PRE47]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, if we run the Docker container without the `-v` flag, the container's
    `/host_directory` path will be mapped into the host's default directory for volumes,
    `/var/lib/docker/vfs/`. This is a good solution if you deliver an application
    as an image and you know it requires permanent storage for some reason (for example,
    storing application logs).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们不使用`-v`标志运行 Docker 容器，容器的`/host_directory`路径将映射到主机的卷的默认目录`/var/lib/docker/vfs/`。如果你交付一个应用程序作为镜像并且知道它由于某种原因需要持久存储（例如存储应用程序日志），这是一个很好的解决方案。
- en: Information
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: If a volume is defined both in a Dockerfile and as a flag, the `flag` command
    takes precedence.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个卷在 Dockerfile 和作为标志都被定义，则`flag`命令具有优先权。
- en: Docker volumes can be much more complicated, especially in the case of databases.
    More complex use cases of Docker volumes are, however, outside the scope of this
    book.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷可以更复杂，特别是在数据库的情况下。然而，Docker 卷的更复杂用法超出了本书的范围。
- en: Information
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: A very common approach to data management with Docker is to introduce an additional
    layer, in the form of data volume containers. A data volume container is a Docker
    container whose only purpose is to declare a volume. Then, other containers can
    use it (with the `--volumes-from <container>` option) instead of declaring the
    volume directly. Read more at [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中进行数据管理的一个非常常见的方法是引入一个额外的层，即数据卷容器。数据卷容器是一个 Docker 容器，其唯一目的是声明一个卷。然后，其他容器可以使用它（通过`--volumes-from
    <container>`选项），而不需要直接声明卷。了解更多请访问[https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)。
- en: After understanding Docker volumes, let's see how we can use names to make working
    with Docker images/containers more convenient.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Docker 卷后，让我们看看如何使用名称使得操作 Docker 镜像/容器更加方便。
- en: Using names in Docker
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker 中使用名称
- en: So far, when we've operated on containers, we've always used autogenerated names.
    This approach has some advantages, such as the names being unique (no naming conflicts)
    and automatic (no need to do anything). In many cases, however, it's better to
    give a user-friendly name to a container or an image.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们操作容器时，我们总是使用自动生成的名称。这种方法有一些优点，例如名称唯一（没有命名冲突）和自动化（无需做任何事）。然而，在许多情况下，给容器或镜像起一个用户友好的名称更好。
- en: Naming containers
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名容器
- en: 'There are two good reasons to name a container: convenience and the possibility
    of automation. Let''s look at why, as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个好理由来给容器命名：方便性和自动化的可能性。让我们看一下原因，具体如下：
- en: '**Convenience**: It''s simpler to make any operations on a container when addressing
    it by name than by checking the hashes or the autogenerated name.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方便性**：用名称来操作容器比检查哈希或自动生成的名称更简单。'
- en: '**Automation**: Sometimes, we would like to depend on the specific naming of
    a container.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：有时，我们希望依赖于容器的特定命名。'
- en: For example, we would like to have containers that depend on each other and
    to have one linked to another. Therefore, we need to know their names.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望有相互依赖的容器，并将一个容器链接到另一个容器。因此，我们需要知道它们的名称。
- en: 'To name a container, we use the `--name` parameter, as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给容器命名，我们使用`--name`参数，如下所示：
- en: '[PRE48]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can check (with `docker ps`) that the container has a meaningful name. Also,
    as a result, any operation can be performed using the container''s name, as in
    the following example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `docker ps` 来检查容器是否具有有意义的名称。这样，任何操作都可以使用容器的名称进行，例如以下示例：
- en: '[PRE49]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Please note that when a container is named, it does not lose its identity. We
    can still address the container by its autogenerated hash ID, just as we did before.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当容器被命名时，它不会失去其身份。我们仍然可以通过自动生成的哈希 ID 来引用容器，就像我们之前做的那样。
- en: Information
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: A container always has both an ID and a name. It can be addressed by either
    of them, and both are unique.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器总是有一个 ID 和一个名称。我们可以通过任意一个来引用它们，而且它们都是唯一的。
- en: Tagging images
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像打标签
- en: 'Images can be tagged. We already did this when creating our own images—for
    example, in the case of building the `hello_world_python` image, as illustrated
    here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以打标签。我们在创建自己的镜像时已经做过这件事——例如，在构建 `hello_world_python` 镜像时，如下所示：
- en: '[PRE50]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `-t` flag describes the tag of the image. If we don't use it, the image
    will be built without any tags and, as a result, we would have to address it by
    its ID (hash) in order to run the container.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志描述镜像的标签。如果我们不使用它，镜像将没有标签，因此我们必须通过其 ID（哈希值）来引用它，才能运行容器。'
- en: 'The image can have multiple tags, and they should follow this naming convention:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以有多个标签，它们应该遵循以下命名约定：
- en: '[PRE51]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A tag consists of the following parts:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标签由以下部分组成：
- en: '`registry_address`: IP and port of the registry or the alias name'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_address`：注册表的 IP 和端口或别名'
- en: '`image_name`: Name of the image that is built—for example, `ubuntu`'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_name`：构建的镜像名称，例如 `ubuntu`'
- en: '`version`: A version of the image in any form—for example, `20.04`, `20170310`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：镜像的版本，可以是任何形式的版本，例如 `20.04`、`20170310`'
- en: We will cover Docker registries in [*Chapter 5*](B18223_05_ePub.xhtml#_idTextAnchor133), *Automated
    Acceptance Testing*. If an image is kept on the official Docker Hub registry,
    we can skip the registry address. This is why we've run the `tomcat` image without
    any prefix. The last version is always tagged as the latest and it can also be
    skipped, so we've run the `tomcat` image without any suffix.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第五章*](B18223_05_ePub.xhtml#_idTextAnchor133) 中讨论 Docker 注册表，*自动化验收测试*。如果镜像保存在官方的
    Docker Hub 注册表中，我们可以跳过注册表地址。这就是为什么我们运行 `tomcat` 镜像时没有任何前缀的原因。最后的版本总是被标记为 `latest`，并且可以省略，因此我们运行
    `tomcat` 镜像时没有任何后缀。
- en: Information
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'Images usually have multiple tags; for example, all these three tags are the
    same image: `ubuntu:18.04`, `ubuntu:bionic-20190122`, and `ubuntu:bionic`.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像通常有多个标签；例如，以下三个标签表示同一个镜像：`ubuntu:18.04`、`ubuntu:bionic-20190122` 和 `ubuntu:bionic`。
- en: Last but not least, we need to learn how to clean up after playing with Docker.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要学习如何在玩 Docker 之后进行清理。
- en: Docker cleanup
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 清理
- en: Throughout this chapter, we have created a number of containers and images.
    This is, however, only a small part of what you will see in real-life scenarios.
    Even when containers are not running, they need to be stored on the Docker host.
    This can quickly result in exceeding the storage space and stopping the machine. How
    can we approach this concern?
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经创建了许多容器和镜像。然而，这仅仅是你在实际场景中会看到的一小部分。即使容器未运行，它们也需要存储在 Docker 主机上。这可能会迅速导致存储空间不足并停止机器。我们该如何解决这个问题呢？
- en: Cleaning up containers
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理容器
- en: 'First, let''s look at the containers that are stored on our machine. Here are
    the steps we need to follow:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下存储在我们机器上的容器。以下是我们需要遵循的步骤：
- en: 'To print all the containers (irrespective of their state), we can use the `docker
    ps -a` command, as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印所有容器（无论其状态如何），我们可以使用 `docker ps -a` 命令，如下所示：
- en: '[PRE52]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to delete a stopped container, we can use the `docker rm` command
    (if a container is running, we need to stop it first), as follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了删除一个停止的容器，我们可以使用`docker rm`命令（如果容器正在运行，我们需要先停止它），如下所示：
- en: '[PRE53]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we want to remove all stopped containers, we can use the following command:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要删除所有停止的容器，可以使用以下命令：
- en: '[PRE54]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can also adopt a different approach and ask the container to remove itself
    as soon as it has stopped by using the `--rm` flag, as in the following example:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以采用另一种方法，通过使用`--rm`标志，要求容器在停止后自动删除自己，如以下示例所示：
- en: '[PRE55]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In most real-life scenarios, we don't use stopped containers, and they are left
    only for debugging purposes.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现实场景中，我们不会使用已停止的容器，它们通常仅用于调试目的。
- en: Cleaning up images
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理镜像
- en: 'Cleaning up images is just as important as cleaning up containers. They can
    occupy a lot of space, especially in the case of the CD process, when each build
    ends up in a new Docker image. This can quickly result in a *no space left on
    device* error. The steps are as outlined here:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 清理镜像与清理容器一样**重要**。它们可能占用大量空间，尤其是在 CD 流程中，每次构建都会生成一个新的 Docker 镜像。这可能很快导致*磁盘空间不足*的错误。具体步骤如下：
- en: 'To check all the images in the Docker container, we can use the `docker images` command,
    as follows:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看 Docker 容器中的所有镜像，我们可以使用`docker images`命令，如下所示：
- en: '[PRE56]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To remove an image, we can call the following command:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除一个镜像，我们可以使用以下命令：
- en: '[PRE57]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the case of images, the automatic cleanup process is slightly more complex.
    Images don''t have states, so we cannot ask them to remove themselves when not
    used. A common strategy would be to set up a cron cleanup job, which removes all
    old and unused images. We could do this using the following command:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于镜像，自动清理过程稍微复杂一些。镜像没有状态，因此我们不能要求它们在不使用时自动删除。一个常见的策略是设置一个定时清理任务，删除所有旧的和未使用的镜像。我们可以使用以下命令来实现：
- en: '[PRE58]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With the cleaning up section, we've come to the end of the main Docker description.
    Now, let's do a short wrap-up and walk through the most important Docker commands.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理部分结束后，我们已经完成了主要的 Docker 描述。接下来，让我们简要总结一下并回顾一下最重要的 Docker 命令。
- en: Tip
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `docker system prune` command to remove all unused containers, images,
    and networks. Additionally, you can add the `–volumes` parameter to clean up volumes.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker system prune`命令删除所有未使用的容器、镜像和网络。此外，你还可以添加`–volumes`参数来清理卷。
- en: Docker commands overview
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 命令概览
- en: 'All Docker commands can be found by executing the following `help` command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Docker 命令可以通过执行以下`help`命令找到：
- en: '[PRE59]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To see all the options of any particular Docker command, we can use `docker
    help <command>`, as in the following example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看任何特定 Docker 命令的所有选项，我们可以使用`docker help <command>`，如下所示：
- en: '[PRE60]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There is also a very good explanation of all Docker commands on the official
    Docker page at [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/).
    It's worth reading, or at least skimming, through.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Docker 页面上也有非常好的Docker命令解释，[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)
    上有详细说明。值得一读，或者至少浏览一下。
- en: 'In this chapter, we''ve covered the most useful commands and their options.
    As a quick reminder, let''s walk through them, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了最有用的命令及其选项。作为快速回顾，以下是它们的总结：
- en: '![](img/B18223_02_Table_01.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18223_02_Table_01.jpg)'
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we covered the Docker basics, which is enough for building
    images and running applications as containers. Here are the key takeaways.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讲解了 Docker 的基础知识，这足以构建镜像和运行作为容器的应用程序。以下是主要要点总结。
- en: The containerization technology addresses the issues of isolation and environment
    dependencies using Linux kernel features. This is based on a process separation
    mechanism, so, therefore, no real performance drop is observed. Docker can be
    installed on most systems but is supported natively only on Linux. Docker allows
    us to run applications from images available on the internet and to build our
    own images. An image is an application packed together with all the dependencies.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化技术通过使用 Linux 内核特性来解决隔离和环境依赖问题。这是基于进程分离机制，因此不会出现真正的性能下降。Docker 可以安装在大多数系统上，但仅在
    Linux 上原生支持。Docker 允许我们从互联网上获取可用的镜像并构建我们自己的镜像。镜像是将应用程序与所有依赖项打包在一起的文件。
- en: Docker provides two methods for building images—a Dockerfile or committing a
    container. In most cases, the first option is used. Docker containers can communicate
    over the network by publishing the ports they expose. Docker containers can share
    persistent storage using volumes. For the purpose of convenience, Docker containers
    should be named, and Docker images should be tagged. In the Docker world, there
    is a specific convention for how to tag images. Docker images and containers should
    be cleaned from time to time in order to save on server space and avoid *no space
    left on device* errors.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了两种构建镜像的方法——使用 Dockerfile 或提交容器。在大多数情况下，使用第一种方法。Docker 容器可以通过发布它们暴露的端口进行网络通信。Docker
    容器可以通过卷共享持久存储。为了方便，Docker 容器应该命名，Docker 镜像应该打标签。在 Docker 的世界里，关于如何标记镜像有一个特定的约定。为了节省服务器空间并避免
    *磁盘空间不足* 错误，应该定期清理 Docker 镜像和容器。
- en: In the next chapter, we will look at the Jenkins configuration and find out
    how Jenkins can be used in conjunction with Docker.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Jenkins 配置，并了解如何将 Jenkins 与 Docker 配合使用。
- en: Exercises
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'We''ve covered a lot of material in this chapter. To consolidate what we have
    learned, we recommend the following two exercises:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章中已经覆盖了很多内容。为了巩固我们所学的知识，推荐以下两个练习：
- en: 'Run `CouchDB` as a Docker container and publish its port, as follows:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `CouchDB` 作为 Docker 容器并发布其端口，如下所示：
- en: Tip
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `docker search` command to find the `CouchDB` image.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 `docker search` 命令查找 `CouchDB` 镜像。
- en: Run the container.
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行容器。
- en: Publish the `CouchDB` port.
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布`CouchDB`端口。
- en: Open the browser and check that `CouchDB` is available.
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并检查`CouchDB`是否可用。
- en: 'Create a Docker image with a REST service, replying `Hello World` to `localhost:8080/hello`.
    Use any language and framework you prefer. Here are the steps you need to follow:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 REST 服务的 Docker 镜像，回复 `Hello World` 到 `localhost:8080/hello`。使用你喜欢的任何语言和框架。以下是你需要遵循的步骤：
- en: Tip
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: The easiest way to create a REST service is to use Python with the Flask framework
    ([https://flask.palletsprojects.com/](https://flask.palletsprojects.com/)). Note
    that a lot of web frameworks, by default, start an application only on the localhost
    interface. In order to publish a port, it's necessary to start it on all interfaces
    (`app.run(host='0.0.0.0')` in the case of a Flask framework).
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建 REST 服务的最简单方法是使用 Python 和 Flask 框架（[https://flask.palletsprojects.com/](https://flask.palletsprojects.com/)）。请注意，许多
    Web 框架默认只在本地主机接口上启动应用程序。为了发布端口，必须在所有接口上启动它（在 Flask 框架中使用 `app.run(host='0.0.0.0')`）。
- en: Create a web service application.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Web 服务应用程序。
- en: Create a Dockerfile to install dependencies and libraries.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Dockerfile 来安装依赖和库。
- en: Build the image.
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像。
- en: Run the container that is publishing the port.
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行发布端口的容器。
- en: Check that it's running correctly by using the browser (or `curl`).
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器（或 `curl`）检查它是否正确运行。
- en: Questions
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: To verify the knowledge acquired from this chapter, please answer the following
    questionsUse L-numbering for this list
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你在本章中获得的知识，请回答以下问题，使用 L-编号进行列表。
- en: What is the main difference between containerization (such as with Docker) and
    virtualization (such as with VirtualBox)?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器化（如 Docker）和虚拟化（如 VirtualBox）之间的主要区别是什么？
- en: What are the benefits of providing an application as a Docker image? Name at
    least two.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序提供为 Docker 镜像的好处是什么？请至少列举两点。
- en: Can the Docker daemon be run natively on Windows and macOS?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程是否可以在 Windows 和 macOS 上原生运行？
- en: What is the difference between a Docker image and a Docker container?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 镜像和 Docker 容器之间有什么区别？
- en: What does it mean when saying that Docker images have layers?
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当说 Docker 镜像有层时，这意味着什么？
- en: What are two methods of creating a Docker image?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像的两种方法是什么？
- en: Which command is used to create a Docker image from a Dockerfile?
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于从 Dockerfile 创建 Docker 镜像？
- en: Which command is used to run a Docker container from a Docker image?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于从 Docker 镜像运行 Docker 容器？
- en: In Docker terminology, what does it mean to publish a port?
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker 术语中，发布端口是什么意思？
- en: What is a Docker volume?
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Docker 卷？
- en: Further reading
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you''re interested in getting a deeper understanding of Docker and related
    technologies, please have a look at the following resources:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对深入了解 Docker 和相关技术感兴趣，请查阅以下资源：
- en: Docker documentation—*Get started*: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 文档——*入门*：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
- en: '*The Docker Book* by *James Turnbull*: [https://dockerbook.com/](https://dockerbook.com/)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker书籍* 由 *詹姆斯·特恩布尔* 编写：[https://dockerbook.com/](https://dockerbook.com/)'
