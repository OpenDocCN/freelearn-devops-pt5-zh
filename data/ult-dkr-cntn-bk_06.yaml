- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Debugging Code Running in Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试在容器中运行的代码
- en: In the previous chapter, we learned how to work with stateful containers – that
    is, containers that consume and produce data. We also learned how to configure
    our containers at runtime and at image build time using environment variables
    and config files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用有状态容器——即那些消费和产生数据的容器。我们还学习了如何使用环境变量和配置文件，在运行时和镜像构建时配置容器。
- en: In this chapter, we’re going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while it’s running in
    a container. With these techniques at hand, you will enjoy a frictionless development
    process for applications running in a container, similar to what you experience
    when developing applications that run natively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将介绍一些常用技术，这些技术可以帮助开发人员在容器中运行代码时进行演进、修改、调试和测试。掌握这些技巧后，你将在容器中开发应用时享受无摩擦的开发过程，类似于开发本地运行的应用程序。
- en: 'Here is a list of the topics we’re going to discuss:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要讨论的主题列表：
- en: Evolving and testing code running in a container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展和测试运行在容器中的代码
- en: Auto-restarting code upon changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码变更后的自动重启
- en: Line-by-line code debugging inside a container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内逐行调试代码
- en: Instrumenting your code to produce meaningful logging information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中插入日志，以产生有意义的日志信息
- en: Using Jaeger to monitor and troubleshoot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jaeger进行监控和故障排除
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做以下事情：
- en: Mount source code residing on the host in a running container
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载在主机上的源代码到运行中的容器
- en: Configure an application running in a container to auto-restart after a code
    change
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置运行在容器中的应用程序，在代码更改后自动重启
- en: Configure **Visual Studio Code** (**VS Code**) to debug applications written
    in Java, Node.js, Python, or .NET running inside a container line by line
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置**Visual Studio Code**（**VS Code**）逐行调试在容器内运行的Java、Node.js、Python或.NET应用程序
- en: Log important events from your application code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用代码中记录重要事件
- en: Configure your multi-component application for distributed tracing using the
    OpenTracing standard and a tool such as Jaeger
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenTracing标准和像Jaeger这样的工具，为你的多组件应用程序配置分布式追踪
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, if you want to follow along with the code, you will need Docker
    Desktop on macOS or Windows and a code editor – preferably VS Code. The samples
    will also work on a Linux machine with Docker and VS Code installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，如果你想跟随代码进行操作，你需要在macOS或Windows上安装Docker Desktop和一个代码编辑器——最好是VS Code。样例代码也可以在安装了Docker和VS
    Code的Linux机器上运行。
- en: 'To prepare your environment for the coming hands-on labs, follow these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备接下来的动手实验，请按照以下步骤操作：
- en: 'Please navigate to the folder where you have cloned the sample repository to.
    Normally, this should be `~/The-Ultimate-Docker-Container-Book`, so do the following:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请导航到你克隆示例代码库所在的文件夹。通常情况下，这应该是`~/The-Ultimate-Docker-Container-Book`，因此请执行以下操作：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new subfolder called `ch06` and navigate to it:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ch06`的新子文件夹并导航到它：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A complete set of sample solutions for all the examples discussed in this chapter
    can be found in the `sample-solutions/ch06` folder or directly on GitHub: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的所有示例的完整样本解决方案可以在`sample-solutions/ch06`文件夹中找到，或者直接在GitHub上查看：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06)。
- en: Evolving and testing code running in a container
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发展和测试运行在容器中的代码
- en: 'Make sure you have Node.js and `npm` installed on your computer before you
    continue. On Mac, use this command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，确保你的计算机已安装Node.js和`npm`。在Mac上，使用以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Windows, use the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，使用以下命令：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When developing code that will eventually be running in a container, the best
    approach is often to run the code in the container from the very beginning, to
    make sure there will be no surprises. But we have to do this in the right way
    so that we don’t introduce any unnecessary friction to our development process.
    First, let’s look at a naïve way we could run and test code in a container. We
    can do this using a basic Node.js sample application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发最终将运行在容器中的代码时，最好的做法通常是从一开始就将代码运行在容器中，以确保不会有任何意外情况。但我们必须以正确的方式做这件事，以免为我们的开发过程引入不必要的摩擦。首先，让我们看看我们可以如何在容器中运行和测试代码的一个简单方法。我们可以使用一个基本的Node.js样本应用程序来做到这一点：
- en: 'Create a new project folder and navigate to it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹并导航到该文件夹：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s use `npm` to create a new Node.js project:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`npm`来创建一个新的Node.js项目：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Accept all the defaults. Notice that a `package.json` file is created with
    the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受所有默认设置。注意，`package.json`文件已经创建，内容如下：
- en: '![Figure 6.1 – Content of the package.json file of the sample Node.js application](img/B19199_06_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 样本Node.js应用程序的package.json文件内容](img/B19199_06_01.jpg)'
- en: Figure 6.1 – Content of the package.json file of the sample Node.js application
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 样本Node.js应用程序的package.json文件内容
- en: 'We want to use the `Express.js` library in our Node application; thus, use
    `npm` to install it:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在Node应用程序中使用`Express.js`库，因此，使用`npm`来安装它：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will install the newest version of `Express.js` on our machine and, because
    of the `–save` parameter, add a reference to our `package.json` file that looks
    similar to this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们机器上最新版本的`Express.js`，并且因为`–save`参数的存在，它会将类似下面的引用添加到我们的`package.json`文件中：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in your case, the version number of `express` may be different.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在你的情况下，`express`的版本号可能不同。
- en: 'Start VS Code from within this folder:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个文件夹中启动VS Code：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In VS Code, create a new file called `index.js` and add this code snippet to
    it. Do not forget to save:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中，创建一个名为`index.js`的新文件并将此代码片段添加到其中。别忘了保存：
- en: '![Figure 6.2 – Content of the index.js file of the sample Node.js application](img/B19199_06_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 样本Node.js应用程序的index.js文件内容](img/B19199_06_02.jpg)'
- en: Figure 6.2 – Content of the index.js file of the sample Node.js application
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 样本Node.js应用程序的index.js文件内容
- en: 'From within your terminal window, start the application:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，启动应用程序：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On Windows and Mac, when you execute the preceding command for the first time,
    a window will pop up, asking you to approve it on the firewall.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows和Mac上，当你第一次执行上述命令时，会弹出一个窗口，要求你在防火墙上批准它。
- en: 'You should see this as the output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这样的输出：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This means that the application is running and ready to listen at the `0.0.0.0:3000`
    endpoint.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序正在运行，并准备在`0.0.0.0:3000`端点监听。
- en: Tip
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You might be wondering what the meaning of the host address, `0.0.0.0`, is and
    why we have chosen it. We will come back to this later when we run the application
    inside a container. For the moment, just know that `0.0.0.0` is a reserved IP
    address with a special meaning, similar to the loopback address, `127.0.0.1`.
    The `0.0.0.0` address simply means all IPv4 addresses on the local machine. If
    a host has two IP addresses, say `52.11.32.13` and `10.11.0.1`, and a server running
    on the host listens on `0.0.0.0`, it will be reachable at both of those IPs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道`0.0.0.0`这个主机地址的含义是什么，为什么我们选择了它。稍后当我们在容器中运行应用程序时会再提到这个问题。现在，只需要知道`0.0.0.0`是一个具有特殊意义的保留IP地址，类似于回环地址`127.0.0.1`。`0.0.0.0`地址的含义是本地机器上的所有IPv4地址。如果主机有两个IP地址，例如`52.11.32.13`和`10.11.0.1`，而主机上的服务器监听`0.0.0.0`，那么它将在这两个IP上都可以访问。
- en: 'Now, open a new tab in your favorite browser and navigate to `http://localhost:3000`.
    You should see this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你喜欢的浏览器中打开一个新标签页并导航到`http://localhost:3000`。你应该会看到这个：
- en: '![Figure 6.3 – Sample Node.js application running in a browser](img/B19199_06_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 样本Node.js应用程序在浏览器中运行](img/B19199_06_03.jpg)'
- en: Figure 6.3 – Sample Node.js application running in a browser
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 样本Node.js应用程序在浏览器中运行
- en: Great – our Node.js application is running on our developer machine. Stop the
    application by pressing *Ctrl* + *C* in the terminal.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很好 – 我们的Node.js应用程序在开发者机器上运行。通过在终端按下*Ctrl* + *C*来停止应用程序。
- en: 'Now, we want to test the application we have developed so far by running it
    inside a container. To do this, we must create a Dockerfile so that we can build
    a container image, from which we can then run a container. Let’s use VS Code again
    to add a file called `Dockerfile` to our project folder and give it the following
    content:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望通过在容器内运行应用程序来测试目前为止开发的应用程序。为此，我们必须创建一个Dockerfile，以便我们可以构建一个容器镜像，然后从该镜像运行容器。让我们再次使用VS
    Code，向项目文件夹中添加一个名为`Dockerfile`的文件，并为其提供以下内容：
- en: '![Figure 6.4 – Dockerfile for the sample Node.js application](img/B19199_06_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 示例Node.js应用程序的Dockerfile](img/B19199_06_04.jpg)'
- en: Figure 6.4 – Dockerfile for the sample Node.js application
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 示例Node.js应用程序的Dockerfile
- en: 'We can then use this Dockerfile to build an image called `sample-app`, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个Dockerfile构建一个名为`sample-app`的镜像，如下所示：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It will take a few seconds for the base image to be downloaded and your custom
    image to be built on top of it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像下载并在其上构建你的自定义镜像需要几秒钟。
- en: 'After building, run the application in the container with this command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，使用以下命令在容器中运行应用程序：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding command runs a container called `my-sample-app` from the `sample-app`
    container image and maps the container’s port, `3000`, to the equivalent host
    port. This port mapping is necessary; otherwise, we won’t be able to access the
    application running inside the container from outside the container. We will learn
    more about port mapping in [*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using*
    *Single-Host Networking*. It is similar to when we ran the application directly
    on our host.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会从`sample-app`容器镜像运行一个名为`my-sample-app`的容器，并将容器的端口`3000`映射到对应的宿主端口。这个端口映射是必要的，否则我们无法从容器外部访问容器内部运行的应用程序。我们将在[*第10章*](B19199_10.xhtml#_idTextAnchor218)中详细了解端口映射，*使用*
    *单主机网络*。这与我们直接在宿主机上运行应用程序时是类似的。
- en: Refresh your previous browser tab (or open a new browser tab and navigate to
    `localhost:3000`, if you closed it). You should see that the application still
    runs and produces the same output as when running natively. This is good. We have
    just shown that our application not only runs on our host but also inside a container.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新之前的浏览器标签页（或者如果你已经关闭了，打开一个新的浏览器标签页并导航到`localhost:3000`）。你应该能看到应用程序仍然在运行，并产生与本地运行时相同的输出。这是好的。我们已经展示了我们的应用程序不仅可以在宿主机上运行，也可以在容器内部运行。
- en: Stop and remove the container by pressing *Ctrl* + *C* in the terminal.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中按*Ctrl* + *C*停止并移除容器。
- en: 'Now, let’s modify our code and add some additional functionality. We will define
    another `HTTP GET` endpoint at `/hobbies`. Please add the following code snippet
    at the end of your `index.js` file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改代码并添加一些额外的功能。我们将在`/hobbies`处定义另一个`HTTP GET`端点。请将以下代码片段添加到`index.js`文件的末尾：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can test the new functionality on our host by running the app with the following
    command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令在宿主机上测试新功能：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, we can navigate to `http://localhost:3000/hobbies` in our browser. We
    should see the expected output – a JSON array with the list of hobbies – in the
    browser window. Don’t forget to stop the application with *Ctrl* + *C* when you’ve
    finished testing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在浏览器中导航到`http://localhost:3000/hobbies`。我们应该能在浏览器窗口看到预期的输出——一个包含爱好列表的JSON数组。完成测试后，别忘了按*Ctrl*
    + *C*停止应用程序。
- en: 'Next, we need to test the code when it runs inside the container. So, first,
    we must create a new version of the container image:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要测试代码在容器内运行时的表现。所以，首先，我们必须创建一个新的容器镜像版本：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the build should be quicker than the first time we did this since
    the base image is already in our local cache.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，构建应该比第一次更快，因为基础镜像已经在我们的本地缓存中。
- en: 'Next, we must run a container from this new image:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须从这个新镜像运行一个容器：
- en: '[PRE17]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we can navigate to `http://localhost:3000/hobbies` in our browser and confirm
    that the application works as expected inside the container too.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中导航到`http://localhost:3000/hobbies`，并确认应用程序在容器内也能正常工作。
- en: Once again, don’t forget to stop the container when you’re done by pressing
    *Ctrl* + *C*.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次提醒，完成后不要忘记按*Ctrl* + *C*停止容器。
- en: We can repeat this sequence of tasks over and over again for each feature we
    add or any existing features we improve. It turns out that this is a lot of added
    friction compared to times when all the applications we developed always ran directly
    on the host.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以针对每个新增的特性或改进的现有特性，反复执行这组任务。事实证明，与所有我们开发的应用程序直接在主机上运行的时代相比，这种方法增加了不少摩擦。
- en: However, we can do better. In the next section, we will look at a technique
    that allows us to remove most of this friction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更好。在下一节中，我们将探讨一种技巧，允许我们消除大部分的摩擦。
- en: Mounting evolving code into the running container
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将变化中的代码挂载到运行中的容器
- en: 'What if, after a code change, we do not have to rebuild the container image
    and rerun a container? Wouldn’t it be great if the changes would immediately,
    as we save them in an editor such as VS Code, be available inside the container
    too? Well, that is possible with volume mapping. In the previous chapter, we learned
    how to map an arbitrary host folder to an arbitrary location inside a container.
    We want to leverage that in this section. In [*Chapter 5*](B19199_05.xhtml#_idTextAnchor109),
    *Data Volumes and Configuration*, we learned how to map host folders as volumes
    in a container. For example, if we want to mount a host folder, `/projects/sample-app`,
    into a container at `/app`, the syntax for this will look as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码更改后，我们不需要重建容器镜像并重新运行容器，那会怎么样呢？如果在像 VS Code 这样的编辑器中保存更改时，变化能够立即反映到容器内部，那不是更好吗？实际上，通过卷映射，这是可能的。在上一章中，我们学习了如何将任意的主机文件夹映射到容器内部的任意位置。在本节中，我们将利用这一点。在[*第5章*](B19199_05.xhtml#_idTextAnchor109)，*数据卷和配置*中，我们学习了如何将主机文件夹映射为容器中的卷。例如，如果我们想将主机文件夹`/projects/sample-app`挂载到容器的`/app`路径，语法如下：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the `--volume <host-folder>:<container-folder>` line. The path to the
    host folder needs to be an absolute path, which in this example is `/projects/sample-app`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`--volume <host-folder>:<container-folder>`这一行。主机文件夹的路径需要是绝对路径，在这个例子中是`/projects/sample-app`。
- en: 'Now, if we want to run a container from our `sample-app` container image and
    we do that from the project folder, we can map the current folder to the `/app`
    folder of the container, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想从`sample-app`容器镜像运行一个容器，并且我们从项目文件夹中进行操作，我们可以将当前文件夹映射到容器的`/app`文件夹，具体命令如下：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note `$(pwd)` in place of the host folder path. `$(pwd)` equals the absolute
    path of the current folder, which comes in very handy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`$(pwd)`代替主机文件夹路径。`$(pwd)`代表当前文件夹的绝对路径，非常方便。
- en: 'Now, if we use the above volume mapping parameter, then whatever was in the
    `/app` folder of the `sample-app` container image will be overridden by the content
    of the mapped host folder, which in our case is the current folder. That’s exactly
    what we want – we want the current source to be mapped from the host into the
    container. Let’s test whether it works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用上面的卷映射参数，那么`sample-app`容器镜像中`/app`文件夹中的任何内容将被映射主机文件夹中的内容所覆盖，在我们的例子中就是当前文件夹。这正是我们想要的——我们希望当前源文件从主机映射到容器中。让我们测试一下是否有效：
- en: Stop the container if you have started it by pressing *Ctrl* + *C*.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经启动了容器，可以通过按*Ctrl* + *C*来停止它。
- en: 'Then, add the following snippet to the end of the `index.js` file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码片段添加到`index.js`文件的末尾：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Do not forget to save.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了保存。
- en: 'Then, run the container again – this time, without rebuilding the image first
    – to see what happens:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次运行容器——这次，不需要先重建镜像——观察发生了什么：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In your browser, navigate to `http://localhost:3000/status`. You will see the
    `OK` output in your browser window. Alternatively, instead of using your browser,
    you could use `curl` in another terminal window to probe the `/status` endpoint,
    as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，导航到`http://localhost:3000/status`。你会在浏览器窗口中看到`OK`输出。或者，你可以在另一个终端窗口中使用`curl`来探测`/status`端点，如下所示：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For all those working on Windows and/or Docker Desktop for Windows, you can
    use the PowerShell `Invoke-WebRequest` command or `iwr` for short instead of `curl`.
    In this case, the equivalent to the preceding command would be `PS> iwr -``Url
    http://localhost:3000/status`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有在Windows和/或Windows版Docker Desktop上工作的用户，你可以使用PowerShell的`Invoke-WebRequest`命令，或简称`iwr`，代替`curl`。在这种情况下，前面的命令的等效命令是`PS>
    iwr -Url http://localhost:3000/status`。
- en: Leave the application in the container running for the moment and make yet another
    change. Instead of just returning `OK` when navigating to `/status`, we want a
    message stating `OK, all good` to be returned. Make your modification and save
    your changes.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时让应用在容器中运行，并做另一次修改。当导航到`/status`时，我们希望返回的消息为`OK, all good`，而不仅仅是返回`OK`。进行修改并保存更改。
- en: Then, execute the `curl` command again or, if you did use your browser, refresh
    the page. What do you see? Right – nothing happened. The change we made is not
    reflected in the running application.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次执行`curl`命令，或者如果你使用了浏览器，刷新页面。你看到了什么？对——什么都没发生。我们所做的更改没有反映在运行中的应用程序中。
- en: 'Well, let’s double-check whether the change has been propagated in the running
    container. To do this, let’s execute the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们再次检查更改是否已经传播到运行中的容器中。为此，我们执行以下命令：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This executes the `cat index.js` command inside our already running container.
    We should see something like this – I have shortened the output for readability:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们已运行的容器中执行`cat index.js`命令。我们应该看到类似如下的内容——我已经简化了输出以便于阅读：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we can see, our changes have been propagated into the container as expected.
    Why, then, are the changes not reflected in the running application? Well, the
    answer is simple: for changes to be applied to the application, the Node.js sample
    application has to be restarted.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，修改已经按预期传播到容器中。那么，为什么这些更改没有反映在运行中的应用中呢？原因很简单：要使更改应用到应用程序中，必须重启Node.js示例应用程序。
- en: Let’s try that. Stop the container with the application running by pressing
    *Ctrl* + *C*. Then, re-execute the preceding `docker container run` command and
    use `curl` to probe the `http://localhost:3000/status` endpoint. This time, the
    following new message should b[e displayed:](http://localhost:3000/status)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下。通过按*Ctrl* + *C*停止运行的容器。然后，重新执行前面的`docker container run`命令，并使用`curl`探测`http://localhost:3000/status`端点。这次，应该会显示以下新消息：[http://localhost:3000/status](http://localhost:3000/status)
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we have significantly reduced the friction in the development process
    by mapping the source code in the running container. We can now add new codeor
    modify existing code and test it without having to build the container image first.
    However, a bit of friction has been left in play. We have to manually restart
    the container every time we want to test some new or modified code. Can we automate
    this? The answer is yes! We will demonstrate exactly this in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们通过将源代码映射到运行中的容器中，显著减少了开发过程中的摩擦。现在我们可以添加新代码或修改现有代码并进行测试，而无需首先构建容器镜像。然而，还是留下了一点摩擦。每次我们想测试新代码或修改过的代码时，都必须手动重新启动容器。我们能自动化这一过程吗？答案是肯定的！我们将在下一节中演示如何做到这一点。
- en: Auto-restarting code upon changes
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码更改后自动重启
- en: In the previous section, we showed you how we can massively reduce friction
    by volume mapping the source code folder in the container, thus avoiding having
    to rebuild the container image and rerun the container over and over again. Yet
    we still feel some remaining friction. The application running inside the container
    does not automatically restart when a code change is made. Thus, we have to manually
    stop and restart the container to pick up these new changes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何通过将源代码文件夹映射到容器中，极大地减少了摩擦，避免了每次都重建容器镜像并一遍遍重新运行容器。然而，我们仍然感觉到一些摩擦。容器内部运行的应用程序在代码更改时不会自动重启。因此，我们必须手动停止并重新启动容器，以使这些更改生效。
- en: In this section, we will learn how we can containerize our applications written
    in various languages, such as Node.js, Java, Python, and .NET, and have them restart
    automatically whenever a code change is detected. Let’s start with Node.js.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何将我们用多种语言编写的应用程序，如Node.js、Java、Python和.NET容器化，并在检测到代码更改时自动重启它们。让我们从Node.js开始。
- en: Auto-restarting for Node.js
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js自动重启
- en: 'If you have been coding for a while, you will certainly have heard about helpful
    tools that can run your applications and restart them automatically whenever they
    discover a change in the code base. For Node.js applications, the most popular
    tool is `nodemon`. Let’s take a look:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经编程一段时间了，你肯定听说过一些有用的工具，它们可以运行你的应用程序，并在发现代码库中的更改时自动重启它们。对于Node.js应用程序，最流行的工具是`nodemon`。让我们来看看：
- en: 'We can install `nodemon` globally on our system with the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令在系统上全局安装`nodemon`：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that `nodemon` is available, instead of starting our application (for example,
    on the host) with `node index.js`, we can just execute `nodemon` and we should
    see the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`nodemon`已经可用，不再需要像在主机上那样启动我们的应用程序（例如`node index.js`），只需执行`nodemon`即可，我们应该看到以下输出：
- en: '![Figure 6.5 – Running our Node.js sample application with nodemon](img/B19199_06_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 使用 nodemon 运行我们的 Node.js 示例应用程序](img/B19199_06_05.jpg)'
- en: Figure 6.5 – Running our Node.js sample application with nodemon
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 使用 nodemon 运行我们的 Node.js 示例应用程序
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As we can see, from parsing our `package.json` file, `nodemon` has recognized
    that it should use `node index.js` as the starting command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过解析我们的`package.json`文件，`nodemon`已经识别出应该将`node index.js`作为启动命令。
- en: 'Now, try to change some code. For this example, add the following code snippet
    to the end of `index.js` and then save the file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试更改一些代码。例如，在`index.js`的末尾添加以下代码片段，然后保存文件：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Look at the terminal window. Did you see something happen? You should see this
    additional output:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看终端窗口。看到了什么变化吗？你应该看到以下附加输出：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This indicates that `nodemon` has recognized some changes and automatically
    restarted the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`nodemon`已经检测到了一些更改，并自动重新启动了应用程序。
- en: 'Try this out on your browser by navigating to `localhost:3000/colors`. You
    should see the following expected output in your browser:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中尝试这个，通过访问`localhost:3000/colors`。你应该在浏览器中看到以下预期的输出：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is cool – you got this result without having to manually restart the application.
    This makes us yet another bit more productive. Now, can we do the same within
    the container?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷 – 你可以在不手动重启应用程序的情况下获得这个结果。这使我们的生产力又提高了一点。现在，在容器内部能否做到同样的效果？
- en: 'Yes, we can. However, we won’t use the start command, `node index.js`, as defined
    in the last line of our Dockerfile:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以。但是，我们不会使用在我们的 Dockerfile 最后一行定义的启动命令`node index.js`：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will use `nodemon` instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nodemon`。
- en: Do we have to modify our Dockerfile? Or do we need two different Dockerfiles,
    one for development and one for production?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要修改我们的 Dockerfile？或者我们需要两个不同的 Dockerfile，一个用于开发，一个用于生产？
- en: 'Our original Dockerfile creates an image that unfortunately does not contain
    `nodemon`. Thus, we need to create a new Dockerfile:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原始 Dockerfile 创建了一个不幸没有包含`nodemon`的镜像。因此，我们需要创建一个新的 Dockerfile：
- en: 'Create a new file. Let’s call it `Dockerfile.dev`. Its content should look
    like this:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件。我们称之为`Dockerfile.dev`。它的内容应该如下所示：
- en: '![Figure 6.6 – Dockerfile used for developing our Node.js application](img/B19199_06_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 用于开发我们的 Node.js 应用程序的 Dockerfile](img/B19199_06_06.jpg)'
- en: Figure 6.6 – Dockerfile used for developing our Node.js application
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 用于开发我们的 Node.js 应用程序的 Dockerfile
- en: Comparing this with our original `Dockerfile`, we have added line 2, where we
    install `nodemon`. We have also changed the last line and are now using `nodemon`
    as our start command.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将这与我们的原始`Dockerfile`进行比较，我们在第二行添加了`nodemon`的安装。我们还修改了最后一行，现在使用`nodemon`作为启动命令。
- en: 'Let’s build our development image, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建我们的开发镜像，如下所示：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Please note the `-f Dockerfile.dev` command-line parameter. We must use this
    since we are using a Dockerfile with a non-standard name.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意命令行参数`-f Dockerfile.dev`。由于我们使用的是非标准命名的Dockerfile，必须使用这个参数。
- en: 'Run a container, like this:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个容器，就像这样：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, while the application is running in the container, change some code, save
    it, and notice that the application inside the container is automatically restarted.
    With this, we have achieved the same reduction in friction while running in a
    container as we did when running directly on the host.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当应用程序在容器中运行时，改变一些代码，保存它，并注意到容器内的应用程序已经自动重新启动了。通过这种方式，我们在容器中运行时也实现了减少摩擦的效果，就像直接在主机上运行一样。
- en: Hit *Ctrl* + *C* when you’re done to exit your container.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成时，按下*Ctrl* + *C*退出你的容器。
- en: 'Use the following command to clean up your system and remove all running or
    dangling containers:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令清理系统并删除所有正在运行或悬挂的容器：
- en: '[PRE33]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You might be wondering, does this only apply to Node.js? No – fortunately, many
    popular languages support similar concepts.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这只适用于 Node.js 吗？不，幸运的是，许多流行的编程语言都支持类似的概念。
- en: Auto-restarting for Java and Spring Boot
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 和 Spring Boot 的自动重新启动
- en: Java and Spring Boot are still by far the most popular programming languages
    and libraries when developing **line of business** (**LOB**) type applications.
    Let’s learn how to work as friction-free as possible when developing such an application
    and containerizing it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Java和Spring Boot仍然是开发**业务线**（**LOB**）类型应用程序时最受欢迎的编程语言和库。让我们学习如何在开发这种应用程序并进行容器化时尽可能减少摩擦。
- en: For this example to work, you have to have Java installed on your computer.
    At the time of writing, the recommended version is Java 17\. Use your favorite
    package manager to do so, such as Homebrew on Mac or Chocolatey on Windows.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此示例正常工作，你必须在电脑上安装Java。写本文时，推荐的版本是Java 17。你可以使用你喜欢的包管理工具进行安装，比如Mac上的Homebrew或Windows上的Chocolatey。
- en: 'You may also want to make sure you have *Extension Pack for Java* by Microsoft
    installed for VS Code. You can find more details here: [https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要确保你已经为VS Code安装了*Microsoft的Java扩展包*。你可以在此处找到更多详细信息：[https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack)。
- en: 'Once you have the Java 17 SDK installed and ready on your computer, proceed
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在电脑上安装并准备好Java 17 SDK，请按照以下步骤操作：
- en: The easiest way to bootstrap a Spring Boot application is by using the `Spring
    Web`, and select it (*do not* select **Spring** **Reactive Web**).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Spring Boot应用程序最简单的方法是使用`Spring Web`，并选择它（*不要*选择**Spring** **Reactive Web**）。
- en: 'Your page should look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你的页面应该如下所示：
- en: '![Figure 6.7 – Bootstrapping a new Java project with Spring Initializr](img/B19199_06_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 使用Spring Initializr引导新的Java项目](img/B19199_06_07.jpg)'
- en: Figure 6.7 – Bootstrapping a new Java project with Spring Initializr
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 使用Spring Initializr引导新的Java项目
- en: Click `ch06/java-springboot-demo`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`ch06/java-springboot-demo`。
- en: 'Navigate to this folder:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到此文件夹：
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open VS Code from within this folder by using the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从此文件夹中打开VS Code：
- en: '[PRE35]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Locate the main file of the project, which is called `DemoApplication.java`,
    and click on the `main` method on line 9, as shown in the following screenshot:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到项目的主文件，名为`DemoApplication.java`，然后点击第9行的`main`方法，如下图所示：
- en: '![Figure 6.8 – Starting the Java Spring Boot application](img/B19199_06_08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 启动Java Spring Boot应用程序](img/B19199_06_08.jpg)'
- en: Figure 6.8 – Starting the Java Spring Boot application
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 启动Java Spring Boot应用程序
- en: 'Observe that the application has been compiled and that a terminal window opens.
    Content similar to the following will be displayed:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，应用程序已经被编译，并且打开了一个终端窗口。将显示如下类似的内容：
- en: '![Figure 6.9 – Output generated by a running Spring Boot application](img/B19199_06_09.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 运行Spring Boot应用程序生成的输出](img/B19199_06_09.jpg)'
- en: Figure 6.9 – Output generated by a running Spring Boot application
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 运行Spring Boot应用程序生成的输出
- en: On the second to last line of the preceding output, we can see that the application
    uses the Tomcat web server and is listening at port `8080`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面输出的倒数第二行，我们可以看到应用程序使用了Tomcat Web服务器，并且正在监听端口`8080`。
- en: 'Now, let’s add an endpoint that we can then try to access:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个端点，之后可以尝试访问它：
- en: Decorate the `DemoApplication` class with a `@``RestController` annotation.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`@RestController`注解装饰`DemoApplication`类。
- en: Add a `getSpecies` method that returns a list of strings
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个返回字符串列表的`getSpecies`方法
- en: 'Decorate the method with the following annotation:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下注解装饰该方法：
- en: '`@``GetMapping("/species")`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping("/species")`'
- en: 'Don’t forget to add the required `import` statements. The complete code will
    look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加所需的`import`语句。完整的代码如下所示：
- en: '![Figure 6.10 – Complete demo code for the Spring Boot example](img/B19199_06_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – Spring Boot示例的完整演示代码](img/B19199_06_10.jpg)'
- en: Figure 6.10 – Complete demo code for the Spring Boot example
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – Spring Boot示例的完整演示代码
- en: 'Use `curl` or the `/``species` endpoint:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`或`/species`端点：
- en: '![Figure 6.11 – Using the Thunder Client plugin to test the Java demo application](img/B19199_06_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 使用Thunder Client插件测试Java演示应用程序](img/B19199_06_11.jpg)'
- en: Figure 6.11 – Using the Thunder Client plugin to test the Java demo application
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 使用Thunder Client插件测试Java演示应用程序
- en: 'To add auto-restart support to our Java Spring Boot application, we need to
    add the so-called dev tools:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为我们的Java Spring Boot应用程序添加自动重启支持，我们需要添加所谓的开发工具：
- en: Locate the `pom.xml` file in your Java project and open it in the editor.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Java项目中找到`pom.xml`文件并在编辑器中打开它。
- en: 'Add the following snippet to the dependencies section of the file:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码段添加到文件的依赖部分：
- en: '![Figure 6.12 – Adding a reference to the Spring Boot dev tools](img/B19199_06_12.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 添加对Spring Boot开发工具的引用](img/B19199_06_12.jpg)'
- en: Figure 6.12 – Adding a reference to the Spring Boot dev tools
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 添加对Spring Boot开发工具的引用
- en: Note that the version node in the dependency definition can be omitted as the
    project uses `spring-boot-starter-parent` as the parent.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，依赖项定义中的版本节点可以省略，因为项目使用了`spring-boot-starter-parent`作为父级。
- en: Stop and rerun the application.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止并重新运行应用程序。
- en: Modify line 20 of the `DemoApplication` class and add `Crocodile` as a fourth
    species to return to the caller.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`DemoApplication`类的第20行，添加`Crocodile`作为返回给调用者的第四个物种。
- en: Save your changes and observe that the application automatically rebuilds and
    restarts.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的更改，并观察应用程序自动重新构建并重启。
- en: Use `curl` or Thunder Client again to access the `/species` endpoint. This time,
    a list of four species should be returned, including the just-added `Crocodile`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`或Thunder Client再次访问`/species`端点。这次应该返回一个包含刚刚添加的`Crocodile`在内的四个物种的列表。
- en: 'Great – we have a Java Spring Boot application that automatically re-compiles
    and restarts when we change any code in it. Now, we need to dockerize the whole
    thing, as we did with the Node.js example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒——我们有一个Java Spring Boot应用程序，当我们更改代码时，它会自动重新编译并重启。现在，我们需要像在Node.js示例中那样将整个应用容器化：
- en: 'Add a `Dockerfile` to the root of the project with the following content:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到项目根目录的`Dockerfile`中：
- en: '![Figure 6.13 – Dockerfile for the Java Spring Boot demo](img/B19199_06_13.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13 – Java Spring Boot示例的Dockerfile](img/B19199_06_13.jpg)'
- en: Figure 6.13 – Dockerfile for the Java Spring Boot demo
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – Java Spring Boot示例的Dockerfile
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have used the `eclipse-temurin` image with the `17-jdk-focal` tag for this
    example since this image, at the time of writing, works on the M1 or M2 processor
    used by modern MacBooks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中使用了`eclipse-temurin`镜像和`17-jdk-focal`标签，因为在撰写本文时，该镜像适用于现代MacBook上使用的M1或M2处理器。
- en: 'Create an image using the preceding Dockerfile with this command:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个镜像，使用前面的Dockerfile：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a container from this Docker image with the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从这个Docker镜像创建一个容器：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first time you run the container, it will take a while to compile since
    all the Maven dependencies need to be downloaded.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行容器时，由于需要下载所有Maven依赖项，因此编译会花费一些时间。
- en: Try to access the `/species` endpoint, as you did previously.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试像之前一样访问`/species`端点。
- en: Now, change some code – for example, add a fifth species to be returned to the
    `getSpecies` method, such as `Penguin`, and then save your changes.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改一些代码——例如，向`getSpecies`方法中添加一个第五个物种，比如`Penguin`，然后保存更改。
- en: Observe how the application running inside the container is rebuilt. Verify
    that the change has been incorporated by accessing the `/species` endpoint once
    again and asserting that five species are returned, including `Penguin`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察容器内运行的应用程序是如何被重新构建的。通过再次访问`/species`端点并确认返回五个物种，包括`Penguin`，来验证更改是否已被纳入。
- en: When you’re done playing around, stop the container either via the dashboard
    of Docker Desktop or the Docker plugin in VS Code.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成操作后，可以通过Docker Desktop的仪表盘或VS Code中的Docker插件停止容器。
- en: Well, that was quite straightforward, wasn’t it? But let me tell you, setting
    up your development environment this way can make developing containerized applications
    much more enjoyable by eliminating much of the unnecessary friction.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这不是很简单吗？不过让我告诉你，这种设置开发环境的方式可以通过消除许多不必要的摩擦，让开发容器化应用变得更加愉快。
- en: Challenge
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战
- en: Try to find out how you could map your local Maven cache into the container,
    to accelerate the first startup of the container even further.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出如何将本地的Maven缓存映射到容器中，以进一步加速容器的首次启动。
- en: Next, we are going to show you how easy it is to do the same exercise in Python.
    Stay tuned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向你展示如何轻松地在Python中完成相同的操作，敬请期待。
- en: Auto-restarting for Python
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python的自动重启
- en: Let’s look at how the same thing works for Python.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看相同的操作在Python中是如何工作的。
- en: Prerequisites
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前提条件
- en: For this example to work, you need to have Python 3.x installed on your computer.
    You can do this using your preferred package manager, such as Homebrew on Mac
    or Chocolatey on Windows.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例能够正常工作，你需要在电脑上安装Python 3.x。你可以通过你喜欢的包管理工具来安装，例如Mac上的Homebrew或Windows上的Chocolatey。
- en: 'On your Mac, use this command to install the latest Python version:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Mac上，使用此命令安装最新的Python版本：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On your Windows computer, use this command to do the same:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Windows 计算机上，使用此命令进行相同操作：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use this command to verify that the installation was successful:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令验证安装是否成功：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the author’s case, the output looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的案例中，输出看起来是这样的：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s begin:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'First, create a new project folder for our sample Python application and navigate
    to it:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为我们的示例 Python 应用程序创建一个新的项目文件夹，并导航到该文件夹：
- en: '[PRE42]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open VS Code from within this folder by using the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从此文件夹中打开 VS Code：
- en: '[PRE43]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will create a sample Python application that uses the popular Flask library.
    Thus, add a file to this folder called `requirements.txt` that contains this content:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个使用流行 Flask 库的示例 Python 应用程序。因此，向此文件夹中添加一个名为 `requirements.txt` 的文件，内容如下：
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, add a `main.py` file and give it this content:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个 `main.py` 文件，并将以下内容填入其中：
- en: '![Figure 6.14 – Content of the main.py file of our sample Python application](img/B19199_06_14.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 我们的示例 Python 应用程序的 main.py 文件内容](img/B19199_06_14.jpg)'
- en: Figure 6.14 – Content of the main.py file of our sample Python application
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 我们的示例 Python 应用程序的 main.py 文件内容
- en: This is a sim[ple Hello World-type](http://localhost:5000/) app that implements
    a single RESTful endpoint at `http://localhost:5000/`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 Hello World 类型的 [应用](http://localhost:5000/)，它在 `http://localhost:5000/`
    实现了一个 RESTful 端点。
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `host="0.0.0.0"` parameter in the `app.run` command is needed so that we
    can expose the port on which the Python app is listening (`5000`) to the host.
    We will need this later in this example.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.run` 命令中的 `host="0.0.0.0"` 参数是必要的，这样我们才能将 Python 应用监听的端口（`5000`）暴露给主机。稍后我们会用到这个。
- en: Please also note that some people have reported that, when running on a Mac
    and using port `5000`, an error stating “Address already in use. Port `5000` is
    in use by another program...” is triggered. In this case, just try to use a different
    port, such as `5001`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有些人在 Mac 上运行时，使用端口 `5000` 时，出现错误提示：“地址已在使用中。端口 `5000` 已被另一个程序占用...”。遇到这种情况时，只需尝试使用不同的端口，例如
    `5001`。
- en: 'Before we can run and test this application, we need to install the necessary
    dependencies – in our case, Flask. In the terminal, run the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行并测试此应用程序之前，我们需要安装必要的依赖项——在我们这个例子中是 Flask。在终端中运行以下命令：
- en: '[PRE45]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This should install Flask on your host. We are now ready to go.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在主机上安装 Flask。我们现在可以开始了。
- en: 'When using Python, we can also use `nodemon` to have our application auto-restart
    when any changes are made to the code. For example, assume that your command to
    start the Python application is `python main.py`. In this case, you would just
    use `nodemon` like so:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 Python 时，我们还可以使用 `nodemon` 使我们的应用在代码有任何更改时自动重启。例如，假设你启动 Python 应用的命令是 `python
    main.py`，在这种情况下，你只需像这样使用 `nodemon`：
- en: '[PRE46]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should see the following output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 6.15 – Using nodemon to auto-restart a Python 3 application](img/B19199_06_15.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 使用 nodemon 自动重启 Python 3 应用程序](img/B19199_06_15.jpg)'
- en: Figure 6.15 – Using nodemon to auto-restart a Python 3 application
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 使用 nodemon 自动重启 Python 3 应用程序
- en: 'When using `nodemon` to start and monitor a Python application, we can test
    the application by using `curl`. Open another terminal window and enter this:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `nodemon` 启动并监控 Python 应用程序时，我们可以使用 `curl` 测试应用程序。打开另一个终端窗口，并输入以下命令：
- en: '[PRE47]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see this in the output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到以下内容：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let’s modify the code by adding the following snippet to `main.py`, right
    after the definition of the `/` endpoint (that is, right after line 5), and save
    it:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过在 `/` 端点的定义后（即第 5 行后）添加以下代码片段来修改代码，并保存：
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`nodemon` will discover the changes and restart the Python app, as we can see
    in the output produced in the terminal:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodemon` 会发现更改并重启 Python 应用程序，如终端中输出的内容所示：'
- en: '![Figure 6.16 – nodemon discovering a change in the Python code](img/B19199_06_16.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – nodemon 发现 Python 代码中的变化](img/B19199_06_16.jpg)'
- en: Figure 6.16 – nodemon discovering a change in the Python code
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – nodemon 发现 Python 代码中的变化
- en: 'Once again, believing is good, but testing is better. Thus, let’s use our friend
    `curl` once again to probe the new endpoint and see what we get:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，信任是好的，但测试更好。因此，让我们再次使用我们的好朋友 `curl` 来探测新的端点，看看能得到什么：
- en: '[PRE50]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output should look like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Nice – it works! With that, we have covered Python.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 很好 – 它工作正常！到此为止，我们已经覆盖了 Python 部分。
- en: 'Now, it’s time to containerize this application. Add a file called `Dockerfile`
    to the project with the following content:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，到了将这个应用容器化的时候了。将一个名为 `Dockerfile` 的文件添加到项目中，内容如下：
- en: '![Figure 6.17 – Dockerfile for the sample Python application](img/B19199_06_17.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 样例 Python 应用的 Dockerfile](img/B19199_06_17.jpg)'
- en: Figure 6.17 – Dockerfile for the sample Python application
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 样例 Python 应用的 Dockerfile
- en: Note that on line 1, we are using a special base image that contains both Python
    and Node.js code. Then, on line 2, we install the `nodemon` tool before we copy
    the `requirements.txt` file into the container and execute the `pip install` command.
    Next, we copy all other files into the container and define the start command
    for whenever an instance of this image – that is, a container – is created.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第1行，我们使用了一个包含 Python 和 Node.js 代码的特殊基础镜像。然后，在第2行，我们安装了 `nodemon` 工具，接着将
    `requirements.txt` 文件复制到容器中并执行 `pip install` 命令。接下来，我们将所有其他文件复制到容器中，并定义每次创建该镜像实例（即容器）时的启动命令。
- en: 'Let’s build a Docker image with this command:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建 Docker 镜像：
- en: '[PRE52]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can run a container from this image with the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码从此镜像启动一个容器：
- en: '[PRE53]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We should have an output similar to what was produced by the application running
    inside the container in *step 6*, where we ran the application natively:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到与在 *步骤6* 中运行应用程序时，容器内部产生的输出类似，那时我们是本地运行应用程序的：
- en: '![Figure 6.18 – Running the containerized Python sample application](img/B19199_06_18.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 运行容器化的 Python 样例应用](img/B19199_06_18.jpg)'
- en: Figure 6.18 – Running the containerized Python sample application
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 运行容器化的 Python 样例应用
- en: Note how we have mapped the container port, `5000`, to the equivalent host port
    so that we can access the application from outside. We have also mapped the content
    of the sample directory on the host to the `/app` folder inside the running container.
    This way, we can update the code and the containerized application will automatically
    restart.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们如何将容器端口 `5000` 映射到相应的主机端口，以便我们可以从外部访问该应用程序。我们还将主机上的样例目录内容映射到正在运行的容器中的
    `/app` 文件夹。这样，我们就可以更新代码，容器化的应用程序会自动重启。
- en: Try to change the application code, and return a fourth color when the `/colors`
    endpoint is hit. Save the change and observe how the application running inside
    the container is restarted.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改应用程序代码，并在访问 `/colors` 端点时返回第四种颜色。保存更改并观察容器内运行的应用程序如何重新启动。
- en: Use the `curl` command to verify that an array of four colors is returned.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`命令验证返回的是否是包含四种颜色的数组。
- en: When you’re done playing with this example, hit *Ctrl* + *C* in the terminal
    window where you have the container running to stop the application and the container.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你玩完这个示例后，按下终端窗口中运行容器的 *Ctrl* + *C* 来停止应用程序和容器。
- en: With this, we have shown a fully working example for Python that helps you massively
    reduce the friction of working with containers during the development process.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个示例，我们展示了一个完整的 Python 工作示例，帮助你在开发过程中大大减少与容器相关的摩擦。
- en: .NET is another popular platform. Let’s see if we can do something like this
    when developing a C# application on .NET.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 是另一个流行的平台。让我们看看在 .NET 上开发 C# 应用程序时，是否可以做到类似的操作。
- en: Auto-restarting for .NET
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 的自动重启
- en: Our next candidate is a .NET application written in C#. Let’s look at how dynamic
    code updates and auto-restarts work in .NET.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个候选示例是一个用 C# 编写的 .NET 应用程序。让我们看看动态代码更新和自动重启在 .NET 中是如何工作的。
- en: Prerequisites
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前提条件
- en: If you have not done so before, please install .NET on your laptop or workstation.
    You can use your favorite package manager, such as Homebrew on Mac or Chocolatey
    on Windows, to do so.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有安装，请在你的笔记本或工作站上安装 .NET。你可以使用你喜欢的包管理器，例如 Mac 上的 Homebrew 或 Windows 上的
    Chocolatey。
- en: 'On Mac, use this command to install the .NET 7 SDK:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，使用以下命令安装 .NET 7 SDK：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'On a Windows machine, you can use this command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，你可以使用以下命令：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, use this command to verify your installation:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用此命令验证你的安装：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'On the author’s machine, the output is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的机器上，输出如下：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s begin:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'In a new terminal window, navigate to this chapter’s folder:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的终端窗口中，导航到本章文件夹：
- en: '[PRE58]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'From within this folder, use the `dotnet` tool to create a new Web API and
    have it placed in the `dotnet` subfolder:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中，使用 `dotnet` 工具创建一个新的 Web API，并将其放置在 `dotnet` 子文件夹中：
- en: '[PRE59]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Navigate to this new project folder:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到这个新项目文件夹：
- en: '[PRE60]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Open VS Code from within this folder:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该文件夹中打开 VS Code：
- en: '[PRE61]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If this is the first time you have opened a .NET project with VS Code, then
    the editor may display a popup asking you to add the missing dependencies for
    our `dotnet` project. Click the **Yes** button in this case:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次在 VS Code 中打开 .NET 项目，编辑器可能会显示一个弹窗，询问你是否需要添加缺失的依赖项。此时，点击 **是** 按钮：
- en: '![Figure 6.19 – Request to load missing assets for the .NET sample application](img/B19199_06_19.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19 – 请求加载 .NET 示例应用程序的缺失资产](img/B19199_06_19.jpg)'
- en: Figure 6.19 – Request to load missing assets for the .NET sample application
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 请求加载 .NET 示例应用程序的缺失资产
- en: 'In the Project Explorer of VS Code, you should see this:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 的项目资源管理器中，你应该看到以下内容：
- en: '![Figure 6.20 – The .NET sample application in the VS Code Project Explorer](img/B19199_06_20.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.20 – 在 VS Code 项目资源管理器中查看 .NET 示例应用程序](img/B19199_06_20.jpg)'
- en: Figure 6.20 – The .NET sample application in the VS Code Project Explorer
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 在 VS Code 项目资源管理器中查看 .NET 示例应用程序
- en: Please note the `Controllers` folder with the `WeatherForecastController.cs`
    file in it. Open this file and analyze its content. It contains the definition
    for the `WeatherForecastController` class, which implements a simple RESTful controller
    with a GET endpoint at `/WeatherForecast`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意包含 `WeatherForecastController.cs` 文件的 `Controllers` 文件夹。打开这个文件并分析其内容。它包含
    `WeatherForecastController` 类的定义，该类实现了一个简单的 RESTful 控制器，提供 `/WeatherForecast`
    的 GET 端点。
- en: 'From your terminal, run the application with `dotnet run`. You should see something
    like this:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，运行应用程序 `dotnet run`。你应该看到如下所示的内容：
- en: '![Figure 6.21 – Running the .NET sample Web API on the host](img/B19199_06_21.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.21 – 在主机上运行 .NET 示例 Web API](img/B19199_06_21.jpg)'
- en: Figure 6.21 – Running the .NET sample Web API on the host
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 在主机上运行 .NET 示例 Web API
- en: Please note the fourth [line in the above](http://localhost:5080/) output, where
    .NET tells us that the application is listening at `http://localhost:5080`. In
    your case, the port may be a different one. Use the one reported for you for all
    subsequent steps.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上面[输出中的第四行](http://localhost:5080/)，.NET 告诉我们应用程序正在 `http://localhost:5080`
    监听。在你的情况下，端口可能不同。请使用为你报告的端口进行后续所有操作。
- en: 'We can use `curl` to test the application, like so:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `curl` 来测试应用程序，方法如下：
- en: '[PRE62]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will output an array of five JSON objects containing random weather data:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个包含五个随机天气数据的 JSON 对象数组：
- en: '![Figure 6.22 – Weather data produced by the .NET sample application](img/B19199_06_22.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.22 – .NET 示例应用程序生成的天气数据](img/B19199_06_22.jpg)'
- en: Figure 6.22 – Weather data produced by the .NET sample application
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – .NET 示例应用程序生成的天气数据
- en: 'We can now try to modify the code in `WeatherForecastController.cs` and return,
    say, 10 instead of the default 5 items. Change line 24 so that it looks like this:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试修改 `WeatherForecastController.cs` 中的代码，返回 10 条数据而不是默认的 5 条。将第 24 行修改为如下所示：
- en: '[PRE63]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Save your changes and rerun the `curl` command. Notice how the result does not
    contain the newly added value. This is the same problem that we observed for Node.js
    and Python. To see the newly updated return value, we need to (manually) restart
    the application.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的更改并重新运行 `curl` 命令。请注意，结果中不包含新添加的值。这是我们在 Node.js 和 Python 中观察到的相同问题。为了查看最新的返回值，我们需要（手动）重新启动应用程序。
- en: Thus, in your terminal, stop the application with *Ctrl* + *C* and restart it
    with `dotnet run`. Try the `curl` command again. The result should now reflect
    your changes.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在终端中，按 *Ctrl* + *C* 停止应用程序，然后使用 `dotnet run` 重新启动它。再次尝试 `curl` 命令。此时，结果应反映你所做的更改。
- en: 'Luckily for us, the `dotnet` tool has the `watch` command. Stop the application
    by pressing *Ctrl* + *C* and execute this slightly modified command:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，`dotnet` 工具有一个 `watch` 命令。按 *Ctrl* + *C* 停止应用程序，然后执行这个稍作修改的命令：
- en: '[PRE64]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should see output resembling the following (shortened):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出（已缩短）：
- en: '![Figure 6.23 – Running the .NET sample application with the watch task](img/B19199_06_23.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.23 – 使用 watch 任务运行 .NET 示例应用程序](img/B19199_06_23.jpg)'
- en: Figure 6.23 – Running the .NET sample application with the watch task
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 使用 watch 任务运行 .NET 示例应用程序
- en: Notice the first line in the preceding output, which states that the running
    application is now watched for changes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面输出的第一行，它显示正在运行的应用程序现在已经开启监视以检测更改。
- en: 'Make another change in `WeatherForecastController.cs`; for example, make the
    `GET` endpoint method return 100 weather items and then save your changes. Observe
    the output in the terminal. It should look something like this:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherForecastController.cs`中做另一个更改；例如，让`GET`端点方法返回100个天气项，然后保存更改。观察终端中的输出。它应该像这样：
- en: '![Figure 6.24 – Auto-restarting the running sample .NET Core application](img/B19199_06_24.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24 – 自动重启正在运行的.NET Core示例应用](img/B19199_06_24.jpg)'
- en: Figure 6.24 – Auto-restarting the running sample .NET Core application
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 – 自动重启正在运行的.NET Core示例应用
- en: 'By automatically restarting the application upon making changes to the code,
    the result is immediately available to us, and we can easily test it by running
    the following `curl` command:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在更改代码后自动重启应用，结果立即可用，我们可以通过运行以下`curl`命令轻松测试它：
- en: '[PRE65]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 100 instead of 10 weather items should be output this time.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这次应该输出100个天气项目，而不是10个。
- en: 'Now that we have auto-restart working on the host, we can author a `Dockerfile`
    that does the same for the application running inside a container. In VS Code,
    add a new file called `Dockerfile-dev` to the project and add the following content
    to it:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在主机上启用了自动重启，我们可以为容器内运行的应用编写一个`Dockerfile`来实现相同的功能。在VS Code中，向项目中添加一个名为`Dockerfile-dev`的新文件，并将以下内容添加到该文件中：
- en: '![Figure 6.25 – Dockerfile for the .NET sample application](img/B19199_06_25.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图6.25 – .NET示例应用的Dockerfile](img/B19199_06_25.jpg)'
- en: Figure 6.25 – Dockerfile for the .NET sample application
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – .NET示例应用的Dockerfile
- en: Note the `--urls` command-line parameter on line 6\. This explicitly tells the
    application to listen on port `5000` at all endpoints inside the container (denoted
    by the special `0.0.0.0` IP address). If we were to leave the default of `localhost`,
    then we wouldn’t be able to reach the application from outside the container.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第6行中的`--urls`命令行参数。这个参数明确告诉应用在容器内所有端点上监听端口`5000`（由特殊的`0.0.0.0` IP地址表示）。如果我们保留默认的`localhost`，则无法从容器外部访问该应用。
- en: Port is already in use
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 端口已被占用
- en: Please note that some people have reported that when running on a Mac and using
    port `5000`, an error stating “Address already in use. Port `5000` is in use by
    another program...” is triggered. In this case, just try to use a different port,
    such as `5001`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有人报告说，在Mac上使用端口`5000`时，会触发错误消息“地址已被使用。端口`5000`已被其他程序占用...”。这种情况下，只需尝试使用不同的端口，例如`5001`。
- en: 'Now, we’re ready to build the container image:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好构建容器镜像：
- en: 'Use the following command to build a container image for the .NET sample:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为.NET示例构建容器镜像：
- en: '[PRE66]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the image has been built, we can run a container from it:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，我们可以从中运行一个容器：
- en: '[PRE67]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We should see a similar output to what we saw when running natively.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个与原生运行时类似的输出。
- en: 'Let’s test the application with our friend, `curl`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用我们的朋友`curl`来测试应用：
- en: '[PRE68]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We should get the array of weather forecast items. No surprises here – it works
    as expected.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该获得天气预报项的数组。没有意外 – 它按预期工作。
- en: 'Now, let’s make a code change in the controller and save it. Observe what’s
    happening in the terminal window. We should see an output like this:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在控制器中进行代码更改并保存。观察终端窗口中发生的情况。我们应该能看到类似如下的输出：
- en: '![Figure 6.26 – Hot reloading the .NET sample application running inside a
    container](img/B19199_06_26.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图6.26 – 热重载容器内运行的.NET示例应用](img/B19199_06_26.jpg)'
- en: Figure 6.26 – Hot reloading the .NET sample application running inside a container
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26 – 热重载容器内运行的.NET示例应用
- en: Well, that’s exactly what we expected. With this, we have removed most of the
    friction that we introduced by using containers when developing a .NET application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这正是我们预期的。通过这个，我们已经消除了在开发.NET应用时使用容器引入的大部分摩擦。
- en: 'When you’re done playing with the .NET sample application, open the dashboard
    of your Docker Desktop application. Locate the `csharp-sample` container and select
    it. Then, click the red **Delete** button to remove it from your system. This
    is the easiest way to do this since, unfortunately, just pressing *Ctrl* + *C*
    in the terminal window where you ran the container does not work. Alternatively,
    you can open another terminal window and use this command to get rid of the container:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成 .NET 示例应用程序的调试后，打开 Docker Desktop 应用程序的仪表盘。定位到 `csharp-sample` 容器并选择它。然后，点击红色的**删除**按钮，将其从系统中移除。这是最简单的方式，因为不幸的是，仅仅在你运行容器的终端窗口中按下
    *Ctrl* + *C* 并不起作用。另一种方法是，你可以打开一个新的终端窗口并使用以下命令来移除容器：
- en: '[PRE69]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That’s it for now. In this section, we explored how we can reduce friction during
    development when working with containerized applications written in Node.js, Python,
    Spring Boot, Java, or .NET. Next, we are going to learn how we can debug an application
    running in a container line by line.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时就到这里。在本节中，我们探讨了在开发容器化应用程序时，如何减少与 Node.js、Python、Spring Boot、Java 或 .NET 编写的应用程序之间的摩擦。接下来，我们将学习如何逐行调试运行在容器中的应用程序。
- en: Line-by-line code debugging inside a container
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器内逐行调试代码
- en: Before we dive into this section about debugging code running inside a container
    line by line, let me make a disclaimer. What you will learn in this section should
    usually be your last resort if nothing else works. Ideally, when following a test-driven
    approach when developing your application, the code is mostly guaranteed to work
    since you have written unit and integration tests for it and run them against
    your code, which also runs in a container. Alternatively, if unit or integration
    tests don’t provide you with enough insight and you need to debug your code line
    by line, you can do so by running your code directly on your host, thus leveraging
    the support of development environments such as VS Code, Eclipse, or IntelliJ,
    to name just a few IDEs.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何逐行调试容器内运行的代码之前，我要做一个免责声明。你将在本节中学到的内容通常应作为最后的手段，前提是其他方法无效。理想情况下，当你在开发应用程序时采用测试驱动的方法，代码通常是有保障的，因为你已经为其编写了单元测试和集成测试，并且在容器内运行它们。如果单元测试或集成测试未能提供足够的洞见，且你需要逐行调试代码，你可以直接在主机上运行代码，从而利用像
    VS Code、Eclipse 或 IntelliJ 这样的开发环境的支持，以上只是其中的一些 IDE。
- en: With all this preparation, you should rarely need to manually debug your code
    as it is running inside a container. That said, let’s see how you can do it anyways!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 做好所有这些准备后，你应该很少需要手动调试容器内运行的代码。话虽如此，让我们看看无论如何你如何进行调试！
- en: In this section, we are going to concentrate exclusively on how to debug when
    using VS Code. Other editors and IDEs may or may not offer similar capabilities.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于如何使用 VS Code 调试。其他编辑器和 IDE 可能会提供类似或不提供此功能。
- en: Debugging a Node.js application
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 Node.js 应用程序
- en: 'We’ll start with the easiest one – a Node.js application. We will use our sample
    application in the `~/The-Ultimate-Docker-Container-Book/ch06/node-sample` folder,
    which we worked with earlier in this chapter:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最简单的开始——一个 Node.js 应用程序。我们将使用在 `~/The-Ultimate-Docker-Container-Book/ch06/node-sample`
    文件夹中的示例应用程序，这个文件夹是我们在本章之前使用过的：
- en: 'Open a new terminal window and make sure that you navigate to this project
    folder:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，并确保你导航到这个项目文件夹：
- en: '[PRE70]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open VS Code from within this container:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从容器内打开 VS Code：
- en: '[PRE71]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the terminal window, from within the project folder, run a container with
    our sample Node.js application:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，从项目文件夹内运行一个包含我们示例 Node.js 应用程序的容器：
- en: '[PRE72]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding command, we mapped port `9229` to the host. This port is used
    by the Node.js debugger, and VS Studio will communicate with our Node application
    via this port. Thus, it is important that you open this port – but only during
    a debugging session! Also, note that we overrode the standard start command that
    we defined in the Dockerfile (remember, it was just `node index.js`) with `node
    --inspect=0.0.0.0 index.js`. The `--inspect=0.0.0.0` command-line parameter tells
    Node to run in debug mode and listen on all IPv4 addresses in the container.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们将端口 `9229` 映射到主机。该端口由 Node.js 调试器使用，VS Studio 将通过该端口与我们的 Node 应用程序进行通信。因此，打开这个端口是很重要的——但仅限于调试会话期间！另外，请注意，我们覆盖了在
    Dockerfile 中定义的标准启动命令（记得它原本只是 `node index.js`），用的是 `node --inspect=0.0.0.0 index.js`。`--inspect=0.0.0.0`
    命令行参数告诉 Node 以调试模式运行，并监听容器中的所有 IPv4 地址。
- en: Now, we are ready to define a VS Code launch task for the scenario at hand –
    that is, our code running inside a container.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为当前场景定义一个 VS Code 启动任务——也就是让我们的代码在容器内运行。
- en: 'Add a folder called `.vscode` to your project (please note the leading period
    in the name of the folder). Within this folder, add a file called `launch.json`
    with the following content:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中添加一个名为`.vscode`的文件夹（请注意文件夹名称前的点）。在这个文件夹内，添加一个名为`launch.json`的文件，内容如下：
- en: '![Figure 6.27 – The launch configuration to debug a Node.js application](img/B19199_06_27.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.27 – 调试 Node.js 应用的启动配置](img/B19199_06_27.jpg)'
- en: Figure 6.27 – The launch configuration to debug a Node.js application
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27 – 调试 Node.js 应用的启动配置
- en: To open the `launch.json` file, press *cmd* + *Shift* + *P* (or *Ctrl* + *Shift*
    + *P* on Windows) to open the command palette; look for `launch.json` file should
    open in the editor.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开`launch.json`文件，按 *cmd* + *Shift* + *P*（Windows 上为 *Ctrl* + *Shift* + *P*）打开命令面板；搜索
    `launch.json` 文件，应该会在编辑器中打开。
- en: 'Open the `index.js` file and click on the left sidebar on line 25 to set a
    breakpoint:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `index.js` 文件，然后点击左侧边栏第 25 行来设置一个断点：
- en: '![Figure 6.28 – Setting a breakpoint in our Node.js sample application](img/B19199_06_28.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.28 – 在我们的 Node.js 示例应用中设置断点](img/B19199_06_28.jpg)'
- en: Figure 6.28 – Setting a breakpoint in our Node.js sample application
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28 – 在我们的 Node.js 示例应用中设置断点
- en: Open the Debug view in VS Code by pressing *cmd* + *Shift* + *D* (or *Ctrl*
    + *Shift* + *D* on Windows).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *cmd* + *Shift* + *D*（Windows 上为 *Ctrl* + *Shift* + *D*）打开 VS Code 的调试视图。
- en: 'Make sure you select the correct launch task in the dropdown next to the green
    start button at the top of the view. Select `launch.json` file. It should look
    like this:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在视图顶部绿色启动按钮旁边的下拉菜单中选择了正确的启动任务。选择 `launch.json` 文件，应该如下所示：
- en: '![Figure 6.29 – Selecting the correct launch task to debug our Node.js application](img/B19199_06_29.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.29 – 选择正确的启动任务来调试我们的 Node.js 应用](img/B19199_06_29.jpg)'
- en: Figure 6.29 – Selecting the correct launch task to debug our Node.js application
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29 – 选择正确的启动任务来调试我们的 Node.js 应用
- en: Next, click on the green start button to attach VS Code to the Node.js application
    running in the container.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击绿色的启动按钮，将 VS Code 附加到容器内运行的 Node.js 应用。
- en: 'In another terminal window, use `curl` to navigate to the `/``colors` endpoint:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用 `curl` 访问 `/colors` 端点：
- en: '[PRE73]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Observe that the code’s execution stops at the breakpoint:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 观察代码执行在断点处停止：
- en: '![Figure 6.30 – The code’s execution stops at the breakpoint](img/B19199_06_30.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.30 – 代码执行在断点处停止](img/B19199_06_30.jpg)'
- en: Figure 6.30 – The code’s execution stops at the breakpoint
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30 – 代码执行在断点处停止
- en: In the preceding screenshot, we can see a yellow bar, indicating that the code’s
    execution has stopped at the breakpoint. In the top-right corner, we have a toolbar
    that allows us to navigate through the code step by step. On the left-hand side,
    we can see the **VARIABLES**, **WATCH**, and **CALL STACK** windows, which we
    can use to observe the details of our running application. The fact that we are
    debugging the code running inside the container can be verified by the fact that,
    in the terminal windows where we started the container, we can see that the output
    debugger is attached, which was generated the moment we started debugging inside
    VS Code.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到一个黄色的条形，表示代码的执行已在断点处停止。在右上角，我们有一个工具栏，可以逐步导航代码。左侧则是 **VARIABLES**、**WATCH**
    和 **CALL STACK** 窗口，我们可以用它们来观察正在运行的应用的细节。我们正在调试容器内运行的代码这一事实，可以通过我们在启动容器的终端窗口中看到输出调试器已附加来验证，这是我们在
    VS Code 中启动调试的那一刻产生的。
- en: 'To stop the container, enter the following command in the terminal window:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止容器，可以在终端窗口中输入以下命令：
- en: '[PRE74]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we want to use `nodemon` for even more flexibility, then we have to change
    the `container run` command slightly:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想使用 `nodemon` 获得更多的灵活性，则需要稍微修改 `container run` 命令：
- en: '[PRE75]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Note how we use the start command, `nodemon --inspect=0.0.0.0 index.js`. This
    will have the benefit that, upon any code changes, the application running inside
    the container will restart automatically, as we learned earlier in this chapter.
    You should see the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们是如何使用启动命令 `nodemon --inspect=0.0.0.0 index.js` 的。这将带来一个好处：每当代码发生更改时，容器内运行的应用将会自动重启，正如我们在本章前面所学的那样。你应该看到如下内容：
- en: '![Figure 6.31 – Starting the Node.js application with nodemon and debugging
    turned on](img/B19199_06_31.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.31 – 使用 nodemon 启动 Node.js 应用并开启调试](img/B19199_06_31.jpg)'
- en: Figure 6.31 – Starting the Node.js application with nodemon and debugging turned
    on
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31 – 使用 nodemon 启动 Node.js 应用程序并打开调试功能
- en: 'Unfortunately, the consequence of an application restart is that the debugger
    loses its connection with VS Code. But don’t worry – we can mitigate this by adding
    `"restart": true` to our launch task in the `launch.json` file. Modify the task
    so that it looks like this:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '不幸的是，应用程序重启的结果是调试器与 VS Code 失去连接。但别担心——我们可以通过在`launch.json`文件中的启动任务中添加`"restart":
    true`来减轻这个问题。修改任务，使其如下所示：'
- en: '[PRE76]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: After saving your changes, start the debugger in VS Code by clicking the green
    start button in the debug window. In the terminal, you should see that the debugger
    is attached, with a message as the output. In addition to that, VS Code will have
    an orange status bar at the bottom, indicating that the editor is in debug mode.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后，通过点击调试窗口中的绿色启动按钮启动 VS Code 中的调试器。在终端中，你应该能看到调试器已附加，并显示一条消息作为输出。除此之外，VS
    Code 会在底部显示一个橙色状态栏，表示编辑器处于调试模式。
- en: In a different terminal window, use `curl` and try to navigate to `localhost:3000/colors`
    to test that your line-by-line debugging still works. Make sure the code execution
    stops at any breakpoint you have set in the code.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用`curl`并尝试导航到`localhost:3000/colors`，以测试逐行调试是否仍然有效。确保代码执行在你设置的任何断点处停下来。
- en: 'Once you have verified that debugging still works, try to modify some code;
    for example, change the array of returned colors and add yet another color. Save
    your changes. Observe how `nodemon` restarts the application and that the debugger
    is automatically re-attached to the application running inside the container:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你验证调试仍然有效，尝试修改一些代码；例如，修改返回颜色的数组并添加另一个颜色。保存你的更改。观察`nodemon`如何重启应用程序，并且调试器自动重新附加到容器内运行的应用程序：
- en: '![Figure 6.32 – nodemon restarting the application and the debugger automatically
    re-attaching to the application](img/B19199_06_32.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.32 – nodemon 重启应用程序并且调试器自动重新附加到应用程序](img/B19199_06_32.jpg)'
- en: Figure 6.32 – nodemon restarting the application and the debugger automatically
    re-attaching to the application
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32 – nodemon 重启应用程序并且调试器自动重新附加到应用程序
- en: With that, we have everything assembled and can now work with code running inside
    a container as if the same code were running natively on the host. We have removed
    pretty much all of the friction that containers brought into the development process.
    We can now just enjoy the benefits of deploying our code in containers.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成所有的设置，现在可以像在宿主机上运行代码一样，在容器内运行的代码进行操作。我们几乎去除了容器给开发过程带来的所有摩擦。现在我们可以尽情享受将代码部署到容器中的好处。
- en: To clean up, stop the container by pressing *Ctrl* + *C* within the terminal
    window from where you started it.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理时，在你启动容器的终端窗口中按下*Ctrl* + *C*以停止容器。
- en: Now that you’ve learned how to debug a Node.js application running in a container
    line by line, let’s learn how to do the same for a .NET application.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何逐行调试运行在容器中的 Node.js 应用程序，让我们学习如何对 .NET 应用程序做同样的操作。
- en: Debugging a .NET application
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 .NET 应用程序
- en: 'In this section, we want to give you a quick run-through of how to debug a
    .NET application line by line. We will use the sample .NET application that we
    created earlier in this chapter:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将快速演示如何逐行调试一个 .NET 应用程序。我们将使用本章前面创建的示例 .NET 应用程序：
- en: 'Navigate to the project folder and open VS Code from within it:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目文件夹并从其中打开 VS Code：
- en: '[PRE77]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, open VS Code with the following command:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过以下命令打开 VS Code：
- en: '[PRE78]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To work with the debugger, we can fully rely on the help of VS Code commands.
    Hit *cmd* + *Shift* + *P* (*Shift* + *Ctrl* + *P* on Windows) to open the command
    palette.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用调试器，我们可以完全依赖 VS Code 命令的帮助。按*cmd* + *Shift* + *P*（Windows 上是*Shift* + *Ctrl*
    + *P*）来打开命令面板。
- en: 'Search for `Docker: Add Docker Files to Workspace` and select it:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '搜索`Docker: 将 Docker 文件添加到工作区`并选择它：'
- en: Select `5000`.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`5000`。
- en: Once you have entered all the required information, a `Dockerfile` and a `.dockerignore`
    file will be added to the project. Take a moment to explore both. Notice that
    this `Dockerfile` is defined as a multistage build.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了所有必需的信息，`Dockerfile` 和 `.dockerignore` 文件将被添加到项目中。花点时间查看这两个文件。注意，这个`Dockerfile`是定义为多阶段构建的。
- en: The previous command also added the `launch.json` and `tasks.json` files to
    a new `.vscode` folder in the project. These will be used by VS Code to help it
    define what to do when we ask it to debug our sample application.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令还将`launch.json`和`tasks.json`文件添加到项目中新创建的`.vscode`文件夹中。这些文件将由VS Code使用，帮助它定义在我们要求其调试示例应用程序时应该执行的操作。
- en: Let’s put a breakpoint in the first `GET` request of the `WeatherForecastController.cs`
    file.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`WeatherForecastController.cs`文件的第一个`GET`请求处设置一个断点。
- en: Locate the `.vscode/launch.json` file in the project and open it.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到项目中的`.vscode/launch.json`文件并打开它。
- en: 'Locate the Docker .NET Core Launch debug configuration and add the snippet
    marked with the red rectangle to it:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到Docker .NET Core启动调试配置，并将红色矩形框标记的代码片段添加到其中：
- en: '![Figure 6.33 – Modifying the Docker Launch configuration](img/B19199_06_33.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.33 – 修改Docker启动配置](img/B19199_06_33.jpg)'
- en: Figure 6.33 – Modifying the Docker Launch configuration
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 – 修改Docker启动配置
- en: The `dockerServerReadyAction` property in the `launch.json` file of a .NET project
    in VS Code is used to specify an action that should be taken when a Docker container
    is ready to accept requests.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch.json`文件中的`dockerServerReadyAction`属性用于指定在Docker容器准备好接受请求时应采取的操作。'
- en: 'Switch to the debug window of VS Code (use *Command* + *Shift* + *D* or *Ctrl*
    + *Shift* + *D* on Linux or Windows to open it, respectively). Make sure you have
    selected the correct debug launch task – its name is Docker .NET Core Launch:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到VS Code的调试窗口（在Linux或Windows上分别使用*Command* + *Shift* + *D*或*Ctrl* + *Shift*
    + *D*打开）。确保已选择正确的调试启动任务——它的名称是Docker .NET Core Launch：
- en: '![Figure 6.34 – Selecting the correct debug launch task in VS Code](img/B19199_06_34.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.34 – 在VS Code中选择正确的调试启动任务](img/B19199_06_34.jpg)'
- en: Figure 6.34 – Selecting the correct debug launch task in VS Code
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34 – 在VS Code中选择正确的调试启动任务
- en: 'Now, click the green start button to start the debugger. VS Code will build
    the Docker images, run a container of them, and configure the container for debugging.
    The output will be shown in the terminal window of VS Code. A browser window will
    open and navigate to [http://localhost:5000/wetherforecast](http://localhost:5000/wetherforecast)
    since this is what we defined in the launch configuration (*step 6*). At the same
    time, the breakpoint in the application controller is hit, as shown here:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击绿色的启动按钮以启动调试器。VS Code将构建Docker镜像，运行容器，并配置容器进行调试。输出将在VS Code的终端窗口中显示。浏览器窗口将打开并导航到[http://localhost:5000/wetherforecast](http://localhost:5000/wetherforecast)，因为这是我们在启动配置中定义的内容（*第6步*）。与此同时，应用程序控制器中的断点被触发，如下所示：
- en: '![Figure 6.35 – Debugging a .NET Core application running inside a container
    line by line](img/B19199_06_35.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.35 – 逐行调试在容器中运行的.NET Core应用程序](img/B19199_06_35.jpg)'
- en: Figure 6.35 – Debugging a .NET Core application running inside a container line
    by line
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35 – 逐行调试在容器中运行的.NET Core应用程序
- en: We can now step through the code, define watches, or analyze the call stack
    of the application, similar to what we did with the sample Node.js application.
    Hit the **Continue** button on the debug toolbar or press *F5* to continue executing
    the code.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以逐步执行代码、定义观察点或分析应用程序的调用栈，类似于我们在示例Node.js应用程序中所做的那样。点击调试工具栏上的**继续**按钮，或按*F5*继续执行代码。
- en: To stop the application, click the red stop button in the debugging toolbar,
    which is visible in the top-right corner of the preceding screenshot.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止应用程序，点击调试工具栏中的红色停止按钮，该按钮位于前述截图的右上角。
- en: Now that we know how to debug code running in a container line by line, it is
    time to instrument our code so that it produces meaningful logging information.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何逐行调试在容器中运行的代码，是时候为我们的代码加入日志记录功能，以便它能够生成有意义的日志信息。
- en: Instrumenting your code to produce meaningful logging information
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为代码加入日志记录功能以生成有意义的日志信息
- en: Once an application is running in production, it is impossible or strongly discouraged
    to interactively debug the application. Thus, we need to come up with other ways
    to find the root cause when the system is behaving unexpectedly or causing errors.
    The best way is to have the application generate detailed logging information
    that can then be used by the developers that need to track down any errors. Since
    logging is such a common task, all relevant programming languages or frameworks
    offer libraries that make the task of producing logging information inside an
    application straightforward.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序在生产环境中运行，交互式调试应用程序几乎是不可能的，或者强烈不建议这样做。因此，当系统表现异常或出现错误时，我们需要找到其他方法来查找根本原因。最好的方法是让应用程序生成详细的日志信息，开发人员可以使用这些信息来追踪错误。由于日志记录是一个常见的任务，所有相关的编程语言或框架都提供了使得在应用程序中生成日志信息的库，从而使得这一任务变得简单。
- en: 'It is common to categorize the information that’s output by an application
    as logs into so-called severity levels. Here is a list of those severity levels
    with a short description of each:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序输出的信息按日志的严重性级别进行分类是常见的做法。以下是这些严重性级别的列表，并附有每个级别的简短描述：
- en: '| **Log Level** | **Description** |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| **日志级别** | **描述** |'
- en: '| TRACE | Very fine-grained information. At this level, you are looking at
    capturing every detail possible about your application’s behavior. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪 | 非常详细的信息。在这个级别，你会捕捉应用程序行为的每一个可能细节。 |'
- en: '| DEBUG | Relatively granular and mostly diagnostic information that helps
    you pin down potential problems if they occur. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 相对详细且主要用于诊断的信息，帮助你定位潜在的问题。 |'
- en: '| INFO | Normal application behavior or milestones, such as startup or shutdown
    information. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 正常的应用程序行为或里程碑，比如启动或关闭信息。 |'
- en: '| WARNING | The application might have encountered a problem, or you detected
    an unusual situation. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | 应用程序可能遇到问题，或者你检测到了一个异常情况。 |'
- en: '| ERROR | The application encountered a serious issue. This most probably represents
    the failure of an important application task. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 应用程序遇到了严重问题。这很可能表示某个重要的应用程序任务失败。 |'
- en: '| FATAL | The catastrophic failure of your application. The immediate shutdown
    of the application is advised. |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 致命 | 应用程序的灾难性故障。建议立即关闭应用程序。 |'
- en: Table 6.1 – A list of the severity levels used when generating logging information
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 生成日志信息时使用的严重性级别列表
- en: Logging libraries usually allow a developer to define different log sinks –
    that is, destinations for the logging information. Popular sinks are file sinks
    or a stream to the console. When working with containerized applications, it is
    strongly recommended that you always direct logging output to the console or `STDOUT`.
    Docker will then make this information available to you via the `docker container
    logs` command. Other log collectors, such as Logstash, Fluentd, Loki, and others,
    can also be used to scrape this information.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库通常允许开发人员定义不同的日志目的地 —— 即日志信息的去向。常见的目的地有文件目的地或控制台输出流。当处理容器化应用程序时，强烈建议你将日志输出始终定向到控制台或
    `STDOUT`。Docker 随后会通过 `docker container logs` 命令提供这些信息。其他日志收集器，如 Logstash、Fluentd、Loki
    等，也可以用来抓取这些信息。
- en: Instrumenting a Python application
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Python 应用程序添加日志功能
- en: 'Let’s try to instrument our existing Python sample application:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为现有的 Python 示例应用程序添加日志功能：
- en: 'First, in your terminal, navigate to the project folder and open VS Code:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，在你的终端中，导航到项目文件夹并打开 VS Code： '
- en: '[PRE79]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open VS Code with the following command:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令打开 VS Code：
- en: '[PRE80]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Open the `main.py` file and add the following code snippet to the top of it:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.py` 文件，并将以下代码片段添加到文件顶部：
- en: '![Figure 6.36 – Defining a logger for our Python sample application](img/B19199_06_36.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.36 – 为我们的 Python 示例应用程序定义一个日志记录器](img/B19199_06_36.jpg)'
- en: Figure 6.36 – Defining a logger for our Python sample application
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.36 – 为我们的 Python 示例应用程序定义一个日志记录器
- en: On line 1, we import the standard logging library. We then define a logger for
    our sample application on line 3\. On line 4, we define the filter for logging
    to be used. In this case, we set it to `WARN`. This means that all logging messages
    produced by the application with a severity equal to or higher than `WARN` will
    be output to the defined logging handlers or sinks, which is what we called them
    at the beginning of this section. In our case, only log messages with a log level
    of `WARN`, `ERROR`, or `FATAL` will be output.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 行，我们导入了标准的日志库。然后，在第 3 行，我们为我们的示例应用程序定义了一个日志记录器。在第 4 行，我们定义了用于日志记录的过滤器。在这个例子中，我们将其设置为
    `WARN`。这意味着应用程序产生的所有日志消息，其严重性级别等于或高于 `WARN` 的都会被输出到定义的日志处理器或接收器中，这就是我们在本节开头所说的。在我们的例子中，只有日志级别为
    `WARN`、`ERROR` 或 `FATAL` 的消息会被输出。
- en: On line 6, we create a logging sink or handler. In our case, it is `StreamHandler`,
    which outputs to `STDOUT`. Then, on line 8, we define how we want the logger to
    format the messages it outputs. Here, the format that we chose will output the
    time and date, the application (or logger) name, the log severity level, and finally,
    the actual message that we developers define in the code. On line 9, we add the
    formatter to the log handler, while on line 10, we add the handler to the logger.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 行，我们创建了一个日志处理器或接收器。在我们的例子中，它是 `StreamHandler`，输出到 `STDOUT`。然后，在第 8 行，我们定义了日志记录器输出消息的格式。这里，我们选择的格式会输出时间和日期、应用程序（或日志记录器）名称、日志严重性级别，最后是我们开发者在代码中定义的实际消息。在第
    9 行，我们将格式化器添加到日志处理器，而在第 10 行，我们将处理器添加到日志记录器。
- en: Note
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can define more than one handler per logger.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个日志记录器定义多个处理程序。
- en: Now, we are ready to use the logger.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用日志记录器了。
- en: 'Let’s instrument the `hello` function, which is called when we navigate to
    the `/` endpoint:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们工具化 `hello` 函数，该函数在我们导航到 `/` 端点时被调用：
- en: '![Figure 6.37 – Instrumenting a method with logging](img/B19199_06_37.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.37 – 使用日志记录工具化一个方法](img/B19199_06_37.jpg)'
- en: Figure 6.37 – Instrumenting a method with logging
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.37 – 使用日志记录工具化一个方法
- en: As shown in the preceding screenshot, we added line 3 to the preceding snippet,
    where we used the `logger` object to produce a logging message with the `INFO`
    log level. The message is `"Accessing` `endpoint '/'"`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示的截图中，我们在前面的代码段中添加了第 3 行，使用 `logger` 对象生成了一个 `INFO` 级别的日志消息。消息是 `"访问` `端点
    '/'`"。
- en: 'Let’s instrument another function and output a message with the `WARN` log
    level:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们工具化另一个函数并输出一条 `WARN` 级别的消息：
- en: '![Figure 6.38 – Generating a warning](img/B19199_06_38.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.38 – 生成一个警告](img/B19199_06_38.jpg)'
- en: Figure 6.38 – Generating a warning
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.38 – 生成一个警告
- en: This time, we produced a message with the `WARN` log level on line 3 in the
    `colors` function. So far, so good – that wasn’t hard!
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们在 `colors` 函数的第 3 行生成了一条 `WARN` 级别的日志消息。到目前为止，一切顺利——这并不难！
- en: 'Now, let’s run the application and see what output we get:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序并查看我们得到的输出：
- en: '[PRE81]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, in your browser, navigate to `localhost:5000/` first and then to `localhost:5000/colors`.
    You should see an output like this:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在浏览器中，首先导航到 `localhost:5000/`，然后导航到 `localhost:5000/colors`。你应该看到类似以下的输出：
- en: '![Figure 6.39 – Running the instrumented sample Python application](img/B19199_06_39.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.39 – 运行已工具化的示例 Python 应用程序](img/B19199_06_39.jpg)'
- en: Figure 6.39 – Running the instrumented sample Python application
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.39 – 运行已工具化的示例 Python 应用程序
- en: As you can see, only the warning is output to the console; the `INFO` message
    is not. This is due to the filter we set when defining the logger. Also, note
    how our logging message is formatted with the date and time at the beginning,
    then the name of the logger, the log level, and finally, the message that was
    defined on line 3 of the snippet shown in *Figure 6**.39*.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有警告消息被输出到控制台；`INFO` 消息没有显示。这是由于我们在定义日志记录器时设置的过滤器。此外，注意我们的日志消息是如何格式化的，开头包含日期和时间，然后是日志记录器的名称、日志级别，最后是第
    3 行中定义的消息，如 *图 6.39* 中所示。
- en: When you’re done, stop the application by pressing *Ctrl* + *C*.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，按 *Ctrl* + *C* 停止应用程序。
- en: Now that we’ve learned how to instrument a Python application, let’s learn how
    to do the same for .NET.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何对 Python 应用程序进行工具化，接下来让我们学习如何对 .NET 做同样的事情。
- en: Instrumenting a .NET C# application
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 .NET C# 应用程序进行工具化
- en: 'Let’s instrument our sample C# application:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对示例 C# 应用程序进行工具化：
- en: 'First, navigate to the project folder, from where you’ll open VS Code:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到项目文件夹，从这里打开 VS Code：
- en: '[PRE82]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Open VS Code with the following command:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令打开 VS Code：
- en: '[PRE83]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we need to add a NuGet package containing the logging library to the
    project:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将包含日志库的NuGet包添加到项目中：
- en: '[PRE84]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This should add the following line to your `dotnet.csproj` project file:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将以下行添加到你的`dotnet.csproj`项目文件中：
- en: '[PRE85]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Open the `Program.cs` class and notice that we have the following statement
    on line 1:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`类，并注意到我们在第1行有以下语句：
- en: '[PRE86]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This method call, by default, adds a few logging providers to the application,
    among which is the console logging provider. This comes in very handy and frees
    us from having to do any complicated configuration first. You can, of course,
    override the default setting at any time with your own settings.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此方法调用会向应用程序添加几个日志提供程序，其中包括控制台日志提供程序。这非常方便，并且使我们不必进行任何复杂的配置。你当然可以随时使用自己的设置覆盖默认设置。
- en: 'Next, open the `WeatherForecastController.cs` file in the `Controllers` folder
    and add the following:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`Controllers`文件夹中的`WeatherForecastController.cs`文件，并添加以下内容：
- en: Add an instance variable, `logger`, of the `ILogger` type.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为`ILogger`的实例变量`logger`。
- en: 'Add a constructor that has a parameter of the `ILogger< WeatherForecastController
    >` type. Assign this parameter to the `logger` instance variable:'
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数，具有`ILogger<WeatherForecastController>`类型的参数。将此参数分配给`logger`实例变量：
- en: '![Figure 6.40 – Defining a logger for the Web API controller](img/B19199_06_40.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图6.40 – 为Web API控制器定义日志记录器](img/B19199_06_40.jpg)'
- en: Figure 6.40 – Defining a logger for the Web API controller
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.40 – 为Web API控制器定义日志记录器
- en: 'Now, we’re ready to use the logger in the controller methods. Let’s instrument
    the `Get` method with an *info* message (line 4 in the following code):'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在控制器方法中使用日志记录器。让我们在`Get`方法中添加一个*info*消息（如下代码中的第4行）：
- en: '![Figure 6.41 – Logging an INFO message from the API controller](img/B19199_06_41.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![图6.41 – 从API控制器记录INFO消息](img/B19199_06_41.jpg)'
- en: Figure 6.41 – Logging an INFO message from the API controller
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.41 – 从API控制器记录INFO消息
- en: 'Now, let’s add a method that implements a `/warning` endpoint right after the
    `Get` method and instrument it (line 4 here):'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`Get`方法后添加一个实现`/warning`端点的方法，并进行日志记录（此处为第4行）：
- en: '![Figure 6.42 – Logging messages with the WARN log level](img/B19199_06_42.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![图6.42 – 使用WARN日志级别记录消息](img/B19199_06_42.jpg)'
- en: Figure 6.42 – Logging messages with the WARN log level
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.42 – 使用WARN日志级别记录消息
- en: 'Let’s run the application by using the following command:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用以下命令运行应用程序：
- en: '[PRE87]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We should see the following output when in a new browser tab. To do so, we
    must navigate to `localhost:3000/weatherforecast` and then `localhost:3000/warning`:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的浏览器标签页中，我们应该看到以下输出。为此，我们必须导航到`localhost:3000/weatherforecast`，然后是`localhost:3000/warning`：
- en: '![Figure 6.43 – The log output of our sample .NET application](img/B19199_06_43.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![图6.43 – 我们示例.NET应用程序的日志输出](img/B19199_06_43.jpg)'
- en: Figure 6.43 – The log output of our sample .NET application
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.43 – 我们示例.NET应用程序的日志输出
- en: We can see the output of our log message, which is of the `info` and `warn`
    types, marked by red arrows. All the other log items have been produced by the
    ASP.NET library. You can see that there is a lot of helpful information available
    if you need to debug the application.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到日志消息的输出，标有红色箭头，分别是`info`和`warn`类型。所有其他日志项均由ASP.NET库生成。如果需要调试应用程序，您可以看到有很多有用的信息。
- en: When you’re done, end the application with *Ctrl* + *C*.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，按*Ctrl* + *C*结束应用程序。
- en: Now that we have learned how to instrument code to simplify how we can find
    the root cause of an issue when running in production, next, we will look at how
    we can instrument a distributed application using the Open Tracing standard for
    distributed tracing and then use Jaeger as a tool.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学习了如何为代码添加日志记录，简化了在生产环境中查找问题根源的方式，接下来，我们将了解如何使用Open Tracing标准进行分布式追踪，并使用Jaeger作为工具来监控分布式应用程序。
- en: Using Jaeger to monitor and troubleshoot
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jaeger进行监控和故障排除
- en: When we want to monitor and troubleshoot transactions in a complex distributed
    system, we need something a bit more powerful than what we have just learned.
    Of course, we can and should continue to instrument our code with meaningful logging
    messages, yet we need something more on top of that. This *more* is the capability
    to trace a single request or transaction end to end, as it flows through a system
    consisting of many application services. Ideally, we also want to capture other
    interesting metrics, such as the time spent on each component versus the total
    time that the request took.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在复杂的分布式系统中监控和故障排除事务时，我们需要比刚刚学到的东西更强大的工具。当然，我们可以并且应该继续通过有意义的日志消息来插桩我们的代码，但我们需要在此基础上再加上更多的功能。这个*更多*就是能够端到端地跟踪单个请求或事务，它穿越了由多个应用服务组成的系统。理想情况下，我们还希望捕获其他有趣的指标，例如每个组件花费的时间与请求总时长的对比。
- en: Luckily, we do not have to reinvent the wheel. There is battle-tested open source
    software out there that helps us achieve the aforementioned goals. One example
    of such an infrastructure component or softwa[re is Jaeger (https:/](http://www.jaegertracing.io/)
    www.jaegertracing.io/). When using Jaeger, you run a central Jaeger server component
    and each application component uses a Jaeger client that will forward debug and
    tracing information transparently to the Jaeger server component. There are Jaeger
    clients for all major programming languages and frameworks, such as Node.js, Python,
    Java, and .NET.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必从头开始发明轮子。有许多经过实战检验的开源软件帮助我们实现上述目标。一个这样的基础设施组件或软件的例子是Jaeger（[https://www.jaegertracing.io/](http://www.jaegertracing.io/)）。使用Jaeger时，您运行一个中央Jaeger服务器组件，每个应用组件使用一个Jaeger客户端，将调试和跟踪信息透明地转发到Jaeger服务器组件。Jaeger为所有主要编程语言和框架提供了客户端，例如Node.js、Python、Java和.NET。
- en: 'We will not go into all the intimate details of how to use Jaeger in this book,
    but we will provide a high-level overview of how it works conceptually:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中不会详细讨论如何使用Jaeger的所有细节，但我们会提供一个概念上的高级概述：
- en: First, we must define a Jaeger tracer object. This object coordinates the whole
    process of tracing a request through our distributed application. We can use this
    tracer object and also create a logger object from it, which our application code
    can use to generate log items, similar to what we did in the previous Python and
    .NET examples.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义一个Jaeger跟踪器对象。这个对象协调了在我们分布式应用中跟踪请求的整个过程。我们可以使用这个跟踪器对象，并从中创建一个logger对象，应用代码可以使用它来生成日志项，类似于我们在之前的Python和.NET示例中所做的。
- en: Next, we must wrap each method in the code that we want to trace with what Jaeger
    calls a span. This span has a name and provides us with a scope object.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用Jaeger所称的span来包装每个我们希望跟踪的代码方法。这个span有一个名称，并为我们提供了一个作用域对象。
- en: 'Let’s look at some C# pseudocode that illustrates this:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一些C#伪代码来说明这一点：
- en: '![Figure 6.44 – Defining a span in Jaeger – pseudocode](img/B19199_06_44.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![图6.44 – 在Jaeger中定义一个span – 伪代码](img/B19199_06_44.jpg)'
- en: Figure 6.44 – Defining a span in Jaeger – pseudocode
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.44 – 在Jaeger中定义一个span – 伪代码
- en: As you can see, we’re instrumenting the `SayHello` method. With a `using` statement
    creating a span, we’re wrapping the whole application code of this method. We
    have called the span `sayhello`; this will be the ID with which we can identify
    the method in the trace log produced by Jaeger.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在对`SayHello`方法进行插桩。通过`using`语句创建一个span，我们将整个应用代码包装在这个方法中。我们将这个span命名为`sayhello`；这将是我们在Jaeger生成的跟踪日志中识别该方法的ID。
- en: Note that the method calls another nested method, `FormatString`. This method
    will look quite similar to the code needed to instrument it.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该方法调用了另一个嵌套方法`FormatString`。这个方法与所需的插桩代码非常相似。
- en: 'The span that our tracer object builds in this method will be a child span
    of the calling method. This child span is called `format-string`. Also, note that
    we are using the logger object in the preceding method to explicitly generate
    a log item of the `INFO` log level:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的跟踪器对象在该方法中构建的span将是调用方法的子span。这个子span被称为`format-string`。另外，请注意，在前面的代码中我们使用了logger对象，显式地生成了一个`INFO`日志级别的日志项：
- en: '![Figure 6.45 – Creating a child span in Jaeger – pseudocode](img/B19199_06_45.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![图6.45 – 在Jaeger中创建子span – 伪代码](img/B19199_06_45.jpg)'
- en: Figure 6.45 – Creating a child span in Jaeger – pseudocode
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.45 – 在Jaeger中创建子span – 伪代码
- en: 'In the code included with this chapter, you can find a complete sample application
    written in Java and Spring Boot consisting of a Jaeger server container and two
    application containers called `api` and `inventory` that use the Jaeger client
    library to instrument the code. Follow these steps to rebuild this solution:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章提供的代码中，你可以找到一个完整的Java和Spring Boot应用程序示例，其中包含一个Jaeger服务器容器和两个名为`api`和`inventory`的应用容器，它们使用Jaeger客户端库来对代码进行仪表化。按照以下步骤重建这个解决方案：
- en: Navigate to the [`api`, as follows:](https://start.spring.io)
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[`api`，如下所示：](https://start.spring.io)
- en: '[](https://start.spring.io)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://start.spring.io)'
- en: '[![Figure 6.46 – Bootstrapping the API component of the Jaeger sample](img/B19199_06_46.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[![图 6.46 – 引导Jaeger示例的API组件](img/B19199_06_46.jpg)'
- en: Figure 6.46 – Bootstrapping the API component of the Jaeger sample
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.46 – 引导Jaeger示例的API组件
- en: Note how we are using Spring Boot 2.7.7 for this example since, at the time
    of writing, the Jaeger and Open Tracing integration does not yet work with Spring
    Boot 3\. Also, note how we have added the Spring Web reference to the project.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这个示例中使用的是Spring Boot 2.7.7版本，因为在撰写时，Jaeger和Open Tracing集成尚未支持Spring Boot
    3。还要注意，我们已经将Spring Web引用添加到了项目中。
- en: Click `api.zip` will be downloaded to your computer.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`api.zip`，文件将被下载到你的计算机。
- en: Repeat the same steps but this time change the `inventory`. Then, click `inventory.zip`
    containing the bootstrap code will be downloaded to your computer.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复相同的步骤，但这次更改`inventory`。然后，点击`inventory.zip`，其中包含引导代码，文件将被下载到你的计算机。
- en: 'Navigate to the source folder for this chapter:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到本章的源代码文件夹：
- en: '[PRE88]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, create a subfolder called `jaeger-demo` in it:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在其中创建一个名为`jaeger-demo`的子文件夹：
- en: '[PRE89]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Extract the two ZIP files into the `jaeger-demo` folder. Make sure the subfolders
    are called `api` and `inventory`, respectively.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个ZIP文件解压到`jaeger-demo`文件夹中。确保子文件夹分别命名为`api`和`inventory`。
- en: 'Open VS Code from within this folder:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此文件夹中打开VS Code：
- en: '[PRE90]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, create a `docker-compose.yml` file in the root with this content:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在根目录创建一个`docker-compose.yml`文件，内容如下：
- en: '![Figure 6.47 – The Docker Compose file for the Jaeger demo](img/B19199_06_47.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.47 – Jaeger示例的Docker Compose文件](img/B19199_06_47.jpg)'
- en: Figure 6.47 – The Docker Compose file for the Jaeger demo](https://start.spring.io)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.47 – Jaeger示例的Docker Compose文件](https://start.spring.io)
- en: '[We will explain what a `docker-compose` file is in detail in](https://start.spring.io)
    [*Chapter 11*](B19199_11.xhtml#_idTextAnchor237), *Managing Containers with* *Docker
    Compose.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[我们将在](https://start.spring.io) [*第11章*](B19199_11.xhtml#_idTextAnchor237)中详细解释什么是`docker-compose`文件，*使用Docker
    Compose管理容器*。'
- en: 'Run Jaeger with this command:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Jaeger：
- en: '[PRE91]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In a new browser t[ab, navigate to the Ja](http://localhost:16686)eger UI at
    `http://localhost:16686`.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的浏览器标签中，导航到Jaeger UI，地址是`http://localhost:16686`。
- en: 'Locate the two `pom.xml` files for the `api` and `inventory` projects in your
    VS Code. Add the Jaeger integration component to each file by adding this snippet
    to their `dependencies` sections:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的VS Code中找到`api`和`inventory`项目的两个`pom.xml`文件。通过将以下代码片段添加到它们的`dependencies`部分，将Jaeger集成组件添加到每个文件：
- en: '![Figure 6.48 – Adding integration with Jaeger to the Java project(s)](img/B19199_06_48.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.48 – 将Jaeger集成添加到Java项目](img/B19199_06_48.jpg)'
- en: Figure 6.48 – Adding integration with Jaeger to the Java project(s)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.48 – 将Jaeger集成添加到Java项目
- en: 'In the `inventory` project, locate the start class, `InventoryApplication`,
    and add a bean to it that generates an instance of `RestTemplate`. We will use
    this to access an external API to download some data. The code snippet should
    look like this:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inventory`项目中，找到启动类`InventoryApplication`，并为其添加一个生成`RestTemplate`实例的bean。我们将使用它来访问外部API下载一些数据。代码片段应该如下所示：
- en: '[PRE92]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Do the same for the start class of the `api` project, called `ApiApplication`.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api`项目的启动类`ApiApplication`中做相同的操作。
- en: 'Now, let’s go back to the `inventory` project. Add a new file called `Todo.java`
    as a sibling next to the start class. The file will have the following content:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到`inventory`项目。添加一个名为`Todo.java`的新文件，与启动类平级。文件内容如下：
- en: '![Figure 6.49 – The Todo class in the api project for the Jaeger demo](img/B19199_06_49.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.49 – Jaeger示例中的API项目中的Todo类](img/B19199_06_49.jpg)'
- en: Figure 6.49 – The Todo class in the api project for the Jaeger demo
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.49 – Jaeger示例中的API项目中的Todo类
- en: This is a really simple POJO class that we are using as a data container.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的POJO类，我们将其用作数据容器。
- en: Do the same in the `api` project.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api`项目中做相同的操作。
- en: 'Go to the `inventory` project and add a new file called `TodosController.java`
    with the following content:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`inventory`项目，添加一个名为`TodosController.java`的新文件，内容如下：
- en: '![Figure 6.50 – The TodosController class for the Jaeger demo](img/B19199_06_50.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.50 – Jaeger 演示的 TodosController 类](img/B19199_06_50.jpg)'
- en: Figure 6.50 – The TodosController class for the Jaeger demo
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.50 – Jaeger 演示的 TodosController 类
- en: Notice how, on line 19, we reach out to the public **JSONPlaceholder API** to
    download a list of todo items and return those items to the caller on line 20\.
    There’s nothing fancy here.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第 19 行，我们通过公共**JSONPlaceholder API**来下载待办事项列表，并在第 20 行将这些项目返回给调用者。这里没有什么特别的。
- en: 'For the `api` project, add a new file called `HelloController.java` with the
    following content:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`api`项目，添加一个名为`HelloController.java`的新文件，内容如下：
- en: '![Figure 6.51 – The HelloController class for the Jaeger demo](img/B19199_06_51.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.51 – Jaeger 演示的 HelloController 类](img/B19199_06_51.jpg)'
- en: Figure 6.51 – The HelloController class for the Jaeger demo
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.51 – Jaeger 演示的 HelloController 类
- en: Notice how the first method, which is listening on the `/hello` endpoint, just
    returns a string. However, the second endpoint, which is listening on the `/todos`
    endpoint, reaches out to the `api` service and its endpoint, `/api/todos`. The
    `api` service will send back the list of todos that it downloaded from the JSON
    Placeholder API. This way, we have a real distributed application ready to demonstrate
    the power of Jaeger and Open Tracing.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个方法监听`/hello`端点，它只是返回一个字符串。然而，第二个端点监听`/todos`端点，它连接到`api`服务及其端点`/api/todos`。`api`服务会返回它从
    JSON Placeholder API 下载的待办事项列表。这样，我们就有了一个真正的分布式应用程序，准备展示 Jaeger 和 Open Tracing
    的强大功能。
- en: 'We are not quite done yet. We need to configure both projects via their respective
    `applications.properties` files:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有完全完成。我们需要通过各自的`applications.properties`文件来配置这两个项目：
- en: 'Locate the `application.properties` file in the `api` project and add the following
    line to it:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api`项目中找到`application.properties`文件，并向其中添加以下行：
- en: '[PRE93]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The preceding code defines the name of the service and how Jaeger will report
    it.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了服务的名称以及 Jaeger 如何报告该服务。
- en: 'Locate the same file in the `inventory` project and add the following two lines
    to it:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inventory`项目中找到相同的文件，并向其中添加以下两行：
- en: '[PRE94]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The first line makes sure the inventory service is listening at port `8090`
    and not at the default port of `8080` to avoid any conflict with the `api` service,
    which will run on the default port.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行确保库存服务监听在端口`8090`，而不是默认的`8080`端口，以避免与将运行在默认端口的`api`服务发生冲突。
- en: The second line defines the name of the service and how Jaeger will report it.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行定义了服务的名称以及 Jaeger 如何报告该服务。
- en: Now, start the `inventory` and `api` projects from within VS Code by clicking
    the `main` methods of their respective start classes.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 VS Code 中点击各自启动类的`main`方法，启动`inventory`和`api`项目。
- en: Use `curl` or Thunder Client to access the expo[sed endpoint of the inventory
    s](http://localhost:8090/api/todos)ervice at `http://localhost:8090/api/todos`.
    You can also do the same in a new browser tab. You should receive a list of 100
    random todo items.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`或 Thunder Client 访问库存服务的[暴露端点](http://localhost:8090/api/todos)，地址为`http://localhost:8090/api/todos`。你也可以在新的浏览器标签页中执行相同操作。你应该会收到
    100 条随机待办事项列表。
- en: Ne[xt, try to access the `api` s](http://localhost:8080/api/todos)ervice at
    the `http://localhost:8080/todos` endpoint. The same list of todos should be returned,
    but this time, they should originate from the `api` service and not directly from
    the JSON Placeholder API.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试访问`api`服务的[该链接](http://localhost:8080/api/todos) ，它位于`http://localhost:8080/todos`端点。应返回相同的待办事项列表，但这次，它们应该来自`api`服务，而不是直接来自
    JSON Placeholder API。
- en: Now, go back to the browser tab where you opened the Jaeger UI.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到你打开 Jaeger UI 的浏览器标签页。
- en: Make sure you are on the **Search** tab.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在**搜索**标签页上。
- en: From the **Services** drop-down list, select **jaeger-demo:api**.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**服务**下拉列表中选择**jaeger-demo:api**。
- en: 'Click **Find Traces**. You should see something like this:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**查找跟踪**。你应该能看到类似这样的内容：
- en: '![Figure 6.52 – Jaeger trace for the api service](img/B19199_06_52.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.52 – api 服务的 Jaeger 跟踪](img/B19199_06_52.jpg)'
- en: Figure 6.52 – Jaeger trace for the api service
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.52 – api 服务的 Jaeger 跟踪
- en: 'Click on the trace to expand it. You should see this:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击跟踪以展开它。你应该会看到如下内容：
- en: '![Figure 6.53 – Details of the Jaeger trace for the api service](img/B19199_06_53.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.53 – api 服务的 Jaeger 跟踪详细信息](img/B19199_06_53.jpg)'
- en: Figure 6.53 – Details of the Jaeger trace for the api service
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.53 – api 服务的 Jaeger 跟踪详细信息
- en: Here, we can see how the call is reaching out from the `api` service to the
    `inventory` service. We can also see the time that’s been spent on each component.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `api` 服务如何调用 `inventory` 服务。我们还可以看到每个组件花费的时间。
- en: 'To clean up, stop the Jaeger server container:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理，停止 Jaeger 服务器容器：
- en: '[PRE95]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Also, stop the API with *Ctrl* + *C*.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，使用 *Ctrl* + *C* 停止 API。
- en: In this demo, we saw that without any special code, by just adding a component
    that integrates our Spring Boot applications with Jaeger and Open Tracing, we
    have gained a lot of insight. However, we’re only just scratching the surface
    of what is possible.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在本演示中，我们看到仅仅通过添加一个将我们的 Spring Boot 应用与 Jaeger 和 Open Tracing 集成的组件，无需任何特殊代码，我们便获得了大量的洞察。然而，我们只是刚刚触及可能性的表面。
- en: '`api` and `inventory` services using a similar `Dockerfile` for each, as we
    did in the Java demo application earlier in this chapter. The respective `Dockerfile`
    should be in the root of the `api` and `inventory` projects.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`api` 和 `inventory` 服务使用类似的 `Dockerfile`，正如我们在本章 Java 演示应用中所做的那样。各自的 `Dockerfile`
    应位于 `api` 和 `inventory` 项目的根目录中。'
- en: 'Then, amend the `docker-compose.yml` file. When you’re done, run the whole
    application with this command:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改 `docker-compose.yml` 文件。完成后，使用以下命令运行整个应用：
- en: '[PRE96]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Don’t worry if you’re not familiar with Docker Compose yet. We will discuss
    this very useful tool in [*Chapter 11*](B19199_11.xhtml#_idTextAnchor237),*Managing
    Containers with* *Docker Compose*.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉 Docker Compose，不用担心。我们将在 [*第 11 章*](B19199_11.xhtml#_idTextAnchor237)
    中详细讨论这个非常有用的工具，*使用 Docker Compose 管理容器*。
- en: Summary
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to run and debug Node.js, Python, Java, and
    .NET code running inside a container. We started by mounting the source code from
    the host into the container to avoid the container image being rebuilt each time
    the code changes. Then, we smoothed out the development process further by enabling
    automatic application restarts inside the container upon code changes. Next, we
    learned how to configure VS Code to enable full interactive code debugging when
    code is running inside a container.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，我们学习了如何在容器内运行和调试 Node.js、Python、Java 和 .NET 代码。我们从将源代码从主机挂载到容器开始，以避免每次代码更改时都重新构建容器镜像。接着，我们通过启用容器内的自动应用重启功能，使得代码更改后能够更顺畅地进行开发。然后，我们学习了如何配置
    VS Code，以便在容器内运行代码时启用完整的交互式代码调试。
- en: Finally, we learned how we can instrument our applications so that they generate
    logging information that can help us do root cause analysis on failures of misbehaving
    applications or application services running in production. We started by instrumenting
    our code using a logging library. Then, we used the Open Tracing standard for
    distributed tracing and the Jaeger tool to instrument a Java and Spring Boot application
    and gain valuable insight into the application’s inner workings.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何为我们的应用添加监控，以便它们生成日志信息，帮助我们对生产环境中表现异常的应用或应用服务进行根本原因分析。我们首先通过使用日志库对代码进行监控。接着，我们使用
    Open Tracing 标准进行分布式追踪，并使用 Jaeger 工具对 Java 和 Spring Boot 应用进行监控，从而获得应用内部运行的宝贵洞察。
- en: In the next chapter, we are going to show you how using Docker containers can
    supercharge your automation, from running a simple automation task in a container
    to using containers to build a CI/CD pipeline.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，我们将展示如何利用 Docker 容器提升自动化，从在容器中运行简单的自动化任务，到使用容器构建 CI/CD 管道。
- en: Questions
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try to answer the following questions to assess your learning progress:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答以下问题，以评估你的学习进度：
- en: Name two methods that help reduce the friction in the development process that’s
    introduced by using containers.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举两种通过使用容器来减少开发过程中的摩擦的方法。
- en: How can you achieve live code inside a container?
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在容器内实现实时代码？
- en: When and why would you debug code line by line when running inside a container?
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行时，何时以及为何要逐行调试代码？
- en: Why is instrumenting code with good debugging information paramount?
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么为代码添加良好的调试信息至关重要？
- en: Answers
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章节问题的答案：
- en: 'Possible answers:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能的答案：
- en: Volume-mount your source code in the container
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码挂载到容器中
- en: Use a tool that automatically restarts the app running inside the container
    when code changes are detected
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个工具，自动重启容器内运行的应用，当检测到代码更改时
- en: Configure your container for remote debugging
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置你的容器以进行远程调试
- en: You can mount the folder containing the source code on your host in the container.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将包含源代码的文件夹从主机挂载到容器中。
- en: If you cannot cover certain scenarios easily with unit or integration tests
    and if the observed behavior of the application cannot be reproduced when the
    application runs on the host. Another scenario is a situation where you cannot
    run the application on the host directly due to a lack of the necessary language
    or framework.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法通过单元测试或集成测试轻松覆盖某些场景，并且当应用程序在主机上运行时无法重现观察到的行为。另一种情况是由于缺少必要的语言或框架，无法直接在主机上运行应用程序。
- en: Once an application is running in production, we cannot easily gain access to
    it as developers. If the application shows unexpected behavior or even crashes,
    logs are often the only source of information we have to help us reproduce the
    situation and pinpoint the root cause of the bug.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序投入生产环境，我们作为开发者通常无法轻易访问它。如果应用程序出现意外行为甚至崩溃，日志通常是我们唯一的可用信息来源，帮助我们重现情况并找出bug的根本原因。
