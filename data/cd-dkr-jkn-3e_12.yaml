- en: '*Chapter 9*: Advanced Continuous Delivery'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：高级持续交付'
- en: In the previous chapters, we started with nothing and ended with a complete
    continuous delivery pipeline. Now, it's time to present a mixture of different
    aspects that are also very important in the continuous delivery process, but which
    haven't been described yet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们从零开始，最终构建了一个完整的持续交付流水线。现在，是时候介绍一些持续交付过程中同样非常重要，但尚未描述的不同方面了。
- en: 'This chapter covers the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Managing database changes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据库变更
- en: Pipeline patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线模式
- en: Release patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布模式
- en: Working with legacy systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与遗留系统的合作
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the instructions in this chapter, you''ll need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的指导，你需要以下内容：
- en: Java 8+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8+
- en: A Jenkins instance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Jenkins实例
- en: All the examples and solutions to the exercises can be found on GitHub at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter09).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例和练习解决方案可以在GitHub上的[https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter09)找到。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3NVVOyi](https://bit.ly/3NVVOyi).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的Code in Action视频可以在[https://bit.ly/3NVVOyi](https://bit.ly/3NVVOyi)查看。
- en: Managing database changes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据库变更
- en: 'So far, we have focused on a continuous delivery process that was applied to
    a web service. A simple factor in this was that web services are inherently stateless.
    This fact means that they can easily be updated, restarted, cloned in many instances,
    and recreated from the given source code. A web service, however, is usually linked
    to its stateful part: a database that poses new challenges to the delivery process.
    These challenges can be grouped into the following categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是应用于web服务的持续交付过程。其简单的因素之一是web服务本身就是无状态的。这一事实意味着它们可以轻松地更新、重启、克隆多个实例并从给定的源代码中重新创建。然而，web服务通常与其有状态部分（数据库）关联，而这给交付过程带来了新的挑战。这些挑战可以分为以下几类：
- en: '**Compatibility**: The database schema, and the data itself, must be compatible
    with the web service all the time.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：数据库模式及其数据本身必须始终与web服务兼容。'
- en: '**Zero-downtime deployment**: In order to achieve zero-downtime deployment,
    we use rolling updates, which means that a database must be compatible with two different web
    service versions at the same time.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机部署**：为了实现零停机部署，我们使用滚动更新，这意味着数据库必须同时兼容两个不同的web服务版本。'
- en: '**Rollback**: A rollback of a database can be difficult, limited, or sometimes
    even impossible because not all operations are reversible (for example, removing
    a column that contains data).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：数据库的回滚可能是困难的、有限的，甚至有时是不可能的，因为并非所有操作都是可逆的（例如，删除包含数据的列）。'
- en: '**Test data**: Database-related changes are difficult to test because we need
    test data that is very similar to production data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试数据**：与数据库相关的变更很难测试，因为我们需要与生产数据非常相似的测试数据。'
- en: In this section, I will explain how to address these challenges so that the
    continuous delivery process will be as safe as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释如何解决这些挑战，以便使持续交付过程尽可能安全。
- en: Understanding schema updates
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模式更新
- en: If you think about the delivery process, it's not really the data itself that
    causes difficulties, because we don't usually change the data when we deploy an
    application. The data is something that is collected while the system is live
    in production, whereas, during deployment, we only change the way we store and
    interpret this data. In other words, in the context of the continuous delivery
    process, we are interested in the structure of the database, not exactly in its
    content. This is why this section concerns mainly relational databases (and their
    schemas) and focuses less on other types of storage, such as NoSQL databases,
    where there is no structure definition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑交付过程，实际上并不是数据本身导致了困难，因为我们在部署应用时通常不会更改数据。数据是在系统上线运行时收集的，而在部署过程中，我们只是更改了存储和解释这些数据的方式。换句话说，在持续交付过程中，我们关注的是数据库的结构，而不是其内容。这也是为什么本节主要讨论关系型数据库（及其模式），而较少涉及其他类型的存储，如NoSQL数据库，因为后者没有结构定义。
- en: To better understand this, think of Hazelcast, which we have already used in
    this book. It stored the cached data so, effectively, it was a database. Nevertheless,
    it required zero effort from the continuous delivery perspective since it didn't
    have any data structure. All it stored were the key-value entries, which do not
    evolve over time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，可以考虑我们在本书中已经使用过的Hazelcast。它存储了缓存数据，因此，实际上它就是一个数据库。然而，从持续交付的角度来看，它不需要任何努力，因为它没有任何数据结构。它存储的只是键值对条目，这些条目不会随时间变化。
- en: Information
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: NoSQL databases usually don't have any restricting schema, and therefore, they
    simplify the continuous delivery process because there is no additional schema
    update step required. This is a huge benefit; however, it doesn't necessarily
    mean that writing applications with NoSQL databases is simpler because we have
    to put more effort into data validation in the source code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库通常没有任何限制性的模式，因此，它们简化了持续交付过程，因为不需要额外的模式更新步骤。这是一个巨大的好处；然而，这并不一定意味着使用NoSQL数据库编写应用程序更简单，因为我们必须在源代码中投入更多精力进行数据验证。
- en: Relational databases have static schemas. If we would like to change it (for
    example, to add a new column to the table), we need to write and execute a SQL **data
    definition language** (**DDL**) script. Doing this manually for every change requires
    a lot of work and leads to error-prone solutions in which the operations team
    has to keep the code and the database structure in sync. A much better solution
    is to automatically update the schema in an incremental manner. Such a solution
    is called **database migration**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库具有静态模式。如果我们想要更改它（例如，向表中添加一个新列），我们需要编写并执行一个SQL **数据定义语言** (**DDL**) 脚本。手动执行每个变更需要大量工作，并且容易出错，导致运维团队必须保持代码和数据库结构的同步。一个更好的解决方案是以增量方式自动更新模式。这样的解决方案称为
    **数据库迁移**。
- en: Introducing database migration
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍数据库迁移
- en: 'Database schema migration is a process of incremental changes to the relational
    database structure. Let''s take a look at the following diagram to understand
    it better:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式迁移是对关系型数据库结构进行增量变更的过程。让我们看看下面的图表，以便更好地理解：
- en: '![Figure 9.1 – Database schema migration'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 数据库模式迁移'
- en: '](img/B18223_09_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_01.jpg)'
- en: Figure 9.1 – Database schema migration
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 数据库模式迁移
- en: The database in version *v1* has the schema defined by the `V1_init.sql` file.
    Additionally, it stores the metadata related to the migration process, for example,
    its current schema version and the migration changelog. When we want to update
    the schema, we provide the changes in the form of a SQL file, such as `V2_add_table.sql`.
    Then, we need to run the migration tool that executes the given SQL file on the
    database (it also updates the metatables). In effect, the database schema is a
    result of all subsequently executed SQL migration scripts. Next, we will see an
    example of migration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 *v1* 中的数据库具有由 `V1_init.sql` 文件定义的模式。此外，它存储了与迁移过程相关的元数据，例如当前的模式版本和迁移变更日志。当我们想要更新模式时，我们提供以SQL文件形式的变更，例如
    `V2_add_table.sql`。然后，我们需要运行迁移工具，在数据库上执行给定的SQL文件（它还会更新元数据表）。实际上，数据库模式是所有随后的SQL迁移脚本执行的结果。接下来，我们将看到一个迁移的示例。
- en: Information
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Migration scripts should be stored in the version control system, usually in
    the same repository as the source code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移脚本应存储在版本控制系统中，通常与源代码存储在同一个代码库中。
- en: 'Migration tools and the strategies they use can be divided into two categories:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移工具及其使用的策略可以分为两类：
- en: '**Upgrade and downgrade**: This approach (as used by the Ruby on Rails framework,
    for example) means that we can migrate up (from *v1* to *v2*) and down (from *v2*
    to *v1*). It allows the database schema to roll back, which may sometimes end
    in data loss (if the migration is logically irreversible).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**升级和降级**：这种方法（例如Ruby on Rails框架中使用的方式）意味着我们可以向上迁移（从*v1*到*v2*）和向下迁移（从*v2*到*v1*）。它允许数据库模式回滚，但有时这可能会导致数据丢失（如果迁移在逻辑上是不可逆的）。'
- en: '**Upgrade only**: This approach (as used by the Flyway tool, for example) only
    allows us to migrate up (from *v1* to *v2*). In many cases, the database updates
    are not reversible, for example, when removing a table from the database. Such
    a change cannot be rolled back, because even if we recreate the table, we have
    already lost all the data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅升级**：这种方法（例如Flyway工具中使用的方式）只允许我们向上迁移（从*v1*到*v2*）。在许多情况下，数据库更新是不可逆的，例如，当从数据库中删除一个表时。这样的变更无法回滚，因为即使我们重新创建该表，也已经丢失了所有数据。'
- en: There are many database migration tools available on the market, the most popular
    of which are **Flyway**, **Liquibase**, and **Rail Migrations** (from the Ruby on
    Rails framework). As a next step to understanding how such tools work, we will
    look at an example based on the Flyway tool.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多数据库迁移工具，其中最流行的是**Flyway**、**Liquibase**和**Rail Migrations**（来自 Ruby on
    Rails 框架）。作为理解这些工具如何工作的下一步，我们将基于 Flyway 工具查看一个示例。
- en: Information
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: There are also commercial solutions provided for the particular databases, for
    example, Redgate (for SQL Server) and Optim Database Administrator (for DB2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些商业解决方案提供给特定的数据库，例如 Redgate（针对 SQL Server）和 Optim Database Administrator（针对
    DB2）。
- en: Using Flyway
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Flyway
- en: 'Let''s use Flyway to create a database schema for the calculator web service.
    The database will store the history of all operations that were executed on the
    service: the first parameter, the second parameter, and the result.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Flyway 为计算器 Web 服务创建一个数据库模式。该数据库将存储所有在服务上执行过的操作历史：第一个参数，第二个参数，以及结果。
- en: 'We show how to use the SQL database and Flyway in three steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何通过三个步骤使用 SQL 数据库和 Flyway：
- en: Configuring the Flyway tool to work with Gradle
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Flyway 工具与 Gradle 一起使用
- en: Defining the SQL migration script to create the calculation history table
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 SQL 迁移脚本以创建计算历史表
- en: Using the SQL database inside the Spring Boot application code
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序代码中使用 SQL 数据库
- en: Let's get started.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Configuring Flyway
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置 Flyway
- en: 'In order to use Flyway with Gradle, we need to add the following content to
    the `build.gradle` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Gradle 中使用 Flyway，我们需要将以下内容添加到`build.gradle`文件中：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some quick comments on the configuration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于配置的一些简要说明：
- en: We used the H2 database, which is an in-memory (and file-based) database.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 H2 数据库，它是一个内存型（和基于文件的）数据库。
- en: We store the database in the `/tmp/calculator` file.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将数据库存储在`/tmp/calculator`文件中。
- en: The default database user is called `sa` (system administrator).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的数据库用户被称为`sa`（系统管理员）。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: In the case of other SQL databases (for example, MySQL), the configuration would
    be very similar. The only difference is in the Gradle dependencies and the JDBC
    connection.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于其他 SQL 数据库（例如 MySQL），配置将非常相似。唯一的区别在于 Gradle 依赖项和 JDBC 连接。
- en: 'After this configuration is applied, we should be able to run the Flyway tool
    by executing the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用此配置后，我们应该能够通过执行以下命令来运行 Flyway 工具：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command created the database in the `/tmp/calculator.mv.db` file. Obviously,
    it has no schema, since we haven't defined anything yet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在`/tmp/calculator.mv.db`文件中创建了数据库。显然，它没有任何模式，因为我们还没有定义任何内容。
- en: Information
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Flyway can be used as a command-line tool, via the Java API, or as a plugin
    for the popular building tools Gradle, Maven, and Ant.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway 可以作为命令行工具、通过 Java API 或作为流行构建工具 Gradle、Maven 和 Ant 的插件来使用。
- en: Defining the SQL migration script
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 SQL 迁移脚本
- en: 'The next step is to define the SQL file that adds the calculation table to
    the database schema. Let''s create the `src/main/resources/db/migration/V1__Create_calculation_table.sql` file,
    with the following content:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义 SQL 文件，添加计算表到数据库模式中。让我们创建`src/main/resources/db/migration/V1__Create_calculation_table.sql`文件，内容如下：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the migration file naming convention, `<version>__<change_description>.sql`.
    The SQL file creates a table with four columns, `ID`, `A`, `B`, and `RESULT`.
    The `ID` column is an automatically incremented primary key of the table. Now,
    we are ready to run the `flyway` command to apply the migration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意迁移文件的命名规则，`<version>__<change_description>.sql`。该 SQL 文件创建了一个包含四列的表，`ID`、`A`、`B`
    和 `RESULT`。`ID` 列是表的自动递增主键。现在，我们已经准备好运行`flyway`命令以应用迁移：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The command automatically detected the migration file and executed it on the
    database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令自动检测到迁移文件并在数据库上执行它。
- en: Information
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The migration files should be always kept in the version control system, usually
    with the source code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件应该始终保存在版本控制系统中，通常与源代码一起保存。
- en: Accessing the database
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问数据库
- en: We have executed our first migration, so the database is prepared. To see the
    complete example, we should also adapt our project so that it can access the database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经执行了第一次迁移，因此数据库已经准备好。要查看完整的示例，我们还应调整我们的项目，使其能够访问数据库。
- en: 'Let''s first configure the Gradle dependencies to use `h2database` from the
    Spring Boot project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们配置 Gradle 依赖项，以便使用 Spring Boot 项目中的`h2database`：
- en: 'We can do this by adding the following lines to the `build.gradle` file:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过向`build.gradle`文件中添加以下行来实现：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to set up the database location and the startup behavior in
    the `src/main/resources/application.properties` file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`src/main/resources/application.properties`文件中设置数据库位置和启动行为：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second line means that Spring Boot will not try to automatically generate
    the database schema from the source code model. On the contrary, it will only
    validate if the database schema is consistent with the Java model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行表示Spring Boot不会尝试从源代码模型自动生成数据库模式。相反，它只会验证数据库模式是否与Java模型一致。
- en: 'Now, let''s create the Java ORM entity model for the calculation in the new `src/main/java/com/leszko/calculator/Calculation.java` file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为新的`src/main/java/com/leszko/calculator/Calculation.java`文件创建Java ORM实体模型：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Entity` class represents the database mapping in the Java code. A table
    is expressed as a class, with each column as a field. The next step is to create
    the repository for loading and storing the `Calculation` entities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity`类表示Java代码中的数据库映射。一个表通过一个类来表达，每个列作为一个字段。下一步是为加载和存储`Calculation`实体创建仓库。'
- en: 'Let''s create the `src/main/java/com/leszko/calculator/CalculationRepository.java`
    file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`src/main/java/com/leszko/calculator/CalculationRepository.java`文件：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can use the `Calculation` and `CalculationRepository` classes to
    store the calculation history. Let''s add the following code to the `src/main/java/com/leszko/calculator/CalculatorController.java` file:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`Calculation`和`CalculationRepository`类来存储计算历史记录。让我们将以下代码添加到`src/main/java/com/leszko/calculator/CalculatorController.java`文件中：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can finally start the service, for example, using the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以最终启动服务，例如，使用以下命令：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we have started the service, we can send a request to the `/sum` endpoint.
    As a result, each summing operation is logged into the database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动服务后，可以向`/sum`端点发送请求。结果，每个加法操作都会被记录到数据库中。
- en: Tip
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you would like to browse the database content, you can add `spring.h2.console.enabled=true`
    to the `application.properties` file, and then browse the database via the `/h2-console` endpoint.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想浏览数据库内容，可以将`spring.h2.console.enabled=true`添加到`application.properties`文件中，然后通过`/h2-console`端点浏览数据库。
- en: We explained how the database schema migration works and how to use it inside
    a Spring Boot project built with Gradle. Now, let's take a look at how it integrates
    within the continuous delivery process.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了数据库模式迁移的工作原理以及如何在使用Gradle构建的Spring Boot项目中使用它。现在，让我们来看一下它是如何与持续交付过程集成的。
- en: Changing the database in continuous delivery
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在持续交付中更改数据库
- en: 'The first approach to use database updates inside the continuous delivery pipeline
    is to add a stage within the migration command execution. This simple solution
    works correctly for many cases; however, it has two significant drawbacks:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库更新在持续交付管道中的第一种方法是在线程执行过程中添加一个阶段。这个简单的解决方案在很多情况下都能正常工作；然而，它有两个显著的缺点：
- en: '**Rollback**: As mentioned before, it''s not always possible to roll back the
    database change (Flyway doesn''t support downgrades at all). Therefore, in the
    case of service rollback, the database becomes incompatible.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：如前所述，数据库更改并不总是可以回滚的（Flyway根本不支持降级）。因此，在服务回滚的情况下，数据库会变得不兼容。'
- en: '**Downtime**: The service update and the database update are not executed at
    exactly the same time, which causes downtime.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停机时间**：服务更新和数据库更新并不会同时执行，这会导致停机时间。'
- en: 'This leads us to two constraints that we will need to address:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们需要解决的两个约束：
- en: The database version needs to be compatible with the service version all the
    time.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库版本需要始终与服务版本兼容。
- en: The database schema migration is not reversible.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式迁移是不可逆的。
- en: 'We will address these constraints for two different cases: backward-compatible
    updates and non-backward-compatible updates.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理两种不同情况的约束：向后兼容的更新和非向后兼容的更新。
- en: Backward-compatible changes
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向后兼容的更改
- en: 'Backward-compatible changes are simpler. Let''s look at the following figure to
    see how they work:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容的更改较为简单。让我们通过以下图形来查看它们是如何工作的：
- en: '![Figure 9.2 – Backward-compatible database migration'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 向后兼容的数据库迁移'
- en: '](img/B18223_09_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_02.jpg)'
- en: Figure 9.2 – Backward-compatible database migration
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 向后兼容的数据库迁移
- en: Suppose that the **Database v10** schema migration is backward-compatible. If
    we need to roll back the **Service v1.2.8** release, then we deploy **Service
    v1.2.7**, and there is no need to do anything with the database (database migrations
    are not reversible, so we keep **Database v11**). Since the schema update is backward-compatible,
    **Service v.1.2.7** works perfectly fine with **Database v11**. The same applies
    if we need to roll back to **Service v1.2.6**, and so on. Now, suppose that **Database
    v10** and all other migrations are backward-compatible; then we could roll back
    to any service version, and everything would work correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 **数据库 v10** 的架构迁移是向后兼容的。如果我们需要回滚 **服务 v1.2.8** 的发布，那么我们部署 **服务 v1.2.7**，并且不需要对数据库做任何操作（数据库迁移不可逆，因此我们保持
    **数据库 v11**）。由于架构更新是向后兼容的，**服务 v1.2.7** 与 **数据库 v11** 完美兼容。如果我们需要回滚到 **服务 v1.2.6**，同样可以正常工作，依此类推。现在，假设
    **数据库 v10** 和所有其他迁移都是向后兼容的，那么我们可以回滚到任何服务版本，一切都能正常工作。
- en: There is also no problem with downtime. If the database migration has zero-downtime
    itself, then we can execute it first, and then use the rolling updates for the
    service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 停机时间也没有问题。如果数据库迁移本身没有停机时间，那么我们可以先执行它，然后再对服务使用滚动更新。
- en: 'Let''s look at an example of a backward-compatible change. We will create a
    schema update that adds a `created_at` column to the calculation table. The `src/main/resources/db/migration/V2__Add_created_at_column.sql` migration
    file looks as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个向后兼容变更的例子。我们将创建一个架构更新，向计算表添加一个 `created_at` 列。`src/main/resources/db/migration/V2__Add_created_at_column.sql`
    迁移文件如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Aside from the migration script, the calculator service requires a new field
    in the `Calculation` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迁移脚本外，计算器服务还需要在 `Calculation` 类中添加一个新字段：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to adjust its constructor, and then its usage in the `CalculatorController` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整其构造函数，然后调整它在 `CalculatorController` 类中的使用：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After running the service, the calculation history is stored with the `created_at` column.
    Note that the change is backward-compatible because, even if we reverted the Java
    code and left the `created_at` column in the database, everything would work perfectly
    fine (the reverted code does not address the new column at all).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务后，计算历史记录会存储在 `created_at` 列中。请注意，这个变更是向后兼容的，因为即使我们还原了 Java 代码并在数据库中保留了 `created_at`
    列，一切仍然可以正常工作（还原的代码根本不涉及新列）。
- en: Non-backward-compatible changes
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非向后兼容的变更
- en: Non-backward-compatible changes are way more difficult. Looking at the previous
    diagram, if the **v11** database change was backward-incompatible, it would be impossible to
    roll back the service to **1.2.7**. In this case, how can we approach non-backward-compatible
    database migrations so that rollbacks and zero-downtime deployments would be possible?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 非向后兼容的变更要困难得多。从之前的示意图来看，如果 **v11** 数据库的变更是向后不兼容的，那么就无法将服务回滚到 **1.2.7**。在这种情况下，我们该如何处理非向后兼容的数据库迁移，以便能够进行回滚并实现零停机部署呢？
- en: 'To cut a long story short, we can address this issue by converting a non-backward-compatible
    change into a change that is backward-compatible for a certain period of time.
    In other words, we need to put in the extra effort and split the schema migration
    into two parts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以通过将非向后兼容的变更转换为在一定时间内向后兼容的变更来解决这个问题。换句话说，我们需要额外付出努力，将架构迁移分为两个部分：
- en: Backward-compatible update executed now, which usually means keeping some redundant
    data
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前执行的向后兼容更新，通常意味着保留一些冗余数据
- en: Non-backward-compatible update executed after the rollback period time that
    defines how far back we can revert our code
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回滚期后执行非向后兼容的更新，定义我们可以回退代码的最大时间
- en: 'To better illustrate this, let''s look at the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这一点，我们来看下面的示意图：
- en: '![Figure 9.3 – Non-backward-compatible database migration'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 非向后兼容的数据库迁移'
- en: '](img/B18223_09_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_03.jpg)'
- en: Figure 9.3 – Non-backward-compatible database migration
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 非向后兼容的数据库迁移
- en: 'Let''s consider an example of dropping a column. A proposed method would include
    two steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑一个删除列的例子。一个建议的方法包括两个步骤：
- en: Stop using the column in the source code (**v1.2.5**, backward-compatible update,
    executed first).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止在源代码中使用该列 (**v1.2.5**，向后兼容更新，首先执行)。
- en: Drop the column from the database (**v11**, non-backward-compatible update,
    executed after the rollback period).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中删除该列 (**v11**，非向后兼容更新，回滚期后执行)。
- en: All service versions until **Database v11** can be rolled back to any previous
    version; the services starting from **Service v1.2.8** can only be rolled back
    within the rollback period. Such an approach may sound trivial because all we
    did was delay the column removal from the database. However, it addresses both
    the rollback issue and the zero-downtime deployment issue. As a result, it reduces
    the risk associated with the release. If we adjust the rollback period to a reasonable
    amount of time (for example, in the case of multiple releases per day to 2 weeks),
    then the risk is negligible. We don't usually roll many versions back.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有版本直到**数据库 v11**都可以回滚到任何之前的版本；从**服务 v1.2.8**开始的服务只能在回滚周期内回滚。这个方法可能听起来很简单，因为我们所做的只是延迟了从数据库中删除列的操作。然而，它解决了回滚问题和零停机时间部署问题。因此，它降低了发布过程中相关的风险。如果我们将回滚周期调整为合理的时间（例如，在一天内多次发布时调整为2周），那么风险几乎可以忽略不计。我们通常不会回滚很多版本。
- en: 'Dropping a column was a very simple example. Let''s take a look at a more difficult
    scenario and rename the result column in our calculator service. We show how to
    do this in a few steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 删除列是一个非常简单的例子。让我们来看一个更复杂的场景，重命名我们计算器服务中的结果列。我们展示了如何通过几个步骤来完成这项操作：
- en: Adding a new column to the database
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向数据库中添加新列
- en: Changing the code to use both columns
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改代码以使用两列数据
- en: Merging the data in both columns
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两列中的数据
- en: Removing the old column from the code
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码中删除旧列
- en: Dropping the old column from the database
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中删除旧列
- en: Let's look at these steps in detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些步骤。
- en: Adding a new column to the database
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向数据库中添加新列
- en: 'Let''s suppose that we need to rename the `result` column to `sum`. The first
    step is to add a new column that will be a duplicate. We must create a `src/main/resources/db/migration/V3__Add_sum_column.sql` migration
    file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将`result`列重命名为`sum`。第一步是添加一个新的列，它将是旧列的副本。我们需要创建一个迁移文件：`src/main/resources/db/migration/V3__Add_sum_column.sql`：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a result, after executing the migration, we will have two columns: `result` and `sum`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，在执行迁移后，我们将拥有两列：`result`和`sum`。
- en: Changing the code to use both columns
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改代码以使用两列数据
- en: 'The next step is to rename the column in the source code model and to use both
    database columns for the `set` and `get` operations. We can change it in the `Calculation` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在源代码模型中重命名列，并在`set`和`get`操作中使用两列数据。我们可以在`Calculation`类中进行更改：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To be 100% accurate, in the `getSum()` method, we should compare something like
    the last modification column date. (It's not exactly necessary to always take
    the new column first.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到100%的准确性，在`getSum()`方法中，我们应该比较类似于最后修改日期的列。（并不一定总是需要先使用新列。）
- en: From now on, every time we add a row into the database, the same value is written
    to both the `result` and `sum` columns. While reading `sum`, we first check whether
    it exists in the new column, and if not, we read it from the old column.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，每次向数据库中添加一行时，相同的值会写入`result`和`sum`两列。在读取`sum`时，我们首先检查它是否存在于新列中，如果没有，则从旧列中读取。
- en: Tip
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The same result can be achieved with the use of database triggers that would
    automatically write the same values into both columns.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用数据库触发器来实现相同的结果，触发器会自动将相同的值写入两列中。
- en: All the changes that we have made so far are backward-compatible, so we can
    roll back the service anytime we want, to any version we want.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有更改都是向后兼容的，因此我们可以随时将服务回滚到任何我们想要的版本。
- en: Merging the data in both columns
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并两列中的数据
- en: 'This step is usually done after some time when the release is stable. We need
    to copy the data from the old `result` column into the new `sum` column. Let''s
    create a migration file called `V4__Copy_result_into_sum_column.sql`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步通常在发布版本稳定后进行。我们需要将旧的`result`列中的数据复制到新的`sum`列。让我们创建一个迁移文件，命名为`V4__Copy_result_into_sum_column.sql`：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We still have no limits for the rollback; however, if we need to deploy the
    version before the change in *step 2*, then this database migration needs to be
    repeated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有回滚的限制；但是，如果我们需要部署变更前的版本（在*步骤2*之前），则需要重复执行此数据库迁移。
- en: Removing the old column from the code
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从代码中删除旧列
- en: 'At this point, we already have all data in the new column, so we can start
    to use it without the old column in the data model. In order to do this, we need
    to remove all code related to `result` in the `Calculation` class so that it would
    look as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经将所有数据迁移到新的列中，因此我们可以在数据模型中开始使用新列，而不再依赖旧列。为了做到这一点，我们需要删除与`result`相关的所有代码，这些代码在`Calculation`类中应如下所示：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this operation, we will no longer use the `result` column in the code.
    Note that this operation is only backward-compatible up to *step 2*. If we need
    to roll back to *step 1*, then we could lose the data stored after this step.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将不再在代码中使用`result`列。请注意，这一操作仅在*步骤2*之前向后兼容。如果我们需要回滚到*步骤1*，则可能会丢失此步骤后存储的数据。
- en: Dropping the old column from the database
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从数据库中删除旧的列
- en: The last step is to drop the old column from the database. This migration should
    be performed after the rollback period when we are sure we won't need to roll
    back before *step 4*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是从数据库中删除旧的列。此迁移操作应在回滚期后进行，当我们确认在*步骤4*之前不会需要回滚时。
- en: Information
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The rollback period can be very long since we aren't using the column from the
    database anymore. This task can be treated as a cleanup task, so even though it's
    non-backward-compatible, there is no associated risk.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚期可能非常长，因为我们不再使用数据库中的该列。这个任务可以视为清理任务，因此即使它不向后兼容，也没有相关的风险。
- en: 'Let''s add the final migration, `V5__Drop_result_column.sql`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加最终的迁移文件，`V5__Drop_result_column.sql`：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After this step, we will have finally completed the column renaming procedure.
    Note that the steps we took complicated the operation a little bit in order to
    stretch it in time. This reduced the risk of backward-incompatible database changes
    and allowed for zero-downtime deployments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们将最终完成列重命名过程。请注意，我们采取的步骤使得操作变得稍微复杂了一些，以便将其延长至更长时间。这减少了数据库不向后兼容更改的风险，并实现了零停机时间部署。
- en: Separating database updates from code changes
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数据库更新与代码更改分离
- en: 'So far, in all images, we showed that database migrations are run with service
    releases. In other words, each commit (which implies each release) took both database changes
    and code changes. However, the recommended approach is to make a clear separation
    that a commit to the repository is either a database update or a code change.
    This method is presented in the following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在所有图像中，我们展示了数据库迁移是与服务发布一起进行的。换句话说，每次提交（即每次发布）都包括数据库更改和代码更改。然而，推荐的做法是明确区分，提交到代码库的内容是数据库更新还是代码更改。这个方法在下图中展示：
- en: '![Figure 9.4 – Separating database updates and code changes'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 将数据库更新与代码更改分离'
- en: '](img/B18223_09_04.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_04.jpg)'
- en: Figure 9.4 – Separating database updates and code changes
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 将数据库更新与代码更改分离
- en: The benefit of database-service change separation is that we get the backward-compatibility
    check for free. Imagine that the **v11** and **v1.2.7** changes concern one logical
    change, for example, adding a new column to the database. Then, we first commit
    **Database v11**, so the tests in the continuous delivery pipeline check whether
    **Database v11** works correctly with **Service v.1.2.6**. In other words, they
    check whether the **Database v11** update is backward-compatible. Then, we commit
    the **v1.2.7** change, so the pipeline checks whether **Database v11** works with
    **Service v1.2.7**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库与服务更改分离的好处是我们能够免费进行向后兼容性检查。假设**v11**和**v1.2.7**的更改涉及一个逻辑更改，例如向数据库中添加一个新列。然后，我们首先提交**Database
    v11**，这样持续交付流水线中的测试就会检查**Database v11**是否与**Service v1.2.6**正确兼容。换句话说，它们检查**Database
    v11**更新是否向后兼容。然后，我们提交**v1.2.7**的更改，流水线会检查**Database v11**是否与**Service v1.2.7**兼容。
- en: Information
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The database-code separation does not mean that we must have two separate Jenkins
    pipelines. The pipeline can always execute both, but we should keep it as a good
    practice that a commit is either a database update or a code change.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库与代码的分离并不意味着我们必须有两个独立的 Jenkins 流水线。流水线可以始终执行两者，但我们应当将其视为一种良好的实践，确保每次提交要么是数据库更新，要么是代码更改。
- en: To sum up, the database schema changes should never be done manually. Instead,
    we should always automate them using a migration tool executed as a part of the
    continuous delivery pipeline. We should also avoid non-backward-compatible database
    updates, and the best way to ensure this is to commit the database and code changes
    into the repository separately.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，数据库模式的更改永远不应该手动进行。相反，我们应该始终通过迁移工具来自动化这些更改，并将其作为持续交付管道的一部分执行。我们还应避免进行不向后兼容的数据库更新，而确保这一点的最佳方法是将数据库和代码更改分别提交到仓库中。
- en: Avoiding a shared database
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免共享数据库
- en: In many systems, we can spot that the database becomes the central point that
    is shared between multiple services. In such a case, any update to the database
    becomes much more challenging, because we need to coordinate it between all services.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，我们可以发现数据库成为多个服务共享的**中心**点。在这种情况下，任何对数据库的更新都会变得更加具有挑战性，因为我们需要在所有服务之间进行协调。
- en: 'For example, imagine we are developing an online shop, and we have a `Customers` table
    that contains the following columns: `first name`, `last name`, `username`, `password`,
    `email`, and `discount`. There are three services that are interested in the customer''s
    data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在开发一个在线商店，并且我们有一个`Customers`表，其中包含以下列：`first name`、`last name`、`username`、`password`、`email`和`discount`。有三个服务对客户数据感兴趣：
- en: '**Profile manager**: This enables editing user''s data.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户资料管理器**：用于编辑用户数据。'
- en: '**Checkout processor**: This processes the checkout (reads username and email).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结账处理器**：处理结账过程（读取用户名和电子邮件）。'
- en: '**Discount manager**: This analyzes the customer''s orders and applies a suitable
    discount.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折扣管理器**：用于分析客户的订单并应用适当的折扣。'
- en: 'Let''s look at the following diagram that shows this situation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图示，展示了这种情况：
- en: '![Figure 9.5 – Shared database anti-pattern'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 共享数据库反模式'
- en: '](img/B18223_09_05.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_05.jpg)'
- en: Figure 9.5 – Shared database anti-pattern
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 共享数据库反模式
- en: 'The three services are dependent on the same database schema. There are at
    least two issues with such an approach:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个服务依赖于相同的数据库模式。这种方法至少有两个问题：
- en: When we want to update the schema, it must be compatible with all three services.
    While all backward-compatible changes are fine, any non-backward-compatible update
    becomes far more difficult, or even impossible.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要更新模式时，它必须与所有三个服务兼容。虽然所有向后兼容的更改都可以，但任何不向后兼容的更新将变得更加困难，甚至不可能实现。
- en: Each service has a separate delivery cycle and a separate continuous delivery
    pipeline. So, *which pipeline should we use for the database schema migrations?*
    Unfortunately, there is no good answer to this question.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都有单独的交付周期和独立的持续交付管道。那么，*我们应该使用哪个管道来进行数据库模式迁移？* 不幸的是，这个问题没有一个明确的答案。
- en: 'For the reasons mentioned previously, each service should have its own database
    and the services should communicate via their APIs. Using our example, we could
    apply the following refactoring:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面提到的原因，每个服务应该拥有自己的数据库，服务之间应该通过其API进行通信。以我们的示例为例，我们可以应用以下重构：
- en: The checkout processor should communicate with the profile manager's API to
    fetch the customer's data.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结账处理器应该通过调用用户资料管理器的API来获取客户数据。
- en: The discount column should be extracted to a separate database (or schema),
    and the discount manager should take ownership.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折扣列应该提取到一个单独的数据库（或模式），并且折扣管理器应该负责管理。
- en: 'The refactored version is presented in the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的版本如下图所示：
- en: '![Figure 9.6 – Database per service pattern'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6 – 每服务数据库模式'
- en: '](img/B18223_09_06.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_06.jpg)'
- en: Figure 9.6 – Database per service pattern
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 每服务数据库模式
- en: Such an approach is consistent with the principles of the microservice architecture
    and should always be applied. Communication over APIs is far more flexible than
    direct database access.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与微服务架构的**原则**一致，并且应该始终应用。通过API进行通信比直接访问数据库更加灵活。
- en: Information
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the case of monolithic systems, a database is usually the integration point.
    Since such an approach causes a lot of issues, it's considered an anti-pattern.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单体系统来说，数据库通常是集成点。由于这种方式会引发许多问题，因此被视为反模式。
- en: Preparing test data
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备测试数据
- en: We have already presented database migrations that keep the database schema
    consistent between the environments as a side effect. This is because if we run
    the same migration scripts on the development machine, in the staging environment,
    or in the production, then we would always get the result in the same schema.
    However, the data values inside the tables differ. How can we prepare the test
    data so that it would effectively test our system? This will be the focus of the
    next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了数据库迁移，它通过副作用确保环境之间的数据库模式一致。这是因为如果我们在开发机器、预发布环境或生产环境中运行相同的迁移脚本，我们总能得到相同模式的结果。然而，表中的数据值是不同的。那么，我们该如何准备测试数据，以便有效地测试我们的系统呢？这将是下一节的重点。
- en: The answer to this question depends on the type of test, and it is different
    for unit testing, integration/acceptance testing, and performance testing. Let's
    examine each case.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案取决于测试类型，并且在单元测试、集成/验收测试和性能测试中是不同的。让我们逐个检查每种情况。
- en: Unit testing
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: In the case of unit testing, we don't use the real database. We either mock
    the test data on the level of the persistence mechanism (repositories and data
    access objects) or we fake the real database with an in-memory database (for example,
    an H2 database). Since unit tests are created by developers, the exact data values
    are also usually invented by developers and aren't as important.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试的情况下，我们不会使用真实的数据库。我们要么在持久化机制（如仓库和数据访问对象）层面模拟测试数据，要么用内存数据库（例如 H2 数据库）伪造真实数据库。由于单元测试是由开发人员编写的，因此测试数据的具体值通常是由开发人员自行创设的，且这些数据值并不那么重要。
- en: Integration/acceptance testing
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成/验收测试
- en: 'Integration and acceptance tests usually use the test/staging database, which
    should be as similar to the production as possible. One approach, adopted by many
    companies, is to snapshot the production data into staging that guarantees that
    it is exactly the same. This approach, however, is treated as an anti-pattern,
    for the following reasons:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 集成和验收测试通常使用测试/预发布数据库，该数据库应该尽可能与生产环境相似。许多公司采用的一种方法是将生产数据快照到预发布环境中，确保数据完全相同。然而，这种方法被视为反模式，原因如下：
- en: '**Test isolation**: Each test operates on the same database, so the result
    of one test may influence the input of the others.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试隔离**：每个测试都在相同的数据库上进行，因此一个测试的结果可能会影响其他测试的输入。'
- en: '**Data security**: Production instances usually store sensitive information
    and are, therefore, better secured.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据安全**：生产环境中的实例通常存储敏感信息，因此需要更高的安全保障。'
- en: '**Reproducibility**: After every snapshot, the test data is different, which
    may result in flaky tests.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重现性**：每次快照后，测试数据都会有所不同，这可能导致不稳定的测试结果。'
- en: For these reasons, the preferred approach is to manually prepare the test data
    by selecting a subset of the production data with the customer or the business
    analyst. When the production database grows, it's worth revisiting its content
    to see if there are any reasonable cases that should be added.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，推荐的做法是通过与客户或业务分析师一起选择一部分生产数据手动准备测试数据。当生产数据库增长时，值得重新审视其内容，看看是否有任何合理的情况应该被加入。
- en: The best way to add data to the staging database is to use the public API of
    a service. This approach is consistent with acceptance tests, which are usually
    black-box. Furthermore, using the API guarantees that the data itself is consistent
    and simplifies database refactoring by limiting direct database operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 向预发布数据库添加数据的最佳方式是使用服务的公共 API。这种方式与验收测试一致，后者通常是黑盒测试。此外，使用 API 可以确保数据本身的一致性，并通过限制直接操作数据库来简化数据库重构。
- en: Performance testing
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: The test data for the performance testing is usually similar to acceptance testing.
    One significant difference is the amount of data. In order to test the performance
    correctly, we need to provide a sufficient volume of input data, as large as is
    available on the production (during the peak time). For this purpose, we can create
    data generators, which are usually shared between acceptance and performance tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的测试数据通常与验收测试相似。一个显著的区别是数据量的大小。为了正确测试性能，我们需要提供足够的输入数据量，最好与生产环境中的数据量相当（尤其是在高峰时段）。为此，我们可以创建数据生成器，通常这些生成器会在验收测试和性能测试之间共享。
- en: We have covered a lot about databases in the continuous delivery process. Now,
    let's move to something completely different. Let's move to the topic of improving
    our Jenkins pipeline using well-known pipeline patterns.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在持续交付过程中已经涵盖了很多关于数据库的内容。现在，让我们转到一个完全不同的话题。让我们讨论如何使用著名的流水线模式来改进我们的Jenkins流水线。
- en: Pipeline patterns
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流水线模式
- en: We already know everything necessary to start a project and set up the continuous
    delivery pipeline with Jenkins, Docker, Kubernetes, Ansible, and Terraform. This
    section is intended to extend this knowledge with a few of the recommended Jenkins
    pipeline practices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了启动项目和设置Jenkins、Docker、Kubernetes、Ansible和Terraform的持续交付流水线所需的一切。本节旨在通过一些推荐的Jenkins流水线实践来扩展这些知识。
- en: Parallelizing pipelines
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化流水线
- en: In this book, we have always executed the pipeline sequentially, stage by stage,
    step by step. This approach makes it easy to reason the state and the result of
    the build. If there is first the acceptance test stage and then the release stage,
    it means that the release won't ever happen until the acceptance tests are successful.
    Sequential pipelines are simple to understand and usually do not cause any surprises.
    That's why the first method to solve any problem is to do it sequentially.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们始终是按顺序执行流水线的，一阶段接一阶段，一步接一步。这种方法使得构建的状态和结果容易推理。如果先有验收测试阶段，再有发布阶段，那就意味着只有在验收测试成功后，发布才会发生。顺序流水线易于理解，通常不会带来意外情况。因此，解决任何问题的首选方法是按顺序执行。
- en: 'However, in some cases, the stages are time-consuming and it''s worth running
    them in parallel. A very good example is performance tests. They usually take
    a lot of time, so, assuming that they are independent and isolated, it makes sense
    to run them in parallel. In Jenkins, we can parallelize the pipeline on two different
    levels:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，阶段执行时间较长，值得将它们并行运行。一个非常好的例子是性能测试。它们通常需要较长时间，因此，如果假设它们是独立且隔离的，选择并行运行是有意义的。在Jenkins中，我们可以在两个不同的层面上并行化流水线：
- en: '**Parallel steps**: Within one stage, parallel processes run on the same agent.
    This method is simple because all Jenkins workspace-related files are located
    on one physical machine. However, as always with vertical scaling, the resources
    are limited to that single machine.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行步骤**：在一个阶段内，多个并行进程在同一代理上运行。这种方法很简单，因为所有与Jenkins工作区相关的文件都位于同一台物理机器上。然而，与垂直扩展一样，资源限制于这台机器。'
- en: '`stash` `Jenkinsfile` keyword) if a file created in the previous stage is needed
    on the other physical machine.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在前一个阶段创建的文件在其他物理机器上需要，可以使用`stash`（`Jenkinsfile`关键字）。
- en: 'Let''s see how this looks in practice. If we want to run two steps in parallel,
    the `Jenkinsfile` script should look as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作中会是什么样子。如果我们想并行执行两个步骤，`Jenkinsfile`脚本应如下所示：
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `Stage 1`, with the use of the `parallel` keyword, we execute two parallel
    steps, `one` and `two`. Note that `Stage 2` is only executed after both parallel
    steps are completed. That's why such solutions are perfectly safe to run tests
    in parallel; we can always be sure that the deployment stage only runs after all
    parallelized tests have already passed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Stage 1`中，使用`parallel`关键字，我们执行了两个并行步骤，`one`和`two`。请注意，`Stage 2`只有在两个并行步骤都完成后才会执行。这就是为什么这种解决方案在并行运行测试时非常安全；我们始终可以确保部署阶段只有在所有并行测试都通过之后才会执行。
- en: 'The preceding code sample concerned the parallel steps level. The other solution
    would be to use parallel stages, and therefore, run each stage on a separate agent
    machine. The decision on which type of parallelism to use usually depends on two
    factors:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码示例涉及的是并行步骤层次。另一种解决方案是使用并行阶段，因此每个阶段在不同的代理机器上运行。选择使用哪种并行化方法通常取决于两个因素：
- en: How powerful the agent machines are
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理机器的强大程度
- en: How much time the given stage takes
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定阶段所需的时间
- en: As a general recommendation, unit tests are fine to run in parallel steps, but
    performance tests are usually better off on separate machines.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议是，单元测试可以在并行步骤中运行，但性能测试通常最好在不同的机器上进行。
- en: Reusing pipeline components
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用流水线组件
- en: When the `Jenkinsfile` script grows in size and becomes more complex, we may
    want to reuse its parts between similar pipelines.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Jenkinsfile`脚本变得更大、更复杂时，我们可能希望在类似的流水线之间重用其部分内容。
- en: 'For example, we may want to have separate (but similar) pipelines for different
    environments (development, QA, and production). Another common example in the
    microservice world is that each service has a very similar `Jenkinsfile`. Then,
    how do we write `Jenkinsfile` scripts so that we don''t repeat the same code all
    over again? There are two good patterns for this purpose: parameterized builds,
    and shared libraries. Let''s go over them individually.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望为不同的环境（开发、QA 和生产）拥有独立的（但相似的）流水线。在微服务世界中，另一个常见的例子是每个服务都有一个非常相似的 `Jenkinsfile`。那么，我们如何编写
    `Jenkinsfile` 脚本，以便不重复相同的代码呢？有两个很好的模式可以实现这一目标：参数化构建和共享库。让我们分别来讨论这两种方式。
- en: Build parameters
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建参数
- en: 'We already mentioned in [*Chapter 4*](B18223_04_ePub.xhtml#_idTextAnchor106), *Continuous
    Integration Pipeline*, that a pipeline can have input parameters. We can use them
    to provide different use cases with the same pipeline code. As an example, let''s
    create a pipeline parameterized with the `environment` type:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 [*第 4 章*](B18223_04_ePub.xhtml#_idTextAnchor106)，*持续集成流水线* 中提到过，流水线可以有输入参数。我们可以使用这些参数为相同的流水线代码提供不同的用例。例如，让我们创建一个带有
    `environment` 类型的流水线参数：
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The build takes one input parameter, `Environment`. Then, all we do in this
    step is print the parameter. We can also add a condition to execute different
    code for different environments.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该构建需要一个输入参数，`Environment`。然后，我们在这个步骤中所做的就是打印该参数。我们还可以添加条件，以便根据不同的环境执行不同的代码。
- en: 'With this configuration, when we start the build we will see a prompt for the
    input parameter, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，当我们启动构建时，我们将看到一个输入参数提示，如下所示：
- en: '![Figure 9.7 – Jenkins parametrized build'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7 – Jenkins 参数化构建'
- en: '](img/B18223_09_07.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_07.jpg)'
- en: Figure 9.7 – Jenkins parametrized build
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – Jenkins 参数化构建
- en: A parameterized build can help us reuse the pipeline code for scenarios that
    differ just a little bit. However, this feature should not be overused, because
    too many conditions can make a `Jenkinsfile` difficult to understand.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化构建可以帮助我们在略有不同的场景中重用流水线代码。然而，这个功能不应被过度使用，因为过多的条件可能使得 `Jenkinsfile` 难以理解。
- en: Shared libraries
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享库
- en: The other solution to reuse the pipeline is to extract its parts into a shared library.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重用流水线的解决方案是将其部分提取到共享库中。
- en: 'A shared library is a Groovy code that is stored as a separate, source-controlled
    project. This code can later be used in many `Jenkinsfile` scripts as pipeline
    steps. To make it clear, let''s take a look at an example. A shared library technique
    always requires three steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库是存储为独立的、源代码控制的项目的 Groovy 代码。以后可以在许多 `Jenkinsfile` 脚本中作为流水线步骤使用这些代码。为了更清楚地说明这一点，让我们看一个例子。使用共享库技术通常需要三个步骤：
- en: Create a shared library project.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个共享库项目。
- en: Configure the shared library in Jenkins.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 中配置共享库。
- en: Use the shared library in a `Jenkinsfile`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Jenkinsfile` 中使用共享库。
- en: Creating a shared library project
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建共享库项目
- en: We start by creating a new Git project, in which we put the shared library code.
    Each Jenkins step is expressed as a Groovy file located in the `vars` directory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的 Git 项目，在其中存放共享库代码。每个 Jenkins 步骤都作为一个 Groovy 文件表示，文件位于 `vars` 目录中。
- en: 'Let''s create a `sayHello` step that takes the `name` parameter and echoes
    a simple message. This should be stored in the `vars/sayHello.groovy` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `sayHello` 步骤，该步骤接受 `name` 参数并回显一条简单的消息。此代码应存放在 `vars/sayHello.groovy`
    文件中：
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Information
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Human-readable descriptions for shared library steps can be stored in the `*.txt` files.
    In our example, we could add the `vars/sayHello.txt` file with the step documentation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库步骤的可读描述可以存储在 `*.txt` 文件中。在我们的例子中，我们可以添加 `vars/sayHello.txt` 文件以记录步骤文档。
- en: When the library code is done, we need to push it to the repository, for example,
    as a new GitHub project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当库代码完成后，我们需要将其推送到仓库，例如作为一个新的 GitHub 项目。
- en: Configure the shared library in Jenkins
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Jenkins 中配置共享库
- en: 'The next step is to register the shared library in Jenkins. We open **Manage
    Jenkins** | **Configure System** and find the **Global Pipeline Libraries** section.
    There, we can add the library giving it a chosen name, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将共享库注册到 Jenkins 中。我们打开 **管理 Jenkins** | **配置系统**，找到 **全局流水线库** 部分。在这里，我们可以添加库，并为其指定一个选择的名称，如下所示：
- en: '![Figure 9.8 – Jenkins global pipeline library configuration'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – Jenkins 全局流水线库配置'
- en: '](img/B18223_09_08.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_08.jpg)'
- en: Figure 9.8 – Jenkins global pipeline library configuration
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – Jenkins 全局流水线库配置
- en: We specified the name under which the library is registered and the library
    repository address. Note that the latest version of the library will automatically
    be downloaded during the pipeline build.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了库的注册名称和库的仓库地址。请注意，库的最新版本将在管道构建过程中自动下载。
- en: Information
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We showed importing the Groovy code as a *Global Shared Library*, but there
    are also other solutions. Read more at [https://www.jenkins.io/doc/book/pipeline/shared-libraries/](https://www.jenkins.io/doc/book/pipeline/shared-libraries/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了将Groovy代码作为*全局共享库*导入，但也有其他解决方案。详情请阅读[https://www.jenkins.io/doc/book/pipeline/shared-libraries/](https://www.jenkins.io/doc/book/pipeline/shared-libraries/)。
- en: Using the shared library in a Jenkinsfile
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Jenkinsfile中使用共享库
- en: 'Finally, we can use the shared library in a `Jenkinsfile`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`Jenkinsfile`中使用共享库：
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If `@Library('example') _` at the beginning of the `Jenkinsfile` script.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`@Library('example') _`在`Jenkinsfile`脚本的开头。
- en: As you can see, we can use the Groovy code as a `sayHello` pipeline step. Obviously,
    after the pipeline build completes, we should see `Hello Rafal!` in the console
    output.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以将Groovy代码用作`sayHello`管道步骤。显然，在管道构建完成后，我们应该在控制台输出中看到`Hello Rafal!`。
- en: Information
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Shared libraries are not limited to one step. Actually, with the power of the
    Groovy language, they can even act as templates for entire Jenkins pipelines.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库不限于一个步骤。事实上，凭借Groovy语言的强大功能，它们甚至可以作为整个Jenkins管道的模板。
- en: After describing how to share the Jenkins pipeline code, let's also write a
    few words on rolling back deployments during the continuous delivery process.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述如何共享Jenkins管道代码之后，让我们再谈一谈在持续交付过程中回滚部署的几句话。
- en: Rolling back deployments
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚部署
- en: I remember the words of my colleague, a senior architect—*You don't need more
    QAs, you need a faster rollback*. While this statement is oversimplified and the
    QA team is often of great value, there is a lot of truth in this sentence. Think
    about it; if you introduce a bug in the production but roll it back soon after
    the first user reports an error, then usually, nothing bad happens. On the other
    hand, if production errors are rare but no rollback is applied, then the process
    to debug the production usually ends in long, sleepless nights and some dissatisfied
    users. That's why we need to think about the rollback strategy upfront while creating
    the Jenkins pipeline.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我同事，一位高级架构师的话——*你不需要更多的QA，你需要更快的回滚*。虽然这个说法过于简化，且QA团队通常非常有价值，但这句话中确实有不少真理。想想看，如果你在生产环境中引入了一个bug，但在第一个用户报告错误后很快就回滚了，那么通常不会发生什么坏事。另一方面，如果生产环境中的错误很少发生，但没有回滚操作，那么调试生产环境的过程通常会以漫长的失眠之夜和一些不满的用户告终。这就是为什么我们在创建Jenkins管道时，需要提前思考回滚策略的原因。
- en: 'In the context of continuous delivery, there are two moments when the failure
    can happen:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付的背景下，失败可能发生的时刻有两个：
- en: During the release process, in the pipeline execution
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布过程中，在管道执行中
- en: After the pipeline build is completed, in production
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道构建完成后，在生产环境中
- en: The first scenario is pretty simple and harmless. It concerns a case when the
    application is already deployed to production but the next stage fails, for example,
    the smoke test. Then, all we need to do is execute a script in the `post` pipeline
    section for the `failure` case, which downgrades the production service to the
    older Docker image version. If we use blue-green deployment (as we will describe
    later in this chapter), the risk of any downtime is minimal, since we usually
    execute the load-balancer switch as the last pipeline stage after the smoke test.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景非常简单且无害。它涉及一个应用程序已经部署到生产环境，但下一个阶段失败的情况，例如烟雾测试失败。此时，我们只需要在`post`管道部分的`failure`情况下执行一个脚本，该脚本将生产服务降级到较旧的Docker镜像版本。如果我们使用蓝绿部署（稍后我们将在本章中描述），任何停机的风险将最小，因为通常我们会在烟雾测试之后的最后一个管道阶段执行负载均衡器切换。
- en: The second scenario, in which we notice a production bug after the pipeline
    is successfully completed, is more difficult and requires a few words of comment.
    Here, the rule is that we should always release the rolled-back service using
    exactly the same process as the standard release. Otherwise, if we try to do something
    manually in a faster way, we are asking for trouble. Any non-repetitive task is
    risky, especially under stress when production is out of order.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是在管道成功完成后，我们发现了一个生产环境的错误，这种情况更为复杂，需要稍作评论。在这种情况下，规则是我们应该总是通过与标准发布完全相同的流程来发布回滚的服务。否则，如果我们尝试以更快的方式手动处理，就会带来麻烦。任何非重复性的任务都是有风险的，特别是在生产环境故障时，压力更大。
- en: Information
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: As a side note, if the pipeline completes successfully but there is a production
    bug, then it means that our tests are not good enough. So, the first thing after
    the rollback is to extend the unit/acceptance test suites with the corresponding
    scenarios.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果管道成功完成，但出现了生产环境的错误，那么说明我们的测试还不够充分。因此，回滚后的第一件事是扩展单元/验收测试套件，加入相应的场景。
- en: The most common continuous delivery process is a single, fully automated pipeline
    that starts by checking out the code and ends with release to the production.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的持续交付过程是一个单一的、完全自动化的管道，它从检出代码开始，到发布到生产环境结束。
- en: 'The following diagram shows how this works:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这个流程是如何运作的：
- en: '![Figure 9.9 – Continuous delivery pipeline'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 持续交付管道'
- en: '](img/B18223_09_09.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_09.jpg)'
- en: Figure 9.9 – Continuous delivery pipeline
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 持续交付管道
- en: We already presented the classic continuous delivery pipeline in this book.
    If the rollback should use exactly the same process, then all we need to do is
    revert the latest code change from the repository. As a result, the pipeline automatically
    builds, tests, and finally, releases the right version.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们已经展示了经典的持续交付管道。如果回滚需要使用完全相同的流程，那么我们只需从代码库中恢复最新的代码更改。这样，管道会自动构建、测试，最终发布正确的版本。
- en: Information
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Repository reverts and emergency fixes should never skip the testing stages
    in the pipeline, otherwise, we may end up with a release that is still not working
    correctly due to another issue that makes debugging even harder.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库回滚和紧急修复永远不应跳过管道中的测试阶段，否则，我们可能会得到一个仍然无法正常工作的发布版本，且由于其他问题，调试变得更加困难。
- en: The solution is very simple and elegant. The only drawback is the downtime that
    we need to spend on the complete pipeline build. This downtime can be avoided
    if we use blue-green deployment or canary releases, in which cases, we only change
    the load balancer setting to address the healthy environment.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常简单且优雅。唯一的缺点是我们需要在完整的管道构建中消耗一些停机时间。如果我们使用蓝绿部署或金丝雀发布，就可以避免这些停机时间，在这种情况下，我们只需要修改负载均衡器的设置以指向健康的环境。
- en: The rollback operation becomes far more complex in the case of orchestrated
    releases, during which many services are deployed at the same time. This is one
    of the reasons why orchestrated releases are treated as an anti-pattern, especially
    in the microservice world. The correct approach is to always maintain backward
    compatibility, at least for a time (as we showed for the database at the beginning
    of this chapter). Then, it's possible to release each service independently.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在协调发布的情况下，回滚操作变得更加复杂，因为在协调发布过程中，多个服务会同时部署。这也是为什么协调发布被视为反模式，特别是在微服务世界中。正确的方法是始终保持向后兼容性，至少在一段时间内（如本章开始时我们展示的数据库）。然后，就可以独立发布每个服务。
- en: Adding manual steps
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加手动步骤
- en: In general, the continuous delivery pipelines should be fully automated, triggered
    by a commit to the repository, and end after the release. Sometimes, however,
    we can't avoid having manual steps. The most common example is the release approval,
    which means that the process is fully automated, but there is a manual step to
    approve the new release. Another common example is manual tests. Some of them
    may exist because we operate on a legacy system; some others may occur when a
    test simply cannot be automated. No matter what the reason is, sometimes, there
    is no choice but to add a manual step.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，持续交付管道应该是完全自动化的，通过提交到代码库触发，并在发布后结束。然而，有时我们无法避免手动步骤。最常见的例子是发布批准，这意味着过程是完全自动化的，但仍然需要手动步骤来批准新的发布。另一个常见的例子是手动测试。有些手动测试是因为我们在操作遗留系统，有些则是因为某些测试无法自动化。不管是什么原因，有时我们别无选择，只能添加手动步骤。
- en: 'Jenkins syntax offers an `input` keyword for manual steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 语法提供了一个 `input` 关键字用于手动步骤：
- en: '[PRE22]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The pipeline will stop execution on the `input` step and wait until it's manually
    approved.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线将在 `input` 步骤上停止执行，并等待手动批准。
- en: Remember that manual steps quickly become a bottleneck in the delivery process,
    and this is why they should always be treated as a solution that is inferior to
    complete automation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，手动步骤很快就会成为交付过程中的瓶颈，这就是为什么它们应始终被视为完全自动化的次优解的原因。
- en: Tip
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is sometimes useful to set a timeout for the input to avoid waiting forever
    for the manual interaction. After the configured time is elapsed, the whole pipeline
    is aborted.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有时为输入设置超时是有用的，以避免无限期等待手动交互。在配置的时间过去后，整个流水线将被中止。
- en: We have covered a lot of important pipeline patterns; now, let's focus on different
    deployment release patterns.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了许多重要的流水线模式；现在让我们专注于不同的部署发布模式。
- en: Release patterns
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布模式
- en: In the last section, we discussed the Jenkins pipeline patterns used to speed
    up the build execution (parallel steps), help with the code reuse (shared libraries),
    limit the risk of production bugs (rollback), and deal with manual approvals (manual
    steps). This section will focus on the next group of patterns; this time, related
    to the release process. They are designed to reduce the risk of updating the production
    to a new software version.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了用于加速构建执行（并行步骤）、帮助代码重用（共享库）、限制生产错误风险（回滚）以及处理手动批准（手动步骤）的 Jenkins 流水线模式。本节将专注于下一组模式；这次是与发布过程相关的。它们旨在减少将新软件版本更新到生产环境中的风险。
- en: 'We already described one of the release patterns, rolling updates, in [*Chapter
    6*](B18223_06_ePub.xhtml#_idTextAnchor152), *Clustering with Kubernetes*. Here,
    we will present two more: blue-green deployment and canary releases.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 6 章*](B18223_06_ePub.xhtml#_idTextAnchor152) 中描述了一个发布模式，即滚动更新，这里我们将介绍另外两种：蓝绿部署和金丝雀发布。
- en: Information
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: A very convenient way to use the release patterns in Kubernetes is to use the
    Istio service mesh. Read more at [https://istio.io/](https://istio.io/).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用发布模式的一个非常方便的方式是使用 Istio 服务网格。详细信息请参阅 [https://istio.io/](https://istio.io/)。
- en: Blue-green deployment
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: 'Blue-green deployment is a technique to reduce the downtime associated with
    the release. It concerns having two identical production environments—one called **green**,
    the other called **blue**—as presented in the following diagram:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种减少与发布相关的停机时间的技术。它涉及拥有两个相同的生产环境——一个称为 **绿色**，另一个称为 **蓝色**——如下图所示：
- en: '![Figure 9.10 – Blue-green deployment'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 蓝绿部署'
- en: '](img/B18223_09_10.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_10.jpg)'
- en: Figure 9.10 – Blue-green deployment
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 蓝绿部署
- en: In the figure, the currently accessible environment is blue. If we want to make
    a new release, then we deploy everything to the green environment and, at the
    end of the release process, change the load balancer to the green environment.
    As a result, the user suddenly starts using the new version. The next time we
    want to make a release, we make changes to the blue environment and, in the end,
    we change the load balancer to blue. We proceed the same every time, switching
    from one environment to another.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，当前可访问的环境是蓝色的。如果我们要进行新版本发布，那么我们将所有内容部署到绿色环境，并在发布流程结束时将负载均衡器切换到绿色环境。因此，用户突然开始使用新版本。下次我们想发布时，我们对蓝色环境进行更改，最终将负载均衡器切换到蓝色。我们每次都按相同方式进行，从一个环境切换到另一个环境。
- en: Information
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'The blue-green deployment technique works correctly with two assumptions: environmental
    isolation and no orchestrated releases.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署技术的正确运作需要满足两个假设：环境隔离和无编排的发布。
- en: 'This solution provides the following benefits:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案提供以下好处：
- en: '**Zero downtime**: All the downtime, from the user perspective, is a moment
    of changing the load balance switch, which is negligible.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机时间**：从用户的角度来看，所有停机时间仅仅是改变负载均衡开关的时刻，这是可以忽略不计的。'
- en: '**Rollback**: In order to roll back one version, it''s enough to change back
    the load balance switch.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚（Rollback）**：为了回滚到上一个版本，只需切换回负载均衡开关。'
- en: 'Note that the blue-green deployment must include the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，蓝绿部署必须包括以下内容：
- en: '**Database**: Schema migrations can be tricky in case of a rollback, so it''s
    worth using the patterns discussed at the beginning of this chapter.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：在回滚情况下，模式迁移可能会有些棘手，因此使用本章开头讨论的模式是值得的。'
- en: '**Transactions**: Running database transactions must be handed over to the
    new database.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务**：运行数据库事务必须交给新数据库处理。'
- en: '**Redundant infrastructure/resources**: We need to have double the resources.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余基础设施/资源**：我们需要准备两倍的资源。'
- en: There are techniques and tools to overcome these challenges, so the blue-green
    deployment pattern is highly recommended and is widely used in the IT industry.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术和工具可以克服这些挑战，因此蓝绿部署模式被广泛推荐，并在 IT 行业中得到广泛应用。
- en: Information
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read more about the blue-green deployment technique on the excellent
    blog from Martin Fowler, at [https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Martin Fowler 的博客上进一步阅读有关蓝绿部署技术的内容，网址是 [https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html)。
- en: Canary release
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: 'Canary release is a technique to reduce the risk associated with introducing
    a new version of the software. Similar to blue-green deployment, it uses two identical
    environments, as presented in the following diagram:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布是一种减少引入新版本软件时风险的技术。与蓝绿部署类似，它使用两个相同的环境，如下图所示：
- en: '![Figure 9.11 – Canary release'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 金丝雀发布'
- en: '](img/B18223_09_11.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_09_11.jpg)'
- en: Figure 9.11 – Canary release
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 金丝雀发布
- en: Also, similar to the blue-green deployment technique, the release process starts
    by deploying a new version in the environment that is currently unused. Here,
    however, the similarities end. The load balancer, instead of switching to the
    new environment, is set to link only a selected group of users to the new environment.
    The rest still use the old version. This way, a new version can be tested by some
    users and, in case of a bug, only a small group will be affected. After the testing
    period, all users are switched to the new version.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类似于蓝绿部署技术，发布过程从在当前未使用的环境中部署新版本开始。不过，在这里，相似之处就结束了。负载均衡器不是切换到新环境，而是仅将一部分用户链接到新环境，其余用户仍然使用旧版本。通过这种方式，只有一部分用户可以测试新版本，如果出现错误，也仅会影响小范围的用户。测试期结束后，所有用户都将切换到新版本。
- en: 'This approach has some great benefits:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些很好的优点：
- en: '**Acceptance and performance testing**: If the acceptance and performance testing
    are difficult to run in the staging environment, then it''s possible to test them
    in production, minimizing the impact on a small group of users.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收与性能测试**：如果在暂存环境中难以进行验收与性能测试，则可以在生产环境中进行测试，最小化对小部分用户的影响。'
- en: '**Simple rollback**: If a new change causes a failure, then rolling back is
    done by switching all users back to the old version.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单回滚**：如果新变更导致故障，可以通过将所有用户切换回旧版本来实现回滚。'
- en: '**A/B testing**: If we are not sure whether the new version is better from
    the UX or the performance perspective, then it''s possible to compare it with
    the old version.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A/B 测试**：如果我们不确定新版本在用户体验或性能方面是否更好，可以将其与旧版本进行比较。'
- en: Canary release shares the same drawbacks as the blue-green deployment. The additional
    challenge is that we have two production systems running at the same time. Nevertheless,
    canary release is an excellent technique used in most companies to help with the
    release and testing.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布与蓝绿部署有相同的缺点。额外的挑战是，我们同时运行了两个生产系统。尽管如此，金丝雀发布仍然是大多数公司广泛使用的优秀技术，帮助进行发布和测试。
- en: Information
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read more about the canary release technique on Martin Fowler's blog,
    at [https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Martin Fowler 的博客上进一步阅读有关金丝雀发布技术的内容，网址是 [https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html)。
- en: Working with legacy systems
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与遗留系统的协作
- en: Everything we have described so far applies to greenfield projects, for which
    setting up a continuous delivery pipeline is relatively simple.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止我们所描述的一切适用于绿地项目，对于这些项目，设置持续交付管道相对简单。
- en: Legacy systems are, however, far more challenging, because they usually depend
    on manual tests and manual deployment steps. In this section, we will walk through the
    recommended scenario to incrementally apply continuous delivery to a legacy system.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，遗留系统要复杂得多，因为它们通常依赖手动测试和手动部署步骤。在这一部分中，我们将讲解如何逐步将持续交付应用于遗留系统的推荐场景。
- en: As the first step, I recommend reading a great book by Michael Feathers, *Working
    Effectively with Legacy Code*. His ideas on how to deal with testing, refactoring,
    and adding new features address most of the concerns about how to automate the
    delivery process for legacy systems.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我建议阅读 Michael Feathers 的一本好书，《*与遗留代码有效合作*》。他关于如何处理测试、重构以及添加新特性的观点，解决了大多数关于如何自动化遗留系统交付过程的疑虑。
- en: Information
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For many developers, it may be tempting to completely rewrite a legacy system
    rather than refactor it. While the idea is interesting from a developer's perspective,
    it is usually a bad business decision that results in a product failure. You can
    read more about the history of rewriting the Netscape browser in a brilliant blog
    post by Joel Spolsky, *Things You Should Never Do,* at [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多开发人员来说，完全重写遗留系统而不是重构它可能是一个诱人的选择。虽然从开发者的角度来看，这个想法很有趣，但通常这是一个糟糕的商业决策，最终导致产品失败。你可以在
    Joel Spolsky 的一篇精彩博客《*你永远不该做的事*》中了解更多关于重写 Netscape 浏览器的历史，博客地址为 [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i)。
- en: 'The way to apply the continuous delivery process depends a lot on the current
    project''s automation, the technology used, the hardware infrastructure, and the
    current release process. Usually, it can be split into three steps:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 应用持续交付过程的方式在很大程度上取决于当前项目的自动化程度、所使用的技术、硬件基础设施以及当前的发布流程。通常，它可以分为三个步骤：
- en: Automating build and deployment
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化构建与部署
- en: Automating tests
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Refactoring and introducing new features
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构与引入新特性
- en: Let's look at these in detail.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些内容。
- en: Automating build and deployment
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化构建与部署
- en: The first step includes automating the deployment process. The good news is
    that in most legacy systems that I have worked with, there was already some automation
    in place (for example, in the form of shell scripts).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段包括自动化部署过程。好消息是，在我曾经接触过的大多数遗留系统中，已经有一些自动化措施（例如，采用 Shell 脚本的形式）。
- en: 'In any case, the activities for automated deployment include the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，自动化部署的活动包括以下内容：
- en: '**Build and package**: Some automation usually already exists, in the form
    of Makefile, Ant, Maven, or any other build tool configuration, or a custom script.'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建与打包**：通常，已经存在一些自动化措施，比如 Makefile、Ant、Maven 或任何其他构建工具的配置，或者是自定义脚本。'
- en: '**Database migration**: We need to start incrementally managing the database
    schema. This requires putting the current schema as an initial migration and making
    all the further changes with tools such as Flyway or Liquibase, as already described
    in this chapter.'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据库迁移**：我们需要开始逐步管理数据库架构。这要求将当前的架构作为初始迁移，并使用 Flyway 或 Liquibase 等工具进行所有进一步的更改，正如本章中已描述的那样。'
- en: '**Deployment**: Even if the deployment process is fully manual, then there
    is usually a text/wiki page description that needs to be converted into an automated
    script.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署**：即使部署过程完全是手动的，通常也会有一个需要转化为自动化脚本的文本/维基页面描述。'
- en: '**Repeatable configuration**: In legacy systems, configuration files are usually
    changed manually. We need to extract the configuration and use a configuration
    management tool, as described in [*Chapter 7*](B18223_07_ePub.xhtml#_idTextAnchor185), *Configuration
    Management with Ansible*.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可重复配置**：在遗留系统中，配置文件通常是手动更改的。我们需要提取配置并使用配置管理工具，正如在 [*第 7 章*](B18223_07_ePub.xhtml#_idTextAnchor185)《*使用
    Ansible 的配置管理*》中所描述的那样。'
- en: After the preceding steps, we can put everything into a deployment pipeline
    and use it as an automated phase after a manual **user acceptance testing** (**UAT**) cycle.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤完成后，我们可以将所有内容放入部署管道，并在手动**用户验收测试**（**UAT**）周期后，作为自动化阶段使用。
- en: From the process perspective, it's already worth starting to release more often.
    For example, if the release is yearly, try to do it quarterly, then monthly. The
    push for that factor will later result in faster-automated delivery adoption.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 从流程的角度来看，现在开始更频繁地发布版本已经是值得的。例如，如果发布周期是每年一次，尝试改为每季度发布一次，再到每月发布一次。推动这一因素将最终促使更快的自动化交付方式的采用。
- en: Automating tests
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'The next step, usually much more difficult, is to prepare the automated tests
    for the system. It requires communicating with the QA team in order to understand
    how they currently test the software so that we can move everything into an automated
    acceptance test suite. This phase requires two steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，通常更加困难，是为系统准备自动化测试。这需要与QA团队沟通，了解他们当前如何测试软件，从而将所有内容迁移到自动化验收测试套件中。这个阶段需要两个步骤：
- en: '**Acceptance/sanity test suite**: We need to add automated tests that replace
    some of the regression activities of the QA team. Depending on the system, they
    can be provided as a black-box Selenium test or a Cucumber test.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验收/健康检查测试套件**：我们需要添加自动化测试，替代QA团队的部分回归活动。根据系统的不同，可以使用黑盒Selenium测试或Cucumber测试提供这些测试。'
- en: '**(Virtual) test environments**: At this point, we should already be thinking
    of the environments in which our tests would run. Usually, the best solution to
    save resources and limit the number of machines required is to virtualize the
    testing environment using Vagrant or Docker.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**（虚拟）测试环境**：此时，我们应该已经开始考虑测试将在哪些环境中运行。通常，为了节省资源并限制所需机器的数量，最佳解决方案是使用Vagrant或Docker来虚拟化测试环境。'
- en: The ultimate goal is to have an automated acceptance test suite that will replace
    the whole UAT phase from the development cycle. Nevertheless, we can start with
    a sanity test that will check if the system is correct, from the regression perspective.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是拥有一个自动化验收测试套件，取代开发周期中的整个UAT阶段。然而，我们可以从一个检查系统是否正确的简单测试开始，重点是回归测试。
- en: Information
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: While adding test scenarios, remember that the test suite should execute in
    a reasonable time. For sanity tests, it is usually less than 10 minutes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加测试场景时，请记住，测试套件应该在合理的时间内执行。对于健康检查测试，通常要求时间不超过10分钟。
- en: Refactoring and introducing new features
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构与引入新功能
- en: When we have the fundamental regression testing suite (at a minimum), we are
    ready to add new features and refactor the old code. It's always better to do
    it in small pieces step by step, because refactoring everything at once usually
    ends up in chaos, and that leads to production failures (not related to any particular
    change).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有基本的回归测试套件（至少）时，就可以开始添加新功能并重构旧代码。最好一步一步地进行小规模的重构，因为一次性重构所有代码通常会导致混乱，进而导致生产环境的故障（与某一特定更改无关）。
- en: 'This phase usually includes the following activities:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段通常包括以下活动：
- en: '**Refactoring**: The best place to start refactoring the old code is where
    the new features are expected. Starting this way prepares us for the new feature
    requests yet to come.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：开始重构旧代码的最佳位置是预期要新增功能的地方。从这里开始，我们为未来的功能请求做好准备。'
- en: '**Rewrite**: If we plan to rewrite parts of the old code, we should start from
    the code that is the most difficult to test. This way, we can constantly increase
    the code coverage in our project.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写**：如果我们计划重写旧代码的部分内容，应该从最难测试的代码开始。这样，我们可以不断增加项目中的代码覆盖率。'
- en: '**Introducing new features**: During the new feature implementation, it''s
    worth using the **feature toggle** pattern. Then, if anything bad happens, we
    can quickly turn off the new feature. The same pattern should also be used during
    refactoring.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引入新功能**：在实现新功能时，使用**功能开关**模式是值得推荐的。这样，如果出现问题，我们可以迅速关闭新功能。重构时也应使用相同的模式。'
- en: Information
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: 'For this phase, it''s worth reading a very good book by Martin Fowler, *Refactoring:
    Improving the Design of Existing Code*.'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个阶段，阅读马丁·福勒的《*重构：改善现有代码的设计*》这本非常好的书是值得的。
- en: While touching on the old code, it's good to follow the rule to always add a
    passing unit test first, and only then change the code. With this approach, we
    can rely on automation to check that we don't accidentally change the business
    logic.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理旧代码时，最好遵循一个规则：始终先添加一个通过的单元测试，然后再修改代码。通过这种方法，我们可以依赖自动化来检查我们是否不小心改变了业务逻辑。
- en: Understanding the human element
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解人的因素
- en: While introducing the automated delivery process to a legacy system, you may
    feel the human factor more than anywhere else. In order to automate the build
    process, we need to communicate well with the operations team, and they must be
    willing to share their knowledge. The same story applies to the manual QA team;
    they need to be involved in writing automated tests because only they know how
    to test the software. If you think about it, both the operations and QA teams
    need to contribute to the project that will later automate their work. At some
    point, they may realize that their future in the company is not stable and become
    less helpful. Many companies struggle with introducing the continuous delivery
    process because teams do not want to get involved enough.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在向旧系统引入自动化交付过程时，可能会比其他地方更能感受到人因素。为了实现构建过程的自动化，我们需要与运维团队良好沟通，而他们必须愿意分享他们的知识。同样的道理也适用于手动
    QA 团队；他们需要参与编写自动化测试，因为只有他们知道如何测试软件。如果仔细想想，运维和 QA 团队都需要为后期自动化他们的工作做出贡献。在某些时候，他们可能会意识到自己在公司中的未来不稳定，从而变得不那么热衷提供帮助。许多公司在引入持续交付过程中面临困难，因为团队不愿意充分参与。
- en: In this section, we discussed how to approach legacy systems and the challenges
    they pose. If you are in the process of converting your project and organization
    to the continuous delivery approach, then you may want to take a look at the Continuous
    Delivery Maturity Model, which aims to give some structure to the process of adopting
    automated delivery.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何处理旧系统及其带来的挑战。如果您正在将项目和组织转变为持续交付方式，那么您可能希望查看《持续交付成熟度模型》，该模型旨在为采用自动化交付的过程提供一些结构。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter has been a mixture of various continuous delivery aspects that
    were not previously covered. The key takeaways from the chapter are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对各种持续交付方面的混合介绍，这些方面以前没有涉及。本章的关键要点如下：
- en: Databases are an essential part of most applications, and should, therefore,
    be included in the continuous delivery process.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库是大多数应用程序的核心部分，因此应将其纳入持续交付过程。
- en: Database schema changes are stored in the version control system and managed
    by database migration tools.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库架构更改存储在版本控制系统中，并通过数据库迁移工具进行管理。
- en: 'There are two types of database schema changes: backward-compatible and backward-incompatible.
    While the first type is simple, the second requires a bit of overhead (split to
    multiple migrations spread over time).'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库架构更改有两种类型：向后兼容和向后不兼容。第一种类型比较简单，而第二种类型需要一些额外的开销（需要分多次迁移，分布在一段时间内）。
- en: A database should not be the central point of the whole system. The preferred
    solution is to provide each service with its own database.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库不应是整个系统的核心。首选的解决方案是为每个服务提供其自己的数据库。
- en: The delivery process should always be prepared for a rollback scenario.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付过程应该始终为回滚场景做好准备。
- en: 'Three release patterns should always be considered: rolling updates, blue-green
    deployment, and canary release.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在考虑发布模式时，应该始终考虑三种模式：滚动更新、蓝绿部署和金丝雀发布。
- en: Legacy systems can be converted to the continuous delivery process in small
    steps, rather than all at once.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧系统可以通过小步快走的方式转变为持续交付过程，而不是一次性完成。
- en: Next, for the last part of the book, we will look into the best practices for
    your continuous delivery process.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在书的最后部分，我们将研究持续交付过程的最佳实践。
- en: Exercises
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we covered various aspects of the continuous delivery process.
    Since practice makes perfect, we recommend the following exercises:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了持续交付过程的各个方面。由于实践能带来完美，我们推荐以下练习：
- en: 'Use Flyway to create a non-backward-compatible change in the MySQL database:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Flyway 在 MySQL 数据库中创建一个向后不兼容的更改：
- en: Use the official Docker image, `mysql`, to start the database.
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用官方 Docker 镜像 `mysql` 启动数据库。
- en: Configure Flyway with a proper database address, username, and password.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的数据库地址、用户名和密码配置 Flyway。
- en: 'Create an initial migration that creates a `USERS` table with three columns:
    `ID`, `EMAIL`, and `PASSWORD`.'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始迁移，该迁移创建一个包含三个列的 `USERS` 表：`ID`、`EMAIL` 和 `PASSWORD`。
- en: Add sample data to the table.
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向表中添加示例数据。
- en: Change the `PASSWORD` column to `HASHED_PASSWORD`, which will store the hashed
    passwords.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PASSWORD` 列更改为 `HASHED_PASSWORD`，该列将存储哈希后的密码。
- en: Split the non-backward-compatible change into three migrations, as described
    in this chapter.
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向后不兼容的更改分成三个迁移，如本章所述。
- en: You can use `MD5` or `SHA` for hashing.
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `MD5` 或 `SHA` 进行哈希处理。
- en: Check that the database doesn't store any passwords in plain text as a result.
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数据库是否未将任何密码以明文形式存储。
- en: 'Create a Jenkins shared library with steps to build and unit test Gradle projects:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Jenkins 共享库，包含构建和单元测试 Gradle 项目的步骤：
- en: Create a separate repository for the library.
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为库创建一个独立的代码库。
- en: 'Create two files in the library: `gradleBuild.groovy` and `gradleTest.groovy`.'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库中创建两个文件：`gradleBuild.groovy` 和 `gradleTest.groovy`。
- en: Write the appropriate `call` methods.
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写适当的 `call` 方法。
- en: Add the library to Jenkins.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库添加到 Jenkins。
- en: Use the steps from the library in a pipeline.
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管道中使用库中的步骤。
- en: Questions
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To verify the knowledge from this chapter, please answer the following questions:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证本章的知识，请回答以下问题：
- en: What are database (schema) migrations?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是数据库（模式）迁移？
- en: Can you name at least three database migration tools?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能列举至少三个数据库迁移工具吗？
- en: What are the main two types of changes to the database schema?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库模式的主要两种变更类型是什么？
- en: Why should one database not be shared between multiple services?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么一个数据库不应该在多个服务之间共享？
- en: What is the difference between the test data for unit tests and integration/acceptance
    tests?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试与集成/验收测试的数据有什么区别？
- en: What Jenkins pipeline keyword do you use to make the steps run in parallel?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 管道中使用什么关键字来使步骤并行执行？
- en: What are different methods to reuse Jenkins pipeline components?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些不同的方法可以重用 Jenkins 管道组件？
- en: What Jenkins pipeline keyword do you use to make a manual step?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 管道中使用什么关键字来创建手动步骤？
- en: What are the three release patterns mentioned in this chapter?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中提到的三种发布模式是什么？
- en: Further reading
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To read more about the advanced aspects of the continuous delivery process,
    please refer to the following resources:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解持续交付过程的高级方面，请参考以下资源：
- en: '*Databases as a Challenge for Continuous Delivery*: [https://phauer.com/2015/databases-challenge-continuous-delivery/](https://phauer.com/2015/databases-challenge-continuous-delivery/).'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库作为持续交付的挑战*： [https://phauer.com/2015/databases-challenge-continuous-delivery/](https://phauer.com/2015/databases-challenge-continuous-delivery/)。'
- en: '*Zero Downtime Deployment with a Database*: [https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database](https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database).'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用数据库的零停机部署*： [https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database](https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database)。'
- en: '*Canary Release*: [https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*金丝雀发布*： [https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html)。'
- en: '*Blue-Green Deployment*: [https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html).'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蓝绿部署*： [https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html)。'
