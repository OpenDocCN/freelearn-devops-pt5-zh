- en: Data Volumes and Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据卷和配置
- en: In the last chapter, we learned how to build and share our own container images.
    Particular focus was placed on how to build images that are as small as possible
    by only containing artifacts that are really needed by the containerized application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何构建和共享自己的容器镜像。重点是如何通过仅包含容器化应用程序真正需要的工件，来构建尽可能小的镜像。
- en: In this chapter, we are going to learn how we can work with stateful containers—that
    is, containers that consume and produce data. We will also learn how to configure
    our containers at runtime and at image build time, using environment variables
    and config files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何处理有状态容器——即那些消耗和生产数据的容器。我们还将学习如何在运行时和镜像构建时，通过环境变量和配置文件来配置容器。
- en: 'Here is a list of the topics we''re going to discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将讨论的主题列表：
- en: Creating and mounting data volumes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和挂载数据卷
- en: Sharing data between containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器之间共享数据
- en: Using host volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机卷
- en: Defining volumes in images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在镜像中定义卷
- en: Configuring containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置容器
- en: 'After working through this chapter, you will be able to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容后，你将能够做到以下几点：
- en: Create, delete, and list data volumes.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、删除和列出数据卷。
- en: Mount an existing data volume into a container.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的数据卷挂载到容器中。
- en: Create durable data from within a container using a data volume.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内使用数据卷创建持久化数据。
- en: Share data between multiple containers using data volumes.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷在多个容器之间共享数据。
- en: Mount any host folder into a container using data volumes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷将任何主机文件夹挂载到容器中。
- en: Define the access mode (read/write or read-only) for a container when accessing
    data in a data volume.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问数据卷中的数据时，定义容器的访问模式（读/写或只读）。
- en: Configure environment variables for applications running in a container.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在容器中运行的应用程序配置环境变量。
- en: Parametrize a `Dockerfile` by using build arguments.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用构建参数来参数化 `Dockerfile`。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need either Docker Toolbox installed on your machine or
    access to a Linux **virtual machine** (**VM**) running Docker on your laptop or
    in the cloud. Furthermore, it is advantageous to have Docker for Desktop installed
    on your machine. There is no code accompanying this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容需要在你的机器上安装 Docker Toolbox，或者可以访问一台在你的笔记本电脑或云端运行 Docker 的 Linux **虚拟机**（**VM**）。此外，安装
    Docker for Desktop 会更加方便。本章没有配套代码。
- en: Creating and mounting data volumes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和挂载数据卷
- en: All meaningful applications consume or produce data. Yet containers are, preferably,
    meant to be stateless. How are we going to deal with this? One way is to use Docker
    volumes. Volumes allow containers to consume, produce, and modify a state. Volumes
    have a life cycle that goes beyond the life cycle of containers. When a container
    that uses a volume dies, the volume continues to exist. This is great for the
    durability of the state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有意义的应用程序都会消耗或产生数据。然而，容器最好是无状态的。我们将如何处理这个问题呢？一种方法是使用 Docker 卷。卷允许容器消费、生产并修改状态。卷的生命周期超出了容器的生命周期。当使用卷的容器停止时，卷会继续存在。这对状态的持久性非常有利。
- en: Modifying the container layer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改容器层
- en: 'Before we dive into volumes, let''s first discuss what happens if an application
    in a container changes something in the filesystem of the container. In this case,
    the changes are all happening in the writable container layer that we introduced
    in [Chapter 3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering Containers*.
    Let''s quickly demonstrate this by running a container, and execute a script in
    it that is creating a new file, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论卷之前，让我们先讨论一下，如果容器中的应用程序更改了容器文件系统中的某些内容，会发生什么情况。在这种情况下，所有更改都发生在我们在[第 3 章](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml)中介绍的可写容器层中，*掌握容器*。我们通过运行容器并在其中执行一个创建新文件的脚本来快速演示这一点，像这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command creates a container named `demo`, and, inside this container,
    creates a file called `sample.txt` with the content `This is a test`. The container
    exits after running the `echo` command but remains in memory, available for us
    to do our investigations. Let''s use the `diff` command to find out what has changed
    in the container''s filesystem in relation to the filesystem of the original image,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一个名为`demo`的容器，并在该容器内创建了一个名为`sample.txt`的文件，文件内容为`This is a test`。执行完`echo`命令后，容器退出，但仍保留在内存中，方便我们进行调查。接下来，我们可以使用`diff`命令来查看与原始镜像文件系统相比，容器文件系统发生了哪些变化，具体如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output should look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Evidently, a new file, as indicated by the `A`, has been added to the filesystem of
    the container, as expected. Since all layers that stem from the underlying image
    (`alpine`, in this case) are immutable, the change could only happen in the writeable
    container layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如`A`所示，容器的文件系统中添加了一个新文件，这是预期的结果。由于所有来自底层镜像（在本例中为`alpine`）的层都是不可变的，改变只能发生在可写的容器层中。
- en: Files that have changed compared to the original image will be marked with a
    `C`, and those that have been deleted, with a `D`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始镜像相比发生变化的文件将标记为`C`，被删除的文件将标记为`D`。
- en: If we now remove the container from memory, its container layer will also be
    removed, and with it, all the changes will be irreversibly deleted. If we need
    our changes to persist even beyond the lifetime of the container, this is not
    a solution. Luckily, we have better options, in the form of Docker volumes. Let's
    get to know them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在我们从内存中移除容器，它的容器层也将被移除，并且所有更改将不可逆转地被删除。如果我们需要让更改在容器生命周期结束后仍然存在，这不是一个解决方案。幸运的是，我们有更好的选择，即
    Docker 卷。让我们来了解一下它们。
- en: Creating volumes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建卷
- en: 'Since at this time, when using Docker for Desktop on a macOS or Windows computer,
    containers are not running natively on macOS or Windows but rather in a (hidden)
    VM created by Docker for Desktop, for illustrative purposes it is best we use `docker-machine` to
    create and use an explicit VM running Docker. At this point, we assume that you
    have Docker Toolbox installed on your system. If not, then please go back to [Chapter
    2](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml), *Setting up a Working Environment,* where
    we provide detailed instructions on how to install Toolbox:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此时，使用 Docker for Desktop 的 macOS 或 Windows 计算机上，容器并没有在 macOS 或 Windows 上本地运行，而是在
    Docker for Desktop 创建的（隐藏的）虚拟机中运行，为了演示目的，最好使用`docker-machine`创建并使用一个显式运行 Docker
    的虚拟机。此时，我们假设你已经在系统上安装了 Docker Toolbox。如果没有，请返回[第 2 章](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml)中的*设置工作环境*，那里有关于如何安装
    Toolbox 的详细说明：
- en: 'Use `docker-machine` to list all VMs currently running in VirtualBox, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-machine`列出当前在 VirtualBox 中运行的所有虚拟机，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you do not have a VM called `node-1` listed, then please create one with
    the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有名为`node-1`的虚拟机，请使用以下命令创建一个：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refer back to [Chapter 2](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml), *Setting
    up a Working Environment*, on how to create a Hyper-V-based VM with `docker-machine`
    if you are running on Windows with Hyper-V enabled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 上启用了 Hyper-V，可以参考[第 2 章](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml)中关于如何使用`docker-machine`创建基于
    Hyper-V 的虚拟机的说明，*设置工作环境*。
- en: 'If, on the other hand, you have a VM called `node-1` but it is not running,
    then please start it, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果你有一个名为`node-1`的虚拟机，但它没有运行，请启动它，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that everything is ready, use `docker-machine` to SSH into this VM, like
    this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以使用`docker-machine`通过 SSH 连接到这个虚拟机，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should be greeted by this welcome image:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到这个欢迎图片：
- en: '![](img/223cb246-5c36-42aa-8905-22913d6642ba.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/223cb246-5c36-42aa-8905-22913d6642ba.png)'
- en: docker-machine VM welcome message
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: docker-machine 虚拟机欢迎消息
- en: 'To create a new data volume, we can use the `docker volume create` command.
    This will create a named volume that can then be mounted into a container and
    used for persistent data access or storage. The following command creates a volume
    called `sample`, using the default volume driver:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的数据卷，我们可以使用`docker volume create`命令。此命令将创建一个命名的卷，可以将其挂载到容器中，用于持久化数据访问或存储。以下命令创建一个名为`sample`的卷，使用默认的卷驱动程序：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The default volume driver is the so-called local driver, which stores the data
    locally in the host filesystem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的卷驱动程序是所谓的本地驱动程序，它将数据存储在主机文件系统中。
- en: 'The easiest way to find out where the data is stored on the host is by using
    the `docker volume inspect` command on the volume we just created. The actual
    location can differ from system to system, and so, this is the safest way to find
    the target folder. You can see this command in the following code block:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找数据在主机上存储位置的最简单方法是使用 `docker volume inspect` 命令查看我们刚创建的卷。实际位置因系统而异，因此这是找到目标文件夹的最安全方式。你可以在下面的代码块中看到这个命令：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The host folder can be found in the output under `Mountpoint`. In our case,
    when using `docker-machine` with a LinuxKit-based VM running in VirtualBox, the
    folder is `/mnt/sda1/var/lib/docker/volumes/sample/_data`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主机文件夹可以在输出中的 `Mountpoint` 下找到。在我们的情况下，当使用 `docker-machine` 并在 VirtualBox 中运行基于
    LinuxKit 的虚拟机时，该文件夹是 `/mnt/sda1/var/lib/docker/volumes/sample/_data`。
- en: The target folder is often a protected folder, and we thus might need to use `sudo` to
    navigate to this folder and execute any operations in it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件夹通常是受保护的文件夹，因此我们可能需要使用 `sudo` 来导航到该文件夹并执行任何操作。
- en: On our LinuxKit-based VM in Docker Toolbox, access is also denied, yet we don't
    have `sudo` available either. Is that the end of our exploration?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们基于 LinuxKit 的 Docker Toolbox 虚拟机中，访问也被拒绝，且我们没有 `sudo` 权限。难道这就意味着我们的探索到此为止了吗？
- en: Luckily not; I have prepared a `fundamentalsofdocker/nsenter` utility container that
    allows us to access the backing folder of our `sample` volume we created earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，没有；我已经准备了一个 `fundamentalsofdocker/nsenter` 工具容器，它允许我们访问之前创建的 `sample` 卷的后备文件夹。
- en: 'We need to run this container in `privileged` mode to get access to this protected
    part of the filesystem, like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以 `privileged` 模式运行此容器，以便访问文件系统中的受保护部分，像这样：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are running the container with the `--privileged` flag. This means that any
    app running in the container gets access to the devices of the host. The `--pid=host` flag
    signifies that the container is allowed to access the process tree of the host
    (the hidden VM in which the Docker daemon is running). Now, the preceding container
    runs the Linux `nsenter` tool to enter the Linux namespace of the host and then
    runs a shell within there. From this shell, we are thus granted access to all
    resources managed by the host.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在以 `--privileged` 标志运行容器。这意味着在容器中运行的任何应用都可以访问主机的设备。`--pid=host` 标志表示容器可以访问主机的进程树（即
    Docker 守护进程运行的隐藏虚拟机）。现在，前述容器运行 Linux `nsenter` 工具以进入主机的 Linux 命名空间，并在其中运行一个 shell。通过这个
    shell，我们被授予访问主机管理的所有资源的权限。
- en: 'When running the container, we basically execute the following command inside
    the container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器时，我们基本上在容器内执行以下命令：
- en: '`nsenter -t 1 -m -u -n -i sh`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsenter -t 1 -m -u -n -i sh`'
- en: If that sounds complicated to you, don't worry; you will understand more as
    we proceed through this book. If there is one takeaway for you out of this, then
    it is to realize how powerful the right use of containers can be.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，不用担心；随着我们继续阅读这本书，你会理解得更多。如果你从中能获得一个收获，那就是要意识到正确使用容器有多么强大。
- en: 'From within this container, we can now navigate to the folder representing
    the mount point of the volume, and then list its content, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个容器内，我们现在可以导航到表示卷挂载点的文件夹，并列出其内容，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The folder is currently empty since we have not yet stored any data in the volume.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹当前是空的，因为我们尚未在卷中存储任何数据。
- en: Exit the tool container by pressing *Ctrl* + *D*.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *D* 键退出工具容器。
- en: There are other volume drivers available from third parties, in the form of
    plugins. We can use the `--driver` parameter in the `create` command to select
    a different volume driver. Other volume drivers use different types of storage
    systems to back a volume, such as cloud storage, **Network File System** (**NFS**)
    drives, software-defined storage, and more. The discussion of the correct usage
    of other volume drivers is beyond the scope of this book, though.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他第三方卷驱动程序，作为插件的形式提供。我们可以在 `create` 命令中使用 `--driver` 参数来选择不同的卷驱动程序。其他卷驱动程序使用不同类型的存储系统来支持卷，例如云存储、**网络文件系统**（**NFS**）驱动、软件定义存储等。然而，其他卷驱动程序的正确使用讨论超出了本书的范围。
- en: Mounting a volume
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载卷
- en: 'Once we have created a named volume, we can mount it into a container by following
    these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个命名卷，就可以按照以下步骤将其挂载到容器中：
- en: 'For this, we can use the `-v` parameter in the `docker container run` command,
    like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们可以在 `docker container run` 命令中使用 `-v` 参数，像这样：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command mounts the `sample` volume to the `/data` folder inside
    the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`sample`卷挂载到容器内的`/data`文件夹。
- en: 'Inside the container, we can now create files in the `/data` folder and then
    exit, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内，我们现在可以在`/data`文件夹中创建文件，然后退出，如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we navigate to the host folder that contains the data of the volume and
    list its content, we should see the two files we just created inside the container
    (remember: we need to use the `fundamentalsofdocker/nsenter` tool container to
    do so), as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们导航到包含卷数据的宿主机文件夹并列出其内容，我们应该能看到我们刚刚在容器内创建的两个文件（记住：我们需要使用`fundamentalsofdocker/nsenter`工具容器来执行此操作），如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can even try to output the content of, say, the second file, like this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以尝试输出第二个文件的内容，像这样：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try to create a file in this folder from the host, and then use the
    volume with another container, like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试从宿主机在此文件夹中创建一个文件，然后使用该卷在另一个容器中，像这样：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Exit the tool container by pressing *Ctrl* + *D*.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *D*退出工具容器。
- en: 'Now, let''s delete the `test` container, and run another one based on CentOS.
    This time, we are even mounting our volume to a different container folder, `/app/data`,
    like this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除`test`容器，并运行另一个基于CentOS的容器。这次，我们甚至将我们的卷挂载到另一个容器文件夹`/app/data`，像这样：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once inside the `centos` container, we can navigate to the `/app/data` folder
    to which we have mounted the volume, and list its content, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`centos`容器后，我们可以导航到挂载了卷的`/app/data`文件夹，并列出其内容，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As expected, we should see these three files:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们应该能看到这三个文件：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the definitive proof that data in a Docker volume persists beyond the
    lifetime of a container, and also, that volumes can be reused by other, even different,
    containers from the one that used it first.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据在Docker卷中超出容器生命周期存储的最终证明，同时也表明卷可以被其他容器甚至不同于第一个使用它的容器重用。
- en: It is important to note that the folder inside the container to which we mount
    a Docker volume is excluded from the Union filesystem. That is, each change inside
    this folder and any of its subfolders will not be part of the container layer,
    but will be persisted in the backing storage provided by the volume driver. This
    fact is really important since the container layer is deleted when the corresponding
    container is stopped and removed from the system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意的是，我们挂载Docker卷到容器内的文件夹被排除在联合文件系统之外。也就是说，容器内该文件夹及其任何子文件夹中的所有更改都不会成为容器层的一部分，而是会保存在卷驱动程序提供的后端存储中。这个事实非常重要，因为容器层在对应容器停止并从系统中删除时会被删除。
- en: Exit the `centos` container with *Ctrl* + *D*. Now, exit the `node-1` VM by
    pressing *Ctrl* + *D* again.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *D*退出`centos`容器。现在，再次按*Ctrl* + *D*退出`node-1`虚拟机。
- en: Removing volumes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除卷
- en: 'Volumes can be removed using the `docker volume rm` command. It is important
    to remember that removing a volume destroys the containing data irreversibly,
    and thus is to be considered a dangerous command. Docker helps us a bit in this
    regard, as it does not allow us to delete a volume that is still in use by a container.
    Always make sure before you remove or delete a volume that you either have a backup
    of its data or you really don''t need this data anymore. Let''s see how to remove
    volumes by following these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`docker volume rm`命令删除卷。需要注意的是，删除卷会不可逆转地销毁其中的数据，因此应该视为一个危险命令。在这方面，Docker稍微提供了帮助，因为它不允许删除仍在容器中使用的卷。在删除卷之前，请始终确保你要么已经备份了它的数据，要么真的不再需要这些数据。让我们按照以下步骤来看如何删除卷：
- en: 'The following command deletes our `sample` volume that we created earlier:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令删除我们之前创建的`sample`卷：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After executing the preceding command, double-check that the folder on the host
    has been deleted.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行上述命令后，双重检查宿主机上的文件夹是否已被删除。
- en: 'To remove all running containers in order to clean up the system, run the following
    command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理系统，删除所有正在运行的容器，请执行以下命令：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that by using the `-v` or `--volume` flag in the command you use to remove
    a container, you can ask the system to also remove any volume associated with
    that particular container. Of course, that will only work if the particular volume
    is only used by this container.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过在删除容器时使用`-v`或`--volume`标志，你可以要求系统同时删除与该容器相关联的任何卷。当然，这仅在该卷仅被该容器使用时有效。
- en: In the next section, we will show how we can access the backing folder of a
    volume when working with Docker for Desktop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何在使用Docker for Desktop时访问卷的底层文件夹。
- en: Accessing volumes created with Docker for Desktop
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Docker for Desktop创建的卷
- en: 'Follow these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: 'Let''s create a `sample` volume and inspect it using Docker for Desktop on
    our macOS or Windows machine, like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`sample`卷，并在我们的macOS或Windows机器上使用Docker for Desktop对其进行检查，像这样：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Mountpoint` is shown as `/var/lib/docker/volumes/sample/_data`, but you
    will discover that there is no such folder on your macOS or Windows machine. The
    reason is that the path shown is in relation to the hidden VM that Docker for
    Windows uses to run containers. At this time, Linux containers cannot run natively
    on macOS, nor on Windows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mountpoint`显示为`/var/lib/docker/volumes/sample/_data`，但你会发现，在你的macOS或Windows机器上并没有这样的文件夹。原因是，显示的路径是相对于Docker
    for Windows用来运行容器的隐藏虚拟机而言的。此时，Linux容器无法在macOS或Windows上原生运行。'
- en: 'Next, let''s generate two files with data in the volume from within an `alpine`
    container. To run the container and mount the sample `volume` to the `/data` folder
    of the container, use the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`alpine`容器中生成两个文件，文件存储在卷中。要运行容器并将示例`volume`挂载到容器的`/data`文件夹中，请使用以下代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Generate two files in the `/data` folder inside the container, like this:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器的`/data`文件夹中生成两个文件，像这样：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exit the `alpine` container by pressing *Ctrl + D*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl + D*退出`alpine`容器。
- en: As mentioned earlier, we cannot directly access the backing folder of the `sample`
    volume from our macOS or from Windows. This is because the volume is in the hidden
    VM running on macOS or Windows that is used to run the Linux container in Docker
    for Desktop.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不能直接从macOS或Windows访问`sample`卷的底层文件夹。因为该卷位于在macOS或Windows上运行Docker for
    Desktop的隐藏虚拟机中。
- en: To access that hidden VM from our macOS, we have two options. We can either
    use a special container and run it in privileged mode, or we can use the `screen`
    utility to screen into the Docker driver. The first method is also applicable
    to Docker for Windows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要从macOS访问那个隐藏虚拟机，我们有两种选择。我们可以使用一个特殊容器并以特权模式运行它，或者使用`screen`工具进入Docker驱动程序。第一种方法同样适用于Docker
    for Windows。
- en: 'Let''s start with the first method mentioned, by running a container from the `fundamentalsofdocker/nsenter` image.
    We have been using this container already in the previous section. Run the following
    code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从提到的第一种方法开始，通过运行来自`fundamentalsofdocker/nsenter`镜像的容器。我们已经在上一节中使用了这个容器。运行以下代码：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now navigate to the folder backing our `sample` volume, like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以像这样导航到支撑`sample`卷的文件夹：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s see what is in this folder by running this code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行这段代码来查看这个文件夹中的内容：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s try to create a file from within this special container, and then list
    the content of the folder, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试从这个特殊的容器中创建一个文件，然后列出文件夹的内容，如下所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And now, we have the files in the backing folder of the `sample` volume.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在`sample`卷的底层文件夹中得到了文件。
- en: To exit our special privileged container, we can just press *Ctrl* + *D*.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出我们的特权容器，只需按*Ctrl* + *D*。
- en: 'Now that we have explored the first option, and if you''re using macOS, let''s
    try the `screen` tool, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们探讨了第一种方法之后，如果你正在使用macOS，让我们尝试使用`screen`工具，如下所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By doing so, we will be greeted by an empty screen. Hit *Enter*, and a `docker-desktop:~#` command-line
    prompt will be displayed. We can now navigate to the volume folder, like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做后，我们将看到一个空白屏幕。按*Enter*键，会显示一个`docker-desktop:~#`命令行提示符。我们现在可以像这样导航到卷文件夹：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create another file with some data in it, and then list the content
    of the folder, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个包含数据的文件，然后列出文件夹的内容，如下所示：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To exit this session with the Docker VM, press *Ctrl* + *A* + *K*.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出与Docker虚拟机的会话，请按*Ctrl* + *A* + *K*。
- en: 'We have now created data using three different methods, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经通过三种不同的方法创建了数据，如下所示：
- en: From within a container that has a `sample` volume mounted.
  id: totrans-128
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从挂载了`sample`卷的容器内部进行操作。
- en: Using a special privileged folder to access the hidden VM used by Docker for
    Desktop, and directly writing into the backing folder of the `sample` volume.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个特殊的特权文件夹来访问Docker for Desktop使用的隐藏虚拟机，并直接写入`sample`卷的底层文件夹。
- en: Only on macOS, using the `screen` utility to enter into the hidden VM, and also directly
    writing into the backing folder of the `sample` volume.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在macOS上，使用`screen`工具进入隐藏虚拟机，并直接写入`sample`卷的底层文件夹。
- en: Sharing data between containers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器之间共享数据
- en: Containers are like sandboxes for the applications running inside them. This
    is mostly beneficial and wanted, in order to protect applications running in different
    containers from each other. It also means that the whole filesystem visible to
    an application running inside a container is private to this application, and
    no other application running in a different container can interfere with it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 容器就像运行在其中的应用程序的沙箱。这通常是有益的，并且是期望的，以保护不同容器中运行的应用程序不相互干扰。它还意味着，容器中运行的应用程序所能看到的整个文件系统是该应用程序私有的，其他容器中的应用程序无法干扰它。
- en: At times, though, we want to share data between containers. Say an application
    running in container A produces some data that will be consumed by another application
    running in container B. *How can we achieve this?* Well, I'm sure you've already
    guessed it—we can use Docker volumes for this purpose. We can create a volume
    and mount it to container A, as well as to container B. In this way, both applications
    A and B have access to the same data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们希望在容器之间共享数据。假设容器A中运行的应用程序生成了一些数据，这些数据将被容器B中运行的另一个应用程序使用。*我们如何实现这一目标？*
    你肯定已经猜到了——我们可以使用Docker卷来实现这个目的。我们可以创建一个卷，并将其挂载到容器A和容器B。这样，应用程序A和B都能访问相同的数据。
- en: 'Now, as always when multiple applications or processes concurrently access
    data, we have to be very careful to avoid inconsistencies. To avoid concurrency
    problems such as race conditions, we ideally have only one application or process
    that is creating or modifying data, while all other processes concurrently accessing
    this data only read it. We can enforce a process running in a container to only
    be able to read the data in a volume by mounting this volume as read-only. Have
    a look at the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如多种应用程序或进程同时访问数据时总是需要注意的，我们必须非常小心以避免不一致性。为了避免并发问题，如竞态条件，理想情况下我们应该只有一个应用程序或进程在创建或修改数据，而所有其他并发访问该数据的进程只能读取数据。我们可以通过将此卷挂载为只读来强制在容器中运行的进程仅能读取数据。请看下面的命令：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we create a container called `writer` that has a volume, `shared-data`,
    mounted in default read/write mode:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个名为`writer`的容器，该容器有一个名为`shared-data`的卷，挂载在默认的读/写模式下：
- en: 'Try to create a file inside this container, like this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在此容器中创建一个文件，如下所示：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It should succeed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会成功。
- en: 'Exit this container, and then execute the following command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出此容器，然后执行以下命令：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And we have a container called `reader` that has the same volume mounted as **read-only** (`ro`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们有一个名为`reader`的容器，它将相同的卷挂载为**只读**（`ro`）。
- en: 'Firstly, make sure you can see the file created in the first container, like
    this:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保你能在第一个容器中看到创建的文件，如下所示：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, try to create a file, like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试创建一个文件，如下所示：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It will fail with the following message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以以下错误信息失败：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s exit the container by typing `exit` at the Command Prompt. Back on the
    host, let''s clean up all containers and volumes, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在命令提示符下输入`exit`来退出容器。返回主机后，让我们清理所有容器和卷，如下所示：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once this is done, exit the `docker-machine` VM by also typing `exit` at the
    Command Prompt. You should be back on your Docker for Desktop. Use `docker-machine` to
    stop the VM, like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，通过在命令提示符下输入`exit`退出`docker-machine`虚拟机。你应该回到你的Docker for Desktop。使用`docker-machine`停止虚拟机，如下所示：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we will show how to mount arbitrary folders from the Docker host into
    a container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何将任意文件夹从Docker主机挂载到容器中。
- en: Using host volumes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机卷
- en: 'In certain scenarios, such as when developing new containerized applications
    or when a containerized application needs to consume data from a certain folder
    produced—say—by a legacy application, it is very useful to use volumes that mount
    a specific host folder. Let''s look at the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，比如开发新的容器化应用程序，或者当一个容器化应用程序需要消费某个由旧版应用程序生成的文件夹中的数据时，使用挂载特定主机文件夹的卷非常有用。让我们看以下示例：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding expression interactively starts an `alpine` container with a shell
    and mounts the `src` subfolder of the current directory into the container at `/app/src`.
    We need to use `$(pwd)` (or `` `pwd` ``, for that matter), which is the current
    directory, as when working with volumes, we always need to use absolute paths.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式交互式地启动一个`alpine`容器并打开一个shell，并将当前目录的`src`子文件夹挂载到容器中的`/app/src`。我们需要使用`$(pwd)`（或者``
    `pwd` ``，也可以）作为当前目录，因为在使用卷时，我们总是需要使用绝对路径。
- en: Developers use these techniques all the time when they are working on their
    application that runs in a container, and want to make sure that the container
    always contains the latest changes they make to the code, without the need to
    rebuild the image and rerun the container after each change.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在工作时经常使用这些技巧，当他们的应用程序在容器中运行时，并且希望确保容器始终包含他们对代码所做的最新更改，而无需在每次更改后重新构建镜像并重新运行容器。
- en: 'Let''s make a sample to demonstrate how that works. Let''s say we want to create
    a simple static website using nginx as our web server as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个示例来演示这一过程。假设我们想要使用nginx作为我们的Web服务器来创建一个简单的静态网站，如下所示：
- en: 'First, let''s create a new folder on the host, where we will put our web assets—such
    as HTML, CSS, and JavaScript files—and navigate to it, like this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在主机上创建一个新文件夹，在其中放置我们的网页资源——例如HTML、CSS和JavaScript文件——并导航到该文件夹，像这样：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we create a simple web page, like this:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们创建一个简单的网页，像这样：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we add a `Dockerfile` that will contain instructions on how to build the
    image containing our sample website.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加一个`Dockerfile`，该文件将包含如何构建包含我们示例网站的镜像的指令。
- en: 'Add a file called `Dockerfile` to the folder, with this content:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件夹中添加一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Dockerfile` starts with the latest Alpine version of nginx, and then copies
    all files from the current host directory into the `/usr/share/nginx/html` containers
    folder. This is where nginx expects web assets to be located.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`从最新版本的Alpine nginx开始，然后将当前主机目录中的所有文件复制到`/usr/share/nginx/html`容器文件夹中。这是nginx期望网页资源所在的位置。'
- en: 'Now, let''s build the image with the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用以下命令构建镜像：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And finally, we run a container from this image. We will run the container
    in detached mode, like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从这个镜像运行一个容器。我们将以分离模式运行容器，像这样：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note the `-p 8080:80` parameter. We haven't discussed this yet, but we will
    do it in detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *Single-Host
    Networking*. At the moment, just know that this maps the container port `80` on
    which nginx is listening for incoming requests to port `8080` of your laptop,
    where you can then access the application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`-p 8080:80`参数。我们还没有讨论过这个内容，但我们将在[第10章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)中详细讲解，*单主机网络*。目前，只需知道这将`nginx`监听的容器端口`80`映射到你笔记本电脑的`8080`端口，你可以在该端口访问应用程序。
- en: Now, open a browser tab and navigate to `http://localhost:8080/index.html`,
    and you should see your website, which currently consists only of a title, `Personal
    Website`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开浏览器标签页，导航到`http://localhost:8080/index.html`，你应该能看到你的网站，当前只包含一个标题，`个人网站`。
- en: 'Now, edit the `index.html` file in your favorite editor, to look like this:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你喜欢的编辑器中编辑`index.html`文件，使其看起来像这样：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, save it, and then refresh the browser. Oh! That didn''t work. The browser
    still displays the previous version of the `index.html` file, which consists only
    of the title. So, let''s stop and remove the current container, then rebuild the
    image, and rerun the container, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存文件，然后刷新浏览器。哦！那没有成功。浏览器仍然显示先前版本的`index.html`文件，仅包含标题。所以，让我们停止并移除当前容器，然后重新构建镜像并重新运行容器，如下所示：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This time, when you refresh the browser, the new content should be shown. Well,
    it worked, but there is way too much friction involved. Imagine you have to do
    this each and every time that you make a simple change to your website. That's
    not sustainable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当你刷新浏览器时，新的内容应该会显示出来。好吧，成功了，但涉及的步骤太多了。想象一下，每次对你的网站做出简单更改时，都必须这么操作。这是不可持续的。
- en: 'Now is the time to use host-mounted volumes. Once again, remove the current
    container and rerun it with the volume mount, like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候使用主机挂载卷了。再次移除当前容器，并使用挂载卷重新运行容器，像这样：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, append some more content to the `index.html` file, and save it. Then, refresh
    your browser. You should see the changes. And this is exactly what we wanted to
    achieve; we also call this an *edit-and-continue* experience. You can make as
    many changes in your web files and always immediately see the result in the browser,
    without having to rebuild the image and restart the container containing your
    website.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向`index.html`文件中添加更多内容，并保存它。然后，刷新浏览器。你应该能看到变化。这正是我们想要实现的目标；我们也称之为*编辑并继续*的体验。你可以在网页文件中做任意修改，并且始终能立即在浏览器中看到结果，而无需重新构建镜像并重启包含你网站的容器。
- en: It is important to note that the updates are now propagated bi-directionally.
    If you make changes on the host, they will be propagated to the container, and
    vice versa. Also important is the fact that when you mount the current folder
    into the container target folder, `/usr/share/nginx/html`, the content that is
    already there is replaced by the content of the host folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，更新现在是双向传播的。如果你在主机上进行更改，它们会传播到容器中，反之亦然。同样重要的是，当你将当前文件夹挂载到容器目标文件夹`/usr/share/nginx/html`时，原本在那里已存在的内容将被主机文件夹的内容替换。
- en: Defining volumes in images
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在镜像中定义卷
- en: 'If we go for a moment back to what we have learned about containers in [Chapter
    3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering Containers,* then we
    have this: the filesystem of each container, when started, is made up of the immutable
    layers of the underlying image, plus a writable container layer specific to this
    very container. All changes that the processes running inside the container make
    to the filesystem will be persisted in this container layer. Once the container
    is stopped and removed from the system, the corresponding container layer is deleted
    from the system and irreversibly lost.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到[第3章](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml)，*容器掌握*，我们已经学到的内容，那么我们会发现：每个容器的文件系统，在启动时，由底层镜像的不可变层组成，再加上一个只针对该容器的可写容器层。容器内运行的进程对文件系统所做的所有更改都会保存在这个容器层中。一旦容器停止并从系统中移除，相应的容器层也会从系统中删除，并且不可恢复地丢失。
- en: Some applications, such as databases running in containers, need to persist
    their data beyond the lifetime of the container. In this case, they can use volumes.
    To make things a bit more explicit, let's look at a concrete example. MongoDB
    is a popular open source document database. Many developers use MongoDB as a storage
    service for their applications. The maintainers of MongoDB have created an image
    and published it on Docker Hub, which can be used to run an instance of the database
    in a container. This database will be producing data that needs to be persisted
    long term, but the MongoDB maintainers do not know who uses this image and how
    it is used. So, they have no influence over the `docker container run` command
    with which the users of the database will start this container. *How can they
    now define volumes?*
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序，如在容器中运行的数据库，需要在容器生命周期之外持久化它们的数据。在这种情况下，它们可以使用卷。为了让事情更加明确，我们来看一个具体的例子。MongoDB
    是一个流行的开源文档数据库。许多开发者将 MongoDB 作为他们应用程序的存储服务。MongoDB 的维护者创建了一个镜像，并将其发布到 Docker Hub
    上，可以用来在容器中运行数据库实例。这个数据库会生成需要长期持久化的数据，但 MongoDB 的维护者并不知道谁在使用这个镜像以及如何使用它。因此，他们无法影响用户启动容器时使用的`docker
    container run`命令。*那么，他们该如何定义卷呢？*
- en: 'Luckily, there is a way of defining volumes in the `Dockerfile`. The keyword
    to do so is `VOLUME`, and we can either add the absolute path to a single folder
    or a comma-separated list of paths. These paths represent folders of the container''s
    filesystem. Let''s look at a few samples of such volume definitions, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以在`Dockerfile`中定义卷。实现这一点的关键字是`VOLUME`，我们可以将单个文件夹的绝对路径或以逗号分隔的路径列表添加到其中。这些路径表示容器文件系统中的文件夹。我们来看几个这样的卷定义示例，如下所示：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first line in the preceding snippet defines a single volume to be mounted
    at `/app/data`. The second line defines three volumes as a comma-separated list.
    The last one defines the same as the second line, but this time, the value is
    formatted as a JSON array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的第一行定义了一个要挂载到`/app/data`的单个卷。第二行定义了三个卷，并以逗号分隔的列表形式表示。最后一行定义了与第二行相同的内容，但这次，值的格式是一个
    JSON 数组。
- en: When a container is started, Docker automatically creates a volume and mounts
    it to the corresponding target folder of the container for each path defined in
    the `Dockerfile`. Since each volume is created automatically by Docker, it will
    have an SHA-256 as its ID.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动容器时，Docker 会自动创建一个卷并将其挂载到`Dockerfile`中定义的每个路径的对应目标文件夹。由于每个卷都是由 Docker 自动创建的，它将拥有一个
    SHA-256 作为其 ID。
- en: At container runtime, the folders defined as volumes in the `Dockerfile` are
    excluded from the Union filesystem, and thus any changes in those folders do not
    change the container layer but are persisted to the respective volume. It is now
    the responsibility of the operations engineers to make sure that the backing storage
    of the volumes is properly backed up.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器运行时，`Dockerfile`中定义的作为卷的文件夹被排除在联合文件系统之外，因此对这些文件夹的任何更改不会改变容器层，而是会被持久化到相应的卷中。现在，确保卷的后端存储得到妥善备份是运维工程师的责任。
- en: 'We can use the `docker image inspect` command to get information about the
    volumes defined in the `Dockerfile`. Let''s see what MongoDB gives us by following
    these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker image inspect`命令获取有关`Dockerfile`中定义的卷的信息。让我们通过以下步骤查看MongoDB给我们的信息：
- en: 'First, we pull the image with the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用以下命令拉取镜像：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we inspect this image, and use the `--format` parameter to only extract
    the essential part from the massive amount of data, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查此镜像，并使用`--format`参数从大量数据中仅提取必要部分，如下所示：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note the `| jq .` at the end of the command. We are piping the output of `docker
    image inspect` into the `jq` tool, which nicely formats the output. If you haven't
    installed `jq` yet on your system, you can do so with `brew install jq` on your
    macOS, or with `choco install jq` on Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令末尾的`| jq .`。我们将`docker image inspect`的输出通过管道传递给`jq`工具，后者可以很好地格式化输出。如果你还没有在系统上安装`jq`，你可以通过在macOS上使用`brew
    install jq`，或者在Windows上使用`choco install jq`来安装。
- en: 'The preceding command will return the following result:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令将返回以下结果：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Evidently, the `Dockerfile` for MongoDB defines two volumes at `/data/configdb` and `/data/db`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，MongoDB的`Dockerfile`定义了两个卷，分别是`/data/configdb`和`/data/db`。
- en: 'Now, let''s run an instance of MongoDB in the background as a daemon, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在后台作为守护进程运行一个MongoDB实例，如下所示：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can now use the `docker container inspect` command to get information about
    the volumes that have been created, among other things.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`docker container inspect`命令获取有关已创建卷的信息，等等。
- en: 'Use this command to just get the volume information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令仅获取卷的信息：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding command should output something like this (shortened):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令应该会输出类似以下内容（已缩短）：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the values of the `Name` and `Source` fields have been trimmed for
    readability. The `Source` field gives us the path to the host directory, where
    the data produced by the MongoDB inside the container will be stored.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Name`和`Source`字段的值已被裁剪以提高可读性。`Source`字段为我们提供了主机目录的路径，其中MongoDB在容器内生成的数据将被存储。
- en: That's it for the moment about volumes. In the next section, we will explore
    how we can configure applications running in containers, and the container image
    build process itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前关于卷的内容就这些。在下一部分，我们将探讨如何配置在容器中运行的应用程序，以及容器镜像构建过程本身。
- en: Configuring containers
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置容器
- en: More often than not, we need to provide some configuration to the application
    running inside a container. The configuration is often used to allow one and the
    same container to run in very different environments, such as in development,
    test, staging, or production environments.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要为运行在容器中的应用程序提供一些配置。这些配置通常用于使同一个容器能够在非常不同的环境中运行，如开发、测试、预生产或生产环境。
- en: In Linux, configuration values are often provided via environment variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，配置值通常通过环境变量提供。
- en: We have learned that an application running inside a container is completely
    shielded from its host environment. Thus, the environment variables that we see
    on the host are different from the ones that we see from within a container.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，运行在容器中的应用程序与其主机环境是完全隔离的。因此，我们在主机上看到的环境变量与我们在容器内部看到的不同。
- en: 'Let''s prove that by first looking at what is defined on our host:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过首先查看我们主机上定义的内容来证明这一点：
- en: 'Use this command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'On my macOS, I see something like this (shortened):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的macOS上，我看到类似以下内容（已缩短）：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, let''s run a shell inside an `alpine` container, and list the environment
    variables we see there, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在一个`alpine`容器中运行一个shell，并列出我们在那里看到的环境变量，如下所示：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding output we see from the `export` command is evidently totally different
    than what we saw directly on the host.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`export`命令看到的前述输出显然与我们直接在主机上看到的完全不同。
- en: Hit *Ctrl* + *D* to leave the `alpine` container.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *D*离开`alpine`容器。
- en: Next, let's define environment variables for containers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为容器定义环境变量。
- en: Defining environment variables for containers
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为容器定义环境变量
- en: 'Now, the good thing is that we can actually pass some configuration values
    into the container at start time. We can use the `--env` (or the short form, `-e`)
    parameter in the form `--env <key>=<value>` to do so, where `<key>` is the name
    of the environment variable and `<value>` represents the value to be associated
    with that variable. Let''s assume we want the app that is to be run in our container
    to have access to an environment variable called `LOG_DIR`, with the value `/var/log/my-log`.
    We can do so with this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好消息是我们实际上可以在容器启动时传递一些配置值。我们可以使用`--env`（或者简写形式`-e`）参数，格式为`--env <key>=<value>`来实现，其中，`<key>`是环境变量的名称，而`<value>`表示要与该变量关联的值。假设我们希望容器中运行的应用程序能够访问名为`LOG_DIR`的环境变量，值为`/var/log/my-log`。我们可以使用以下命令来实现：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code starts a shell in an `alpine` container and defines the
    requested environment inside the running container. To prove that this is true,
    we can execute this command inside the `alpine` container:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在`alpine`容器中启动一个shell，并在运行中的容器内定义所需的环境。为了证明这一点，我们可以在`alpine`容器内执行以下命令：
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The output looks as expected. We now indeed have the requested environment variable
    with the correct value available inside the container.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如预期所示。现在，我们确实在容器内获得了所需的环境变量，并且值是正确的。
- en: 'We can, of course, define more than just one environment variable when we run
    a container. We just need to repeat the `--env` (or `-e`) parameter. Have a look
    at this sample:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在运行容器时可以定义多个环境变量。我们只需要重复`--env`（或`-e`）参数。请看这个示例：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we do a list of the environment variables now, we see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在列出环境变量，我们会看到以下内容：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let's now look at situations where we have many environment variables to configure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下当我们需要配置多个环境变量时的情况。
- en: Using configuration files
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置文件
- en: Complex applications can have many environment variables to configure, and thus
    our command to run the corresponding container can quickly become unwieldy. For
    this purpose, Docker allows us to pass a collection of environment variable definitions
    as a file, and we have the `--env-file` parameter in the `docker container run` command.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的应用程序可能需要配置多个环境变量，因此我们运行相应容器的命令可能会迅速变得难以管理。为此，Docker允许我们将一组环境变量定义传递为一个文件，我们可以在`docker
    container run`命令中使用`--env-file`参数。
- en: 'Let''s try this out, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下，操作如下：
- en: 'Create a `fod/05` folder and navigate to it, like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fod/05`文件夹并进入该文件夹，如下所示：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use your favorite editor to create a file called `development.config` in this
    folder. Add the following content to the file, and save it, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器，在这个文件夹中创建一个名为`development.config`的文件。将以下内容添加到文件中并保存，如下所示：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice how we have the definition of a single environment variable per line
    in the format `<key>=<value>`, where, once again, `<key>` is the name of the environment
    variable, and `<value>` represents the value to be associated with that variable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们每行定义一个环境变量，格式为`<key>=<value>`，其中，`<key>`是环境变量的名称，而`<value>`表示要与该变量关联的值。
- en: 'Now, from within the `fod/05` folder, let''s run an `alpine` container, pass
    the file as an environment file, and run the `export` command inside the container
    to verify that the variables listed inside the file have indeed been created as
    environment variables inside the container, like this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`fod/05`文件夹内，让我们运行一个`alpine`容器，传递该文件作为环境文件，并在容器内运行`export`命令，以验证文件中列出的变量是否确实已经作为环境变量在容器内创建，如下所示：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And indeed, the variables are defined, as we can see in the output generated:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，变量已经被定义，我们可以在生成的输出中看到：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, let's look at how to define default values for environment variables that
    are valid for all container instances of a given Docker image.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下如何为给定Docker镜像的所有容器实例定义有效的环境变量默认值。
- en: Defining environment variables in container images
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器镜像中定义环境变量
- en: 'Sometimes, we want to define some default value for an environment variable
    that must be present in each container instance of a given container image. We
    can do so in the `Dockerfile` that is used to create that image by following these
    steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望为某个必须在给定容器镜像的每个容器实例中存在的环境变量定义一些默认值。我们可以通过以下步骤，在用于创建该镜像的`Dockerfile`中做到这一点：
- en: 'Use your favorite editor to create a file called `Dockerfile` in the `~/fod/05` folder.
    Add the following content to the file, and save it:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你最喜欢的编辑器在 `~/fod/05` 文件夹中创建一个名为 `Dockerfile` 的文件。将以下内容添加到该文件并保存：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a container image called `my-alpine` using the preceding `Dockerfile`,
    as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的 `Dockerfile` 创建一个名为 `my-alpine` 的容器镜像，如下所示：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run a container instance from this image that outputs the environment variables
    defined inside the container, like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个镜像运行一个容器实例，输出容器内定义的环境变量，像这样：
- en: '[PRE68]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is exactly what we would have expected.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的结果。
- en: 'The good thing, though, is that we are not stuck with those variable values
    at all. We can override one or many of them, using the `--env` parameter in the
    `docker container run` command. Have a look at the following command and its output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，好的地方在于，我们完全不必被这些变量值所限制。我们可以通过在 `docker container run` 命令中使用 `--env` 参数来覆盖其中一个或多个变量。看看以下命令及其输出：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can also override default values, using environment files together with the
    `--env-file` parameter in the `docker container run` command. Please try it out
    for yourself.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过环境文件结合 `docker container run` 命令中的 `--env-file` 参数来覆盖默认值。请自己尝试一下。
- en: Environment variables at build time
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建时的环境变量
- en: 'Sometimes, we would want to have the possibility to define some environment
    variables that are valid at the time when we build a container image. Imagine
    that you want to define a `BASE_IMAGE_VERSION` environment variable that shall
    then be used as a parameter in your `Dockerfile`. Imagine the following `Dockerfile`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望能够定义一些在构建容器镜像时有效的环境变量。假设你想定义一个 `BASE_IMAGE_VERSION` 环境变量，并且这个变量将作为参数在
    `Dockerfile` 中使用。假设以下是一个 `Dockerfile`：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We are using the `ARG` keyword to define a default value that is used each time
    we build an image from the preceding `Dockerfile`. In this case, that means that
    our image uses the `node:12.7-stretch` base image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ARG` 关键字来定义一个默认值，每次从前面的 `Dockerfile` 构建镜像时都会使用这个默认值。在这种情况下，这意味着我们的镜像使用的是
    `node:12.7-stretch` 基础镜像。
- en: 'Now, if we want to create a special image for—say—testing purposes, we can
    override this variable at image build time using the `--build-arg` parameter,
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要为测试目的创建一个特殊的镜像，我们可以在镜像构建时使用 `--build-arg` 参数覆盖这个变量，像这样：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this case, the resulting `my-node-test:latest` image will be built from the `node:12.7-alpine` base
    image and not from the `node:12.7-stretch` default image.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，生成的 `my-node-test:latest` 镜像将从 `node:12.7-alpine` 基础镜像构建，而不是从默认的 `node:12.7-stretch`
    镜像构建。
- en: To summarize, environment variables defined via `--env` or `--env-file` are
    valid at container runtime. Variables defined with `ARG` in the `Dockerfile` or
    `--build-arg` in the `docker container build` command are valid at container image
    build time. The former are used to configure an application running inside a container,
    while the latter are used to parametrize the container image build process.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，通过 `--env` 或 `--env-file` 定义的环境变量在容器运行时有效。通过 `Dockerfile` 中的 `ARG` 或 `docker
    container build` 命令中的 `--build-arg` 定义的变量在容器镜像构建时有效。前者用于配置运行在容器内的应用程序，而后者用于为容器镜像构建过程提供参数。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced Docker volumes that can be used to persist
    states produced by containers and make them durable. We can also use volumes to
    provide containers with data originating from various sources. We have learned
    how to create, mount, and use volumes. We have learned various techniques of defining
    volumes such as by name, by mounting a host directory, or by defining volumes
    in a container image.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了可以用来持久化容器生成的状态并使其持久化的 Docker 卷。我们还可以使用卷为容器提供来自不同来源的数据。我们已经学习了如何创建、挂载和使用卷。我们还学习了多种定义卷的技巧，比如通过名称、挂载主机目录或在容器镜像中定义卷。
- en: In this chapter, we have also discussed how we can configure environment variables
    that can be used by applications running inside a container. We have shown how
    to define those variables in the `docker container run` command, either explicitly,
    one by one, or as a collection in a configuration file. We have also shown how
    to parametrize the build process of container images by using build arguments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还讨论了如何配置可以供容器内应用程序使用的环境变量。我们展示了如何在 `docker container run` 命令中显式地一个一个地定义这些变量，或将它们作为配置文件中的一部分进行定义。我们还展示了如何通过使用构建参数来为容器镜像构建过程提供参数。
- en: In the next chapter, we are going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍常用的技术，允许开发人员在容器中运行代码时对其进行演化、修改、调试和测试。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题，以评估你的学习进度：
- en: How would you create a named data volume with a name—for example, `my-products`—using
    the default driver?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将如何使用默认驱动程序创建一个命名数据卷，例如`my-products`？
- en: How would you run a container using the `alpine` image and mount the `my-products` volume
    in read-only mode into the `/data` container folder?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将如何使用`alpine`镜像运行容器，并将`my-products`卷以只读模式挂载到容器中的`/data`文件夹？
- en: How would you locate the folder that is associated with the `my-products` volume and
    navigate to it? Also, how will you create a file, `sample.txt`, with some content?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何找到与`my-products`卷关联的文件夹并进入它？另外，你将如何创建一个名为`sample.txt`的文件，并为其添加一些内容？
- en: How would you run another `alpine` container in to which you mount the `my-products` volume
    to the `/app-data` folder, in read/write mode? Inside this container, navigate
    to the `/app-data` folder and create a `hello.txt` file with some content.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将如何运行另一个`alpine`容器，并将`my-products`卷以读写模式挂载到`/app-data`文件夹？在该容器中，进入`/app-data`文件夹并创建一个名为`hello.txt`的文件并写入内容。
- en: How would you mount a host volume—for example, `~/my-project`—into a container?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将如何将主机卷（例如`~/my-project`）挂载到容器中？
- en: How would you remove all unused volumes from your system?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将如何从系统中删除所有未使用的卷？
- en: The list of environment variables that an application running in a container
    sees is the same as if the application were to run directly on the host.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器中运行的应用程序所看到的环境变量列表与该应用程序直接在主机上运行时看到的相同。
- en: A. True
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: Your application that shall run in a container needs a huge list of environment
    variables for configuration. What is the simplest method to run a container with
    your application and provide all this information to it?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要在容器中运行的应用程序需要一大堆环境变量来进行配置。最简单的方法是什么，可以让你的应用程序在容器中运行并提供所有这些信息？
- en: Further reading
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles provide more in-depth information:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章提供了更深入的信息：
- en: Use volumes, at [http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷，见 [http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)
- en: Manage data in Docker, at [http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中管理数据，见 [http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)
- en: Docker volumes on **Play with Docker** (**PWD**), at [http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Play with Docker**（**PWD**）中的Docker卷，见 [http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)'
- en: '`nsenter` —Linux man page, at [https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsenter` —Linux手册，见 [https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
- en: Set environment variables, at [https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境变量，见 [https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)
- en: Understanding how `ARG` and `FROM` interact, at [https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`ARG`和`FROM`的相互作用，见 [https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)
