- en: The Future of Serverless
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器的未来
- en: This chapter discusses what lies ahead beyond FaaS. We will start by discussing
    a new experimental technique to restore the speed of the container runtime by
    introducing RunF, a libcontainer-based runtime designed for invoking immutable
    function containers. This chapter will continue the discussion of the possibility
    of using LinuxKit to prepare immutable infrastructure for FaaS platforms in general.
    We conclude this chapter by exploring a new architecture to hybrid the FaaS architecture
    on-premises with the serverless architecture on the public cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 FaaS 之外的未来发展。我们将首先讨论一种新型的实验性技术，通过引入 RunF（一种基于 libcontainer 的运行时，旨在调用不可变函数容器）来恢复容器运行时的速度。本章还将继续讨论使用
    LinuxKit 为 FaaS 平台准备不可变基础设施的可能性。最后，我们将探讨一种新架构，将本地的 FaaS 架构与公共云上的无服务器架构结合起来。
- en: Before going to these topics, let's start by summarizing what we have learned
    so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这些话题之前，让我们首先总结一下迄今为止学到的内容。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: FaaS and Docker reviews
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FaaS 和 Docker 回顾
- en: Runtime for function containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数容器的运行时
- en: LinuxKit – immutable infrastructure for FaaS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinuxKit – 为 FaaS 提供不可变基础设施
- en: Beyond serverless
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越无服务器架构
- en: Declarative containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式容器
- en: FaaS and Docker reviews
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FaaS 和 Docker 回顾
- en: In this book, we introduced serverless, the FaaS platforms, and how Docker is
    relevant to this technology. We learned together about how to set up Docker Swarm
    clusters on production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书介绍了无服务器架构、FaaS 平台以及 Docker 与该技术的相关性。我们共同学习了如何在生产环境中设置 Docker Swarm 集群。
- en: The book discussed three well-known FaaS platforms, which are *OpenFaaS*, *OpenWhisk*,
    and the *Fn Project*. OpenFaaS uses the Swarm-based orchestrator, while OpenWhisk
    and Fn used their own scheduling techniques on plain Docker.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论了三个知名的 FaaS 平台，分别是*OpenFaaS*、*OpenWhisk* 和 *Fn 项目*。OpenFaaS 使用基于 Swarm 的调度器，而
    OpenWhisk 和 Fn 使用自己的调度技术，在普通的 Docker 上运行。
- en: Then, we demonstrated a project in [Chapter 8](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml),
    *Putting Them All Together*, to present how we can link all of these three platforms
    together, by running them on the same network of a Docker cluster. The project
    was demonstrated on how we could invoke the services of other FaaS platforms.
    Functions written in several programming languages were presented including Java,
    Go, and JavaScript (Node.js).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在[第8章](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml)《*将它们整合在一起*》中展示了一个项目，介绍了如何通过在
    Docker 集群的同一网络上运行这三个平台，将它们联通在一起。该项目展示了如何调用其他 FaaS 平台的服务。演示了用多种编程语言编写的函数，包括 Java、Go
    和 JavaScript（Node.js）。
- en: We used Java to write a simple function. For modern programming models, we could
    use the RxJava library to help writing Java programs in the reactive style, which
    fit very nicely for the event-driven programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Java 编写了一个简单的函数。对于现代编程模型，我们可以使用 RxJava 库来帮助编写响应式风格的 Java 程序，这非常适合事件驱动编程。
- en: With JavaScript, we wrote a Chrome-based scripting to connect through. We also
    deployed a blockchain to demonstrate that it works nicely with the FaaS computing
    model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们编写了一个基于 Chrome 的脚本进行连接。我们还部署了一个区块链，以展示它如何与 FaaS 计算模型良好配合。
- en: In the following sections, we will discuss some advanced, experimental topics
    that go deeply or beyond the current scope of serverless and FaaS. However, some
    of them may be going to be mainstream in the near future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论一些高级的、实验性的话题，这些话题深入或超出了当前无服务器架构和 FaaS 的范围。然而，其中一些可能很快会成为主流。
- en: Runtime for function containers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数容器的运行时
- en: One of the most important components of the container ecosystem is the **container
    runtime**. During the early days of Docker, the runtime was LXC, then it changed
    to be the Docker-owned libcontainer. The libcontainer was later donated to **OCI**,
    the **Open Container Initiative** project under the Linux Foundation. Later, Project
    RunC was started. RunC is a command-line wrapper around libcontainer to enable
    developers to start containers from a Terminal. A developer could start a container
    by invoking the RunC binary and passing a root filesystem and a container specification
    to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 容器生态系统中最重要的组件之一是**容器运行时**。在 Docker 的早期，运行时是 LXC，后来它被更改为 Docker 拥有的 libcontainer。libcontainer
    后来被捐赠给了 **OCI**（**开放容器倡议**）项目，该项目由 Linux 基金会支持。之后，RunC 项目启动。RunC 是一个围绕 libcontainer
    的命令行工具，允许开发者从终端启动容器。开发者可以通过调用 RunC 二进制文件并传递根文件系统和容器规范来启动容器。
- en: RunC is an extremely stable piece of software. It has been with Docker since
    version 1.12 and is already used by millions of users. The `docker run` command actually
    sends its parameters to another daemon, containerd, which converts that information
    into a configuration file for RunC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RunC 是一个非常稳定的软件。自 Docker 1.12 版本以来就一直与 Docker 一起，并已被数百万用户使用。`docker run` 命令实际上会将其参数发送给另一个守护程序
    containerd，后者将这些信息转换为 RunC 的配置文件。
- en: RunC makes the dependencies simpler as we need only a single binary, a root
    filesystem, and a configuration file to start a container.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 RunC 简化了依赖关系，我们只需一个单一的二进制文件，一个根文件系统和一个配置文件来启动一个容器。
- en: As RunC is a thin wrapper around libcontainer, its code is straightforward.
    It is relatively easy to directly make use of libcontainer with some Go programming
    knowledge. The only drawback of RunC is that it is designed and built to run containers
    in general. In the next section, we will introduce *RunF,* a minimal runtime designed
    specially for running function containers efficiently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RunC 只是 libcontainer 的一个薄包装，其代码非常直接。如果具备一定的 Go 编程知识，直接使用 libcontainer 相对容易。RunC
    的唯一缺点是它被设计和构建用于一般容器运行。在下一节中，我们将介绍 *RunF*，一个专门设计用于高效运行函数容器的最小运行时环境。
- en: Meet RunF
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遇见 RunF
- en: This section introduces RunF. It is a RunC counterpart that is designed for
    running immutable function containers. RunF is an experimental project that uses
    *libcontainer* to implement a new runtime to run containers in the read-only and
    rootless environment. Containers started with RunF are expected to be running
    efficiently, even inside other containers. RunF allows rootless container execution
    by mapping a non-root user from the host to the root user's ID inside the container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 RunF。它是 RunC 的对应物，专为运行不可变函数容器而设计。RunF 是一个实验性项目，使用 *libcontainer* 实现了一个新的运行时环境，以在只读和无根的环境中运行容器。使用
    RunF 启动的容器预期在其他容器内部高效运行。RunF 允许通过将主机上的非 root 用户映射到容器内部的 root 用户 ID 来执行无根容器。
- en: 'How can we use it? The following diagram illustrates the scenario. We have
    a FaaS platform, and the **Gateway** accepts the incoming request and forwards
    it to the function **Initiator**. Through the **Event Bus**, a **Function Executor**
    then uses it rather than Docker to invoke the function container. With this architecture,
    we can improve the overall performance of the platform:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用它？以下图表说明了场景。我们有一个 FaaS 平台，**网关**接受传入请求并将其转发给函数**初始化程序**。通过**事件总线**，**函数执行器**然后使用它来调用函数容器，而不是
    Docker。通过这种架构，我们可以提高平台的整体性能：
- en: '![](img/ba5ab83d-cca2-4693-b9fd-8c6162aab03c.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba5ab83d-cca2-4693-b9fd-8c6162aab03c.png)'
- en: 'Figure 9.1: The block diagram illustrating a FaaS architecture with RunF as
    its runtime'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：展示了一个以 RunF 为运行时的 FaaS 架构的块图。
- en: A rootless container is a container allowed to run without the root user, such
    as in AWS Lambda. We want an immutable version of a function with read-only and
    rootless, because rootless containers make the system and infrastructure more
    secure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无根容器是允许在无 root 用户的情况下运行的容器，例如 AWS Lambda。我们希望有一个不可变的函数版本，具有只读和无根权限，因为无根容器使系统和基础架构更加安全。
- en: Then there is a network constraint. A function should not be aware of any network-related
    configuration. All current FaaS platforms we have implemented so far have this
    limitation. Say we need to attach a running function to a certain network in order
    to make it work correctly, and be able to resolve names of other dependent services.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是网络约束。一个函数不应该意识到任何与网络相关的配置。到目前为止，我们实现的所有当前 FaaS 平台都有这个限制。假设我们需要将一个正在运行的函数附加到某个网络，以使其正确工作，并能够解析其他依赖服务的名称。
- en: We found during [Chapter 8](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml), *Putting
    Them All Together*, that it is tricky to make a function container work virtually
    with any network provided by the platform. *RunF* is designed to solve this issue
    by letting the function container use the outer container network namespace. With
    this execution model, the *function proxy* is responsible for attaching itself
    to the networks, and the function container will also use these networks to access
    other services. If the function container runs inside the container of the function
    proxy, all network configuration could be eliminated.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml)《将它们全部结合起来》中，我们发现使功能容器在平台提供的任何网络下正常工作是很棘手的。*RunF*
    旨在通过让功能容器使用外部容器的网络命名空间来解决这个问题。通过这种执行模型，*功能代理* 负责将自己附加到网络，而功能容器也会使用这些网络来访问其他服务。如果功能容器运行在功能代理的容器内部，所有的网络配置都可以被省略。
- en: Performance-wise with a special container runtime such as *RunF*, it is possible
    to cache all necessary filesystems inside each function proxy, and make them immutable.
    With this, we can achieve the highest possible performance similar to the way
    the mechanism of hot functions work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，通过使用像 *RunF* 这样的特殊容器运行时，能够将所有必要的文件系统缓存到每个功能代理内，并使其变为不可变。这样，我们就可以实现与热函数机制类似的最高性能。
- en: 'Now let''s see what''s inside the implementation to make it meet all requirements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看实现中的内容，看看它是如何满足所有要求的：
- en: Immutable
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变
- en: Rootless
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无根
- en: Host networking by default
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认使用主机网络
- en: Zero configuration.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零配置。
- en: We mostly use the libcontainer APIs directly. Here, we explain the details to
    show how RunF uses libcontainer to achieve the mutable runtime for function containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要直接使用 libcontainer API。在这里，我们详细解释了 RunF 如何利用 libcontainer 实现功能容器的可变运行时。
- en: 'The program starts by initializing the libcontainer, with the `Cgroupfs` configuration,
    to say that libcontainer will use `Cgroup` to control the resources of the process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通过初始化 libcontainer 开始，并使用 `Cgroupfs` 配置，表示 libcontainer 将使用 `Cgroup` 来控制进程的资源：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following snippet creates a config. The default location of the `rootfs`
    is `./rootfs` under the current directory. We set the flag `Readonlyfs` to be
    `true` for the immutable filesystem. `NoNewPrivileges` is set to `true` so as
    to not allow the process to gain any new privilege. `Rootless` being `true` is
    designed to tell us that we will map non-root UID and GID to the container''s
    root ID. After the initial flags, we then set the capability of the process. Here''s
    the list:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个配置。`rootfs` 的默认位置是当前目录下的 `./rootfs`。我们将标志 `Readonlyfs` 设置为 `true`，以实现不可变文件系统。`NoNewPrivileges`
    设置为 `true`，以防止进程获得任何新特权。`Rootless` 设置为 `true`，表示我们将把非根 UID 和 GID 映射到容器的根 ID。初始化标志后，我们设置进程的能力。以下是能力列表：
- en: '`CAP_AUDIT_WRITE` is the ability to write to the kernel''s audit logs'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_AUDIT_WRITE` 是写入内核审计日志的能力'
- en: '`CAP_KILL` is the ability for the process to send the signals'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_KILL` 是进程发送信号的能力'
- en: '`CAP_NET_BIND_SERVICE` is the ability to bind a socket to the privileged ports'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_NET_BIND_SERVICE` 是绑定套接字到特权端口的能力。'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Namespaces` property is one of the most important settings of the container
    runtime. Within this block of configuration, we set it to use the following namespaces,
    `NS`, `UTS` (hostname and domain name), `IPC`, `PID`, and `USER`. The user namespace,
    `NSUSER`, is the key setting to allow running containers in the rootless mode.
    We left out the `NET` namespace. The reason is that `runf` will start a function
    container inside another container, the *function executor*. Without the `NET`
    namespace isolation, the function container will use the same network namespace
    as the outside container, so it will be able to access any service attached to
    the network of the function executor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Namespaces` 属性是容器运行时最重要的设置之一。在此配置块中，我们将其设置为使用以下命名空间：`NS`、`UTS`（主机名和域名）、`IPC`、`PID`
    和 `USER`。用户命名空间 `NSUSER` 是允许以无根模式运行容器的关键设置。我们省略了 `NET` 命名空间。原因是 `runf` 会在另一个容器内部启动一个功能容器，即*功能执行器*。如果没有
    `NET` 命名空间的隔离，功能容器将与外部容器共享同一网络命名空间，从而能够访问附加到功能执行器网络的任何服务。'
- en: 'Another setting is the `Cgroup` setting. This setting allows hierarchical control
    resources of the process. This is mostly the default configuration:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个设置是 `Cgroup` 设置。此设置允许对进程的资源进行层次控制。这个设置大多是默认配置：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`MaskPaths` and `ReadonlyPaths` are set as the following. This setting is mainly
    to prevent the changes made by the running process to the system:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaskPaths`和`ReadonlyPaths`设置如下。此设置主要是为了防止运行中的进程对系统所做的更改：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All devices are set to be auto created. Then, the `Mount` setting defines a
    set of filesystems required to mount from the host into the container. In the
    case of RunF, it is a nested mounted from the function executor to the function
    container:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设备都设置为自动创建。然后，`Mount`设置定义了一组需要从主机挂载到容器中的文件系统。对于RunF，它是从函数执行器到函数容器的嵌套挂载：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the UID and GID mapping from the host ID (`HostID`) to the ID inside
    the container (`ContainerID`). In the following example, we map the current user
    ID to the ID of the `root` user inside the container:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从主机ID（`HostID`）到容器内部ID（`ContainerID`）的UID和GID映射。在以下示例中，我们将当前用户ID映射到容器内`root`用户的ID：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use libcontainer''s factor to create a container with the generated ID and
    the `config` we have set:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用libcontainer的工厂方法创建一个带有生成ID和我们已设置的`config`的容器：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we prepare environment variables. They are simply an *array of strings*.
    Each element is a *key=value* pair of each variable that we''d like to set for
    the process. We prepare a process to run using `libcontainer.Process`. Process
    input, output, and error are redirected to the default standard counterparts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们准备环境变量。它们只是一个*字符串数组*。每个元素是一个*key=value*对，表示我们希望为进程设置的每个变量。我们使用`libcontainer.Process`准备一个要运行的进程。进程的输入、输出和错误会被重定向到默认的标准对等端：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will then prepare and build the `runf` binary. This requires *libcontainer*
    and other few to build. We normally use the `go get` command to do so. After that,
    just simply build with the `go build` command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将准备并构建`runf`二进制文件。这需要*libcontainer*及其他一些工具来构建。我们通常使用`go get`命令来完成。之后，只需使用`go
    build`命令进行构建：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To prepare a root filesystem, we use `undocker.py` together with the `docker
    save` command. The `undocker.py` script can be downloaded from [https://github.com/larsks/undocker](https://github.com/larsks/undocker).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备根文件系统，我们使用`undocker.py`和`docker save`命令。`undocker.py`脚本可以从[https://github.com/larsks/undocker](https://github.com/larsks/undocker)下载。
- en: 'Here''s the command to prepare a root filesystem to the `rootfs` directory
    from the `busybox` image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将根文件系统准备到`rootfs`目录的命令，来源于`busybox`镜像：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s test running some containers. We will see that the `ls` command
    lists files inside a container:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试运行一些容器。我们将看到`ls`命令列出容器内的文件：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Within a Docker network
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker网络内
- en: 'Next, we will try something a bit advanced by preparing a small system that
    looks similar to the following diagram. The scenario is that we would like a container
    started by **runf** inside another container, **wrapper-runf** (which is, in reality,
    a function executor), to connect to some network services running on the same
    Docker network, **test_net**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试一些稍微复杂的操作，准备一个小系统，其外观类似于以下图示。场景是我们希望由**runf**启动的容器位于另一个容器**wrapper-runf**（实际上是一个函数执行器）内，连接到同一Docker网络上运行的一些网络服务，**test_net**：
- en: '![](img/215f30db-9eb2-4691-ac17-cd519153647c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/215f30db-9eb2-4691-ac17-cd519153647c.png)'
- en: 'Figure 9.2: An example of using RunF inside a Docker network'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：在Docker网络中使用RunF的示例
- en: 'The trick is that we put `resolv.conf` from the standard Docker Swarm mode
    as `./rootfs/etc/resolv.conf` to make the process inside the nested container
    be able to resolve all service names on the attached Docker network. Here''s the
    content of `resolv.conf`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是我们将标准Docker Swarm模式中的`resolv.conf`放置为`./rootfs/etc/resolv.conf`，使得嵌套容器内的进程能够解析附加Docker网络上的所有服务名称。以下是`resolv.conf`的内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we prepare a Dockerfile for the `wrapper-runf` container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为`wrapper-runf`容器准备一个Dockerfile：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can build it normally with the `docker build` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`docker build`命令正常构建它：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following snippet is the preparation for creating a Docker network, attaching
    `nginx` to the network, then running a `wrapper-runf` container with `/bin/bash`
    there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段是创建一个Docker网络的准备，接着将`nginx`连接到该网络，然后在其中运行一个带有`/bin/bash`的`wrapper-runf`容器。
- en: 'Finally, we start a nested container with `runf` that connects to `nginx`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动一个通过`runf`连接到`nginx`的嵌套容器：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What's next?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: With `runf`, it is potentially a way to move towards another step of fast and
    immutable functions with a special runtime. What you can try is to implement a
    proxy container wrapping around `runf` and make it run functions inside the real
    platform. This is left as an (a bit advanced) exercise.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `runf`，它可能是朝着另一个步骤——使用特殊运行时的快速不可变功能迈进的方式。您可以尝试实现一个代理容器，包装在 `runf` 周围，并使其在实际平台中运行函数。这被留作一个（稍微高级一点的）练习。
- en: LinuxKit – immutable infrastructure for FaaS
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinuxKit – FaaS 的不可变基础设施
- en: LinuxKit is a set of tools for preparing immutable sets of infrastructure. It
    is designed to compose containers into a ready-to-use OS. Of course, an OS produced
    by LinuxKit is for running containers. To make an immutable and scalable infrastructure
    for FaaS platforms, LinuxKit is one of the best choices out there.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: LinuxKit 是一套用于准备不可变基础设施工具的集合。它旨在将容器组合成一个可供使用的操作系统。当然，LinuxKit 生成的操作系统是用于运行容器的。为了构建一个不可变且可扩展的
    FaaS 平台基础设施，LinuxKit 是最好的选择之一。
- en: 'Here''s a sample of a LinuxKit YAML file to build an immutable OS for Docker.
    The kernel block is saying that this OS will boot with Linux Kernel 4.14.23\.
    The `boot` command, `cmdline`, says that the kernel will be starting with consoles
    on four different TTYs:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 LinuxKit YAML 文件示例，用于构建一个用于 Docker 的不可变操作系统。内核块表示该操作系统将使用 Linux 内核 4.14.23
    启动。`boot` 命令和 `cmdline` 表示内核将在四个不同的 TTY 上启动控制台：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The four next containers declared inside the `init` block are the base programs
    that will be unpacked directly onto the filesystem. All the `init` level programs
    include `runc` and containerd. Also, the CA certificates will be installed directly
    onto the filesystem before the programs declared in the next, `onboot`, block
    can proceed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 块中声明的接下来的四个容器是将直接解压到文件系统中的基本程序。所有 `init` 级别的程序包括 `runc` 和 containerd。此外，CA
    证书将直接安装到文件系统中，以便在接下来的 `onboot` 块声明的程序继续运行之前：'
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `onboot` block and the `mountie` command will automatically mount the first
    available partition to `/var/lib/docker`. Please note that LinuxKit only allows
    you to mount to the directory under the `/var` directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`onboot` 块和 `mountie` 命令将自动将第一个可用分区挂载到 `/var/lib/docker`。请注意，LinuxKit 仅允许您挂载到
    `/var` 目录下的目录：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `services` block declares system containers, which serve as long running
    services. All these services are run and maintained by containers, started by
    the `init` process in the `init` block.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`services` 块声明了系统容器，它们作为长期运行的服务。这些服务都是由容器运行和维护的，由 `init` 块中的 `init` 进程启动。'
- en: A service declared in this block can be started in any order.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此块中声明的服务可以按任意顺序启动。
- en: 'In the following example, `docker` is one of the services. Docker image, `docker:17.09.0-ce-dind`,
    is used for running this Docker service. This service runs on the host network.
    This is basically the same concept as RancherOS. This instance of `dockerd` run
    by the `docker` service is the user-level container management system, while containerd
    from the `init` block is the system-level container management system. Other system
    containers here are `rngd`—a random number generator daemon, `dhcpd`—an DHCP service,
    and `ntpd`—the OpenNTPD daemon for syncing the machine clock, for example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`docker` 是其中一个服务。使用的 Docker 镜像 `docker:17.09.0-ce-dind` 用于运行这个 Docker
    服务。该服务运行在主机网络上。这与 RancherOS 的概念基本相同。由 `docker` 服务运行的 `dockerd` 实例是用户级的容器管理系统，而
    `init` 块中的 containerd 是系统级的容器管理系统。其他系统容器包括 `rngd`——随机数生成守护进程，`dhcpd`——DHCP 服务，`ntpd`——用于同步机器时钟的
    OpenNTPD 守护进程等：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The file block is for declaring *files* or *directories* that we would like
    to have on our immutable filesystem. In the following example, we declare `/var/lib/docker`
    and create a Docker''s daemon configuration `/etc/docker/daemon.json` with the
    content `{"debug": true}` inside it. These files are created during the image''s
    build phase:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '文件块用于声明我们希望在不可变文件系统中拥有的*文件*或*目录*。在以下示例中，我们声明了 `/var/lib/docker` 并创建了 Docker
    的守护进程配置 `/etc/docker/daemon.json`，其中包含内容 `{"debug": true}`。这些文件将在镜像构建阶段创建：'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have another example of the `files` block. This is the standard way to put
    our public key into the filesystem image. The attribute `mode` is for setting
    the file mode when copying the file to the final image. In this example, we require
    the public key file to be `0600`. With this configuration and the running `sshd`
    service, we will be allowed to remotely SSH into the machine:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有另一个`files`块的例子。这是将公钥放入文件系统镜像的标准方法。`mode`属性用于设置复制文件到最终镜像时的文件模式。在这个例子中，我们要求公钥文件的模式为`0600`。通过这个配置和正在运行的`sshd`服务，我们将被允许远程SSH进入机器：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s the step to build the LinuxKit command line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建LinuxKit命令行的步骤：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we have already installed the Go programming language using GVM, the binary
    will be available to run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经使用GVM安装了Go编程语言，那么二进制文件将可用来运行。
- en: 'We''ll build a Docker OS, available at [https://github.com/linuxkit/linuxkit/blob/master/examples/docker.yml](https://github.com/linuxkit/linuxkit/blob/master/examples/docker.yml):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个Docker操作系统，详见[https://github.com/linuxkit/linuxkit/blob/master/examples/docker.yml](https://github.com/linuxkit/linuxkit/blob/master/examples/docker.yml)：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Beyond serverless
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越无服务器
- en: Hybrid serverless would be a deployment model that links hybrid cloud to the
    serverless deployment model. It is already started by IT vendors offering hardware
    rental services in the form of private clouds, putting them to customer's organizations,
    and charging at the rate of pay-as-you-go.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 混合无服务器将是一种将混合云与无服务器部署模型连接的部署模式。它已经由IT供应商开始提供硬件租赁服务，以私有云的形式部署到客户的组织中，并按需计费。
- en: When the serverless and FaaS computing platforms are deployed on top of that
    kind of hybrid infrastructure, they become **hybrid serverless**. This could be
    the next generation of computing platform that allows you to store sensitive data
    inside the organization, having some important FaaS functions running on the local
    system, while leveraging some extra computing resources as pay-per-request. It
    will be in the scope of the definition of serverless, if the customer's organization
    does not need to maintain or administer any of the hardware servers. Fortunately,
    when mixing this model with what we have discussed throughout this book, using
    Docker as our infrastructure would still be applied to this kind of infrastructure.
    Docker is still a good choice for balancing between maintaining infrastructure
    on our own and making the serverless platforms do the rest of the work for us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当无服务器和FaaS计算平台部署在这种混合基础设施之上时，它们就变成了**混合无服务器**。这可能是下一代计算平台，允许你将敏感数据存储在组织内部，运行一些重要的FaaS功能在本地系统中，同时利用按请求付费的额外计算资源。如果客户的组织不需要维护或管理任何硬件服务器，它将符合无服务器的定义。幸运的是，当将这种模式与我们在本书中讨论的内容混合时，使用Docker作为基础设施仍然适用于这种架构。Docker仍然是平衡自主维护基础设施和让无服务器平台为我们做剩余工作的良好选择。
- en: 'In the following diagram, the overall system shows a hybrid architecture. In
    the case of using a FaaS platform only from inside the organization, requests
    would be made firstly to the on-premises infrastructure. When loads become large,
    instances of the function executors would be scaled out and eventually burst to
    a public cloud infrastructure. However, the data stores are usually placed inside
    the organization. So, the outside function executors must be able to access them
    just as if they were running on-premises:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，整体系统展示了一种混合架构。如果仅在组织内部使用FaaS平台，请求将首先发送到本地基础设施。当负载增大时，函数执行实例会横向扩展，最终爆发到公共云基础设施。然而，数据存储通常放置在组织内部。因此，外部函数执行器必须能够访问这些数据，就像它们在本地运行一样：
- en: '![](img/e6768fae-af48-4305-b6bc-136a4c2c085f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6768fae-af48-4305-b6bc-136a4c2c085f.png)'
- en: 'Figure 9.3: A hybrid architecture for FaaS'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：FaaS的混合架构
- en: Declarative containers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式容器
- en: 'Declarative containers could be considered as a technology in between a normal
    container and a container running on FaaS. Let''s look at the following imaginary
    Dockerfile:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式容器可以被看作是一种介于普通容器和运行在FaaS上的容器之间的技术。让我们看一下下面的假想Dockerfile：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What do we see here? At the first time of reading, it would look like a normal
    Dockerfile. Yes, it is. But it's not a declarative way to define an application
    container. Why?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了什么？第一次阅读时，它看起来像是一个普通的Dockerfile。没错，就是它。但这并不是一种声明式的方式来定义应用容器。为什么？
- en: We already know that this is a Java application doing some work for us. But
    it has hardcoded some important and brittle configurations, for example, when
    `openjdk:8` pinned the app to use only that implementation, while `-Xmx2G` limits
    the memory usage of the app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道这是一个 Java 应用程序在为我们做一些工作。但它硬编码了一些重要且脆弱的配置，例如，当 `openjdk:8` 锁定应用程序只使用那个实现时，而
    `-Xmx2G` 限制了应用程序的内存使用。
- en: All FaaS platforms these days use containers in the same way. They tie some
    specific configurations into function containers but actually people need a very
    neutral and portable way of deploying functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所有的 FaaS 平台都以相同的方式使用容器。它们将一些特定的配置绑定到函数容器中，但实际上人们需要的是一种非常中立且可移植的方式来部署函数。
- en: So what does a declarative container look like?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，声明式容器是什么样的？
- en: 'It looks something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You might think it is impossible to run this container on any runtime at the
    moment. The answer is you are correct. But I still argue that the application
    should be declared in the same way. We should remove all brittle configuration
    out of the `Dockerfile` as much as possible. Then we should let a new entity,
    maybe inside a container engine, manage the environment around the application
    for us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为目前无法在任何运行时环境中运行这个容器。答案是你是对的。但我仍然认为应用程序应该以相同的方式声明。我们应该尽可能地将所有脆弱的配置从 `Dockerfile`
    中移除。然后，我们应该让一个新的实体，可能是在容器引擎内部，来管理应用程序周围的环境。
- en: 'For example, it is relatively easy to intercept the container creation process
    then compute the limitation of the memory allowed by the container (via `docker
    run -m` for example) and put that value into the command line of `java` to cap
    the memory limit at the application level. The entity responsible for this kind
    of work inside a container engine would be called the **Application Profile Manager**,
    as shown in the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，拦截容器创建过程并计算容器允许的内存限制（例如通过 `docker run -m`）并将该值传递给 `java` 命令行以在应用程序层面限制内存，这相对容易。负责这类工作的容器引擎内部实体被称为
    **应用配置文件管理器**，如下图所示：
- en: '![](img/61d4cc6a-a41b-470a-b849-92fb0861c78f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61d4cc6a-a41b-470a-b849-92fb0861c78f.png)'
- en: 'Figure 9.4: A container engine with the application profile manager'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：带有应用配置文件管理器的容器引擎
- en: The crosscutting concept like this is nothing new. We already have a similar
    concept applied to Docker. Guess what? It's the security concern. Docker already
    has the AppArmor default profile applied to each running container with the AppArmor
    subsystem enabled. That's about security concerns. This is at the more application-specific
    level of concern, so why don't we have a similar concept to help make our life
    easier?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的交叉概念并不新鲜。我们已经有一个类似的概念应用于 Docker。你猜怎么着？那就是安全性问题。Docker 已经对每个运行中的容器应用了默认的
    AppArmor 配置文件，并启用了 AppArmor 子系统。这就是安全性问题。这是在更应用特定的层面上的关注，那么为什么我们不能有一个类似的概念来帮助让我们的生活更轻松呢？
- en: With this concept, container images would become declarative containers as there
    is no specific environment or configuration hardcoded for them. And it's the responsibility
    of the **Application Profile Manager** to selectively apply an appropriate profile
    for the container and make it work nicely.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个概念下，容器镜像将变成声明式容器，因为没有为它们硬编码任何特定的环境或配置。而 **应用配置文件管理器** 负责选择性地为容器应用合适的配置文件，并使其正常工作。
- en: What is the practical benefit of declarative containers? Here's a concrete explanation
    for the Java app we discussed earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式容器的实际好处是什么？这里有一个我们之前讨论的 Java 应用的具体解释。
- en: In the world of Java, the application architecture has been designed to decouple
    between the application and the runtime. With the very strong specification of
    the JVM, the JVM for running applications is always swappable and replaceable.
    For example, if we start running an application with an OpenJDK, and we are not
    happy with its performance, we can safely swap the JVM to be the Zulu JVM or the
    IBM J9.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 的世界中，应用架构已经被设计成解耦应用程序和运行时环境。由于 JVM 的强大规范，运行应用程序的 JVM 总是可以被交换和替换。例如，如果我们开始使用
    OpenJDK 运行应用程序，并且对其性能不满意，我们可以安全地将 JVM 更换为 Zulu JVM 或 IBM J9。
- en: With the declarative approach to containers, the Java runtime would be easily
    swappable on-the-fly without rebuilding the Docker image. It also allows you to
    apply JVM hot fixes to the running system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明式容器的方法，Java 运行时可以在不重新构建 Docker 镜像的情况下动态切换。这还允许你对运行中的系统应用 JVM 热修复。
- en: We can download the modified version of Docker with this declarative feature
    for Java from [http://github.com/joconen/engine](http://github.com/joconen/engine).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从[http://github.com/joconen/engine](http://github.com/joconen/engine)下载带有此声明式特性的修改版Docker，以便为Java使用。
- en: Exercises
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Now it''s time to review all the concepts in this chapter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回顾本章的所有概念了：
- en: What do you think is lying ahead after the serverless era?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为在无服务器时代之后，未来会有什么发展？
- en: What is the next generation of computing you might probably be thinking of?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能在想的下一代计算是什么？
- en: What is the feature of libcontainer that allows rootless execution?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: libcontainer的特性是什么，允许无根执行？
- en: What are the namespaces provided by Linux?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux提供了哪些命名空间？
- en: Explain why RunF is able to access the network services when running inside
    other containers.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么RunF在其他容器内部运行时能够访问网络服务。
- en: What is the benefit of using LinuxKit to prepare an infrastructure.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LinuxKit准备基础设施有什么好处？
- en: What is a declarative approach to containers? How could it apply to other application
    platforms, beside Java?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器的声明式方法是什么？它如何应用到Java以外的其他应用平台？
- en: How could we design a hybrid serverless architecture when we would like to access
    services from outside the organization?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们希望访问来自组织外部的服务时，如何设计一个混合的无服务器架构？
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter ends this book with a discussion of what we could use to make the
    FaaS moving forward. We reviewed what we have been through with Docker and three
    major FaaS platforms running on it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过讨论我们可以使用什么来推动FaaS的发展，结束了这本书。我们回顾了在Docker和其上运行的三个主要FaaS平台上的经历。
- en: Docker is a great infrastructure when it's considered that all these three FaaS
    platforms are actually using its direct feature, rather than solely relying on
    its orchestrator functionalities. Why? Maybe because the FaaS computing model
    fits this simple kind of infrastructure instead of complex ones.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个很好的基础设施，因为考虑到这三个FaaS平台实际上都在使用Docker的直接特性，而不是仅仅依赖它的调度器功能。为什么？也许是因为FaaS计算模型适合这种简单的基础设施，而不是复杂的基础设施。
- en: What if we could simply do `docker run`, then the container is transformed into
    a FaaS function serving its functionality somewhere on the cluster? Function wrapper,
    action proxy, or function watchdog could be injected into a simple container that
    processes input and output via standard I/O and turns it into an online function.
    Then a kind of magical infrastructure will be taking care of everything for us.
    We are gradually moving toward to that reality.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以简单地执行`docker run`，然后容器被转化为一个FaaS功能，在集群的某个地方提供它的功能呢？功能包装器、动作代理或功能监视器可以注入到一个简单的容器中，通过标准I/O处理输入和输出，并将其转变为一个在线功能。然后，一种神奇的基础设施将为我们处理一切。我们正逐步迈向这一现实。
- en: References
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Apache Foundation. *Apache OpenWhisk*. Available at: [https://openwhisk.apache.org/.](https://openwhisk.apache.org/.)
    (Accessed: March 28, 2018).'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache Foundation. *Apache OpenWhisk*。可在：[https://openwhisk.apache.org/.](https://openwhisk.apache.org/)（访问日期：2018年3月28日）。
- en: 'Microsoft Corp. Azure functions—serverless architecture | Microsoft Azure.
    Available at: [https://azure.microsoft.com/en-us/services/functions/.](https://azure.microsoft.com/en-us/services/functions/.)
    (Accessed: March 28, 2018).'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Microsoft Corp. Azure Functions—无服务器架构 | Microsoft Azure。可在：[https://azure.microsoft.com/en-us/services/functions/.](https://azure.microsoft.com/en-us/services/functions/)（访问日期：2018年3月28日）。
- en: Burns, B., Grant, B., Oppenheimer, D., Brewer, E. & Wilkes, J. Borg, Omega,
    and Kubernetes. Queue 14, 10:70–10:93 (2016).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Burns, B., Grant, B., Oppenheimer, D., Brewer, E. & Wilkes, J. Borg, Omega,
    和Kubernetes。Queue 14, 10:70–10:93（2016）。
- en: 'Schickling, J., Lüthy, M., Suchanek, T. & et al. *chromeless: Chrome automation
    made simple.* (Graphcool, 2018).'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Schickling, J., Lüthy, M., Suchanek, T. 等人 *chromeless: 简化的Chrome自动化*。（Graphcool，2018）。'
- en: 'Google Inc. Concepts | Cloud Functions. *Google Cloud* Available at: [https://cloud.google.com/functions/docs/concepts.](https://cloud.google.com/functions/docs/concepts.)
    (Accessed: 28th March 2018).'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Inc. 概念 | 云功能。*Google Cloud* 可在：[https://cloud.google.com/functions/docs/concepts.](https://cloud.google.com/functions/docs/concepts)（访问日期：2018年3月28日）。
- en: 'Crosby, M., Day, S., Laventure, K.-M., McGowan, D. & et al. *containerd: An
    open and reliable container runtime.* (containerd, 2018).'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Crosby, M., Day, S., Laventure, K.-M., McGowan, D. 等人 *containerd: 一个开放且可靠的容器运行时*。（containerd，2018）。'
- en: 'Docker Inc. Docker. (2018). Available at: [https://www.docker.com/.](https://www.docker.com/.)
    (Accessed: 28th March 2018).'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Inc. Docker。（2018）。可在：[https://www.docker.com/.](https://www.docker.com/.)（访问日期：2018年3月28日）。
- en: Smith, R. *Docker Orchestration*. (Packt Publishing Ltd, 2017).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Smith, R. *Docker调度*。（Packt Publishing Ltd，2017）。
- en: 'Merkel, D. Docker: Lightweight Linux Containers for Consistent Development
    and Deployment. *Linux J.* **2014**, (2014).'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Merkel, D. Docker：轻量级 Linux 容器，确保开发和部署的一致性。*Linux J.* **2014年**，（2014年）。
- en: 'The Go Community. Documentation - The Go Programming Language. Available at:
    [https://golang.org/doc/.](https://golang.org/doc/.) (Accessed: 30th March 2018).'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go社区。文档 - Go 编程语言。可在以下链接查看：[https://golang.org/doc/.](https://golang.org/doc/.)
    （访问日期：2018年3月30日）。
- en: 'The Linux Foundation. Envoy Proxy - Home. Available at: [https://www.envoyproxy.io/.](https://www.envoyproxy.io/.)
    (Accessed: 1st April 2018).'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: The Linux Foundation. Envoy Proxy - 首页。可在以下链接查看：[https://www.envoyproxy.io/.](https://www.envoyproxy.io/.)
    （访问日期：2018年4月1日）。
- en: 'The Ethereum Foundation. Ethereum Project. Available at: [https://www.ethereum.org/.](https://www.ethereum.org/.)
    (Accessed: 30th March 2018).'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以太坊基金会。以太坊项目。可在以下链接查看：[https://www.ethereum.org/.](https://www.ethereum.org/.)
    （访问日期：2018年3月30日）。
- en: Avram, A. FaaS, PaaS, and the Benefits of the Serverless Architecture. *Retrieved
    from’InfoQ’https://www. infoq. com/news/2016/06/faasserverless-architecture* on
    **28**, (2016).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Avram, A. FaaS、PaaS 和无服务器架构的好处。*从‘InfoQ’检索* [https://www.infoq.com/news/2016/06/faasserverless-architecture](https://www.infoq.com/news/2016/06/faasserverless-architecture)
    于**2016年6月28日**检索。
- en: 'Oracle Inc. Fn Project - The Container Native Serverless Framework. Available
    at: [https://fnproject.io/.](https://fnproject.io/.) (Accessed: 28th March 2018).'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Oracle Inc. Fn项目 - 容器原生的无服务器框架。可在以下链接查看：[https://fnproject.io/.](https://fnproject.io/.)
    （访问日期：2018年3月28日）。
- en: 'Arimura, C., Reeder, T. & et al. *Fn: The container native, cloud agnostic
    serverless platform.* (Oracle inc., 2018).'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Arimura, C., Reeder, T. & 等人。*Fn：容器原生、云无关的无服务器平台。*（Oracle公司，2018年）。
- en: 'Google Inc. Google Cloud Functions Documentation | Cloud Functions. *Google
    Cloud* Available at: [https://cloud.google.com/functions/docs/.](https://cloud.google.com/functions/docs/.)
    (Accessed: 28th March 2018). Kaewkasi, C. & Chuenmuneewong, K. Improvement of
    container scheduling for docker using ant colony optimization. in *Knowledge and
    Smart Technology (KST), 2017 9th International Conference on* 254–259 (IEEE, 2017).'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Inc. Google Cloud Functions 文档 | Cloud Functions. *Google Cloud* 可在以下链接查看：[https://cloud.google.com/functions/docs/.](https://cloud.google.com/functions/docs/.)
    （访问日期：2018年3月28日）。Kaewkasi, C. & Chuenmuneewong, K. 使用蚁群优化改进 Docker 容器调度。在 *知识与智能技术（KST），2017年第九届国际会议*
    254–259 （IEEE，2017年）。
- en: 'Apache Foundation. incubator-openwhisk: *Apache OpenWhisk is a serverless event-based
    programming service and an Apache Incubator project.* (The Apache Software Foundation,
    2018).'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache Foundation. incubator-openwhisk：*Apache OpenWhisk 是一个无服务器的基于事件的编程服务，也是一个
    Apache 孵化项目。*（Apache软件基金会，2018年）。
- en: 'Cormack, J. & et al. linuxkit: *A toolkit for building secure, portable and
    lean operating systems for containers.* (LinuxKit, 2018).'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cormack, J. & 等人。linuxkit：*用于构建安全、便携和精简容器操作系统的工具包。*（LinuxKit，2018年）。
- en: 'Janakiraman, B. Martin Fowler’s bliki: Serverless. *martinfowler.com* (2016).
    Available at: [https://martinfowler.com/bliki/Serverless.html.](https://martinfowler.com/bliki/Serverless.html.)
    (Accessed: 28th March 2018).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Janakiraman, B. Martin Fowler的Bliki：无服务器。*martinfowler.com*（2016年）。可在以下链接查看：[https://martinfowler.com/bliki/Serverless.html.](https://martinfowler.com/bliki/Serverless.html.)
    （访问日期：2018年3月28日）。
- en: Sharma, S. *Mastering Microservices with Java 9*. (Packt Publishing Ltd, 2017).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sharma, S. *使用 Java 9 精通微服务。*（Packt Publishing Ltd，2017年）。
- en: 'Moby Community,The. Moby. *GitHub* Available at: [https://github.com/moby.](https://github.com/moby.)
    (Accessed: 30th March 2018).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Moby Community, The. Moby. *GitHub* 可在以下链接查看：[https://github.com/moby.](https://github.com/moby.)
    （访问日期：2018年3月30日）。
- en: 'Moby Community,The. moby: *Moby Project* - a collaborative project for the
    container ecosystem to assemble container-based systems. (Moby, 2018).'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Moby Community, The. moby：*Moby项目* - 一个容器生态系统的协作项目，用于组装基于容器的系统。（Moby，2018年）。
- en: 'Jones, D. E. & et al. Moqui Ecosystem. Available at: [https://www.moqui.org/.](https://www.moqui.org/.)
    (Accessed: 30th March 2018).'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jones, D. E. & 等人。Moqui 生态系统。可在以下链接查看：[https://www.moqui.org/.](https://www.moqui.org/.)
    （访问日期：2018年3月30日）。
- en: Soppelsa, F. & Kaewkasi, C. *Native Docker Clustering with Swarm.* (Packt Publishing
    - ebooks Account, 2017).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Soppelsa, F. & Kaewkasi, C. *使用 Swarm 实现原生 Docker 集群。*（Packt Publishing - 电子书帐户，2017年）。
- en: Marmol, V., Jnagal, R. & Hockin, T. Networking in containers and container clusters.
    *Proceedings of netdev 0.1, February* (2015).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Marmol, V., Jnagal, R. & Hockin, T. 容器和容器集群中的网络。*netdev 0.1 会议论文集，2015年2月*（2015年）。
- en: Ellis, A. *OpenFaaS - Serverless Functions Made Simple for Docker & Kubernetes.*
    (OpenFaaS, 2018).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ellis, A. *OpenFaaS - 为 Docker 和 Kubernetes 简化的无服务器函数。*（OpenFaaS，2018年）。
- en: Amazon Web Services, Inc. Optimizing Enterprise Economics with Serverless Architectures.
    (2017).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚马逊网络服务公司（AWS）。通过无服务器架构优化企业经济学。（2017年）。
- en: 'Parse Community,The. Parse + Open Source. *Parse Open Source Hub* Available
    at: [http://parseplatform.org/.](http://parseplatform.org/.) (Accessed: 30th March
    2018).'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Parse Community, The。Parse + 开源。*Parse开源平台* 可访问：[http://parseplatform.org/.](http://parseplatform.org/.)（访问日期：2018年3月30日）。
- en: 'Vilmart, F. & et al. parse-server: *Parse-compatible API server module for
    Node/Express*. (Parse, 2018).'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vilmart, F. 等人。parse-server：*兼容Parse的API服务器模块，适用于Node/Express*。（Parse，2018年）。
- en: 'Linux Foundation,The. *runc: CLI tool for spawning and running containers according
    to the OCI specification*. (Open Container Initiative, 2018).'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux基金会。*runc：根据OCI规范生成和运行容器的CLI工具*。（开放容器倡议，2018年）。
- en: Christensen, B., Karnok, D. & et al. *RxJava – Reactive Extensions for the JVM
    – a library for composing asynchronous and event-based programs using observable
    sequences for the Java VM*. (ReactiveX, 2018).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Christensen, B., Karnok, D. 等人。*RxJava – JVM的反应式扩展 – 用于在Java虚拟机上使用可观察序列来编写异步和基于事件的程序的库*。（ReactiveX，2018年）。
- en: 'Roberts, M. Serverless Architectures. *martinfowler.com* (2016). Available
    at: [https://martinfowler.com/articles/serverless.html.](https://martinfowler.com/articles/serverless.html.)
    (Accessed: 28th March 2018).'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Roberts, M. 无服务器架构。*martinfowler.com*（2016年）。可访问：[https://martinfowler.com/articles/serverless.html.](https://martinfowler.com/articles/serverless.html.)（访问日期：2018年3月28日）。
- en: 'Baldini, I. et al. Serverless computing: Current trends and open problems.
    in *Research Advances in Cloud Computing* 1–20 (Springer, 2017).'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Baldini, I. 等人。无服务器计算：当前趋势与开放问题。见*云计算研究进展*，1-20页（Springer，2017年）。
- en: 'GOTO Conferences. *Serverless: the Future of Software Architecture by Peter
    Sbarski.* (2017).'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GOTO Conferences。*无服务器：软件架构的未来——由Peter Sbarski讲述。*（2017年）。
- en: Fox, G. C., Ishakian, V., Muthusamy, V. & Slominski, A. Status of Serverless
    Computing and Function-as-a-Service (FaaS) in Industry and Research. *arXiv preprint
    arXiv:1708.08028* (2017).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fox, G. C., Ishakian, V., Muthusamy, V. & Slominski, A. 无服务器计算与函数即服务（FaaS）在行业与研究中的现状。*arXiv预印本arXiv:1708.08028*（2017年）。
- en: 'Docker Inc. Swarm mode overview. *Docker Documentation (2018)*. Available at:
    [https://docs.docker.com/engine/swarm/.](https://docs.docker.com/engine/swarm/.)
    (Accessed: 28th March 2018).'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Inc. Swarm模式概述。*Docker文档（2018）*。可访问：[https://docs.docker.com/engine/swarm/.](https://docs.docker.com/engine/swarm/.)（访问日期：2018年3月28日）。
- en: Kaewkasi, C. & et al. *The Docker Swarm 2000 Collaborative Project.* (SwarmZilla
    Collaborative Project, 2016).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kaewkasi, C. 等人。*Docker Swarm 2000协作项目。*（SwarmZilla协作项目，2016年）。
- en: 'Containous. Træfik. Available at: [https://traefik.io/.](https://traefik.io/.)
    (Accessed: 1st April 2018).'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Containous。Træfik。可访问：[https://traefik.io/.](https://traefik.io/.)（访问日期：2018年4月1日）。
- en: 'Lubin, J. & et al. Truffle Suite - Your Ethereum Swiss Army Knife. *Truffle
    Suite* Available at: [http://truffleframework.com.](http://truffleframework.com./)
    (Accessed: 30th March 2018).'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lubin, J. 等人。Truffle Suite - 你的以太坊瑞士军刀。*Truffle Suite* 可访问：[http://truffleframework.com.](http://truffleframework.com./)（访问日期：2018年3月30日）。
- en: 'Weaveworks Inc. Weave Net: Network Containers Across Environments | Weaveworks.
    Available at: [https://www.weave.works/oss/net/.](https://www.weave.works/oss/net/.)
    (Accessed:30th March 2018).'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Weaveworks Inc. Weave Net：跨环境的网络容器 | Weaveworks。可访问：[https://www.weave.works/oss/net/.](https://www.weave.works/oss/net/.)（访问日期：2018年3月30日）。
