- en: Introduction to Docker Content Trust
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 内容信任简介
- en: In this chapter, we will learn about the Docker Content Trust concept and its
    related tools. To provide trusted content in Docker environments, we will use
    Docker Content Trust to encrypt metadata information applied to Docker objects.
    Therefore, any unauthorized changes or object manipulation will be reported. We
    will be able to ensure that all the objects in our environment are trusted if
    none of these issues are found.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Docker 内容信任概念及其相关工具。为了在 Docker 环境中提供受信任的内容，我们将使用 Docker 内容信任来加密应用于
    Docker 对象的元数据。因此，任何未经授权的更改或对象操作都会被报告。如果没有发现这些问题，我们就能够确保环境中的所有对象都是受信任的。
- en: First, we will introduce The Update Framework, and then we will learn how to
    sign images. After that, we will learn how to verify signatures to ensure their
    precedence and ownership. Finally, we will apply those concepts to run a trusted
    environment in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍更新框架，然后学习如何签名镜像。之后，我们将学习如何验证签名，以确保其优先性和所有权。最后，我们将应用这些概念，在生产环境中运行一个受信任的环境。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The Update Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新框架
- en: Signing images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名镜像
- en: Reviewing signatures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查签名
- en: Creating and running applications in trusted environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在受信任的环境中创建和运行应用程序
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will learn about various Docker Content Trust concepts.
    We''ll provide some labs at the end of this chapter that will help you understand
    and learn about the shown concepts. These labs can be run on your laptop or PC
    using the provided Vagrant standalone environment or any already-deployed Docker
    host deployed by yourself. You can find additional information in this book''s
    GitHub code repository: [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于各种 Docker 内容信任的概念。在本章末尾，我们将提供一些实验，帮助你理解并学习所展示的概念。这些实验可以在你的笔记本电脑或
    PC 上运行，使用提供的 Vagrant 独立环境，或者使用你自己部署的任何 Docker 主机。你可以在本书的 GitHub 代码仓库中找到更多信息：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码如何运作：
- en: '"[https://bit.ly/3b0qviR](https://bit.ly/3b0qviR)"'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/3b0qviR](https://bit.ly/3b0qviR)"'
- en: The Update Framework
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新框架
- en: 'Before learning about **The Update Framework**, also known as **TUF**, we will
    introduce a number of concepts. The following concepts will help us understand
    why we need tools to manage application updates:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 **更新框架**（也称为 **TUF**）之前，我们将介绍一些概念。以下概念将帮助我们理解为什么我们需要工具来管理应用程序更新：
- en: '**Software update system**: A software update system is an application that
    looks for new updates continuously. When they are found, it triggers processes
    to get these updates and installs these changes. A good example is the Google
    Chrome web browser update system. It continuously looks for its components'' updates
    and, once they are found, it will show us a There is a new release, do you want
    to update now? message.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件更新系统**：软件更新系统是一种持续寻找新更新的应用程序。当找到更新时，它会触发过程以获取这些更新并安装这些更改。一个很好的例子是 Google
    Chrome 浏览器的更新系统。它会持续寻找其组件的更新，一旦发现更新，就会向我们显示一条消息：有一个新版本，是否现在更新？'
- en: '**Library package managers**: The library package managers will manage and
    update programming language libraries and their dependencies. Python''s **Package
    Installer for Python** (**PIP**) and Node.js''s **Node Package Manager** (**NPM**)
    are good examples. These applications look for library updates and install them
    with their requisite dependencies.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库包管理器**：库包管理器将管理和更新编程语言库及其依赖项。Python 的 **Python 包安装器**（**PIP**）和 Node.js
    的 **Node 包管理器**（**NPM**）就是很好的例子。这些应用程序会查找库的更新并安装它们及其所需的依赖项。'
- en: '**Operating system component updates**: In this case, different package managers
    will manage all software updates and their dependencies, triggering, in some cases,
    some of the aforementioned solutions (software update systems or library package
    managers).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统组件更新**：在这种情况下，不同的软件包管理器将管理所有软件更新及其依赖项，并在某些情况下触发前面提到的某些解决方案（软件更新系统或库包管理器）。'
- en: 'An application update usually takes three logical steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序更新通常包含三个逻辑步骤：
- en: It looks for any update or change.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会查找任何更新或更改。
- en: It downloads updates.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它下载更新。
- en: It applies changes to our system.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将更改应用于我们的系统。
- en: What would happen if those updates were malicious because the code was intercepted
    and modified by an attacker?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些更新是恶意的，因为代码被攻击者截获并篡改了，会发生什么情况？
- en: TUF was created to prevent these situations. It will handle the steps described
    for application updates to ensure that downloaded changes are trusted. No manipulated
    changes will be allowed. TUF metadata includes information related to trusted
    keys, cryptographic hashes and files, component versions, creation and expiration
    dates, and signatures. An application that requires a number of updates does not
    have to manage this verification process. It will ask TUF to manage these processes.
    To summarize, we can say, in a way, that TUF provides a secure method of obtaining
    trusted files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TUF 被创建来防止这些情况。它将处理应用程序更新的步骤，以确保下载的更改是受信任的。不会允许篡改的更改。TUF 元数据包括与受信任的密钥、加密哈希、文件、组件版本、创建和过期日期以及签名相关的信息。一个需要多个更新的应用程序无需管理此验证过程。它将请求
    TUF 来管理这些过程。总而言之，我们可以这样说，TUF 提供了一种安全的方法来获取受信任的文件。
- en: TUF is currently hosted by the Linux Foundation as part of the **Cloud Native
    Computing Foundation** (**CNCF**). It is open source and can be used in production
    environments. It is recommended to use this in conjunction with some vendor tools
    because it will be easier to manage and use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TUF 目前由 Linux 基金会托管，作为 **云原生计算基金会**（**CNCF**）的一部分。它是开源的，可以在生产环境中使用。建议与一些厂商工具结合使用，这样更容易管理和使用。
- en: 'TUF metadata provides information about the truthfulness of the update to the
    software update system. This component will then make the right decision (install
    or reject the update). This metadata information will be presented in JSON format.
    We will talk about four levels of signing. We will refer to them as roles:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TUF 元数据为软件更新系统提供了有关更新真实性的信息。然后，该组件将做出正确的决定（安装或拒绝更新）。这些元数据信息将以 JSON 格式呈现。我们将讨论四个级别的签名，并将其称为角色：
- en: '**Root metadata (**`root.json`**) and role**: This role is related to the owner
    of the change. It is the top role; others will be related to this one.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根元数据（`root.json`）和角色**：此角色与变更的所有者相关。它是顶级角色，其他角色将与该角色相关联。'
- en: '**Targets metadata (**`targets.json`**) and role**: This role is related to
    the files included in the package.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标元数据（`targets.json`）和角色**：此角色与包中包含的文件相关。'
- en: '**Snapshot metadata (**`snapshot.json`**) and role**: All files apart from
    `timestamp.json` will be listed on this role to ensure the consistency of updates.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快照元数据（`snapshot.json`）和角色**：除了 `timestamp.json` 之外的所有文件都将在该角色中列出，以确保更新的一致性。'
- en: '**Timestamp metadata (**`timestamp.json`**) and role**: This sign will ensure
    the exact date of the update and that it is the only one required when checking
    for updates, for example.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳元数据（`timestamp.json`）和角色**：这个标志将确保更新的确切日期，并且在检查更新时它是唯一需要的标志，例如。'
- en: The update application uses TUF to interact with the repositories and sources
    of files while managing their updates. Roles, trusted keys, and target files should
    not be included in those repositories because they will be used to manage them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更新应用程序使用 TUF 与仓库和文件来源进行交互，同时管理它们的更新。角色、受信任的密钥和目标文件不应包含在这些仓库中，因为它们将用于管理这些内容。
- en: 'There should be a client side on this framework so that we can include the
    roles described in its normal usage. Therefore, a client side must manage the
    following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架应该有一个客户端，以便我们可以在其正常使用中包含所描述的角色。因此，客户端必须管理以下内容：
- en: Trusted root keys, from all possible owners that must be trusted
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可能的所有者的受信任根密钥，必须被信任
- en: Target delegation, when there is a target with many owners
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标委托，当一个目标有多个所有者时
- en: Checking for updates using timestamp role dates
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间戳角色日期检查更新
- en: All signing processes
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有签名过程
- en: Now that we know the benefits of using TUF to manage repository updates, let's
    review how this is implemented in Docker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用 TUF 来管理仓库更新的好处，接下来让我们回顾一下它在 Docker 中的实现方式。
- en: Docker Content Trust is the Docker implementation of TUF. It is integrated using
    Notary, which is an open source tool for publishing and managing trusted content.
    The Docker client provides an interface that allows us to sign and verify content
    publishers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 内容信任是 Docker 实现的 TUF。它通过 Notary 集成，Notary 是一个用于发布和管理受信任内容的开源工具。Docker
    客户端提供了一个界面，允许我们签名并验证内容发布者。
- en: Notary is a separate piece of software; it can be downloaded and used to inspect
    keys included in a Docker registry. Docker integrates Notary using its library.
    Therefore, every time we pull an image when Docker Content Trust is enabled (disabled
    by default), the Docker daemon will validate its signatures. Image pulling is
    done by its digest. Image names and tags will not be used. This ensures that only
    the right image will be downloaded.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Notary 是一个独立的软件；可以下载并用于检查包含在 Docker 仓库中的密钥。Docker 使用其库集成了 Notary。因此，每当我们在启用
    Docker 内容信任时拉取镜像（默认情况下为禁用）时，Docker 守护进程将验证其签名。镜像拉取是通过其摘要进行的。镜像名称和标签将不再使用。这确保了只有正确的镜像会被下载。
- en: 'Notary usage is beyond the scope of this book. At the time of writing, it is
    not required in order to pass the DCA certification exam. It is recommended, however,
    to read about some of the Notary features provided at the following link: [https://docs.docker.com/notary/getting_started](https://docs.docker.com/notary/getting_started).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Notary 的使用超出了本书的范围。在撰写时，它并不是通过 DCA 认证考试的必需内容。不过，建议阅读以下链接提供的 Notary 特性：[https://docs.docker.com/notary/getting_started](https://docs.docker.com/notary/getting_started)。
- en: When we use Docker Content Trust and we push an image, the Docker client will
    ask us to sign at all the levels described (root, target, snapshot, and timestamp).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Docker 内容信任并推送镜像时，Docker 客户端会要求我们在所有描述的级别上进行签名（根级别、目标级别、快照级别和时间戳级别）。
- en: 'In summary, Docker Content Trust (Docker''s TUF implementation) will do the
    following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Docker 内容信任（Docker 的 TUF 实现）将执行以下操作：
- en: Ensure image provenance
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保镜像来源的可信度
- en: Sign content prior to distribution
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分发之前签署内容
- en: Ensure that everything running on a host is trusted.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保主机上运行的所有内容都是可信的。
- en: In the next section, we will learn how to sign and use signed images that have
    been validated by Docker Engine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何签署并使用经过 Docker 引擎验证的签名镜像。
- en: Signing images
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署镜像
- en: 'So far, we have learned about the different roles and the metadata information
    that will be used to validate and trust image content. Let''s look at a quick
    summary before getting into the Docker signing action:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了不同的角色和将用于验证和信任镜像内容的元数据。让我们在进入 Docker 签名操作之前，快速总结一下：
- en: The root key will validate other keys. It signs the `root.json` file, which
    contains the list of IDs of the root, targets, snapshot, and timestamp public
    keys. To verify content signatures, the Docker client will use these public keys.
    The root key is offline and must be kept safe. The owner of a collection of images
    should maintain this key. Don't lose this key. You can recreate it, but all your
    signed images will be invalid.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根密钥将验证其他密钥。它签署 `root.json` 文件，该文件包含根、目标、快照和时间戳公钥的 ID 列表。为了验证内容签名，Docker 客户端将使用这些公钥。根密钥是离线的，必须保管好。镜像集合的所有者应该保管此密钥。不要丢失此密钥。你可以重新创建它，但所有签名的镜像将无效。
- en: The target key signs the `targets.json` file, which contains a list of your
    content filenames, along with their sizes and hashes. This file is used to delegate
    trust to other users in a team so that others can sign the same repository. This
    key is held by administrators and owners of a collection (repository).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标密钥签署 `targets.json` 文件，其中包含内容文件名的列表，以及它们的大小和哈希值。该文件用于将信任委派给团队中的其他用户，以便其他人可以签署相同的仓库。此密钥由管理员和集合（仓库）所有者持有。
- en: The delegation key is used to sign delegation metadata files. This key is held
    by administrators and everyone who can contribute to the specified collection.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委派密钥用于签署委派元数据文件。此密钥由管理员和所有能为指定集合做出贡献的人持有。
- en: The snapshot key signs the `snapshot.json` metadata file. This file also contains
    filenames, as well as the sizes and hashes of root, targets, and delegation files
    in the collection. This key will be held by administrators and the collection
    owner. If we use the Notary service, this key can also be held by this service
    to allow signing by collection collaborators. This key represents the current
    package signature.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照密钥签署 `snapshot.json` 元数据文件。该文件还包含文件名、以及根、目标和委派文件的大小和哈希值。此密钥由管理员和集合所有者持有。如果我们使用
    Notary 服务，此密钥也可以由该服务持有，以允许集合协作者签署。此密钥代表当前的包签名。
- en: The timestamp key ensures the freshness of the collection. It is used to verify
    the integrity of the `snapshot.json` file. Because this key is only valid for
    a period of time, it is better to be held in Notary. In this case, it will not
    be necessary that owners recreate the key each time it expires. Notary will regenerate
    this key as needed.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳密钥确保集合的新鲜度。它用于验证 `snapshot.json` 文件的完整性。因为这个密钥只在一定时间内有效，所以最好将其保存在 Notary
    中。在这种情况下，所有者不必在每次密钥过期时重新创建密钥。Notary 将根据需要重新生成这个密钥。
- en: Now, let's sign an image using the Docker client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Docker 客户端签名一个镜像。
- en: 'First, we will enable Docker Content Trust. By default, it is not enabled.
    We can enable it for all Docker commands or add an argument each time we want
    to enable it. To enable Docker Content Trust for all subsequent Docker commands,
    we need to define the `DOCKER_CONTENT_TRUST` variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将启用 Docker 内容信任。默认情况下，它是禁用的。我们可以为所有 Docker 命令启用它，或者每次想启用时添加一个参数。要为所有后续的
    Docker 命令启用 Docker 内容信任，我们需要定义 `DOCKER_CONTENT_TRUST` 变量：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, we can enable Docker Content Trust for only specified commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以为指定的命令启用 Docker 内容信任：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We used `--disable-content-trust=false` here because, by default, Docker Content
    Trust is disabled.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了 `--disable-content-trust=false`，因为默认情况下，Docker 内容信任是禁用的。
- en: 'Now that we have enabled Docker Content Trust for all commands in this session
    by setting `DOCKER_CONTENT_TRUST= 1`, we can pull an image using `docker image
    pull`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过设置 `DOCKER_CONTENT_TRUST=1` 为当前会话中的所有命令启用了 Docker 内容信任，我们可以使用 `docker
    image pull` 拉取镜像：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the `docker image pull` command's output changed. In fact, the downloaded
    image was managed by its hash; in this case, `busybox@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`docker image pull` 命令的输出发生了变化。事实上，下载的镜像是通过其哈希值进行管理的；在这种情况下，哈希值是 `busybox@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a`。
- en: Docker's official images and certified images are always signed. Official images
    are managed and built by Docker, and they are located under `docker.io/<REPOSITORY>:<TAG>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的官方镜像和认证镜像始终是已签名的。官方镜像由 Docker 管理和构建，位于 `docker.io/<REPOSITORY>:<TAG>`
    下。
- en: 'Let''s run this image using `docker container run` and see what happens:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `docker container run` 来运行这个镜像，看看会发生什么：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It worked, as expected. We added a file because we wanted to modify a container
    before committing its content to create a new, untrusted image. For this process,
    we will run `docker container commit`, setting `DOCKER_CONTENT_TRUST=0` for the
    command. We do this because Content Trust was previously enabled in our current
    session:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按预期，它成功了。我们添加了一个文件，因为我们想要在提交容器的内容之前修改容器，以创建一个新的、不受信任的镜像。对于这个过程，我们将运行 `docker
    container commit`，并为命令设置 `DOCKER_CONTENT_TRUST=0`。我们之所以这么做，是因为在当前会话中已启用内容信任：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have an untrusted `busybox`image. What will happen if we try to execute
    this image?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个不受信任的 `busybox` 镜像。如果我们尝试执行这个镜像，会发生什么呢？
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We cannot run this image because it is not trusted; it does not have any content
    trust metadata. Therefore, it cannot be validated and will not be allowed to run.
    If Docker Content Trust is enabled, unsigned images will not be allowed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能运行这个镜像，因为它不受信任；它没有任何内容信任元数据。因此，它无法通过验证，并且不会被允许运行。如果启用了 Docker 内容信任，则未签名的镜像将不被允许。
- en: 'Let''s sign this image. In this case, we will change the image name and create
    a new `trusted` tag. The signing process requires two passphrases, as described
    here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们签名这个镜像。在这种情况下，我们将更改镜像名称并创建一个新的 `trusted` 标签。签名过程需要两个密码短语，正如这里所述：
- en: First, we will be asked to set a `root` passphrase. You will be asked twice
    to validate the password that's entered as it is not shown.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将被要求设置一个 `root` 密码短语。你将被再次询问两次，以验证输入的密码（因为密码不会显示）。
- en: Then, you will be asked to set a `repository` passphrase. You will be asked
    twice again to validate the password that's entered as it is not shown.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你会被要求设置一个 `repository` 密码短语。你将被再次询问两次，以验证输入的密码（因为密码不会显示）。
- en: 'We have been asked for the passphrase twice because we are setting their values
    for the first time. Next time we use these keys to push or pull to this repository,
    we will be asked just once (or more if it was typed in incorrectly). Let''s execute
    `docker image push`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求输入密码短语两次，因为这是第一次设置它们的值。下次我们使用这些密钥推送或拉取到这个仓库时，只会被要求一次（如果密码输入错误，可能会要求更多次）。让我们执行
    `docker image push`：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The root passphrase is very important. Keep it safe because if you lose it,
    you will need to start again. If this happens, your already-signed images will
    be untrusted and you will need to update them. If you lose a key, you will need
    to contact Docker Support (`support@docker.com`) to reset the repository state.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根密码短语非常重要。请妥善保管，因为如果丢失，你需要重新开始。如果发生这种情况，你之前签名的镜像将变得不受信任，你需要更新它们。如果丢失了密钥，你需要联系Docker支持（`support@docker.com`）来重置仓库状态。
- en: The passphrases you choose for both the root key and your repository should
    be strong. It is recommended to use randomly generated ones.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你为根密钥和你的仓库选择的密码短语应该是强密码。建议使用随机生成的密码。
- en: Now, we have a signed image. It is owned by us (in this example, I am the owner
    of `frjaraur/mybusybox:trusted`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有一个已签名的镜像。它归我们所有（在这个例子中，我是`frjaraur/mybusybox:trusted`的所有者）。
- en: 'Now, we can execute this newly signed (and hence trusted) image using `docker
    container run`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`docker container run`来执行这个新签名的（因此是受信的）镜像：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To manage Docker Content Trust, we can use `docker trust` with its available
    actions. We will be able to manage keys (load and revoke) and sign images (this
    process is similar to the one previously described). We can review these signatures
    using `docker trust inspect`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理Docker内容信任，我们可以使用`docker trust`及其可用的操作。我们将能够管理密钥（加载和撤销）并签名镜像（该过程类似于前面描述的过程）。我们可以使用`docker
    trust inspect`来查看这些签名：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we have used `docker.io/frjaraur/mybusybox:trusted` instead of `frjaraur/mybusybox:trusted`.
    This is because if we do not use the registry's **fully qualified domain name**
    (**FQDN**) and the image exists locally, it will be used to retrieve all signature
    information and you will receive a `WARN[0006] Error while downloading remote
    metadata, using cached timestamp - this might not be the latest version available
    remotely` message because you will be using the cached timestamp instead of the
    real one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`docker.io/frjaraur/mybusybox:trusted`而不是`frjaraur/mybusybox:trusted`。这是因为如果我们没有使用注册表的**完全限定域名**（**FQDN**）且镜像在本地存在，它将用于检索所有签名信息，你将收到`WARN[0006]
    Error while downloading remote metadata, using cached timestamp - this might not
    be the latest version available remotely`的消息，因为你将使用缓存的时间戳，而不是实际的时间戳。
- en: Now that we have learned how to sign content – in this case, images – let's
    move on and learn how to verify signatures.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何签署内容——在这种情况下是镜像——接下来让我们学习如何验证签名。
- en: Reviewing signatures
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查签名
- en: The Docker client stores content trust-related files under the `.docker/trust`
    directory, inside the user's home directory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端将与内容信任相关的文件存储在用户主目录下的`.docker/trust`目录中。
- en: 'If we navigate to the trusted directory, we will find different registry files
    under `.docker/trust/tuf`. We used Docker Hub in this chapter''s examples. Therefore,
    we will find the `docker.io` registry and different repositories. This may vary
    in your environment; you may have more registries or repositories. It will depend
    on when you started to use Docker Content Trust in your Docker host. Using the
    examples from the previous sections, we will find a tree-like directory structure
    under the `.docker` directory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到受信目录下，我们将在`.docker/trust/tuf`中找到不同的注册表文件。我们在本章的示例中使用了Docker Hub。因此，我们会找到`docker.io`注册表和不同的仓库。在你的环境中可能会有所不同，你可能会有更多的注册表或仓库，这取决于你何时开始在Docker主机上使用Docker内容信任。根据前面部分的示例，我们将在`.docker`目录下找到类似树形结构的目录：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember the JSON files described in the previous section. All these files are
    located under each registry and repository's structure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记住前面一节中描述的JSON文件。所有这些文件都位于每个注册表和仓库的结构下。
- en: The Docker client will store your keys under your `.docker/trust/private` directory.
    It is very important to keep them safe. To back up these keys, use the `$ umask
    077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private; umask 022`
    command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端会将你的密钥存储在`.docker/trust/private`目录下。妥善保管这些密钥非常重要。要备份这些密钥，可以使用`$ umask
    077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private; umask 022`命令。
- en: Notary will assist us in managing signatures. It is an open source server and
    client application and can be downloaded from its GitHub project page ([https://github.com/theupdateframework/notary](https://github.com/theupdateframework/notary)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Notary将帮助我们管理签名。它是一个开源的服务器和客户端应用程序，可以从其GitHub项目页面下载([https://github.com/theupdateframework/notary](https://github.com/theupdateframework/notary))。
- en: Notary can be installed either on Linux or Windows hosts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Notary可以安装在Linux或Windows主机上。
- en: 'We will simply download the latest release using the `curl` command and modify
    its permissions and path:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`curl`命令下载最新版本，并修改其权限和路径：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this section, we will use Docker's own Notary server that's been published
    on the internet ([https://notary.docker.io](https://notary.docker.io)) and that
    is associated with Docker Hub.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Docker自己发布的Notary服务器，该服务器已在互联网上发布（[https://notary.docker.io](https://notary.docker.io)），并且与Docker
    Hub相关联。
- en: Docker Enterprise will run its own Docker Notary server implementation in your
    environment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Docker企业版将在你的环境中运行自己的Docker Notary服务器实现。
- en: 'Let''s verify, for example, all the signatures associated with a Docker Hub
    repository. In this example, we are reviewing the `busybox` repository. We use
    `notary list` with the appropriate server and directory arguments:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证，例如，与Docker Hub仓库关联的所有签名。在这个例子中，我们正在查看`busybox`仓库。我们使用`notary list`，并提供适当的服务器和目录参数：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We listed all the targets on a remote trusted collection – in this case, the
    `busybox` collection on Docker Hub (`docker.io/library/busybox`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出了远程受信集合中的所有目标——在这个例子中，是Docker Hub上的`busybox`集合（`docker.io/library/busybox`）。
- en: Now, let's learn how to automate these processes and ensure security to build
    a trusted environment in our organization.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何自动化这些过程，并确保安全性，以便在我们的组织中构建一个受信环境。
- en: Creating and running applications in trusted environments
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在受信环境中创建和运行应用程序
- en: In this section, we will consider a trusted environment where `CONTENT_TRUST_ENABLED`
    is used for all actions. This will ensure that images built in that environment
    will always be signed. All images that have been pushed and pulled will be signed,
    and we will only run containers based on trusted images.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑一个受信环境，在其中`CONTENT_TRUST_ENABLED`会用于所有操作。这将确保在该环境中构建的镜像始终会被签名。所有已推送和拉取的镜像都会被签名，我们只会运行基于受信镜像的容器。
- en: It is interesting to add CI/CD orchestration tools to these processes. It is
    not easy to disallow non-trusted content without some system or even higher security
    policies. If we set the `DOCKER_CONTENT_TRUST` value to only allow Docker Content
    Trust, but users are allowed to interact with the Docker host directly, they can
    disable this feature at the command line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将CI/CD编排工具加入这些流程是非常有趣的。在没有某些系统或更高安全政策的情况下，禁止非受信内容并不容易。如果我们将`DOCKER_CONTENT_TRUST`的值设置为仅允许Docker内容信任，但用户可以直接与Docker主机交互，那么他们可以在命令行禁用此功能。
- en: Automation is key in production environments, although it is true that Docker
    Enterprise provides other methods, which we will discuss later on in [Chapter
    12](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control Plane*. Kubernetes
    also provides features to force security for trusted content, but this topic is
    beyond the scope of this book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化在生产环境中至关重要，尽管Docker企业版提供了其他方法，我们将在[第12章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)中讨论，*通用控制平面*。Kubernetes也提供了强制执行受信内容安全的功能，但这一话题超出了本书的范围。
- en: 'Using an external CI/CD, we can automate the building, sharing, or deployment
    of Docker content. Let''s look at a brief example of building and pushing an image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部CI/CD，我们可以自动化构建、共享或部署Docker内容。让我们看一个简单的例子，展示如何构建和推送一个镜像：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can write a script for a CI/CD orchestration job using the `root` and `repository`
    passphrases to ensure that content trust is applied during building and pushing
    to our registry. We can follow the same method to deploy on production, disallowing
    any user interaction with this secure environment. Take care of environment variables
    for passphrases on scripts because they will be visible. CI/CD orchestrators will
    provide secure methods to manage this. This will give you an idea of how you should
    implement a secure chain with your own management configuration tools.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个脚本，用于CI/CD编排任务，使用`root`和`repository`密码短语来确保在构建和推送到我们的注册表时应用内容信任。我们可以使用相同的方法在生产环境中进行部署，禁止任何用户与这个安全环境进行交互。在脚本中处理密码短语的环境变量时要小心，因为它们将是可见的。CI/CD编排工具将提供安全的管理方法。这样，你就能了解如何使用你自己的管理配置工具来实现一个安全的链条。
- en: Now, let's review a lab to better understand the topics we've learned in this
    chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一个实验，更好地理解我们在本章中所学的内容。
- en: Chapter labs
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章实验
- en: We will now complete a lab that will help us improve on the concepts we've learned
    about.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将完成一个实验，帮助我们提升对所学概念的理解。
- en: Deploy `environments/standalone-environment`from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment`folder to start your virtual
    environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有部署过 `environments/standalone-environment`，请从本书的 GitHub 仓库（[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)）部署它。你也可以使用你自己的
    CentOS 7 服务器。从 `environments/standalone-environment` 文件夹中使用 `vagrant up` 启动你的虚拟环境。
- en: 'If you are using a standalone environment, wait until it is running. We can
    check the statuses of our nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用独立环境，请等它运行起来。我们可以使用 `vagrant status` 检查节点的状态。使用 `vagrant ssh standalone`
    连接到你的实验节点。`standalone` 是你的节点名称。你将使用具有管理员权限的 `vagrant` 用户，通过 `sudo` 执行操作。你应该会看到以下输出：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now connect to a standalone node using `vagrant ssh standalone`. This
    process may vary if you''ve already deployed a standalone virtual node before
    and you''ve just started it using `vagrant up`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `vagrant ssh standalone` 连接到独立节点。如果你之前已经部署过独立虚拟节点并且刚刚使用 `vagrant up`
    启动它，那么此过程可能会有所不同：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are reusing your standalone environment, this means Docker Engine is
    installed. If you started a new instance, please execute the `/vagrant/install_requirements.sh`
    script so that you have all the required tools (Docker Engine and `docker-compose`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在重复使用你的独立环境，这意味着 Docker Engine 已经安装。如果你启动了一个新的实例，请执行 `/vagrant/install_requirements.sh`
    脚本，以确保你拥有所有必需的工具（Docker Engine 和 `docker-compose`）：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you are ready to start the labs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好开始实验了。
- en: Signing images for Docker Hub
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Docker Hub 签名镜像
- en: 'First, sign in to [https://hub.docker.com/signup](https://hub.docker.com/signup)
    to create your own account at Docker Hub if you do not already have one. You can
    use your own registry, but you should have a Notary server running. Let''s get
    started:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你还没有 Docker Hub 账户，请登录 [https://hub.docker.com/signup](https://hub.docker.com/signup)
    创建一个账户。你可以使用你自己的注册中心，但你需要有一个 Notary 服务器在运行。让我们开始吧：
- en: This lab will use the `frjaraur/pingo` repository in Docker Hub. You must substitute
    `frjaraur` with your username.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验将使用 Docker Hub 上的 `frjaraur/pingo` 仓库。你必须将 `frjaraur` 替换为你的用户名。
- en: 'In this lab, we will start from the very beginning. This is a lab, so don''t
    remove your own `.docker/trust` directory if you have been signing images beforehand.
    In that case, back up your trust directory somewhere safe so that you can recover
    it later or just create a dummy user in your Docker host system. To create this
    backup, we will just execute `cp -pR ~/.docker/trust ~/.docker/trust.BKP`. After
    these labs, you can recover it:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本实验中，我们将从头开始。如果你之前已经签名过镜像，别删除你自己的 `.docker/trust` 目录。在这种情况下，请将信任目录备份到一个安全的位置，以便稍后恢复，或者干脆在
    Docker 主机系统中创建一个虚拟用户。为了创建这个备份，我们将执行 `cp -pR ~/.docker/trust ~/.docker/trust.BKP`。在这些实验完成后，你可以恢复它：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, enable Docker Content Trust and create a directory for this lab:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启用 Docker 内容信任并为本实验创建一个目录：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have prepared a quite-simple Dockerfile, executing `ping` to `8.8.8.8` for
    `300` times. These lab files can be found in the `chapter6` directory if you have
    downloaded the book samples from this book''s GitHub repository. Create a `Dockerfile`
    file with the following content using your file editor:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备了一个相当简单的 Dockerfile，它将 `ping` 命令发送到 `8.8.8.8`，并执行 `300` 次。如果你从本书的 GitHub
    仓库下载了书本示例文件，可以在 `chapter6` 目录中找到这些实验文件。使用你的文本编辑器创建一个包含以下内容的 `Dockerfile` 文件：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can build the image. Remember that Docker Content Trust was enabled.
    We will use `docker image build` in the directory where you wrote your Dockerfile:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构建镜像。记得已经启用了 Docker 内容信任（Docker Content Trust）。我们将在你编写 Dockerfile 的目录中使用
    `docker image build`：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may have noticed new messages from the Docker daemon. The daemon used the
    `alpine:3.8` image hash, `sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9`,
    instead of the image name and tag. If we had an image locally with the same `image:tag`
    values, it would have been verified. If the hash did not match, it would have
    been avoided and the real image would have been downloaded from Docker Hub. This
    will ensure that the trusted `alpine:3.8` image will be downloaded.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到来自 Docker 守护进程的新消息。守护进程使用了`alpine:3.8`镜像哈希值`sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9`，而不是镜像名称和标签。如果我们本地有相同`image:tag`值的镜像，它将被验证。如果哈希不匹配，它将被避免，真实镜像将从
    Docker Hub 下载。这将确保下载的是受信任的`alpine:3.8`镜像。
- en: 'Now, we will sign this image using `docker trust sign`. This process will ask
    us to create a `root` passphrase, a `repository` passphrase, and a `user` passphrase
    (this is new in this chapter because we did not use Docker Content Trust in previous
    chapters). This will create a new `trust` directory under `.docker`*.* When the
    image is pushed, you will be asked about your registry user passphrase again.
    This is not your Docker Hub password. This is the passphrase you created so that
    you can perform signing. We will use `docker trust sign`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`docker trust sign`对这个镜像进行签名。此过程将要求我们创建一个`root`密码短语、一个`repository`密码短语和一个`user`密码短语（这是本章的新内容，因为我们在之前的章节中没有使用
    Docker Content Trust）。这将创建一个新的`trust`目录在`.docker`*.* 当镜像被推送时，你将再次被询问关于注册用户密码短语的问题。这不是你的
    Docker Hub 密码，而是你为执行签名操作创建的密码短语。我们将使用`docker trust sign`：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With that, the image was signed and pushed to Docker Hub. We can verify that
    the image was uploaded by using `curl`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，镜像就已经签名并推送到 Docker Hub。我们可以使用`curl`验证镜像是否已上传：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we will review the image signatures using `docker trust inspect`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`docker trust inspect`查看镜像签名：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's look at a brief summary of the topics that were covered in this chapter
    before we look at some questions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们看一些问题之前，让我们简要总结一下本章所涵盖的主题。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Docker Content Trust helps us guarantee content security in container environments
    and ensure image provenance and trusted content. In production environments, it
    is critical to be able to ensure that any running container was generated from
    trusted content. If image security cannot be validated, no container should be
    allowed to run based on that image.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Content Trust 帮助我们确保容器环境中的内容安全，确保镜像的来源和受信任的内容。在生产环境中，能够确保任何正在运行的容器是由受信任内容生成的至关重要。如果无法验证镜像的安全性，则不应允许基于该镜像运行容器。
- en: We have learned that Content Trust improves Docker repository security by means
    of four fundamental keys. The root key ensures ownership and the targets key will
    allow content to be verified in specific collections or repositories. These keys
    will be protected by passphrases and we will be asked for them when signing. The
    snapshot and timestamp keys will not require any user interaction and will be
    generated automatically to guarantee the content key files and the dates and expiration
    of the signed image.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，Content Trust 通过四个基本密钥提高了 Docker 仓库的安全性。根密钥确保所有权，目标密钥允许验证特定集合或仓库中的内容。这些密钥将受到密码短语的保护，签名时会要求我们输入这些密码。快照和时间戳密钥不需要用户交互，将自动生成，以保证内容密钥文件以及签名镜像的日期和过期时间。
- en: In the next chapter, we will introduce the concept of orchestration. We will
    review all the features required to manage container-based applications in distributed
    environments.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍编排的概念。我们将回顾管理基于容器的应用程序在分布式环境中的所有功能。
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these sentences is not true?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪句话是不正确的？
- en: a) Docker Content Trust is based on TUF.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: a) Docker Content Trust 基于 TUF。
- en: b) TUF was developed to ensure software updating processes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: b) TUF（信任更新框架）被开发用来确保软件更新过程。
- en: c) It is not possible to validate new software releases.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: c) 无法验证新的软件版本。
- en: d) All of the preceding statements are false.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有陈述都是错误的。
- en: Which of the following names represent Docker Content Trust keys used to validate
    image content?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项名称表示用于验证镜像内容的 Docker Content Trust 密钥？
- en: a) Targets
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: a) 目标
- en: b) Users
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: b) 用户
- en: c) Groups
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: c) 组
- en: d) Timestamp
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: d) 时间戳
- en: How can we ensure that the `busybox:latest` release is, in fact, the latest
    one?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确保`busybox:latest`发布的镜像确实是最新的？
- en: a) We cannot ensure the freshness of images.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: a) 我们无法确保镜像的最新性。
- en: b) `busybox:latest` indicates that this image is the latest one created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: b) `busybox:latest`表示这是创建的最新镜像。
- en: c) Content Trust will validate the freshness of images; therefore, we can ensure
    that the host really executes the `busybox:latest` image, although we cannot ensure
    that it is the latest one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: c) 内容信任将验证镜像的新鲜度；因此，我们可以确保主机确实执行的是`busybox:latest`镜像，尽管我们无法确保它是最新的。
- en: d) All of the preceding statements are false.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: d) 之前的所有陈述都是错误的。
- en: 'Why will we obtain a `denied: requested access to the resource is denied` error
    when trying to sign `busybox:trusted`?'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为什么我们在尝试签署`busybox:trusted`时会遇到`denied: requested access to the resource is
    denied`错误？'
- en: a) This image does not exist.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: a) 此镜像不存在。
- en: b) We are not allowed to modify that repository.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: b) 我们不被允许修改该仓库。
- en: c) Docker Content Trust was probably not enabled.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: c) Docker 内容信任可能没有启用。
- en: d) All of the preceding.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: d) 之前的所有内容。
- en: We lost our root key because we changed our laptop. Which of the following statements
    is true?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们丢失了根密钥，因为我们更换了笔记本电脑。以下哪一项陈述是正确的？
- en: a) If we don't have a key under `.docker/trust/private`, a new one will be generated
    when signing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: a) 如果我们在`.docker/trust/private`下没有密钥，在签名时会生成一个新的密钥。
- en: b) We can recover the private root key if we perform a backup.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: b) 如果我们进行备份，我们可以恢复私钥根密钥。
- en: c) If we generate a new key, our old images will become untrusted and we will
    need to resign them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: c) 如果我们生成了新的密钥，我们的旧镜像将变得不可信，并且我们需要重新签名它们。
- en: d) All of the preceding statements are true.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: d) 之前的所有陈述都是正确的。
- en: Further reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on the topics that
    were covered in this chapter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，获取有关本章所涵盖主题的更多信息：
- en: 'TUF: [https://theupdateframework.io/](https://theupdateframework.io/)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TUF: [https://theupdateframework.io/](https://theupdateframework.io/)'
- en: 'TUF specification: [https://github.com/theupdateframework/specification](https://github.com/theupdateframework/specification)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TUF 规范: [https://github.com/theupdateframework/specification](https://github.com/theupdateframework/specification)'
- en: 'Notary: [https://github.com/theupdateframework/notary](https://github.com/theupdateframework/notary)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Notary: [https://github.com/theupdateframework/notary](https://github.com/theupdateframework/notary)'
- en: 'Docker Content Trust: [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 内容信任: [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)'
