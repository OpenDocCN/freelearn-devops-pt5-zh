- en: Orchestration - End-to-End Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调 - 端到端自动化
- en: '"The key to following the continuous delivery path is to continually question
    your own assumptions about what''s possible."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"遵循持续交付路径的关键是不断质疑自己对可能性假设的看法。"'
- en: '- Jeff Sussna'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Jeff Sussna'
- en: In this chapter, we will discuss different ways to automate application life
    cycle management, using orchestration available via open source and commercial
    alternatives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将讨论使用开源和商业替代方案提供的协调功能，自动化应用程序生命周期管理的不同方法。
- en: We will be using Jenkins plugins and Visual Studio Team Services tasks to orchestrate
    and automate all the activities that are performed during application life cycle
    management.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jenkins 插件和 Visual Studio Team Services 任务来协调和自动化应用程序生命周期管理期间执行的所有活动。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: End-to-end automation orchestration of application life cycle management using
    Jenkins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 进行应用程序生命周期管理的端到端自动化协调
- en: End-to-end automation using Jenkins, Chef, and AWS EC2
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins、Chef 和 AWS EC2 的端到端自动化
- en: End-to-end automation using Jenkins and AWS Elastic Beanstalk
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 和 AWS Elastic Beanstalk 的端到端自动化
- en: End-to-end automation using Jenkins and Microsoft Azure app services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 和 Microsoft Azure 应用服务的端到端自动化
- en: End-to-end automation orchestration of application life cycle management using
    VSTS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VSTS 进行应用程序生命周期管理的端到端自动化协调
- en: End-to-end automation of application life cycle management using Jenkins
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 进行应用程序生命周期管理的端到端自动化
- en: 'In [Chapter 2](part0047.html#1CQAE0-651ea628c0544d18a4415dfef8fe6271), *Continous
    Integration*, we created a build job that performs the following tasks:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](part0047.html#1CQAE0-651ea628c0544d18a4415dfef8fe6271)，*持续集成* 中，我们创建了一个构建作业，该作业执行以下任务：
- en: 'Static code analysis of the PetClinic web application:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 PetClinic Web 应用程序的静态代码分析：
- en: '![](img/00194.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00194.jpeg)'
- en: Successful execution of static code analysis will show a URL pointing to the
    SonaQube dashboard for a specific project in Jenkins dashboard.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态代码分析成功执行后，Jenkins 仪表板会显示指向特定项目的 SonaQube 仪表板的 URL。
- en: 'Verification of the Jenkins dashboard with all the analysis details:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 Jenkins 仪表板以及所有分析细节：
- en: '![](img/00206.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00206.jpeg)'
- en: 'Compilation of source files and unit test execution:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源文件编译和单元测试执行：
- en: '![](img/00295.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00295.jpeg)'
- en: Unit test results will be available in the Jenkins project dashboard itself.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试结果将显示在 Jenkins 项目仪表板本身。
- en: 'Creation of package files:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包文件的创建：
- en: '![](img/00298.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00298.jpeg)'
- en: Once our package file is ready we can deploy it in the AWSEC2 instance, Microsoft
    Azure Virtual Machine, AWS Elastic Beanstalk, Microsoft Azure App Services, containers,
    or any physical machine that is accessible from the system that Jenkins is installed
    on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的包文件准备好，我们可以将其部署到 AWSEC2 实例、Microsoft Azure 虚拟机、AWS Elastic Beanstalk、Microsoft
    Azure 应用服务、容器或任何可以从安装了 Jenkins 系统的物理机器访问的机器上。
- en: End-to-end automation using Jenkins, Chef, and AWS EC2
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins、Chef 和 AWS EC2 的端到端自动化
- en: In this section, we will orchestrate different tasks using the Build Pipeline
    plugin available in Jenkins.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Jenkins 中可用的 Build Pipeline 插件来协调不同的任务。
- en: In [Chapter 4](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271), *Cloud
    Computing and Configuration Management*, we installed a Chef workstation, configured
    the hosted Chef account, and installed knife plugins for AWS and Microsoft Azure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第4章](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271)，*云计算与配置管理* 中，我们安装了
    Chef 工作站，配置了托管 Chef 账户，并为 AWS 和 Microsoft Azure 安装了刀具插件。
- en: 'We created an instance in AWS EC2 using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令在 AWS EC2 中创建了一个实例：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We created a virtual machine in Microsoft Azure using the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令在 Microsoft Azure 中创建了一个虚拟机：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We verified the AWS EC2 instance and Microsoft Azure Virtual Machine registration
    in the hosted Chef.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证了 AWS EC2 实例和 Microsoft Azure 虚拟机在托管 Chef 中的注册。
- en: We executed both the commands from the command prompt. In Jenkins, we can execute
    commands for Windows, Linux, or Mac. We can execute the same commands from a Jenkins
    build job by creating a freestyle job.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从命令提示符执行了这两个命令。在 Jenkins 中，我们可以为 Windows、Linux 或 Mac 执行命令。我们也可以通过创建自由风格的作业，在
    Jenkins 构建作业中执行相同的命令。
- en: Configuring SSH authentication using a key
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密钥配置 SSH 身份验证
- en: A Chef workstation installed on a virtual machine is accessible from a system
    where we have installed Jenkins. We can create a virtual machine using a virtual
    box or a VMware workstation on a laptop; and can also then install CentOS 6 or
    7 and configure the Chef workstation the way we did in [Chapter 4](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271),
    *Cloud Computing and Configuration Management*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在虚拟机上的 Chef 工作站可以从安装了 Jenkins 的系统中访问。我们可以使用虚拟盒子或 VMware 工作站在笔记本上创建虚拟机；然后可以安装
    CentOS 6 或 7，并按照我们在[第 4 章](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271)中所做的配置
    Chef 工作站，*云计算与配置管理*。
- en: Before starting with the configuration of end-to-end automation and orchestration
    using a build pipeline plugin and upstream/downstream jobs, we will configure
    SSH authentication using a key.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始配置端到端自动化和使用构建管道插件以及上下游任务进行编排之前，我们将使用密钥配置 SSH 认证。
- en: 'The main objective behind configuring SSH authentication is to allow the Jenkins
    virtual machine to connect to the Chef workstation virtual machine. By doing this
    we can execute commands from the Jenkins machine on the Chef workstation. This
    way we can create an instance in AWS or the Azure cloud using the Chef workstation,
    and install a runtime environment on it to deploy the PetClinic application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 SSH 认证的主要目的是允许 Jenkins 虚拟机连接到 Chef 工作站虚拟机。这样我们就可以从 Jenkins 机器执行命令到 Chef 工作站。通过这种方式，我们可以使用
    Chef 工作站在 AWS 或 Azure 云中创建实例，并在其上安装运行时环境来部署 PetClinic 应用程序：
- en: '![](img/00002.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00002.jpeg)'
- en: 'If we try to access the Chef workstation from Jenkins, it won''t work, as we
    still need to configure a password-free configuration, because in the Jenkins
    job execution we can''t wait in the middle of a flow to give a password. Let''s
    configure password-free access on Jenkins to access the Chef workstation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从 Jenkins 访问 Chef 工作站，它将不起作用，因为我们仍然需要配置无密码配置，因为在 Jenkins 作业执行中，我们不能在流程中间等待输入密码。让我们配置无密码访问
    Jenkins，以便访问 Chef 工作站：
- en: 'Open a terminal in a virtual machine where Jenkins is installed. Use `ssh-keygen`
    to create a new key:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开安装了 Jenkins 的虚拟机中的终端。使用`ssh-keygen`创建一个新密钥：
- en: '![](img/00016.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: Verify the key on the local filesystem.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地文件系统上验证密钥。
- en: 'Copy the key to the remote host where the Chef workstation is configured using
    `ssh-copy-id`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ssh-copy-id`将密钥复制到配置了 Chef 工作站的远程主机：
- en: '![](img/00075.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: Now try to access the Chef workstation VM using the Jenkins build job by executing
    commands from `execute` shell commands.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过执行`execute` Shell 命令，尝试通过 Jenkins 构建作业访问 Chef 工作站虚拟机。
- en: If it fails, then try to access the Chef workstation from the Jenkins VM using
    the Terminal. If you get the Agent admitted failure to sign using key message,
    then execute the `ssh-add` command to fix the issue.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果失败，则尝试从 Jenkins 虚拟机通过终端访问 Chef 工作站。如果看到“代理被拒绝使用密钥签名”的错误信息，则执行`ssh-add`命令来解决问题。
- en: 'Once the connection is successful in the Terminal, execute the `ifconfig` command
    to find the IP address so that we find out on which virtual machine that command
    is executed:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在终端中连接成功，执行`ifconfig`命令来查找 IP 地址，这样我们就能找出在哪台虚拟机上执行该命令：
- en: '![](img/00312.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00312.jpeg)'
- en: At this stage, our SSH connection is successful using a key that we created
    and configured instead of a password.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们的 SSH 连接已成功使用我们创建和配置的密钥，而不是密码。
- en: Now we have access to the Chef workstation from Jenkins' VM so we can execute
    knife commands from Jenkins on the Chef workstation. Our next goal is to try to
    create an instance in AWS using the Jenkins build job and the Chef workstation.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从 Jenkins 的虚拟机访问 Chef 工作站，因此我们可以从 Jenkins 执行 knife 命令到 Chef 工作站。我们的下一个目标是尝试使用
    Jenkins 构建作业和 Chef 工作站在 AWS 中创建实例。
- en: 'In a Jenkins build job, add a Build step, select Execute shell, and add the
    command shown here. We have already discussed `knife ec2` commands:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 构建作业中，添加一个构建步骤，选择执行 Shell，并添加此处显示的命令。我们已经讨论过`knife ec2`命令：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/00042.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: Replace the Access Key ID and Secret Access Key with your own. Click on Save.
    Click on the Build now link to execute the build job.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你自己的 Access Key ID 和 Secret Access Key 替换。点击保存。点击“立即构建”链接以执行构建作业。
- en: 'Go to Console Output to check the progress:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到控制台输出查看进度：
- en: '![](img/00182.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00182.jpeg)'
- en: Inspect the logs; AWS instance creation has started.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查日志；AWS 实例创建已启动。
- en: 'Verify it in the AWS management console:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 管理控制台中验证：
- en: '![](img/00200.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00200.jpeg)'
- en: 'Before execution can go further, check whether the AWS security group has an
    entry for SSH access:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行进一步操作之前，请检查 AWS 安全组是否已为 SSH 访问设置条目：
- en: '![](img/00211.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00211.jpeg)'
- en: Once SSH access is available, it will start the Chef client installations.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 SSH 访问可用，它将开始安装 Chef 客户端。
- en: 'In our case, it will start downloading the Chef client and installing it on
    the AWS instance that we have created using the Chef workstation:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，它将开始下载 Chef 客户端，并将其安装到我们使用 Chef 工作站创建的 AWS 实例上：
- en: Verify the Chef installation process on the console. Once the Chef client is
    installed on the AWS instance, it will start its first Chef client execution.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中验证 Chef 安装过程。一旦 Chef 客户端安装在 AWS 实例上，它将启动第一次 Chef 客户端执行。
- en: Observe the run list and synchronizing cookbooks. It will converge and start
    installing packages.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察运行列表并同步 cookbook。它将汇聚并开始安装软件包。
- en: Verify the package installations.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证软件包的安装情况。
- en: It will also display `conf.xml`, where port-related details can be verified
    based on the configuration.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还将显示 `conf.xml`，可以根据配置验证与端口相关的详细信息。
- en: Once the package installation is finished, it will start service management.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦软件包安装完成，将开始服务管理。
- en: 'Now, the Chef client execution has finished, and it will display related information
    for the AWS instance we created:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Chef 客户端执行已完成，并将显示我们创建的 AWS 实例的相关信息：
- en: '![](img/00187.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00187.jpeg)'
- en: Check the AWS management console for the successful status.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 AWS 管理控制台，确认构建状态是否成功。
- en: 'Verify the hosted Chef for the registered nodes:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证已注册节点的托管 Chef：
- en: '![](img/00015.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 'At this stage, we have an AWS instance ready that has Tomcat and Java installed
    so we can deploy our application easily. Now, we have all the resources ready
    to configure the build pipeline:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们已经准备好了一个 AWS 实例，该实例已安装 Tomcat 和 Java，因此我们可以轻松部署我们的应用程序。现在，我们已经准备好所有资源来配置构建流水线：
- en: Go to PetClinic-Code job and select Build other projects from add Post-build
    Actions.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 PetClinic-Code 任务，并从“添加构建后操作”中选择“构建其他项目”。
- en: 'Enter PetClinic in Projects to build:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“要构建的项目”中输入 PetClinic：
- en: '![](img/00021.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: Here PetClinic-Code becomes an upstream project for PetClinic and PetClinic
    becomes a downstream project for PetClinic-Code. The Build Pipeline plugin needs
    relations established, using upstream and downstream projects for visualization.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此，PetClinic-Code 成为 PetClinic 的上游项目，而 PetClinic 成为 PetClinic-Code 的下游项目。构建流水线插件需要建立关系，使用上游和下游项目进行可视化。
- en: Go to the PetClinic-Code job and select Build other projects from Add Post-build
    Actions.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 PetClinic-Code 任务，并从“添加构建后操作”中选择“构建其他项目”。
- en: 'Enter PetClinic-CloudProvisioning in Projects to build:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“PetClinic-CloudProvisioning”项目中输入，进行构建：
- en: '![](img/00032.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: If this build job has executed successfully, then it means the deployed virtual
    machine is ready with an installed runtime environment.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此构建任务执行成功，则表示已部署的虚拟机已准备好，并安装了运行时环境。
- en: Go to the PetClinic-CloudProvisioning job and select Build other projects from
    Add Post-build Actions.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 PetClinic-CloudProvisioning 任务，并从“添加构建后操作”中选择“构建其他项目”。
- en: 'Enter PetClinic-Deploy in Projects to build:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“要构建的项目”中输入 PetClinic-Deploy：
- en: '![](img/00089.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: 'Once the artifact copy operation has verified, configure the build job so we
    can deploy it as a manual operation. We will create a job with the String Parameter
    of a newly created instance''s domain name or IP address:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦验证了工件复制操作，配置构建任务以便我们可以将其作为手动操作进行部署。我们将创建一个作业，使用新创建实例的域名或 IP 地址作为字符串参数：
- en: '![](img/00057.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: 'Configure the build job to execute deployment of a WAR file in an AWS instance
    by executing the following commands:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置构建任务，在 AWS 实例上执行部署 WAR 文件的操作，执行以下命令：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Execute this command from the Execute shell commands section in the Jenkins
    build job:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 构建任务中的“执行 shell 命令”部分执行以下命令：
- en: '![](img/00173.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: Once this build job ha executed successfully, it means that the application
    deployment is successful, so we can perform a functional test.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦此构建任务执行成功，意味着应用程序部署成功，我们可以进行功能测试。
- en: 'Configure promotion on the PetClinic-FuncTest build using the Promotion plugin:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Promotion 插件配置 PetClinic-FuncTest 构建的提升：
- en: '![](img/00188.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00188.jpeg)'
- en: 'After execution of PetClinic-FuncTest, our pipeline ends:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 PetClinic-FuncTest 后，我们的流水线结束：
- en: '![](img/00094.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: Save PetClinic-FuncTest and verify the upstream projects.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 PetClinic-FuncTest，并验证上游项目。
- en: Install a Build Pipeline plugin from Manage Jenkins | Manage Plugins.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“管理Jenkins | 管理插件”安装Build Pipeline插件。
- en: On the Jenkins Dashboard, click on the + sign.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jenkins仪表板上，点击+号。
- en: 'Provide a View name:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供视图名称：
- en: '![](img/00215.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00215.jpeg)'
- en: 'Select Initial Job in the Upstream / downstream config:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Upstream / downstream配置中选择初始任务：
- en: '![](img/00116.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: Click on Run to execute. Make sure that Tomcat and Sonar, which are configured
    in Jenkins, are running.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Run执行。确保在Jenkins中配置的Tomcat和Sonar正在运行。
- en: 'We have configured PetClinic-Deploy as a downstream project in Build other
    projects (manual step). We have defined the parameters too:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将PetClinic-Deploy配置为Build其他项目中的下游项目（手动步骤）。我们也定义了参数：
- en: '![](img/00306.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00306.jpeg)'
- en: Fig: Build pipeline for end-to-end automation of application life cycle management
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图：用于端到端应用生命周期管理自动化的构建流水线
- en: 'Verify the parameter symbol:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证参数符号：
- en: '![](img/00008.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: 'Fig: Build pipeline with parameterized job'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图：具有参数化任务的构建流水线
- en: Once the PetClinic-CloudProvisioning project has completed successfully, note
    the domain name and provide it as a default parameter in the PetClinic-Deploy
    project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦PetClinic-CloudProvisioning项目成功完成，记下域名并将其作为默认参数提供给PetClinic-Deploy项目。
- en: 'Click on Trigger:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Trigger：
- en: '![](img/00041.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: 'Fig: Build pipeline with manual trigger'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图：具有手动触发的构建流水线
- en: Verify the end-to-end build pipeline execution.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证端到端构建流水线执行。
- en: So, with the use of the Build Pipeline plugin we can orchestrate the automation
    of different activities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用Build Pipeline插件我们可以协调不同活动的自动化。
- en: End-to-end automation using Jenkins and AWS Elastic Beanstalk
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jenkins和AWS Elastic Beanstalk进行端到端自动化
- en: 'To deploy the PetClinic Spring application in Amazon Elastic Beanstalk (PaaS),
    we need the following flow:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Amazon Elastic Beanstalk（PaaS）中部署PetClinic Spring应用程序，我们需要以下流程：
- en: '![](img/00166.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00166.jpeg)'
- en: We have PetClinic-Code, PetClinic, and PetClinic-Deploy-ElasticBeanstalk build
    jobs that we have created in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中创建了PetClinic-Code、PetClinic和PetClinic-Deploy-ElasticBeanstalk构建任务。
- en: Configure PetClinic as a downstream job for PetClinic-Code; and configure PetClinic-Deploy-ElasticBeanstalk
    as a downstream job for the PetClinic build job.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将PetClinic配置为PetClinic-Code的下游任务；并将PetClinic-Deploy-ElasticBeanstalk配置为PetClinic构建任务的下游任务。
- en: End-to end aautomation using Jenkins and Microsoft Azure app services
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jenkins和Microsoft Azure应用服务进行端到端自动化
- en: 'To deploy thePetClinic Spring application in Microsoft Azure web apps (PaaS),
    we need the following flow:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Microsoft Azure Web应用（PaaS）中部署PetClinic Spring应用程序，我们需要以下流程：
- en: '![](img/00164.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00164.jpeg)'
- en: We have PetClinic-Code, PetClinic, and PetClinic-Deploy-Azure build jobs that
    we have created throughout this chapter. Configure PetClinic as a downstream job
    for PetClinic-Code; and configure PetClinic-Deploy-Azure as a downstream job for
    the PetClinic build job.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中创建了PetClinic-Code、PetClinic和PetClinic-Deploy-Azure构建任务。将PetClinic配置为PetClinic-Code的下游任务；并将PetClinic-Deploy-Azure配置为PetClinic构建任务的下游任务。
- en: 'In Microsoft Azure''s case, there is an alternative as well: we can use the
    Visual Studio Team server and TFS online for continuous integration, continuous
    delivery, and continuous deployment.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Azure的情况下，也有替代方案：我们可以使用Visual Studio Team服务器和TFS在线进行持续集成、持续交付和持续部署。
- en: End-to-end automation orchestration of application life cycle management using
    VSTS
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VSTS进行端到端的应用生命周期管理自动化协调
- en: 'In [Chapter 5](part0077.html#29DRA0-651ea628c0544d18a4415dfef8fe6271), *Continuous
    Delivery*, we saw how to deploy our web application using VSTS:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0077.html#29DRA0-651ea628c0544d18a4415dfef8fe6271)，*持续交付*中，我们看到如何使用VSTS部署我们的Web应用：
- en: Go to Releases and check the latest release definition.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Releases并检查最新的发布定义。
- en: Look at the Build & Release column to verify the build number.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Build & Release列以验证构建编号。
- en: 'Double click on Release-22 to get more details on the release definition execution
    in VSTS:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击Release-22以获取VSTS中发布定义执行的更多详细信息：
- en: '![](img/00170.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: 'Now let''s verify the details we have on the release definition execution in
    VSTS:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们验证在VSTS中发布定义执行的详细信息：
- en: In Details, verify the build number that triggered the execution of the release
    definition. It also provides details on the user who requested continuous deployment.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Details中，验证触发发布定义执行的构建编号。它还提供了请求持续部署的用户的详细信息。
- en: 'The Environments section provides details on which the environment release
    definition has done deployment. It also shows the Deployment status: when the
    release definition was triggered, when it was completed, and whether or not there
    was any test execution. In our case, there are no test cases in the release definition:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境部分提供了有关环境发布定义执行了哪些部署的详细信息。它还显示了部署状态：发布定义何时被触发，何时完成，以及是否执行了测试。在我们的例子中，发布定义中没有测试用例：
- en: '![](img/00192.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00192.jpeg)'
- en: To get more details on the release definition execution, click on Logs. It will
    have a series of steps that have been executed during the release definition execution.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取有关发布定义执行的更多详细信息，请单击日志。它将显示在发布定义执行过程中执行的一系列步骤。
- en: If the approval mechanism is set, then it will ask for approval first; once
    approval is given, it will run on an agent. It will initialize the agent first;
    then, once the agent is available for the release definition execution, it will
    download the artifact or WAR file from the source folder.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了审批机制，它将首先要求审批；一旦获得审批，它将在代理上运行。它将首先初始化代理；然后，一旦代理可用于发布定义执行，它将从源文件夹下载构件或 WAR
    文件。
- en: We already know that we can't deploy the WAR file directly, so, based on our
    configuration, it will convert the WAR file into a ZIP file. Once we have a ZIP
    file of our package, then our Deploy Azure App Service task will deploy the application
    package into Azure Web Apps.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经知道无法直接部署 WAR 文件，因此，根据我们的配置，它将把 WAR 文件转换为 ZIP 文件。一旦我们拥有了 ZIP 格式的包文件，我们的部署
    Azure 应用服务任务将把应用程序包部署到 Azure Web 应用中。
- en: Click on each individual step to get a detailed log on the step execution.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击每个单独的步骤，以获取该步骤执行的详细日志。
- en: Let's see what the WAR Converter **/*.war step does.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看 WAR 转换器 **/*.war 步骤的作用。
- en: 'Similarly, the Deploy Azure App Service step execution will give details on
    how the deployment process is executed:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，部署 Azure 应用服务步骤执行将提供有关如何执行部署过程的详细信息：
- en: '![](img/00175.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00175.jpeg)'
- en: 'As there is no Post-deployment approval configured, it is auto-approved and
    hence the build execution was successful:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有配置后部署审批，它会自动批准，因此构建执行成功：
- en: '![](img/00120.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: We already know the Azure web application URL, or we can get it from the Azure
    portal. Visit it and check whether the application has deployed correctly or not.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 Azure Web 应用程序的 URL，或者我们可以从 Azure 门户中获取它。访问该 URL 并检查应用程序是否已正确部署。
- en: So, up to this point, we have configured end-to-end automation for application
    life cycle management using continuous integration and continuous deployment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用持续集成和持续部署配置了端到端的应用程序生命周期管理自动化。
- en: We use deployment slots for different environments. So, we should create multiple
    environments here in the release definition and perform a deployment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用部署槽来处理不同的环境。所以，我们应该在发布定义中创建多个环境并进行部署。
- en: So, the next question should be how to create an environment so we can use it
    for package deployment in a specific deployment slot in Azure Web Apps?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，下一个问题是如何创建一个环境，以便我们可以在 Azure Web 应用中的特定部署槽中使用它进行包部署？
- en: 'In the release definition, click on +Add environment and select Create new
    environment. We can select Clone selected environment if we want to use the same
    tasks of the existing environment in the new environment:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布定义中，单击 +添加环境，然后选择创建新环境。如果我们想在新环境中使用现有环境的相同任务，可以选择克隆所选环境：
- en: '![](img/00078.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: 'In the new environment, let''s keep pre-deployment approval automatic:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在新环境中，我们保持自动的前部署审批：
- en: Select Trigger to Deploy automatically whenever a deployment to the environment
    Production is successful. We can rearrange or rename it once all the environments
    are configured.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择触发器，以便每当部署到生产环境成功时，自动进行部署。我们可以在所有环境配置完成后重新排列或重命名它。
- en: Select the Hosted agent for the release definition execution.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用于发布定义执行的托管代理。
- en: Click on Create.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击创建。
- en: Change the name of an environment by double-clicking on the Name of the environment.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击环境名称来更改环境名称。
- en: 'Based on the environment, the rest of the deployment details can be configured:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据环境，可以配置其余的部署详细信息：
- en: '![](img/00020.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: Change the existing environment name to Dev and click on (...). It will open
    a menu and select the Clone selected environment option.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有环境名称更改为 Dev，然后单击（...）。这将打开一个菜单，选择克隆所选环境选项。
- en: In the case of a new environment, what if we want to keep approvals before the
    deployment process takes place?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是新环境，假设我们想在部署过程开始前保留审批，怎么办？
- en: In the Pre-deployment approval, select Specific users. All the users available
    in the VSTS account are eligible for approval rights. We can provide any name
    from that list.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预部署批准中，选择特定用户。VSTS 帐户中的所有用户都可以获得审批权限。我们可以从该列表中提供任何名称。
- en: Select Trigger to Deploy automatically whenever a deployment to the environment
    Dev is successful. We can rearrange or rename it once all environments are configured.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择触发器，以便每次向环境 Dev 部署成功后自动部署。配置完所有环境后，我们可以重新排列或重命名它。
- en: Select the Hosted agent for the release definition execution.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为发布定义执行选择已托管代理。
- en: 'Click on Create. Change the name of an environment as `QA` by double-clicking
    on the Name of the environment. Based on the environment, the rest of the deployment
    details can be configured:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建。通过双击环境名称，将环境名称更改为 `QA`。根据环境，其他部署细节可以配置：
- en: '![](img/00023.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: Configure the UAT environment in a similar fashion.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式配置 UAT 环境。
- en: To assign approvals manually to any environment, select Environments, click
    on (...), and select Assign approvers....
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要手动分配审批到任何环境，选择“环境”，点击（...），然后选择“分配审批人...”。
- en: In Pre-deployment approval, we can specify users who can approve the execution
    of the release definition for the deployment.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预部署批准中，我们可以指定可以批准执行发布定义的用户。
- en: Click on OK.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定。
- en: 'We need to only configure where to deploy the WAR file in different environments
    that we have created recently:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需配置最近创建的不同环境中部署 WAR 文件的位置：
- en: '![](img/00183.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00183.jpeg)'
- en: 'Let''s start with the Dev environment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Dev 环境开始：
- en: Click on the Dev environment.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Dev 环境。
- en: Go to Deploy Azure App Service task available in the release definition.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到发布定义中的 Deploy Azure App Service 任务。
- en: AzureRM Subscription and App Service Name are already configured, as we did
    that exercise earlier
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AzureRM 订阅和应用服务名称已经配置，就像我们之前做的那样。
- en: To deploy the WAR file into a specific slot, that is dev in this case, let's
    click on the Deploy to Slot checkbox.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 WAR 文件部署到特定插槽，在此案例中为 dev，请勾选部署到插槽复选框。
- en: 'It will ask for the Resource Group: select the resource group from which the
    Azure web application is available.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会要求选择资源组：选择可用的 Azure Web 应用所在的资源组。
- en: In the Slot list, all slots created for the Azure Web Apps will be listed. Select
    the dev slot.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插槽列表中，将列出为 Azure Web 应用创建的所有插槽。选择 dev 插槽。
- en: 'Keep the rest of the details as they are and save the release definition:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其余细节不变并保存发布定义：
- en: '![](img/00026.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: 'Now, let''s configure the QA environment:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置 QA 环境：
- en: Click on the QA environment.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 QA 环境。
- en: Go to the Deploy Azure App Service task available in the release definition.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到发布定义中的 Deploy Azure App Service 任务。
- en: AzureRM Subscription and App Service Name are already configured as we did that
    exercise earlier too.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AzureRM 订阅和应用服务名称也已经配置，就像我们之前做的那样。
- en: To deploy the WAR file into a specific slot, that is qa in this case, let's
    click on the Deploy to Slot checkbox.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 WAR 文件部署到特定插槽，在此案例中为 qa，请勾选部署到插槽复选框。
- en: 'It will ask for the Resource Group: select the resource group from which the
    Azure web application is available.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会要求选择资源组：选择可用的 Azure Web 应用所在的资源组。
- en: In the Slot list, all slots created for the Azure Web Apps will be listed. Select
    the qa slot.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插槽列表中，将列出为 Azure Web 应用创建的所有插槽。选择 qa 插槽。
- en: 'Keep the rest of the details as they are and save the release definition:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其余细节不变并保存发布定义：
- en: '![](img/00288.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00288.jpeg)'
- en: 'To configure the UAT environment, follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 UAT 环境，请按照以下步骤操作：
- en: Click on the UAT environment.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 UAT 环境。
- en: Go to the Deploy Azure App Service task available in the release definition.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到发布定义中的 Deploy Azure App Service 任务。
- en: Azure RM Subscription and App Service Name are already configured, as we did
    that exercise earlier.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure RM 订阅和应用服务名称已经配置，就像我们之前做的那样。
- en: To deploy the WAR file into a specific slot, that is `dev` in this case, let's
    click on the Deploy to Slot checkbox.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 WAR 文件部署到特定插槽，在此案例中为 `dev`，请勾选部署到插槽复选框。
- en: 'It will ask for the Resource Group: select the resource group in which the
    Azure Web App is available.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会要求选择资源组：选择 Azure Web 应用所在的资源组。
- en: In the Slot list, all slots created for the Azure Web Apps will be listed. Select
    the uat/stage slot.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插槽列表中，将列出为 Azure Web 应用创建的所有插槽。选择 uat/stage 插槽。
- en: 'Keep the rest of the details as they are and save the release definition:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他细节不变，保存发布定义：
- en: '![](img/00030.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: 'To deploy an application in the production slot or main Azure Web Apps, we
    need not select any slot. We just need to provide the Azure web application name
    and it will deploy into the main web application in Azure:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在生产插槽或主要 Azure Web 应用中部署应用程序，我们无需选择任何插槽。只需提供 Azure Web 应用名称，系统将自动将其部署到 Azure
    中的主 Web 应用：
- en: '![](img/00303.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00303.jpeg)'
- en: 'Save the release definition:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存发布定义：
- en: 'Click on the Release link:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击发布链接：
- en: '![](img/00301.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00301.jpeg)'
- en: We have set the approval process in the release definition execution so, until
    and unless the approver approves it, the execution of the release definition won't
    take place.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在发布定义执行中已设置了批准流程，因此，除非批准者批准，否则发布定义的执行将不会进行。
- en: Look at the warning available in the summary section of the release definition
    execution. It says a pre-deployment approval is pending for the `dev` environment.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 查看发布定义执行的摘要部分中的警告。它显示`dev`环境的预部署批准正在等待中。
- en: 'As I have configured my own ID as the approver, the links are available to
    approve or reject the build:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我已将自己的 ID 配置为批准者，因此可以使用批准或拒绝构建的链接：
- en: '![](img/00304.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00304.jpeg)'
- en: Let's click on the Approve or Reject link.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们点击批准或拒绝链接。
- en: It will open a small dialog box. We need to provide a comment in it and click
    on Approve or Reject. We can assign multiple approvers in this mechanism as well,
    and we can also set whether we want to have approval from either approver, or
    all approvers.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会打开一个小对话框。我们需要在其中提供评论，然后点击批准或拒绝。我们还可以在此机制中分配多个批准者，并且可以设置是否希望所有批准者或任何一个批准者进行批准。
- en: 'In this case, we will click on Approve:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将点击批准：
- en: '![](img/00308.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00308.jpeg)'
- en: 'In Logs, now we can see that Pre-deployment approval has been given and the
    rest of the processes are about to be executed for application deployment in the
    Dev slot:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在日志中，我们现在可以看到已经给予了预部署批准，接下来的流程即将执行，用于在开发插槽中的应用部署：
- en: '![](img/00039.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: 'The artifact from the build definition will be downloaded so it can be converted
    to a ZIP file, and then we can deploy it into the Dev slot:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自构建定义的工件将被下载，然后可以将其转换为 ZIP 文件，接着我们可以部署到开发插槽：
- en: '![](img/00001.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00001.jpeg)'
- en: Once deployment to the Dev environment is successful, the execution process
    will wait for the approval before it starts deployment into the QA slot.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功部署到开发环境，执行过程将等待批准，然后才会开始部署到 QA 插槽。
- en: 'We need to provide approval to get the step execution going for the application
    deployment:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要提供批准，以便开始执行应用程序部署步骤：
- en: '![](img/00044.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: In the releases, we can see that there are four different environments, as in
    our release definition we created those environments.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发布记录中，我们可以看到有四个不同的环境，因为在我们的发布定义中创建了这些环境。
- en: 'We can see the current status of the release definition execution:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到当前发布定义执行的状态：
- en: '![](img/00048.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: Give approvals for the QA slot deployment and it will deploy a WAR file into
    the QA slot as well.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 QA 插槽的部署给予批准，它也将把 WAR 文件部署到 QA 插槽中。
- en: We need to remember that the process is going to be the same and nothing is
    going to change, except some parameters, during the application deployment in
    the different Azure web application deployment slots.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，除了某些参数之外，应用程序部署到不同 Azure Web 应用程序部署插槽中的过程是相同的，且不会改变。
- en: We need to remember that every slot is a live web application, so if we want
    to see where the application is deployed and what else is going on behind the
    scene, then we can go to the `Kudu` editor for each slot and verify that the operations
    have taken place for the deployment in each slot of the Azure web application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，每个插槽都是一个实时的 Web 应用程序，因此，如果我们想查看应用程序部署的位置以及幕后发生了什么，可以进入每个插槽的`Kudu`编辑器，验证是否已在每个
    Azure Web 应用程序的插槽中执行了部署操作。
- en: 'Similarly, deploy into the UAT or Stage slot and Production slot too:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，也需要部署到 UAT 或 Stage 插槽以及生产插槽：
- en: '![](img/00050.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: Now, as an exercise on your own, commit some changes in the code of the application
    and observe how the build definition is executed; how it triggers the release
    definition after successful execution of the build job; and how an application
    is deployed on different slots. Once that is done, visit a specific URL of the
    deployment slot of an Azure web application and check whether the application
    deployment in different environments has been successful or not.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为你自己的练习，提交一些应用程序代码的更改，并观察构建定义是如何执行的；它是如何在构建任务成功执行后触发发布定义的；以及如何将应用程序部署到不同的插槽。完成后，访问
    Azure Web 应用程序的某个部署插槽的特定 URL，检查应用程序在不同环境中的部署是否成功。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how to automate different tasks that are part
    of application life cycle management.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经看到了如何自动化应用生命周期管理中不同任务的执行。
- en: We have deployed an application using Jenkins on AWS and Microsoft Azure Cloud
    service providers. We used the Chef configuration management tool for installing
    runtime environment.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Jenkins 在 AWS 和 Microsoft Azure 云服务提供商上部署了一个应用程序，并使用 Chef 配置管理工具来安装运行时环境。
- en: We also deployed an application on AWS Elastic Beanstalk using Jenkins, and
    used Visual Studio Team Services for end-to-end automation for deploying the application
    in Azure App Services, which is a PaaS offering from Microsoft.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 Jenkins 在 AWS Elastic Beanstalk 上部署了一个应用程序，并使用 Visual Studio Team Services
    进行端到端自动化，以便在 Azure App Services 上部署该应用程序，Azure App Services 是微软提供的 PaaS 服务。
- en: In the next chapter, we will learn more about configuring security and monitoring
    related details. We will look further at role-based access to resources available
    in Jenkins, VSTS and Microsoft Azure.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习更多关于配置安全性和监控相关的内容。我们将进一步探讨 Jenkins、VSTS 和 Microsoft Azure 中基于角色的资源访问控制。
