- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Managing Containers with Docker Compose
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理容器
- en: In the previous chapter, we learned a lot about how container networking works
    on a single Docker host. We introduced the **Container Network Model** (**CNM**),
    which forms the basis of all networking between Docker containers, and then we
    dove deep into different implementations of the CNM, specifically the bridge network.
    Finally, we introduced Traefik, a reverse proxy to enable sophisticated HTTP application-level
    routing between containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学到了很多关于容器网络如何在单一 Docker 主机上工作的知识。我们介绍了**容器网络模型**（**CNM**），它构成了所有 Docker
    容器之间网络通信的基础，随后我们深入探讨了 CNM 的不同实现，特别是桥接网络。最后，我们介绍了 Traefik，一个反向代理，用于在容器之间实现复杂的 HTTP
    应用级路由。
- en: This chapter introduces the concept of an application consisting of multiple
    services, each running in a container, and how Docker Compose allows us to easily
    build, run, and scale such an application using a declarative approach.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了由多个服务组成的应用程序的概念，每个服务都运行在一个容器中，以及 Docker Compose 如何通过声明式方法让我们轻松构建、运行和扩展这样的应用程序。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Demystifying declarative versus imperative orchestration of containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密声明式与命令式的容器编排方式
- en: Running a multi-service application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个多服务应用程序
- en: Building images with Docker Compose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 构建镜像
- en: Running an application with Docker Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 运行应用程序
- en: Scaling a service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展服务
- en: Building and pushing an application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和推送一个应用程序
- en: Using Docker Compose overrides
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 覆盖
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做到以下几点：
- en: Explain, in a few short sentences, the main differences between an imperative
    and declarative approach for defining and running an application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要解释定义和运行应用程序时，命令式方法与声明式方法的主要区别
- en: Describe, in your own words, the difference between a container and a Docker
    Compose service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用你自己的话描述容器和 Docker Compose 服务之间的区别
- en: Author a Docker Compose YAML file for a simple multi-service application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为一个简单的多服务应用程序编写 Docker Compose YAML 文件
- en: Build, push, deploy, and tear down a simple multi-service application using
    Docker Compose
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 构建、推送、部署和拆除一个简单的多服务应用程序
- en: Use Docker Compose to scale an application service up and down
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 扩展应用程序服务的规模
- en: Define environment-specific Docker Compose files using overrides
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用覆盖定义环境特定的 Docker Compose 文件
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code accompanying this chapter can be found at [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章配套的代码可以在这里找到：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11)。
- en: 'Before we start, let’s make sure we have a folder ready for the code you are
    going to implement in this chapter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们确保你已经准备好一个文件夹，用来存放你将在本章实现的代码：
- en: 'Navigate to the folder in which you cloned the previously listed code repository
    accompanying this book. Normally, this is the `The-Ultimate-Docker-Container-Book`
    folder in your home folder:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你之前克隆的与本书配套的代码仓库所在的文件夹。通常这个文件夹是你主文件夹中的 `The-Ultimate-Docker-Container-Book`
    文件夹：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a subfolder called `ch11` and navigate to it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ch11`的子文件夹并进入该文件夹：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the past, you needed to have a separate docker-compose tool installed on
    your system. This is not the case anymore as the Docker CLI has recently been
    extended such that it contains all the functionality and more than the docker-compose
    tool previously offered.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，你需要在系统上安装一个单独的 docker-compose 工具。但现在不再需要，因为 Docker CLI 最近进行了扩展，已经包含了 docker-compose
    工具之前提供的所有功能及更多功能。
- en: 'If you are curious, you can find detailed installation instructions for the
    old `docker-compose` tool here: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，你可以在这里找到旧版 `docker-compose` 工具的详细安装说明：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)。
- en: Demystifying declarative versus imperative orchestration of containers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密声明式与命令式的容器编排方式
- en: Docker Compose is a tool provided by Docker that is mainly used when you need
    to run and orchestrate containers running on a single Docker host. This includes,
    but is not limited to, development, **continuous integration** (**CI**), automated
    testing, manual QA, or demos. Since very recently, Docker Compose is embedded
    in the normal Docker CLI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 是 Docker 提供的一个工具，主要用于在单个 Docker 主机上运行和协调容器。它的应用场景包括但不限于开发、**持续集成**（**CI**）、自动化测试、手动
    QA 或演示。最近，Docker Compose 已经被嵌入到正常的 Docker CLI 中。
- en: Docker Compose uses files formatted in YAML as input. By default, Docker Compose
    expects these files to be called `docker-compose.yml`, but other names are possible.
    The content of a `docker-compose.yml` file is said to be a declarative way of
    describing and running a containerized application potentially consisting of more
    than a single container.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 使用 YAML 格式的文件作为输入。默认情况下，Docker Compose 期望这些文件被命名为`docker-compose.yml`，但也可以使用其他名称。`docker-compose.yml`文件的内容被称为描述和运行一个可能包含多个容器的容器化应用程序的声明式方式。
- en: '*So, what is the meaning* *of declarative?*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，声明式是什么意思？*'
- en: 'First of all, declarative is the antonym of imperative. Well, that doesn’t
    help much. Now that I have introduced another definition, I need to explain both:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明式是命令式的反义词。嗯，这并没有太大帮助。既然我介绍了另一个定义，那么我需要解释一下这两个词：
- en: '**Imperative**: This is a way in which we can solve problems by specifying
    the exact procedure that has to be followed by the system.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令式**：这是一种通过指定系统必须遵循的精确步骤来解决问题的方法。'
- en: If I tell a system, such as the Docker daemon, imperatively how to run an application,
    then that means that I must describe, step by step, what the system has to do
    and how it must react if some unexpected situation occurs. I must be very explicit
    and precise in my instructions. I need to cover all edge cases and how they need
    to be treated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我以命令式的方式告诉系统（例如 Docker 守护进程）如何运行一个应用程序，那么这意味着我必须一步一步地描述系统需要做什么，并且如果发生一些意外情况，系统应该如何反应。我必须非常明确和精确地给出指示，覆盖所有的边界情况，并且说明如何处理它们。
- en: '**Declarative**: This is a way in which we can solve problems without requiring
    the programmer to specify an exact procedure to be followed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**：这是一种不要求程序员指定精确步骤来解决问题的方法。'
- en: A declarative approach means that I tell the Docker engine what my desired state
    for an application is and it has to figure out on its own how to achieve this
    desired state and how to reconcile it if the system deviates from it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式方法意味着我告诉 Docker 引擎我希望应用程序达到的目标状态，而它必须自行弄清楚如何实现这个目标状态，并且在系统偏离目标状态时如何将其恢复。
- en: Docker clearly recommends the declarative approach when dealing with containerized
    applications. Consequently, the Docker Compose tool uses this approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 明确推荐在处理容器化应用程序时采用声明式方法。因此，Docker Compose 工具也采用了这种方法。
- en: Running a multi-service app
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多服务应用程序
- en: In most cases, applications do not consist of only one monolithic block, but
    rather of several application services that work together. When using Docker containers,
    each application service runs in its own container. When we want to run such a
    multi-service application, we can, of course, start all the participating containers
    with the well-known `docker container run` command, and we have done this in previous
    chapters. But this is inefficient at best. With the Docker Compose tool, we are
    given a way to define the application in a declarative way in a file that uses
    the YAML format.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，应用程序并不只包含一个单一的整体模块，而是由多个协同工作的应用服务组成。在使用 Docker 容器时，每个应用服务运行在自己的容器中。当我们想要运行这样一个多服务的应用程序时，当然可以使用大家熟悉的`docker
    container run`命令来启动所有参与的容器，这也是我们在前几章中做过的。但这最多只能算是低效的做法。有了 Docker Compose 工具，我们可以通过声明式的方式，在一个使用
    YAML 格式的文件中定义应用程序。
- en: 'Let’s create and analyze a simple `docker-compose.yml` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并分析一个简单的`docker-compose.yml`文件：
- en: 'Inside the chapter’s folder (`ch11`), create a subfolder called `step1` and
    navigate to it:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的文件夹（`ch11`）内，创建一个名为`step1`的子文件夹并进入：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside this folder, add a file called `docker-compose.yml` and add the following
    snippet to it:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，添加一个名为`docker-compose.yml`的文件，并将以下代码片段添加到文件中：
- en: '![Figure 11.1 – Simple Docker Compose file](img/Figure_11.01_B19199.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 简单的 Docker Compose 文件](img/Figure_11.01_B19199.jpg)'
- en: Figure 11.1 – Simple Docker Compose file
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 简单的 Docker Compose 文件
- en: 'The lines in the file are explained as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的各行解释如下：
- en: 'Line 1: `version` – On this line, we specify the version of the Docker Compose
    format we want to use. At the time of writing, this is version `3.8`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1行：`version` – 在这一行中，我们指定了要使用的 Docker Compose 格式版本。在撰写本文时，这是版本 `3.8`。
- en: 'Lines 2–21: `services` – In this section, we specify the services that make
    up our application in the `services` block. In our sample, we have two application
    services, and we call them `db` and `pgadmin`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2至第21行：`services` – 在这一部分，我们在 `services` 块中指定了构成我们应用程序的服务。在我们的示例中，我们有两个应用程序服务，分别命名为
    `db` 和 `pgadmin`。
- en: 'Lines 3–11: `db` – The `db` service is using the image name `postgres:alpine`,
    which is the latest version of the Alpine Linux-based PostgreSQL database:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3至第11行：`db` – `db` 服务使用的镜像名称为 `postgres:alpine`，这是基于 Alpine Linux 的 PostgreSQL
    数据库的最新版本：
- en: 'Line 4: `image` – Here, we define which Docker image to use for the service.
    As mentioned previously, we’re using the curated `postgres` image with a tag of
    `alpine`. Since we’re not specifying a version number, it will take the latest
    stable version of the Alpine-based PostgreSQL image.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4行：`image` – 在这里，我们定义了用于该服务的 Docker 镜像。如前所述，我们使用的是带有 `alpine` 标签的精选 `postgres`
    镜像。由于没有指定版本号，它将使用基于 Alpine 的 PostgreSQL 镜像的最新稳定版本。
- en: 'Lines 5–8: `environment` – Here, we are defining the environment variables
    that will be accessible from within the running PostgreSQL service. In this case,
    we define the default username, password, and database name.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5至第8行：`environment` – 在这里，我们定义了在运行中的 PostgreSQL 服务内可以访问的环境变量。在此，我们定义了默认的用户名、密码和数据库名称。
- en: 'Lines 9–11: `volumes` – We are defining two volume mappings.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第9至第11行：`volumes` – 我们定义了两个卷映射。
- en: 'Line 10: We are mapping a volume called `pg-data` to the `/var/lib/postgresql/data`
    container folder. This is where PostgreSQL by default stores the data. This way,
    the data is persisted into the `pg-data` volume and will survive a restart of
    the `db` service.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10行：我们将一个名为 `pg-data` 的卷映射到 `/var/lib/postgresql/data` 容器文件夹。这是 PostgreSQL
    默认存储数据的位置。这样，数据将被持久化到 `pg-data` 卷中，并且在 `db` 服务重启后仍然存在。
- en: 'Line 11: In this case, we are mapping the host folder, `./db`, into a container
    folder called `/docker-entrypoint-initdb.d`. This is the folder where PostgreSQL
    expects any initialization files that are run upon the first start of the database.
    In our case, we’ll use it to define a database initialization script called `init-db.sql`.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11行：在这种情况下，我们将主机文件夹 `./db` 映射到一个名为 `/docker-entrypoint-initdb.d` 的容器文件夹。这是
    PostgreSQL 在首次启动数据库时期望运行的初始化文件所在的文件夹。在我们的例子中，我们将使用它来定义一个名为 `init-db.sql` 的数据库初始化脚本。
- en: 'Lines 13–21: `pgadmin` – The `pgadmin` service uses a Docker image containing
    the popular administration tool for PostgreSQL and similar databases called `Pg4Admin`.
    We are mounting a volume called `pgadmin-data` into the container of the `db`
    service:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第13至第21行：`pgadmin` – `pgadmin` 服务使用的 Docker 镜像包含了一个流行的 PostgreSQL 和类似数据库的管理工具
    `Pg4Admin`。我们将一个名为 `pgadmin-data` 的卷挂载到 `db` 服务的容器中：
- en: 'Line 14: `image` – This service is using the `dpage/pgadmin4` image. Note we’re
    not defining any tags for the image, so we’ll automatically work with the latest
    version.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第14行：`image` – 此服务使用的是 `dpage/pgadmin4` 镜像。请注意，我们没有为该镜像定义任何标签，因此它将自动使用最新版本。
- en: 'Lines 15–16: `ports` – Here, we define which container ports we want to map
    to the host. In this case, we map the default `Pg4Admin` port `80` to the host
    port `5050`. This way, we can access the admin tool on this latter port from a
    browser window, as we will see shortly.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第15至第16行：`ports` – 在这里，我们定义了要映射到主机的容器端口。在这种情况下，我们将默认的 `Pg4Admin` 端口 `80` 映射到主机端口
    `5050`。这样，我们就可以通过浏览器窗口访问这个端口的管理工具，稍后我们将看到这一点。
- en: 'Lines 17–19: `environment` – Here, we are defining the environment variables
    that will be accessible from within the running `Pg4Admin` tool container. It
    is the email and password we will need to log in to the tool.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第17至第19行：`environment` – 在这里，我们定义了在运行中的 `Pg4Admin` 工具容器内可以访问的环境变量。这是我们登录工具时所需的电子邮件和密码。
- en: 'Lines 20–21: `volumes` – We are mapping a Docker volume called `pgadmin-data`
    to the `/var/lib/pgadmin` folder inside the container. This is the place where
    the tool stores its data and makes it possible to survive a restart of the tool
    container.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第20至第21行：`volumes` – 我们将一个名为 `pgadmin-data` 的 Docker 卷映射到容器内的 `/var/lib/pgadmin`
    文件夹。这是该工具存储其数据的位置，使得即使工具容器重启，数据也能得以保留。
- en: 'Lines 23–25: `volumes` – The volumes used by any of the services must be declared
    in this section. In our sample, this is the last section of the file. The first
    time the application is run, volumes called `pg-data` and `pgadmin-data` will
    be created by Docker and then, in subsequent runs, if the volumes are still there,
    they will be reused. This could be important if the application, for some reason,
    crashes and must be restarted. Then, the previous data is still around and ready
    to be used by the restarted database service.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第23–25行：`volumes` – 任何服务使用的卷必须在此部分声明。在我们的示例中，这是文件的最后一部分。当应用程序首次运行时，Docker将创建名为`pg-data`和`pgadmin-data`的卷，然后，在后续运行中，如果卷仍然存在，它们将被重用。如果应用程序由于某种原因崩溃并且必须重新启动，则之前的数据仍然可用，并准备好供重新启动的数据库服务使用。
- en: 'Create a folder called `db` in the `step1` folder and add a file called `init-db.sql`
    to it with the following content:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`step1`文件夹中创建一个名为`db`的文件夹，并添加一个名为`init-db.sql`的文件，其内容如下：
- en: '![Figure 11.2 – Database initialization script](img/Figure_11.02_B19199.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 数据库初始化脚本](img/Figure_11.02_B19199.jpg)'
- en: Figure 11.2 – Database initialization script
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 数据库初始化脚本
- en: 'If you don’t want to type in all of the preceding, you can find the file here:
    [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql).
    As you will see later, this file will be used to initialize our database with
    some initial schema and some data.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想键入所有前面的内容，你可以在这里找到该文件：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql)。稍后你会看到，这个文件将用于初始化我们的数据库，并添加一些初始架构和数据。
- en: 'Next, let’s see how we can run the services with the help of Docker Compose.
    Execute the following command from within your `step1` folder where the `docker-compose.yml`
    file resides:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何通过Docker Compose运行服务。请从包含`docker-compose.yml`文件的`step1`文件夹中执行以下命令：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s analyze the output generated by the preceding command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析上一个命令生成的输出：
- en: The first few lines are telling us that Docker is pulling the images for the
    `db` and `pgadmin` services
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几行告诉我们，Docker正在拉取`db`和`pgadmin`服务的镜像
- en: The next few lines indicate that Docker is automatically creating a new network
    called `step1_default`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的几行指示Docker正在自动创建一个名为`step1_default`的新网络
- en: Two volumes called `step1_pgadmin-data` and `step1-pg-data`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个名为`step1_pgadmin-data`和`step1-pg-data`的卷
- en: Two container instances called `step1-db-1` and `step1-pgadmin-1`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个容器实例分别称为`step1-db-1`和`step1-pgadmin-1`
- en: '![Figure 11.3 – Creating the resources for the Docker Compose application](img/Figure_11.03_B19199.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 为Docker Compose应用程序创建资源](img/Figure_11.03_B19199.jpg)'
- en: Figure 11.3 – Creating the resources for the Docker Compose application
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 为Docker Compose应用程序创建资源
- en: Note the `step1_` prefix added to all the preceding resources. This is the folder
    name within which the `docker-compose.yml` exists and from where the app was started,
    combined with the underscore character.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以上所有资源都添加了`step1_`前缀。这是`docker-compose.yml`所在的文件夹名称，应用程序启动的地方，与下划线字符结合使用。
- en: 'Now, let’s look at the third part of the output in blue. Here, the database
    is started up:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们看一下蓝色输出中的第三部分。在这里，数据库正在启动：
- en: '![Figure 11.4 – Starting up the database](img/Figure_11.04_B19199.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 启动数据库](img/Figure_11.04_B19199.jpg)'
- en: Figure 11.4 – Starting up the database
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 启动数据库
- en: 'The second part of the initialization of the database looks like this:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库初始化的第二部分看起来像这样：
- en: '![Figure 11.5 – Initializing the database using the provided script](img/Figure_11.05_B19199.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 使用提供的脚本初始化数据库](img/Figure_11.05_B19199.jpg)'
- en: Figure 11.5 – Initializing the database using the provided script
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 使用提供的脚本初始化数据库
- en: We have shortened the second part of the output a bit. It shows us how the database
    finalizes its initialization. We can specifically see how our initialization script,
    `init-db.sql`, is applied, which defines a database and seeds it with some data.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经简化了输出的第二部分。它展示了数据库如何完成其初始化过程。我们可以具体看到我们的初始化脚本`init-db.sql`是如何应用的，它定义了一个数据库并添加了一些数据。
- en: The last line in the output tells us that the PostgreSQL database is now up
    and running and ready to accept an incoming connection. The connection is expected
    to happen at port `5432`, as indicated by the fourth and fifth last lines in the
    preceding output.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出的最后一行告诉我们，PostgreSQL 数据库现在已经启动并运行，准备接受传入的连接。连接预计会发生在端口 `5432`，这一点可以从前面输出中的倒数第四和倒数第五行看出。
- en: Hint
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If for some reason your volume mapping does not work – you may have a typo or
    so in the volume mapping part – you can start over by using the `docker compose
    down -v` command, where the `-v` parameter instructs Docker to remove any volumes
    associated with this application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某些原因你的卷映射不起作用——可能在卷映射部分有拼写错误等——你可以通过使用 `docker compose down -v` 命令重新开始，其中
    `-v` 参数指示 Docker 删除与此应用程序相关的所有卷。
- en: 'Lastly, we have the initialization of the `pgamin` tool, shown in yellow:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是 `pgadmin` 工具的初始化，显示为黄色：
- en: '![Figure 11.6 – Starting up the pgadmin tool](img/Figure_11.06_B19199.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 启动 pgadmin 工具](img/Figure_11.06_B19199.jpg)'
- en: Figure 11.6 – Starting up the pgadmin tool
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 启动 pgadmin 工具
- en: 'We are now ready to roll. Let’s open a new browser window and navigate to `http://localhost:5050`.
    When asked, log in using the username (email) and password defined for the `pgadmin`
    tool in the `docker-compose.yml` file, namely `admin@acme.com` for the email and
    `admin` for the password. Add a server called `demo` and fill out the connection
    details as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好了。让我们打开一个新的浏览器窗口并访问 `http://localhost:5050`。当系统提示时，使用在 `docker-compose.yml`
    文件中为 `pgadmin` 工具定义的用户名（邮箱）和密码登录，即邮箱为 `admin@acme.com`，密码为 `admin`。添加一个名为 `demo`
    的服务器，并填写以下连接详情：
- en: '![Figure 11.7 – Pg4Admin connection details](img/Figure_11.07_B19199.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – Pg4Admin 连接详情](img/Figure_11.07_B19199.jpg)'
- en: Figure 11.7 – Pg4Admin connection details
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – Pg4Admin 连接详情
- en: Note that the hostname/address, `db`, corresponds to the name of the database
    service in our docker-compose file. Port `5432` is the default port used by a
    PostgreSQL database and the username and password correspond to what we have defined
    in our docker-compose file for the database as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主机名/地址 `db` 对应于我们在 docker-compose 文件中定义的数据库服务名称。端口 `5432` 是 PostgreSQL 数据库使用的默认端口，用户名和密码也对应我们在
    docker-compose 文件中为数据库定义的内容。
- en: Once connected to the database, make sure that you can locate the `pets` database
    and within it the `images` table. Use the tool to retrieve all the records in
    the `images` table. You should find the 12 records that we defined in the `init-db.sql`
    initialization script.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接到数据库，确保你能找到 `pets` 数据库及其中的 `images` 表。使用该工具检索 `images` 表中的所有记录。你应该能找到我们在
    `init-db.sql` 初始化脚本中定义的 12 条记录。
- en: 'Before you continue, you can stop the application by pressing *Ctrl* + *C*
    in the terminal window where the application still runs. After that, run the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，你可以通过在终端窗口中按下 *Ctrl* + *C* 停止应用程序，确保该应用程序仍在运行。然后，运行以下命令：
- en: '[PRE4]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is to make sure the application container, the network, and the volumes
    are removed. You should see the following output in your terminal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保应用容器、网络和卷被移除。你应该在终端中看到以下输出：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Specifically, notice the use of the `-v` command-line parameter, which tells
    Docker to forcibly remove volumes that were created and used by the application.
    Use this parameter wisely as it will destroy all data that has been persisted
    into those volumes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意使用 `-v` 命令行参数，它告诉 Docker 强制删除由应用程序创建和使用的卷。请谨慎使用此参数，因为它会销毁所有已持久化到这些卷中的数据。
- en: Great, that worked. You have learned how to use the `docker-compose.yml` file
    to declaratively define an application made up of more than one service and start
    it with a simple `docker compose` `up` command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，成功了。你已经学会了如何使用 `docker-compose.yml` 文件声明式地定义由多个服务组成的应用程序，并通过简单的 `docker compose`
    `up` 命令启动它。
- en: Next, you will learn how you can use Docker Compose to build your own custom
    images.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用 Docker Compose 构建自定义镜像。
- en: Building images with Docker Compose
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 构建镜像
- en: 'To demonstrate how to build a Docker image using Docker Compose, we need a
    small application. Proceed as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用 Docker Compose 构建 Docker 镜像，我们需要一个小型应用程序。请按以下步骤操作：
- en: 'In the chapter’s folder (`ch11`), create a subfolder, `step2`, and navigate
    to it:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在章节文件夹（`ch11`）中，创建一个子文件夹 `step2` 并进入该文件夹：
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the previous exercise, copy the `db` folder containing the database initialization
    script to the `step2` folder and also copy the `docker-compose.yml` file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前的练习中，复制包含数据库初始化脚本的`db`文件夹到`step2`文件夹，并且也复制`docker-compose.yml`文件：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a folder called `web` in the `step2` folder. This folder will contain
    a simple Express.js web application.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`step2`文件夹中创建一个名为`web`的文件夹。这个文件夹将包含一个简单的 Express.js 网页应用程序。
- en: 'Add a file called `package.json` to the folder with this content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中添加一个名为`package.json`的文件，并添加以下内容：
- en: '![Figure 11.8 – The package.json file of the sample web application](img/Figure_11.08_B19199.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 示例网页应用程序的 package.json 文件](img/Figure_11.08_B19199.jpg)'
- en: Figure 11.8 – The package.json file of the sample web application
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 示例网页应用程序的 package.json 文件
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you prefer not to type yourself, you can always download the files from
    the sample solution: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢自己打字，总是可以从样例解决方案中下载文件：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2)。
- en: Create a folder called `src` inside the `web` folder.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`web`文件夹中创建一个名为`src`的文件夹。
- en: 'Add a file called `server.js` to the `src` folder with this content:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中添加一个名为`server.js`的文件，并添加以下内容：
- en: '![Figure 11.9 – The server.js file of the sample web application](img/Figure_11.09_B19199.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 示例网页应用程序的 server.js 文件](img/Figure_11.09_B19199.jpg)'
- en: Figure 11.9 – The server.js file of the sample web application
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 示例网页应用程序的 server.js 文件
- en: This file contains the complete logic for our simple web application. Of interest
    is specifically the logic for the `/animal` endpoint on lines 32 to 40\. Also
    note how we connect to the PostgreSQL database using a constant `pool` of type
    `Pool` (lines 15 to 21). The username, password, and database name should match
    the ones we define for the database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含了我们简单网页应用程序的完整逻辑。特别感兴趣的是第32至40行关于`/animal`端点的逻辑。还请注意，我们使用类型为`Pool`的常量`pool`连接到
    PostgreSQL 数据库（第15至21行）。用户名、密码和数据库名称应与我们为数据库定义的相匹配。
- en: 'Add another file called `index.xhtml` to the `src` folder with this content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中添加另一个名为`index.xhtml`的文件，并添加以下内容：
- en: '![Figure 11.10 – The index.xhtml file of the sample web application](img/Figure_11.10_B19199.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 示例网页应用程序的 index.xhtml 文件](img/Figure_11.10_B19199.jpg)'
- en: Figure 11.10 – The index.xhtml file of the sample web application
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 示例网页应用程序的 index.xhtml 文件
- en: This file serves as a template to display the image of a wild animal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件用作展示野生动物图片的模板。
- en: 'Add a folder called `public/css` to the `web` folder:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`web`文件夹中添加一个名为`public/css`的文件夹：
- en: '[PRE8]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a file called `main.css` to this `public/css` folder, which we will use
    to style our sample web application. Add this content to the file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`public/css`文件夹中添加一个名为`main.css`的文件，我们将用它来为我们的示例网页应用程序添加样式。将以下内容添加到文件中：
- en: '![Figure 11.11 – The main.css file of the sample web application](img/Figure_11.11_B19199.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – 示例网页应用程序的 main.css 文件](img/Figure_11.11_B19199.jpg)'
- en: Figure 11.11 – The main.css file of the sample web application
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – 示例网页应用程序的 main.css 文件
- en: 'Now we need some real images to display. The easiest way is to copy our sample
    images from GitHub:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一些真实的图片来展示。最简单的方法是从 GitHub 复制我们的示例图片：
- en: Create a folder called `images` in the `public` folder.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`public`文件夹中创建一个名为`images`的文件夹。
- en: 'Then, download all images into this `images` folder, which you can find here:
    [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images).'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将所有图片下载到这个`images`文件夹中，你可以在这里找到：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images)。
- en: 'We now need to make a small addition to the `docker-compose.yml` file that
    we have copied from the `step1` folder. Locate the `docker-compose.yml` file in
    the `step2` folder, open it, and after line 4, add this snippet:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要对从`step1`文件夹复制过来的`docker-compose.yml`文件进行小小的修改。在`step2`文件夹中找到`docker-compose.yml`文件，打开它，在第4行之后添加这个片段：
- en: '[PRE9]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result should look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![Figure 11.12 – Add host port mapping to the db service](img/Figure_11.12_B19199.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 向 db 服务添加主机端口映射](img/Figure_11.12_B19199.jpg)'
- en: Figure 11.12 – Add host port mapping to the db service
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 向 db 服务添加主机端口映射
- en: This way, we can actually access the database from any application running on
    the host. We will use this possibility in the coming steps.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以从主机上运行的任何应用程序访问数据库。我们将在接下来的步骤中使用这个功能。
- en: 'Now, we are ready to run and test this application:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好运行并测试这个应用程序了：
- en: 'Run the database using the docker-compose file and this command:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 docker-compose 文件和以下命令运行数据库：
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are telling Docker Compose to only start the db service and to run it in
    `detach` mode, indicated by the `--``detach` parameter.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们告诉 Docker Compose 仅启动 db 服务，并以 `detach` 模式运行，`--detach` 参数表示这一点。
- en: 'Navigate to the `web` folder:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `web` 文件夹：
- en: '[PRE11]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install all dependencies with the following:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装所有依赖：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the application using the following:'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see this:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到这个：
- en: '![Figure 11.13 – Running the web application natively](img/Figure_11.13_B19199.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 本地运行 web 应用程序](img/Figure_11.13_B19199.jpg)'
- en: Figure 11.13 – Running the web application natively
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 本地运行 web 应用程序
- en: 'Open a browser tab and navigate to [http://localhost:3000/animal](http://localhost:3000/animal)
    and you should see something like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器标签并访问 [http://localhost:3000/animal](http://localhost:3000/animal)，你应该看到类似的内容：
- en: '![Figure 11.14 – The web application running and displaying a wild animal](img/Figure_11.14_B19199.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – Web 应用程序正在运行并显示一只野生动物](img/Figure_11.14_B19199.jpg)'
- en: Figure 11.14 – The web application running and displaying a wild animal
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – Web 应用程序正在运行并显示一只野生动物
- en: Refresh the browser a few times and notice that each time, a new random animal
    is displayed.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器几次，注意每次都会显示一个新的随机动物。
- en: Before you leave, make sure to stop the web application and stop the other containers
    with `docker` `compose down`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你离开之前，确保停止 web 应用程序并使用 `docker` `compose down` 停止其他容器。
- en: 'Great, now we can move on to the next step, where we will Dockerize the web
    application and use Docker Compose to build the image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，现在我们可以进入下一步，我们将 Docker 化 web 应用程序，并使用 Docker Compose 构建镜像：
- en: 'Add a file called `Dockerfile` to the `web` folder and add this snippet:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `web` 文件夹中添加一个名为 `Dockerfile` 的文件，并添加以下代码段：
- en: '![Figure 11.15 – Dockerfile for the web application](img/Figure_11.15_B19199.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – Web 应用程序的 Dockerfile](img/Figure_11.15_B19199.jpg)'
- en: Figure 11.15 – Dockerfile for the web application
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – Web 应用程序的 Dockerfile
- en: Analyze this Dockerfile and try to understand what it does exactly. Refer to
    what you learned in [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083), *Creating
    and Managing Container Images*, if needed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 分析这个 Dockerfile，尝试理解它的具体作用。如有需要，请参考你在 [*第 4 章*](B19199_04.xhtml#_idTextAnchor083)
    中学到的内容，*创建和管理容器镜像*。
- en: 'Open the `docker-compose.yml` file from the `step2` folder and add the definition
    of the `web` service, right after the `db` and `pgadmin` services and before the
    `volumes` section (that is, after line 24). The snippet to add should look like
    this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `step2` 文件夹中的 `docker-compose.yml` 文件，并在 `db` 和 `pgadmin` 服务之后、`volumes`
    部分之前（即第 24 行之后）添加 `web` 服务的定义。要添加的代码段如下所示：
- en: '![Figure 11.16 – Defining the service called web in the docker-compose.yml
    file](img/Figure_11.16_B19199.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 在 docker-compose.yml 文件中定义名为 web 的服务](img/Figure_11.16_B19199.jpg)'
- en: Figure 11.16 – Defining the service called web in the docker-compose.yml file
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 在 docker-compose.yml 文件中定义名为 web 的服务
- en: Make sure that on line 2, you replace the `gnschenker` username with your own
    Docker Hub username.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在第 2 行，将 `gnschenker` 用户名替换为你自己的 Docker Hub 用户名。
- en: 'Build the image using this command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令构建镜像：
- en: '[PRE14]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding command assumes that you are in the `step2` folder and that there
    is a `docker-compose.yml` file located in that folder.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令假设你在 `step2` 文件夹中，并且该文件夹中有一个 `docker-compose.yml` 文件。
- en: 'When building the image, Docker looks for and uses a Dockerfile in the `web`
    folder, as instructed by the `build: web` instruction on line 3 in the preceding
    snippet.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '在构建镜像时，Docker 会查找并使用 `web` 文件夹中的 Dockerfile，如前面代码段第 3 行中的 `build: web` 指令所示。'
- en: 'To build images using Docker Compose, use the following instructions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 构建镜像，使用以下指令：
- en: Open a terminal window.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口。
- en: 'Make sure that you are in the `ch11/step2` subfolder of the `The-Ultimate-Docker-Container-Book`
    folder:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在 `The-Ultimate-Docker-Container-Book` 文件夹的 `ch11/step2` 子文件夹中：
- en: '[PRE15]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, build the images:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，构建镜像：
- en: '[PRE16]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we enter the preceding command, then the tool will assume that there must
    be a file in the current directory called `docker-compose.yml` and it will use
    that one to run. In our case, this is indeed the case, and the tool will build
    the images.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入上述命令，工具会假定当前目录下必须有一个名为 `docker-compose.yml` 的文件，并会使用该文件来运行。在我们的案例中，确实如此，工具将构建镜像。
- en: 'Observe the output in your terminal window. You should see something like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察终端窗口中的输出。你应该看到类似这样的内容：
- en: '![Figure 11.17 – Building the Docker image for the web service](img/Figure_11.17_B19199.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – 为 web 服务构建 Docker 镜像](img/Figure_11.17_B19199.jpg)'
- en: Figure 11.17 – Building the Docker image for the web service
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – 为 web 服务构建 Docker 镜像
- en: In the preceding screenshot, you can see that docker-compose first downloads
    the base image, `node:19.7-alpine`, for the `web` image we’re building from Docker
    Hub. Subsequently, it uses the Dockerfile found in the `web` folder to build the
    image and names it `gnschenker/ch11-web:2.0`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到 docker-compose 首先从 Docker Hub 下载了基础镜像 `node:19.7-alpine`，这是我们为
    `web` 镜像构建所用的镜像。随后，它使用位于 `web` 文件夹中的 Dockerfile 来构建镜像，并将其命名为 `gnschenker/ch11-web:2.0`。
- en: After building the Docker image for the `web` service, we are ready to use Docker
    Compose to run the whole multi-service application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `web` 服务构建 Docker 镜像之后，我们已准备好使用 Docker Compose 来运行整个多服务应用程序。
- en: Running an application with Docker Compose
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 运行应用程序
- en: 'Once we have built our images, we can start the application using Docker Compose:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了镜像，就可以使用 Docker Compose 启动应用程序：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output, similar to the output we discussed in the previous section for
    the `db` and `pgadmin` services, will look as follows for the `web` service:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出内容与我们在上一节中讨论的 `db` 和 `pgadmin` 服务的输出类似，`web` 服务的输出如下：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This indicates that the containerized `web` service is ready and is listening
    on port `3000`. Coincidentally, we have mapped container port `3000` to the same
    port `3000` on the host in our `docker-compose.yml` file. Thus, we can just open
    a new browser tab and navigate to the URL [http://localhost:3000/animal](http://localhost:3000/animal);
    we should once again see a wild animal displayed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明容器化的 `web` 服务已准备好，并正在监听端口 `3000`。巧合的是，我们在 `docker-compose.yml` 文件中已将容器端口
    `3000` 映射到主机上的相同端口 `3000`。因此，我们只需打开一个新的浏览器标签页并导航到 URL [http://localhost:3000/animal](http://localhost:3000/animal)；我们应该再次看到一只野生动物展示出来。
- en: Refresh the browser a few times to see other animal images. The application
    selects the current image randomly from a set of 12 images whose URLs are stored
    in the database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新浏览器几次以查看其他动物图像。应用程序会从存储在数据库中的 12 张图像的 URL 集合中随机选择当前的图像。
- en: 'As the application is running in interactive mode and, thus, the terminal where
    we ran Docker Compose is blocked, we can cancel the application by pressing *Ctrl*
    + *C*. If we do so, we will see the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序正在以交互模式运行，因此我们运行 Docker Compose 的终端被阻塞，我们可以通过按 *Ctrl* + *C* 来取消应用程序。如果我们这样做，我们将看到以下内容：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will notice that the `db` and `web` services stop immediately. Sometimes,
    though, some services will take about 10 seconds to do so. The reason for this
    is that the `db` and the `web` service listen, and react, to the `SIGTERM` signal
    sent by Docker, while other services might not, and so Docker kills them after
    a predefined timeout interval of 10 seconds.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到，`db` 和 `web` 服务会立即停止。然而，有时一些服务可能需要大约 10 秒钟才能停止。出现这种情况的原因是 `db` 和 `web`
    服务会监听并响应 Docker 发送的 `SIGTERM` 信号，而其他服务则可能不会，因此 Docker 会在 10 秒的预定义超时间隔后强制终止它们。
- en: If we run the application again with `docker compose up`, the startup will be
    much faster as the database didn’t have to initialize from scratch, but it was
    just reusing the data that was already present in the `pg-data` volume from the
    previous run.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次使用 `docker compose up` 启动应用程序，启动速度将会更快，因为数据库不需要从头开始初始化，而是只重新使用之前运行时存储在
    `pg-data` 卷中的数据。
- en: 'We can also run the application in the background. All containers will run
    as daemons. For this, we just need to use the `-d` parameter, as shown in the
    following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将应用程序在后台运行。所有容器将作为守护进程运行。为此，我们只需要使用 `-d` 参数，如下所示的代码：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Docker Compose offers us many more commands than just `up`. We can also use
    the tool to list all services that are part of the application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 提供的命令远不止 `up`。我们还可以使用该工具列出作为应用程序一部分的所有服务：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should see this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下内容：
- en: '![Figure 11.18 – Output of docker compose ps](img/Figure_11.18_B19199.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18 – docker compose ps 的输出](img/Figure_11.18_B19199.jpg)'
- en: Figure 11.18 – Output of docker compose ps
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – docker compose ps 的输出
- en: This command is similar to `docker container ls`, with the only difference being
    that docker-compose only lists containers or services that are part of the application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与 `docker container ls` 类似，唯一的区别是 docker-compose 只列出属于应用程序的容器或服务。
- en: 'To stop and clean up the application, we use the `docker compose` `down` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止并清理应用程序，我们使用 `docker compose` 的 `down` 命令：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should result in an output similar to this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出类似于下面的内容：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we also want to remove the volumes for the database, then we can use the
    following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想移除数据库的卷，可以使用以下命令：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, instead of using the two commands, `docker compose down` and
    `docker volume rm <volume name>`, we can combine them into a single command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，除了使用两个命令 `docker compose down` 和 `docker volume rm <volume name>`，我们可以将它们合并为一个命令：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the argument `-v` (or `--volumes`) removes named volumes declared in the
    `volumes` section of the Docker Compose file and anonymous volumes attached to
    containers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，参数 `-v`（或 `--volumes`）移除 Docker Compose 文件 `volumes` 部分声明的命名卷和附加到容器的匿名卷。
- en: 'Why is there a `step2` prefix in the name of the volume? In the `docker-compose.yml`
    file, we have called the volumes to use `pg-data` and `pgadmin-data`. But, as
    we have already mentioned, Docker Compose prefixes all names with the name of
    the parent folder of the `docker-compose.yml` file plus an underscore. In this
    case, the parent folder is called `step2`. If you don’t like this approach, you
    can define a project name explicitly, for example, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么卷的名称中有一个 `step2` 前缀？在 `docker-compose.yml` 文件中，我们调用了 `pg-data` 和 `pgadmin-data`
    作为要使用的卷。但正如我们之前提到的，Docker Compose 会在所有名称前加上 `docker-compose.yml` 文件所在父文件夹的名称，并加上下划线。在这个例子中，父文件夹名为
    `step2`。如果你不喜欢这种方式，可以显式地定义项目名称，例如，像这样：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This way, all resources (containers, networks, and volumes) will be prefixed
    by the project name, in this case, called `demo`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有资源（容器、网络和卷）将以项目名称为前缀，在本例中为 `demo`。
- en: Scaling a service
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展服务
- en: 'Now, let’s, for a moment, assume that our sample application has been live
    on the web and become very successful. Loads of people want to see our cute animal
    images. But now we’re facing a problem: our application has started to slow down.
    To overcome this problem, we want to run multiple instances of the `web` service.
    With Docker Compose, this is readily done.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时假设我们的示例应用程序已经上线并且非常成功。很多人想查看我们可爱的动物图片。但现在我们面临一个问题：我们的应用程序开始变得缓慢。为了解决这个问题，我们希望运行多个
    `web` 服务实例。使用 Docker Compose，这可以轻松实现。
- en: 'Running more instances is also called scaling out. We can use this tool to
    scale our `web` service up to, say, three instances:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更多实例也称为横向扩展。我们可以使用这个工具将 `web` 服务扩展到，例如，三实例：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we do this, we are in for a surprise. The output will look as in the following
    screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，会有一个惊喜等着我们。输出将会像下图所示：
- en: '![Figure 11.19 – Output of docker-compose --scale](img/Figure_11.19_B19199.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – docker-compose --scale 的输出](img/Figure_11.19_B19199.jpg)'
- en: Figure 11.19 – Output of docker-compose --scale
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – docker-compose --scale 的输出
- en: The second and third instances of the `web` service fail to start. The error
    message tells us why we cannot use the same host port, `3000`, more than once.
    When instances 2 and 3 try to start, Docker realizes that port `3000` is already
    taken by the first instance. What can we do? Well, we can just let Docker decide
    which host port to use for each instance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个 `web` 服务实例无法启动。错误信息告诉我们为什么不能多次使用相同的主机端口 `3000`。当实例 2 和 3 尝试启动时，Docker
    发现端口 `3000` 已被第一个实例占用。我们该怎么办？嗯，我们可以让 Docker 自动选择每个实例使用的主机端口。
- en: 'If, in the `ports` section of the Docker Compose file, we only specify the
    container port and leave out the host port, then Docker automatically selects
    an ephemeral port. Let’s do exactly this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Docker Compose 文件的 `ports` 部分，我们只指定容器端口而省略主机端口，那么 Docker 会自动选择一个临时端口。我们就来做这个操作：
- en: 'First, let’s tear down the application:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们拆除应用程序：
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we modify the `docker-compose.yml` file. The port mapping of the `web`
    service originally looks like this:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们修改 `docker-compose.yml` 文件。`web` 服务的端口映射原本是这样的：
- en: '[PRE29]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We change it to simply the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其更改为如下所示：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This way, Docker will allocate the host port dynamically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Docker 将动态分配主机端口。
- en: 'Now, we can start the application again and scale it up immediately after that:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以重新启动应用程序并立即扩展它：
- en: '[PRE31]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And we should see this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到如下内容：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we now execute `docker compose ps`, we should see what is in the following
    screenshot:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在执行`docker compose ps`，我们应该看到如下截图中的内容：
- en: '![Figure 11.20 – Output of the docker compose ps command](img/Figure_11.20_B19199.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20 – docker compose ps 命令的输出](img/Figure_11.20_B19199.jpg)'
- en: Figure 11.20 – Output of the docker compose ps command
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 – docker compose ps 命令的输出
- en: Note that in your case, the host ports may be different than those shown in
    the preceding screenshot. There, we have a mapping to ports `590076`, `59078`,
    and `59077` for the three instances of `web`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在你的情况下，主机端口可能与前面截图中显示的不同。那里，我们为三个`web`实例映射了端口`590076`、`59078`和`59077`。
- en: 'We can try to see whether those port mappings work, for example, using `curl`.
    Let’s test the third instance, `step2_web-3`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以尝试检查那些端口映射是否有效，例如，使用`curl`。让我们测试第三个实例`step2_web-3`：
- en: '[PRE33]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We should see the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到如下内容：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The answer tells us that, indeed, our application is still working as expected.
    Try it out for the other two instances to be sure.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 答案告诉我们，实际上我们的应用程序仍然按预期工作。为确保正确，请对其他两个实例进行测试。
- en: In the next section, we are going to learn how to build and subsequently push
    the application container images to an image registry.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何构建并随后将应用程序容器镜像推送到镜像仓库。
- en: Building and pushing an application
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和推送应用程序
- en: 'We saw earlier that we can also use the `docker-compose build` command to just
    build the images of an application defined in the underlying `docker-compose`
    file. But to make this work, we’ll have to add the build information to the `docker-compose`
    file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，我们也可以使用`docker-compose build`命令仅构建基础`docker-compose`文件中定义的应用程序镜像。但要使其生效，我们必须将构建信息添加到`docker-compose`文件中：
- en: 'Open a new browser window and navigate to the chapter’s folder (`ch11`):'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器窗口并导航到章节文件夹（`ch11`）：
- en: '[PRE35]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a subfolder called `step3` and navigate to it:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`step3`的子文件夹，并导航到该文件夹：
- en: '[PRE36]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Copy the `docker-compose.yml` file from the `step2` folder to this new folder:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`docker-compose.yml`文件从`step2`文件夹复制到此新文件夹：
- en: '[PRE37]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Open the copied file and please note the `build` key for the web service on
    line 3 in the following screenshot. The value of that key indicates the context
    or folder where Docker is expecting to find the Dockerfile to build the corresponding
    image.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开复制的文件，请注意以下截图中第 3 行 web 服务的`build`键。该键的值指示 Docker 期望在何处找到 Dockerfile 来构建相应的镜像。
- en: '![Figure 11.21 – The build key in the web service of the docker-compose.yml
    file](img/Figure_11.21_B19199.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.21 – docker-compose.yml 文件中 web 服务的 build 键](img/Figure_11.21_B19199.jpg)'
- en: Figure 11.21 – The build key in the web service of the docker-compose.yml file
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21 – docker-compose.yml 文件中 web 服务的 build 键
- en: Please note the `depends_on` section on lines 8 and 9\. This instructs Docker
    Compose to make sure that the `db` service is started before the `web` service.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第 8 和第 9 行中的`depends_on`部分。这指示 Docker Compose 确保`db`服务在`web`服务之前启动。
- en: 'If we wanted to use a Dockerfile that is named differently, say `Dockerfile.dev`,
    for the `web` service, then the `build` block in the `docker-compose` file would
    look like this:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想使用一个名称不同的 Dockerfile，例如`Dockerfile.dev`，用于`web`服务，那么`docker-compose`文件中的`build`块将如下所示：
- en: '[PRE38]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Copy the `web` and the `db` folder and their contents from the `step2` folder
    into the `step3` folder:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`step2`文件夹中的`web`和`db`文件夹及其内容复制到`step3`文件夹中：
- en: '[PRE39]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a file called `Dockerfile.dev` in the `web` folder, which is just a
    copy of the existing Dockerfile:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`web`文件夹中创建一个名为`Dockerfile.dev`的文件，它只是现有 Dockerfile 的副本：
- en: '[PRE40]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To the `step3` folder, add a new file, `docker-compose.dev.yml`, which is a
    copy of the `docker-compose.yml` file:'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`step3`文件夹中添加一个新文件`docker-compose.dev.yml`，它是`docker-compose.yml`文件的副本：
- en: '[PRE41]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Modify the `build` block according to the preceding snippet.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的代码片段修改`build`块。
- en: 'Let’s use that alternative `docker-compose.dev.yml` file now:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用那个替代的`docker-compose.dev.yml`文件：
- en: '[PRE42]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `-f` parameter will tell the Docker Compose application which Docker Compose
    file to use.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`参数将告诉 Docker Compose 应用程序使用哪个 Docker Compose 文件。'
- en: 'To push all images to Docker Hub, we can use `docker` `compose push`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将所有镜像推送到 Docker Hub，我们可以使用`docker compose push`：
- en: 'We need to be logged in to Docker Hub so that this succeeds; otherwise, we
    get an authentication error while pushing. Thus, in my case, I do the following:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要登录到 Docker Hub，才能使其成功；否则，在推送时会出现身份验证错误。因此，在我的情况下，我进行如下操作：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assuming the login succeeds, I can then push the following code:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设登录成功，我就可以推送以下代码：
- en: '[PRE44]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This may take a while, depending on the bandwidth of your internet connection.
    While pushing, your screen may look like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的互联网连接带宽，这可能需要一段时间。在推送过程中，您的屏幕可能会显示如下：
- en: '![Figure 11.22 – Pushing images with docker-compose to Docker Hub](img/Figure_11.22_B19199.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – 使用 docker-compose 将镜像推送到 Docker Hub](img/Figure_11.22_B19199.jpg)'
- en: Figure 11.22 – Pushing images with docker-compose to Docker Hub
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 使用 docker-compose 将镜像推送到 Docker Hub
- en: The preceding command pushes the Docker image for the `web` service to the `gnschenker`
    account on Docker Hub. The other two services, `db` and `pgadmin`, in the Docker
    Compose file are ignored.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将 `web` 服务的 Docker 镜像推送到 Docker Hub 上的 `gnschenker` 账户。Docker Compose 文件中的另外两个服务
    `db` 和 `pgadmin` 将被忽略。
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you are using your own Docker Hub account instead of `gnschenker`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的是自己的 Docker Hub 账户，而不是 `gnschenker`。
- en: The last feature of Docker Compose we want to discuss is overrides.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的 Docker Compose 的最后一个功能是覆盖设置。
- en: Using Docker Compose overrides
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 覆盖设置
- en: Sometimes, we want to run our applications in different environments that need
    specific configuration settings. Docker Compose provides a handy capability to
    address exactly this issue.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在不同的环境中运行应用程序，这些环境需要特定的配置设置。Docker Compose 提供了一个便捷的功能来解决这个问题。
- en: 'Let’s illustrate the with a specific sample:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的示例来说明：
- en: 'Open a new browser window and navigate to the chapter’s folder (`ch11`):'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器窗口，导航到本章的文件夹（`ch11`）：
- en: '[PRE45]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a subfolder called `step4` and navigate to it:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `step4` 的子文件夹并进入该文件夹：
- en: '[PRE46]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Copy the `web` and `db` folder and their contents from the `step2` folder into
    the `step4` folder:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `step2` 文件夹中的 `web` 和 `db` 文件夹及其内容复制到 `step4` 文件夹中：
- en: '[PRE47]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can define a base Docker Compose file and then define environment-specific
    overrides. Let’s assume we have a file called `dockercompose.base.yml` with the
    following content:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以定义一个基础的 Docker Compose 文件，然后定义针对不同环境的覆盖设置。假设我们有一个名为 `dockercompose.base.yml`
    的文件，其内容如下：
- en: '![Figure 11.23 – Docker Compose file used as a base](img/Figure_11.23_B19199.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – 用作基础的 Docker Compose 文件](img/Figure_11.23_B19199.jpg)'
- en: Figure 11.23 – Docker Compose file used as a base
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – 用作基础的 Docker Compose 文件
- en: This only defines the part that should be the same in all environments. All
    specific settings have been taken out.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅定义了在所有环境中应该相同的部分。所有特定的设置都已被提取出来。
- en: 'Now assume we want to run the application in `docker-compose.ci.yml` and add
    this snippet of code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设我们要在 `docker-compose.ci.yml` 中运行该应用程序，并添加以下代码片段：
- en: '![Figure 11.24 – Docker Compose file for CI](img/Figure_11.24_B19199.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – 用于 CI 的 Docker Compose 文件](img/Figure_11.24_B19199.jpg)'
- en: Figure 11.24 – Docker Compose file for CI
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 用于 CI 的 Docker Compose 文件
- en: 'We can run this application with the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行该应用程序：
- en: '[PRE48]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that with the first `-f` parameter, we provide the base Docker Compose
    file, and with the second one, we provide the override. The `--build` parameter
    instructs Docker Compose to rebuild all Docker images before starting them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个 `-f` 参数中，我们提供了基础的 Docker Compose 文件，而在第二个参数中，我们提供了覆盖文件。`--build` 参数指示
    Docker Compose 在启动服务之前重新构建所有 Docker 镜像。
- en: Warning
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'When using environment variables, note the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量时，请注意以下几点：
- en: 1) Declaring them in the Docker file defines a default value
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 1) 在 Docker 文件中声明它们定义了一个默认值
- en: 2) Declaring the same variable in the Docker Compose file overrides the value
    from the Dockerfile
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 2) 在 Docker Compose 文件中声明相同的变量会覆盖 Dockerfile 中的值
- en: With this, we have reached the end of this chapter about Docker Compose. But
    before we finish, we have the following tip for you.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们已经完成了关于 Docker Compose 的本章内容。但在结束之前，我们有一个小提示要给你。
- en: Tip
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Had we followed the standard naming convention and called the base file just
    `docker-compose.yml` and the override file `docker-compose.overrid.yml` instead,
    then we could have started the application with `docker-compose up -d` without
    explicitly naming the Docker Compose files. In any other case, we need to use
    the following full and more verbose syntax:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循标准命名约定，将基础文件命名为 `docker-compose.yml`，并将覆盖文件命名为 `docker-compose.override.yml`，那么我们就可以使用
    `docker-compose up -d` 启动应用程序，而无需显式指定 Docker Compose 文件。在其他情况下，我们需要使用以下完整且更详细的语法：
- en: '`$ docker compose -f <base compose file> -f <override compose` `file> up`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker compose -f <基础 compose 文件> -f <覆盖 compose 文件> up`'
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the docker-compose tool. This tool is mostly
    used to run and scale multi-service applications on a single Docker host. Typically,
    developers and CI servers work with single hosts, and those two are the main users
    of Docker Compose. The tool uses YAML files as input, which contain the description
    of the application in a declarative way.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 docker-compose 工具。该工具主要用于在单个 Docker 主机上运行和扩展多服务应用程序。通常，开发人员和 CI 服务器使用单一主机，而这两者是
    Docker Compose 的主要用户。该工具使用 YAML 文件作为输入，文件以声明的方式描述应用程序。
- en: The tool can also be used to build and push images, among many other helpful
    tasks.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具还可以用于构建和推送镜像，以及许多其他有用的任务。
- en: In the next chapter, we will discuss why logging and monitoring is important
    and show how container logs can be collected and shipped to a central location
    where the aggregated logs can then be parsed to gain useful information.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论为什么日志记录和监控非常重要，并展示如何收集容器日志并将其发送到一个中央位置，在那里可以解析聚合的日志以获取有用的信息。
- en: You will also learn how to instrument an application, so that it exposes metrics,
    and how those metrics can be scraped and shipped again to a central location.
    Finally, you will learn how to convert those collected metrics into graphical
    dashboards that can be used to monitor a containerized application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何为应用程序添加监控功能，使其能够暴露度量数据，以及如何抓取这些度量数据并再次将其发送到中央位置。最后，你将学习如何将收集到的度量数据转换为图形化的仪表盘，用于监控容器化的应用程序。
- en: Further reading
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links provide additional information on the topics discussed
    in this chapter:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接提供了本章讨论主题的更多信息：
- en: '*The official YAML* *website*: [http://www.yaml.org/](http://www.yaml.org/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*官方 YAML* *网站*: [http://www.yaml.org/](http://www.yaml.org/)'
- en: '*The Docker Compose* *documentation*: [http://dockr.ly/1FL2VQ6](http://dockr.ly/1FL2VQ6)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker Compose* *文档*: [http://dockr.ly/1FL2VQ6](http://dockr.ly/1FL2VQ6)'
- en: '*Docker Compose file version 2* *reference*: [https://docs.docker.com/compose/compose-file/compose-file-v2/](https://docs.docker.com/compose/compose-file/compose-file-v2/)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker Compose 文件版本 2* *参考资料*: [https://docs.docker.com/compose/compose-file/compose-file-v2/](https://docs.docker.com/compose/compose-file/compose-file-v2/)'
- en: '*Docker Compose file version 3* *reference*: [https://docs.docker.com/compose/compose-file/compose-file-v3/](https://docs.docker.com/compose/compose-file/compose-file-v3/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker Compose 文件版本 3* *参考资料*: [https://docs.docker.com/compose/compose-file/compose-file-v3/](https://docs.docker.com/compose/compose-file/compose-file-v3/)'
- en: '*Share Docker Compose configurations between files and* *projects*: [https://docs.docker.com/compose/extends/](https://docs.docker.com/compose/extends/)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在文件和* *项目之间共享 Docker Compose 配置*: [https://docs.docker.com/compose/extends/](https://docs.docker.com/compose/extends/)'
- en: Questions
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your learning of Docker Compose, please answer the following questions:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你对 Docker Compose 的学习，请回答以下问题：
- en: What is Docker Compose, and what is it used for?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 是什么，它的用途是什么？
- en: What is a Docker Compose file, and what are some of the key elements it can
    contain?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Docker Compose 文件，它可能包含哪些关键元素？
- en: How can you use Docker Compose to start and stop an application, and what are
    some of the key command-line options?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 Docker Compose 启动和停止一个应用程序，并且一些关键的命令行选项有哪些？
- en: What are some of the benefits of using Docker Compose to manage multi-container
    applications?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 来管理多容器应用程序有什么一些好处？
- en: How do you use docker-compose to run an application in daemon mode?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 docker-compose 以守护进程模式运行一个应用程序？
- en: How do you use docker-compose to display the details of the running service?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 docker-compose 显示正在运行的服务的详细信息？
- en: How do you scale up a particular `web` service to, say, three instances?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将特定的 `web` 服务扩展到三实例？
- en: Answers
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are some sample answers to the questions of [*Chapter 11*](B19199_11.xhtml#_idTextAnchor237):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些[ *第 11 章* ](B19199_11.xhtml#_idTextAnchor237)问题的示例答案：
- en: Docker Compose is a tool for defining and running multi-container Docker applications.
    It allows you to define the services that make up your application in a YAML file,
    and then run and manage those services with a single command.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它允许你在一个 YAML 文件中定义构成应用程序的服务，然后通过一个命令来运行和管理这些服务。
- en: 'A Docker Compose file is a YAML file that defines the services that make up
    a Docker application, along with any associated configuration options. Some of
    the key elements that a Docker Compose file can contain include the following:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 文件是一个 YAML 文件，定义了构成 Docker 应用程序的服务，以及任何相关的配置选项。Docker Compose
    文件可能包含的一些关键元素如下：
- en: '`version`: The version of the Docker Compose file syntax to use. This field
    is mandatory.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 要使用的 Docker Compose 文件语法的版本。此字段是必需的。'
- en: '`services`: A list of the services that make up the application, along with
    any associated configuration options.'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`: 应用程序所包含的服务列表，以及任何相关的配置选项。'
- en: '`ports`: A list of ports that need to be opened for the respective service
    and mapped to a corresponding container port.'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`: 需要为相应服务打开并映射到相应容器端口的端口列表。'
- en: '`networks`: Any custom networks that need to be created for the application.
    Note that a service can be attached to more than one network at the same time.'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networks`: 需要为应用程序创建的任何自定义网络。请注意，服务可以同时连接到多个网络。'
- en: '`volumes`: Any volumes that need to be created for the application.'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`: 需要为应用程序创建的任何卷。'
- en: 'Here is a (shortened) example `docker-compose.yml` file using more than one
    network:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用多个网络的（缩短的）示例 `docker-compose.yml` 文件：
- en: '[PRE49]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To start an application with Docker Compose, you can use the `docker compose
    up` command. This command reads the Docker Compose file, creates any necessary
    containers, and starts the services. To stop an application, you can use the `docker
    compose down` command. Some of the key command-line options that can be used with
    these commands include the following:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Docker Compose 启动应用程序，可以使用 `docker compose up` 命令。该命令读取 Docker Compose 文件，创建任何必要的容器，并启动服务。要停止应用程序，可以使用
    `docker compose down` 命令。这些命令可以与以下关键命令行选项一起使用：
- en: '`-d` or `--detach`: Run containers in the background and print new container
    names'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 或 `--detach`: 在后台运行容器并打印新的容器名称。'
- en: '`-p` or `--project-name`: Specify an alternate project name'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 或 `--project-name`: 指定替代项目名称。'
- en: '`--build`: Build images before starting containers'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build`: 在启动容器之前构建镜像。'
- en: 'Some of the benefits of using Docker Compose to manage multi-container applications
    include the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理多容器应用程序的一些好处包括以下内容：
- en: '**Simplifying the deployment process**: Docker Compose allows you to define
    your application’s services and configurations in a single file, which can simplify
    the deployment process and make it easier to manage complex applications'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化部署过程**：Docker Compose 允许您在单个文件中定义应用程序的服务和配置，这可以简化部署过程，并使复杂应用程序的管理变得更加容易。'
- en: '**Enabling collaboration**: By using a Docker Compose file to define an application,
    developers can easily share their development environments with others and collaborate
    more effectively'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进协作**：通过使用 Docker Compose 文件定义应用程序，开发人员可以轻松与他人共享其开发环境，并更有效地进行协作。'
- en: '**Enabling portability**: Docker Compose allows you to define an application’s
    environment and dependencies in a portable way, which can make it easier to move
    applications between different environments and infrastructure providers'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可移植性**：Docker Compose 允许您以便携方式定义应用程序的环境和依赖关系，这可以使应用程序在不同的环境和基础设施提供商之间更容易移动。'
- en: 'To run the application services in daemon (or `detach`) mode, use the following:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要以守护程序（或 `detach`）模式运行应用程序服务，请使用以下命令：
- en: '[PRE50]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To display the details of the running services in a Docker Compose application,
    use the following:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示 Docker Compose 应用程序中运行服务的详细信息，请使用以下命令：
- en: '[PRE51]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To scale, for example, the `web` service of a Docker Compose application to
    three instances, use the following command:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，要将 Docker Compose 应用程序的 `web` 服务扩展到三个实例，请使用以下命令：
- en: '[PRE52]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
