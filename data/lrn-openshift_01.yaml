- en: Containers and Docker Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和 Docker 概述
- en: This book is much more than just the fundamentals of OpenShift. It's about the
    past, present, and the future of microservices and containers in general. In this
    book, we are going to cover OpenShift and its surroundings; this includes topics
    such as the fundamentals of containers, Docker basics, and studying sections where
    we will work with both Kubernetes and OpenShift in order to feel more comfortable
    with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不仅仅是 OpenShift 基础知识的介绍。它讲述了微服务和容器的过去、现在与未来。我们将在本书中讨论 OpenShift 及其相关内容；这包括容器基础、Docker
    基础等主题，并通过与 Kubernetes 和 OpenShift 的结合使用，帮助你更好地掌握它们。
- en: During our OpenShift journey, we will walk you through all the main and most
    of the advanced components of OpenShift. We are going to cover OpenShift security
    and networking and also application development for OpenShift using the most popular
    and built-in OpenShift DevOps tools, such as CI/CD with Jenkins and **Source-to-Image**
    (**S2I**) in conjunction with GitHub.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 OpenShift 之旅中，我们将带领你了解 OpenShift 的所有主要组件以及大多数高级组件。我们将涵盖 OpenShift 的安全性、网络配置，以及使用
    OpenShift 最受欢迎和内建的 DevOps 工具（如 Jenkins 的 CI/CD 和与 GitHub 配合使用的 **Source-to-Image**
    (**S2I**)）进行应用开发。
- en: We will also learn about the most critical part for every person who would like
    to actually implement OpenShift in their company—the design part. We are going
    to show you how to properly design and implement OpenShift, examining the most
    common mistakes made by those who have just started working with OpenShift.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习每个希望在公司实际实现 OpenShift 的人最关键的一部分——设计部分。我们将展示如何正确设计和实现 OpenShift，分析那些刚开始使用
    OpenShift 的人最常犯的错误。
- en: The chapter is focused on container and Docker technologies. We will describe
    container concepts and Docker basics, from the architecture to low-level technologies.
    In this chapter, we will learn how to use Docker CLI and manage Docker containers
    and Docker images. A significant part of the chapter is focused on building and
    running Docker container images. As a part of the chapter, you are asked to develop
    a number of Dockerfiles and to containerize several applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍容器和 Docker 技术。我们将从架构到低层技术，介绍容器概念和 Docker 基础。在本章中，我们将学习如何使用 Docker CLI
    管理 Docker 容器和 Docker 镜像。本章的一个重要部分是构建和运行 Docker 容器镜像。作为本章的一部分，你需要开发多个 Dockerfile，并将多个应用程序容器化。
- en: 'In this chapter, we will look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括以下几个部分：
- en: Containers overview
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器概述
- en: Docker container architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器架构
- en: Understanding Docker images and layers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 镜像和层
- en: Understanding Docker Hub and Docker registries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker Hub 和 Docker 注册表
- en: Installing and configuring Docker software
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 Docker 软件
- en: Using the Docker command line
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 命令行
- en: Managing images via Docker CLI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Docker CLI 管理镜像
- en: Managing containers via Docker CLI
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Docker CLI 管理容器
- en: Understanding the importance of environment variables inside Docker containers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解环境变量在 Docker 容器中的重要性
- en: Managing persistent storage for Docker containers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Docker 容器管理持久存储
- en: Building a custom Docker image
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义 Docker 镜像
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we are going to use the following technologies and software:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术和软件：
- en: Vagrant
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vagrant
- en: Bash Shell
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash Shell
- en: GitHub
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Docker
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Firefox (recommended) or any other browser
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐使用 Firefox 或任何其他浏览器
- en: The Vagrant installation and all the code we use in this chapter are located
    on GitHub at [https://github.com/PacktPublishing/Learn-OpenShift](https://github.com/PacktPublishing/Learn-OpenShift).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 安装以及我们在本章使用的所有代码都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-OpenShift](https://github.com/PacktPublishing/Learn-OpenShift)。
- en: Instructions on how to install and configure Docker are provided in this chapter
    as we learn.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供如何安装和配置 Docker 的说明，随着学习的进展，我们将深入了解这些内容。
- en: Bash Shell will be used as a part of your virtual environment based on CentOS
    7.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Bash Shell 将作为你基于 CentOS 7 的虚拟环境的一部分使用。
- en: Firefox or any other browser can be used to navigate through Docker Hub.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Firefox 或其他任何浏览器来浏览 Docker Hub。
- en: As a prerequisite, you will need a stable internet connection from your laptop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前提条件，你需要一台能够稳定连接互联网的笔记本电脑。
- en: Containers overview
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器概述
- en: Traditionally, software applications were developed following a monolithic architecture
    approach, meaning all the services or components were locked to each other. You
    could not take out a part and replace it with something else. That approach changed
    over time and became the N-tier approach. The N-tier application approach is one
    step forward in container and microservices architecture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，软件应用的开发遵循单体架构方法，这意味着所有的服务或组件都紧密耦合在一起。你不能随意抽出一部分并替换成其他组件。随着时间的推移，这种方法发生了变化，演变成了
    N 层架构。N 层应用架构是容器和微服务架构向前迈进的一步。
- en: The major drawbacks of the monolith architecture were its lack of reliability,
    scalability, and high availability. It was really hard to scale monolith applications
    due to their nature. The reliability of these applications was also questionable
    because you could rarely easily operate and upgrade these applications without
    any downtime. There was no way you could efficiently scale out monolith applications,
    meaning you could not just add another one, five, or ten applications back to
    back and let them coexist with each other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构的主要缺点是其缺乏可靠性、可扩展性和高可用性。由于单体应用的特性，扩展这些应用变得非常困难。这些应用的可靠性也是一个问题，因为你几乎无法在不发生停机的情况下轻松地操作和升级它们。你无法有效地扩展单体应用，也就是说，你不能简单地再添加一个、五个或十个应用，并让它们相互共存。
- en: We had monolith applications in the past, but then people and companies started
    thinking about application scalability, security, reliability, and **high availability**
    (**HA**). And that is what created N-tier design. The N-tier design is a standard
    application design like 3-tier web applications where we have a web tier, application
    tier, and database backend. It's pretty standard. Now it is all evolving into
    microservices. Why do we need them? The short answer is *for better numbers*.
    It's cheaper, much more scalable, and secure. Containerized applications bring
    you to a whole new level and this is where you can benefit from automation and
    DevOps.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 过去我们有单体应用，但随着人们和公司开始关注应用的可扩展性、安全性、可靠性和**高可用性**（**HA**），这种架构才逐渐发展起来。这就是 N 层设计的由来。N
    层设计是一种标准的应用设计方式，比如三层 Web 应用，其中包括 Web 层、应用层和数据库后端。这是一个非常标准的设计。如今，它正向微服务架构演变。那么，为什么我们需要微服务？简短的回答是
    *为了更好的效果*。它更便宜、扩展性更强、也更安全。容器化的应用将把你带到一个全新的层次，这也是你能从自动化和 DevOps 中受益的地方。
- en: Containers are a new generation of virtual machines. That brings software development
    to a whole new level. Containers are an isolated set of different rules and resources
    inside a single operating system. This means that containers can provide the same
    benefits as virtual machines but use far less CPU, memory, and storage. There
    are several popular container providers including LXC, Rockt, and Docker, which
    we are going to focus on this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是新一代虚拟机，它将软件开发带入了一个全新的层次。容器是在单一操作系统内的一组隔离的不同规则和资源。这意味着容器能够提供与虚拟机相同的好处，但使用的
    CPU、内存和存储却少得多。当前有几个流行的容器提供商，包括 LXC、Rockt 和 Docker，我们在本书中将重点讨论 Docker。
- en: Container features and advantages
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的特点和优势
- en: This architecture brings a lot of advantages to software development.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构为软件开发带来了诸多优势。
- en: 'Some of the major advantages of containers are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的主要优势包括以下几点：
- en: Efficient hardware resource consumption
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的硬件资源消耗
- en: Application and service isolation
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用与服务隔离
- en: Faster deployment
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快速的部署
- en: Microservices architecture
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: The stateless nature of containers
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的无状态特性
- en: Efficient hardware resource consumption
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的硬件资源消耗
- en: Whether you run containers natively on a bare-metal server or use virtualization
    techniques, using containers allows you to utilize resources (CPU, memory, and
    storage) in a better and much more efficient manner. In the case of a bare-metal
    server, containers allow you to run tens or even hundreds of the same or different
    containers, providing better resource utilization in comparison to usually one
    application running on a dedicated server. We have seen in the past that some
    server utilization at peak times is only 3%, which is a waste of resources. And
    if you are going to run several of the same or different applications on the same
    servers, they are going to conflict with each other. Even if they work, you are
    going to face a lot of problems during day-to-day operation and troubleshooting.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在裸金属服务器上原生运行容器，还是使用虚拟化技术，容器都能让你更好、更高效地利用资源（CPU、内存和存储）。在裸金属服务器的情况下，容器允许你运行几十个甚至上百个相同或不同的容器，与通常只在专用服务器上运行一个应用程序相比，提供了更好的资源利用率。我们曾经看到过某些服务器在高峰期的利用率只有3%，这是一种资源浪费。如果你要在同一台服务器上运行几个相同或不同的应用程序，它们会相互冲突。即使它们能正常工作，你在日常操作和故障排除中也会面临许多问题。
- en: If you are going to isolate these applications by introducing popular virtualization
    techniques such as KVM, VMware, XEN, or Hyper-V, you will run into a different
    issue. There is going to be a lot of overhead because, in order to virtualize
    your app using any hypervisor, you will need to install an operating system on
    top of your hypervisor OS. This operating system needs CPU and memory to function.
    For example, each VM has its own kernel and kernel space associated with it. A
    perfectly tuned container platform can give you up to four times more containers
    in comparison to standard VMs. It may be insignificant when you have five or ten
    VMs, but when we talk hundreds or thousands, it makes a huge difference.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算通过引入流行的虚拟化技术（如KVM、VMware、XEN或Hyper-V）来隔离这些应用程序，你会遇到另一个问题。由于为了虚拟化你的应用程序，你需要在虚拟机管理程序操作系统之上安装一个操作系统，而这个操作系统需要CPU和内存来运行。例如，每个虚拟机都有自己的内核和内核空间。与标准虚拟机相比，经过精心调优的容器平台可以让你运行最多四倍数量的容器。当你只有五个或十个虚拟机时，差异可能不显著，但当我们谈论上百或上千个虚拟机时，差距就非常大。
- en: Application and service isolation
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序和服务隔离
- en: Imagine a scenario where we have ten different applications hosted on the same
    server. Each application has a number of dependencies (such as packages, libraries,
    and so on). If you need to update an application, usually it involves updating
    the process and its dependencies. If you update all related dependencies, most
    likely it will affect the other application and services. It may cause these applications
    not to work properly. Sure, to a degree these issues are addressed by environment
    managers such as `virtualenv` for Python and `rbenv`/`rvm` for Ruby—and dependencies
    on shared libraries can be isolated via `LD_LIBRARY_PATH`—but what if you need
    different versions of the same package? Containers and virtualization solve that
    issue. Both VMs and containers provide environment isolation for your applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有十个不同的应用程序托管在同一台服务器上。每个应用程序都有一些依赖项（如包、库等）。如果需要更新某个应用程序，通常涉及到更新该应用程序及其依赖项。如果你更新所有相关的依赖项，很可能会影响其他应用程序和服务，导致这些应用程序无法正常工作。当然，某种程度上，这些问题可以通过环境管理工具来解决，比如Python的`virtualenv`和Ruby的`rbenv`/`rvm`，而共享库的依赖项可以通过`LD_LIBRARY_PATH`进行隔离。但如果你需要同一个包的不同版本呢？容器和虚拟化技术解决了这个问题。虚拟机和容器都为你的应用程序提供了环境隔离。
- en: But, in comparison to bare-metal application deployment, container technology
    (for example, Docker) provides an efficient way to isolate applications, and other
    computer resources libraries from each other. It not only provides these applications
    with the ability to co-exist on the same OS, but also provides efficient security,
    which is a big must for every customer-facing and content-sensitive application.
    It allows you to update and patch your containerized applications independently
    of each other.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但与裸金属应用程序部署相比，容器技术（例如Docker）提供了一种高效的方式，将应用程序和其他计算资源库相互隔离。它不仅使这些应用程序能够在同一操作系统上共存，还提供了高效的安全性，这是每个面向客户和内容敏感的应用程序所必须的。它使你能够独立地更新和修补容器化的应用程序。
- en: Faster deployment
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的部署
- en: Using container images, discussed later in this book, allows us speed up container
    deployment. We are talking about seconds to completely restart a container versus
    minutes or tens of minutes with bare-metal servers and VMs. The main reason for
    this is that a container does not need to restart the whole OS, it just needs
    to restart the application itself.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书后续将讨论的容器镜像，可以加速容器部署。我们说的是几秒钟就能完全重启一个容器，而不像裸金属服务器和虚拟机那样需要几分钟甚至几十分钟。这主要是因为容器不需要重启整个操作系统，它只需要重启应用程序本身。
- en: Microservices architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Containers bring application deployment to a whole new level by introducing
    microservices architecture. What it essentially means is that, if you have a monolith
    or N-tier application, it usually has many different services communicating with
    each other. Containerizing your services allows you to break down your application
    into multiple pieces and work with each of them independently. Let's say you have
    a standard application that consists of a web server, application, and database.
    You can probably put it on one or three different servers, three different VMs,
    or three simple containers, running each part of this application. All these options
    require a different amount of effort, time, and resources. Later in this book,
    you will see how simple it is to do using containers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过引入微服务架构，将应用程序部署提升到全新水平。其实质是，如果你有一个单体应用或多层应用，它通常有许多不同的服务相互通信。将服务容器化可以让你将应用程序拆分成多个部分，并独立操作每个部分。假设你有一个标准的应用程序，包含一个
    Web 服务器、应用程序和数据库。你可能会将其部署到一台或三台不同的服务器、三台虚拟机或三个简单的容器中，每个容器运行应用程序的一个部分。这些选项所需的工作量、时间和资源各不相同。本书后续会展示使用容器进行这一操作是多么简单。
- en: The stateless nature of containers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的无状态特性
- en: Containers are stateless, which means that you can bring containers up and down,
    create or destroy them at any time, and this will not affect your application
    performance. That is one of the greatest features of containers. We are going
    to delve into this later in this book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是无状态的，这意味着你可以随时启动和关闭容器，创建或销毁容器，这不会影响你的应用性能。这是容器的最伟大特性之一。本书后续将深入探讨这一点。
- en: Docker container architecture
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 容器架构
- en: Docker is one of the most popular application containerization technologies
    these days. So why do we want to use Docker if there are other container options
    available? Because collaboration and contribution are key in the era of open source,
    and Docker has made many different things that other technologies have not been
    able to in this area.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是当今最流行的应用容器化技术之一。那么，既然有其他容器选项，为什么我们要使用 Docker 呢？因为在开源时代，协作和贡献至关重要，而 Docker
    在这一领域做到了其他技术无法做到的许多事情。
- en: For example, Docker partnered with other container developers such as Red Hat,
    Google, and Canonical to jointly work on its components. Docker also contributed
    it's software container format and runtime to the Linux Foundation's open container
    project. Docker has made containers very easy to learn about and use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Docker 与其他容器开发者（如 Red Hat、Google 和 Canonical）合作，共同开发其组件。Docker 还将其软件容器格式和运行时贡献给了
    Linux 基金会的开放容器项目。Docker 使得容器的学习和使用变得非常简单。
- en: Docker architecture
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 架构
- en: 'As we mentioned already, Docker is the most popular container platform. It
    allows for creating, sharing, and running applications inside Docker containers.
    Docker separates running applications from the infrastructure. It allows you to
    speed up the application delivery process drastically. Docker also brings application
    development to an absolutely new level. In the diagram that follows, you can see
    a high-level overview of the Docker architecture:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，Docker 是最流行的容器平台。它允许在 Docker 容器中创建、共享和运行应用程序。Docker 将运行中的应用程序与基础设施分开。它可以大大加快应用程序交付的速度。Docker
    还将应用程序开发提升到一个全新的水平。在下图中，你可以看到 Docker 架构的高级概览：
- en: '![](img/00005.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: Docker architecture
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 架构
- en: 'Docker uses a client-server type of architecture:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用的是客户端-服务器类型的架构：
- en: '**Docker server**: This is a service running as a daemon in an operating system.
    This service is responsible for downloading, building, and running containers.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 服务器**：这是一个作为守护进程在操作系统中运行的服务。该服务负责下载、构建和运行容器。'
- en: '**Docker client**: The CLI tool is responsible for communicating with Docker
    servers using the REST API.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 客户端**：该命令行工具负责使用 REST API 与 Docker 服务器进行通信。'
- en: Docker's main components
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的主要组件
- en: 'Docker uses three main components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用三个主要组件：
- en: '**Docker containers**: Isolated user-space environments running the same or
    different applications and sharing the same host OS. Containers are created from
    Docker images.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器**：隔离的用户空间环境，运行相同或不同的应用程序，并共享相同的主机操作系统。容器是由Docker镜像创建的。'
- en: '**Docker images**: Docker templates that include application libraries and
    applications. Images are used to create containers and you can bring up containers
    immediately. You can create and update your own custom images as well as download
    build images from Docker''s public registry.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：包含应用程序库和应用程序的Docker模板。镜像用于创建容器，您可以立即启动容器。您可以创建和更新自己的自定义镜像，也可以从Docker的公共注册表中下载构建镜像。'
- en: '**Docker registries**: This is a images store. Docker registries can be public
    or private, meaning that you can work with images available over the internet
    or create your own registry for internal purposes. One popular public Docker registry
    is Docker Hub, discussed later in this chapter.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker注册表**：这是一个镜像存储库。Docker注册表可以是公共的或私有的，这意味着您可以使用互联网上可用的镜像，也可以为内部用途创建自己的注册表。一个流行的公共Docker注册表是Docker
    Hub，本章稍后会讨论。'
- en: Linux containers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux容器
- en: 'As mentioned in the previous section, Docker containers are secured and isolated
    from each other. In Linux, Docker containers use several standard features of
    the Linux kernel. This includes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，Docker容器是安全的，并且彼此隔离。在Linux中，Docker容器使用Linux内核的几个标准特性。这包括：
- en: '**Linux namespaces**: It is a feature of Linux kernel to isolate resources
    from each other. This allows one set of Linux processes to see one group of resources
    while allowing another set of Linux processes to see a different group of resources.
    There are several kinds of namespaces in Linux: **Mount** (**mnt**), **Process
    ID** (**PID**), **Network** (**net**), **User ID** (**user**), **Control group**
    (**cgroup**), and **Interprocess Communication** (**IPC**). The kernel can place
    specific system resources that are normally visible to all processes into a namespace.
    Inside a namespace, a process can see resources associated with other processes
    in the same namespace. You can associate a process or a group of processes with
    their own namespace or, if using network namespaces, you can even move a network
    interface to a network namespace. For example, two processes in two different
    mounted namespaces may have different views of what the mounted root file system
    is. Each container can be associated with a specific set of namespaces, and these
    namespaces are used inside these containers only.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux命名空间**：这是Linux内核中的一个功能，用于将资源彼此隔离。这允许一组Linux进程看到一组资源，而另一组Linux进程则看到另一组资源。Linux中有几种类型的命名空间：**挂载**（**mnt**）、**进程ID**（**PID**）、**网络**（**net**）、**用户ID**（**user**）、**控制组**（**cgroup**）和**进程间通信**（**IPC**）。内核可以将通常对所有进程可见的特定系统资源放入命名空间中。在命名空间内，进程只能看到与同一命名空间中的其他进程相关联的资源。您可以将进程或一组进程与其自己的命名空间关联，或者如果使用网络命名空间，甚至可以将网络接口移动到网络命名空间。例如，位于两个不同挂载命名空间中的两个进程可能对挂载的根文件系统有不同的视图。每个容器都可以与一组特定的命名空间关联，这些命名空间仅在这些容器内部使用。'
- en: '**Control groups** (**cgroups**): These provide an effective mechanism for
    resource limitation. With cgroups, you can control and manage system resources
    per Linux process, increasing overall resource utilization efficiency. Cgroups
    allow Docker to control resource utilization per container.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制组**（**cgroups**）：这些提供了一种有效的资源限制机制。通过cgroups，您可以按Linux进程控制和管理系统资源，提高整体资源利用效率。Cgroups允许Docker按容器控制资源的使用。'
- en: '**SELinux**: **Security Enhanced Linux** (**SELinux**) is **mandatory access
    control** (**MAC**) used for granular system access, initially developed by the **National
    Security Agency** (**NSA**). It is an additional security layer for Debian and
    RHEL-based distributions like Red Hat Enterprise Linux, CentOS, and Fedora. Docker
    uses SELinux for two main reasons: host protection and to isolate containers from
    each other. Container processes run with limited access to the system resources
    using special SELinux rules.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SELinux**：**Security Enhanced Linux**（**SELinux**）是**强制访问控制**（**MAC**），用于细粒度的系统访问，最初由**国家安全局**（**NSA**）开发。它是Debian和基于RHEL的发行版（如Red
    Hat Enterprise Linux、CentOS和Fedora）的一层附加安全性。Docker使用SELinux的两个主要原因：主机保护和将容器彼此隔离。容器进程使用特殊的SELinux规则，以限制对系统资源的访问。'
- en: The beauty of Docker is that it leverages the aforementioned low-level kernel
    technologies, but hides all complexity by providing an easy way to manage your
    containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的优势在于它利用了上述低级内核技术，但通过提供一种简便的方式来管理容器，隐藏了所有复杂性。
- en: Understanding Docker images and layers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Docker 镜像和层
- en: A Docker image is a read-only template used to build containers. An image consists
    of a number of layers that are combined into a single virtual filesystem accessible
    for Docker applications. This is achieved by using a special technique which combines
    multiple layers into a single view. Docker images are immutable, but you can add
    an extra layer and save them as a new image. Basically, you can add or change
    the Docker image content without changing these images directly. Docker images
    are the main way to ship, store, and deliver containerized applications. Containers
    are created using Docker images; if you do not have a Docker image, you need to
    download or build one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是一个只读模板，用于构建容器。一个镜像由多个层组成，这些层被组合成一个单一的虚拟文件系统，Docker 应用可以访问。通过使用一种特殊的技术，将多个层合并成一个单一视图，从而实现这一点。Docker
    镜像是不可变的，但你可以添加一个额外的层并将其保存为一个新的镜像。基本上，你可以添加或更改 Docker 镜像的内容，而无需直接更改这些镜像。Docker
    镜像是运送、存储和交付容器化应用的主要方式。容器是通过 Docker 镜像创建的；如果没有 Docker 镜像，你需要下载或构建一个。
- en: Container filesystem
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器文件系统
- en: 'The container filesystem, used for every Docker image, is represented as a
    list of read-only layers stacked on top of each other. These layers eventually
    form a base root filesystem for a container. In order to make it happen, different
    storage drivers are being used. All the changes to the filesystem of a running
    container are done to the top level image layer of a container. This layer is
    called a Container layer. What it basically means is that several containers may
    share access to the same underlying level of a Docker image, but write the changes
    locally and uniquely to each other. This process is shown in the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 容器文件系统用于每个 Docker 镜像，它表现为一个堆叠在一起的只读层列表。这些层最终形成容器的基础根文件系统。为了实现这一点，使用了不同的存储驱动程序。对正在运行的容器文件系统的所有更改都会应用到容器的最上层镜像层，这一层称为容器层。基本上，这意味着多个容器可以共享对
    Docker 镜像的相同底层访问权限，但会在本地独立且唯一地写入更改。这个过程在以下图示中展示：
- en: '![](img/00006.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: Docker layers
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 层
- en: Docker storage drivers
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 存储驱动程序
- en: 'A Docker storage driver is the main component to enable and manage container
    images. Two main technologies are used for that—copy-on-write and stackable image
    layers. The storage driver is designed to handle the details of these layers so
    that they interact with each other. There are several drivers available. They
    do pretty much the same job, but each and every one of them does it differently.
    The most common storage drivers are AUFS, Overlay/Overlay2, Devicemapper, Btrfs,
    and ZFS. All storage drivers can be categorized into three different types:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 存储驱动程序是启用和管理容器镜像的主要组件。为了实现这一点，使用了两种主要技术——写时复制和可堆叠的镜像层。存储驱动程序的设计目的是处理这些层的细节，使它们能够相互作用。有多种驱动程序可供选择。它们基本上执行相同的工作，但每一种方法都不同。最常见的存储驱动程序是
    AUFS、Overlay/Overlay2、Devicemapper、Btrfs 和 ZFS。所有存储驱动程序可以分为三种不同类型：
- en: '| **Storage driver category** | **Storage drivers** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **存储驱动类别** | **存储驱动** |'
- en: '| Union filesystems | AUFS, Overlay, Overlay2 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 联合文件系统 | AUFS, Overlay, Overlay2 |'
- en: '| Snapshotting filesystems | Btrfs, ZFS |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 快照文件系统 | Btrfs, ZFS |'
- en: '| Copy-on-write block devices | Devicemapper |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 写时复制块设备 | Devicemapper |'
- en: Container image layers
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像层
- en: As previously mentioned, a Docker image contains a number of layers that are
    combined into a single filesystem using a storage driver. The layers (also called
    intermediate images) are generated when commands are executed during the Docker
    image build process. Usually, Docker images are created using a Dockerfile, the
    syntax of which will be described later. Each layer represents an instruction
    in the image's Dockerfile.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker 镜像包含多个层，这些层通过存储驱动程序组合成一个单一的文件系统。层（也称为中间镜像）是在执行 Docker 镜像构建过程中的命令时生成的。通常，Docker
    镜像是通过 Dockerfile 创建的，其语法将在后面描述。每一层代表镜像 Dockerfile 中的一个指令。
- en: 'Each layer, except the very last one, is read-only:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一层外，每一层都是只读的：
- en: '![](img/00007.gif)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.gif)'
- en: Docker image layers
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像层
- en: A Docker image usually consists of several layers, stacked one on top of the
    other. The top layer has read-write permissions, and all the remaining layers
    have read-only permissions. This concept is very similar to the copy-on-write
    technology. So, when you run a container from the image, all the changes are done
    to this top writable layer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Docker 镜像通常由多个层组成，层与层之间是堆叠的。最上层具有读写权限，所有其他层都是只读权限。这个概念与写时复制技术非常相似。因此，当你从镜像启动容器时，所有更改都会应用到最上层的可写层。
- en: Docker registries
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 注册表
- en: As mentioned earlier, a Docker image is a way to deliver applications. You can
    create a Docker image and share it with other users using a public/private registry
    service. A registry is a stateless, highly scalable server-side application which
    you can use to store and download Docker images. Docker registry is an open source
    project, under the permissive Apache license. Once the image is available on a
    Docker registry service, another user can download it by pulling the image and
    can use this image to create new Docker images or run containers from this image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker 镜像是一种交付应用程序的方式。你可以创建一个 Docker 镜像并通过公共/私有注册表服务与其他用户共享。注册表是一个无状态的、高度可扩展的服务器端应用程序，你可以用它来存储和下载
    Docker 镜像。Docker 注册表是一个开源项目，使用宽松的 Apache 许可证。一旦镜像在 Docker 注册表服务上可用，其他用户可以通过拉取镜像来下载它，并使用该镜像创建新的
    Docker 镜像或从该镜像运行容器。
- en: 'Docker supports several types of docker registry:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 支持几种类型的 Docker 注册表：
- en: Public registry
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共注册表
- en: Private registry
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有注册表
- en: Public registry
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共注册表
- en: You can start a container from an image stored in a public registry. By default,
    the Docker daemon looks for and downloads Docker images from Docker Hub, which
    is a public registry provided by Docker. However, many vendors add their own public
    registries to the Docker configuration at installation time. For example, Red
    Hat has its own *proven and blessed* public Docker registry which you can use
    to pull Docker images and to build containers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从存储在公共注册表中的镜像启动容器。默认情况下，Docker 守护进程会从 Docker Hub（一个由 Docker 提供的公共注册表）查找并下载
    Docker 镜像。然而，许多厂商在安装时将自己的公共注册表添加到 Docker 配置中。例如，Red Hat 有自己的 *经过验证且被推荐* 的公共 Docker
    注册表，你可以用它来拉取 Docker 镜像并构建容器。
- en: Private registry
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有注册表
- en: Some organization or specific teams don't want to share their custom container
    images with everyone for a reason. They still need a service to share Docker images,
    but just for internal usage. In that case, a private registry service can be useful.
    A private registry can be installed and configured as a service on a dedicated
    server or a virtual machine inside your network.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织或特定团队出于某种原因，不希望与所有人共享他们定制的容器镜像。它们仍然需要一个服务来共享 Docker 镜像，但仅供内部使用。在这种情况下，私有注册表服务可能会很有用。可以在专用服务器或网络内的虚拟机上安装并配置一个私有注册表服务。
- en: You can easily install a private Docker registry by running a Docker container
    from a public registry image. The private Docker registry installation process
    is no different from running a regular Docker container with additional options.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从公共注册表镜像启动一个 Docker 容器，轻松安装私有 Docker 注册表。私有 Docker 注册表的安装过程与使用附加选项运行常规
    Docker 容器没有区别。
- en: Accessing registries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问注册表
- en: A Docker registry is accessed via the Docker daemon service using a Docker client.
    The Docker command line uses a RESTful API to request process execution from the
    daemon. Most of these commands are translated into HTTP requests and may be transmitted
    using `curl`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Docker 客户端使用 Docker 守护进程服务访问 Docker 注册表。Docker 命令行使用 RESTful API 来请求守护进程执行处理。这些命令大多被转换为
    HTTP 请求，并可以通过 `curl` 传输。
- en: The process of using Docker registries is shown in the following section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 注册表的过程将在下一个部分中展示。
- en: A developer can create a Docker image and put it into a private or public registry.
    Once the image is uploaded, it can be immediately used to run containers or build
    other images.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以创建一个 Docker 镜像，并将其上传到私有或公共注册表。一旦镜像上传成功，就可以立即用来运行容器或构建其他镜像。
- en: Docker Hub overview
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Hub 概述
- en: Docker Hub is a cloud-based registry service that allows you to build your images
    and test them, push these images, and link to Docker cloud so you can deploy images
    on your hosts. Docker Hub provides a centralized resource for container image
    discovery, distribution and change management, user and team collaboration, and
    workflow automation throughout the development pipeline.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是一个基于云的注册服务，它允许您构建镜像并进行测试，推送这些镜像，并连接到 Docker 云，以便将镜像部署到您的主机上。Docker
    Hub 提供了一个集中式资源，用于容器镜像的发现、分发和变更管理、用户和团队协作以及整个开发管道中的工作流自动化。
- en: Docker Hub is the public registry managed by the Docker project, and it hosts
    a large set of container images, including those provided by major open source
    projects, such as MySQL, Nginx, Apache, and so on, as well as customized container
    images developed by the community.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是由 Docker 项目管理的公共注册中心，托管着大量容器镜像，包括由主要开源项目（如 MySQL、Nginx、Apache 等）提供的镜像，以及由社区开发的定制容器镜像。
- en: 'Docker Hub provides some of the following features:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 提供以下一些功能：
- en: '**Image repositories**: You can find and download images managed by other Docker
    Hub users. You can also push or pull images from private image libraries you have
    access to.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像仓库**：您可以查找并下载其他 Docker Hub 用户管理的镜像。您还可以推送或拉取您有权限访问的私人镜像库中的镜像。'
- en: '**Automated builds**: You can automatically create new images when you make
    changes to a source code repository.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动构建**：当您对源代码仓库进行更改时，可以自动创建新的镜像。'
- en: '**Webhooks**: The action trigger that allows you to automate builds when there
    is a push to a repository.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webhooks**：当仓库发生推送时触发的操作，以便自动化构建。'
- en: '**Organizations**: The ability to create groups and manage access to image
    repositories.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织**：创建小组并管理对镜像仓库的访问权限。'
- en: In order to start working with Docker Hub, you need to log in to Docker Hub
    using a Docker ID. If you do not have one, you can create your Docker ID by following
    the simple registration process. It is completely free. The link to create your
    Docker ID if you do not have one is [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Docker Hub，您需要使用 Docker ID 登录 Docker Hub。如果您没有 Docker ID，可以通过简单的注册过程创建一个。它完全免费。如果您还没有
    Docker ID，创建链接是 [https://hub.docker.com/](https://hub.docker.com/)。
- en: You can search for and pull Docker images from Docker Hub without logging in;
    however, to push images you must log in. Docker Hub gives you the ability to create
    public and private repositories. Public repositories will be publicly available
    for anyone and private repositories will be restricted to a set of users of organizations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在不登录的情况下搜索和拉取 Docker 镜像；但是，要推送镜像，您必须先登录。Docker Hub 让您能够创建公共和私人仓库。公共仓库将对所有人开放，而私人仓库将仅限于特定用户或组织使用。
- en: Docker Hub contains a number of official repositories. These are public, certified
    repositories from different vendors and Docker contributors. It includes vendors
    like Red Hat, Canonical, and Oracle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 包含多个官方仓库。这些是来自不同供应商和 Docker 贡献者的公共认证仓库，涵盖了像 Red Hat、Canonical 和 Oracle
    等供应商。
- en: Docker installation and configuration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 安装和配置
- en: 'Docker software is available in two editions: **Community Edition** (**CE**)
    and **Enterprise Edition** (**EE**).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 软件有两个版本：**社区版**（**CE**）和**企业版**（**EE**）。
- en: '**Docker CE** is a good point from which to start learning Docker and using
    containerized applications. It is available on different platforms and operating
    systems. Docker CE comes with an installer so you can start working with containers
    immediately. Docker CE is integrated and optimized for infrastructure so you can
    maintain a native app experience while getting started with Docker.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker CE** 是学习 Docker 和使用容器化应用程序的一个很好的起点。它支持多个平台和操作系统。Docker CE 带有安装程序，您可以立即开始使用容器。Docker
    CE 集成并优化了基础设施，因此在开始使用 Docker 时，您可以保持原生应用体验。'
- en: '**Docker Enterprise Edition** (**EE**) is a **Container-as-a-Service** (**CaaS**)
    platform for IT that manages and secures diverse applications across disparate
    infrastructures, both on-premises and in a cloud. In other words, Docker EE is
    similar to Docker CE in that it is supported by Docker Inc.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 企业版**（**EE**）是一个**容器即服务**（**CaaS**）平台，面向 IT 管理并保护跨不同基础设施（无论是本地还是云端）的多样化应用程序。换句话说，Docker
    EE 与 Docker CE 类似，它由 Docker Inc. 提供支持。'
- en: Docker software supports a number of platforms and operating systems. The packages
    are available for most popular operating systems such as Red Hat Enterprise Linux,
    Fedora Linux, CentOS, Ubuntu Linux, Debian Linux, macOS, and Microsoft Windows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 软件支持多种平台和操作系统。大多数流行的操作系统都可以获得 Docker 的安装包，如 Red Hat Enterprise Linux、Fedora
    Linux、CentOS、Ubuntu Linux、Debian Linux、macOS 和 Microsoft Windows。
- en: Docker installation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 安装
- en: The Docker installation process is dependent on the particular operating system.
    In most cases, it is well described on the official Docker portal—[https://docs.docker.com/install/](https://docs.docker.com/install/).
    As a part of this book, we will be working with Docker software on CentOS 7.x.
    Docker installation and configuration on other platforms is not part of this book.
    If you still need to install Docker on another operating system, just visit the
    official Docker web portal.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 安装过程取决于具体的操作系统。在大多数情况下，官方 Docker 门户网站上已经有很好的描述——[https://docs.docker.com/install/](https://docs.docker.com/install/)。作为本书的一部分，我们将在
    CentOS 7.x 上使用 Docker 软件。在其他平台上的 Docker 安装与配置不在本书范围内。如果您仍然需要在其他操作系统上安装 Docker，请访问官方
    Docker 网站。
- en: 'Usually, the Docker node installation process looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Docker 节点的安装过程如下：
- en: Installation and configuration of an operating system
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统的安装与配置
- en: Docker packages installation
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 包安装
- en: Configuring Docker settings
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Docker 设置
- en: Running the Docker service
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Docker 服务
- en: We assume that our readers have sufficient knowledge to install and configure
    a CentOS-based **virtual machine** (**VM**) or bare-metal host. If you do not
    know how to use Vagrant, please follow the guidelines at [https://www.vagrantup.com/intro/getting-started/](https://www.vagrantup.com/intro/getting-started/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者已经具备足够的知识来安装和配置基于 CentOS 的 **虚拟机** (**VM**) 或裸金属主机。如果您不知道如何使用 Vagrant，请参阅以下指南：[https://www.vagrantup.com/intro/getting-started/](https://www.vagrantup.com/intro/getting-started/)。
- en: Once you properly install Vagrant on your system, just run `vagrant init centos/7` followed
    by `vagrant up`. You can verify whether vagrant is up with the `vagrant status` command,
    and finally you can `ssh` into VM by using `vagrant ssh` command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在系统上正确安装了 Vagrant，只需运行 `vagrant init centos/7`，然后运行 `vagrant up`。您可以通过 `vagrant
    status` 命令验证 Vagrant 是否已启动，最后可以通过 `vagrant ssh` 命令进入虚拟机。
- en: Since Docker is supported on even the most popular OSes, you have an option
    to install Docker directly on your desktop OS. We advise you to either use Vagrant
    or any other virtualization provider such as VMware or KVM, because we have done
    all the tests inside the virtual environment on CentOS 7\. If you still want to
    install Docker on your desktop OS, follow the link: [https://docs.docker.com/install/](https://docs.docker.com/install/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 支持包括最流行的操作系统在内的多种操作系统，您可以选择直接在桌面操作系统上安装 Docker。我们建议您使用 Vagrant 或其他虚拟化提供商，如
    VMware 或 KVM，因为我们已经在 CentOS 7 的虚拟环境中完成了所有测试。如果您仍然希望在桌面操作系统上安装 Docker，请访问链接：[https://docs.docker.com/install/](https://docs.docker.com/install/)。
- en: 'Docker CE is available on CentOS 7 with standard repositories. The installation
    process is focused on the `docker` package installation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CE 可以在 CentOS 7 上通过标准仓库进行安装。安装过程侧重于 `docker` 包的安装：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the installation is completed, you need to run the Docker daemon to be
    able to manage your containers and images. On RHEL7 and CentOS 7, this just means
    starting the Docker service like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您需要启动 Docker 守护进程，才能管理您的容器和镜像。在 RHEL7 和 CentOS 7 上，这仅仅意味着启动 Docker 服务，操作如下：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can verify that your Docker daemon works properly by showing Docker information
    provided by the `docker info` command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `docker info` 命令来验证 Docker 守护进程是否正常工作，从而显示 Docker 信息：
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Docker configuration
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 配置
- en: Docker daemon configuration is managed by the Docker configuration file (`/etc/docker/daemon.json`)
    and Docker daemon startup options are usually controlled by the `systemd` unit
    named Docker. On Red Hat-based operating systems, some configuration options are
    available at `/etc/sysconfig/docker` and `/etc/sysconfig/docker-storage`. Modification
    of the mentioned file will allow you to change Docker parameters such as the UNIX
    socket path, `listen` on TCP sockets, registry configuration, storage backends,
    and so on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程的配置由 Docker 配置文件（`/etc/docker/daemon.json`）管理，Docker 守护进程的启动选项通常由名为
    Docker 的 `systemd` 单元控制。在基于 Red Hat 的操作系统中，一些配置选项可以在 `/etc/sysconfig/docker` 和
    `/etc/sysconfig/docker-storage` 中找到。修改上述文件将允许您更改 Docker 参数，如 UNIX 套接字路径、`listen`
    在 TCP 套接字上的配置、注册表配置、存储后端等。
- en: Using the Docker command line
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 命令行
- en: 'In order to start using Docker CLI, you need to configure and bring up a Vagrant
    VM. If you are using macOS, the configuration process using Vagrant will look
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用 Docker CLI，你需要配置并启动一个 Vagrant 虚拟机。如果你使用的是 macOS，使用 Vagrant 进行配置的过程如下所示：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**# Using Docker man, help, info'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 使用 Docker man、help、info'
- en: The Docker daemon listens on `unix:///var/run/docker.sock` but you can bind
    Docker to another host/port or a Unix socket. The Docker client (the `docker` utility)
    uses the Docker API to interact with the Docker daemon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程监听 `unix:///var/run/docker.sock`，但你可以将 Docker 绑定到其他主机/端口或 Unix 套接字。Docker
    客户端（`docker` 工具）使用 Docker API 与 Docker 守护进程进行交互。
- en: The Docker client supports dozens of commands, each with numerous options, so
    an attempt to list them all would just result in a copy of the CLI reference from
    the official documentation. Instead, we will provide you with the most useful
    subsets of commands to get you up and running.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端支持数十个命令，每个命令都有众多选项，因此尝试列出它们会导致一份官方文档中的 CLI 参考副本。相反，我们将为你提供最有用的子集命令，帮助你快速上手。
- en: 'You can always check available man pages for all Docker sub-commands using:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时通过以下命令查看所有 Docker 子命令的手册页：
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will be able to see a list of man pages for Docker and all the sub-commands
    available:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够看到 Docker 及其所有子命令的手册页列表：
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another way to get information regarding a command is to use `docker COMMAND
    --help`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 获取有关命令的另一个方法是使用 `docker COMMAND --help`：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `docker` utility allows you to manage container infrastructure. All sub-commands
    can be grouped as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` 工具允许你管理容器基础设施。所有子命令可以按如下方式进行分组：'
- en: '| **Activity type** | **Related subcommands** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **活动类型** | **相关子命令** |'
- en: '| Managing images | `search`, `pull`, `push`, `rmi`, `images`, `tag`, `export`,
    `import`, `load`, `save` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 管理镜像 | `search`, `pull`, `push`, `rmi`, `images`, `tag`, `export`, `import`,
    `load`, `save` |'
- en: '| Managing containers | `run`, `exec`, `ps`, `kill`, `stop`, `start` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 管理容器 | `run`, `exec`, `ps`, `kill`, `stop`, `start` |'
- en: '| Building custom images | `build`, `commit` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 构建自定义镜像 | `build`, `commit` |'
- en: '| Information gathering | `info`, `inspect` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 信息收集 | `info`, `inspect` |'
- en: Managing images using Docker CLI
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker CLI 管理镜像
- en: The first step in running and using a container on your server or laptop is
    to search and pull a Docker image from the Docker registry using the `docker search` command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的服务器或笔记本电脑上运行和使用容器的第一步是使用 `docker search` 命令从 Docker 注册表中搜索并拉取 Docker 镜像。
- en: 'Let''s search for the web server container. The command to do so is:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们搜索 Web 服务器容器。执行此操作的命令是：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, we can go to [https://hub.docker.com/](https://hub.docker.com/)
    and type `httpd` in the search window. It will give us something similar to the `docker
    search httpd` results:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以访问[https://hub.docker.com/](https://hub.docker.com/)，在搜索窗口输入`httpd`，它会给我们类似于
    `docker search httpd` 的结果：
- en: '![](img/00008.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: Docker Hub search results
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 搜索结果
- en: 'Once the container image is found, we can pull this image from the Docker registry
    in order to start working with it. To pull a container image to your host, you
    need to use the `docker pull` command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到容器镜像，我们可以从 Docker 注册表中拉取该镜像以开始使用它。要将容器镜像拉取到主机上，你需要使用 `docker pull` 命令：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/00009.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: Note that Docker uses concepts from union filesystem layers to build Docker
    images. This is why you can see seven layers being pulled from Docker Hub. One
    stacks up onto another, building a final image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker 使用联合文件系统层的概念来构建 Docker 镜像。这就是为什么你可以看到从 Docker Hub 拉取的七个层级。一个层叠加在另一个之上，最终构建出一个完整的镜像。
- en: 'By default, Docker will try to pull the image with the latest tag, but we can
    also download an older, more specific version of an image we are interested in
    using different tags. The best way to quickly find available tags is to go to
    [https://hub.docker.com/](https://hub.docker.com/), search for the specific image,
    and click on the image details:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 会尝试拉取最新标签的镜像，但我们也可以使用不同的标签下载我们感兴趣的较旧版本镜像。快速找到可用标签的最佳方式是访问[https://hub.docker.com/](https://hub.docker.com/)，搜索特定镜像并点击镜像详情：
- en: '![](img/00010.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Docker Hub image details
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 镜像详情
- en: There we are able to see all the image tags available for us to pull from Docker
    Hub. There are ways to achieve the same goal using the `docker search` CLI command,
    which we are going to cover later in this book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里我们可以看到从 Docker Hub 拉取的所有镜像标签。也有方法可以通过 `docker search` CLI 命令实现相同的目标，稍后我们将在本书中介绍。
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding code should look something like the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应如下所示：
- en: '![](img/00011.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: You may notice that the download time for the second image was significantly
    lower than for the first image. It happens because the first image we pulled (`docker:latest`)
    has most layers in common with the second image (`httpd:2.2.29`). So there is
    no need to download all the layers again. This is very useful and saves a lot
    of time in large environments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，第二个镜像的下载时间明显低于第一个镜像。这是因为我们拉取的第一个镜像（`docker:latest`）与第二个镜像（`httpd:2.2.29`）有许多层是相同的。因此，系统无需再次下载所有的层。这在大型环境中非常有用，可以节省大量时间。
- en: Working with images
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作镜像
- en: 'Now we want to check the images available on our local server. To do this,
    we can use the `docker images` command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想检查本地服务器上可用的镜像。为此，我们可以使用`docker images`命令：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将如下所示：
- en: '![](img/00012.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: 'If we downloaded a wrong image, we can always delete it from the local server
    by using the `docker rmi` command: **ReMove Image** (**RMI**). In our case, we
    have two versions of the same image, so we can specify a tag for the image we
    want to delete:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们下载了一个错误的镜像，可以使用`docker rmi`命令将其从本地服务器中删除：**删除镜像**（**RMI**）。在我们的案例中，我们有两个版本的同一镜像，因此可以指定要删除的镜像标签：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将如下所示：
- en: '![](img/00013.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: 'At this point, we have only one image left, which is `httpd:latest`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只剩下一个镜像，它是`httpd:latest`：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将如下所示：
- en: '![](img/00014.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: Saving and loading images
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存与加载镜像
- en: The Docker CLI allows us to export and import Docker images and container layers
    using export/import or save/load Docker commands. The difference between save/load
    and export/import is that the first one works with images including metadata,
    but the export/import combination uses only container layers and doesn't include
    any image metadata information such as name, tags, and so on. In most cases, the
    save/load combination is more relevant and works properly for images without special
    needs. The `docker save` command packs the layers and metadata of all the chains
    required to build the image. You can then load this *saved* images chain into
    another Docker instance and create containers from these images.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI允许我们使用export/import或save/load命令导出和导入Docker镜像和容器层。save/load与export/import的区别在于，前者处理包含元数据的镜像，而后者仅使用容器层，不包含任何镜像元数据，如名称、标签等。在大多数情况下，save/load的组合更加相关，并且适用于没有特殊需求的镜像。`docker
    save`命令将打包所有用于构建镜像的层和元数据。然后，你可以将这个*保存的*镜像链加载到另一个Docker实例中，并基于这些镜像创建容器。
- en: 'The `docker export` will fetch the whole container, like a snapshot of a regular
    VM. It saves the OS, of course, but also any change a you made and any data file
    written during the container life. This one is more like a traditional backup:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker export`将提取整个容器，类似于普通虚拟机的快照。它不仅保存操作系统，还包括你在容器生命周期中所做的任何更改和写入的任何数据文件。这更像是传统的备份：'
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](img/00015.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 'To load the image back from the file, we can use the `docker load` command.
    Before we do that, though, let''s remove the httpd image from the local repository
    first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中加载镜像，我们可以使用`docker load`命令。不过，在此之前，我们先从本地仓库中删除httpd镜像：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将如下所示：
- en: '![](img/00016.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: 'We verify that we do not have any images in the local repository:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证本地仓库中没有任何镜像：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Load the image file we previously saved with the `docker save` command. Like
    `docker export` and docker import, this command forms a pair with Docker save
    and thus is used for loading a saved container archive with all intermediate layers
    and metadata to the Docker cache:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker save`命令保存的镜像文件，可以通过`docker load`命令将其加载回来。像`docker export`和`docker
    import`一样，这个命令与Docker的save功能成对使用，因此用于将保存的容器归档（包含所有中间层和元数据）加载到Docker缓存中：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将如下所示：
- en: '![](img/00017.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: 'Check the local docker images with `docker image` command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker image`命令检查本地的docker镜像：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00018.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Uploading images to the Docker registry
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将镜像上传到 Docker 仓库
- en: Now we know how to search, pull, remove, save, load, and list available images.
    The last piece we are missing is how to push images back to Docker Hub or a private
    registry.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何搜索、拉取、删除、保存、加载和列出可用的镜像。最后我们缺少的部分是如何将镜像推送回 Docker Hub 或私有仓库。
- en: 'To upload an image to Docker Hub, we need to do a few tricks and follow these
    steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要将镜像上传到 Docker Hub，我们需要做一些处理并按照以下步骤操作：
- en: 'Log in to Docker Hub:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 Docker Hub：
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Copy the Docker image you want to push to a different path in the Docker repository
    on your server:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您想要推送的 Docker 镜像复制到服务器上 Docker 仓库中的不同路径：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `flashdumper` is your Docker Hub username.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`flashdumper` 是您的 Docker Hub 用户名。
- en: 'Finally, push the copied image back to Docker Hub:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将复制的镜像推送回 Docker Hub：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00019.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: Now the image is pushed to your Docker Hub and available for anyone to download.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像已推送到您的 Docker Hub 并可供任何人下载。
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00020.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: 'You can check the same result using a web browser. If you go to [https://hub.docker.com/](https://hub.docker.com/)
    you should be able to see this `httpd` image available under your account:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用网页浏览器查看相同的结果。如果您访问 [https://hub.docker.com/](https://hub.docker.com/)，您应该能够在您的帐户下看到该
    `httpd` 镜像：
- en: '![](img/00021.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: Docker Hub account images
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 账户镜像
- en: Managing containers using Docker CLI
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker CLI 管理容器
- en: 'The next step is to actually run a container from the image we pulled from
    Docker Hub or a private registry in the previous chapter. We are going to use
    the `docker run` command to run a container. Before we do that, let''s check if
    we have any containers running already by using the `docker ps` command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实际运行一个容器，该容器来自于我们在上一章从 Docker Hub 或私有仓库拉取的镜像。我们将使用 `docker run` 命令来运行一个容器。在此之前，让我们先用
    `docker ps` 命令检查是否有任何容器正在运行：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run a container with the `docker run` command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker run` 命令运行一个容器：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00022.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: The container is running, but we cannot leave the terminal and continue working
    in the foreground. And the only way we can escape it is by sending a TERM signal
    (*Ctrl* + *C*) and killing it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 容器正在运行，但我们无法离开终端并继续在前台工作。而我们唯一能逃离的方法是发送一个 TERM 信号（*Ctrl* + *C*）并终止它。
- en: Docker ps and logs
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker ps 和日志
- en: 'Run the `docker ps` command to show that there are no running containers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker ps` 命令来显示没有正在运行的容器：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run `docker ps -a` to show both running and stopped containers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker ps -a` 命令来显示运行中的和已停止的容器：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00023.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'There are a few things to note here. The `STATUS` field says that container
    `5e3820a43ffc` exited about one minute ago. In order to get container log information,
    we can use the `docker logs` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意。`STATUS` 字段表示容器 `5e3820a43ffc` 大约在一分钟前退出。为了获取容器日志信息，我们可以使用 `docker
    logs` 命令：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00024.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: 'The last message says `caught SIGTERM, shutting down`. It happened after we
    pressed *Ctrl *+ *C*. In order to run a container in background mode, we can use
    the `-d` option with the `docker run` command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条消息显示 `caught SIGTERM, shutting down`。这发生在我们按下 *Ctrl* + *C* 之后。为了在后台模式下运行容器，我们可以使用
    `docker run` 命令的 `-d` 选项：
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It generates a random ID, the first 12 characters of which are used for the
    container ID. Along with the generated ID, a random container name is also generated.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成一个随机的 ID，其中前 12 个字符用于容器 ID。同时还会生成一个随机的容器名称。
- en: 'Run `docker ps` to verify the container ID, name, and status:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker ps` 来验证容器的 ID、名称和状态：
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下所示：
- en: '![](img/00025.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: Executing commands inside a container
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内执行命令
- en: 'From the output, we can see that the container status is `UP`. Now we can execute
    some commands inside the container using the `docker exec` command with different
    options:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到容器状态为`UP`。现在我们可以使用不同选项的`docker exec`命令在容器内执行一些命令：
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Option `-i` (`--interactive`) allows you to run a Docker without dropping inside
    the container. But we can easily override this behavior and enter this container
    by using `-i` and `-t` (`--tty`) options (or just `-it`):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`-i`（`--interactive`）允许你运行Docker而不进入容器。但我们可以通过使用`-i`和`-t`（`--tty`）选项（或者直接使用`-it`）轻松覆盖这种行为，进入容器：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We should fall into container bash CLI. From here, we can execute other general
    Linux commands. This trick is very useful for troubleshooting. To exit the container
    console, just type `exit` or press *Ctrl *+ *D*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该进入容器的bash CLI。在这里，我们可以执行其他常规的Linux命令。这种技巧在故障排除时非常有用。要退出容器控制台，只需输入`exit`或按*Ctrl*
    + *D*。
- en: Starting and stopping containers
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和停止容器
- en: 'We can also stop and start running containers by running `docker stop` and
    `docker start` commands:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过运行`docker stop`和`docker start`命令来停止和启动正在运行的容器：
- en: 'Enter the following command to stop the container:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以停止容器：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Enter the following command to start the container:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以启动容器：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Docker port mapping
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker端口映射
- en: 'In order to actually benefit from the container, we need to make it publicly
    accessible from the outside. This is where we will need to use the `-p` option
    with a few arguments while running the `docker run` command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际利用容器，我们需要使它从外部可访问。为此，我们在运行`docker run`命令时需要使用`-p`选项并提供一些参数：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Option `-p` maps container port `80` to your server port `8080`. Verify that
    you have a `httpd` container exposed and a web server running:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`-p`将容器的端口`80`映射到服务器端口`8080`。验证是否有`httpd`容器暴露并且web服务器正在运行：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inspecting the Docker container
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Docker容器
- en: 'While the container is running, we can inspect its parameters by using the `docker
    inspect` command. The output is provided in JSON format and it gives us a very
    comprehensive output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器正在运行时，我们可以使用`docker inspect`命令检查其参数。输出以JSON格式提供，给我们一个非常全面的结果：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Removing containers
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'In order to delete a container, you can use the `docker rm` command. If the
    container you want to delete is running, you can stop and delete it or use the `-f`
    option and it will do the job:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除一个容器，你可以使用`docker rm`命令。如果你要删除的容器正在运行，你可以先停止并删除它，或者使用`-f`选项，它会完成任务：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's try using `-f` option.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`-f`选项。
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another trick you can use to delete all containers, both stopped and running,
    is the following command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来删除所有容器，包括已停止和正在运行的容器：
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Verify that all the containers are deleted:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 验证所有容器是否已删除：
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using environment variables
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: Due to the dynamic and stateless nature of containers, applications cannot rely
    on either fixed IP addresses or DNS hostnames while communicating with middleware
    and other application services. Docker lets you store data such as configuration
    settings, encryption keys, and external resource addresses in environment variables.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器的动态和无状态特性，应用程序在与中间件和其他应用服务通信时无法依赖固定的IP地址或DNS主机名。Docker允许你将数据，如配置设置、加密密钥和外部资源地址，存储在环境变量中。
- en: Passing environment variables to a container
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向容器传递环境变量
- en: At runtime, environment variables are exposed to the application inside the
    container. You can set environment variables in a service's containers with the
    *environment* key, just like with `docker run -e VARIABLE=VALUE`. You can also
    pass environment variables from your shell straight through to a service's containers
    with the environment key by not giving them a value, just like with `docker run
    -e VARIABLE`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，环境变量会暴露给容器内的应用程序。你可以像使用`docker run -e VARIABLE=VALUE`一样，使用*environment*键在服务的容器中设置环境变量。你还可以通过不提供值的方式，直接将环境变量从你的shell传递给服务的容器，就像使用`docker
    run -e VARIABLE`一样。
- en: Environment variables are used to set specific application parameters, like
    IP addresses, for a server to connect the database server address with login credentials.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量用于设置特定的应用程序参数，如IP地址，以便服务器连接到数据库服务器地址和登录凭证。
- en: Some container startup scripts use environment variables to perform the initial
    configuration of an application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器启动脚本使用环境变量来执行应用程序的初始配置。
- en: 'For example, a `mariadb` image is created to use several environment variables
    to start a container and create users/databases at the start time. This image
    uses the following important parameters, among others:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`mariadb`镜像是为了使用多个环境变量来启动容器，并在启动时创建用户/数据库。该镜像使用以下重要参数（其中包括其他参数）：
- en: '| **Parameter** | **Description** |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `MYSQL_ROOT_PASSWORD` | This variable is mandatory and specifies the password
    that will be set for the MariaDB `root` superuser account. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `MYSQL_ROOT_PASSWORD` | 这个变量是必需的，它指定将为MariaDB `root`超级用户账户设置的密码。 |'
- en: '| `MYSQL_DATABASE` | This variable is optional and allows you to specify the
    name of a database to be created on image startup. If a user/password was supplied
    (parameters in the row below) then that user will be granted superuser access
    (corresponding to `GRANT ALL`) to this database. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `MYSQL_DATABASE` | 这个变量是可选的，允许你指定在镜像启动时要创建的数据库名称。如果提供了用户/密码（见下行参数），则该用户将被授予此数据库的超级用户访问权限（对应于`GRANT
    ALL`）。 |'
- en: '| `MYSQL_USER` and `MYSQL_PASSWORD` | These variables are optional and used
    in conjunction to create a new user and to set that user''s password. This user
    will be granted superuser permissions for the database specified by the `MYSQL_DATABASE`
    variable. Both variables are required for a user to be created. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `MYSQL_USER` 和 `MYSQL_PASSWORD` | 这些变量是可选的，用于一起创建新用户并设置该用户的密码。这个用户将被授予指定的`MYSQL_DATABASE`变量所指定数据库的超级用户权限。创建用户时，这两个变量都是必需的。
    |'
- en: 'First, we can try to pull and start a `mariadb` container without specifying
    the password/user/database-related information. It will fail since the image expects
    the parameters. In this example, we are starting a container in the foreground
    to be able to see all error messages:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以尝试拉取并启动一个`mariadb`容器，而不指定与密码/用户/数据库相关的信息。它将失败，因为镜像期望这些参数。在这个例子中，我们在前台启动容器，以便看到所有错误信息：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now try to run `mariadb` container without any options and arguments.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行没有任何选项和参数的`mariadb`容器。
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `docker run` command failed because the MariaDB image initial startup script
    was not able to find the required variables. This script expects us to have at
    least the MariaDB root password to start a database server. Let''s try to start
    a database container again by providing all required variables:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令失败，因为MariaDB镜像的初始启动脚本无法找到所需的变量。该脚本要求我们至少提供MariaDB的root密码，以便启动数据库服务器。让我们尝试再次启动数据库容器，提供所有必需的变量：'
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the `docker ps` command to verify that the container is up and running:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令验证容器是否已成功启动：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The container was created successfully. Run the verification command to check
    that `example_user` has access to the `example` database:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已成功创建。运行验证命令检查`example_user`是否有权限访问`example`数据库：
- en: '[PRE44]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The startup script created a user named `example_user` with the password `password`
    as we specified in the environment variables. It also configured a password for
    the root user. The full list of MariaDB image variables you can specify is located
    at [https://hub.docker.com/_/mariadb/](https://hub.docker.com/_/mariadb/).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 启动脚本创建了一个名为`example_user`的用户，并将密码设置为`password`，这是我们在环境变量中指定的。它还为root用户配置了一个密码。你可以在[https://hub.docker.com/_/mariadb/](https://hub.docker.com/_/mariadb/)查看你可以指定的MariaDB镜像变量的完整列表。
- en: Linking containers
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接容器
- en: 'Environment variables adjust settings for a single container. The same approach
    can be used to start a multi-tier application where one container or application
    works alongside the other:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量调整单个容器的设置。相同的方法也可以用于启动多层应用程序，其中一个容器或应用程序与另一个协同工作：
- en: '![](img/00026.jpeg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Multi-tier application example
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 多层应用程序示例
- en: In a multi-tier application, both the application server container and database
    server container may need to share variables such as database login credentials.
    Of course, we can pass all database connectivity settings to the application container
    using environment variables. It is very easy to make a mistake while passing multiple
    `-e` options to the `docker run` command, and it is very time-consuming, not to
    mention that it is very ineffective. Another option is to use container IP addresses
    to establish connections. We can gather IP address information using `docker inspect` but
    it will be difficult to track this information in a multi-container environment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在多层应用程序中，应用服务器容器和数据库服务器容器可能都需要共享数据库登录凭据等变量。当然，我们可以使用环境变量将所有数据库连接设置传递给应用程序容器。在将多个
    `-e` 选项传递给 `docker run` 命令时，很容易出错，而且这种方法非常耗时，更不用说效率低下了。另一种选择是使用容器 IP 地址建立连接。我们可以使用
    `docker inspect` 收集 IP 地址信息，但在多容器环境中追踪这些信息将非常困难。
- en: This means that using environment variables is just not enough to build multi-tier
    applications where containers depend on each other.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，仅使用环境变量不足以构建多层应用程序，其中容器相互依赖。
- en: Docker has a featured called *linked containers* to solve this problem. It automatically
    copies all environment variables from one container to another. Additionally,
    by linking containers, we can define environment variables based on the other
    container's IP address and exposed ports.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 有一个名为 *链接容器* 的功能来解决这个问题。它会自动将一个容器的所有环境变量复制到另一个容器。此外，通过链接容器，我们可以根据另一个容器的
    IP 地址和暴露的端口定义环境变量。
- en: 'Using linked containers is done by simply adding the `--link container:alias` option
    to the `docker run` command. For example, the following command links to a container
    named MariaDB using the DB alias:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链接容器非常简单，只需将 `--link container:alias` 选项添加到 `docker run` 命令中。例如，以下命令使用 DB
    别名链接到一个名为 MariaDB 的容器：
- en: '[PRE45]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The new `my_application` container will then get all variables defined from
    the linked container `mariadb`. Those variable names are prefixed by `DB_ENV_`
    so as not to conflict with the new container's own environment variables.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `my_application` 容器将获得从链接容器 `mariadb` 定义的所有变量。这些变量名以 `DB_ENV_` 为前缀，以避免与新容器的环境变量冲突。
- en: Please be aware that the aliases are all uppercase.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，别名都是大写的。
- en: 'Variables providing information about container IP addresses and ports are
    named according to the following scheme:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 提供有关容器 IP 地址和端口信息的变量按照以下规则命名：
- en: '`{ALIAS}_PORT_{exposed-port}_TCP_ADDR`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ALIAS}_PORT_{exposed-port}_TCP_ADDR`'
- en: '`{ALIAS}_PORT_{exposed-port}_TCP_PORT`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ALIAS}_PORT_{exposed-port}_TCP_PORT`'
- en: 'Continuing with the MariaDB image example, the application container would
    get the following variables:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以 MariaDB 镜像为例，应用容器将获得以下变量：
- en: '`DB_PORT_3306_TCP_ADDR`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_PORT_3306_TCP_ADDR`'
- en: '`DB_PORT_3306_TCP_PORT`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_PORT_3306_TCP_PORT`'
- en: If the linked container exposes multiple ports, each of them generates a set
    of environment variables.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接的容器暴露多个端口，每个端口都会生成一组环境变量。
- en: 'Let''s take an example. We will be creating a WordPress container which needs
    access to a database server. This integration will require shared database access
    credentials. The first step in creating this application is to create a database
    server:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们将创建一个需要访问数据库服务器的 WordPress 容器。这个集成将需要共享的数据库访问凭据。创建此应用程序的第一步是创建一个数据库服务器：
- en: '[PRE46]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step is to run a WordPress container. In that command, we will link
    the `wordpress` container with the `mariadb` container:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是运行一个 WordPress 容器。在该命令中，我们将把 `wordpress` 容器与 `mariadb` 容器链接起来：
- en: '[PRE47]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s check container environments with the `docker exec` command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker exec` 命令检查容器环境：
- en: '[PRE48]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see all these variables because the WordPress container startup script
    handles the `mysql` link. We can see here that the link set a number of `MYSQL_ENV`
    and `MYSQL_PORT` variables, which are used by the WordPress startup script.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到所有这些变量，因为 WordPress 容器启动脚本处理了 `mysql` 链接。我们可以看到，这里链接设置了一些 `MYSQL_ENV` 和
    `MYSQL_PORT` 变量，WordPress 启动脚本将使用这些变量。
- en: Using persistent storage
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用持久化存储
- en: In the previous sections, we saw that containers can be created and deleted
    easily. But when a container is deleted, all the data associated with that container
    disappears too. That is why a lot of people refer to containers as a stateless
    architecture. But we can change this behavior and keep all the data by using persistent
    volumes. In order to enable persistent storage for a Docker container, we need
    to use the `-v` option, which binds the container filesystem to the host filesystem
    that runs that container.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到容器可以轻松创建和删除。但是，当容器被删除时，所有与该容器相关的数据也会消失。这就是为什么很多人将容器称为无状态架构的原因。但我们可以通过使用持久化卷来改变这一行为，保持所有数据。为了为
    Docker 容器启用持久化存储，我们需要使用`-v`选项，它将容器文件系统与运行该容器的主机文件系统绑定。
- en: In the next example, we will create a MariaDB container with persistent storage
    in the `/mnt/data` folder on the host. Then, we delete the MariaDB container and
    recreate it again using the same persistent storage.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将创建一个在主机`/mnt/data`文件夹中具有持久化存储的 MariaDB 容器。然后，我们删除 MariaDB 容器，并使用相同的持久化存储重新创建它。
- en: 'First, remove all previously created containers:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除所有之前创建的容器：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have to prepare persistent storage on the node before we begin. Be aware
    that we need to give read/write permissions to the persistent storage directory.
    The MariaDB application works with a MySQL user with *UID=999* inside the container.
    Also, it is important to mention that the special SE Linux security context `svirt_sandbox_file_t` is
    required. This can be achieved using the following commands:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开始之前必须为节点准备持久化存储。请注意，我们需要为持久化存储目录授予读写权限。MariaDB 应用程序与容器内的 MySQL 用户 *UID=999*
    配合工作。此外，重要的是要提到，特殊的 SE Linux 安全上下文 `svirt_sandbox_file_t` 是必需的。可以通过以下命令实现：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The next step is to create the container running the MariaDB service:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建运行 MariaDB 服务的容器：
- en: '[PRE51]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the `docker ps` command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令：
- en: '[PRE52]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a new database and verify the existence of this new DB:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新数据库并验证该新数据库的存在：
- en: '[PRE53]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Verify that there is new data in the `/mnt/data` directory created by the `mariadb`
    container. This is how we make the data persistent:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 验证`/mnt/data`目录中是否有新的数据，这些数据是由`mariadb`容器创建的。这就是我们使数据持久化的方式：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Delete the `mariadb` container and verify that all files will be kept:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`mariadb`容器并验证所有文件将被保留：
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We are going to rerun the container and verify whether the previously created
    database *persistent* survived container removal and creation:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新运行容器并验证先前创建的数据库 *persistent* 是否在容器删除和创建后仍然存在：
- en: '[PRE56]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the database with the name `persistent` is still here.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，名为`persistent`的数据库仍然存在。
- en: 'Remove all the containers before you proceed to the next section:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一部分之前，删除所有容器：
- en: '[PRE57]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Creating a custom Docker image
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 Docker 镜像
- en: The Docker community has Docker images for most popular software applications.
    These include, for example, images for web servers (Apache, Nginx, and so on),
    enterprise application platforms (JBoss EAP, Tomcat), images with programming
    languages (Perl, PHP, Python), and so on.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 社区为大多数流行的软件应用程序提供了 Docker 镜像。例如，包含 Web 服务器（Apache、Nginx 等）、企业应用平台（JBoss
    EAP、Tomcat）、编程语言镜像（Perl、PHP、Python）等。
- en: In most cases, you do not need to build your own Docker images to run standard
    software. But if you have a business need that requires having a custom application,
    you probably need to create your own Docker image.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你无需构建自己的 Docker 镜像来运行标准软件。但是，如果你有需要自定义应用程序的业务需求，你可能需要创建自己的 Docker 镜像。
- en: 'There are a number of ways to create a new docker image:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新 Docker 镜像有多种方式：
- en: '**Commit**: Creating a Docker image from a running container. Docker allows
    you to *convert* a working container to a Docker image using the `docker commit`
    command. This means that image layers will be stored as a separate docker image.
    This approach is the easiest way to create a new image.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交**：从运行中的容器创建 Docker 镜像。Docker 允许你使用`docker commit`命令将一个正在运行的容器*转换*为 Docker
    镜像。这意味着镜像层将作为独立的 Docker 镜像存储。这种方法是创建新镜像的最简单方式。'
- en: '**Import/Export**: This is similar to the first one but uses another Docker
    command. Running container layers will be saved to a filesystem using docker export
    and then the image will be recreated using docker import. We do not recommend
    this method for creating a new image since the first one is simpler.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入/导出**：这与第一个方法类似，但使用了另一个 Docker 命令。运行的容器层会通过 `docker export` 命令保存到文件系统中，然后通过
    `docker import` 命令重新创建镜像。我们不推荐使用这种方法来创建新镜像，因为第一个方法更简单。'
- en: '**Dockerfile**: Building a Docker image using a Dockerfile. Dockerfile is a
    plain text file that contains a number of steps sometimes called instructions.
    These instructions can run a particular command inside a container or copy files
    to a container. A user can initiate a build process using Dockerfile and the Docker
    daemon will run all instructions in the Dockerfile in a temporary container. Then
    this container is converted to a docker image. This is the most common way to
    create a new docker image. Building custom docker images from Dockerfile will
    be described in details in a later chapter.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：使用 Dockerfile 构建 Docker 镜像。Dockerfile 是一个包含多个步骤的纯文本文件，这些步骤有时被称为指令。这些指令可以在容器内运行特定的命令或将文件复制到容器中。用户可以通过
    Dockerfile 启动构建过程，Docker 守护进程会在临时容器中执行 Dockerfile 中的所有指令。然后，这个容器会被转换成 Docker 镜像。这是创建新
    Docker 镜像最常见的方法。如何从 Dockerfile 构建自定义 Docker 镜像将在后续章节中详细介绍。'
- en: '**From scratch**: Building a base Docker image. In the two previous methods,
    Docker images are created using Docker images, and these docker images were created
    from a base Docker image. You cannot modify this base image unless you create
    one yourself. If you want to know what is inside your image, you might want to
    create a base image instead. There are two ways to do so:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从零开始**：构建一个基础的 Docker 镜像。在前两种方法中，Docker 镜像是通过 Docker 镜像创建的，而这些 Docker 镜像又是从基础
    Docker 镜像创建的。除非自己创建一个，否则无法修改这个基础镜像。如果你想了解镜像内部的内容，可能需要创建一个基础镜像。可以通过两种方式来实现：'
- en: Create a base image layer using the `tar` command.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tar` 命令创建一个基础镜像层。
- en: Use special Dockerfile instructions (from scratch). Both methods will be described
    in later chapters.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊的 Dockerfile 指令（从零开始）。两种方法将在后续章节中描述。
- en: Customizing images using docker commit
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `docker commit` 自定义镜像
- en: The general recommendation is that all Docker images should be built from a
    Dockerfile to create clean and proper image layers without unwanted temporary
    and log files, despite the fact that some vendors deliver their Docker images
    without an available Dockerfile . If there is a need to modify that existing image,
    you can use the standard `docker commit` functionality to convert an existing
    container to a new image.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议所有 Docker 镜像都应该通过 Dockerfile 构建，以创建干净且正确的镜像层，避免包含不需要的临时文件和日志文件，尽管一些供应商提供的
    Docker 镜像没有可用的 Dockerfile。如果需要修改现有镜像，可以使用标准的 `docker commit` 功能将现有容器转换为新镜像。
- en: As an example, we will try to modify our existing httpd container and make an
    image from it.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将尝试修改现有的 httpd 容器并从中创建一个镜像。
- en: 'First, we need to get the httpd image:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取 httpd 镜像：
- en: '[PRE58]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we need a container to be running. That container will be used as a template
    for a future image
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个正在运行的容器。这个容器将作为未来镜像的模板。
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we can connect to the container and modify its layers. As an example, we
    will update `index.html`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以连接到容器并修改其层。作为示例，我们将更新 `index.html` 文件：
- en: '[PRE60]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s see the changes we made using the `docker diff` command. This command
    shows you all files that were modified from the original image. The output looks
    like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用 `docker diff` 命令所做的更改。该命令会显示从原始镜像中修改的所有文件。输出结果如下：
- en: '[PRE61]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following table shows the file states of the `docker diff` command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了 `docker diff` 命令的文件状态：
- en: '| **Symbol** | **Description** |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **描述** |'
- en: '| **A** | A file or directory was added |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **A** | 添加了文件或目录 |'
- en: '| **D** | A file or directory was deleted |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| **D** | 删除了文件或目录 |'
- en: '| **C** | A file or directory was changed |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| **C** | 文件或目录已更改 |'
- en: In our case, `docker diff httpd` command shows that `index.html` was changed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`docker diff httpd` 命令显示 `index.html` 文件已被更改。
- en: 'Create a new image from the running container:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行中的容器创建新镜像：
- en: '[PRE62]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Verify that the new image has been created:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 验证新镜像是否已经创建：
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The final step is to verify that the image works properly:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是验证镜像是否正常工作：
- en: '[PRE64]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using Dockerfile build
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 构建
- en: Usually, those who use Docker containers expect to have a high-level of automation,
    and the `docker commit` command is difficult to automate. Luckily, Docker can
    build images automatically by reading instructions from a special file usually
    called a Dockerfile. A Dockerfile is a text document that contains all the commands
    a user can call on the command line to assemble an image. Using docker build,
    users can create an automated build that executes several command-line instructions
    in succession. On CentOS 7, you can learn a lot more using the Dockerfile built-in
    documentation page `man Dockerfile`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 Docker 容器的人期望实现高度自动化，而 `docker commit` 命令很难自动化。幸运的是，Docker 可以通过读取一个通常称为
    Dockerfile 的特殊文件中的指令来自动构建镜像。Dockerfile 是一个文本文件，包含了用户可以在命令行上调用的所有命令，用于组装镜像。通过使用
    docker build，用户可以创建一个自动化构建，依次执行多个命令行指令。在 CentOS 7 上，你可以通过 Dockerfile 内置的文档页面 `man
    Dockerfile` 学到更多。
- en: 'A Dockerfile has a number of instructions that help Docker to build an image
    according to your requirements. Here is a Dockerfile example, which allows us
    to achieve the same result as in the previous section:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 有许多指令，帮助 Docker 根据你的需求构建镜像。下面是一个 Dockerfile 示例，它允许我们实现与上一节相同的结果：
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once this Dockerfile is created, we can build a custom image using the `docker
    build` command:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这个 Dockerfile，我们可以使用 `docker build` 命令构建自定义镜像：
- en: '[PRE67]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Please note that the `.` at the end of the first line is important as it specifies
    the working directory. Alternatively, you can use `./` or even `$(pwd)`. So the
    full commands are going to be:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行末尾的 `.` 非常重要，它指定了工作目录。或者，你可以使用 `./` 或甚至 `$(pwd)`。所以完整的命令将是：
- en: '`docker build -t custom_image2 .`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build -t custom_image2 .`'
- en: or
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '`docker build -t custom_image2 ./`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build -t custom_image2 ./`'
- en: or
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '`docker build -t custom_image2 $(pwd)`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build -t custom_image2 $(pwd)`'
- en: '[PRE68]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Using Docker history
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 历史记录
- en: 'We can check the history of image modifications using `docker history`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker history` 来查看镜像修改的历史：
- en: '[PRE69]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that a new layer, `6b9be8efcb3a`, is added. This is where we change the
    content of the `index.html` file in comparison to the original `httpd` image.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，添加了一个新层，`6b9be8efcb3a`。这就是我们与原始 `httpd` 镜像相比更改 `index.html` 文件内容的地方。
- en: Dockerfile instructions
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 指令
- en: 'Some Dockerfile instructions are shown in the table:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Dockerfile 指令如下表所示：
- en: '| **Instruction** | **Description and examples** |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述及示例** |'
- en: '| `FROM image[:tag]` | It sets the base image used in the build process.Examples:FROM
    httpdFROM httpd:2.2 |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `FROM image[:tag]` | 设置在构建过程中使用的基础镜像。示例：FROM httpd FROM httpd:2.2 |'
- en: '| `RUN <command> <parameters>` | The RUN instruction executes any commands
    in a new layer on top of the current image and commits the results.Examples:RUN
    `yum install -y httpd &&\` `echo "custom answer" >/var/www/html/index.html` |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `RUN <command> <parameters>` | RUN 指令在当前镜像上方的新层中执行任何命令并提交结果。示例：RUN `yum install
    -y httpd &&\`  `echo "custom answer" >/var/www/html/index.html` |'
- en: '| `RUN ["command", "param1", "param2"]` | This is the same as the last one
    but in Docker format. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `RUN ["command", "param1", "param2"]` | 这与最后一个相同，但采用 Docker 格式。 |'
- en: '| `COPY <src> <dst>` | The COPY instruction copies new files from `<src>` and
    adds them to the filesystem of the container at the path `<dest>`. The `<src>`
    must be the path to a file or directory relative to the source directory that
    is being built (the context of the build) or a remote file URL.Examples:COPY `index.html
    /var/www/html/index.html` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `COPY <src> <dst>` | COPY 指令将新的文件从 `<src>` 复制并添加到容器的 `<dst>` 路径中。`<src>`
    必须是相对于正在构建的源目录（构建上下文）的文件或目录路径，或者是远程文件的 URL。示例：COPY `index.html /var/www/html/index.html`
    |'
- en: '| `ENTRYPOINT ["executable", "param1", "param2"]` | An ENTRYPOINT helps you
    configure a container that can be run as an executable. When you specify an ENTRYPOINT,
    the whole container runs as if it were only that executable.Examples:ENTRYPOINT
    `["/usr/sbin/httpd","-D","FOREGROUND"]`In most cases the default value of ENTRYPOINT
    is `/bin/sh -c`, which means that CMD will be interpreted as a command to run
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT ["executable", "param1", "param2"]` | ENTRYPOINT 帮助你配置一个可以作为可执行文件运行的容器。当你指定一个
    ENTRYPOINT 时，整个容器就像只运行那个可执行文件一样。示例：ENTRYPOINT `["/usr/sbin/httpd","-D","FOREGROUND"]`
    在大多数情况下，ENTRYPOINT 的默认值是 `/bin/sh -c`，这意味着 CMD 将被解释为要运行的命令 |'
- en: '| `EXPOSE <port>` | This instruction informs a Docker daemon that an application
    will be listening on this port at runtime. This is not very useful when working
    with standalone Docker containers because port publishing is performed via the
    `-p` argument of the CLI, but it is used by OpenShift when creating a service
    for a new application deployed from a Docker image and by Docker itself when exporting
    default environment variables inside a container. |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE <port>` | 此指令通知Docker守护进程，某个应用程序将在运行时监听这个端口。当与独立的Docker容器一起工作时，这个指令并不特别有用，因为端口发布是通过CLI的`-p`参数来完成的，但它在OpenShift中创建新应用程序服务时会使用，并且Docker本身在容器内导出默认环境变量时也会用到。
    |'
- en: '| `CMD ["executable", "param1", "param2"]`  | Provides arguments to an `ENTRYPOINT`
    command and can be overridden at runtime with the `docker run` command.Example:`CMD
     ["/usr/sbin/httpd","-D","FOREGROUND"]` |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `CMD ["executable", "param1", "param2"]` | 提供参数给`ENTRYPOINT`命令，并且可以在运行时通过`docker
    run`命令进行覆盖。例如：`CMD  [" /usr/sbin/httpd", "-D", "FOREGROUND"]` |'
- en: 'When the `docker build` command is run, Docker reads the provided Dockerfile
    from top to bottom, creating a separate layer for every instruction and placing
    it in the internal cache. If an instruction from Dockerfile is updated, it invalidates
    the respective caching layer and every subsequent one, forcing Docker to rebuild
    them when the docker build command is run again. Therefore, it''s more effective
    to place the most malleable instructions at the end of Dockerfile, so that the
    number of invalidated layers is minimized and cache usage is maximized. For example,
    suppose we have a Dockerfile with the following contents:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`docker build`命令时，Docker从上到下读取提供的Dockerfile，为每个指令创建一个单独的层并将其放入内部缓存中。如果Dockerfile中的某个指令被更新，它将使相应的缓存层以及所有后续层失效，这将迫使Docker在再次运行`docker
    build`命令时重新构建这些层。因此，将最易变的指令放在Dockerfile的末尾更为有效，这样可以最小化失效的层数，并最大化缓存的使用。例如，假设我们有一个包含以下内容的Dockerfile：
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the example, if you choose to use MySQL instead of MariaDB, the layer created
    by the second RUN command, as well as the third one, will be invalidated, which
    for complex images means a noticeably longer build process.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果你选择使用MySQL而不是MariaDB，那么第二个RUN命令创建的层，以及第三个命令创建的层，将会被失效，这对于复杂的镜像意味着构建过程明显变长。
- en: 'Consider the following example. Docker includes images for minimal OSes. These
    base images can be used to build custom images on top of them. In the example,
    we will be using a CentOS 7 base image to create a web server container from scratch:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下示例。Docker包含了最小操作系统的镜像。这些基础镜像可以用来在其上构建自定义镜像。在这个例子中，我们将使用一个CentOS 7基础镜像从零开始创建一个Web服务器容器：
- en: 'First, we need to create a `project` directory:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`project`目录：
- en: '[PRE71]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we create a Dockerfile with the following content:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含以下内容的Dockerfile：
- en: '[PRE72]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create the `index.html` file:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`文件：
- en: '[PRE73]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Build the image using `docker build`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`命令构建镜像：
- en: '[PRE74]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, we can check that the new image exists and has all the required image
    layers:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以检查新镜像是否存在，并且包含所有需要的镜像层：
- en: '[PRE75]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The top three layers are the instructions we added in the Dockerfile.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 前三层是我们在Dockerfile中添加的指令。
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have discussed container architecture, worked with Docker
    images and containers, examined different Docker registries, learned how to manage
    persistent storage for containers, and finally looked at how to build a Docker
    image with Dockerfile. All these skills will be required in [Chapter 3](part0093.html#2OM4A0-78aafb146b304cdeb9b3261a70edabde),
    *CRI-O Overview*, where we start working with Kubernetes. Kubernetes is an essential
    and critical OpenShift component. It all works like a snowball: Docker skills
    are required by Kubernetes, and Kubernetes skills are required by Openshift.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们讨论了容器架构，使用了Docker镜像和容器，检查了不同的Docker注册表，学习了如何管理容器的持久存储，最后了解了如何使用Dockerfile构建Docker镜像。所有这些技能都将在[第3章](part0093.html#2OM4A0-78aafb146b304cdeb9b3261a70edabde)中用到，*CRI-O概述*，我们将在那里开始使用Kubernetes。Kubernetes是OpenShift的一个重要组成部分，至关重要。它们就像滚雪球一样：Kubernetes需要Docker技能，OpenShift又需要Kubernetes技能。
- en: In the next chapter, we are going to work with Kubernetes. Kubernetes is an
    industry-standard orchestration layer for Docker containers. This is where you
    are going to install and run some basic Docker containers using Kubernetes.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Kubernetes。Kubernetes是Docker容器的行业标准编排层。在这里，你将安装并运行一些基本的Docker容器，使用Kubernetes进行管理。
- en: Questions
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'What are the three main Docker components? choose one:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker的三个主要组件是什么？请选择一个：
- en: Docker Container, Docker Image, Docker Registry
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 容器、Docker 镜像、Docker 注册中心
- en: Docker Hub, Docker Image, Docker Registry
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Hub、Docker 镜像、Docker 注册中心
- en: Docker Runtime, Docker Image, Docker Hub
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 运行时、Docker 镜像、Docker Hub
- en: Docker Container, Docker Image, Docker Hub
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 容器、Docker 镜像、Docker Hub
- en: 'Choose two valid registry types:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个有效的注册中心类型：
- en: Personal Registry
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 个人注册中心
- en: Private Registry
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有注册中心
- en: Public Registry
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共注册中心
- en: Security Registry
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全注册中心
- en: 'The main purpose of Docker Persistent Storage is to make sure that an application
    data is saved if a container dies:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 持久存储的主要目的是确保在容器死亡时，应用数据能够被保存：
- en: 'True'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'What Linux feature controls resource limitations for a Docker container? choose
    one:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么 Linux 特性控制 Docker 容器的资源限制？选择一个：
- en: Cgroups
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cgroups
- en: Namespaces
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间
- en: SELinux
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux
- en: chroot
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: chroot
- en: 'What commands can be used to build a custom image from a Dockerfile? choose
    two:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么命令可以用来从 Dockerfile 构建自定义镜像？选择两个：
- en: docker build -t new_httpd_image .
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: docker build -t new_httpd_image .
- en: docker build -t new_httpd_image .\
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: docker build -t new_httpd_image .\
- en: docker build -t new_httpd_image ($pwd)
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: docker build -t new_httpd_image ($pwd)
- en: docker build -t new_httpd_image ./
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: docker build -t new_httpd_image ./
- en: 'The `docker commit` command saves Docker images to an upstream repository:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker commit` 命令将 Docker 镜像保存到上游仓库：'
- en: 'True'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Further reading
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Since we are covering the very basics of Docker containers, you may be interested
    in diving into specific topics. Here''s a list of links that may be helpful to
    look through to learn more about Docker and containers in general:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讲解 Docker 容器的基础知识，你可能有兴趣深入了解一些特定的主题。这里有一份链接列表，供你参考，帮助你更深入地了解 Docker 和容器的相关内容：
- en: '**Docker overview**: [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 概览**: [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)'
- en: '**Docker CLI**: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker CLI**: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)'
- en: '**Docker Storage**: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 存储**: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)'
- en: '**Docker storage drivers**: [https://docs.docker.com/storage/storagedriver/select-storage-driver/](https://docs.docker.com/storage/storagedriver/select-storage-driver/)**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 存储驱动**: [https://docs.docker.com/storage/storagedriver/select-storage-driver/](https://docs.docker.com/storage/storagedriver/select-storage-driver/)'
