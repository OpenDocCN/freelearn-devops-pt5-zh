- en: '*Chapter 1*: Communicating with Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：与 Kubernetes 通信'
- en: This chapter contains an explanation of container orchestration, including its
    benefits, use cases, and popular implementations. We'll also review Kubernetes
    briefly, including a layout of the architectural components, and a primer on authorization,
    authentication, and general communication with Kubernetes. By the end of this
    chapter, you'll know how to authenticate and communicate with the Kubernetes API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含容器编排的解释，包括其优点、用例和流行的实现方式。我们还将简要回顾 Kubernetes，包括架构组件的布局，以及有关授权、身份验证和与 Kubernetes
    一般通信的入门知识。到本章结束时，您将了解如何对 Kubernetes API 进行身份验证和通信。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A container orchestration primer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器编排入门
- en: Kubernetes' architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的架构
- en: Authentication and authorization on Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 上的身份验证和授权
- en: Using kubectl and YAML files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kubectl 和 YAML 文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    running Linux, macOS, or Windows. This chapter will teach you how to install the
    `kubectl` command-line tool that you will use in all later chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章详细介绍的命令，您需要一台运行 Linux、macOS 或 Windows 的计算机。本章将教您如何安装 `kubectl` 命令行工具，您将在后续章节中使用该工具。
- en: 'The code used in this chapter can be found in the book''s GitHub repository
    at the following link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的 GitHub 仓库中找到，链接如下：
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1)'
- en: Introducing container orchestration
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍容器编排
- en: We cannot talk about Kubernetes without an introduction of its purpose. Kubernetes
    is a container orchestration framework, so let's review what that means in the
    context of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在不介绍 Kubernetes 目的的情况下谈论它。Kubernetes 是一个容器编排框架，因此让我们回顾一下在本书中这个概念的含义。
- en: What is container orchestration?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是容器编排？
- en: Container orchestration is a popular pattern for running modern applications
    both in the cloud and the data center. By using containers – preconfigured application
    units with bundled dependencies – as a base, developers can run many instances
    of an application in parallel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排是运行现代应用程序的一种流行模式，适用于云端和数据中心。通过使用容器——预配置的应用单元，包含所有依赖项——作为基础，开发人员可以并行运行多个应用实例。
- en: Benefits of container orchestration
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器编排的好处
- en: There are quite a few benefits that container orchestration offers, but we will
    highlight the main ones. First, it allows developers to easily build **high-availability**
    applications. By having multiple instances of an application running, a container
    orchestration system can be configured in a way that means it will automatically
    replace any failed instances of the application with new ones.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排提供了许多好处，但我们将突出主要的几个。首先，它允许开发人员轻松构建**高可用性**的应用程序。通过运行多个应用实例，容器编排系统可以以一种配置方式工作，确保它能自动用新的实例替换任何故障的应用实例。
- en: This can be extended to the cloud by having those multiple instances of the
    application spread across physical data centers, so if one data center goes down,
    other instances of the application will remain, and prevent downtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将应用程序的多个实例分布在物理数据中心中扩展到云端，因此如果一个数据中心出现故障，其他实例的应用程序将继续运行，避免停机。
- en: Second, container orchestration allows for highly **scalable** applications.
    Since new instances of the application can be created and destroyed easily, the
    orchestration tool can auto-scale up and down to meet demand. Either in a cloud
    or data center environment, new **Virtual Machines** (**VMs**) or physical machines
    can be added to the orchestration tool to give it a bigger pool of compute to
    manage. This process can be completely automated in a cloud setting to allow for
    completely hands-free scaling, both at the micro and macro level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，容器编排可以支持高度**可扩展**的应用程序。由于可以轻松创建和销毁应用程序的新实例，编排工具可以根据需求自动进行上下扩展。无论是在云环境还是数据中心环境中，都可以向编排工具添加新的**虚拟机**（**VMs**）或物理机器，以提供更大的计算池供其管理。在云环境中，这一过程可以完全自动化，允许实现完全免人工干预的扩展，既可以在微观层面，也可以在宏观层面进行。
- en: Popular orchestration tools
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的编排工具
- en: 'There are several highly popular container orchestration tools available in
    the ecosystem:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在生态系统中，有几种非常流行的容器编排工具：
- en: '**Docker Swarm**: Docker Swarm was created by the team behind the Docker container
    engine. It is easier to set up and run compared to Kubernetes, but somewhat less
    flexible.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Swarm**：Docker Swarm 是由 Docker 容器引擎背后的团队创建的。与 Kubernetes 相比，它的设置和运行更加简单，但灵活性稍差。'
- en: '**Apache Mesos**: Apache Mesos is a lower-level orchestration tool that manages
    compute, memory, and storage, in both data center and cloud environments. By default,
    Mesos does not manage containers, but Marathon – a framework that runs on top
    of Mesos – is a fully fledged container orchestration tool. It is even possible
    to run Kubernetes on top of Mesos.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Mesos**：Apache Mesos 是一个低层次的编排工具，管理计算、内存和存储，在数据中心和云环境中均可使用。默认情况下，Mesos
    不管理容器，但 Marathon —— 一个运行在 Mesos 上的框架 —— 是一个完整的容器编排工具。甚至可以在 Mesos 上运行 Kubernetes。'
- en: '**Kubernetes**: As of 2020, much of the work in container orchestration has
    consolidated around Kubernetes (koo-bur-net-ees), often shortened to k8s. Kubernetes
    is an open source container orchestration tool that was originally created by
    Google, with learnings from internal orchestration tools Borg and Omega, which
    had been in use at Google for years. Since Kubernetes became open source, it has
    risen in popularity to become the de facto way to run and orchestrate containers
    in an enterprise environment. There are a few reasons for this, including that
    Kubernetes is a mature product that has an extremely large open source community.
    It is also simpler to operate than Mesos, and more flexible than Docker Swarm.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：截至 2020 年，容器编排的许多工作已经集中在 Kubernetes（koo-bur-net-ees）上，通常缩写为
    k8s。Kubernetes 是一个开源容器编排工具，最初由 Google 创建，借鉴了其内部的编排工具 Borg 和 Omega，这些工具在 Google
    内部已使用多年。自从 Kubernetes 开源以来，它的受欢迎程度迅速上升，成为企业环境中运行和编排容器的事实标准。原因有几个，其中之一是 Kubernetes
    是一个成熟的产品，拥有极其庞大的开源社区。它的操作也比 Mesos 更简单，比 Docker Swarm 更加灵活。'
- en: The most important thing to take away from this comparison is that although
    there are multiple relevant options for container orchestration and some are indeed
    better in certain ways, Kubernetes has emerged as the de facto standard. With
    this in mind, let's take a look at how Kubernetes works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个比较中最重要的结论是，尽管有多个相关的容器编排选项，并且其中一些在某些方面确实更好，但 Kubernetes 已成为事实上的标准。考虑到这一点，让我们来看看
    Kubernetes 是如何工作的。
- en: Kubernetes' architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: Kubernetes is an orchestration tool that can run on cloud VMs, on VMs running
    in your data center, or on bare metal servers. In general, Kubernetes runs on
    a set of nodes, each of which can each be a VM or a physical machine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个可以运行在云虚拟机、数据中心的虚拟机或裸金属服务器上的编排工具。一般来说，Kubernetes 运行在一组节点上，每个节点可以是虚拟机或物理机器。
- en: Kubernetes node types
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 节点类型
- en: 'Kubernetes nodes can be many different things – from a VM, to a bare metal
    host, to a Raspberry Pi. Kubernetes nodes are split into two distinct categories:
    first, the master nodes, which run the Kubernetes control plane applications;
    second, the worker nodes, which run the applications that you deploy onto Kubernetes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 节点可以是许多不同的东西 —— 从虚拟机到裸金属主机，再到树莓派。Kubernetes 节点分为两类：首先是主节点，运行 Kubernetes
    控制平面应用程序；其次是工作节点，运行你部署到 Kubernetes 上的应用程序。
- en: In general, for high availability, a production deployment of Kubernetes should
    have a minimum of three master nodes and three worker nodes, though most large
    deployments have many more workers than masters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，为了保证高可用性，Kubernetes 的生产环境部署应至少有三个主节点和三个工作节点，尽管大多数大型部署中，工作节点的数量远多于主节点。
- en: The Kubernetes control plane
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 控制平面
- en: 'The Kubernetes control plane is a suite of applications and services that run
    on the master nodes. There are several highly specialized services at play that
    form the core of Kubernetes functionality. They are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 控制平面是一组运行在主节点上的应用程序和服务。这里有多个高度专业化的服务，它们构成了 Kubernetes 功能的核心。它们如下所示：
- en: '**kube-apiserver**: This is the Kubernetes API server. This application handles
    instructions sent to Kubernetes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-apiserver**：这是 Kubernetes API 服务器。这个应用程序处理发送到 Kubernetes 的指令。'
- en: '**kube-scheduler**: This is the Kubernetes scheduler. This component handles
    the work of deciding which nodes to place workloads on, which can become quite
    complex.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-scheduler**：这是 Kubernetes 调度器。这个组件负责决定将工作负载放置在哪些节点上，这个过程可能变得非常复杂。'
- en: '**kube-controller-manager**: This is the Kubernetes controller manager. This
    component provides a high-level control loop that ensures that the desired configuration
    of the cluster and applications running on it is implemented.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-controller-manager**：这是 Kubernetes 控制器管理器。这个组件提供了一个高级控制循环，确保集群及其上运行的应用程序的期望配置得以实现。'
- en: '**etcd**: This is a distributed key-value store that contains the cluster configuration.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：这是一个分布式键值存储，包含集群配置。'
- en: Generally, all of these components take the form of system services that run
    on every master node. They can be started manually if you wanted to bootstrap
    your cluster entirely by hand, but through the use of a cluster creation library
    or cloud provider-managed service such as **Elastic Kubernetes Service (EKS)**,
    this will usually be done automatically in a production setting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些组件都以系统服务的形式运行在每个主节点上。如果你想手动启动集群，这些服务可以手动启动，但通过使用集群创建库或云提供商托管的服务，如 **弹性
    Kubernetes 服务 (EKS)**，通常在生产环境中会自动完成。
- en: The Kubernetes API server
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器
- en: The Kubernetes API server is a component that accepts HTTPS requests, typically
    on port `443`. It presents a certificate, which can be self-signed, as well as
    authentication and authorization mechanisms, which we will cover later in this
    chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器是一个组件，接受 HTTPS 请求，通常使用端口 `443`。它会呈现一个证书，可以是自签名的，并且提供认证和授权机制，这些内容我们将在本章后面介绍。
- en: When a configuration request is made to the Kubernetes API server, it will check
    the current cluster configuration in `etcd` and change it if necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 Kubernetes API 服务器发送配置请求时，它会检查当前集群配置中的 `etcd` 并在必要时进行更改。
- en: The Kubernetes API is generally a RESTful API, with endpoints for each Kubernetes
    resource type, along with an API version that is passed in the query path; for
    instance, `/api/v1`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 通常是一个 RESTful API，针对每种 Kubernetes 资源类型提供端点，并带有一个 API 版本，在查询路径中传递；例如，`/api/v1`。
- en: For the purposes of extending Kubernetes (see [*Chapter 13*](B14790_13_Final_PG_ePub.xhtml#_idTextAnchor289),
    *Extending Kubernetes with CRDs*), the API also has a set of dynamic endpoints
    based on API groups, which can expose the same RESTful API functionality to custom
    resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展 Kubernetes（参见 [*第 13 章*](B14790_13_Final_PG_ePub.xhtml#_idTextAnchor289)，*通过
    CRD 扩展 Kubernetes*），API 还具有一组基于 API 组的动态端点，这些端点可以将相同的 RESTful API 功能暴露给自定义资源。
- en: The Kubernetes scheduler
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 调度器
- en: The Kubernetes scheduler decides where instances of a workload should be run.
    By default, this decision is influenced by workload resource requirements and
    node status. You can also influence the scheduler via placement controls that
    are configurable in Kubernetes (see [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*). These controls can act on node labels, which other
    pods are already running on a node, and many other possibilities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 调度器决定工作负载的实例应该运行在哪里。默认情况下，这个决定受到工作负载资源需求和节点状态的影响。你还可以通过在 Kubernetes
    中可配置的放置控制来影响调度器（参见 [*第 8 章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)，*Pod
    放置控制*）。这些控制可以作用于节点标签、节点上已经运行的其他 Pod，以及许多其他可能性。
- en: The Kubernetes controller manager
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 控制器管理器
- en: 'The Kubernetes controller manager is a component that runs several controllers.
    Controllers run control loops that ensure that the actual state of the cluster
    matches that stored in the configuration. By default, these include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 控制器管理器是一个运行多个控制器的组件。控制器运行控制循环，确保集群的实际状态与存储在配置中的状态相匹配。默认情况下，这些包括以下内容：
- en: The node controller, which ensures that nodes are up and running
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点控制器，确保节点正常运行
- en: The replication controller, which ensures that each workload is scaled properly
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本控制器，确保每个工作负载得到适当的扩展
- en: The endpoints controller, which handles communication and routing configuration
    for each workload (see [*Chapter 5*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)*,
    Services and Ingress – Communicating with the Outside World*)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点控制器，负责处理每个工作负载的通信和路由配置（参见 [*第 5 章*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)*，服务与入口
    – 与外界通信*）
- en: Service account and token controllers, which handle the creation of API access
    tokens and default accounts
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务账户和令牌控制器，负责创建 API 访问令牌和默认账户
- en: etcd
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd
- en: etcd is a distributed key-value store that houses the configuration of the cluster
    in a highly available way. An `etcd` replica runs on each master node and uses
    the Raft consensus algorithm, which ensures that a quorum is maintained before
    allowing any changes to the keys or values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: etcd 是一个分布式键值存储，用于以高度可用的方式存储集群的配置。每个主节点上运行一个 `etcd` 副本，并使用 Raft 一致性算法，确保在允许对键值进行任何更改之前，必须保持法定人数。
- en: The Kubernetes worker nodes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 工作节点
- en: Each Kubernetes worker node contains components that allow it to communicate
    with the control plane and handle networking.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Kubernetes 工作节点都包含一些组件，使其能够与控制平面通信并处理网络。
- en: First, there is the **kubelet**, which makes sure that containers are running
    on the node as dictated by the cluster configuration. Second, **kube-proxy** provides
    a network proxy layer to workloads running on each node. And finally, the **container
    runtime** is used to run the workloads on each node.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 **kubelet**，它确保集群配置要求的容器在节点上运行。其次，**kube-proxy** 提供了一个网络代理层，支持每个节点上运行的工作负载。最后，**容器运行时**
    用于在每个节点上运行工作负载。
- en: kubelet
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubelet
- en: The kubelet is an agent that runs on every node (including master nodes, though
    it has a different configuration in that context). Its main purpose is to receive
    a list of PodSpecs (more on those later) and ensure that the containers prescribed
    by them are running on the node. The kubelet gets these PodSpecs through a few
    different possible mechanisms, but the main way is by querying the Kubernetes
    API server. Alternately, the kubelet can be started with a file path, which it
    will monitor for a list of PodSpecs, an HTTP endpoint to monitor, or its own HTTP
    endpoint to receive requests on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet 是一个运行在每个节点上的代理（包括主节点，尽管在此上下文中具有不同的配置）。它的主要功能是接收一份 PodSpecs 列表（稍后将详细介绍），并确保这些
    PodSpecs 所指定的容器在节点上运行。kubelet 可以通过几种不同的机制来获取这些 PodSpecs，但主要方式是通过查询 Kubernetes
    API 服务器。或者，kubelet 也可以通过文件路径启动，它将监视该文件路径中的 PodSpecs 列表、监视 HTTP 端点，或使用它自己的 HTTP
    端点接收请求。
- en: kube-proxy
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-proxy
- en: kube-proxy is a network proxy that runs on every node. Its main purpose is to
    do TCP, UDP, and SCTP forwarding (either via stream or round-robin) to workloads
    running on its node. kube-proxy supports the Kubernetes `Service` construct, which
    we will discuss in [*Chapter 5*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)*,
    Services and Ingress – Communicating with the Outside World*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy 是一个运行在每个节点上的网络代理。它的主要目的是将 TCP、UDP 和 SCTP 转发（通过流或轮询方式）到其节点上运行的工作负载。kube-proxy
    支持 Kubernetes 的 `Service` 构造，我们将在[*第 5 章*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)中讨论，*服务与入口——与外部世界通信*。
- en: The container runtime
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器运行时
- en: The container runtime runs on each node and is the component that actually runs
    your workloads. Kubernetes supports CRI-O, Docker, containerd, rktlet, and any
    valid **Container Runtime Interface** (**CRI**) runtime. As of Kubernetes v1.14,
    the RuntimeClass feature has been moved from alpha to beta and allows for workload-specific
    runtime selection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时在每个节点上运行，并且是实际运行你工作负载的组件。Kubernetes 支持 CRI-O、Docker、containerd、rktlet 和任何有效的
    **容器运行时接口**（**CRI**）运行时。从 Kubernetes v1.14 版本开始，RuntimeClass 功能已从 alpha 版本移至 beta
    版本，并允许针对特定工作负载选择运行时。
- en: Addons
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: In addition to the core cluster components, a typical Kubernetes installation
    includes addons, which are additional components that provide cluster functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心集群组件外，典型的 Kubernetes 安装还包括插件，它们是提供集群功能的附加组件。
- en: For example, `Calico`, `Flannel`, or `Weave` provide overlay network functionality
    that adheres to Kubernetes' networking requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Calico`、`Flannel` 或 `Weave` 提供符合 Kubernetes 网络要求的覆盖网络功能。
- en: CoreDNS, on the other hand, is a popular addon for in-cluster DNS and service
    discovery. There are also tools such as Kubernetes Dashboard, which provides a
    GUI for viewing and interacting with your cluster.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CoreDNS 是一个流行的集群内 DNS 和服务发现插件。还有像 Kubernetes Dashboard 这样的工具，它提供了一个 GUI 用于查看和交互操作你的集群。
- en: At this point, you should have a high-level idea of the major components of
    Kubernetes. Next, we will review how a user interacts with Kubernetes to control
    those components.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该对 Kubernetes 的主要组件有一个高层次的了解。接下来，我们将回顾用户如何与 Kubernetes 交互以控制这些组件。
- en: Authentication and authorization on Kubernetes
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 中的身份验证和授权
- en: Namespaces are an extremely important concept in Kubernetes, and since they
    can affect API access as well as authorization, we'll cover them now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是 Kubernetes 中一个极其重要的概念，由于它们可能会影响 API 访问和授权，因此我们现在来讨论它们。
- en: Namespaces
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace in Kubernetes is a construct that allows you to group Kubernetes
    resources in your cluster. They are a method of separation with many possible
    uses. For instance, you could have a namespace in your cluster for each environment
    – dev, staging, and production.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的命名空间是一种允许你将集群中的 Kubernetes 资源进行分组的结构。它们是一种分隔方法，具有许多可能的用途。例如，你可以为每个环境（如开发、测试和生产）在集群中创建一个命名空间。
- en: By default, Kubernetes will create the default namespace, the `kube-system`
    namespace, and the `kube-public` namespace. Resources created without a specified
    namespace will be created in the default namespace. `kube-system` contains the
    cluster services such as `etcd`, the scheduler, and any resource created by Kubernetes
    itself and not users. `kube-public` is readable by all users by default and can
    be used for public resources.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 会创建默认命名空间、`kube-system` 命名空间和 `kube-public` 命名空间。没有指定命名空间的资源将被创建在默认命名空间中。`kube-system`
    包含集群服务，如 `etcd`、调度器和 Kubernetes 自身创建的任何资源，而不是用户创建的。`kube-public` 默认对所有用户可读，可以用于公共资源。
- en: Users
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户
- en: There are two types of users in Kubernetes – regular users and service accounts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中有两种用户类型——普通用户和服务账户。
- en: Regular users are generally managed by a service outside the cluster, whether
    they be private keys, usernames and passwords, or some form of user store. Service
    accounts however are managed by Kubernetes and restricted to specific namespaces.
    To create a service account, the Kubernetes API may automatically make one, or
    they can be made manually through calls to the Kubernetes API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 普通用户通常由集群外的服务管理，无论是私钥、用户名和密码，还是某种形式的用户存储。而服务账户则由 Kubernetes 管理，并且被限制在特定的命名空间内。要创建一个服务账户，Kubernetes
    API 可能会自动创建，或者可以通过调用 Kubernetes API 手动创建。
- en: There are three possible types of requests to the Kubernetes API – those associated
    with a regular user, those associated with a service account, and anonymous requests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种可能的请求类型：与普通用户相关的请求、与服务账户相关的请求以及匿名请求。
- en: Authentication methods
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证方法
- en: 'In order to authenticate requests, Kubernetes provides several different options:
    HTTP basic authentication, client certificates, bearer tokens, and proxy-based
    authentication.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了认证请求，Kubernetes 提供了几种不同的选项：HTTP 基本认证、客户端证书、承载令牌和基于代理的认证。
- en: To use HTTP authentication, the requestor sends requests with an `Authorization`
    header that will have the value bearer `"token value"`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 HTTP 认证，请求者发送包含 `Authorization` 头的请求，该头部的值为 bearer `"token value"`。
- en: In order to specify which tokens are valid, a CSV file can be provided to the
    API server application when it starts using the `--token-auth-file=filename` parameter.
    A new beta feature (as of the writing of this book), called *Bootstrap Tokens*,
    allows for the dynamic swapping and changing of tokens while the API server is
    running, without restarting it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定哪些令牌有效，启动 API 服务器应用程序时可以提供一个 CSV 文件，使用 `--token-auth-file=filename` 参数。一个新的
    beta 特性（截至本书撰写时）叫做 *引导令牌*，允许在 API 服务器运行时动态交换和更改令牌，而无需重启。
- en: Basic username/password authentication is also possible via the `Authorization`
    token, by using the header value `Basic base64encoded(username:password)`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过 `Authorization` 令牌进行基本的用户名/密码认证，使用请求头值 `Basic base64encoded(username:password)`。
- en: Kubernetes' certificate infrastructure for TLS and security
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 的 TLS 和安全证书基础设施
- en: In order to use client certificates (X.509 certificates), the API server must
    be started using the `--client-ca-file=filename` parameter. This file needs to
    contain one or more **Certificate Authorities** (**CAs**) that will be used when
    validating certificates passed with API requests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用客户端证书（X.509 证书），必须使用 `--client-ca-file=filename` 参数启动 API 服务器。此文件需要包含一个或多个
    **证书颁发机构**（**CAs**），它们将在验证 API 请求中传递的证书时使用。
- en: In addition to the `groups` can be included, which we will discuss in the *Authorization*
    options section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `groups` 可以包含的内容，我们将在 *Authorization* 选项部分讨论。
- en: 'For instance, you can use the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用以下内容：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a CSR for the user `myuser` who is part of groups named `dev`
    and `staging`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为用户 `myuser` 创建一个 CSR，该用户属于名为 `dev` 和 `staging` 的组。
- en: Once the CA and CSR are created, the actual client and server certificates can
    be created using `openssl`, `easyrsa`, `cfssl`, or any certificate generation
    tool. TLS certificates for the Kubernetes API can also be created at this point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 CA 和 CSR 被创建，就可以使用 `openssl`、`easyrsa`、`cfssl` 或任何证书生成工具创建实际的客户端和服务器证书。此时还可以为
    Kubernetes API 创建 TLS 证书。
- en: Since our aim is to get you started running workloads on Kubernetes as soon
    as possible, we will leave all the various possible certificate configurations
    out of this book – but both the Kubernetes documentation and the article *Kubernetes
    The Hard Way* have some great tutorials on setting up a cluster from scratch.
    In the majority of production settings, you will not be doing these steps manually.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的目标是尽快让你开始在 Kubernetes 上运行工作负载，所以我们将本书中省略所有可能的证书配置——但 Kubernetes 文档和文章 *Kubernetes
    The Hard Way* 提供了一些关于从零开始设置集群的很好的教程。在大多数生产环境中，你不会手动执行这些步骤。
- en: Authorization options
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权选项
- en: 'Kubernetes provides several authorization methods: nodes, webhooks, RBAC, and
    ABAC. In this book, we will focus on RBAC and ABAC as they are the ones used most
    often for user authorization. If you extend your cluster with other services and/or
    custom features, the other authorization modes may become more important.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了几种授权方法：节点、webhook、RBAC 和 ABAC。在本书中，我们将重点讨论 RBAC 和 ABAC，因为它们是最常用于用户授权的方式。如果你通过其他服务和/或自定义功能扩展集群，其他授权模式可能会变得更加重要。
- en: RBAC
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC
- en: '`Role`, `ClusterRole`, `RoleBinding`, and `ClusterRoleBinding`. To enable RBAC
    mode, the API server can be started with the `--authorization-mode=RBAC` parameter.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role`、`ClusterRole`、`RoleBinding` 和 `ClusterRoleBinding`。要启用 RBAC 模式，API 服务器可以通过
    `--authorization-mode=RBAC` 参数启动。'
- en: '`Role` and `ClusterRole` resources specify a set of permissions, but do not
    assign those permissions to any specific users. Permissions are specified using
    `resources` and `verbs`. Here is a sample YAML file specifying a `Role`. Don''t
    worry too much about the first few lines of the YAML file – we''ll get to those
    soon. Focus on the `resources` and `verbs` lines to see how the actions can be
    applied to resources:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role` 和 `ClusterRole` 资源指定了一组权限，但并没有将这些权限分配给任何特定的用户。权限是通过 `resources` 和 `verbs`
    来指定的。以下是一个指定 `Role` 的示例 YAML 文件。不要过于担心 YAML 文件的前几行——我们稍后会解释。重点关注 `resources` 和
    `verbs` 行，看看如何将操作应用于资源：'
- en: Read-only-role.yaml
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Read-only-role.yaml
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only difference between a `Role` and `ClusterRole` is that a `Role` is restricted
    to a particular namespace (in this case, the default namespace), while a `ClusterRole`
    can affect access to all resources of that type in the cluster, as well as cluster-scoped
    resources such as nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role` 和 `ClusterRole` 之间唯一的区别在于，`Role` 限制在特定的命名空间中（在这种情况下是默认命名空间），而 `ClusterRole`
    可以影响集群中该类型的所有资源访问，以及集群范围的资源，如节点。'
- en: '`RoleBinding` and `ClusterRoleBinding` are resources that associate a `Role`
    or `ClusterRole` with a user or a list of users. The following file represents
    a `RoleBinding` resource to connect our `read-only-role` with a user, `readonlyuser`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleBinding` 和 `ClusterRoleBinding` 是将 `Role` 或 `ClusterRole` 与用户或用户列表关联的资源。以下文件表示一个将
    `read-only-role` 与用户 `readonlyuser` 连接的 `RoleBinding` 资源：'
- en: Read-only-rb.yaml
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Read-only-rb.yaml
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `subjects` key contains a list of all entities to associate a role with;
    in this case, the user `alex`. `roleRef` contains the name of the role to associate,
    and the type (either `Role` or `ClusterRole`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`subjects` 键包含所有要关联角色的实体列表；在此例中是用户 `alex`。`roleRef` 包含要关联的角色的名称，以及类型（`Role`
    或 `ClusterRole`）。'
- en: ABAC
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABAC
- en: '`--authorization-mode=ABAC` and `--authorization-policy-file=filename` parameters.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`--authorization-mode=ABAC` 和 `--authorization-policy-file=filename` 参数。'
- en: 'In the policy file, each policy object contains information about a single
    policy: firstly, which subjects it corresponds to, which can be either users or
    groups, and secondly, which resources can be accessed via the policy. Additionally,
    a Boolean `readonly` value can be included to limit the policy to `list`, `get`,
    and `watch` operations.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略文件中，每个策略对象包含有关单个策略的信息：首先，它对应的主体是哪个，可以是用户或组；其次，哪些资源可以通过该策略进行访问。此外，可以包含一个布尔值
    `readonly` 来限制策略仅对 `list`、`get` 和 `watch` 操作有效。
- en: A secondary type of policy is associated not with a resource, but with types
    of non-resource requests, such as calls to the `/version` endpoint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一种次要类型的策略与资源无关，而是与非资源请求类型相关，例如对 `/version` 端点的调用。
- en: When a request to the API is made in ABAC mode, the API server will check the
    user and any group it is a part of against the list in the policy file, and see
    if any policies match the resource or endpoint that the user is trying to access.
    On a match, the API server will authorize the request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当在ABAC模式下向API发出请求时，API服务器会检查用户及其所属的任何组是否在策略文件中的列表中，并检查是否有策略匹配用户尝试访问的资源或端点。如果匹配，API服务器将授权该请求。
- en: You should have a good understanding now of how the Kubernetes API handles authentication
    and authorization. The good news is that while you can directly access the API,
    Kubernetes provides an excellent command-line tool to simply authenticate and
    make Kubernetes API requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对Kubernetes API如何处理身份验证和授权有了很好的理解。好消息是，尽管你可以直接访问API，但Kubernetes提供了一个出色的命令行工具，可以轻松进行身份验证并发出Kubernetes
    API请求。
- en: Using kubectl and YAML
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl和YAML
- en: kubectl is the officially supported command-line tool for accessing the Kubernetes
    API. It can be installed on Linux, macOS, or Windows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl是官方支持的用于访问Kubernetes API的命令行工具。它可以安装在Linux、macOS或Windows上。
- en: Setting up kubectl and kubeconfig
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置kubectl和kubeconfig
- en: To install the newest release of kubectl, you can use the installation instructions
    at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装kubectl的最新版本，你可以参考[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)的安装说明。
- en: 'Once kubectl is installed, it needs to be set up to authenticate with one or
    more clusters. This is done using the `kubeconfig` file, which looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了kubectl，它需要设置为与一个或多个集群进行身份验证。这是通过使用`kubeconfig`文件来完成的，格式如下：
- en: Example-kubeconfig
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例-kubeconfig
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file is written in YAML and is very similar to other Kubernetes resource
    specifications that we will get to shortly – except that this file lives only
    on your local machine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件采用YAML格式，类似于我们稍后将介绍的其他Kubernetes资源规范——不同之处在于，这个文件仅存在于你的本地机器上。
- en: 'There are three sections to a `Kubeconfig` YAML file: `clusters`, `users`,
    and `contexts`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kubeconfig` YAML文件有三个部分：`clusters`、`users`和`contexts`：'
- en: The `clusters` section is a list of clusters that you will be able to access
    via kubectl, including the CA filename and server API endpoint.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clusters`部分是你能够通过kubectl访问的集群列表，包括CA文件名和服务器API端点。'
- en: The `users` section lists users that you will be able to authorize with, including
    any user certificates or username/password combinations for authentication.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`部分列出了你可以授权的用户，包括任何用于认证的用户证书或用户名/密码组合。'
- en: Finally, the `contexts` section lists combinations of a cluster, a namespace,
    and a user that combine to make a context. Using the `kubectl config use-context`
    command, you can easily switch between contexts, which allows easy switching between
    cluster, user, and namespace combinations.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`contexts`部分列出了集群、命名空间和用户的组合，这些组合形成一个上下文。使用`kubectl config use-context`命令，你可以轻松在不同的上下文之间切换，从而实现集群、用户和命名空间组合的快速切换。
- en: Imperative versus declarative commands
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式与声明式命令
- en: 'There are two paradigms for talking to the Kubernetes API: imperative and declarative.
    Imperative commands allow you to dictate to Kubernetes "what to do" – that is,
    "spin up two copies of Ubuntu," "scale this application to five copies," and so
    on.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes API交互有两种范式：命令式和声明式。命令式命令允许你告诉Kubernetes“做什么”——例如，“启动两个Ubuntu实例”，“将此应用程序扩展为五个副本”等等。
- en: Declarative commands, on the other hand, allow you to write a file with a specification
    of what should be running on the cluster, and have the Kubernetes API ensure that
    the configuration matches the cluster configuration, updating it if necessary.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，声明式命令允许你编写一个文件，指定集群上应该运行的内容，并让Kubernetes API确保配置与集群配置匹配，并在必要时进行更新。
- en: Though imperative commands allow you to quickly get started with Kubernetes,
    it is far better to write some YAML and use a declarative configuration when running
    production workloads, or workloads of any complexity. The reason for this is that
    it makes it easier to track changes, for instance via a GitHub repo, or introduce
    Git-driven **Continous Integration/Continuous** Delivery (**CI/CD**) to your cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管命令式命令允许你快速开始使用Kubernetes，但在运行生产工作负载或任何复杂工作负载时，最好编写一些YAML文件并使用声明式配置。原因在于，这使得跟踪变更更容易，例如通过GitHub仓库，或者在集群中引入Git驱动的**持续集成/持续交付**（**CI/CD**）。
- en: Some basic kubectl commands
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本的kubectl命令
- en: kubectl provides many convenient commands for checking the current state of
    your cluster, querying resources, and creating new ones. kubectl is structured
    so most commands can access resources in the same way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl 提供了许多方便的命令，用于检查集群的当前状态、查询资源和创建新资源。kubectl 的结构设计使得大多数命令能够以相同的方式访问资源。
- en: First, let's learn how to see Kubernetes resources in your cluster. You can
    do this by using `kubectl get resource_type` where `resource_type` is the full
    name of the Kubernetes resource, or alternately, a shorter alias. A full list
    of aliases (and `kubectl` commands) can be found in the kubectl documentation
    at [https://kubernetes.io/docs/reference/kubectl/overview](https://kubernetes.io/docs/reference/kubectl/overview).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何查看集群中的 Kubernetes 资源。你可以使用 `kubectl get resource_type` 来做到这一点，其中 `resource_type`
    是 Kubernetes 资源的全名，或者使用简短的别名。完整的别名列表（以及 `kubectl` 命令）可以在 Kubernetes 文档中找到：[https://kubernetes.io/docs/reference/kubectl/overview](https://kubernetes.io/docs/reference/kubectl/overview)。
- en: We already know about nodes, so let's start with that. To find which nodes exist
    in a cluster, we can use `kubectl get nodes` or the alias `kubectl get no`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了节点，所以让我们从这个开始。要查找集群中存在的节点，我们可以使用 `kubectl get nodes` 或别名 `kubectl get
    no`。
- en: 'kubectl''s `get` commands return a list of Kubernetes resources that are currently
    in the cluster. We can run this command with any Kubernetes resource type. To
    add additional information to the list, you can add the `wide` output flag: `kubectl
    get nodes -o wide`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl 的 `get` 命令返回当前集群中 Kubernetes 资源的列表。我们可以对任何 Kubernetes 资源类型运行此命令。为了在列表中添加更多信息，你可以加上
    `wide` 输出标志：`kubectl get nodes -o wide`。
- en: Listing resources isn't enough, of course – we need to be able to see the details
    of a particular resource. For this, we use the `describe` command, which works
    similarly to `get`, except that we can optionally pass the name of a specific
    resource. If this last parameter is omitted, Kubernetes will return the details
    of all resources of that type, which will probably result in a lot of scrolling
    in your terminal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 仅列出资源当然不够——我们需要能够查看特定资源的详细信息。为此，我们使用 `describe` 命令，它与 `get` 命令类似，唯一的区别是我们可以选择性地传递特定资源的名称。如果省略此最后一个参数，Kubernetes
    将返回该类型所有资源的详细信息，这可能会导致终端输出过多信息。
- en: For example, `kubectl describe nodes` will return details for all nodes in the
    cluster, while `kubectl describe nodes node1` will return a description of the
    node named `node1`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl describe nodes` 将返回集群中所有节点的详细信息，而 `kubectl describe nodes node1`
    将返回名为 `node1` 的节点的描述。
- en: 'As you''ve probably noticed, these commands are all in the imperative style,
    which makes sense since we''re just fetching information about existing resources,
    not creating new ones. To create a Kubernetes resource, we can use the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这些命令都是以命令式风格书写的，这很合理，因为我们只是获取现有资源的信息，而不是创建新资源。要创建一个 Kubernetes 资源，我们可以使用以下命令：
- en: '`kubectl create -f /path/to/file.yaml`, which is an imperative command'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl create -f /path/to/file.yaml`，这是命令式命令'
- en: '`kubectl apply -f /path/to/file.yaml`, which is declarative'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl apply -f /path/to/file.yaml`，这是声明式的'
- en: Both commands take a path to a file, which can be either YAML or JSON – or you
    can just use `stdin`. You can also pass in the path to a folder instead of a file,
    which will create or apply all YAML or JSON files in that folder. `create` works
    imperatively, so it will create a new resource, but if you run it again with the
    same file, the command will fail since the resource already exists. `apply` works
    declaratively, so if you run it the first time it will create the resource, and
    subsequent runs will update the running resource in Kubernetes with any changes.
    You can use the `--dry-run` flag to see the output of the `create` or `apply`
    commands (that is, what resources will be created, or any errors if they exist).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令都需要一个文件路径，可以是 YAML 或 JSON 文件——或者你也可以直接使用 `stdin`。你还可以传递一个文件夹的路径，而不是文件，这样就会创建或应用该文件夹中的所有
    YAML 或 JSON 文件。`create` 是命令式的，因此它会创建一个新的资源，但如果你再次使用相同的文件运行它，命令将失败，因为资源已经存在。`apply`
    是声明式的，因此如果你第一次运行它，它会创建资源，随后的运行会更新 Kubernetes 中运行的资源，反映出任何变化。你可以使用 `--dry-run`
    标志来查看 `create` 或 `apply` 命令的输出（即，哪些资源将被创建，或者如果存在错误，会显示错误信息）。
- en: 'To update existing resources imperatively, use the `edit` command like so:
    `kubectl edit resource_type resource_name` – just like with our `describe` command.
    This will open up the default terminal editor with the YAML of the existing resource,
    regardless of whether you created it imperatively or declaratively. You can edit
    this and save as usual, which will trigger an automatic update of the resource
    in Kubernetes.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要命令式地更新现有资源，请使用 `edit` 命令，如下所示：`kubectl edit resource_type resource_name` ——
    就像我们使用 `describe` 命令一样。这将打开默认的终端编辑器，显示现有资源的 YAML，不论你是以命令式还是声明式方式创建的。你可以编辑它并像往常一样保存，这将触发
    Kubernetes 中资源的自动更新。
- en: To update existing resources declaratively, you can edit your local YAML resource
    file that you used to create the resource in the first place, then run `kubectl
    apply -f /path/to/file.yaml`. Deleting resources is best accomplished via the
    imperative command `kubectl delete resource_type resource_name`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明式地更新现有资源，你可以编辑当初用来创建资源的本地 YAML 文件，然后运行 `kubectl apply -f /path/to/file.yaml`。删除资源最好通过命令式命令
    `kubectl delete resource_type resource_name` 来完成。
- en: The last command we'll talk about in this section is `kubectl cluster-info`,
    which will show the IP addresses where the major Kubernetes cluster services are
    running.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们要讨论的最后一个命令是 `kubectl cluster-info`，它将显示主要 Kubernetes 集群服务运行的 IP 地址。
- en: Writing Kubernetes resource YAML files
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Kubernetes 资源 YAML 文件
- en: 'For communicating with the Kubernetes API declaratively, formats of both YAML
    and JSON are allowed. For the purposes of this book, we will stick to YAML since
    it is a bit cleaner and takes up less space on the page. A typical Kubernetes
    resource YAML file looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes API 进行声明性通信时，允许使用 YAML 和 JSON 格式。为了本书的目的，我们将坚持使用 YAML，因为它稍微更简洁，且占用页面空间更少。一个典型的
    Kubernetes 资源 YAML 文件如下所示：
- en: resource.yaml
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: resource.yaml
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A valid Kubernetes YAML file has four top-level keys at a minimum. They are
    `apiVersion`, `kind`, `metadata`, and `spec`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的 Kubernetes YAML 文件至少有四个顶级键。它们是 `apiVersion`、`kind`、`metadata` 和 `spec`。
- en: '`apiVersion` dictates which version of the Kubernetes API will be used to create
    the resource. `kind` specifies what type of resource the YAML file is referencing.
    `metadata` provides a location to name the resource, as well as adding annotations
    and name-spacing information (more on that later). And finally, the `spec` key
    will contain all the resource-specific information that Kubernetes needs to create
    the resource in your cluster.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion` 决定将使用哪个版本的 Kubernetes API 来创建资源。`kind` 指定 YAML 文件所引用的资源类型。`metadata`
    提供了命名资源的位置，并可以添加注解和命名空间信息（稍后会详细介绍）。最后，`spec` 键将包含 Kubernetes 创建资源所需的所有资源特定信息。'
- en: Don't worry about `kind` and `spec` quite yet – we'll get to what a `Pod` is
    in [*Chapter 3*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091), *Running Application
    Containers on Kubernetes*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不用担心 `kind` 和 `spec` —— 我们将在 [*第 3 章*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091)，*在
    Kubernetes 上运行应用容器* 中详细介绍什么是 `Pod`。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the background behind container orchestration, an
    architectural overview of a Kubernetes cluster, how a cluster authenticates and
    authorizes API calls, and how to communicate with the API via imperative and declarative
    patterns using kubectl, the officially supported command-line tool for Kubernetes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们学习了容器编排的背景，Kubernetes 集群的架构概述，集群如何验证和授权 API 调用，以及如何通过命令式和声明式模式使用 kubectl
    与 API 进行通信，kubectl 是 Kubernetes 官方支持的命令行工具。
- en: In the next chapter, we'll learn several ways to get started with a test cluster,
    and master harnessing the kubectl commands you've learned so far.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习几种启动测试集群的方法，并掌握如何利用你迄今为止学到的 kubectl 命令。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is container orchestration?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是容器编排？
- en: What are the constituent parts of the Kubernetes control plane, and what do
    they do?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 控制平面的组成部分有哪些？它们分别有什么作用？
- en: How would you start the Kubernetes API server in ABAC authorization mode?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何以 ABAC 授权模式启动 Kubernetes API 服务器？
- en: Why is it important to have more than one master node for a production Kubernetes
    cluster?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在生产 Kubernetes 集群中有多个主节点很重要？
- en: What is the difference between `kubectl apply` and `kubectl create`?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl apply` 和 `kubectl create` 有什么区别？'
- en: How would you switch between contexts using `kubectl`?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 `kubectl` 在不同上下文之间切换？
- en: What are the downsides of creating a Kubernetes resource declaratively and then
    editing it imperatively?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明式地创建 Kubernetes 资源后，再进行命令式编辑有什么缺点？
- en: Further reading
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubernetes 官方文档: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
