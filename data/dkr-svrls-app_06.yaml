- en: OpenWhisk on Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenWhisk on Docker
- en: This chapter will discuss another player in the serverless space, OpenWhisk.
    The chapter will start with an overview of the OpenWhisk platform, its design
    rationale, and features. After that, the chapter will go through the steps of
    deploying a local instance of OpenWhisk for function development, how to use its
    command-line interface, its components and architecture, and how to prepare functions
    to deploy on the platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论服务器无关平台中的另一个角色——OpenWhisk。首先将概述 OpenWhisk 平台、其设计原理和功能，之后本章将介绍如何部署本地 OpenWhisk
    实例以进行函数开发，如何使用其命令行界面，OpenWhisk 的组件和架构，以及如何准备函数以部署到该平台。
- en: What is OpenWhisk?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OpenWhisk？
- en: Donated to the Apache foundation, OpenWhisk is a robust FaaS platform originally
    developed by IBM and Adobe. Built atop Docker container technologies, OpenWhisk
    can be deployed in the cloud or on on-premises hardware. It is a platform that
    frees developers from worrying about managing the life cycle of their code or
    operations of the container runtimes that execute the code. OpenWhisk is designed
    to be scalable and to support massive numbers of function invocations. Currently,
    OpenWhisk is the engine behind IBM Cloud Functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 被捐赠给 Apache 基金会，是一个强大的 FaaS 平台，最初由 IBM 和 Adobe 开发。它建立在 Docker 容器技术之上，可以部署在云端或本地硬件上。它是一个平台，能够解放开发者，让他们无需担心代码的生命周期或执行代码的容器运行时的管理。OpenWhisk
    旨在具有可扩展性，并支持大量函数调用。目前，OpenWhisk 是 IBM Cloud Functions 的引擎。
- en: The OpenWhisk scaling mechanism is not built on top of Docker Swarm or Kubernetes
    schedulers. It plugs directly into each Docker instance to start and scale function
    containers. With this design, OpenWhisk fits better with the plain Docker infrastructure
    than Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 的扩展机制并非建立在 Docker Swarm 或 Kubernetes 调度器之上，而是直接连接到每个 Docker 实例以启动和扩展函数容器。凭借这种设计，OpenWhisk
    与普通的 Docker 基础设施相比，更适合与其结合，而不是 Kubernetes。
- en: 'For developers, OpenWhisk provides a number of compelling features via its
    high-level programming model surrounding functions. Its event triggering mechanism
    is shown in Figure 6.1:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，OpenWhisk 通过围绕函数的高级编程模型提供了许多引人注目的功能。其事件触发机制如图 6.1 所示：
- en: '![](img/f10236a1-723f-41aa-8756-1fe01f159c0e.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f10236a1-723f-41aa-8756-1fe01f159c0e.png)'
- en: 'Figure 6.1: OpenWhisk''s flow of event triggering'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：OpenWhisk 事件触发流程
- en: Similar to other platforms, OpenWhisk's smallest deployment unit is a function.
    In OpenWhisk, a function is referred to as an action. An action can be executed
    in response to an event. An event, in the form of a trigger, will be processed
    through a rule, where it selects an appropriate action to execute. After the action
    is executed, its result will be stored in the result storage before being emitted
    back to the source of the event.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他平台，OpenWhisk 的最小部署单元是一个函数。在 OpenWhisk 中，函数称为操作。操作可以响应事件进行执行。事件以触发器的形式出现，通过规则进行处理，选择适当的操作进行执行。操作执行后，其结果将存储在结果存储中，然后返回到事件的源头。
- en: OpenWhisk natively supports many language runtimes out of the box. However,
    this chapter focuses only on its Docker runtime, which allows developers to pack
    any kind of workload into a container and let OpenWhisk do the rest. An action
    in OpenWhisk can be invoked synchronously, asynchronously, or even on a schedule.
    Besides an action, OpenWhisk provides a declarative programming construct, such
    as a sequence to allow multiple actions to be chained and executed as a flow.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 原生支持许多语言运行时。然而，本章仅专注于其 Docker 运行时，允许开发者将任何类型的工作负载打包到容器中，并让 OpenWhisk
    完成剩下的工作。OpenWhisk 中的操作可以同步调用、异步调用，甚至按计划触发。除了操作，OpenWhisk 还提供了一种声明式编程构造，例如序列，允许多个操作链接起来并作为一个流程执行。
- en: Installing OpenWhisk
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenWhisk
- en: At the time of writing, the quickest way to install OpenWhisk on a local machine
    is to use Docker and Docker Compose.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，安装 OpenWhisk 在本地机器上的最快方式是使用 Docker 和 Docker Compose。
- en: 'To install Docker Compose, we can follow instructions from [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker Compose，我们可以按照 [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)
    上的说明进行操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To check the version of Docker Compose, use the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Docker Compose 的版本，请使用以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use Docker Compose 1.17.1 in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的是 Docker Compose 1.17.1。
- en: Also check if the Git is installed already. If so, now we are ready to install
    a local OpenWhisk instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要检查是否已经安装 Git。如果安装了 Git，现在我们可以准备安装本地的 OpenWhisk 实例。
- en: 'First, clone the OpenWhisk Dev tools repository from GitHub ([https://github.com/apache/incubator-openwhisk-devtools](https://github.com/apache/incubator-openwhisk-devtools))
    using the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 GitHub 克隆 OpenWhisk Dev tools 仓库（[https://github.com/apache/incubator-openwhisk-devtools](https://github.com/apache/incubator-openwhisk-devtools)），使用以下命令：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `--depth=1` tells `git` to shallow clone the repository, which means that
    only the latest revision of the Git history will be there to save time and space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`--depth=1` 告诉 `git` 浅克隆仓库，这意味着只有 Git 历史的最新版本会被下载，以节省时间和空间：'
- en: 'Next, move into the directory `incubator-openwhisk-devtools/docker-compose`.
    This directory contains `docker-compose.yml` and the required environment variables
    to start a single node OpenWhisk instance. Look for a `Makefile` there; it contains
    the `quick-start` target to provision an instance, set up the initial data, and
    invoke an example function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 `incubator-openwhisk-devtools/docker-compose` 目录。该目录包含 `docker-compose.yml`
    文件和启动单节点 OpenWhisk 实例所需的环境变量。在那里找到一个 `Makefile`，它包含 `quick-start` 目标，用于提供实例、设置初始数据并调用示例函数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The command will be doing the following.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将执行以下操作：
- en: 'First, it will download the latest source of OpenWhisk from the `master` branch
    of its GitHub repository, along with the `wsk` CLI binary. Second, it will start
    an OpenWhisk local cluster and initialize the data with the Ansible playbooks
    that came with the OpenWhisk source tree. Then it will register the `hello-world`
    function and finally invoke it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将从 GitHub 仓库的 `master` 分支下载 OpenWhisk 的最新源代码以及 `wsk` CLI 二进制文件。第二步，它将启动一个
    OpenWhisk 本地集群，并使用 OpenWhisk 源代码树中附带的 Ansible playbook 初始化数据。然后，它将注册 `hello-world`
    函数，最后调用它：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sometimes, when the process is up and running, the instance becomes flaky. Simply
    press *Ctrl* + *C* and issue the command `make run` instead of `make quick-start` to
    try to start the instance again. If you'd like to start over, simply run the `make
    destroy` command to destroy the instance. After destroying it, you can start over
    with `make quick-start`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当进程启动并运行时，实例可能会变得不稳定。只需按 *Ctrl* + *C*，然后使用 `make run` 命令代替 `make quick-start`
    再次尝试启动实例。如果您希望重新开始，只需运行 `make destroy` 命令销毁实例。销毁后，您可以使用 `make quick-start` 重新开始。
- en: 'If the output ends like this, OpenWhisk is now ready to serve at `localhost:443`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出以此结束，OpenWhisk 现在已准备好在 `localhost:443` 提供服务：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then use the `docker ps` command to double check that all OpenWhisk
    containers are running:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `docker ps` 命令再次检查所有 OpenWhisk 容器是否在运行：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the wsk client
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wsk 客户端：
- en: 'The `wsk` client will have already been installed by the `make quick-start`
    command. The `wsk` binary can be found at `openmaster/bin/wsk`. We usually copy
    the `wsk` CLI to `/usr/local/bin` and set up bash completion for it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsk` 客户端已经通过 `make quick-start` 命令安装。`wsk` 二进制文件可以在 `openmaster/bin/wsk` 找到。我们通常将
    `wsk` CLI 复制到 `/usr/local/bin` 并为其设置 Bash 自动补全：'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first sub-command introduced here is `wsk property get`. It is to display
    OpenWhisk information, including the current namespace, the authentication key,
    and the build number. For example, we use `-i` or `--insecure` for insecurely
    connecting to the OpenWhisk instance as the generated certificate is self-signed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的第一个子命令是`wsk property get`。它用于显示 OpenWhisk 的信息，包括当前的命名空间、认证密钥和构建号。例如，我们使用`-i`或`--insecure`选项不安全地连接到
    OpenWhisk 实例，因为生成的证书是自签名的：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What does the information tell us? We are currently at the guest `namespace`
    using API version 1 and the long string, starting with `23bc`, is our API key
    for authentication. Any OpenWhisk client, including the `wsk` itself, needs this
    key to connect to the OpenWhisk instance. Our current API gateway is at `localhost:443`,
    which will forward all requests to the underlying controllers. The overview of
    each OpenWhisk component and the architecture will be discussed in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息告诉我们什么？我们当前位于访客 `namespace`，使用的是 API 版本 1，且以 `23bc` 开头的长字符串是我们的 API 密钥用于认证。任何
    OpenWhisk 客户端，包括 `wsk` 本身，都需要这个密钥才能连接到 OpenWhisk 实例。我们当前的 API 网关位于 `localhost:443`，它将把所有请求转发给底层控制器。每个
    OpenWhisk 组件的概述和架构将在下一节中讨论：
- en: Components and architecture
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件与架构：
- en: In this section, we discuss the architecture and components of OpenWhisk. OpenWhisk
    is designed to be a rock-solid FaaS platform as it is powering IBM Cloud Function,
    one of the FaaS production systems already launched by IBM. The key of this rock-solid
    architecture is Kafka. OpenWhisk cleverly uses Kafka as its backbone to guarantee
    that every single function request accepted by Kafka will be delivered to the
    invoker layer. Let's start by looking its overall architecture.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论 OpenWhisk 的架构和组件。OpenWhisk 被设计为一个坚如磐石的 FaaS 平台，它为 IBM Cloud Function
    提供支持，IBM Cloud Function 是 IBM 已经推出的 FaaS 生产系统之一。这个坚如磐石的架构的关键是 Kafka。OpenWhisk
    巧妙地使用 Kafka 作为其主干，保证 Kafka 接受的每一个函数请求都会传递到调用层。让我们从查看它的整体架构开始。
- en: Architecture
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'The following diagram in *Figure 6.2* shows the overall architecture of OpenWhisk:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下图 *图 6.2* 显示了 OpenWhisk 的整体架构：
- en: '![](img/c783eee1-e45d-4c01-9f39-ac503a26052d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c783eee1-e45d-4c01-9f39-ac503a26052d.png)'
- en: 'Figure 6.2: The overview architecture of OpenWhisk.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：OpenWhisk 的整体架构。
- en: The edge component is the API gateway built on top of NGINX and OpenResty. The
    API gateway optionally uses Redis for caching. The API gateway sits in front of
    one or more controllers. The controller stores all configuration in a CouchDB
    cluster. Behind the controller, there is a Kafka cluster coordinated by a ZooKeeper
    quorum. The Kafka cluster is very important; every invocation is guaranteed to
    be executed. Kafka acts as a resilient buffer between controllers and invokers.
    Each invoker is responsible for invoking real implementations of functions, in
    this case Docker containers. Therefore, an invoker requires a special privilege
    to connect to the host's Docker socket. An invoker is optionally able to use `docker-runc`
    to improve the performance of the invocation process. Every single component of
    OpenWhisk is able to run inside a container, such as when we deployed it with
    Docker Compose.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘组件是基于 NGINX 和 OpenResty 构建的 API 网关。API 网关可选择使用 Redis 进行缓存。API 网关位于一个或多个控制器之前。控制器将所有配置存储在
    CouchDB 集群中。控制器背后是一个由 ZooKeeper 法定节点协调的 Kafka 集群。Kafka 集群非常重要；每一个调用都能得到保证执行。Kafka
    作为控制器和调用者之间的一个弹性缓冲区。每个调用者负责调用函数的真实实现，在本例中是 Docker 容器。因此，调用者需要特殊权限才能连接到主机的 Docker
    套接字。调用者可选择使用 `docker-runc` 来提升调用过程的性能。OpenWhisk 的每个组件都能够在容器内运行，比如我们通过 Docker Compose
    部署时的情况。
- en: Components
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Now we will proceed to the details of each component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进入每个组件的详细信息。
- en: API gateway
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 网关
- en: The API gateway component of OpenWhisk is built atop NGINX and OpenResty technologies.
    The main reason NGINX is chosen is because it provides high performance as the
    edge component of the platform. NGINX sits in front of every other component in
    the system. The API gateway is capable of caching the request with OpenResty talking
    to a Redis cluster on its side. However, Redis is an optional component. It can
    easily be disabled by removing it from the Docker Compose configuration. The API
    gateway is also responsible for severing the secured HTTPS protocol from users.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 的 API 网关组件建立在 NGINX 和 OpenResty 技术之上。选择 NGINX 的主要原因是它作为平台的边缘组件提供高性能。NGINX
    位于系统中所有其他组件之前。API 网关能够通过 OpenResty 与 Redis 集群进行通信来缓存请求。然而，Redis 是一个可选组件，可以通过从
    Docker Compose 配置中移除它来轻松禁用。API 网关还负责从用户处提供安全的 HTTPS 协议。
- en: The current version of the API gateway is `adobeapiplatform/apigateway:1.1.0`.
    It is the version of the API gateway under joint development by Adobe and IBM.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的 API 网关是 `adobeapiplatform/apigateway:1.1.0`。这是 Adobe 和 IBM 联合开发的 API 网关版本。
- en: Controller
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: A controller is one of the most important components of OpenWhisk. As the name
    implies, it mainly controls the invocation process of the cluster. Controllers
    can work without having the API gateway in front of them. A controller serves
    the HTTP protocol directly, in an insecure form, as the HTTPS part is the function
    of the API gateway. Basically, a controller source is a part of the OpenWhisk
    project. The configuration used in this chapter is the latest Docker image published
    by OpenWhisk.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是 OpenWhisk 中最重要的组件之一。顾名思义，它主要控制集群的调用过程。控制器可以在没有 API 网关的情况下工作。控制器直接提供 HTTP
    协议，在不安全的形式下进行通信，因为 HTTPS 部分是 API 网关的功能。基本上，控制器源代码是 OpenWhisk 项目的一部分。本章使用的配置是 OpenWhisk
    发布的最新 Docker 镜像。
- en: Database
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: The storage component of OpenWhisk is CouchDB. CouchDB is highly available,
    document-based data storage. The controller talks to CouchDB to store every entity
    related to the function invocation. The most important entity stored in CouchDB
    is the activation data. The activation data contains information of each invocation
    process. The progress of actions and their results are stored in the form of *activation
    documents*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 的存储组件是 CouchDB。CouchDB 是一种高度可用的文档型数据存储。控制器与 CouchDB 通信，以存储与函数调用相关的所有实体。存储在
    CouchDB 中的最重要实体是激活数据。激活数据包含每次调用过程的信息。操作的进展及其结果以 *激活文档* 形式存储。
- en: The official CouchDB version 1.6, `couchdb:1.6`, is used in the current configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当前配置中使用的是官方的 CouchDB 版本 1.6，`couchdb:1.6`。
- en: Kafka
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kafka
- en: Kafka plays a very important role in the system. By nature, Kafka is a message
    broker that stores every received message and replays them reliably. With Kafka
    as the backbone, requests for action invocation will be reliably delivered to
    the invokers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka 在系统中扮演着非常重要的角色。从本质上讲，Kafka 是一个消息代理，它存储每个接收到的消息并可靠地重放它们。以 Kafka 为骨干，操作调用的请求将可靠地传递给调用者。
- en: Kafka is formed as a cluster using the ZooKeeper quorum. Kafka is running on
    port `9092` within the default network. We use the `wurstmeister/kafka:0.11.0.1`
    image for the configuration in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka 通过使用 ZooKeeper 集群来组成。Kafka 在默认网络中的 `9092` 端口上运行。在本章的配置中，我们使用 `wurstmeister/kafka:0.11.0.1`
    镜像。
- en: Invoker
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用者
- en: The invoker is the component that is responsible for receiving invocation requests
    from Kafka topics, message queues that consumers could subscribe to receive messages.
    After receiving the messages, the invoker executes the functions using a backend
    runtime. OpenWhisk supports both native and Docker runtimes. The Docker runtime
    is internally called **blackbox**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者是负责接收来自 Kafka 主题的调用请求的组件，消息队列消费者可以订阅这些主题以接收消息。接收到消息后，调用者使用后台运行时执行函数。OpenWhisk
    支持本地和 Docker 运行时。Docker 运行时在内部被称为 **blackbox**。
- en: OpenWhisk also has an option to use Docker's `runc` directly to improve the
    function performance. With this architecture, the invoker requires access to `/var/run/docker.sock`
    of the local Docker host. This limitation prevents OpenWhisk from scaling efficiently
    in Swarm mode. We will discuss the new architecture for OpenWhisk over Swarm in
    a later chapter, when we discuss the deployment of OpenWhisk in a production environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 还可以选择直接使用 Docker 的 `runc` 来提高函数性能。在这种架构下，调用者需要访问本地 Docker 主机的 `/var/run/docker.sock`。这个限制阻止了
    OpenWhisk 在 Swarm 模式下的高效扩展。我们将在后续章节讨论 OpenWhisk 在 Swarm 上的新架构，届时我们将讨论 OpenWhisk
    在生产环境中的部署。
- en: Action runtime
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作运行时
- en: There are several kinds of runtime provided by OpenWhisk. Java, Node.js, and
    Python are native runtimes, for example. As previously mentioned, the Docker runtime
    is called blackbox.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 提供了几种运行时环境。例如，Java、Node.js 和 Python 是本地运行时。正如前面提到的，Docker 运行时被称为 blackbox。
- en: The runtime takes the Docker image registered by the process of action creation.
    Then it starts the Docker container to accept the request. The runtime can keep
    the container running so subsequent calls can be significantly faster.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时会使用在操作创建过程中注册的 Docker 镜像。然后它启动 Docker 容器以接受请求。运行时可以保持容器持续运行，从而使后续调用显著更快。
- en: Function preparation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数准备
- en: In this section, we discuss how to prepare a function using the Docker template
    called **Docker skeleton**, provided by OpenWhisk.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们讨论如何使用 OpenWhisk 提供的 Docker 模板 **Docker skeleton** 来准备一个函数。
- en: OpenWhisk Docker SDK
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenWhisk Docker SDK
- en: 'To install the Docker skeleton, normally we would do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker 模板，通常我们需要执行以下操作：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But if the file does not exist on your local OpenWhisk, you can download it
    directly from [https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz](https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件在本地 OpenWhisk 中不存在，你可以直接从 [https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz](https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz)
    下载。
- en: 'The following steps are to download SDK, extract the SDK, change its directory
    from `dockerSkeleton` to `docker_c`, and change into the `docker_c` directory
    to check its contents:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是下载 SDK，解压 SDK，切换目录从 `dockerSkeleton` 到 `docker_c`，然后进入 `docker_c` 目录查看其内容：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The skeleton contains a Dockerfile, a simple C program, a bash script for building
    and pushing the finished function to Docker's Hub, and a `README.md` file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架包含一个 Dockerfile，一个简单的 C 程序，一个用于构建并将完成的功能推送到 Docker Hub 的 Bash 脚本，以及一个 `README.md`
    文件。
- en: 'We start with the content of the C program to see what it is for. The C program
    that came with the Docker skeleton SDK contains only the `main` function with
    a couple of `printf` statements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 C 程序的内容开始，看看它的作用。附带的 Docker 骨架 SDK 中的 C 程序只包含一个 `main` 函数，并有几个 `printf`
    语句：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last `printf` line tells us the whole story of OpenWhisk's action. This
    action returns JSON data by printing it out to STDOUT. The action accepts arguments,
    also in the form of JSON, through the main function's `argv`. It is the action's
    responsibility to decode the arguments and encode the output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行 `printf` 向我们讲述了 OpenWhisk action 的整个故事。这个 action 通过将 JSON 数据打印到 STDOUT
    返回数据。该 action 通过 `main` 函数的 `argv` 接受参数，参数形式也是 JSON。action 需要负责解码这些参数并将输出编码回来。
- en: Next, we'll take a look at its `Dockerfile`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看它的 `Dockerfile`。
- en: The file starts by declaring `openwhisk/dockerskeleton` as the base image. In
    the next line, the environment variable `FLASK_PROXY_PORT` is defined as `8080`.
    You may guess here that the framework used as the wrapper of every Docker function
    is `Flask`, a Python web framework.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件首先声明 `openwhisk/dockerskeleton` 作为基础镜像。在下一行，环境变量 `FLASK_PROXY_PORT` 被定义为
    `8080`。你可能会猜到，这里作为每个 Docker 函数包装器的框架是 `Flask`，一个 Python Web 框架。
- en: Moving to the next two lines, they add the C program into the building container,
    install the GCC compiler, and then compile the program. The output binary is named
    `exec`. It must be placed at `/action/exec`. This is the mandatory location of
    the executable needed by OpenWhisk's `actionproxy`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行将 C 程序添加到构建容器中，安装 GCC 编译器，然后编译程序。输出的二进制文件名为 `exec`，必须放置在 `/action/exec`。这是
    OpenWhisk 的 `actionproxy` 所需的执行文件的必需位置。
- en: 'What is `actionproxy`? It is the OpenWhisk version of a function wrapping server.
    The server accepts a web request through its exposed port, `8080`. As mentioned
    earlier, it is written in Python with the Flask framework, so every OpenWhisk
    function requires Python and Flask dependencies in order to start the `actionproxy`.
    This kind of setup is already there by inheriting from the base image, `openwhisk/dockerskeleton`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `actionproxy`？它是 OpenWhisk 版本的函数包装服务器。该服务器通过其暴露的端口 `8080` 接受 Web 请求。如前所述，它是用
    Python 和 Flask 框架编写的，因此每个 OpenWhisk 函数都需要 Python 和 Flask 依赖项才能启动 `actionproxy`。这种设置已经通过继承基础镜像
    `openwhisk/dockerskeleton` 完成：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead of using the provided script, we will build it ourselves using the
    `docker build` command. Please recall that you need to use your own `<DOCKER ID>`
    as the repository name to allow you to push the built image onto Docker Hub:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不使用提供的脚本，而是使用 `docker build` 命令自己构建。请记住，你需要使用自己的 `<DOCKER ID>` 作为仓库名称，以便将构建的镜像推送到
    Docker Hub：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If everything was done correctly, don't forget to use the `docker push` command
    to store this image on the Hub.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，别忘了使用 `docker push` 命令将这个镜像存储到 Hub 上。
- en: Preparing a Go function
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Go 函数
- en: Next, we will write a function using the Go programming language to show you
    how to decode JSON parameters using the Go built-in library. Of course, we will
    modify OpenWhisk's Docker skeleton by adding Go compilers and use a multi-stage
    build to optimize the build process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Go 编程语言编写一个函数，向你展示如何使用 Go 内置库解码 JSON 参数。当然，我们将通过添加 Go 编译器来修改 OpenWhisk
    的 Docker 骨架，并使用多阶段构建来优化构建过程。
- en: Let's start over.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始。
- en: 'We''ll untar the Docker skeleton again, and this time we rename the `dockerSkeleton`
    directory `docker_go`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次解压 Docker 骨架，这次我们将 `dockerSkeleton` 目录重命名为 `docker_go`：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `docker_go` directory, we will write a Go program to decode the
    JSON `params` of the action, rearrange them, encode them back to JSON, and write
    them to the caller:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker_go` 目录下，我们将编写一个 Go 程序，用于解码 action 的 JSON `params`，重新排列它们，重新编码为 JSON，然后写入调用者：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We save this program as `main.go` before continuing to the next step, writing
    our Dockerfile for multi-stage builds to compile the Go program, and pack it as
    an OpenWhisk action. Here''s the new version of `Dockerfile`. Its first build
    stage is to compile the Go program using Go 1.9.2\. Please note that we compile
    it into a statically linked binary so that it can run independently inside the
    OpenWhisk base image. In the second build stage, we copy the binary `/go/src/app/main`
    from the first stage as `/action/exec`, the binary location required for OpenWhisk
    `actionproxy` to execute:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行下一步之前，我们将此程序保存为`main.go`，然后编写用于多阶段构建的 Dockerfile 来编译 Go 程序，并将其打包为 OpenWhisk
    动作。下面是新的`Dockerfile`版本。它的第一阶段是使用 Go 1.9.2 编译 Go 程序。请注意，我们将其编译为静态链接的二进制文件，以便它可以在
    OpenWhisk 基础镜像内独立运行。在第二阶段构建中，我们将从第一阶段复制二进制文件`/go/src/app/main`到`/action/exec`，这是
    OpenWhisk `actionproxy` 执行所需的二进制文件位置：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now the `Dockerfile` is ready. Let''s build it using the `docker build` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Dockerfile`已经准备好了。让我们使用`docker build`命令来构建它：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The action image is now ready as `chanwit/whisk_go`. Again, please use your
    Docker Hub's ID, not mine, as the image repository and don't forget to push it
    to the Hub.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 动作镜像现在已经准备好，名称为`chanwit/whisk_go`。请再次使用你自己的 Docker Hub ID，而不是我的，作为镜像仓库，并且不要忘记将其推送到
    Hub。
- en: Invoking functions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: This section describes the internal flow of how OpenWhisk invokes its actions.
    We will learn how to create (or register) a Docker container as an OpenWhisk action
    and how to invoke it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 OpenWhisk 如何调用其动作的内部流程。我们将学习如何创建（或注册）一个 Docker 容器作为 OpenWhisk 动作，并如何调用它。
- en: Invocation flows
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用流程
- en: As OpenWhisk is an event-driven platform, any kind of event fired to it could
    be intercepted and interpreted. However, in this example, we will show you only
    the event triggered by sending a direct request to the gateway.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenWhisk 是一个事件驱动的平台，任何传递到它的事件都可以被拦截和解释。然而，在本示例中，我们只展示通过直接请求网关触发的事件。
- en: The invocation flow starts with an invocation request in the form of an HTTP-based
    request and is sent to the API gateway. For example, we can use the wsk CLI to
    initiate this kind of request. After the API gateway receives the request, it
    will forward that call to a controller behind it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调用流程以基于 HTTP 的请求开始，并发送到 API 网关。例如，我们可以使用 wsk CLI 发起这种请求。在 API 网关收到请求后，它会将该请求转发给背后的控制器。
- en: One of the most important components of OpenWhisk is the controller. The controller
    is a component written in Scala using the infamous framework Akka and Spray to
    implement a set of REST APIs. The controller accepts all kinds of requests; if
    it accepts a POST request, it will interpret it as an invocation of an OpenWhisk
    action.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk 最重要的组件之一是控制器。控制器是用 Scala 编写的，并使用臭名昭著的框架 Akka 和 Spray 来实现一组 REST API。控制器接受各种请求；如果它接受一个
    POST 请求，它会将其解释为一个 OpenWhisk 动作的调用。
- en: The controller then starts to authenticate and authorize the access of the requested
    action.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后控制器开始对请求的动作进行身份验证和授权。
- en: The controller will look up the credential information and verify it against
    the data stored in an instance of CouchDB.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器将查找凭据信息并根据存储在 CouchDB 实例中的数据进行验证。
- en: If the action is not found, the controller simply returns 404 back to the caller,
    for example. Also, if access is denied after verification of the credentials,
    the controller will send a chunk of JSON back to the caller saying that they are
    not allowed to access the action.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到动作，控制器会直接返回 404 给调用者，例如。如果在验证凭据后拒绝访问，控制器将返回一段 JSON 给调用者，表示他们没有权限访问该动作。
- en: If everything is granted, the controller goes to the next step.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都被授权，控制器将进入下一步。
- en: 'The controller then again looks up the information about the action: what it
    is, what kind it is, and how to invoke it.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后控制器再次查找有关动作的信息：它是什么，属于什么类型，如何调用它。
- en: In our case, we use Docker as an action primitive. So, the controller will find
    that our action is a blackbox. Now it's ready to invoke the action.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用 Docker 作为动作原语。所以，控制器会发现我们的动作是一个黑盒子。现在它准备好调用该动作了。
- en: The controller will not make a request to an invoker directly; instead, it will
    make a request to a Kafka cluster, the backbone of the messaging system. As previously
    mentioned, using Kafka could prevent the loss of the invocation, as well as make
    the system robust by queuing the invocation when the system is busy under heavy
    load.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器不会直接向调用者发起请求；相反，它会向 Kafka 集群发起请求，Kafka 是消息系统的骨干。如前所述，使用 Kafka 可以防止调用丢失，并通过在系统负载过重时排队调用，使系统更加健壮。
- en: So the controller publishes a message to Kafka. The request message contains
    all information needed to invoke an action. This message is also persisted by
    Kafka so that it can be replayed when the system crashes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以控制器向 Kafka 发布一条消息。请求消息包含调用操作所需的所有信息。这条消息也会被 Kafka 持久化，以便在系统崩溃时能够重放。
- en: Once Kafka gets the message, the controller is responded to with an activation
    ID to later obtain the result of invocation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Kafka 收到消息，控制器将返回一个激活 ID，供稍后获取调用结果使用。
- en: On the other side of Kafka, a set of invokers subscribe to the requested messages.
    Once a message is available in the queue, an invoker will be notified. Then the
    invoker will do the real job, invoking the real Docker container. After it gets
    the results, the invoker stores them in the instance of CouchDB under the same
    activation ID.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kafka 的另一端，一组调用者订阅请求消息。一旦消息在队列中可用，调用者会收到通知。然后调用者会执行实际的工作，调用真正的 Docker 容器。在获得结果后，调用者会将它们存储在同一激活
    ID 下的 CouchDB 实例中。
- en: Action invoke
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作调用
- en: 'OK, now we are ready to try out both newly created C and Go functions built
    in the previous sections. First, we will create an action using the `wsk action
    create` command starting with the C program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们准备好尝试之前部分章节中新创建的 C 和 Go 函数了。首先，我们将使用 `wsk action create` 命令创建一个操作，开始使用
    C 程序：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If things go correctly, `wsk` will tell us `ok: created action`. Next, we will
    invoke the action using the `wsk action invoke` command. The `invoke` command
    accepts one or more `--param` to pass parameters to the action. We can also pass
    `--result` to obtain the result synchronously. The result is, of course returned
    as JSON:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一切顺利，`wsk` 会告诉我们 `ok: created action`。接下来，我们将使用 `wsk action invoke` 命令来调用该操作。`invoke`
    命令接受一个或多个 `--param` 参数来传递给操作。我们还可以使用 `--result` 来同步获取结果。结果当然是以 JSON 格式返回的：'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will try once more, this time with the Go program. First, create the action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再试一次，这次使用 Go 程序。首先，创建操作：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, invoke the action using `wsk action invoke`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `wsk action invoke` 调用该操作：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we have seen, we pack actions with Docker and it basically simplifies the
    whole process, starting with action preparation, creation, and invocation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们将操作打包到 Docker 中，这基本上简化了整个过程，从操作准备、创建到调用。
- en: Obtaining activation results
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取激活结果
- en: 'Each time an action is invoked, OpenWhisk creates an activation record for
    it. To see the activation record, we may invoke an action without the `--result`
    parameter, for example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用操作时，OpenWhisk 都会为其创建一个激活记录。要查看激活记录，我们可以在没有 `--result` 参数的情况下调用一个操作，例如：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The ID `6ba2c0fd6f4348b8a2c0fd6f4388b864` is called an activation ID. We can
    now obtain the activation record using the `wsk activation get` command. Putting
    a field name after the activation ID will filter it to display only that field.
    The following example shows only the field `response` of the activation record
    `6ba2c0`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`6ba2c0fd6f4348b8a2c0fd6f4388b864` 这个 ID 被称为激活 ID。我们现在可以使用 `wsk activation
    get` 命令获取激活记录。在激活 ID 后加上字段名称将对结果进行过滤，仅显示该字段。以下示例仅显示激活记录 `6ba2c0` 的 `response`
    字段：'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the activation record, the JSON result is placed under the `result` key.
    You may observe that all the data is correctly serialized to JSON and recorded
    there.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活记录中，JSON 结果被放置在 `result` 键下。你可以观察到所有数据都正确地序列化为 JSON 并记录在其中。
- en: User interface
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面
- en: There is no open source portal for OpenWhisk at the time of writing. To make
    it easier for developers to use OpenWhisk, I'm developing a UI portal for it.
    SuraWhisk is an open source project hosted on GitHub. Its source can be found
    at [https://github.com/surawhisk/ui](https://github.com/surawhisk/ui). If you
    do not want to look at the source code, you can just start the UI from a ready-to-use
    Docker image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时，OpenWhisk 没有公开的开源门户。为了让开发者更方便使用 OpenWhisk，我正在开发一个 UI 门户。SuraWhisk 是一个开源项目，托管在
    GitHub 上。其源代码可以在 [https://github.com/surawhisk/ui](https://github.com/surawhisk/ui)
    找到。如果你不想查看源代码，可以直接从现成的 Docker 镜像启动 UI。
- en: 'First, create a volume to store the settings data. Endpoints and their API
    keys for authentication will be stored there in the volume:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个卷来存储设置数据。端点及其 API 密钥将存储在该卷中，用于身份验证：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then the UI can be run using the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用以下命令运行 UI：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After SuraWhisk UI starts, point the browser to `http://localhost:8080`. The
    UI''s navigation bar on the left-hand side currently contains three basic items:
    settings, actions, and namespaces.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 SuraWhisk UI 后，将浏览器指向`http://localhost:8080`。UI 的左侧导航栏当前包含三个基本项目：设置、操作和命名空间。
- en: 'The Settings page, as shown in *Figure 6.3*, is for setting up an OpenWhisk
    endpoint and its API key. The SuraWhisk container is running on a bridge network;
    therefore, it can access the OpenWhisk''s API gateway via the Docker''s gateway
    bridge IP, `172.17.0.1`. That is, the endpoint to our local OpenWhisk''s instance
    will be `https://172.17.0.1/api/v1`. The API key for the current guest namespace
    can be obtained by running the `wsk` CLI with the following command. If the bridge
    IP is not working, you may try the local IP of the local machine, as the OpenWhisk''s
    API gateway is exposed over the machine''s IP as well:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置页面，如*图 6.3*所示，用于设置 OpenWhisk 端点及其 API 密钥。SuraWhisk 容器在桥接网络上运行；因此，它可以通过 Docker
    的网关桥接 IP `172.17.0.1` 访问 OpenWhisk 的 API 网关。也就是说，我们本地 OpenWhisk 实例的端点将是`https://172.17.0.1/api/v1`。可以通过运行以下命令的
    `wsk` CLI 获取当前访客命名空间的 API 密钥。如果桥接 IP 无法使用，可以尝试本地机器的 IP，因为 OpenWhisk 的 API 网关也通过机器的
    IP 公开：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of the command provides a long string saying that it is a `whisk
    auth`. Copy and paste the whole string, `23b...IwP`, into the API Key textbox
    of the Settings page, and click the Save button:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果提供了一个长字符串，表示它是一个`whisk auth`。将整个字符串`23b...IwP`复制并粘贴到设置页面的 API 密钥文本框中，然后点击保存按钮：
- en: '![](img/75d7fbc7-5239-4f73-a0c5-60fc73b2e420.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75d7fbc7-5239-4f73-a0c5-60fc73b2e420.png)'
- en: 'Figure 6.3: The Settings screen of SuraWhisk for specifying the Endpoint and
    API Key'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：SuraWhisk 的设置屏幕，用于指定端点和 API 密钥
- en: Now the SuraWhisk Portal will be able to communicate with the OpenWhisk instance.
    We will proceed to the step of defining a new function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SuraWhisk 门户将能够与 OpenWhisk 实例通信。我们将进入定义新函数的步骤。
- en: 'A function, an action in OpenWhisk, can be defined on the Actions/Create page,
    as in *Figure 6.4*. The Docker image built earlier in this chapter will be used
    here. In the following example, we create a function named `hello` as a Docker
    container, whose image is `chanwit/whisk_c`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作/创建页面（如*图 6.4*所示），可以定义一个函数，作为 OpenWhisk 中的操作。这里将使用本章前面构建的 Docker 镜像。在以下示例中，我们创建一个名为
    `hello` 的函数，作为一个 Docker 容器，其镜像为 `chanwit/whisk_c`：
- en: '![](img/be85fc16-34ac-471b-9443-d8773018f01f.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be85fc16-34ac-471b-9443-d8773018f01f.png)'
- en: 'Figure 6.4: The Action Creation screen which allows us to define a new action
    in OpenWhisk'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：操作创建屏幕，允许我们在 OpenWhisk 中定义一个新操作
- en: When everything is ready, click the Create button. The portal will connect to
    the OpenWhisk instance and request creation of a new action. The Docker image
    is not pulled during this stage, so the step will be finished quickly. If the
    `hello` action is created successfully, dialog will pop up, as in Figure 6.5.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切准备就绪时，点击创建按钮。门户将连接到 OpenWhisk 实例并请求创建一个新操作。在这个阶段不会拉取 Docker 镜像，因此此步骤会迅速完成。如果
    `hello` 操作创建成功，将会弹出对话框，如图 6.5 所示。
- en: '![](img/89cee774-b1d3-4241-8f2f-8db3cf5936aa.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89cee774-b1d3-4241-8f2f-8db3cf5936aa.png)'
- en: 'Figure 6.5: Dialog showing that an action was successfully created'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：对话框显示操作已成功创建
- en: 'To invoke the action, go to the menu Actions/Invoke on the left-hand side navigation
    bar, as in *Figure 6.6*. All actions in the current namespace will be listed in
    the Action combo box. Each invocation accepts key/value pairs as the action''s
    parameters. They can be added by clicking the Add button. In the following example,
    the `book` parameter is set to contain the value `serverless`. A parameter can
    be removed at any time by clicking the Remove button of each pair. These parameters
    will be encoded into JSON before being passed to the action:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用操作，请转到左侧导航栏的菜单 Actions/Invoke，如*图 6.6*所示。当前命名空间中的所有操作将列出在操作下拉框中。每个调用都接受作为操作参数的键/值对。可以通过点击添加按钮添加它们。在以下示例中，`book`
    参数设置为包含值 `serverless`。可以通过点击每个键值对的删除按钮随时删除一个参数。这些参数将在传递给操作之前被编码为 JSON：
- en: '![](img/a143defb-24f0-4456-8f78-0b5555578352.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a143defb-24f0-4456-8f78-0b5555578352.png)'
- en: 'Figure 6.6: The Invoke Action screen in SuraWhisk showing the result'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：SuraWhisk 中的调用操作屏幕，显示结果
- en: After selecting the action to be invoked, clicking the invoke button will start
    the invocation process. In the previous example, the `hello` action is in the
    form of a Docker container.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要调用的动作后，点击调用按钮将启动调用过程。在前面的示例中，`hello`动作是以Docker容器的形式存在的。
- en: Exercises
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are more questions to help you review the contents of this chapter:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些帮助你复习本章内容的问题：
- en: What are the strengths of OpenWhisk?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenWhisk有哪些优势？
- en: Please describe OpenWhisk's architecture.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请描述OpenWhisk的架构。
- en: What is the role of the OpenWhisk controller?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenWhisk控制器的作用是什么？
- en: What is the role of Kafka? Why is it important for OpenWhisk?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kafka的作用是什么？它为什么对OpenWhisk很重要？
- en: What is an invoker?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是调用器？
- en: Is there any reason why the controller and invoker are not connected directly?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么控制器和调用器没有直接连接？
- en: How could we define and invoke an action on the OpenWhisk platform?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在OpenWhisk平台上定义并调用一个动作？
- en: How could we improve the performance of the invoker?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何提高调用器的性能？
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced OpenWhisk, especially when we utilized Docker as parts
    of its ecosystem. OpenWhisk is a fully featured, fault-tolerant, and polyglot
    serverless platform that allows you to virtually run functions written in any
    language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了OpenWhisk，特别是我们如何使用Docker作为其生态系统的一部分。OpenWhisk是一个功能完备、容错性强、支持多种语言的无服务器平台，允许你以任何语言编写的函数在虚拟环境中运行。
- en: This chapter walked through its components and architecture, and discussed how
    to use the `wsk` CLI to prepare, create, and invoke OpenWhisk functions. This
    chapter also introduced SuraWhisk, a web UI for OpenWhisk to help us manage and
    invoke OpenWhisk's actions more easily.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了OpenWhisk的组件和架构，并讨论了如何使用`wsk`命令行工具准备、创建和调用OpenWhisk函数。本章还介绍了SuraWhisk，一个OpenWhisk的Web界面，帮助我们更轻松地管理和调用OpenWhisk的动作。
- en: We have learned all about three major FaaS platforms. In the next chapter, we
    will discuss how to prepare and operate a Docker cluster to provision and administrate
    FaaS platforms on it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了三大FaaS平台的相关内容。在下一章，我们将讨论如何准备和操作Docker集群，以便在其上配置和管理FaaS平台。
