- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What Are Containers and Why Should I Use Them?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器，为什么我应该使用它们？
- en: This first chapter will introduce you to the world of containers and their orchestration.
    This book starts from the very beginning, in that it assumes that you have limited
    prior knowledge of containers, and will give you a very practical introduction
    to the topic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你进入容器及其编排的世界。本书从最基础的地方开始，假设你对容器的了解有限，因此将为你提供一个非常实用的介绍。
- en: In this chapter, we will focus on the software supply chain and the friction
    within it. Then, we’ll present containers, which are used to reduce this friction
    and add enterprise-grade security on top of it. We’ll also look into how containers
    and the ecosystem around them are assembled. We’ll specifically point out the
    distinctions between the upstream **Open Source Software** (**OSS**) components,
    united under the code name Moby, that form the building blocks of the downstream
    products of Docker and other vendors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讨论软件供应链及其内部的摩擦。接着，我们将介绍容器，它们用于减少这些摩擦，并在此基础上增加企业级安全性。我们还将探讨容器及其周围生态系统是如何组装的。我们将特别指出，作为
    Docker 和其他供应商下游产品构建块的上游 **开源软件** (**OSS**) 组件，这些组件统一在代号 Moby 下。
- en: 'The chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: What are containers?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Why are containers important?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么容器很重要？
- en: What’s the benefit of using containers for me or for my company?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器对我或我的公司有什么好处？
- en: The Moby project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moby 项目
- en: Docker products
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 产品
- en: Container architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器架构
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做到以下几点：
- en: Explain what containers are, using an analogy such as physical containers, in
    a few simple sentences to an interested layperson
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类比，例如物理容器，用简短的几句话向感兴趣的外行解释容器是什么
- en: Justify why containers are so important using an analogy such as physical containers
    versus traditional shipping, or apartment homes versus single-family homes, and
    so on, to an interested layperson
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类比，例如物理容器与传统运输、或者公寓与独栋住宅等，向感兴趣的外行解释为什么容器如此重要
- en: Name at least four upstream open source components that are used by Docker products,
    such as Docker Desktop
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少列举出 Docker 产品（如 Docker Desktop）使用的四个上游开源组件
- en: Draw a high-level sketch of the Docker container architecture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个 Docker 容器架构的高级草图
- en: Let’s get started!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: What are containers?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: A software container is a pretty abstract thing, so it might help to start with
    an analogy that should be pretty familiar to most of you. The analogy is a shipping
    container in the transportation industry. Throughout history, people have transported
    goods from one location to another by various means. Before the invention of the
    wheel, goods would most probably have been transported in bags, baskets, or chests
    on the shoulders of humans themselves, or they might have used animals such as
    donkeys, camels, or elephants to transport them. With the invention of the wheel,
    transportation became a bit more efficient as humans built roads that they could
    move their carts along. Many more goods could be transported at a time. When the
    first steam-driven machines, and later gasoline-driven engines, were introduced,
    transportation became even more powerful. We now transport huge amounts of goods
    on planes, trains, ships, and trucks. At the same time, the types of goods became
    more and more diverse, and sometimes complex to handle. In all these thousands
    of years, one thing hasn’t changed, and that is the necessity to unload goods
    at a target location and maybe load them onto another means of transportation.
    Take, for example, a farmer bringing a cart full of apples to a central train
    station where the apples are then loaded onto a train, together with all the apples
    from many other farmers. Or think of a winemaker bringing their barrels of wine
    on a truck to the port where they are unloaded, and then transferred to a ship
    that will transport those barrels overseas.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 软件容器是一个相当抽象的概念，因此从一个大多数人都很熟悉的类比开始可能会有所帮助。这个类比来自运输行业的集装箱。历史上，人们曾通过各种方式将货物从一个地方运送到另一个地方。在发明轮子之前，货物很可能是通过袋子、篮子或箱子由人类肩背运输，或者使用驴、骆驼或大象等动物运输。随着轮子的发明，运输效率有所提高，因为人类建造了可以推动手推车的道路，可以一次运输更多的货物。当第一台蒸汽驱动机和后来的汽油驱动引擎被引入时，运输变得更加高效。如今，我们通过飞机、火车、船只和卡车运输大量货物。同时，货物种类变得越来越多样，有时也变得更加复杂。在这几千年里，有一件事没有改变，那就是必须在目标地点卸货，并可能需要将货物重新装载到另一种运输工具上。举个例子，比如一个农民把装满苹果的手推车运到中央火车站，然后这些苹果与其他许多农民的苹果一起被装上火车。或者想象一个酿酒师将酒桶装载到卡车上运送到港口，然后这些酒桶被卸下并转移到船上，运往海外。
- en: This unloading from one means of transportation and loading onto another means
    of transportation was a really complex and tedious process. Every type of product
    was packaged in its own way and thus had to be handled in its own particular way.
    Also, loose goods faced the risk of being stolen by unethical workers or damaged
    in the process of being handled.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从一种运输方式卸货并装载到另一种运输方式的过程，实际上是一个非常复杂且繁琐的过程。每种类型的产品都有其特定的包装方式，因此必须按照特定的方式进行处理。此外，散装货物面临着被不道德的工人盗窃或在处理过程中损坏的风险。
- en: '![Figure 1.1 – Sailors unloading goods from a ship](img/B19199_01_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 水手从船上卸货](img/B19199_01_1.jpg)'
- en: Figure 1.1 – Sailors unloading goods from a ship
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 水手从船上卸货
- en: Then, containers came along, and they totally revolutionized the transportation
    industry. A container is just a metallic box with standardized dimensions. The
    length, width, and height of each container are the same. This is a very important
    point. Without the world agreeing on a standard size, the whole container thing
    would not have been as successful as it is now. Now, with standardized containers,
    companies who want to have their goods transported from A to B package those goods
    into these containers. Then, they call a shipper, who uses a standardized means
    of transportation. This can be a truck that can load a container, or a train whose
    wagons can each transport one or several containers. Finally, we have ships that
    are specialized in transporting huge numbers of containers. Shippers never need
    to unpack and repackage goods. For a shipper, a container is just a black box,
    and they are not interested in what is in it, nor should they care in most cases.
    It is just a big iron box with standard dimensions. Packaging goods into containers
    is now fully delegated to the parties who want to have their goods shipped, and
    they should know how to handle and package those goods. Since all containers have
    the same agreed-upon shape and dimensions, shippers can use standardized tools
    to handle containers; that is, cranes that unload containers, say from a train
    or a truck, and load them onto a ship and vice versa. One type of crane is enough
    to handle all the containers that come along over time. Also, the means of transportation
    can be standardized, such as container ships, trucks, and trains. Because of all
    this standardization, all the processes in and around shipping goods could also
    be standardized and thus made much more efficient than they were before the introduction
    of containers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，集装箱出现了，它们彻底改变了运输行业。集装箱只是一个具有标准化尺寸的金属箱子。每个集装箱的长度、宽度和高度都是相同的。这一点非常重要。如果世界各国没有达成统一的标准尺寸，集装箱的使用就不会像现在这样成功。现在，借助标准化的集装箱，那些希望将货物从A地运输到B地的公司，会将货物装入这些集装箱中。然后，他们会联系运输公司，运输公司使用标准化的运输工具。这可以是可以装载集装箱的卡车，或者是每个车厢能够运输一个或多个集装箱的火车。最后，我们有专门运输大量集装箱的船只。运输公司从来不需要拆包和重新包装货物。对运输公司而言，集装箱只是一个黑箱，他们不关心里面是什么，通常情况下也无需关心。它只是一个具有标准尺寸的大铁箱子。将货物包装进集装箱的工作现在完全委托给了那些希望运输货物的一方，他们应该知道如何处理和包装这些货物。由于所有集装箱都有相同的约定形状和尺寸，运输公司可以使用标准化工具来处理集装箱；也就是说，起重机可以将集装箱从火车或卡车上卸下，并将它们装载到船上，反之亦然。只需一种类型的起重机就能处理所有随时间到来的集装箱。而且，运输工具也可以标准化，比如集装箱船、卡车和火车。正是由于这些标准化，运输货物的所有流程得以标准化，因此比集装箱出现之前更加高效。
- en: '![Figure 1.2 – Container ship being loaded in a port](img/B19199_01_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 集装箱船在港口装货](img/B19199_01_2.jpg)'
- en: Figure 1.2 – Container ship being loaded in a port
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 集装箱船在港口装货
- en: Now, you should have a good understanding of why shipping containers are so
    important and why they revolutionized the whole transportation industry. I chose
    this analogy purposefully since the software containers that we are going to introduce
    here fulfill the exact same role in the so-called software supply chain as shipping
    containers do in the supply chain of physical goods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对为什么集装箱如此重要以及它们如何彻底改变整个运输行业有了深入的理解。我有意选择了这个类比，因为我们将在这里介绍的软件容器在所谓的软件供应链中，发挥的作用与集装箱在实体商品供应链中的作用完全相同。
- en: Let’s then have a look at what this whole thing means when translated to the
    IT industry and software development, shall we? In the old days, developers would
    develop new applications. Once an application was completed in their eyes, they
    would hand that application over to the operations engineers, who were then supposed
    to install it on the production servers and get it running. If the operations
    engineers were lucky, they even got a somewhat accurate document with installation
    instructions from the developers. So far, so good, and life was easy. But things
    got a bit out of hand when, in an enterprise, there were many teams of developers
    that created quite different types of applications, yet all of them needed to
    be installed on the same production servers and kept running there. Usually, each
    application has some external dependencies, such as which framework it was built
    on, what libraries it uses, and so on. Sometimes, two applications use the same
    framework but of different versions that might or might not be compatible with
    each other. Our operations engineers’ lives became much harder over time. They
    had to become really creative with how they loaded their ships, that is, their
    servers, with different applications without breaking something. Installing a
    new version of a certain application was now a complex project on its own, and
    often needed months of planning and testing beforehand. In other words, there
    was a lot of friction in the software supply chain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们来看看将这整件事翻译到 IT 行业和软件开发中意味着什么，好吗？在过去，开发人员会开发新的应用程序。一旦应用程序在他们眼中完成，他们就会将该应用程序交给运维工程师，后者需要将其安装到生产服务器上并使其运行。如果运维工程师运气好，他们甚至能从开发人员那里得到一份相对准确的安装文档。到目前为止，一切都很好，生活也很简单。但当一个企业中有多个开发团队，各自开发出不同类型的应用程序，而这些应用程序又都需要安装到同一台生产服务器并保持运行时，事情就有点失控了。通常，每个应用程序都有一些外部依赖项，比如它是基于哪个框架构建的，使用了哪些库，等等。有时，两个应用程序使用的是相同的框架，但版本不同，可能兼容，也可能不兼容。随着时间的推移，我们的运维工程师的生活变得更加艰难。他们必须非常有创造性地思考如何在不破坏任何东西的情况下将不同的应用程序加载到他们的服务器上。现在，安装某个应用程序的新版本本身已经是一个复杂的项目，往往需要几个月的规划和测试。换句话说，软件供应链中充满了摩擦。
- en: But these days, companies rely more and more on software, and the release cycles
    need to become shorter and shorter. Companies cannot afford to just release application
    updates once or twice a year anymore. Applications need to be updated in a matter
    of weeks or days, or sometimes even multiple times per day. Companies that do
    not comply risk going out of business due to the lack of agility. So, what’s the
    solution? One of the first approaches was to use **virtual machines** (**VMs**).
    Instead of running multiple applications all on the same server, companies would
    package and run a single application on each VM. With this, all the compatibility
    problems were gone, and life seemed to be good again. Unfortunately, that happiness
    didn’t last long. VMs are pretty heavy beasts on their own since they all contain
    a full-blown operating system such as Linux or Windows Server, and all that for
    just a single application. This is as if you used a whole ship just to transport
    a single truckload of bananas in the transportation industry. What a waste! That
    would never be profitable. The ultimate solution to this problem was to provide
    something much more lightweight than VMs also able to perfectly encapsulate the
    goods it needed to transport. Here, the goods are the actual application that
    has been written by our developers, plus – and this is important – all the external
    dependencies of the application, such as its framework, libraries, configurations,
    and more. This holy grail of a software packaging mechanism is the **Docker container**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如今，公司越来越依赖软件，发布周期需要变得越来越短。公司已经不能再只在一年或两次发布应用更新了。应用需要在几周甚至几天内进行更新，有时甚至一天内更新多次。不遵守这一点的公司，可能会因为缺乏灵活性而面临倒闭风险。那么，解决办法是什么呢？最早的解决方案之一是使用**虚拟机**（**VMs**）。公司不是在同一台服务器上运行多个应用，而是将每个应用打包并在每个虚拟机上运行。这样，所有兼容性问题就消失了，生活似乎又变得美好了。不幸的是，这种幸福并没有持续多久。虚拟机本身相当笨重，因为它们每个都包含一个完整的操作系统，如Linux或Windows
    Server，而这一切仅仅是为了运行一个单一的应用。这就好比在运输行业中，你为了运送一车香蕉，却使用了一整艘船。这简直是浪费！这种方式是永远无法盈利的。解决这个问题的终极方案是提供一种比虚拟机更轻量的解决方案，同时还能完美封装它需要运输的货物。这里的货物就是我们的开发人员编写的实际应用程序，此外——这一点很重要——还有应用程序的所有外部依赖，如框架、库、配置等。这种软件打包机制的“圣杯”便是**Docker容器**。
- en: Developers package their applications, frameworks, and libraries into Docker
    containers, and then they ship those containers to the testers or operations engineers.
    For testers and operations engineers, a container is just a black box. It is a
    standardized black box, though. All containers, no matter what application runs
    inside them, can be treated equally. The engineers know that if any container
    runs on their servers, then any other containers should run too. And this is actually
    true, apart from some edge cases, which always exist. Thus, Docker containers
    are a means to package applications and their dependencies in a standardized way.
    Docker then coined the phrase *Build*, *ship*, and *run anywhere*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员将他们的应用程序、框架和库打包成Docker容器，然后将这些容器交给测试人员或运维工程师。对于测试人员和运维工程师来说，容器就像一个黑匣子。它是一个标准化的黑匣子。不过，所有的容器，无论内部运行什么应用，都可以被同等对待。工程师知道，只要任何一个容器能在他们的服务器上运行，那么其他容器也应该能运行。除了某些边缘情况（这些情况总是存在的），这一点基本成立。因此，Docker容器是一种标准化的方式，用于打包应用及其依赖项。Docker由此创造了“构建（Build）、运输（ship）和随处运行（run
    anywhere）”这一口号。
- en: Why are containers important?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么容器如此重要？
- en: These days, the time between new releases of an application becomes shorter
    and shorter, yet the software itself does not become any simpler. On the contrary,
    software projects increase in complexity. Thus, we need a way to tame the beast
    and simplify the software supply chain. Also, every day, we hear that cyber-attacks
    are on the rise. Many well-known companies are and have been affected by security
    breaches. Highly sensitive customer data gets stolen during such events, such
    as social security numbers, credit card information, health-related information,
    and more. But not only is customer data compromised – sensitive company secrets
    are stolen too. Containers can help in many ways. In a published report, Gartner
    found that applications running in a container are more secure than their counterparts
    not running in a container. Containers use Linux security primitives such as Linux
    kernel **namespaces** to sandbox different applications running on the same computers
    and **control groups** (**cgroups**) to avoid the noisy-neighbor problem, where
    one bad application uses all the available resources of a server and starves all
    other applications. Since container images are immutable, as we will learn later,
    it is easy to have them scanned for **common vulnerabilities and exposures** (**CVEs**),
    and in doing so, increase the overall security of our applications. Another way
    to make our software supply chain more secure is to have our containers use **content
    trust**. Content trust ensures that the author of a container image is who they
    say they are and that the consumer of the container image has a guarantee that
    the image has not been tampered with in transit. The latter is known as a **man-in-the-middle**
    (**MITM**) attack.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序的新版本发布之间的时间变得越来越短，但软件本身并没有变得更简单。相反，软件项目的复杂性不断增加。因此，我们需要一种方法来驯服这个“野兽”，简化软件供应链。此外，我们每天都听到网络攻击不断上升的消息。许多知名公司受到了安全漏洞的影响。敏感的客户数据在这些事件中被盗，例如社会安全号码、信用卡信息、健康相关信息等等。但不仅仅是客户数据受到威胁——敏感的公司机密也被盗取。容器可以以多种方式提供帮助。在一份发布的报告中，Gartner发现，运行在容器中的应用程序比没有运行在容器中的同类应用程序更加安全。容器使用Linux安全原语，例如Linux内核**命名空间**（**namespaces**），来将在同一台计算机上运行的不同应用程序进行沙箱隔离，并使用**控制组**（**cgroups**）来避免噪音邻居问题，即某个不良应用程序占用了服务器的所有可用资源，导致其他应用程序无法使用资源。由于容器镜像是不可变的，正如我们稍后将了解的那样，扫描它们以查找**常见漏洞和暴露**（**CVEs**）非常容易，这样可以提高我们应用程序的整体安全性。确保我们的软件供应链更加安全的另一种方法是让我们的容器使用**内容信任**（**content
    trust**）。内容信任确保容器镜像的作者就是他们所说的人，并且容器镜像的消费者可以确保该镜像在传输过程中没有被篡改。后者被称为**中间人攻击**（**MITM**）。
- en: Everything I have just said is, of course, technically also possible without
    using containers, but since containers introduce a globally accepted standard,
    they make it so much easier to implement these best practices and enforce them.
    OK, but security is not the only reason containers are important. There are other
    reasons too. One is the fact that containers make it easy to simulate a production-like
    environment, even on a developer’s laptop. If we can containerize any application,
    then we can also containerize, say, a database such as Oracle, PostgreSQL, or
    MS SQL Server. Now, everyone who has ever had to install an Oracle database on
    a computer knows that this is not the easiest thing to do, and it takes up a lot
    of precious space on your computer. You would not want to do that to your development
    laptop just to test whether the application you developed really works end to
    end. With containers to hand, we can run a full-blown relational database in a
    container as easily as saying 1, 2, 3\. And when we are done with testing, we
    can just stop and delete the container and the database will be gone, without
    leaving a single trace on our computer. Since containers are very lean compared
    to VMs, it is common to have many containers running at the same time on a developer’s
    laptop without overwhelming the laptop. A third reason containers are important
    is that operators can finally concentrate on what they are good at – provisioning
    the infrastructure and running and monitoring applications in production. When
    the applications they must run on a production system are all containerized, then
    operators can start to standardize their infrastructure. Every server becomes
    just another **Docker host**. No special libraries or frameworks need to be installed
    on those servers – just an OS and a container runtime such as Docker. Furthermore,
    operators do not have to have intimate knowledge of the internals of applications
    anymore, since those applications run self-contained in containers that ought
    to look like black boxes to them like how shipping containers look to personnel
    in the transportation industry.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才说的所有内容，当然，在不使用容器的情况下也能技术上实现，但由于容器引入了一个全球接受的标准，它们让实现这些最佳实践并强制执行变得更加容易。好的，但安全性并不是容器重要的唯一原因。还有其他原因。一个原因是，容器让开发者即使在自己的笔记本电脑上也能轻松模拟生产环境。如果我们能够将任何应用程序容器化，那么我们也可以将像
    Oracle、PostgreSQL 或 MS SQL Server 这样的数据库容器化。现在，任何曾经在计算机上安装过 Oracle 数据库的人都知道，这并不是一件容易的事，而且会占用很多宝贵的硬盘空间。你肯定不想仅仅为了测试你开发的应用程序是否真正能端到端地工作，就把这个数据库安装在你的开发笔记本上。有了容器，我们可以像说“一、二、三”一样轻松地在容器中运行一个完整的关系型数据库。当我们完成测试时，只需停止并删除容器，数据库就会消失，且不会在我们的电脑上留下任何痕迹。由于容器相比虚拟机非常精简，因此在开发者的笔记本电脑上同时运行多个容器而不至于让笔记本电脑不堪重负是很常见的。容器重要的第三个原因是，运维人员终于可以集中精力做他们擅长的事——提供基础设施、运行和监控生产中的应用程序。当他们必须在生产系统上运行的所有应用程序都已经容器化时，运维人员就可以开始标准化他们的基础设施。每台服务器都变成了另一个**Docker
    主机**。这些服务器上无需安装特殊的库或框架——只需要操作系统和像 Docker 这样的容器运行时。此外，运维人员也不再需要深入了解应用程序的内部结构，因为这些应用程序都是自包含在容器中，对于他们来说，这些容器就像运输行业人员看到的集装箱一样，应该是黑箱。
- en: What is the benefit of using containers for me or for my company?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器对我或我的公司有什么好处？
- en: Somebody once said *“...today every company of a certain size has to acknowledge
    that they need to be a software company...”* In this sense, a modern bank is a
    software company that happens to specialize in the business of finance. Software
    runs all businesses, period. As every company becomes a software company, there
    is a need to establish a software supply chain. For the company to remain competitive,
    its software supply chain must be secure and efficient. Efficiency can be achieved
    through thorough automation and standardization. But in all three areas – security,
    automation, and standardization – containers have been shown to shine. Large and
    well-known enterprises have reported that when containerizing existing legacy
    applications (many call them traditional applications) and establishing a fully
    automated software supply chain based on containers, they can reduce the cost
    for the maintenance of those mission-critical applications by a factor of 50%
    to 60% and they can reduce the time between new releases of these traditional
    applications by up to 90%. That being said, the adoption of container technologies
    saves these companies a lot of money, and at the same time, it speeds up the development
    process and reduces the time to market.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 曾有人说过*“…今天每个规模较大的公司都必须承认，它们需要成为一家软件公司…”* 从这个角度来看，现代银行是一家专注于金融业务的软件公司。软件支撑着所有的业务，毫无疑问。随着每家公司都变成了软件公司，建立一个软件供应链变得至关重要。为了保持竞争力，公司必须确保其软件供应链既安全又高效。通过彻底的自动化和标准化，可以实现效率。但在安全性、自动化和标准化这三个领域中，容器技术已经证明了其优势。许多大型知名企业报告称，在将现有传统应用程序容器化并建立一个基于容器的完全自动化软件供应链后，它们能够将这些关键应用程序的维护成本降低50%到60%，并且能够将这些传统应用程序的新版本发布周期缩短至最多90%。也就是说，容器技术的采用为这些公司节省了大量资金，同时加速了开发进程，缩短了上市时间。
- en: The Moby project
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moby项目
- en: Originally, when Docker (the company) introduced Docker containers, everything
    was open source. Docker did not have any commercial products then. Docker Engine,
    which the company developed, was a monolithic piece of software. It contained
    many logical parts, such as the container runtime, a network library, a RESTful
    (REST) API, a command-line interface, and much more. Other vendors or projects
    such as Red Hat or Kubernetes used Docker Engine in their own products, but most
    of the time, they were only using part of its functionality. For example, Kubernetes
    did not use the Docker network library for Docker Engine but provided its own
    way of networking. Red Hat, in turn, did not update Docker Engine frequently and
    preferred to apply unofficial patches to older versions of Docker Engine, yet
    they still called it Docker Engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，当Docker（公司）推出Docker容器时，一切都是开源的。当时，Docker并没有任何商业产品。Docker Engine是公司开发的一个单体软件，它包含了许多逻辑组件，例如容器运行时、网络库、RESTful（REST）API、命令行接口等。其他供应商或项目，如Red
    Hat或Kubernetes，也在他们自己的产品中使用Docker Engine，但大多数情况下，他们仅使用了其部分功能。例如，Kubernetes并没有使用Docker
    Engine的网络库，而是提供了自己的网络方式。Red Hat则不频繁更新Docker Engine，倾向于在旧版本的Docker Engine上应用非官方补丁，但他们仍然称之为Docker
    Engine。
- en: For all these reasons, and many more, the idea emerged that Docker had to do
    something to clearly separate Docker’s open source part from Docker’s commercial
    part. Furthermore, the company wanted to prevent competitors from using and abusing
    the name Docker for their own gains. This was the main reason the Moby project
    was born. It serves as an umbrella for most of the open source components Docker
    developed and continues to develop. These open source projects do not carry the
    name Docker anymore. The Moby project provides components used for image management,
    secret management, configuration management, and networking and provisioning.
    Also, part of the Moby project are special Moby tools that are, for example, used
    to assemble components into runnable artifacts. Some components that technically
    belong to the Moby project have been donated by Docker to the **Cloud Native Computing
    Foundation** (**CNCF**) and thus do not appear in the list of components anymore.
    The most prominent ones are **notary**, **containerd**, and **runc**, where the
    first is used for content trust and the latter two form the container runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于种种原因，Docker 意识到必须采取措施，明确区分 Docker 的开源部分和商业部分。此外，公司还希望防止竞争对手利用 Docker 这个名称谋取利益。这也是
    Moby 项目诞生的主要原因。它作为大多数 Docker 开发并继续开发的开源组件的伞形项目。这些开源项目不再使用 Docker 名称。Moby 项目提供了用于镜像管理、密钥管理、配置管理以及网络和资源配置的组件。此外，Moby
    项目还包括一些特殊的 Moby 工具，例如用于将组件组装成可运行工件的工具。某些技术上属于 Moby 项目的组件已经由 Docker 捐赠给了 **云原生计算基金会**
    (**CNCF**)，因此不再出现在组件列表中。最著名的有 **notary**、**containerd** 和 **runc**，其中 notary 用于内容信任，后两者构成了容器运行时。
- en: In the words of Docker, *“... Moby is an open framework created by Docker to
    assemble specialized container systems without reinventing the wheel. It provides
    a “Lego set” of dozens of standard components and a framework for assembling them
    into* *custom platforms....”*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Docker 的说法，*“... Moby 是由 Docker 创建的一个开放框架，用于组装专门的容器系统，而无需重新发明轮子。它提供了一个“乐高积木”式的多个标准组件，以及一个将它们组装成*
    *自定义平台* 的框架....”*
- en: Docker products
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 产品
- en: In the past, up until 2019, Docker separated its product lines into two segments.
    There was the **Community Edition** (**CE**), which was closed source yet completely
    free, and then there was the **Enterprise Edition** (**EE**), which was also closed
    source and needed to be licensed yearly. These enterprise products were backed
    by 24/7 support and were supported by bug fixes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，直到 2019 年，Docker 将其产品线分为两个部分。一个是 **社区版** (**CE**)，它是闭源的，但完全免费；另一个是 **企业版**
    (**EE**)，同样是闭源的，并且需要每年授权。这些企业产品提供 24/7 支持，并且有缺陷修复支持。
- en: In 2019, Docker felt that what they had were two very distinct and different
    businesses. Consequently, they split away the EE and sold it to Mirantis. Docker
    itself wanted to refocus on developers and provide them with the optimal tools
    and support to build containerized applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2019 年，Docker 认为他们的业务实际上是两个非常不同的部分。因此，他们将 EE 部分分拆，并将其出售给了 Mirantis。Docker 本身希望重新聚焦于开发者，并为他们提供构建容器化应用程序所需的最佳工具和支持。
- en: Docker Desktop
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Part of the Docker offering are products such as Docker Toolbox and Docker Desktop
    with its editions for Mac, Windows, and Linux. All these products are mainly targeted
    at developers. Docker Desktop is an easy-to-install desktop application that can
    be used to build, debug, and test dockerized applications or services on a macOS,
    Windows, or Linux machine. Docker Desktop is a complete development environment
    that is deeply integrated with the hypervisor framework, network, and filesystem
    of the respective underlying operating system. These tools are the fastest and
    most reliable ways to run Docker on a Mac, Windows, or Linux machine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供的产品包括 Docker Toolbox 和 Docker Desktop，其中 Docker Desktop 还提供适用于 Mac、Windows
    和 Linux 的版本。这些产品主要面向开发者。Docker Desktop 是一款易于安装的桌面应用程序，可以在 macOS、Windows 或 Linux
    机器上用于构建、调试和测试 Docker 化的应用程序或服务。Docker Desktop 是一个完整的开发环境，与各自底层操作系统的虚拟化框架、网络和文件系统深度集成。这些工具是运行
    Docker 的最快、最可靠的方式。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker Toolbox has been deprecated and is no longer in active development. Docker
    recommends using Docker Desktop instead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Toolbox 已被弃用，不再进行积极开发。Docker 推荐改用 Docker Desktop。
- en: Docker Hub
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Hub
- en: Docker Hub is the most popular service for finding and sharing container images.
    It is possible to create individual, user-specific accounts and organizational
    accounts under which Docker images can be uploaded and shared inside a team, an
    organization, or with the wider public. Public accounts are free while private
    accounts require one of several commercial licenses. Later in this book, we will
    use Docker Hub to download existing Docker images and upload and share our own
    custom Docker images.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是最受欢迎的容器镜像查找和共享服务。可以创建个人用户账户和组织账户，用户可以在这些账户下上传并共享 Docker 镜像，可以在团队、组织或更广泛的公众之间共享。公共账户是免费的，而私有账户需要购买多种商业许可证之一。在本书后续部分，我们将使用
    Docker Hub 来下载现有的 Docker 镜像，并上传和分享我们自己的自定义 Docker 镜像。
- en: Docker Enterprise Edition
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 企业版
- en: Docker EE – now owned by Mirantis – consists of the **Universal Control Plane**
    (**UCP**) and the **Docker Trusted Registry** (**DTR**), both of which run on
    top of Docker Swarm. Both are Swarm applications. Docker EE builds on top of the
    upstream components of the Moby project and adds enterprise-grade features such
    as **role-based access control** (**RBAC**), multi-tenancy, mixed clusters of
    Docker Swarm and Kubernetes, a web-based UI, and content trust, as well as image
    scanning on top.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker EE——现在由 Mirantis 拥有——由**Universal Control Plane**（**UCP**）和**Docker Trusted
    Registry**（**DTR**）组成，这两个组件都运行在 Docker Swarm 之上。它们都是 Swarm 应用程序。Docker EE 构建在
    Moby 项目的上游组件之上，并添加了企业级功能，如**基于角色的访问控制**（**RBAC**）、多租户、混合集群的 Docker Swarm 和 Kubernetes、基于
    Web 的 UI、内容信任，以及图像扫描等。
- en: Docker Swarm
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Swarm provides a powerful and flexible platform for deploying and managing
    containers in a production environment. It provides the tools and features you
    need to build, deploy, and manage your applications with ease and confidence.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 提供了一个强大而灵活的平台，用于在生产环境中部署和管理容器。它提供了构建、部署和管理应用程序所需的工具和功能，使您能够轻松自信地进行操作。
- en: Container architecture
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器架构
- en: 'Now, let us discuss how a system that can run Docker containers is designed
    at a high level. The following diagram illustrates what a computer that Docker
    has been installed on looks like. Note that a computer that has Docker installed
    on it is often called a Docker host because it can run or host Docker containers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下一个可以运行 Docker 容器的系统如何在高层次上进行设计。下图展示了安装了 Docker 的计算机的结构。请注意，安装了 Docker
    的计算机通常被称为 Docker 主机，因为它可以运行或托管 Docker 容器：
- en: '![Figure 1.3 – High-level architecture diagram of Docker Engine](img/enlarge_B19199_01_3.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – Docker 引擎的高级架构图](img/enlarge_B19199_01_3.jpg)'
- en: Figure 1.3 – High-level architecture diagram of Docker Engine
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Docker 引擎的高级架构图
- en: 'In the preceding diagram, we can see three essential parts:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到三个关键部分：
- en: At the bottom, we have the **Linux** **Operating System**
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部，我们有**Linux** **操作系统**
- en: In the middle, we have the **Container Runtime**
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中间，我们有**容器运行时**
- en: At the top, we have **Docker Engine**
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部，我们有**Docker 引擎**
- en: Containers are only possible because the Linux OS supplies some primitives,
    such as namespaces, control groups, layer capabilities, and more, all of which
    are used in a specific way by the container runtime and Docker Engine. Linux kernel
    namespaces, such as process ID (`pid`) namespaces or network (`net`) namespaces,
    allow Docker to encapsulate or sandbox processes that run inside the container.
    Control groups make sure that containers do not suffer from noisy-neighbor syndrome,
    where a single application running in a container can consume most or all the
    available resources of the whole Docker host. Control groups allow Docker to limit
    the resources, such as CPU time or the amount of RAM, that each container is allocated.
    The container runtime on a Docker host consists of containerd and runc. runc is
    the low-level functionality of the container runtime such as container creation
    or management, while containerd, which is based on runc, provides higher-level
    functionality such as image management, networking capabilities, or extensibility
    via plugins. Both are open source and have been donated by Docker to the CNCF.
    The container runtime is responsible for the whole life cycle of a container.
    It pulls a container image (which is the template for a container) from a registry,
    if necessary, creates a container from that image, initializes and runs the container,
    and eventually stops and removes the container from the system when asked. Docker
    Engine provides additional functionality on top of the container runtime, such
    as network libraries or support for plugins. It also provides a REST interface
    over which all container operations can be automated. The Docker command-line
    interface that we will use often in this book is one of the consumers of this
    REST interface.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 容器之所以能够存在，是因为 Linux 操作系统提供了一些基本原语，如命名空间、控制组、层级功能等，所有这些都被容器运行时和 Docker 引擎以特定的方式使用。Linux
    内核命名空间，如进程 ID（`pid`）命名空间或网络（`net`）命名空间，使得 Docker 能够封装或沙箱化在容器内运行的进程。控制组确保容器不会遭遇噪声邻居效应（noisy-neighbor
    syndrome），即在一个容器中运行的单个应用可能会消耗整个 Docker 主机的大部分或所有可用资源。控制组允许 Docker 限制每个容器分配的资源，如
    CPU 时间或内存量。Docker 主机上的容器运行时由 containerd 和 runc 组成。runc 是容器运行时的低级功能，如容器创建或管理，而
    containerd 基于 runc 提供更高级的功能，如镜像管理、网络能力或通过插件扩展功能。两者都是开源的，并由 Docker 捐赠给 CNCF。容器运行时负责容器的整个生命周期。它从注册表中拉取容器镜像（即容器的模板），如果需要的话，基于该镜像创建容器，初始化并运行容器，最终在需要时停止并从系统中移除容器。Docker
    引擎提供了容器运行时之上的额外功能，如网络库或对插件的支持。它还提供了一个 REST 接口，通过该接口可以自动化所有容器操作。本书中我们将经常使用的 Docker
    命令行接口就是这个 REST 接口的消费者之一。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how containers can massively reduce friction in
    the software supply chain and, on top of that, make the supply chain much more
    secure. In the next chapter, we will familiarize ourselves with containers. We
    will learn how to run, stop, and remove containers and otherwise manipulate them.
    We will also get a pretty good overview of the anatomy of containers. For the
    first time, we are really going to get our hands dirty and play with these containers.
    So, stay tuned!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了容器如何大幅减少软件供应链中的摩擦，并在此基础上使供应链变得更加安全。在下一章，我们将熟悉容器的基本概念。我们将学习如何运行、停止和删除容器以及如何操作容器。我们还将对容器的结构有一个相当好的概览。我们将第一次真正动手操作容器，亲自体验这些容器。所以，敬请期待！
- en: Further reading
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following is a list of links that lead to more detailed information regarding
    the topics we discussed in this chapter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些链接，提供了更多关于我们在本章中讨论的主题的详细信息：
- en: '*Docker* *overview*: [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker* *overview*: [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)'
- en: '*The Moby* *project*: [https://mobyproject.org/](https://mobyproject.org/)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The Moby* *project*: [https://mobyproject.org/](https://mobyproject.org/)'
- en: '*Docker* *products*: [https://www.docker.com/get-started](https://www.docker.com/get-started)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker* *products*: [https://www.docker.com/get-started](https://www.docker.com/get-started)'
- en: '*Docker* *Desktop*: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker* *Desktop*: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)'
- en: '*Cloud-Native Computing* *Foundation*: [https://www.cncf.io/](https://www.cncf.io/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cloud-Native Computing* *Foundation*: [https://www.cncf.io/](https://www.cncf.io/)'
- en: '*containerd*: [https://containerd.io/](https://containerd.io/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*containerd*: [https://containerd.io/](https://containerd.io/)'
- en: '*Getting Started with Docker Enterprise* *3.1*: [https://www.mirantis.com/blog/getting-started-with-docker-enterprise-3-1/](https://www.mirantis.com/blog/getting-started-with-docker-enterprise-3-1/)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker 企业版入门* *3.1*: [https://www.mirantis.com/blog/getting-started-with-docker-enterprise-3-1/](https://www.mirantis.com/blog/getting-started-with-docker-enterprise-3-1/)'
- en: Questions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please answer the following questions to assess your learning progress:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，以评估你的学习进度：
- en: Which statements are correct (multiple answers are possible)?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些说法是正确的（可以有多个答案）？
- en: A container is kind of a lightweight VM
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是一种轻量级虚拟机
- en: A container only runs on a Linux host
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器只能在 Linux 主机上运行
- en: A container can only run one process
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器只能运行一个进程
- en: The main process in a container always has PID 1
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器中的主要进程总是拥有 PID 1
- en: A container is one or more processes encapsulated by Linux namespaces and restricted
    by cgroups
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是由 Linux 命名空间封装并由 cgroups 限制的一个或多个进程
- en: In your own words, using analogies, explain what a container is.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请用自己的话，借助类比，解释什么是容器。
- en: Why are containers considered to be a game-changer in IT? Name three or four
    reasons.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么容器被认为是 IT 领域的游戏规则改变者？列出三到四个理由。
- en: What does it mean when we claim, if a container runs on a given platform, then
    it runs anywhere? Name two to three reasons why this is true.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们说“如果容器在某个平台上运行，那么它可以在任何地方运行”时，这是什么意思？列出两到三条原因，解释为什么这是正确的。
- en: 'Is the following claim true or false: *Docker containers are only useful for
    modern greenfield applications based on microservices*? Please justify your answer.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下说法是对还是错：*Docker 容器仅适用于基于微服务的现代绿地应用程序*？请说明你的理由。
- en: How much does a typical enterprise save when containerizing its legacy applications?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当企业将其传统应用程序容器化时，通常能节省多少成本？
- en: 20%
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 20%
- en: 33%
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 33%
- en: 50%
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50%
- en: 75%
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 75%
- en: Which two core concepts of Linux are containers based on?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器基于 Linux 的两个核心概念是什么？
- en: On which operating systems is Docker Desktop available?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Desktop 可以在哪些操作系统上使用？
- en: Answers
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The correct answers are *D* and *E*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案是 *D* 和 *E*。
- en: A Docker container is to IT what a shipping container is to the transportation
    industry. It defines a standard on how to package goods. In this case, goods are
    the application(s) developers write. The suppliers (in this case, the developers)
    are responsible for packaging the goods into the container and making sure everything
    fits as expected. Once the goods are packaged into a container, it can be shipped.
    Since it is a standard container, the shippers can standardize their means of
    transportation, such as lorries, trains, or ships. The shipper does not really
    care what is in the container. Also, the loading and unloading process from one
    means of transportation to another (for example, train to ship) can be highly
    standardized. This massively increases the efficiency of transportation. Analogous
    to this is an operations engineer in IT, who can take a software container built
    by a developer and ship it to a production system and run it there in a highly
    standardized way, without worrying about what is in the container. It will just
    work.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 容器对 IT 的意义，就像集装箱对运输行业的意义一样。它定义了如何包装货物的标准。在这种情况下，货物就是开发人员编写的应用程序。供应商（即开发者）负责将货物打包进容器，并确保一切如预期般适合。一旦货物被打包进容器，就可以进行运输。由于它是标准化的容器，运输商可以标准化其运输工具，如卡车、火车或船只。运输商并不关心容器内的具体内容。此外，从一种运输工具（如火车到船）转运的装卸过程可以高度标准化。这大大提高了运输效率。类比到
    IT 中，运维工程师可以将开发人员构建的软件容器运送到生产系统，并以高度标准化的方式运行，而无需担心容器中的内容。它将正常运行。
- en: 'Some of the reasons why containers are game-changers are as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器被认为是游戏规则改变者的一些原因如下：
- en: Containers are self-contained and thus if they run on one system, they run anywhere
    that a Docker container can run.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是自包含的，因此如果它们在一个系统上运行，就可以在任何可以运行 Docker 容器的地方运行。
- en: Containers run on-premises and in the cloud, as well as in hybrid environments.
    This is important for today’s typical enterprises since it allows a smooth transition
    from on-premises to the cloud.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以在本地和云端运行，也可以在混合环境中运行。这对于今天的典型企业至关重要，因为它使得从本地到云的平滑过渡成为可能。
- en: Container images are built or packaged by the people who know best – the developers.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是由最了解它们的人——开发者——构建或打包的。
- en: Container images are immutable, which is important for good release management.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是不可变的，这对于良好的发布管理非常重要。
- en: Containers are enablers of a secure software supply chain based on encapsulation
    (using Linux namespaces and cgroups), secrets, content trust, and image vulnerability
    scanning.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是基于封装（使用 Linux 命名空间和 cgroups）、机密管理、内容信任和镜像漏洞扫描的安全软件供应链的推动者。
- en: 'A container runs on any system that can host containers. This is possible for
    the following reasons:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器可以在任何能够托管容器的系统上运行。之所以可能，是因为以下原因：
- en: Containers are self-contained black boxes. They encapsulate not only an application
    but also all its dependencies, such as libraries and frameworks, configuration
    data, certificates, and so on.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是自包含的黑匣子。它们不仅封装了应用程序，还封装了所有的依赖项，如库和框架、配置数据、证书等。
- en: Containers are based on widely accepted standards such as OCI.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器基于广泛接受的标准，如 OCI。
- en: The answer is false. Containers are useful for modern applications and to containerize
    traditional applications. The benefits for an enterprise when doing the latter
    are huge. Cost savings in the maintenance of legacy apps of 50% or more have been
    reported. The time between new releases of such legacy applications could be reduced
    by up to 90%. These numbers have been publicly reported by real enterprise customers.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是错误的。容器对现代应用程序非常有用，也适用于将传统应用程序容器化。当企业进行后者时，其收益是巨大的。维护传统应用程序的成本节省可达到50%或更多。据报道，这些传统应用程序的新版本发布周期可减少最多90%。这些数字已经由真实的企业客户公开报道。
- en: 50% or more.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50% 或更多。
- en: Containers are based on Linux **namespaces** (network, process, user, and so
    on) and **cgroups**. The former help isolate processes running on the same machine,
    while the latter are used to limit the resources a given process can access, such
    as memory or network bandwidth.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器基于 Linux **命名空间**（网络、进程、用户等）和 **cgroups**。前者帮助隔离在同一台机器上运行的进程，而后者用于限制特定进程可以访问的资源，如内存或网络带宽。
- en: Docker Desktop is available for macOS, Windows, and Linux.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Desktop 可在 macOS、Windows 和 Linux 上使用。
