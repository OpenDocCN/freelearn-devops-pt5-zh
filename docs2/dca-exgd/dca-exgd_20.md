评估

# 第一章

1.  b 和 c: 我们可以在每个容器中运行多个进程，但不推荐这样做，因为 Docker 引擎只会管理主容器进程。我们需要在进程之间管理额外的逻辑，才能一次性启动和停止所有进程。这并不容易，可能会在主机上留下“僵尸”进程。微服务基于每个应用组件的最小功能，这与容器非常契合。

1.  b: 控制组（cgroups）将管理提供给每个容器的主机资源，但非常重要的一点是，默认情况下，容器会以无限制的资源运行。

1.  a 和 b: 容器默认会以 root 用户身份运行，除非源镜像定义了非 root 用户，或者我们在创建容器时指定了非 root 用户。用户命名空间允许我们在容器内使用 root 权限，尽管容器外的真实用户可以拥有非 root 用户 ID。这在进程需要 UID 0 才能工作时非常有用。

1.  d: 以上所有句子都是正确的：Windows 主机将运行两种不同类型的隔离。我们可以在 Windows 上运行 Linux 容器，但反过来则不成立。

1.  a、b 和 c: 我们可以使用 `systemd` 单元文件或 `/etc/docker/daemon.json` 来配置 Linux 上的 Docker 守护进程。在 Windows 主机上，`daemon.json` 位于 `%programdata%\docker\config\` 目录。在这两种情况下，Docker 守护进程的远程访问默认不安全。

# 第二章

1.  b: 镜像 ID 是列出或管理镜像时唯一的标识。我们可以有一个 ID，包含多个名称，包括注册表部分和标签。

1.  d: 所有描述的方法都是有效的。

1.  b: 使用 Dockerfile 是一种可重现的方法，因为我们会描述所有添加软件、执行命令、添加文件等操作，以构建一个新的镜像。我们可以通过自动化和使用模板来构建镜像，这也是首选的方法。

1.  a 和 c: 只有 `RUN`、`CMD` 和 `ENTRYPOINT` 指令支持 shell 和 exec 格式。

1.  a: 使用 shell 格式时，容器的主进程（由 `ENTRYPOINT` 键定义）无法通过参数进行修改。

# 第三章

1.  a 和 c: `build` 仅适用于镜像对象，`destroy` 对任何对象都不存在。

1.  b: 这不正确。Docker 守护进程会等待一定的时间（默认是 10 秒），然后才会向容器的主进程发送 `SIGKILL` 信号。

1.  b: `docker kill` 会立即向容器的主进程发送 `SIGKILL` 信号。如果进程是在后台执行的，比如在容器内部，并非所有进程都会被杀死。如果这些进程没有父子依赖关系，它们可能会变成僵尸进程。如我们所学，容器必须手动删除，`docker kill` 并不会删除它们。

1.  b: `docker container update` 仅会更改容器的重启策略及其对主机资源的访问权限。

1.  c: 我们已经启动了一个特权容器，因此不会应用资源限制，尽管我们使用了 `-memory` 来限制内存使用。特权模式不会影响文件系统。它只会修改主进程的行为，但在这种情况下，我们使用了非 root 用户在一个由 root 拥有的目录中创建新文件，结果导致文件无法创建。

# 第四章

1.  c: 每个容器将使用其自己的文件系统，除非我们为它们声明共享卷。

1.  a、b 和 c: 有不同类型的卷，并且不仅仅在容器创建或执行时允许使用。

1.  b: Docker 卷可以通过 `--volumes`（或 `-v`）选项与其关联的容器一起删除。执行 Docker 卷清理将删除所有未使用的卷；即那些没有与任何容器关联的卷。但 Docker 永远不会删除绑定挂载卷的内容（即挂载到容器上的本地目录）。

1.  c: 只有自定义的桥接网络可以在容器创建后附加。如果我们创建或启动一个容器，并希望它连接到默认的桥接网络，我们需要重新创建它并在容器创建时将其连接到该网络。

1.  b: 使用 `--publish-all` 或 `-P` 将把 `32768` 到 `65535` 之间的随机端口关联到容器的内部端口 `80`。Docker 守护进程将自动创建一个 NAT 规则以允许这种通信。你可以禁用 Docker 守护进程的 iptables 管理，但默认是启用的。

# 第五章

1.  a: Docker Compose 会在单一主机上运行所有应用组件。我们还将使用 `docker-compose` 文件来部署通过 Swarm 协调的应用程序，这些应用程序的组件分布在不同的主机上，但这需要一个正在运行的集群。在这种情况下，我们不会使用 `docker-compose` 二进制文件来部署应用程序；只有定义文件有效，我们将使用 `docker stack` 操作。 在 Docker Swarm 中，我们部署的是 Swarm 服务，而不是容器。

1.  d: Docker Compose 提供了所有所需的操作来构建、共享和部署多容器应用程序。

1.  a 和 c: Docker Compose 会检查项目镜像是否存在于主机中。如果没有，Docker 守护进程将尝试下载所有缺失的镜像。一旦 Docker 守护进程拥有所有所需的镜像，它将启动所有项目容器，除非使用 `--detach` 或 `-d` 参数，否则我们的终端将附加到容器的标准输出和错误输出。

1.  a: Docker Compose 将允许我们扩展与某个服务关联的容器数量。默认情况下，Docker Compose 会为我们的部署创建一个桥接网络，因此一个内部 DNS 将会关联并管理所有应用程序的 IP 地址和名称。在扩展服务中，每次我们请求已定义的服务名称时，我们将收到一个副本的 IP 地址。它使用轮询 DNS 解析。

1.  d: 在这种情况下，我们可以说答案 c 几乎正确，但它不完整。Docker Compose 将删除所有容器。如果容器正在运行，它们将在删除之前被停止。所有在应用执行过程中创建的相关资源也将被移除。

# 第六章

1.  c: Docker 内容信任基于**更新框架**（**TUF**），该框架旨在通过使用不同的密钥确保在更新之间发布内容。可以使用 TUF 验证包或任何其他内容的可信度。

1.  a 和 d: Docker 内容信任将使用 Root、Targets、Snapshot 和 Timestamp 密钥来确保内容。

1.  c: 我们使用内容信任来确保镜像的新鲜度，但确实无法确保在给定仓库中标记为“latest”的镜像实际上是最新创建的镜像。我们只能确保将使用标记为“latest”的镜像。始终建议使用标签，避免使用“latest”。

1.  b: 我们尝试签署一个非公开的写仓库版本。我们不被允许修改 docker.io 上的根仓库。

1.  d: 如果我们有备份，可以恢复密钥。如果不可能，我们可以生成一个新的密钥，或者让 Docker 在首次签署时为我们生成一个新的密钥。尽管在生成新密钥后我们能够签署镜像，但所有先前签署的镜像将被视为不受信任，因为我们更改了签名。

# 第七章

1.  a: 编排器将不了解你的应用逻辑。另一方面，我们已经快速审查了使用编排的接口，以确保容器在分布式环境中获得适当的数据量。

1.  c: 编排器不会管理应用数据，也不了解你的应用逻辑。编排器将负责应用组件的健康状况，如果某个必需的实例死亡，它会启动一个新的实例。

1.  a 和 b: 分布式环境将帮助我们以更高的可用性和更好的性能部署应用程序。但另一方面，我们将面临新的挑战，因为我们需要能够在不同节点上分布应用逻辑和组件的交互。

1.  a 和 b: 答案 a 和 b 是正确的，而 c 是错误的，因为应用组件可以逐一管理。因此，如果应用逻辑知道如何管理情况，升级只会影响一个应用组件。

1.  c: 所有句子都是正确的。我们了解到，可以定义容器限制和所需资源。编排器会审查这些规格，并将在资源充足的节点上部署它们，以确保其正确执行。我们可以引导编排选择带有标签的节点，例如，以确保应用程序的磁盘 I/O，以及许多其他功能。每个编排器将管理不同的规则和工作流，以选择最适合每个工作负载的节点。

# 第八章

1.  a: Docker Swarm 是内置于 Docker 引擎中的，但我们需要启用 Swarm 模式才能使其工作。我们可以部署其他编排器，如 Kubernetes，但这将需要额外的工作来部署它们。编排器使我们能够在集群上部署应用程序，因此 Swarm 将部署分布式应用程序。

1.  d: Docker Swarm 通过 DNS 提供服务发现，为服务及其任务提供内部负载均衡，并为分布在不同节点上的服务和容器提供覆盖网络。

1.  b: 每个集群只有一个领导节点。领导节点是从可用的管理节点中选出的。当我们初始化集群时，第一个节点将是领导节点，直到需要进行新的选举为止。除非我们通过服务约束特别避免它们，否则所有管理节点都会运行工作负载。

1.  d: 角色可以根据需要进行更改，例如进行维护时。我们需要始终保持定义的奇数个管理节点，以避免集群不稳定。

1.  a 和 b: 默认情况下，Docker Swarm 将在其自身的网络上部署堆栈，除非另行指定。与待部署应用程序相关的所有内容必须在 Docker Compose 堆栈文件中进行配置。我们可以添加外部创建的组件，但它们必须在堆栈部署之前就存在，并且我们将它们设置为外部组件，在基础设施即代码的堆栈文件中进行配置。

# 第九章

1.  a 和 b: Kubernetes 需要 etcd 才能工作。大多数 Kubernetes 部署解决方案会为你部署 etcd，但它是一个外部应用程序，因此由你来管理并确保该键值存储解决方案提供高可用性。Kubernetes 的内部网络开箱即用，但部署在不同主机上的组件之间的通信依赖于外部插件（CNI 标准）。因此，我们需要选择并部署一个解决方案来提供这种通信。

1.  b 和 c: 我们将在 Kubernetes 中部署 pods，因此它们是最小的部署单元。我们可以在一个 pod 中部署多个容器。Kubernetes 中的容器密度较高。扩展 pod 时，将一次性复制所有组件。

1.  d: 所有句子都正确。一个 pod 中的所有容器共享相同的 IP 地址和 localhost，它们也共享 pod 卷。在同一主机上运行的 pod 之间的连接不需要**容器网络接口**（**CNI**）。它们都可以通过虚拟 IP 地址进行访问。

1.  a、b 和 c: ReplicaSets 使我们能够管理复制的环境。部署将创建 ReplicaSets，并允许我们向上或向下扩展应用程序的 pods。它们还将根据所需的运行 pods 来维持应用程序的健康状态。DaemonSets 将确保每个集群节点上有一个副本。

1.  a: ClusterIP 服务类型仅提供对服务的内部访问。分配的 IP 地址无法从集群节点访问。

# 第十章

1.  c: Docker Machine 由 Docker 社区维护。

1.  a：Docker Enterprise 提供了一个受支持的企业级 CaaS 平台，支持 Kubernetes、**通用控制平面**（**UCP**）和 **Docker 受信注册表**（**DTR**，基于 Docker Registry 社区）。即使使用 Docker Enterprise Engine，我们也可以在生产环境中部署 Docker Swarm 并获得 Docker 的支持。

1.  a、b 和 d：Docker Enterprise 在我们部署 UCP 时提供 Kubernetes 开箱即用——我们不需要手动安装 Kubernetes。

1.  d：我们将为所有组件使用固定 IP 地址。我们将使用外部负载均衡器将流量转发到所有管理节点的 UCP 和所有运行 DTR 的工作节点的注册表。如果流量只转发到一个节点，则在该节点出现故障时将无法提供高可用性。Docker UCP 安装将默认为 Kubernetes 部署 Calico，但我们需要查看 `pod-cidr` 和 `service-cidr`，确保默认定义的子网在我们的环境中有效。

1.  c：为了提供工作负载的高可用性，我们将部署至少两个 Linux 节点。虽然可以在 UCP 管理节点上运行 DTR，但不推荐这样做，因为管理节点需要足够的资源来执行控制平面任务，而镜像扫描可能会影响集群的稳定性。我们还需要为应用程序的前端选择不同的端口，因为两者都使用端口 `443`。

# 第十一章

1.  b：正如我们所学，Docker Enterprise Engine 是安装 UCP 所必需的，它不会为我们自动安装。我们可以使用 Web UI、UCP 包和 UCP API 来管理我们的工作负载和集群配置。UCP 的 RBAC 系统将管理授权，但如果没有配置外部授权源或外部授权源不可用，它也会认证用户。

1.  b 和 d：Docker 提供了一个完整的 UCP 备份和恢复解决方案，使用 `docker/ucp` 镜像，但请记住，我们需要关注 Docker Swarm 的文件系统，因为它不包含在 UCP 的备份中。我们应根据我们的环境使用合适的 `docker/ucp` 镜像版本。实际上，除了升级以外，我们将使用相同的安装版本执行其他任何操作。可以通过 `docker/ucp` 镜像执行 UCP 卸载，这将从集群中所有节点移除 UCP 组件。然后，我们应该移除 `docker/ucp` 镜像。升级过程可以使用 `docker/ucp` 镜像自动完成，但这可能会影响用户。我们通常会先自动升级 UCP 管理节点，然后在工作节点上手动执行升级步骤。

1.  a 和 b：我们可以使用 `--controller-port` 和 `-kube-apiserver-port` 来修改 UCP 控制器和 Kubernetes 的 API 服务器端口。我们还可以通过在多宿主机上选择不同的接口，使用 `--data-path-addr` 来隔离控制平面和数据平面。**主题别名名称** (**SANs**) 将为 UCP 的证书添加别名。我们可以通过多次使用 `--san` 来为我们的环境添加所有需要的别名。

1.  a、c 和 d：UCP 在 Docker Swarm 上部署一个具有高可用性的 Kubernetes 集群。由于 UCP 部署在 Docker Swarm 上，我们至少需要三个节点来提供高可用性。所有管理节点将运行相同的控制平面进程，并且需要一个外部负载均衡器来分配它们之间的访问。这需要透明代理配置，以允许管理节点管理加密通信。我们将使用 `/_ping` 端点来验证管理节点的健康状况，并可以在负载均衡器上用作后端健康检查。

1.  a 和 c：UCP 提供 **None**、**View Only**、**Restricted Control**、**Scheduler** 和 **Full Control**。我们可以创建新的角色，但默认情况下没有特权或管理员角色。Docker Enterprise 管理员并不作为角色定义。用户属性中有一个复选框可以启用此功能。只有管理员才能创建授权、用户、团队、组织和集合。

# 第十二章

1.  b 和 c：始终需要两个标签。我们需要确保 Interlock 使用 `com.docker.lb.hosts` 和 `com.docker.lb.port` 转发服务的请求。这些标签将包含所有必要的信息，但如果服务的实例连接到多个网络，推荐并要求使用 `com.docker.lb.network`。我们需要指定应该使用哪个网络作为入口。

1.  b：Interlock 解决方案基于一个名为 `interlock` 的主进程，负责管理外部代理服务和配置，还有一个 `interlock-proxy` 服务，如果没有指定外部负载均衡器，该服务将在 Docker Enterprise 环境内运行。这三个进程作为服务在 Docker Swarm 中运行，并且它们的前缀是 `ucp-`。`ucp-interlock-controller` 并不存在。

1.  d：默认情况下，只有 `ucp-interlock` 服务会根据节点的角色来定位。所有其他组件可以在任何地方运行。我们将使用位置约束在工作节点上运行 `ucp-interlock-proxy` 和 `ucp-interlock-extension` 组件。

1.  a、b 和 c：Interlock 允许我们管理 `ucp-interlock-proxy` 上的 SSL/TLS 隧道，或将其配置为透明代理。在这种情况下，我们的服务后端应该管理 SSL/TLS 证书。Interlock 与 Docker API 进行交互，所有更改将自动更新到 Interlock 的代理组件。Interlock 是一个七层负载均衡器；反向代理、TCP 和 UDP 协议应该通过路由网格或主机模式发布。

1.  a 和 b：Ingress 控制器和 Interlock 具有相同的逻辑，使用少数公开端口。它们将使用负载均衡和反向代理功能来管理所有的入口流量。我们不会直接发布应用程序。没有应用程序的服务需要直接暴露。Ingress 控制器（和 Interlock）将被暴露，并且它们将把请求路由到应用程序定义的服务。Interlock 需要与应用程序的服务交互，因此它必须连接到这些服务的网络。这将自动发生。Docker Enterprise 将把 `interlock-proxy` 服务连接到我们的应用程序网络。

# 第十三章

1.  b：此列表仅显示一个有效功能。DTR 提供仓库镜像。既不提供仓库负载均衡，也不提供仓库签名功能。我们不对仓库进行签名。我们对仓库的镜像/标签进行签名。

1.  b：DTR 不管理镜像的数据高可用性。部署多个副本将为 DTR 的进程提供高可用性。DTR 的复制需要副本之间的数据共享，但我们必须包含第三方解决方案来为我们的存储提供高可用性。

1.  a 和 b：DTR 安装会运行 `dtr-garant` 和 `dtr-jobrunner` 容器。第一个容器将管理用户身份验证，而 jobrunner 将执行 DTR 的维护任务，以删除未引用的层。`dtr-notary-server` 和 `dtr-notary-signer` 将部署在 DTR 中，以管理 Docker 内容信任元数据。

1.  d：所有问题的句子都描述了部署具有高可用性的 DTR 所需的步骤。

1.  a：DTR 备份不包括镜像的层。这可能包含大量数据，而这些数据是恢复镜像的关键。你应该为这些数据准备第三方解决方案。另一方面，仓库元数据、RBAC 配置和镜像的签名将存储在你的备份 TAR 文件中。

# 考试答案

1 - b 和 c

2 - c

3 - b

4 - a、b 和 c

5 - b

6 - c

7 - a

8 - a、c 和 d

9 - c

10 - a 和 c

11 - b

12 - a

13 - d

14 - b

15 - c

16 - a、b 和 c

17 - a、b 和 c

18 - a

19 - b 和 c

20 - a 和 b

21 - d

22 - c

23 - b、c 和 d

24 - c 和 d

25 - a、c 和 d

26 - a 和 c

27 - c

28 - c

29 - c

30 - b

31 - d

32 - a 和 b

33 - d

34 - b 和 c

35 - d

36 - b

37 - a

38 - c

39 - c

40 - a 和 b

41 - a 和 b

42 - b 和 c

43 - a 和 c

44 - c

45 - a 和 c

46 - b

47 - d

48 - b、c 和 d

49 - a 和 b

50 - a

51 - a

52 - a、b 和 c

53 - b

54 - a

55 - c

56 - b

57 - c 和 d

58 - d

59 - d

60 - b

61 - a

62 - b 和 c

63 - b

64 - b

65 - a

66 - a、b 和 c

67 - b

68 - a 和 b

69 - a

70 - b 和 d
