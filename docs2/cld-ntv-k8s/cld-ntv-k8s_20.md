# 评估

# 第一章 – 与 Kubernetes 进行通信

1.  容器编排是一种软件模式，在这种模式下，多个容器被控制和调度以服务于应用程序。

1.  Kubernetes API 服务器（`kube-apiserver`）处理更新 Kubernetes 资源的请求。调度器（`kube-scheduler`）决定将容器放置（调度）到哪里。控制器管理器（`kube-controller-manager`）确保 Kubernetes 资源的所需配置在集群中得到体现。`etcd` 提供集群配置的数据存储。

1.  `kube-apiserver` 必须使用 `--authorization-mode=ABAC` 和 `--authorization-policy-file=filename` 参数启动。

1.  为了控制平面的高可用性，以防其中一个主节点发生故障。

1.  如果资源已经创建，`kubectl create` 将失败，因为资源已经存在，而 `kubectl apply` 将尝试将任何 YAML 更改应用到该资源。

1.  `kubectl use-context` 命令可用于在 `kubeconfig` 文件中切换多个上下文。要在 `kubeconfig` 文件之间切换，可以将 `KUBECONFIG` 环境变量设置为新文件的路径。

1.  强制命令不提供资源更改的历史记录。

# 第二章 – 设置你的 Kubernetes 集群

1.  Minikube 使得设置本地 Kubernetes 集群进行开发变得更加容易。

1.  在某些情况下，集群可能存在一个固定的最低成本，这个成本比自我配置的集群要高。一些托管选项除了计算成本外，还有许可证费用。

1.  Kubeadm 对基础设施提供商是中立的，而 Kops 仅支持几个主要提供商，并且具有更深的集成和计算资源配置能力。

1.  截至本书编写时，AWS、Google Cloud Platform、Digital Ocean、VMware 和 OpenStack，处于不同的生产就绪阶段。

1.  通常，集群组件在 `systemd` 服务定义中被定义，这样可以在节点关闭并在操作系统级别重新启动时自动重启服务。

# 第三章 – 在 Kubernetes 上运行应用容器

1.  如果你有开发、预发布和生产环境，你可以为每个环境创建一个命名空间。

1.  Pod 所在的节点可能处于 *故障* 状态，控制平面无法访问该节点。通常，当节点优雅地退出集群时，Pod 会被重新调度，而不会显示 *未知* 状态。

1.  防止占用大量内存的 Pod 占用整个节点，并导致该节点上其他 Pod 的不可预测行为。

1.  如果你有 *启动* 探针，应该增加更多的延迟。如果没有，你需要添加一个，或者增加 *就绪* 探针的延迟。

# 第四章 – 扩展和部署你的应用程序

1.  ReplicationControllers 在选择器的配置方式上灵活性较差 – 只允许使用键值选择器。

1.  部署允许你指定如何推出更新。

1.  Jobs 非常适合批处理任务，或者那些可以通过清晰的完成目标水平扩展的任务。

1.  StatefulSets 提供了一个顺序的 Pod 标识符，当这些 Pod 重启时，该标识符保持不变。

1.  除了现有版本，还可以创建一个带有金丝雀版本的新部署。然后，两个版本可以并行访问。

# 第五章 – 服务与 Ingress – 与外部世界的通信

1.  你可以使用 ClusterIP 服务。

1.  你可以使用 `kubectl describe` 命令查看 NodePort 服务在节点上的哪个端口处于活动状态。

1.  在云环境中，通常需要为每个负载均衡器付费，而 Ingress 允许你指定多个路由规则，同时只需为一个负载均衡器付费。

1.  ExternalName 服务可以用于轻松地将流量路由到云环境中的其他基础设施组件，如托管数据库和对象存储。

# 第六章 – Kubernetes 应用配置

1.  Secrets 以编码形式存储，并可以选择加密存储在 `etcd` 中。ConfigMaps 以纯文本形式存储。

1.  它们是 Base64 编码的。

1.  在描述 ConfigMap 时，数据将更加可见。键值对模式在将 ConfigMap 挂载为环境变量时也更易于使用。

1.  根据你的集群设置，你的 secrets 可能根本没有加密。如果集群的 EncryptionConfiguration 没有设置，secrets 将仅进行 Base64 编码，并且可以很容易地解码。通过创建带有 EncryptionConfiguration 的集群，你的 secrets 将加密存储在 `etcd` 中。这并不是一种安全万能方案，但静态加密无疑是提高 secrets 安全性所必需的。

# 第七章 – Kubernetes 上的存储

1.  Volumes 与 Pod 的生命周期相关联，Pod 被删除时，Volumes 也会被删除。而持久卷将在集群被删除或它们被特别删除之前一直存在。

1.  StorageClasses 定义了持久卷（Persistent Volume）的*类型*。它们可用于区分不同类型的存储，例如区分更快的 SSD 存储和较慢的硬盘，或不同类型的云存储。StorageClasses 决定了持久卷声明（PersistentVolumeClaim）和持久卷（Persistent Volume）将如何获取配置的存储。

1.  使用带有集成存储配置的托管 Kubernetes 服务，或将 **cloud-controller-manager** 配置添加到你的集群中。

1.  任何需要存储状态，且存储周期超过单个 Pod 生命周期的应用程序，都无法使用 Volumes。任何需要具有对 Pod 故障容忍性的状态的应用程序需要持久卷。

# 第八章 – Pod 放置控制

1.  节点选择器可以用来与节点标签匹配，多个节点可以满足要求。使用节点名称意味着你指定了 Pod 必须放置的单个节点。

1.  Kubernetes 实现了一些默认的污点，以确保 Pods 不会调度到出现故障或资源不足的节点上。此外，Kubernetes 还会对主节点进行污点处理，以防止在主节点上调度用户应用程序。

1.  过多的亲和性和反亲和性可能会拖慢调度器的速度，甚至导致其无响应。在有很多亲和性或反亲和性的情况下，确定 Pod 的调度位置是一个计算量非常大的过程。

1.  通过使用反亲和性，你可以阻止 Pods 在相同的故障域中与相似的 Pods 共存。位于同一故障域中的节点会被标记上故障域或区域标识符。反亲和性会查找与特定应用层级匹配的 Pods，并阻止其在与该故障域匹配的节点上调度。最终结果是，三层应用程序的每个层级都会分布在多个故障域之间。

# 第九章 – Kubernetes 上的可观察性

1.  指标是对应于数值的内容，展示了多个类别下应用程序/计算性能和/或使用情况，包括磁盘、CPU、内存、延迟等。日志则对应于应用程序、节点或控制平面的文本日志。

1.  Grafana UI 高度可定制，可以用来以优雅且灵活的方式展示复杂的 Prometheus（或其他数据源）的查询结果。

1.  FluentD 需要在生产集群上运行以收集日志。Elasticsearch 和 Kibana 可以运行在一个单独的集群或其他基础设施上。

# 第十章 – Kubernetes 故障排除

1.  Kubernetes 的一大优势是可以通过添加节点或使用诸如污点和容忍度等控制手段轻松地扩展集群，或者改变 Pod 的调度位置。此外，Pod 的重启可能会导致相同应用程序使用完全不同的 IP，这意味着计算和网络拓扑可以是不断变化的。

1.  `kubelet` 通常作为 Linux 服务运行，并使用 `systemd` 管理，可以通过 `systemctl` 控制，日志则保存在 `journalctl` 中。

1.  有几种不同的方法可以使用，但通常，你需要检查所有节点是否准备好并可调度；是否有任何 Pod 调度控制阻止了 Pod 的调度；以及是否存在缺失的存储、ConfigMaps 或密钥等依赖项。

# 第十一章 – Kubernetes 上的模板代码生成与 CI/CD

1.  Helm Charts 使用模板和变量，而 Kustomize 则采用基于补丁的策略。Kustomize 被集成在 kubectl 的最新版本中，而 Helm 使用的是一个单独的 CLI 工具。

1.  配置应侧重于安全性，因为部署凭证可能会被用来将攻击者的工作负载部署到集群中。使用安全的环境变量或云服务提供商的访问管理控制是两种有效的策略。凭证绝对不应放在任何 Git 仓库中。

1.  集群内设置通常更为优选，因为不需要外部系统提供 Kubernetes 凭证。集群外设置通常较为简单，并且比集群内设置更为同步，后者由控制循环决定何时对资源配置进行更改。

# 第十二章 – Kubernetes 安全性和合规性

1.  MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。

1.  一个没有 Pod 选择器的 NetworkPolicy 会选中所有 Pod。如果选择所有 Pod，并且未添加任何规则的情况下添加了 Ingress 和 Egress 类型，则该 NetworkPolicy 会自动拒绝该命名空间中所有 Pod 的所有入站和出站流量。

1.  我们希望追踪所有 API 请求，这些请求涉及资源的修补或更新，因为攻击者可能会使用恶意容器更新 Deployment、Pod 或其他资源。

# 第十三章 – 使用 CRD 扩展 Kubernetes

1.  存储版本是实际存储在数据存储中的版本。服务版本是 API 接受的任何版本，用于读写操作。服务版本在存储到`etcd`时会被转换为存储版本。

1.  测量、分析和更新（通常）。

1.  根据云服务提供商的不同，**cluster-autoscaler** 插件会直接更新自动伸缩组，以便添加或移除节点。

# 第十四章 – 服务网格和无服务器架构

1.  静态 Envoy 配置是指由用户手动创建或编写的 Envoy 配置。动态 Envoy 配置（如 Istio 提供的配置）会不断适应来自外部控制器或数据平面的新容器，以及新的路由和过滤规则。

1.  监听器、路由、集群和端点。

1.  Knative 运行需要多个组件。这提供了丰富的定制化选项，但也使得其配置和操作比 OpenFaaS 更加复杂。

# 第十五章 – 在 Kubernetes 上运行有状态工作负载

1.  Minio 是一个兼容 AWS S3 的存储工具。

1.  StatefulSets 通过为分布式数据库等自聚类应用提供稳定的、顺序的 Pod 标识符，以及持久化存储稳定性，来协助这些应用。

1.  在 Kubernetes 中，Pod 的生命周期可能较短，而有状态应用可以是分布式的。这意味着，在 Pod 的身份发生变化，且存储需要从零开始复制的情况下，维护 Pod 之间状态的过程（例如数据库一致性）可能变得十分复杂。
