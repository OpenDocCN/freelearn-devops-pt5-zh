- en: '*Chapter 2*: Introducing Docker'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how the modern **continuous delivery** (**CD**)
    process looks by introducing Docker, the technology that changed the **information
    technology** (**IT**) industry and the way servers are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Docker hello-world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker container states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using names in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker commands overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you''ll need to meet the following hardware/software
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: At least 4 **gigabytes** (**GB**) of **random-access memory** (**RAM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 10.15+, Windows 10/11 Pro 64-bit, Ubuntu 20.04+, or other Linux operating
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and solutions to the exercises can be found at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3LJv1n6](https://bit.ly/3LJv1n6).
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is an open source project designed to help with application deployment
    using software containers. This approach means running applications together with
    the complete environment (files, code libraries, tools, and so on). Therefore,
    Docker—similar to virtualization—allows an application to be packaged into an
    image that can be run everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization versus virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without Docker, isolation and other benefits can be achieved with the use of hardware virtualization,
    often called **virtual machines** (**VMs**). The most popular solutions are VirtualBox,
    VMware, and parallels. A VM emulates a computer architecture and provides the
    functionality of a physical computer. We can achieve complete isolation of applications
    if each of them is delivered and run as a separate VM image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram presents the concept of virtualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Virtualization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_01.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Virtualization
  prefs: []
  type: TYPE_NORMAL
- en: 'Each application is launched as a separate image with all dependencies and
    a guest operating system. Images are run by the **hypervisor**, which emulates
    the physical computer architecture. This method of deployment is widely supported
    by many tools (such as Vagrant) and dedicated to development and testing environments.
    Virtualization, however, has three significant drawbacks, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low performance**: The VM emulates the whole computer architecture to run
    the guest operating system, so there is a significant overhead associated with
    executing each operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High resource consumption**: Emulation requires a lot of resources and has
    to be done separately for each application. This is why, on a standard desktop
    machine, only a few applications can be run simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large image size**: Each application is delivered with a full operating system,
    so deployment on a server implies sending and storing a large amount of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The concept of containerization presents a different solution, as we can see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Containerization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Containerization
  prefs: []
  type: TYPE_NORMAL
- en: Each application is delivered together with its dependencies, but without the
    operating system. Applications interface directly with the host operating system,
    so there is no additional layer of the guest operating system. This results in
    better performance and no wasted resources. Moreover, shipped Docker images are
    significantly smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, in the case of containerization, isolation happens at the level
    of the host operating system's processes. This doesn't mean, however, that the
    containers share their dependencies. Each of them has its own libraries in the
    right version, and if any of them is updated, it has no impact on the others.
    To achieve this, Docker Engine creates a set of Linux namespaces and control groups
    for the container. This is why Docker security is based on Linux kernel process
    isolation. This solution, although mature enough, could be considered slightly
    less secure than the complete operating system-based isolation offered by VMs.
  prefs: []
  type: TYPE_NORMAL
- en: The need for Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker containerization solves a number of problems seen in traditional software
    delivery. Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing and running software is complex. You need to make decisions about
    the operating system, resources, libraries, services, permissions, other software,
    and everything your application depends on. Then, you need to know how to install
    it. What's more, there may be some conflicting dependencies. *What do you do then?* *What
    if your software needs an upgrade of a library, but the other resources do not?* In
    some companies, such issues are solved by having *classes of applications*, and
    each class is served by a dedicated server, such as a server for web services
    with Java 7, and another one for batch jobs with Java 8\. This solution, however,
    is not balanced in terms of resources and requires an army of IT operations teams
    to take care of all the production and test servers.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the environment's complexity is that it often requires
    a specialist to run an application. A less technical person may have a hard time
    setting up MySQL, **Open Database Connectivity** (**ODBC**), or any other slightly
    more sophisticated tool. This is particularly true for applications not delivered
    as an operating system-specific binary but that require source code compilation
    or any other environment-specific configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep the workspace tidy. One application can change the behavior of another
    one. Imagine what could happen. Applications share one filesystem, so if application
    *A* writes something to the wrong directory, application *B* reads the incorrect
    data. They share resources, so if there is a memory leak in application *A*, it
    can freeze not only itself but also application *B*. They share network interfaces,
    so if applications *A* and *B* both use port `8080`, one of them will crash. Isolation
    concerns the security aspects, too. Running a buggy application or malicious software
    can cause damage to other applications. This is why it is a much safer approach
    to keep each application inside a separate sandbox, which limits the scope of
    possible damage to the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Servers often end up looking messy, with a ton of running applications nobody
    knows anything about. *How will you check which applications are running on the
    server and which dependencies each of them is using?* They could depend on libraries,
    other applications, or tools. Without the exhaustive documentation, all we can
    do is look at the running processes and start guessing. Docker keeps things organized
    by having each application as a separate container that can be listed, searched,
    and monitored.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Write once, run anywhere*, said the slogan while advertising the earliest
    versions of Java. Indeed, Java addresses the portability issue quite well. However,
    I can still think of a few cases where it fails; for example, the incompatible
    native dependencies or the older version of the Java Runtime. Moreover, not all
    software is written in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker moves the concept of portability one level higher; if the Docker version
    is compatible, the shipped software works correctly, regardless of the programming
    language, operating system, or environment configuration. Docker, then, can be
    expressed by the following slogan: *Ship the entire environment instead of just
    code*.
  prefs: []
  type: TYPE_NORMAL
- en: Kittens and cattle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between traditional software deployment and Docker-based deployment
    is often expressed with an analogy of kittens and cattle. Everybody likes kittens.
    Kittens are unique. Each has its own name and needs special treatment. Kittens
    are treated with emotion. We cry when they die. On the contrary, cattle exist
    only to satisfy our needs. Even the form *cattle* is singular since it's just
    a pack of animals treated together—no naming, no uniqueness. Surely, they are
    unique (the same as each server is unique), but this is irrelevant. This is why
    the most straightforward explanation of the idea behind Docker is *treat your
    servers like cattle, not pets*.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative containerization technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is not the only containerization system available on the market. Actually,
    the first versions of Docker were based on the open source **Linux Containers** (**LXC**)
    system, which is an alternative platform for containers. Other known solutions
    are **Windows Server containers**, **OpenVZ**, and **Linux Server**. Docker, however,
    overtook all other systems because of its simplicity, good marketing, and startup
    approach. It works under most operating systems, allows you to do something useful
    in less than 15 minutes, and has a lot of simple-to-use features, good tutorials,
    a great community, and probably the best logo in the IT industry!
  prefs: []
  type: TYPE_NORMAL
- en: 'We already understand the idea of Docker, so let''s move on to the practical
    part and start from the beginning: Docker installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker's installation process is quick and simple. Currently, it's supported
    on most Linux operating systems, and a wide range of them have dedicated binaries
    provided. macOS and Windows are also well supported with native applications.
    However, it's important to understand that Docker is internally based on the Linux
    kernel and its specifics, and this is why, in the case of macOS and Windows, it
    uses VMs (HyperKit for macOS and Hyper-V for Windows) to run the Docker Engine
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker Community Edition requirements are specific for each operating system,
    as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**macOS**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 10.15 or newer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 4 GB of RAM
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No VirtualBox prior to version 4.3.30 installed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64-bit Windows 10/11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hyper-V package enabled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 4 GB of RAM
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64-bit architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel 3.10 or later
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If your machine does not meet these requirements, the solution is to use **VirtualBox** with
    the Ubuntu operating system installed. This workaround, even though it sounds
    complicated, is not necessarily the worst method, especially considering that
    the Docker Engine environment is virtualized anyway in the case of macOS and Windows.
    Furthermore, Ubuntu is one of the best-supported systems for using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: All examples in this book have been tested on the Ubuntu 20.04 operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on a local machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker installation process is straightforward and is described in detail
    on its official page: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to use Docker in your local environment is to install Docker
    Desktop. This way, in just a few minutes, you have a complete Docker development
    environment all set up and running. For Windows and macOS users, Docker Desktop
    provides a native application that hides all the setup difficulties behind the
    scenes. Technically, Docker Engine is installed inside a VM because Docker requires
    the Linux kernel to operate. Nevertheless, as a user, you don''t even need to
    think about this—you install Docker Desktop and you are ready to start using the
    `docker` command. You can see an overview of Docker Desktop in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Docker Desktop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Docker Desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from Docker Engine, Docker Desktop provides a number of additional features,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A **user interface** (**UI**) to display images, containers, and volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic Docker updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume mounting with the local filesystem integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Windows) Support for Windows containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Windows) Integration with **Windows Subsystem for Linux** (**WSL**)/**WSL version
    2** (**WSL2**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please visit [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    for Docker Desktop installation guides.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Docker for Ubuntu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/) to
    find a guide on how to install Docker on an Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Ubuntu 20.04, I''ve executed the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After all operations are completed, Docker should be installed. However, at
    the moment, the only user allowed to use Docker commands is `root`. This means
    that the `sudo` keyword must precede every Docker command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enable other users to use Docker by adding them to the `docker` group,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After a successful logout, everything is set up. With the latest command, however,
    we need to take some precautions not to give the Docker permissions to an unwanted
    user and thereby create a vulnerability in the Docker Engine environment. This
    is particularly important in the case of installation on the server machine.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for other Linux distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker supports most Linux distributions and architectures. For details, please
    check the official page at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Docker installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No matter which installation you''ve chosen (macOS, Windows, Ubuntu, Linux,
    or something else), Docker should be set up and ready. The best way to test it
    is to run the `docker info` command. The output message should be similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing on a server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use Docker over the network, it's possible to either take advantage
    of cloud platform providers or manually install Docker on a dedicated server.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, the Docker configuration differs from one platform to another,
    but it is always very well described in dedicated tutorials. Most cloud platforms
    enable Docker hosts to be created through user-friendly web interfaces or describe
    exact commands to execute on their servers.
  prefs: []
  type: TYPE_NORMAL
- en: The second case (installing Docker manually) does require a few words, however.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing Docker manually on a server does not differ much from the local installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional steps are required, which include setting the Docker daemon
    to listen on the network socket and setting security certificates. These steps
    are described in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, due to security reasons, Docker runs through a non-networked Unix
    socket that only allows local communication. It''s necessary to add listening
    on the chosen network interface socket so that external clients can connect. In
    the case of Ubuntu, the Docker daemon is configured by `systemd`, so, in order
    to change the configuration of how it''s started, we need to modify one line in
    the `/lib/systemd/system/docker.service` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By changing this line, we enabled access to the Docker daemon through the specified
    `systemd` configuration can be found at [https://docs.docker.com/config/daemon/systemd/](https://docs.docker.com/config/daemon/systemd/).
  prefs: []
  type: TYPE_NORMAL
- en: This step of server configuration concerns Docker security certificates. This
    enables only clients authenticated by a certificate to access the server. A comprehensive
    description of the Docker certificate configuration can be found at [https://docs.docker.com/engine/security/protect-access/](https://docs.docker.com/engine/security/protect-access/).
    This step isn't strictly required; however, unless your Docker daemon server is
    inside a firewalled network, it is essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your Docker daemon is run inside a corporate network, you have to configure
    the **HyperText Transfer Protocol** (**HTTP**) proxy. A detailed description can
    be found at [https://docs.docker.com/config/daemon/systemd/](https://docs.docker.com/config/daemon/systemd/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Docker environment is set up and ready, so we can start the first example.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker hello-world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter the following command into your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You''ve just run your first Docker container. I hope you can
    already see how simple Docker is. Let''s examine what happened under the hood,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You ran the Docker client with the `run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker client contacted the Docker daemon and asked to create a container
    from the image called `hello-world`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon checked whether it contained the `hello-world` image locally
    and, since it didn't, requested the `hello-world` image from the remote Docker
    Hub registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker Hub registry contained the `hello-world` image, so it was pulled into
    the Docker daemon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon created a new container from the `hello-world` image that
    started the executable producing the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon streamed this output to the Docker client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker client sent it to your Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The projected flow is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Steps of the docker run command execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Steps of the docker run command execution
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at each Docker component that was illustrated in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is actually an ecosystem that includes a number of components. Let's
    describe all of them, starting with a closer look at the Docker client-server
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Docker client and server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram, which presents the Docker Engine architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Docker client-server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Docker client-server architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Engine consists of the following three components:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Docker daemon** (server) running in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Docker Client** running as a command tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Docker REpresentational State Transfer (REST) application programming interface
    (API)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker means installing all the components so that the Docker daemon
    runs on our computer all the time as a service. In the case of the `hello-world` example,
    we used the Docker client to interact with the Docker daemon; however, we could
    do exactly the same thing using the REST API. Also, in the case of the `hello-world` example,
    we connected to the local Docker daemon. However, we could use the same client
    to interact with the Docker daemon running on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To run the Docker container on a remote machine, you can use the `-H` option: `docker
    -H <server_ip>:2375 run hello-world`.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images and containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **image** is a stateless building block in the Docker world. You can think
    of an image as a collection of all the files necessary to run your application,
    together with the recipe on how to run it. An image is stateless, so you can send
    it over the network, store it in the registry, name it, version it, and save it
    as a file. Images are layered, which means that you can build an image on top
    of another image.
  prefs: []
  type: TYPE_NORMAL
- en: A container is a running instance of an image. We can create many containers
    from the same image if we want to have many instances of the same application.
    Since containers are stateful, this means we can interact with them and make changes
    to their states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of a **container** and **image** layered
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Layered structure of Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Layered structure of Docker images
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, there is always the base image. In most cases, this represents
    an operating system, and we build our images on top of the existing base images.
    It's technically possible to create your own base images; however, this is rarely
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `ubuntu` base image provides all the capabilities of the
    Ubuntu operating system. The `add git` image adds the Git toolkit. Then, there
    is an image that adds the `add JDK` image. Such a container is able, for example,
    to download a Java project from the GitHub repository and compile it to a **Java
    ARchive** (**JAR**) file. As a result, we can use this container to compile and
    run Java projects without installing any tools on our operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that layering is a very smart mechanism to save bandwidth
    and storage. Imagine that we have the following application that is also based
    on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Reusing layers of Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Reusing layers of Docker images
  prefs: []
  type: TYPE_NORMAL
- en: This time, we files will use the Python interpreter. While installing the `add
    python` image, the Docker daemon will note that the `ubuntu` image is already
    installed, and what it needs to do is only to add the Python layer, which is very
    small. So, the `ubuntu` image is a dependency that is reused. The same applies
    if we would like to deploy our image in the network. When we deploy the Git and
    JDK application, we need to send the whole `ubuntu` image. However, while subsequently
    deploying the Python application, we need to send just the small `add python` layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what the Docker ecosystem consists of, let's describe
    how we can run applications packaged as Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of applications are provided in the form of Docker images that can be
    downloaded from the internet. If we know the image name, it would be enough to
    run it in the same way we did with the hello-world example. *How can we find the
    desired application image on Docker Hub?* Let''s take **MongoDB** as an example.
    These are the steps we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to find it on Docker Hub, we have two options, a[s follows:](https://hub.docker.com/search/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Search on the Docke](https://hub.docker.com/search/)r Hub `docker search` command.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second case, we can perform the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many interesting options. *How do we choose the best image?* Usually,
    the most appealing one is the one without any prefix, since it means that it''s
    an official Docker Hub image and should therefore be stable and maintained. The
    images with prefixes are unofficial, usually maintained as open source projects.
    In our case, the best choice seems to be `mongo`, so in order to run the MongoDB
    server, we can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all we need to do. MongoDB has started. Running applications as Docker
    containers is that simple because we don't need to think of any dependencies;
    they are all delivered together with the image. Docker can be treated as a useful
    tool to run applications; however, the real power lies in building your own Docker
    images that wrap the programs together with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: On the Docker Hub service, you can find a lot of applications; they store millions
    of different images.
  prefs: []
  type: TYPE_NORMAL
- en: Building Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how to build Docker images using two different
    methods: the `docker` `commit` command and a Dockerfile automated build.'
  prefs: []
  type: TYPE_NORMAL
- en: docker commit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with an example and prepare an image with the Git and JDK toolkits.
    We will use Ubuntu 20.04 as a base image. There is no need to create it; most
    base images are available in the Docker Hub registry. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a container from `ubuntu:20.04` and connect it to its command line, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've pulled the `ubuntu:20.04` image, run it as a container, and then called
    the `/bin/bash` command in an interactive way (`-i` flag). You should see the
    Terminal of the container. Since containers are stateful and writable, we can
    do anything we want in its Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Git toolkit, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the Git toolkit is installed by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check what has changed in the container by comparing its unique container `ubuntu` image,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command should print a list of all files changed in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit the container to the image, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ve just created our first Docker image. Let''s list all the images of our
    Docker host to see whether the image is present, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we see `hello-world`, `mongo` (installed before), `ubuntu` (the
    base image pulled from Docker Hub), and the freshly built `ubuntu_with_git` image.
    By the way, we can observe that the size of each image corresponds to what we've
    installed on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we create a container from the image, it will have the Git tool installed,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating each Docker image manually with the `commit` command could be laborious,
    especially in the case of build automation and the CD process. Luckily, there
    is a built-in language to specify all the instructions that should be executed
    to build a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example similar to the one with Git. This time, we will
    prepare an `ubuntu_with_python` image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory and a file called `Dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to create an `ubuntu_with_python` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the image was created by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now create a container from the image and check that the Python interpreter
    exists in exactly the same way we did after executing the `docker commit` command.
    Note that the `ubuntu` image is listed only once even though it's the base image
    for both `ubuntu_with_git` and `ubuntu_with_python`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we used the first two Dockerfile instructions, as outlined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM` defines an image on top of which the new image will be built'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN` specifies the commands to run inside the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other widely used instructions are detailed as follows:.
  prefs: []
  type: TYPE_NORMAL
- en: '`COPY/ADD` copies a file or a directory into the filesystem of the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` defines which application should be run in the executable container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete guide of all Dockerfile instructions can be found on the official
    Docker page at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs: []
  type: TYPE_NORMAL
- en: Complete Docker application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have all the information necessary to build a fully working application
    as a Docker image. As an example, we will prepare, step by step, a simple Python
    `hello-world` program. The steps are always the same, no matter which environment
    or programming language we use.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new directory and, inside this directory, create a `hello.py` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Close the file. This is the source code of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our environment will be expressed in the Dockerfile. We need instructions to
    define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which base image should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install the Python interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to include `hello.py` in the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to start the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same directory, create the Dockerfile, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Building the image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can build the image exactly the same way we did before, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We run the application by running the container, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should see a friendly **Hello World from Python!** message. The most interesting
    thing in this example is that we are able to run the application written in Python
    without having the Python interpreter installed in our host system. This is possible
    because the application packed as an image has the environment already included.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: An image with the Python interpreter already exists in the Docker Hub service,
    so in a real-life scenario, it would be enough to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've run our first homemade Docker application. However, *what if the execution
    of the application depends on some conditions?*
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the case of the production server, we would like to print `Hello` to
    the logs, not to the console, or we may want to have different dependent services
    during the testing phase and the production phase. One solution would be to prepare
    a separate Dockerfile for each case; however, there is a better way: environment
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `hello-world` application to print `Hello World from <name_passed_as_environment_variable>
    !`. In order to do this, we need to proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `hello.py` Python script to use the environment variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the image, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the container passing the environment variable, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can define an environment variable value in Dockerfile, such
    as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the container without specifying the `-e` option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Environment variables are especially useful when we need to have different versions
    of the Docker container depending on its purpose; for example, to have separate
    profiles for production and testing servers.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: If an environment variable is defined both in the Dockerfile and as a flag,
    then the flag takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application we've run so far was supposed to do some work and stop—for
    example, we've printed `Hello from Docker!` and exited. There are, however, applications
    that should run continuously, such as services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a container in the background, we can use the `-d` (`--detach`) option.
    Let''s try it with the `ubuntu` image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command started the Ubuntu container but did not attach the console to
    it. We can see that it''s running by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command prints all containers that are in a **running** state. *What about
    our old, already exited containers?* We can find them by printing all containers,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that all the old containers are in an **exited** state. There are two more
    states we haven't observed yet: **paused** and **restarting**.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the states and the transitions between them are presented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Docker container states'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Docker container states
  prefs: []
  type: TYPE_NORMAL
- en: Pausing Docker containers is very rare, and technically, it's done by freezing
    the processes using the `SIGSTOP` signal. Restarting is a temporary state when
    the container is run with the `--restart` option to define a restarting strategy
    (the Docker daemon is able to automatically restart the container in case of failure).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram also shows the Docker commands used to change the Docker
    container state from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can stop running the Ubuntu container, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: We've always used the `docker run` command to create and start a container.
    However, it's possible to just create a container without starting it (with `docker
    create`).
  prefs: []
  type: TYPE_NORMAL
- en: Having grasped the details of Docker states, let's describe the networking basics
    within the Docker world.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications these days do not run in isolation; they need to communicate
    with other systems over the network. If we want to run a website, web service,
    database, or cache server inside a Docker container, we need to first understand
    how to run a service and expose its port to other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Running services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example and run a Tomcat server directly from Docker
    Hub, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tomcat is a web application server whose UI can be accessed by port `8080`.
    Therefore, if we installed Tomcat on our machine, we could browse it at `http://localhost:8080`.
    In our case, however, Tomcat is running inside the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started it the same way we did with the first `Hello World` example. We
    can see that it''s running, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s run as a daemon (with the `-d` option), we don''t see the logs
    in the console right away. We can, however, access it by executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If there are no errors, we should see a lot of logs, which indicates that Tomcat
    has been started and is accessible through port `8080`. We can try going to `http://localhost:8080`,
    but we won't be able to connect. This is because Tomcat has been started inside
    the container and we're trying to reach it from the outside. In other words, we
    can reach it only if we connect with the command to the console in the container
    and check it there. *How do we make running Tomcat accessible from outside?*
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start the container, specifying the port mapping with the `-p` (`--publish`)
    flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s first stop the running container and start a new one, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After waiting a few seconds, Tomcat should have started, and we should be able
    to open its page—`http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates how Docker container ports are published:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Publishing Docker container ports'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Publishing Docker container ports
  prefs: []
  type: TYPE_NORMAL
- en: Such a simple port mapping command is sufficient in most common Docker use cases.
    We are able to deploy (micro) services as Docker containers and expose their ports
    to facilitate communication. However, let's dive a little deeper into what happened
    under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Docker also allows us to publish to the specific host network interface with `-p
    <ip>:<host_port>:<container_port>`.
  prefs: []
  type: TYPE_NORMAL
- en: Container networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have connected to the application that is running inside the container. In
    fact, the connection is two-way because, if you remember from our previous examples,
    we executed the `apt-get install` commands from inside and the packages were downloaded
    from the internet. *How is this possible?*
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the network interfaces on your machine, you can see that one of
    the interfaces is called `docker0`, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker0` interface is created by the Docker daemon in order to connect
    with the Docker container. Now, we can see which interfaces are created inside
    the Tomcat Docker container created with the `docker inspect` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints all the information about the container configuration in **JavaScript
    Object Notation** (**JSON**) format. Among other things, we can find the part
    related to the network settings, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In order to filter the `docker inspect` response, we can use the `--format` option—for
    example, `docker inspect --format '{{ .NetworkSettings.IPAddress }}' <container_id>`.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe that the Docker container has an IP address of `172.17.0.2` and
    it communicates with the Docker host with an IP address of `172.17.0.1`. This
    means that in our previous example, we could access the Tomcat server even without
    the port forwarding, using `http://172.17.0.2:8080`. Nevertheless, in most cases,
    we run the Docker container on a server machine and want to expose it outside,
    so we need to use the `-p` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, by default, the containers don''t open any routes from external
    systems. We can change this default behavior by playing with the `--network` flag
    and setting it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bridge` (default): Network through the default Docker bridge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: No network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container`: Network joined with the other (specified) container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: Host''s network stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NETWORK`: User-created network (using the `docker network create` command)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The different networks can be listed and managed by the `docker network` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If we specify `none` as the network, we will not be able to connect to the container,
    and vice versa; the container has no network access to the external world. The `host` option
    makes the `bridge`) because it lets us define explicitly which ports should be
    published and is both secure and accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing container ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We mentioned a few times that the container exposes the port. In fact, if we
    dig deeper into the Tomcat image on GitHub ([https://github.com/docker-library/tomcat](https://github.com/docker-library/tomcat)),
    we can see the following line in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile instruction stipulates that port `8080` should be exposed from
    the container. However, as we have already seen, this doesn't mean that the port
    is automatically published. The `EXPOSE` instruction only informs users which
    ports they should publish.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic port assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try to run the second Tomcat container without stopping the first one,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This error may be common. In such cases, we have to either take care of the
    uniqueness of the ports on our own or let Docker assign the ports automatically
    using one of the following versions of the `publish` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-p <container_port>`: Publishes the container port to the unused host port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p` (`--publish-all`): Publishes all ports exposed by the container to the
    unused host ports, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the second Tomcat instance has been published to port `32772`,
    so it can be browsed at `http://localhost:32772`.
  prefs: []
  type: TYPE_NORMAL
- en: After understanding Docker network basics, let's see how to provide a persistence
    layer for Docker containers using Docker volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you would like to run a database as a container. You can start
    such a container and enter data. *Where is it stored?* *What happens when you
    stop the container or remove it?* You can start a new one, but the database will
    be empty again. Unless it's your testing environment, you'd expect to have your
    data persisted permanently.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Docker volume is the Docker host''s directory mounted inside the container.
    It allows the container to write to the host''s filesystem as if it were writing
    to its own. The mechanism is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Using a Docker volume'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Using a Docker volume
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker volumes enable the persistence and sharing of a container''s data. Volumes
    also clearly separate the processing from the data. Let''s start with the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify a volume with the `-v <host_path>:<container_path>` option and then
    connect to the container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an empty file in `host_directory` in the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the file was created in the Docker host''s filesystem by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that the filesystem was shared and the data was therefore persisted
    permanently. Stop the container and run a new one to see if our file will still
    be there, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of specifying a volume with the `-v` flag, it''s possible to specify
    it as an instruction in the Dockerfile, as in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, if we run the Docker container without the `-v` flag, the container's
    `/host_directory` path will be mapped into the host's default directory for volumes,
    `/var/lib/docker/vfs/`. This is a good solution if you deliver an application
    as an image and you know it requires permanent storage for some reason (for example,
    storing application logs).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: If a volume is defined both in a Dockerfile and as a flag, the `flag` command
    takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes can be much more complicated, especially in the case of databases.
    More complex use cases of Docker volumes are, however, outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: A very common approach to data management with Docker is to introduce an additional
    layer, in the form of data volume containers. A data volume container is a Docker
    container whose only purpose is to declare a volume. Then, other containers can
    use it (with the `--volumes-from <container>` option) instead of declaring the
    volume directly. Read more at [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/).
  prefs: []
  type: TYPE_NORMAL
- en: After understanding Docker volumes, let's see how we can use names to make working
    with Docker images/containers more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Using names in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, when we've operated on containers, we've always used autogenerated names.
    This approach has some advantages, such as the names being unique (no naming conflicts)
    and automatic (no need to do anything). In many cases, however, it's better to
    give a user-friendly name to a container or an image.
  prefs: []
  type: TYPE_NORMAL
- en: Naming containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two good reasons to name a container: convenience and the possibility
    of automation. Let''s look at why, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Convenience**: It''s simpler to make any operations on a container when addressing
    it by name than by checking the hashes or the autogenerated name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Sometimes, we would like to depend on the specific naming of
    a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, we would like to have containers that depend on each other and
    to have one linked to another. Therefore, we need to know their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'To name a container, we use the `--name` parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check (with `docker ps`) that the container has a meaningful name. Also,
    as a result, any operation can be performed using the container''s name, as in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Please note that when a container is named, it does not lose its identity. We
    can still address the container by its autogenerated hash ID, just as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: A container always has both an ID and a name. It can be addressed by either
    of them, and both are unique.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Images can be tagged. We already did this when creating our own images—for
    example, in the case of building the `hello_world_python` image, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` flag describes the tag of the image. If we don't use it, the image
    will be built without any tags and, as a result, we would have to address it by
    its ID (hash) in order to run the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image can have multiple tags, and they should follow this naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A tag consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registry_address`: IP and port of the registry or the alias name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_name`: Name of the image that is built—for example, `ubuntu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: A version of the image in any form—for example, `20.04`, `20170310`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover Docker registries in [*Chapter 5*](B18223_05_ePub.xhtml#_idTextAnchor133), *Automated
    Acceptance Testing*. If an image is kept on the official Docker Hub registry,
    we can skip the registry address. This is why we've run the `tomcat` image without
    any prefix. The last version is always tagged as the latest and it can also be
    skipped, so we've run the `tomcat` image without any suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'Images usually have multiple tags; for example, all these three tags are the
    same image: `ubuntu:18.04`, `ubuntu:bionic-20190122`, and `ubuntu:bionic`.'
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we need to learn how to clean up after playing with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have created a number of containers and images.
    This is, however, only a small part of what you will see in real-life scenarios.
    Even when containers are not running, they need to be stored on the Docker host.
    This can quickly result in exceeding the storage space and stopping the machine. How
    can we approach this concern?
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at the containers that are stored on our machine. Here are
    the steps we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To print all the containers (irrespective of their state), we can use the `docker
    ps -a` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to delete a stopped container, we can use the `docker rm` command
    (if a container is running, we need to stop it first), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to remove all stopped containers, we can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also adopt a different approach and ask the container to remove itself
    as soon as it has stopped by using the `--rm` flag, as in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In most real-life scenarios, we don't use stopped containers, and they are left
    only for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cleaning up images is just as important as cleaning up containers. They can
    occupy a lot of space, especially in the case of the CD process, when each build
    ends up in a new Docker image. This can quickly result in a *no space left on
    device* error. The steps are as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check all the images in the Docker container, we can use the `docker images` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove an image, we can call the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the case of images, the automatic cleanup process is slightly more complex.
    Images don''t have states, so we cannot ask them to remove themselves when not
    used. A common strategy would be to set up a cron cleanup job, which removes all
    old and unused images. We could do this using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the cleaning up section, we've come to the end of the main Docker description.
    Now, let's do a short wrap-up and walk through the most important Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Use the `docker system prune` command to remove all unused containers, images,
    and networks. Additionally, you can add the `–volumes` parameter to clean up volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All Docker commands can be found by executing the following `help` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all the options of any particular Docker command, we can use `docker
    help <command>`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: There is also a very good explanation of all Docker commands on the official
    Docker page at [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/).
    It's worth reading, or at least skimming, through.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve covered the most useful commands and their options.
    As a quick reminder, let''s walk through them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18223_02_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Docker basics, which is enough for building
    images and running applications as containers. Here are the key takeaways.
  prefs: []
  type: TYPE_NORMAL
- en: The containerization technology addresses the issues of isolation and environment
    dependencies using Linux kernel features. This is based on a process separation
    mechanism, so, therefore, no real performance drop is observed. Docker can be
    installed on most systems but is supported natively only on Linux. Docker allows
    us to run applications from images available on the internet and to build our
    own images. An image is an application packed together with all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides two methods for building images—a Dockerfile or committing a
    container. In most cases, the first option is used. Docker containers can communicate
    over the network by publishing the ports they expose. Docker containers can share
    persistent storage using volumes. For the purpose of convenience, Docker containers
    should be named, and Docker images should be tagged. In the Docker world, there
    is a specific convention for how to tag images. Docker images and containers should
    be cleaned from time to time in order to save on server space and avoid *no space
    left on device* errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the Jenkins configuration and find out
    how Jenkins can be used in conjunction with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a lot of material in this chapter. To consolidate what we have
    learned, we recommend the following two exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `CouchDB` as a Docker container and publish its port, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the `docker search` command to find the `CouchDB` image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the container.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the `CouchDB` port.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the browser and check that `CouchDB` is available.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Docker image with a REST service, replying `Hello World` to `localhost:8080/hello`.
    Use any language and framework you prefer. Here are the steps you need to follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The easiest way to create a REST service is to use Python with the Flask framework
    ([https://flask.palletsprojects.com/](https://flask.palletsprojects.com/)). Note
    that a lot of web frameworks, by default, start an application only on the localhost
    interface. In order to publish a port, it's necessary to start it on all interfaces
    (`app.run(host='0.0.0.0')` in the case of a Flask framework).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a web service application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Dockerfile to install dependencies and libraries.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the image.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the container that is publishing the port.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that it's running correctly by using the browser (or `curl`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To verify the knowledge acquired from this chapter, please answer the following
    questionsUse L-numbering for this list
  prefs: []
  type: TYPE_NORMAL
- en: What is the main difference between containerization (such as with Docker) and
    virtualization (such as with VirtualBox)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of providing an application as a Docker image? Name at
    least two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the Docker daemon be run natively on Windows and macOS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a Docker image and a Docker container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean when saying that Docker images have layers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two methods of creating a Docker image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to create a Docker image from a Dockerfile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to run a Docker container from a Docker image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Docker terminology, what does it mean to publish a port?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Docker volume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re interested in getting a deeper understanding of Docker and related
    technologies, please have a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker documentation—*Get started*: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Docker Book* by *James Turnbull*: [https://dockerbook.com/](https://dockerbook.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
