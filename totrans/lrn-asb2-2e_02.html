<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Automating Simple Tasks</h1></div></div></div><p>As we have mentioned in the previous chapter, Ansible can be used for both, creating and managing a whole infrastructure, as well as be integrated into an infrastructure that is already working.</p><p>In this chapter, we will see:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What a playbook is and how it works</li><li class="listitem" style="list-style-type: disc">How to create a web server using Ansible</li><li class="listitem" style="list-style-type: disc">A close look at the Jinja2 template engine</li></ul></div><p>But first we will talk about <strong>YAML Ain't Markup Language</strong> (<strong>YAML</strong>), a human-readable data serialization language that is widely used in Ansible.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>YAML</h1></div></div></div><p>YAML, like many other data serialization languages (such as JSON), has very few, basic concepts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Declarations</li><li class="listitem" style="list-style-type: disc">Lists</li><li class="listitem" style="list-style-type: disc">Associative arrays</li></ul></div><p>A declaration is very similar to a variable in any other language, that is:</p><pre class="programlisting">name: 'This is the name' &#13;
</pre><p>To create a list, we will have to use '<code class="literal">-</code>':</p><pre class="programlisting">- 'item1' &#13;
- 'item2' &#13;
- 'item3' &#13;
</pre><p>YAML uses indentation to logically divide parents from children. So if we want to create associative arrays (also known as objects), we would just need to add an indentation:</p><pre class="programlisting">item: &#13;
  name: TheName &#13;
  location: TheLocation &#13;
</pre><p>Obviously, we can mix those together, that is:</p><pre class="programlisting">people: &#13;
  - name: Albert &#13;
    number: +1000000000 &#13;
    country: USA &#13;
  - name: David &#13;
    number: +44000000000 &#13;
    country: UK &#13;
</pre><p>Those are the basics of YAML. YAML can do much more, but for now this will be enough.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Hello Ansible</h1></div></div></div><p>As we have seen in the previous chapter, it is possible to use Ansible to automate simple tasks that you probably already perform daily.</p><p>Let's start by checking if a remote machine is reachable; in other words, let's start by pinging a machine. The simplest way to do this, is to run the following:</p><pre class="programlisting">
<strong>$ ansible all -i HOST, -m ping</strong>
</pre><p>Here, <code class="literal">HOST</code> is an IP address, the <strong>Fully Qualified Domain Name</strong> (<strong>FQDN</strong>), or an alias of a machine where you have SSH access (you can use a <strong>Kernel-based Virtual Machine</strong> (<strong>KVM</strong>), as we have seen in the previous chapter).</p><div><div><h3 class="title"><a id="tip7"/>Tip</h3><p>After the "<code class="literal">HOST,</code>" the comma is mandatory, because otherwise it would not be seen as a list, but as a string.</p></div></div><p>In this case, we have performed it against a virtual machine on our system:</p><pre class="programlisting">
<strong>$ ansible all -i test01.fale.io, -m ping</strong>
</pre><p>You should receive something like this as a result:</p><pre class="programlisting">
<strong>test01.fale.io | SUCCESS =&gt; {</strong>
<strong>    "changed": false,</strong>
<strong>    "ping": "pong"</strong>
<strong>}</strong>
</pre><p>Now, let's see what we did and why. Let's start from the Ansible help. To query it, we can use the following command:</p><pre class="programlisting">
<strong>$ ansible --help</strong>
</pre><p>To make it easier to be read, we have removed all the output related to options that we have not used:</p><pre class="programlisting">
<strong>Usage: ansible &lt;host-pattern&gt; [options]</strong>
<strong>Options:</strong>
<strong>  -i INVENTORY, --inventory-file=INVENTORY</strong>
<strong>                        specify inventory host path</strong>
<strong>                        (default=/etc/ansible/hosts) or comma</strong>
<strong>                        separated host list.</strong>
<strong>  -m MODULE_NAME, --module-name=MODULE_NAME</strong>
<strong>                        module name to execute (default=command)</strong>
</pre><p>So, what we did was:</p><div><ol class="orderedlist arabic"><li class="listitem">We invoked Ansible.</li><li class="listitem">We instructed Ansible to run on all hosts.</li><li class="listitem">We specified our inventory (also known as the list of the hosts).</li><li class="listitem">We specified the module we wanted to run (<code class="literal">ping</code>).</li></ol></div><p>Now that we can ping the server, let's <code class="literal">echo hello ansible!</code>
</p><pre class="programlisting">
<strong>$ ansible all -i test01.fale.io, -m shell -a '/bin/echo hello ansible!'</strong>
</pre><p>You should receive something like this as a result:</p><pre class="programlisting">
<strong>test01.fale.io | SUCCESS | rc=0 &gt;&gt;</strong>
<strong>hello ansible!</strong>
</pre><p>In this example, we used an additional option. Let's check the help to see what it does:</p><pre class="programlisting">
<strong>Usage: ansible &lt;host-pattern&gt; [options]</strong>
<strong>Options:</strong>
<strong>  -a MODULE_ARGS, --args=MODULE_ARGS</strong>
<strong>                        module arguments</strong>
</pre><p>As you may have guessed from the context and the name, the <code class="literal">args</code> options allow you to pass additional arguments to the module. Some modules (like <code class="literal">ping</code>) do not support any arguments, while others (such as <code class="literal">shell</code>) will require arguments.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Working with playbooks</h1></div></div></div><p>Playbooks are one of the core features of Ansible and tell Ansible what to execute. They are like a to-do list for Ansible that contains a list of tasks; each task internally links to a piece of code called a <strong>module</strong>. Playbooks are simple, human-readable YAML files, whereas modules are a piece of code that can be written in any language with the condition that its output be in the JSON format. You can have multiple tasks listed in a playbook and these tasks would be executed serially by Ansible. You can think of playbooks as an equivalent of manifests in Puppet, states in Salt, or cookbooks in Chef; they allow you to enter a list of tasks or commands you want to execute on your remote system.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Studying the anatomy of a playbook</h2></div></div></div><p>Playbooks can have a list of remote hosts, user variables, tasks, handlers, and so on. You can also override most of the configuration settings through a playbook. Let's start looking at the anatomy of a playbook.</p><p>The purpose of the playbook we are going to consider now, is to ensure that the <code class="literal">httpd</code> package is installed and the service is <strong>enabled</strong> and <strong>started</strong>. This is the content of the <code class="literal">setup_apache.yaml</code> file:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: fale &#13;
  tasks: &#13;
  - name: Ensure the HTTPd package is installed &#13;
    yum: &#13;
      name: httpd &#13;
      state: present &#13;
      become: True &#13;
  - name: Ensure the HTTPd service is enabled and running &#13;
    service: &#13;
      name: httpd &#13;
      state: started &#13;
      enabled: True &#13;
    become: True &#13;
</pre><p>The <code class="literal">setup_apache.yaml</code> file is an example of a playbook. The file is comprised of three main parts, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hosts</code>: This lists the host or host group against which we want to run the task. The hosts field is mandatory and every playbook should have it. It tells Ansible on which hosts to run the listed tasks. When provided with a host group, Ansible will take the host group from the playbook and try look for it in an inventory file . If there is no match, Ansible will skip all the tasks for that host group. The <code class="literal">--list-hosts</code> option along with the playbook (<code class="literal">ansible-playbook &lt;playbook&gt; --list-hosts</code>) will tell you exactly which hosts the playbook will run against.</li><li class="listitem" style="list-style-type: disc"><code class="literal">remote_user</code>: This is one of the configuration parameters of Ansible (consider, for example, <code class="literal">tom -remote_user</code>) that tells Ansible to use a particular user (in this case, <code class="literal">tom</code>) while logging into the system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tasks</code>: Finally, we come to tasks. All playbooks should contain tasks. Tasks are a list of actions you want to perform. A tasks field contains the name of the task (that is, the help text for the user about the task), a module that should be executed, and arguments that are required for the module. Let's look at the single task that is listed in the playbook, as shown in the preceding snippet of code:</li></ul></div><div><div><h3 class="title"><a id="note8"/>Note</h3><p>All examples in the book would be executed on CentOS, but the same set of examples with a few changes would work on other distributions as well.</p></div></div><p>In the preceding case, there are two tasks. The <code class="literal">name</code> parameter represents what the task is doing and is <code class="literal">present</code> mainly to improve readability, as we'll see during the playbook run. The <code class="literal">name</code> parameter is optional. The <code class="literal">modules</code>, <code class="literal">yum</code> and <code class="literal">service</code>, have their own set of parameters. Almost all modules have the <code class="literal">name</code> parameter (there are exceptions such as the <code class="literal">debug</code> module), which indicates what component the actions are performed on. Let's look at the other parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">yum</code> module's case, the <code class="literal">state</code> parameter has the latest value and it indicates that the <code class="literal">httpd</code> latest package should be installed. The command to execute more or less translates to <code class="literal">yum install httpd</code>.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">service</code> module's scenario, the <code class="literal">state</code> parameter with the started value indicates that the <code class="literal">httpd</code> service should be started, and it roughly translates to <code class="literal">/etc/init.d/httpd</code> start. In this module we also have the "<code class="literal">enabled</code>" parameter that defines whether the service should start at boot or not.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">become: True</code> parameter represents the fact that the tasks should be executed with <code class="literal">sudo</code> access. If the <code class="literal">sudo</code> user's file does not allow the user to run the particular command, then the playbook will fail when it is run.</li></ul></div><div><div><h3 class="title"><a id="note9"/>Note</h3><p>You might have questions about why there is no package module that figures out the architecture internally and runs the <code class="literal">yum</code>, <code class="literal">apt</code>, or any other package options depending on the architecture of the system. Ansible populates the package manager value into a variable named <code class="literal">ansible_pkg_manager</code>.</p><p>In general, we need to remember that the number of packages that have a common name across different operating systems is a small subset of the number of packages that are actually present. For example, the <code class="literal">httpd package</code> is called <code class="literal">httpd</code> in Red Hat systems and <code class="literal">apache2</code> in Debian-based systems. We also need to remember that every package manager has its own set of options that make it powerful; as a result, it makes more sense to use explicit package manager names so that the full set of options are available to the end user writing the playbook.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Running a playbook</h2></div></div></div><p>Now, it's time (yes, finally!) to run the playbook. To instruct Ansible to execute a playbook instead of a module, we will have to use a different command (<code class="literal">ansible-playbooks</code>) that has a syntax very similar to the "<code class="literal">ansible</code>" command we already saw:</p><pre class="programlisting">
<strong>$ ansible-playbook -i HOST, setup_apache.yaml</strong>
</pre><p>As you can see, aside from the host-pattern (that is specified in the playbook) that has disappeared, and the module option that has been replaced by the playbook name, nothing changed. So to execute this command on my machine, the exact command is:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, setup_apache.yaml</strong>
</pre><p>The result is the following:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure the HTTPd package is installed] *********************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure the HTTPd service is enabled and running] ***********</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io    : ok=3    changed=2    unreachable=0    failed=0   </strong>
</pre><p>Wow! The example worked. Let's now check whether the <code class="literal">httpd</code> package is installed and up-and-running on the machine. To check if HTTPd is installed, the easiest way is to ask <code class="literal">rpm</code>:</p><pre class="programlisting">
<strong>$ rpm -qa | grep httpd</strong>
</pre><p>If everything worked properly, you should have an output like the following:</p><pre class="programlisting">
<strong>httpd-tools-2.4.6-40.el7.centos.x86_64</strong>
<strong>httpd-2.4.6-40.el7.centos.x86_64</strong>
</pre><p>To see the status of the service, we can ask <code class="literal">systemd</code>:</p><pre class="programlisting">
<strong>$ systemctl status httpd</strong>
</pre><p>The expected result is something like the following:</p><pre class="programlisting">
<strong>httpd.service - The Apache HTTP Server</strong>
<strong>  Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)</strong>
<strong>   Active: active (running) since Sat 2016-05-07 13:22:14 EDT; 7min ago</strong>
<strong>     Docs: man:httpd(8)</strong>
<strong>           man:apachectl(8)</strong>
<strong> Main PID: 2214 (httpd)</strong>
<strong>   Status: "Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec"</strong>
<strong>   CGroup: /system.slice/httpd.service</strong>
<strong>           -2214 /usr/sbin/httpd -DFOREGROUND</strong>
<strong>           -2215 /usr/sbin/httpd -DFOREGROUND</strong>
<strong>           -2216 /usr/sbin/httpd -DFOREGROUND</strong>
<strong>           -2217 /usr/sbin/httpd -DFOREGROUND</strong>
<strong>           -2218 /usr/sbin/httpd -DFOREGROUND</strong>
<strong>           -2219 /usr/sbin/httpd -DFOREGROUND</strong>
</pre><p>The end state, according to the playbook, has been achieved. Let's briefly look at exactly what happens during the playbook run:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
</pre><p>This line advises us that a playbook is going to start here and that it will be executed on "<code class="literal">all</code>" hosts:</p><pre class="programlisting">
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]</strong>
</pre><p>The <code class="literal">TASK</code> lines show the name of the task (<code class="literal">setup</code> in this case), and their effect on each host. Sometimes people get confused by the <code class="literal">setup</code> task. In fact, if you look at the playbook, there is no <code class="literal">setup</code> task. This is because Ansible, before executing the tasks that we have asked it to, will try to connect to the machine and gather information about it that could be useful later. As you can see, the task resulted with a green <code class="literal">ok</code> state, so it succeeded and nothing was changed on the server:</p><pre class="programlisting">
<strong>TASK [Ensure the HTTPd package is installed] *********************</strong>
<strong>changed: [test01.fale.io]</strong>
<strong>TASK [Ensure the HTTPd service is enabled and running] ***********</strong>
<strong>changed: [test01.fale.io]</strong>
</pre><p>These two task's states are yellow and spell "<code class="literal">changed</code>". This means that those tasks were executed and have succeeded but have actually changed something on the machine:</p><pre class="programlisting">
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io       : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre><p>Those last few lines are a recapitulation of how the playbook went. Let's rerun the task now and see the output after both the tasks have actually run:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]</strong>
<strong>TASK [Ensure the HTTPd package is installed] *********************</strong>
<strong>ok: [test01.fale.io]</strong>
<strong>TASK [Ensure the HTTPd service is enabled and running] ***********</strong>
<strong>ok: [test01.fale.io]</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io    : ok=3    changed=0    unreachable=0    failed=0</strong>
</pre><p>As you would have expected, the two tasks in question give an output of <code class="literal">ok</code>, which would mean that the desired state was already met prior to running the task. It's important to remember that many tasks such as the <strong>Gathering facts</strong> task obtain information regarding a particular component of the system and do not necessarily change anything on the system; hence, these tasks didn't display the changed output earlier.</p><p>The <code class="literal">PLAY RECAP</code> section in the first and second run are shown as follows. You will see the following output during the first run:</p><pre class="programlisting">
<strong>PLAY RECAP ******************************************************</strong>
<strong>test01.fale.io    : ok=3    changed=2    unreachable=0    failed=0   </strong>
</pre><p>You will see the following output during the second run:</p><pre class="programlisting">
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io    : ok=3    changed=0    unreachable=0    failed=0</strong>
</pre><p>As you can see, the difference is that the first task's output shows <code class="literal">changed=2</code>, which means that the system state changed twice due to two tasks. It's very useful to look at this output, since, if a system has achieved its desired state and then you run the playbook on it, the expected output should be <code class="literal">changed=0</code>.</p><p>If you're thinking of the word <strong>Idempotency</strong> at this stage, you're absolutely right and deserve a pat on the back! Idempotency is one of the key tenets of configuration management. Wikipedia defines Idempotency as an operation that, if applied twice to any value, gives the same result as if it were applied once. The earliest examples of this that you would have encountered in your childhood would be multiplicative operations on the number <code class="literal">1</code>, where <code class="literal">1*1=1</code> every single time.</p><p>Most of the configuration management tools have taken this principle and applied it to the infrastructure as well. In a large infrastructure, it is highly recommended to monitor or track the number of changed tasks in your infrastructure and alert the concerned tasks if you find oddities; this applies to any configuration management tool in general. In an ideal state, the only time you should see changes is when you're introducing a new change in the form of any <strong>Create</strong>, <strong>Remove</strong>, <strong>Update</strong>, or <strong>Delete</strong> (<strong>CRUD</strong>) operation on various system components. If you're wondering how you can do it with Ansible, keep reading the book and you'll eventually find the answer!
</p><p>Let's proceed. You could have also written the preceding tasks as follows but when the tasks are run, from an end user's perspective, they are quite readable (we will call this file <code class="literal">setup_apache_no_com.yaml</code>):</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: fale &#13;
  tasks: &#13;
  - yum: &#13;
      name: httpd &#13;
      state: present &#13;
    become: True &#13;
  - service: &#13;
      name: httpd &#13;
      state: started &#13;
      enabled: True &#13;
    become: True &#13;
</pre><p>Let's run the playbook again to spot any difference in the output:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, setup_apache_no_com.yaml</strong>
</pre><p>The output would be:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [yum] *******************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [service] ***************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io    : ok=3    changed=0    unreachable=0    failed=0   </strong>
</pre><p>As you can see, the difference is in the readability. Wherever possible, it's recommended to keep the tasks as simple as possible (the <strong>KISS</strong> principle of <strong>Keep It Simple Stupid</strong>) to allow for maintainability of your scripts in the long run.</p><p>Now that we've seen how you can write a basic playbook and run it against a host, let's look at other options that would help you while running playbooks.
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Ansible verbosity</h1></div></div></div><p>One of the first options anyone picks up is the debug option. To understand what is happening when you run the playbook, you can run it with the <strong>verbose</strong> (<code class="literal">-v</code>) option. Every extra <code class="literal">v</code> will provide the end user with more debug output.</p><p>Let's see an example of using the playbook debug for a single task using the following debug options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">-v</code> option provides the default output, as shown in the preceding examples.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-vv</code> option adds a little more information, as shown in the following example:</li></ul></div><pre class="programlisting">
<strong>    Using /etc/ansible/ansible.cfg as config file &#13;
 &#13;
    PLAYBOOK: setup_apache.yaml ******************************* &#13;
    1 plays in setup_apache.yaml &#13;
 &#13;
    PLAY [all] ************************************************ &#13;
 &#13;
    TASK [setup] ********************************************** &#13;
    ok: [test01.fale.io] &#13;
 &#13;
    TASK [Ensure the HTTPd package is installed] ************** &#13;
    task path: /home/fale/setup_apache.yaml:5 &#13;
    ok: [test01.fale.io] =&gt; {"changed": false, "msg": "", "rc": 0, "results": ["httpd-2.4.6-40.el7.centos.x86_64 providing httpd is already installed"]} &#13;
 &#13;
    TASK [Ensure the HTTPd service is enabled and running] **** &#13;
    task path: /home/fale/setup_apache.yaml:10 &#13;
    ok: [test01.fale.io] =&gt; {"changed": false, "enabled": true, "name": "httpd", "state": "started"} &#13;
 &#13;
    PLAY RECAP ************************************************ &#13;
    test01.fale.io   : ok=3  changed=0   unreachable=0  failed=0  </strong>
</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">-vvv</code> option adds a lot more information, as shown in the following code. This shows the <code class="literal">ssh</code> command Ansible uses to create a temporary file on the remote host and run the script remotely:</li></ul></div><pre class="programlisting">
<strong>TASK [Ensure the HTTPd package is installed] **************</strong>
<strong>task path: /home/fale/setup_apache.yaml:5</strong>
<strong>&lt;test01.fale.io&gt; ESTABLISH SSH CONNECTION FOR USER: fale</strong>
<strong>&lt;test01.fale.io&gt; SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o User=fale -o ConnectTimeout=10 -o ControlPath=/home/fale/.ansible/cp/ansible-ssh-%C test01.fale.io '/bin/sh -c '"'"'( umask 22 &amp;&amp; mkdir -p "` echo $HOME/.ansible/tmp/ansible-tmp-1462644055.19-51001413558638 `" &amp;&amp; echo "` echo $HOME/.ansible/tmp/ansible-tmp-1462644055.19-51001413558638 `" )'"'"''</strong>
<strong>&lt;test01.fale.io&gt; PUT /tmp/tmp9JSYiP TO /home/fale/.ansible/tmp/ansible-tmp-1462644055.19-51001413558638/yum</strong>
<strong>&lt;test01.fale.io&gt; SSH: EXEC sftp -b - -C -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o User=fale -o ConnectTimeout=10 -o ControlPath=/home/fale/.ansible/cp/ansible-ssh-%C '[test01.fale.io]'</strong>
<strong>&lt;test01.fale.io&gt; ESTABLISH SSH CONNECTION FOR USER: fale</strong>
<strong>&lt;test01.fale.io&gt; SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o User=fale -o ConnectTimeout=10 -o ControlPath=/home/fale/.ansible/cp/ansible-ssh-%C -tt test01.fale.io '/bin/sh -c '"'"'sudo -H -S -n -u root /bin/sh -c '"'"'"'"'"'"'"'"'echo BECOME-SUCCESS-axnwopicemeccmdhnlmhawtwlysgfgjc; LANG=en_US.utf8 LC_ALL=en_US.utf8 LC_MESSAGES=en_US.utf8 /usr/bin/python -tt /home/fale/.ansible/tmp/ansible-tmp-1462644055.19-51001413558638/yum; rm -rf "/home/fale/.ansible/tmp/ansible-tmp-1462644055.19-51001413558638/" &gt; /dev/null 2&gt;&amp;1'"'"'"'"'"'"'"'"''"'"''</strong>
<strong>ok: [test01.fale.io] =&gt; {"changed": false, "invocation": {"module_args": {"conf_file": null, "disable_gpg_check": false, "disablerepo": null, "enablerepo": null, "exclude": null, "install_repoquery": true, "list": null, "name": ["httpd"], "state": "present", "update_cache": false}, "module_name": "yum"}, "msg": "", "rc": 0, "results": ["httpd-2.4.6-40.el7.centos.x86_64 providing httpd is already installed"]}</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Variables in playbooks</h1></div></div></div><p>Sometimes it is important to <code class="literal">set</code> and <code class="literal">get</code> variables in a playbook.</p><p>Very often, you'll need to automate multiple similar operations. In those cases, you'll want to create a single playbook that can be called with different variables to ensure code reusability.</p><p>Another case where variables are very important is when you have more than one datacenter and some values will be datacenter-specific. A common example are the DNS servers. Let's analyze the following simple code that will introduce us to the Ansible way to set and get variables:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: fale &#13;
  tasks: &#13;
  - name: Set variable 'name' &#13;
    set_fact: &#13;
      name: Test machine &#13;
  - name: Print variable 'name' &#13;
    debug: &#13;
      msg: '{{ name }}' &#13;
</pre><p>Let's run it in the usual way:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, variables.yaml</strong>
</pre><p>You should see the following result:</p><pre class="programlisting">
<strong>PLAY [all] **********************************************************</strong>
<strong>TASK [setup] ********************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Set variable 'name'] ******************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Print variable 'name'] ****************************************</strong>
<strong>ok: [test01.fale.io] =&gt; {</strong>
<strong>    "msg": "Test machine"</strong>
<strong>}&#13;
&#13;
</strong>
<strong>PLAY RECAP **********************************************************</strong>
<strong>test01.fale.io       : ok=3    changed=0    unreachable=0    failed=0</strong>
</pre><p>If we analyze the code we have just executed, it should be pretty clear what's going on. We set a variable (that in Ansible are called <code class="literal">facts</code>) and then we print it with the <code class="literal">debug</code> function.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Variables should always be between quotes when you use this expanded version of YAML.</p></div></div><p>Ansible allows you to set your variables in many different ways, that is, either by passing a variable file, declaring it in a playbook, passing it to the <code class="literal">ansible-playbook</code> command using <code class="literal">-e / --extra-vars</code>, or by declaring it in an inventory file (we will be discussing more in-depth about this in the next chapter).</p><p>It's now time to start using some metadata that Ansible obtained during the setup phase. Let's start by looking at the data that is gathered by Ansible. To do this, we will execute:</p><pre class="programlisting">
<strong>$ ansible all -i HOST, -m setup</strong>
</pre><p>In our specific case, this means executing the following:</p><pre class="programlisting">
<strong>$ ansible all -i test01.fale.io, -m setup</strong>
</pre><p>We can obviously do the same with a playbook, but this way is faster. Also, for the "setup" case, you will need to see the output only during the development to be sure to use the right variable name for your goal.</p><p>The output will be something like this:</p><pre class="programlisting">
<strong>test01.fale.io | SUCCESS =&gt; {</strong>
<strong>    "ansible_facts": {</strong>
<strong>        "ansible_all_ipv4_addresses": [</strong>
<strong>            "178.62.36.208",</strong>
<strong>            "10.16.0.7"</strong>
<strong>        ],</strong>
<strong>        "ansible_all_ipv6_addresses": [</strong>
<strong>            "fe80::601:e2ff:fef1:1301"</strong>
<strong>        ],</strong>
<strong>        "ansible_architecture": "x86_64",</strong>
<strong>        "ansible_bios_date": "04/25/2016",</strong>
<strong>        "ansible_bios_version": "20160425",</strong>
<strong>        "ansible_cmdline": {</strong>
<strong>            "ro": true,</strong>
<strong>            "root": "LABEL=DOROOT"</strong>
<strong>        },</strong>
<strong>        "ansible_date_time": {</strong>
<strong>            "date": "2016-05-14",</strong>
<strong>            "day": "14",</strong>
<strong>            "epoch": "1463244633",</strong>
<strong>            "hour": "12",</strong>
<strong>            "iso8601": "2016-05-14T16:50:33Z",</strong>
<strong>            "iso8601_basic": "20160514T125033231663",</strong>
<strong>            "iso8601_basic_short": "20160514T125033",</strong>
<strong>            "iso8601_micro": "2016-05-14T16:50:33.231770Z",</strong>
<strong>            "minute": "50",</strong>
<strong>            "month": "05",</strong>
<strong>            "second": "33",</strong>
<strong>            "time": "12:50:33",</strong>
<strong>            "tz": "EDT",</strong>
<strong>            "tz_offset": "-0400",</strong>
<strong>            "weekday": "Saturday",</strong>
<strong>            "weekday_number": "6",</strong>
<strong>            "weeknumber": "19",</strong>
<strong>            "year": "2016"</strong>
<strong>        },</strong>
<strong>        "ansible_default_ipv4": {</strong>
<strong>            "address": "178.62.36.208",</strong>
<strong>            "alias": "eth0",</strong>
<strong>            "broadcast": "178.62.63.255",</strong>
<strong>            "gateway": "178.62.0.1",</strong>
<strong>            "interface": "eth0",</strong>
<strong>            "macaddress": "04:01:e2:f1:13:01",</strong>
<strong>            "mtu": 1500,</strong>
<strong>            "netmask": "255.255.192.0",</strong>
<strong>            "network": "178.62.0.0",</strong>
<strong>            "type": "ether"</strong>
<strong>        },</strong>
<strong>        "ansible_default_ipv6": {},</strong>
<strong>        "ansible_devices": {</strong>
<strong>            "vda": {</strong>
<strong>                "holders": [],</strong>
<strong>                "host": "",</strong>
<strong>                "model": null,</strong>
<strong>                "partitions": {</strong>
<strong>                    "vda1": {</strong>
<strong>                        "sectors": "41943040",</strong>
<strong>                        "sectorsize": 512,</strong>
<strong>                        "size": "20.00 GB",</strong>
<strong>                        "start": "2048"</strong>
<strong>                    }</strong>
<strong>                },</strong>
<strong>                "removable": "0",</strong>
<strong>                "rotational": "1",</strong>
<strong>                "scheduler_mode": "",</strong>
<strong>                "sectors": "41947136",</strong>
<strong>                "sectorsize": "512",</strong>
<strong>                "size": "20.00 GB",</strong>
<strong>                "support_discard": "0",</strong>
<strong>                "vendor": "0x1af4"</strong>
<strong>            }</strong>
<strong>        },</strong>
<strong>        "ansible_distribution": "CentOS",</strong>
<strong>        "ansible_distribution_major_version": "7",</strong>
<strong>        "ansible_distribution_release": "Core",</strong>
<strong>        "ansible_distribution_version": "7.2.1511",</strong>
<strong>        "ansible_dns": {</strong>
<strong>            "nameservers": [</strong>
<strong>                "8.8.8.8",</strong>
<strong>                "8.8.4.4"</strong>
<strong>            ]</strong>
<strong>        },</strong>
<strong>        "ansible_domain": "",</strong>
<strong>        "ansible_env": {</strong>
<strong>            "HOME": "/home/fale",</strong>
<strong>            "LANG": "en_US.utf8",</strong>
<strong>            "LC_ALL": "en_US.utf8",</strong>
<strong>            "LC_MESSAGES": "en_US.utf8",</strong>
<strong>            "LESSOPEN": "||/usr/bin/lesspipe.sh %s",</strong>
<strong>            "LOGNAME": "fale",</strong>
<strong>            "MAIL": "/var/mail/fale",</strong>
<strong>            "PATH": "/usr/local/bin:/usr/bin",</strong>
<strong>            "PWD": "/home/fale",</strong>
<strong>            "SHELL": "/bin/bash",</strong>
<strong>            "SHLVL": "2",</strong>
<strong>            "SSH_CLIENT": "86.187.141.39 37764 22",</strong>
<strong>            "SSH_CONNECTION": "86.187.141.39 37764 178.62.36.208 22",</strong>
<strong>            "SSH_TTY": "/dev/pts/0",</strong>
<strong>            "TERM": "rxvt-unicode-256color",</strong>
<strong>            "USER": "fale",</strong>
<strong>            "XDG_RUNTIME_DIR": "/run/user/1000",</strong>
<strong>            "XDG_SESSION_ID": "180",</strong>
<strong>            "_": "/usr/bin/python"</strong>
<strong>        },</strong>
<strong>        "ansible_eth0": {</strong>
<strong>            "active": true,</strong>
<strong>            "device": "eth0",</strong>
<strong>            "ipv4": {</strong>
<strong>                "address": "178.62.36.208",</strong>
<strong>                "broadcast": "178.62.63.255",</strong>
<strong>                "netmask": "255.255.192.0",</strong>
<strong>                "network": "178.62.0.0"</strong>
<strong>            },</strong>
<strong>            "ipv4_secondaries": [</strong>
<strong>                {</strong>
<strong>                    "address": "10.16.0.7",</strong>
<strong>                    "broadcast": "10.16.255.255",</strong>
<strong>                    "netmask": "255.255.0.0",</strong>
<strong>                    "network": "10.16.0.0"</strong>
<strong>                }</strong>
<strong>            ],</strong>
<strong>            "ipv6": [</strong>
<strong>                {</strong>
<strong>                    "address": "fe80::601:e2ff:fef1:1301",</strong>
<strong>                    "prefix": "64",</strong>
<strong>                    "scope": "link"</strong>
<strong>                }</strong>
<strong>            ],</strong>
<strong>            "macaddress": "04:01:e2:f1:13:01",</strong>
<strong>            "module": "virtio_net",</strong>
<strong>            "mtu": 1500,</strong>
<strong>            "pciid": "virtio0",</strong>
<strong>            "promisc": false,</strong>
<strong>            "type": "ether"</strong>
<strong>        },</strong>
<strong>        "ansible_eth1": {</strong>
<strong>            "active": false,</strong>
<strong>            "device": "eth1",</strong>
<strong>            "macaddress": "04:01:e2:f1:13:02",</strong>
<strong>            "module": "virtio_net",</strong>
<strong>            "mtu": 1500,</strong>
<strong>            "pciid": "virtio1",</strong>
<strong>            "promisc": false,</strong>
<strong>            "type": "ether"</strong>
<strong>        },</strong>
<strong>        "ansible_fips": false,</strong>
<strong>        "ansible_form_factor": "Other",</strong>
<strong>        "ansible_fqdn": "test",</strong>
<strong>        "ansible_hostname": "test",</strong>
<strong>        "ansible_interfaces": [</strong>
<strong>            "lo",</strong>
<strong>            "eth1",</strong>
<strong>            "eth0"</strong>
<strong>        ],</strong>
<strong>        "ansible_kernel": "3.10.0-327.10.1.el7.x86_64",</strong>
<strong>        "ansible_lo": {</strong>
<strong>            "active": true,</strong>
<strong>            "device": "lo",</strong>
<strong>            "ipv4": {</strong>
<strong>                "address": "127.0.0.1",</strong>
<strong>                "broadcast": "host",</strong>
<strong>                "netmask": "255.0.0.0",</strong>
<strong>                "network": "127.0.0.0"</strong>
<strong>            },</strong>
<strong>            "ipv6": [</strong>
<strong>                {</strong>
<strong>                    "address": "::1",</strong>
<strong>                    "prefix": "128",</strong>
<strong>                    "scope": "host"</strong>
<strong>                }</strong>
<strong>            ],</strong>
<strong>            "mtu": 65536,</strong>
<strong>            "promisc": false,</strong>
<strong>            "type": "loopback"</strong>
<strong>        },</strong>
<strong>        "ansible_machine": "x86_64",</strong>
<strong>        "ansible_machine_id": "fd8cf26e06e411e4a9d004010897bd01",</strong>
<strong>        "ansible_memfree_mb": 6,</strong>
<strong>        "ansible_memory_mb": {</strong>
<strong>            "nocache": {</strong>
<strong>                "free": 381,</strong>
<strong>                "used": 108</strong>
<strong>            },</strong>
<strong>            "real": {</strong>
<strong>                "free": 6,</strong>
<strong>                "total": 489,</strong>
<strong>                "used": 483</strong>
<strong>            },</strong>
<strong>            "swap": {</strong>
<strong>                "cached": 0,</strong>
<strong>                "free": 0,</strong>
<strong>                "total": 0,</strong>
<strong>                "used": 0</strong>
<strong>            }</strong>
<strong>        },</strong>
<strong>        "ansible_memtotal_mb": 489,</strong>
<strong>        "ansible_mounts": [</strong>
<strong>            {</strong>
<strong>                "device": "/dev/vda1",</strong>
<strong>                "fstype": "ext4",</strong>
<strong>                "mount": "/",</strong>
<strong>                "options": "rw,relatime,data=ordered",</strong>
<strong>                "size_available": 18368385024,</strong>
<strong>                "size_total": 21004894208,</strong>
<strong>                "uuid": "c5845b43-fe98-499a-bf31-4eccae14261b"</strong>
<strong>            }</strong>
<strong>        ],</strong>
<strong>        "ansible_nodename": "test",</strong>
<strong>        "ansible_os_family": "RedHat",</strong>
<strong>        "ansible_pkg_mgr": "yum",</strong>
<strong>        "ansible_processor": [</strong>
<strong>            "GenuineIntel",</strong>
<strong>            "Intel(R) Xeon(R) CPU E5-2630L v2 @ 2.40GHz"</strong>
<strong>        ],</strong>
<strong>        "ansible_processor_cores": 1,</strong>
<strong>        "ansible_processor_count": 1,</strong>
<strong>        "ansible_processor_threads_per_core": 1,</strong>
<strong>        "ansible_processor_vcpus": 1,</strong>
<strong>        "ansible_product_name": "Droplet",</strong>
<strong>        "ansible_product_serial": "NA",</strong>
<strong>        "ansible_product_uuid": "NA",</strong>
<strong>        "ansible_product_version": "20160415",</strong>
<strong>        "ansible_python_version": "2.7.5",</strong>
<strong>        "ansible_selinux": {</strong>
<strong>            "status": "disabled"</strong>
<strong>        },</strong>
<strong>        "ansible_service_mgr": "systemd",</strong>
<strong>        "ansible_ssh_host_key_dsa_public": "AAAAB3NzaC1kc3MAAACBAPEf4dzeET6ukHemTASsamoRLxo2R8iHg5J1bYQUyuggtRKlbRrHMtpQ8qN5CQNtp8J+2Hq6/JKiDF+cdxgOehf9b7F4araVvJxqx967RvLNBrMWXv7/4hi+efgXG9eejGoGQNAD66up/fkLMd0L8fwSwmTJoZXwOxFwcbnxCZsFAAAAFQDgK7fka+1AKjYZNFIfCB2b0ZitGQAAAIADeofiC5q+SLgEvkBCUCTyJ+EVb6WHeHbVdrpE2GdnUr03R6MmmYhYZMijruS/rcpzBLmi8juDkqAWy6Xqxd+DwixykntXPeUFS3F7LK5vNwFalaRltPwr4Azh+EeSUQ2Zz2AdKx6zSqtLOD8ZMPkRDvz4WGHGmeR+i7UFsFDZdgAAAIEAy26Tx0jAlY3mEaTW9lQ9DoGXgPBxsSX/XqeLh5wBaBO6AJaIrs0dQJdNeHcMhFy0seVkOMN1SpeoBTJSoTOx15HAGsKsAcmnA5mcJeUZqptVR6JxROztHw3zQePQ3/V3KQzAN31tIm3PbKztlEZbXRUM7RV5WsdRHTb8rutENhY=",</strong>
<strong>        "ansible_ssh_host_key_ecdsa_public": "AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBPDXQ9rjgDmUKsEWH4U2vg4iqtK+75urlj9nwW+rNNTFHTE5oG82sOlO6o0tUY8LXgB/tJnIcJ1hINdrWrZNpn4=",</strong>
<strong>        "ansible_ssh_host_key_rsa_public": "AAAAB3NzaC1yc2EAAAADAQABAAABAQCwQx5EElH7FeD/agB/gCJfBUEVhk44tldzdEzwc2IEbI59relTGNOU7soCCMcSH7nwlEbOOvmLa2R/YaXdHv/cb1aXBC/wj/m4ZHylBeF5qzECUkeaB3+CT+hp8qHHApclFr2lm2CwZ+YXjEyjJ3en4K3gLlIQyQjgE2F57kmD1FVVDSJFvNTn+NQvb3DPppND+HKEeHwrJ0GgznoP62yobEgriAIBSGf//0WHCO/9shEvauoRpPM+U9pU7lv637s7qyubIqyrs5fz3u34qBj8oCATOefRN1wsfJDeMG0D5ryI6BI6t/eAi8BPr7VHJSQBk+buM9Jr1yoMQTEasq2J",</strong>
<strong>        "ansible_swapfree_mb": 0,</strong>
<strong>        "ansible_swaptotal_mb": 0,</strong>
<strong>        "ansible_system": "Linux",</strong>
<strong>        "ansible_system_vendor": "DigitalOcean",</strong>
<strong>        "ansible_uptime_seconds": 603067,</strong>
<strong>        "ansible_user_dir": "/home/fale",</strong>
<strong>        "ansible_user_gecos": "",</strong>
<strong>        "ansible_user_gid": 1000,</strong>
<strong>        "ansible_user_id": "fale",</strong>
<strong>        "ansible_user_shell": "/bin/bash",</strong>
<strong>        "ansible_user_uid": 1000,</strong>
<strong>        "ansible_userspace_architecture": "x86_64",</strong>
<strong>        "ansible_userspace_bits": "64",</strong>
<strong>        "ansible_virtualization_role": "host",</strong>
<strong>        "ansible_virtualization_type": "kvm",</strong>
<strong>        "module_setup": true</strong>
<strong>    },</strong>
<strong>    "changed": false</strong>
<strong>}</strong>
</pre><p>As you can see, from this huge list of options, you can gain a huge quantity of information, and you can use them as any other variable. Let's print the OS name and the version. To do so, we can create a new playbook called <code class="literal">setup_variables.yaml</code> with the following content:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: fale &#13;
  tasks: &#13;
  - name: Print OS and version &#13;
    debug: &#13;
      msg: '{{ ansible_distribution }} {{ ansible_distribution_version }}' &#13;
</pre><p>Run it with the following:</p><pre class="programlisting">
<strong>$ ansible-playbook -itest01.fale.io, setup_variables.yaml</strong>
</pre><p>This will give us the following output:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Print OS and version] **************************************</strong>
<strong>ok: [test01.fale.io] =&gt; {</strong>
<strong>    "msg": "CentOS 7.2.1511"&#13;
</strong>
<strong>}&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io     : ok=2   changed=0    unreachable=0    failed=0</strong>
</pre><p>As you can see, it printed the OS name and version, as expected. In addition to the methods seen previously, it's also possible to pass a variable using a command-line argument. In fact, if we look in the Ansible help, we will notice the following:</p><pre class="programlisting">
<strong>-e EXTRA_VARS, --extra-vars=EXTRA_VARS</strong>
<strong>set additional variables as key=value or YAML/JSON</strong>
</pre><p>The same lines are present in the <code class="literal">ansible-playbook</code> command as well. Let's make a small playbook called <code class="literal">cli_variables.yaml</code> with the following content:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: fale &#13;
  tasks: &#13;
  - name: Print variable 'name' &#13;
    debug: &#13;
      msg: '{{ name }}' &#13;
</pre><p>Execute it with the following:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, cli_variables.yaml -e 'name=test01'</strong>
</pre><p>We will receive the following:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]</strong>
<strong>TASK [Print variable 'name'] *************************************</strong>
<strong>ok: [test01.fale.io] =&gt; {</strong>
<strong>    "msg": "test01"</strong>
<strong>}</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io     : ok=2   changed=0    unreachable=0    failed=0</strong>
</pre><p>In case we forgot to add the additional parameter to specify the variable, we would have executed it as:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, cli_variables.yaml</strong>
</pre><p>We would have received the following output:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Print variable 'name'] *************************************</strong>
<strong>fatal: [test01.fale.io]: FAILED! =&gt; {"failed": true, "msg": "'name' is undefined"}&#13;
&#13;
</strong>
<strong>NO MORE HOSTS LEFT ***********************************************</strong>
<strong>to retry, use: --limit @cli_variables.retry&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io     : ok=1   changed=0    unreachable=0    failed=1</strong>
</pre><p>Now that we have learned the basics of playbooks, let's create a web server from scratch using them. To do so, let's start from the beginning, creating an Ansible user and then moving forward from there.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Creating the Ansible user</h1></div></div></div><p>When you create a machine (or rent one from any hosting company) it arrives only with the <code class="literal">root</code> user. Let's start creating a playbook that ensures that an Ansible user is created, it's accessible with an SSH key, and is able to perform actions on behalf of other users (<code class="literal">sudo</code>) with no password asked. I often call this playbook, <code class="literal">firstrun.yaml</code> since I execute it as soon as a new machine is created, but after that, I don't use it since it uses the root user that I disable for security reasons. Our script will look something like the following:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  user: root &#13;
  tasks: &#13;
  - name: Ensure ansible user exists &#13;
    user: &#13;
      name: ansible &#13;
      state: present &#13;
      comment: Ansible &#13;
  - name: Ensure ansible user accepts the SSH key &#13;
    authorized_key: &#13;
      user: ansible &#13;
      key: https://github.com/fale.keys &#13;
   state: present &#13;
  - name: Ensure the ansible user is sudoer with no password required &#13;
    lineinfile: &#13;
      dest: /etc/sudoers &#13;
      state: present &#13;
      regexp: '^ansible ALL\=' &#13;
      line: 'ansible ALL=(ALL) NOPASSWD:ALL' &#13;
      validate: 'visudo -cf %s' &#13;
</pre><p>Before running it, let's look at it a little bit. We have used three different modules (<code class="literal">user</code>, <code class="literal">authorized_key</code>, and <code class="literal">lineinfile</code>) that we have never seen. The <code class="literal">user</code> module, as the name suggests, allows us to make sure a user is present (or absent).</p><p>The <code class="literal">authorized_key</code> module allows us to ensure that a certain SSH key can be used to login as a specific user on that machine. This module will not substitute all the SSH keys that are already enabled for that user, but will simply add (or remove) the specified key. If you want to alter this behavior, you can use the <em>exclusive</em> option, that allows you to delete all the SSH keys that are not specified in this step.</p><p>The <code class="literal">lineinfile</code> module allows us to alter the content of a file. It works in a very similar way to <strong>sed</strong> (a stream editor), where you specify the regular expression that will be used to match the line, and then specify the new line that will be used to substitute the matched line. If no line is matched, the line is added at the end of the file. Now let's run it with:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, firstrun.yaml</strong>
</pre><p>This will give us the following result:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure ansible user exists] ********************************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure ansible user accepts the SSH key] *******************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure the anisble user is sudoer with no password required] *</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io     : ok=4   changed=3    unreachable=0    failed=0</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Configuring a basic server</h1></div></div></div><p>After we have created the user for Ansible with the necessary privileges, we can go on to make some other small changes to the OS. To make it more clear, we will see how each action is performed and then we'll look at the whole playbook.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Enabling EPEL</h2></div></div></div><p>EPEL is the most important repository for Enterprise Linux and it contains a lot of additional packages. It's also a safe repository since no package in EPEL will conflict with packages in the base repository. To enable EPEL in RHEL/CentOS 7, it is enough to just install the <code class="literal">epel-release</code> package. To do so in Ansible, we will use:</p><pre class="programlisting">- name: Ensure EPEL is enabled &#13;
  yum: &#13;
    name: epel-release &#13;
    state: present &#13;
  become: True &#13;
</pre><p>As you can see, we have used the <code class="literal">yum</code> module, as we did in one of the first examples of the chapter, specifying the name of the package and that we want it to be present.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Installing Python bindings for SELinux</h2></div></div></div><p>Since Ansible is written in Python and mainly uses the Python bindings to operate on the operating system, we will need to install the Python bindings for SELinux:</p><pre class="programlisting">- name: Ensure libselinux-python is present &#13;
  yum: &#13;
    name: libselinux-python &#13;
    state: present &#13;
  become: True &#13;
- name: Ensure libsemanage-python is present &#13;
  yum: &#13;
    name: libsemanage-python &#13;
    state: present &#13;
  become: True &#13;
</pre><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>This could be written in a shorter way, using a cycle, but we'll see how to do so in the next chapter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Upgrading all installed packages</h2></div></div></div><p>To upgrade all installed packages, we will need to use the <code class="literal">yum</code> module again, but with a different parameter, in fact we would use:</p><pre class="programlisting">- name: Ensure we have last version of every package &#13;
  yum: &#13;
    name: "*" &#13;
    state: latest &#13;
  become: True &#13;
</pre><p>As you can see, we have specified "<code class="literal">*</code>" as the package name (this stands for a wildcard to match all installed packages) and the <code class="literal">state</code> is <code class="literal">latest</code>. This will upgrade all installed packages to the latest version available.</p><p>If you remember, when we talked about the "<code class="literal">present</code>" state, we said that it was going to install the last available version. So what's the difference between "<code class="literal">present</code>" and "<code class="literal">latest</code>"? Present will install the latest version if the package is not installed, while if the package is already installed (no matter the version) it will go forward without making any change. Latest will install the latest version if the package is not installed, while if the package is already installed will check whether a newer version is available and if it is, Ansible will update the package.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Ensuring that NTP is installed, configured, and running</h2></div></div></div><p>To make sure NTP is present, we use the <code class="literal">yum</code> module:</p><pre class="programlisting">- name: Ensure NTP is installed &#13;
  yum: &#13;
    name: ntp &#13;
    state: present &#13;
  become: True &#13;
</pre><p>Now that we know that NTP is installed, we should ensure that the server is using the <code class="literal">timezone</code> that we want. To do so, we will create a symbolic link in <code class="literal">/etc/localtime</code> that will point to the wanted <code class="literal">zoneinfo</code> file:</p><pre class="programlisting">- name: Ensure the timezone is set to UTC &#13;
  file: &#13;
    src: /usr/share/zoneinfo/GMT &#13;
    dest: /etc/localtime &#13;
    state: link &#13;
  become: True &#13;
</pre><p>As you can see, we have used the <code class="literal">file</code> module to tell Ansible, specifying that it needs to be a link (<code class="literal">state: link</code>).</p><p>To complete the NTP configuration, we need to start the <code class="literal">ntpd</code> service and ensure that it will run at every, consequent boot:</p><pre class="programlisting">- name: Ensure the NTP service is running and enabled &#13;
  service: &#13;
    name: ntpd &#13;
    state: started &#13;
    enabled: True &#13;
  become: True &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Ensuring that FirewallD is present and enabled</h2></div></div></div><p>As you can imagine, the first step is to ensure that FirewallD is installed:</p><pre class="programlisting">- name: Ensure FirewallD is installed &#13;
  yum: &#13;
    name: firewalld &#13;
    state: present &#13;
  become: True &#13;
</pre><p>Since we want to be sure that, when we enable FirewallD we will not lose our SSH connection, we ensure that SSH traffic can always pass through it:</p><pre class="programlisting">- name: Ensure SSH can pass the firewall &#13;
  firewalld: &#13;
    service: ssh &#13;
    state: enabled &#13;
    permanent: True &#13;
    immediate: True &#13;
  become: True &#13;
</pre><p>To do so, we have used the <code class="literal">firewalld</code> module. This module will take parameters that are very similar to the ones the <code class="literal">firewall-cmd</code> console would use. You will have to specify the service that is to be authorized to pass the firewall, whether you want this rule to apply immediately, and whether you want the rule to be permanent so that after a reboot the rule will still be present.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>You can specify the service name (such as '<code class="literal">ssh</code>') using the <code class="literal">service</code> parameter, or you can specify the port (such as '<code class="literal">22/tcp</code>') using the <code class="literal">port</code> parameter.</p></div></div><p>Now that we have installed FirewallD and we are sure that our SSH connection will survive, we can enable it as we do any other service:</p><pre class="programlisting">- name: Ensure FirewallD is running &#13;
  service: &#13;
    name: firewalld &#13;
    state: started &#13;
    enabled: True &#13;
  become: True &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Adding a customized MOTD</h2></div></div></div><p>To add the MOTD, we will need a template that will be the same for all servers and a task to use the template.</p><p>I find it very useful to add a MOTD to every server. It's even more useful if you use Ansible, because you can use it to warn your users that changes to the system could be overwritten by Ansible. My usual template is called <code class="literal">'motd'</code>, and has this content:</p><pre class="programlisting">                This system is managed by Ansible &#13;
  Any change done on this system could be overwritten by Ansible &#13;
  &#13;
OS: {{ ansible_distribution }} {{ ansible_distribution_version }} &#13;
Hostname: {{ inventory_hostname }} &#13;
eth0 address: {{ ansible_eth0.ipv4.address }} &#13;
All connections are monitored and recorded &#13;
    Disconnect IMMEDIATELY if you are not an authorized user&#13;
</pre><p>This is a <code class="literal">jinja2</code> template and it allows us to use every variable set in the playbooks. This also allows us to use complex syntax for conditionals and cycles that we will see later in this chapter. To populate a file from a template in Ansible, we will need to use:</p><pre class="programlisting">- name: Ensure the MOTD file is present and updated &#13;
  template: &#13;
    src: motd &#13;
    dest: /etc/motd &#13;
    owner: root &#13;
    group: root &#13;
    mode: 0644 &#13;
  become: True &#13;
</pre><p>The template module allows us to specify a local file (<code class="literal">src</code>) that will be interpreted by <code class="literal">jinja2</code> and the output of this operation will be saved on the remote machine in a specific path (<code class="literal">dest</code>), be owned by a specific user (<code class="literal">owner</code>) and group (<code class="literal">group</code>), and have a specific access mode (<code class="literal">mode</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Changing the hostname</h2></div></div></div><p>To keep things simple, one way I find useful is to set the hostname of a machine to something meaningful. To do so, we can use a very simple Ansible module called <code class="literal">hostname</code>:</p><pre class="programlisting">- name: Ensure the hostname is the same of the inventory &#13;
  hostname: &#13;
    name: "{{ inventory_hostname }}" &#13;
  become: True &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Reviewing and running the playbook</h2></div></div></div><p>Putting everything together, we now have the following playbook (called <code class="literal">common_tasks.yaml</code> for simplicity):</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: ansible &#13;
  tasks: &#13;
  - name: Ensure EPEL is enabled &#13;
    yum: &#13;
      name: epel-release &#13;
      state: present &#13;
    become: True &#13;
  - name: Ensure libselinux-python is present &#13;
    yum: &#13;
      name: libselinux-python  &#13;
      state: present &#13;
    become: True &#13;
  - name: Ensure libsemanage-python is present &#13;
    yum: &#13;
      name: libsemanage-python &#13;
      state: present &#13;
    become: True &#13;
  - name: Ensure we have last version of every package &#13;
    yum: &#13;
      name: "*" &#13;
      state: latest &#13;
    become: True &#13;
  - name: Ensure NTP is installed &#13;
    yum: &#13;
      name: ntp &#13;
      state: present &#13;
    become: True &#13;
  - name: Ensure the timezone is set to UTC &#13;
    file: &#13;
      src: /usr/share/zoneinfo/GMT &#13;
      dest: /etc/localtime &#13;
      state: link &#13;
    become: True &#13;
  - name: Ensure the NTP service is running and enabled &#13;
    service: &#13;
      name: ntpd &#13;
      state: started &#13;
      enabled: True &#13;
    become: True &#13;
  - name: Ensure FirewallD is installed &#13;
    yum: &#13;
      name: firewalld &#13;
      state: present &#13;
    become: True &#13;
  - name: Ensure FirewallD is running &#13;
    service: &#13;
      name: firewalld &#13;
      state: started &#13;
      enabled: True &#13;
    become: True &#13;
  - name: Ensure SSH can pass the firewall &#13;
    firewalld: &#13;
      service: ssh &#13;
      state: enabled &#13;
      permanent: True &#13;
      immediate: True &#13;
    become: True &#13;
  - name: Ensure the MOTD file is present and updated &#13;
    template: &#13;
      src: motd &#13;
      dest: /etc/motd &#13;
      owner: root &#13;
      group: root &#13;
      mode: 0644 &#13;
    become: True &#13;
  - name: Ensure the hostname is the same of the inventory &#13;
    hostname: &#13;
      name: "{{ inventory_hostname }}" &#13;
    become: True  &#13;
</pre><p>Since this <code class="literal">playbook</code> is pretty complex, we can run the following:</p><pre class="programlisting">
<strong>$ ansible-playbook common_tasks.yaml --list-tasks</strong>
</pre><p>This asks Ansible to print all the tasks in a shorter form so that we can quickly see what tasks a <code class="literal">playbook</code> performs. The output should be something like the following:</p><pre class="programlisting">playbook: common_tasks.yaml &#13;
  play #1 (all): all TAGS: [] &#13;
    tasks: &#13;
      Ensure EPEL is enabled TAGS: [] &#13;
      Ensure libselinux-python is present TAGS: [] &#13;
      Ensure libsemanage-python is present TAGS: [] &#13;
      Ensure we have last version of every package TAGS: [] &#13;
      Ensure NTP is installed TAGS: [] &#13;
      Ensure the timezone is set to UTC TAGS: [] &#13;
      Ensure the NTP service is running and enabled TAGS: [] &#13;
      Ensure FirewallD is installed TAGS: [] &#13;
      Ensure FirewallD is running TAGS: [] &#13;
      Ensure SSH can pass the firewall TAGS: [] &#13;
      Ensure the MOTD file is present and updated TAGS: [] &#13;
      Ensure the hostname is the same of the inventory TAGS: [] &#13;
</pre><p>We can now run the <code class="literal">playbook</code> with the following:</p><pre class="programlisting">
<strong>$ ansible-playbook -itest01.fale.io, common_tasks.yaml</strong>
</pre><p>We will receive the following output:</p><pre class="programlisting">
<strong>PLAY [all] ******************************************************* &#13;
 &#13;
TASK [setup] ***************************************************** &#13;
ok: [test01.fale.io] &#13;
 &#13;
TASK [Ensure EPEL is enabled] ************************************ &#13;
changed: [test01.fale.io] &#13;
 &#13;
TASK [Ensure libselinux-python is present] *********************** &#13;
ok: [test01.fale.io] &#13;
 &#13;
TASK [Esure libsemanage-python is present] *********************** &#13;
ok: [test01.fale.io] &#13;
 &#13;
TASK [Ensure we have last version of every package] ************** &#13;
changed: [test01.fale.io] &#13;
 &#13;
TASK [Ensure NTP is installed] *********************************** &#13;
ok: [test01.fale.io] &#13;
 &#13;
TASK [Ensure the timezone is set to UTC] ************************* &#13;
changed: [test01.fale.io] &#13;
 &#13;
TASK [Ensure the NTP service is running and enabled] ************* &#13;
changed: [test01.fale.io] &#13;
 &#13;
TASK [Ensure FirewallD is installed] ***************************** &#13;
ok: [test01.fale.io] &#13;
  &#13;
TASK [Ensure FirewallD is running] ******************************* &#13;
changed: [test01.fale.io] &#13;
 &#13;
TASK [Ensure SSH can pass the firewall] ************************** &#13;
ok: [test01.fale.io] &#13;
 &#13;
TASK [Ensure the MOTD file is present and updated] *************** &#13;
changed: [test01.fale.io] &#13;
 &#13;
TASK [Ensure the hostname is the same of the inventory] ********** &#13;
changed: [test01.fale.io] &#13;
 &#13;
PLAY RECAP ******************************************************* &#13;
test01.fale.io     : ok=9   changed=7    unreachable=0    failed=0</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Installing and configuring a web server</h1></div></div></div><p>Now that we have made some generic changes to the operating system, let's move on to actually creating a web server. We are splitting those two phases so we can share the first phase between every machine and apply the second only to web servers.</p><p>For this second phase, we will create a new playbook called <code class="literal">webserver.yaml</code> with the following content:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: ansible &#13;
  tasks: &#13;
  - name: Ensure the HTTPd package is installed &#13;
    yum: &#13;
      name: httpd &#13;
      state: present &#13;
    become: True &#13;
  - name: Ensure the HTTPd service is enabled and running &#13;
    service: &#13;
      name: httpd &#13;
      state: started &#13;
      enabled: True &#13;
    become: True &#13;
  - name: Ensure HTTP can pass the firewall &#13;
    firewalld: &#13;
      service: http &#13;
      state: enabled &#13;
      permanent: True &#13;
      immediate: True &#13;
    become: True &#13;
  - name: Ensure HTTPS can pass the firewall &#13;
    firewalld: &#13;
      service: https &#13;
      state: enabled &#13;
      permanent: True &#13;
      immediate: True &#13;
    become: True   &#13;
</pre><p>As you can see, the first two tasks are the same as the ones in the example at the beginning of this chapter, and the last two tasks are used to instruct FirewallD to let HTTP and HTTPS traffic pass.</p><p>Let's run this script with the following:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, webserver.yaml</strong>
</pre><p>This results in the following:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure the HTTPd package is installed] *********************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure the HTTPd service is enabled and running] ***********</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure HTTP can pass the firewall] *************************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure HTTPS can pass the firewall] ************************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io    : ok=5    changed=4    unreachable=0    failed=0</strong>
</pre><p>Now that we have a web server, let's publish a small single-page static website.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Publishing a website</h1></div></div></div><p>Since our website will be a simple, single page website, we can easily create it and publish it using a single Ansible task. To make this page a little bit more interesting, we will create it from a template that will be populated by Ansible with a little data about the machine. The script to publish it will be called <code class="literal">deploy_website.yaml</code> and will have the following content:</p><pre class="programlisting">--- &#13;
- hosts: all &#13;
  remote_user: ansible &#13;
  tasks: &#13;
  - name: Ensure the website is present and updated &#13;
    template: &#13;
      src: index.html.j2 &#13;
      dest: /var/www/html/index.html &#13;
      owner: root &#13;
      group: root &#13;
      mode: 0644 &#13;
    become: True &#13;
</pre><p>Let's start with a simple template that we will call <code class="literal">index.html.j2</code>:</p><pre class="programlisting">&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;h1&gt;Hello World!&lt;/h1&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Now we can test our website deployment by running the following:</p><pre class="programlisting">
<strong>$ ansible-playbook -i test01.fale.io, deploy_website.yaml</strong>
</pre><p>We should receive the following output:</p><pre class="programlisting">
<strong>PLAY [all] *******************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [test01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Ensure the website is present and updated] *****************</strong>
<strong>changed: [test01.fale.io]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>test01.fale.io    : ok=2    changed=1    unreachable=0    failed=0</strong>
</pre><p>If you now go to your test machine IP/FQDN in your browser, you'll find the "Hello World!" page.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Jinja2 templates</h1></div></div></div><p>
<strong>Jinja2</strong> is a widely-used and fully-featured template engine for Python. Let's look at some syntax that will help us with Ansible. This paragraph does not want to be a replacement for the official documentation, but its goal is to teach you some components that you'll find very useful when using them with Ansible.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Variables</h2></div></div></div><p>As we have seen, we can print variable content simply with the '<code class="literal">{{ VARIABLE_NAME }}</code>' syntax. If we want to print just an element of an array we can use '<code class="literal">{{ ARRAY_NAME['KEY'] }}</code>', and if we want to print a property of an object, we can use '<code class="literal">{{ OBJECT_NAME.PROPERTY_NAME }}</code>'.</p><p>So we can improve our previous static page in the following way:</p><pre class="programlisting">&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;h1&gt;Hello World!&lt;/h1&gt; &#13;
        &lt;p&gt;This page was created on {{ ansible_date_time.date }}.&lt;/p&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Filters</h2></div></div></div><p>From time to time, we may want to change the style of a string a little bit, without writing specific code for it, for example, we may want to capitalize some text. To do so, we can use one of Jinja2's filters, such as: '<code class="literal">{{ VARIABLE_NAME | capitalize }}</code>'. There are many filters available for Jinja2 and you can find the full list at: <a class="ulink" href="http://jinja.pocoo.org/docs/dev/templates/#builtin-filters">http://jinja.pocoo.org/docs/dev/templates/#builtin-filters</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Conditionals</h2></div></div></div><p>One thing you may often find useful in a template engine is the possibility of printing different strings depending on the content (or existence) of a string. So we can improve our static web page in the following way:</p><pre class="programlisting">&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;h1&gt;Hello World!&lt;/h1&gt; &#13;
        &lt;p&gt;This page was created on {{ ansible_date_time.date }}.&lt;/p&gt; &#13;
{% if ansible_eth0.active == True %} &#13;
        &lt;p&gt;eth0 address {{ ansible_eth0.ipv4.address }}.&lt;/p&gt; &#13;
{% endif %} &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>As you can see, we have added the capability to print the main IPv4 address for the <code class="literal">eth0</code> connection, if the connection is <code class="literal">active</code>. With conditionals we can also use the tests.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>For a full list, please refer to: <a class="ulink" href="http://jinja.pocoo.org/docs/dev/templates/#builtin-tests">http://jinja.pocoo.org/docs/dev/templates/#builtin-tests</a>.</p></div></div><p>So to obtain the same result we could also have written the following:</p><pre class="programlisting">&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;h1&gt;Hello World!&lt;/h1&gt; &#13;
        &lt;p&gt;This page was created on {{ ansible_date_time.date }}.&lt;/p&gt; &#13;
{% if ansible_eth0.active is equalto True %} &#13;
        &lt;p&gt;eth0 address {{ ansible_eth0.ipv4.address }}.&lt;/p&gt; &#13;
{% endif %} &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>There are a lot of different tests that will really help you to create easy-to-read, effective templates.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Cycles</h2></div></div></div><p>The <code class="literal">jinja2</code> template system also offers the capability to create cycles. Let's add a feature to our page that will print the main IPv4 network address for each device instead of only <code class="literal">eth0</code>. We will then have the following code:</p><pre class="programlisting">&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;h1&gt;Hello World!&lt;/h1&gt; &#13;
        &lt;p&gt;This page was created on {{ ansible_date_time.date }}.&lt;/p&gt; &#13;
        &lt;p&gt;This machine can be reached on the following IP addresses&lt;/p&gt; &#13;
        &lt;ul&gt; &#13;
{% for address in ansible_all_ipv4_addresses %} &#13;
            &lt;li&gt;{{ address }}&lt;/li&gt; &#13;
{% endfor %} &#13;
        &lt;/ul&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>As you can see, the syntax for cycles is familiar if you already know Python.</p><p>These few pages on Jinja2 templating were not a substitute for the official documentation. In fact Jinja2 templates are much more powerful than what we have seen here. The goal here is only to give you the basic Jinja2 templates that are most often used in Ansible.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we started looking at YAML and saw what a playbook is, how it works, and how to use it to create a web server (and a deployment for your static website). We have also seen multiple Ansible modules such as the user, yum, service, FirewalID, lineinfile, and template modules. At the end of the chapter, we focused on templates.</p><p>In the next chapter, we will talk about inventories so that we can easily manage multiple machines.</p></div></body></html>