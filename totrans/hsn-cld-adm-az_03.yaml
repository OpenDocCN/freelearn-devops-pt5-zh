- en: Infrastructure as a Service - the First Layer of Cloud Computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our cloud journey is to leverage the Azure Virtual Machines
    offering as part of Azure IaaS. This is the first logical step when moving our
    workloads to the cloud, as managing Azure Virtual Machines is not much different
    from managing local VMs. We no longer have access to the virtualization host and
    hardware, but administrating and managing Azure VMs is no different from administrating
    and managing local servers or VMs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll show you how to achieve high availability of your services and how to
    scale out workloads as one of the main benefits that Microsoft Azure offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Areas that we''ll cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure Virtual Machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Azure Virtual Machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Azure Load Balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Azure Load Balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Azure Virtual Machines scale sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Azure Virtual Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment of any Azure resource can be done in several ways and it's no different
    with Azure Virtual Machines. We can use the Azure portal, ARM templates, Azure
    PowerShell, or Azure CLI. We will discuss all these methods but for the time being
    we'll stick to the Azure portal and occasionally use ARM templates. This is to
    gain better knowledge of Azure services and what is created in each deployment.
    Other tools can help us in the long run, especially when we talk redeployment
    and automation, but we'll get to that part later.
  prefs: []
  type: TYPE_NORMAL
- en: We already did a quick create of an Azure VM, but this time we'll look more
    closely for options that are available as last time we only considered the Azure
    networking part as the important one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Azure Virtual Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a new Azure VM, we need to select New resource and select New Virtual
    Machine.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to select the operating system for our VM. There are hundreds
    of images available to select from both Windows and Linux. It's important to mention
    that more and more Linux VMs are deployed to Azure daily. Information from the
    end of 2017 tells us that more than 40% of all Azure Virtual Machines are running
    Linux, and that percentage is probably up since then.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supported versions of Windows Server in Azure are:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Server 2008 R2 SP1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2012 R2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Linux, there are too many versions to name but supported distributions
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RHEL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All images can be selected as a minimum installation or preconfigured with additional
    software installed. For example, we can select Windows Server 2016 with all settings
    at default or select an image that has SQL Server installed and ready to use.
    We can choose the same for Linux, choose minimum installation, or choose an already
    configured image with software such as Chef, Puppet, Jenkins, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an option to choose your custom image with the configuration and
    software of your choosing. This can be an image of your on-premises VM that is
    uploaded to Azure or an image created from another Azure VM.
  prefs: []
  type: TYPE_NORMAL
- en: After we choose the OS, we start a new blade that will take us through three
    stages.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Azure Virtual Machine information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to provide basic information for our VM. A name needs to be
    provided for any type of resource in Azure. It's useful to give names based on
    procedures and roles as this will help in later management. It's easier when the
    name of your VM gives you a hint about what its purpose is. As I intend to use
    this one as a web server, I'll name it `WebSrv1`.
  prefs: []
  type: TYPE_NORMAL
- en: VM disk type lets us choose between two values—HDD and SSD. This can be critical
    for our VM as the disk type can significantly impact performance. As this impacts
    the price of the VM as well, we need to find a balance and choose based on expected
    workloads. Choosing HDD may be good enough if we create a web server but if you're
    going to deploy a database server, SSD is the recommended option.
  prefs: []
  type: TYPE_NORMAL
- en: The Username option doesn't allow us to use most common server usernames such
    as `Admin`, `Administrator`, `SysAdmin`, and similar. This is in order to protect
    your cloud resources. As most Azure VMs with a public IP address can be accessed
    through RDP, it's critical to limit that access as much as possible. I have multiple
    VMs that are attacked daily and the most common attempts are made using these
    exact usernames. We can apply additional security to VMs and usernames, but we'll
    discuss that in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to any other resource, we need to provide information for the Subscription,
    the Resource group, and Location where the VM will be deployed. An example of
    basic information can be seen in the screenshot shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5f54b82-dcd4-422b-a6a4-a01e58b70e0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Virtual Machine sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second step in the Azure Virtual Machine creation blade is to choose the
    size of your VM. The size of the VM will determine three things—the number of
    CPUs, the amount of memory, and the type of OS disk. As you choose the type of
    disk in step one as well, this will narrow down the options that are available.
    VM sizes have three different pricing tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic-tier VMs are intended for `dev/test` environments and, even though they
    have a similar performance to VMs on the standard tier, there are a few limitations.
    They have lower IOPS than standard-tier VMs and don't support load balancing or
    auto-scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Standard-tier VMs are intended to be used in a production environment and have
    better CPUs and IOPS performance.
  prefs: []
  type: TYPE_NORMAL
- en: Low-priority VMs are allocated based on free and unused resources in Azure Datacenter.
    They come with a lower price but can be unavailable at any time, as Microsoft
    Azure may claim these resources to satisfy requests with a higher priority. They
    are intended to be used for batch processing and random jobs.
  prefs: []
  type: TYPE_NORMAL
- en: But the pricing tier isn't the only thing to determine the price of your VM.
    Each tier has different sizes that provide a certain amount of CPU and memory;
    a higher amount equals a higher price.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard tier has additional categories based on the VM purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute-optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage-optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-performance compute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these are self-explanatory as general-purpose has a balanced CPU-to-memory
    ratio, compute-optimized has more CPU, memory-optimized has more RAM, and storage-optimized
    has the best IOPS. GPUs are specialized VMs for heavy graphic rendering and video
    editing. High-performance VMs have at least eight vCPUs and use DDR4 RAM.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the VM also determines the number of NICs that can be attached to
    your VM.
  prefs: []
  type: TYPE_NORMAL
- en: This can be from one to eight depending on purpose and size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options for selecting the VM size can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ada72268-d797-4cb6-8e9b-ec5d827cfa04.png)'
  prefs: []
  type: TYPE_IMG
- en: Advanced VM options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third blade gives us the option to configure a lot of additional settings.
    In the previous chapter, we focused only on the networking part, but this time
    we'll explore these options more closely.
  prefs: []
  type: TYPE_NORMAL
- en: The high availability section gives us two options—Availability zone and Availability
    set.
  prefs: []
  type: TYPE_NORMAL
- en: The Availability zone determines the zones inside the Azure Datacenter. These
    zones have an independent power source, networking, and cooling, and protect your
    VM against failures inside the Datacenter. If you have a critical service that
    will run on multiple VMs, you want to place these VMs in different availability
    zones so, if there is a failure on the Datacenter level, there is less chance
    that all your VMs will be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Availability set does similar things on a host level, ensuring that your VMs
    are placed across multiple physical servers, compute racks, storage units, and
    network switches. If hardware failure occurs, there is less chance that all your
    VMs will be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these availability options can't be changed later. You need to define
    the Availability zone and Availability set during the creation process. This is
    important to remember if you plan to design highly available solutions and services.
  prefs: []
  type: TYPE_NORMAL
- en: I'll place this VM in an Availability set named (new) WebSet as I intend to
    use it later.
  prefs: []
  type: TYPE_NORMAL
- en: Storage options allow us to choose between Disk type and Use managed disks.
    The Disk type option is the same as we had before; we can choose between HDD and
    SSD. Depending on the size of VM chosen, all types of disk may not be available
    to choose here. If you want to choose a different option that is not available,
    you need to go back and choose a different size of VM.
  prefs: []
  type: TYPE_NORMAL
- en: Use managed disks are there to make our lives a little easier. This option was
    available from February 2017 and, prior to this, we need to manage storage on
    our own. Creating a disk actually creates a storage account and we needed to manage
    that storage. With a managed disk, we don't have to be concerned with this and
    it's managed automatically. Storage is still created but, if we choose Use managed
    disks, everything is handled in the background and no user action is required.
    This can be especially useful when scaling our VM (or VM Scale Sets). Managed
    disks also introduced a few very useful features such as snapshots and backups.
    I strongly recommend using a managed disk as this helps you get better performance
    with less management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting for high availability and disks can be seen in the screenshot shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ba84a39-99de-4991-a2a5-5700e3d276cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Networking options were covered in the previous chapter but let''s quickly
    review what our options are here. We can select our VNet, subnet on that VNet,
    and public IP address for our VM. The last networking option is to select the
    **network security group** (**NSG**) for our VM. In the following screenshot,
    you can see that I selected PacktVNet and the DMZ (10.1.1.0/24) subnet. A new
    public IP address is created for my new VM as I intend to use it as a web server.
    As I have the NSG rule applied on the DMZ subnet, I don''t want to separate the
    NSG on the VM level. This will help me simplify management and keep standardized
    rules across all my VMs, so I''ll leave the NSG field blank as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb634969-8f14-4667-acf2-caa0c81a7705.png)'
  prefs: []
  type: TYPE_IMG
- en: Extensions gives us the option to add additional features to our VM. You can
    choose from set predefined software or execute a custom script that will install
    additional software or features.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-shutdown can help you save on computing hours if you don't need the VM
    to run 24/7\. For example, if this is a `dev` environment and no one is using
    it after work hours, you can set Auto-shutdown to shut down your VM every day
    at 5 p.m. so you don't pay for it overnight. Of course, if this web or database
    server is in production, this isn't an option you really want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring can be Enabled for boot diagnostics and guest OS monitoring. This
    is beside the basic monitoring options that are available by default. Both of
    these options will require a storage account where logs will be stored. Avoid
    using storage that is used for a VM disk as this can cause performance issues.
    If your VM is having performance issues on a disk level, this will generate more
    logs, and these logs will increase the load on storage on top of that. This will
    cause more disk issues and you will be in an infinite loop where you won't be
    able to see if the issue is caused by disk or by logs.
  prefs: []
  type: TYPE_NORMAL
- en: The last options are Managed service identity and Backup. Managed service identity allows
    you to use your Azure Active Directory with your VM, and Backup will create an
    additional backup service (Azure Backup). Both of these services will be covered
    in more depth later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options for Extensions, Auto-shutdown, Monitoring, Managed service identity,
    and Backup can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7afa1b96-e018-436e-8a12-fafbe642b7e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we can start deployment and after a few minutes we can start using
    our VM. As I mentioned before, the time taken to create a new VM can depend on
    the size of the VM and the availability of resources in the Azure Datacenter.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Azure Virtual Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After deployment is completed, we can see four different resources have been
    created—`Virtual machine`, `Disk`, `Network interface` and `Public IP address`.
    A `Public IP address` is optional and doesn''t need to be created if you intend
    to use and manage the VM only using private IP addresses with the use of VPN.
    If a managed disk wasn''t chosen, there would be a storage account where the disk
    would be placed here as well, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4623beb7-47da-4285-8135-5d5d0fc7c3de.png)'
  prefs: []
  type: TYPE_IMG
- en: Every one of these resources has different options for management. We have already
    seen options for IP addresses and NICs; we'll explore disk and storage in later
    chapters. For now, let us focus on the VM and what options are available to us
    for administration and management.
  prefs: []
  type: TYPE_NORMAL
- en: VM settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under the Virtual Machine blade, we have various options such as SETTINGS,
    OPERATIONS, MONITORING, and SUPPORT. Under SETTINGS, we have multiple choices
    as well: Networking, Disks, Size, Security, Extensions, Availability set and Configuration.
    Properties, Locks and Automation script are available as for all other Azure resources
    as well. Note that we have Continuous delivery (Preview) here as well. Preview
    features are still in development and they aren''t intended for production purposes.
    It''s fine to test but avoid depending on these features until they are officially
    released. In this instance, Continuous delivery (Preview) allows us to connect
    to VSTS projects and make easier CI/CD.'
  prefs: []
  type: TYPE_NORMAL
- en: Some options here are similar to options in the VM creation process. Size will
    allow us to open the blade to choose a different size for our VM at any time.
    Note that to complete this process, a restart of the VM is required. Extensions
    can be used to add software or execute custom scripts, the same as before. Availability
    set is only for information purposes as this setting needs to be defined during
    VM creation. Security and Configuration will be our focus in chapters to come
    and we'll leave these settings as defaults for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Networking option gives us an overview of all network information regarding
    our VM. We can see NIC information, what addresses are associated with our VM,
    the network security group associated with the VM and all NSG rules. We can attach
    additional NICs here and add additional NSG rules. Note that in the following
    screenshot, the NSG is applied on the subnet level. If changes are made to the
    NSG, these will be applied to all VMs on this subnet so you need to be careful.
    For example, if this subnet had multiple VMs and we wanted to allow RDP access
    to a single one, creating this rule would result in all VMs being accessible over
    RDP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2204e568-b80d-45e0-a6bf-0d450f733157.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the disk blade, we can see all disks associated with our VM. The OS disk
    can''t be changed, data disks can be added or removed. An example of the disk
    blade can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e77ab337-1867-48a3-b7f4-4eafdd91080e.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Virtual Machine operation and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OPERATIONS and MONITORING give us more administration and managing options for
    our Azure Virtual Machines. In OPERATIONS, we have Auto-shutdown, Backup, Disaster
    recovery, Update management, Inventory, Change tracking, and the Run command.
    We will explain Auto-shutdown and the Run command now but the rest of these features
    require additional services that we'll cover later.
  prefs: []
  type: TYPE_NORMAL
- en: We have a similar situation with MONITORING , we'll cover Metrics and Alerts
    (classic) now and the rest of the services will be explained in the chapters to
    come.
  prefs: []
  type: TYPE_NORMAL
- en: The Auto-shutdown option enables you to schedule the shutdown of your VM in
    Azure. As I mentioned before, this option allow us to save money if we don't need
    the VM to run all the time. The feature is intended to be used in `dev/test` environments
    and isn't for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I''ve seen people using it for applications that are needed only during
    working hours. In that case, Auto-shutdown is used to turn the VM off at specific
    times and use Azure Automation for starting it before work hours begin. Other
    than for scheduled time, we have options to send a notification when the VM is
    going to be turned off. This allows us to notify people using the VM that shutdown
    will occur. We can use email or webhooks for these notifications. The following
    screenshot shows the `run` script option. We can use various prepared scripts
    such as `EnableAdminAcount`, `SetRDPPort`, `ResetAccountPaasword`, and so on.
    Or we can execute a custom script against our VM. Options for script execution
    can be seen in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4f403d6-fde6-4601-8ea4-9f5232475398.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The running command can be done directly through the portal. This can be really
    useful when we can''t access the VM any other way (for example, from a mobile
    device or machine that doesn''t have PowerShell). An example is shown in the following
    screenshot where the script to enable `PSRemoting` is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51fc783d-335b-499a-ba91-145be37d7cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is also the script to enable `PSRemote` on the Azure Virtual Machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Monitoring your Azure resources is important on many levels. It gives you the
    ability to see your resource consumption and plan the pricing tier accordingly.
    If monitoring shows that your resources are under a certain percentage of workload,
    it''s probably a good idea to lower the resource tier. If it''s another way around
    and you have a high percentage all the time, it''s probably a good idea to change
    to a higher tier. A lot of different metrics are available but not for CPU and
    memory monitoring, you need to enable guest-level monitoring. Metrics gives us
    the option to change different metrics over different time periods. An example
    is show in the screenshot here where you can see graphs on disk `read` and `write`
    operations over the last hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50694a93-185e-44c2-afd6-a6ef62bdc8ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Alerts are an essential part of your Azure resource management and can be real
    lifesavers. In alerts, you can create custom rules that will notify you if a defined
    trigger is activated. For example, you can set up alerts that will notify you
    if the CPU reaches a threshold of 90% utilization over a period of more than 5
    minutes. Similar to auto-shutdown, you can send notifications via email or webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7baf9a3-0b9b-4099-a3cf-2882166e2225.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Beside sending a notification, alerts can be set to trigger a custom action
    with the use of runbooks or logic apps. Both are powerful tools to perform custom
    actions when needed. The logic app is easy to use with workflow diagrams that
    enable you to drag and drop actions that need to be taken, in order to perform
    some maintenance tasks or resolve issues. Runbooks require an Azure Automation
    account and can perform actions based on predefined plans or use custom scripts.
    Most administrators find runbooks more useful as they allow you to perform any
    type of action using PowerShell. In my opinion, both are very useful but administrators
    find runbooks more familiar as they can use PowerShell, which is the tool they
    used for on-premises administration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf66f9de-c614-4550-837e-1f54c3979c51.png)'
  prefs: []
  type: TYPE_IMG
- en: If we select to perform an action via runbooks, we can select either a user-defined
    or built-in action. With a user-defined action, you need to select an automation
    account and select a custom runbook in that account to be executed. This can be
    any type of script that will be executed on your Azure VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Built-in action offers you five options: Restart VM, Stop VM, Scale Up VM,
    Scale Down VM, and Remove VM. An example of a runbook configuration is shown here
    with Built-in runbooks listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07fffd74-9c90-4a0e-944e-c622591f7b28.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of these actions are self-explanatory, but note that you have Scale Up
    VM and Scale Down VM. This allows us to create a scaling up or scaling down of
    our resources based on demand. One of the cloud's benefits is to pay for what
    you use, when you use it. So, if our VM can handle workloads 90% of the time but
    we have peaks in workload only occasionally, we try to avoid paying more to satisfy
    only peaks. If we scale up permanently only to handle peak workloads, we pay more
    and now have a VM that isn't fully utilized 90% of the time, as a lower price
    VM could handle everything but peak periods. Setting up a Scale Up VM rule allows
    you to change your VM size to a higher tier in case 90% CPU is reached. This will
    enable your VM to handle workloads when the threshold is reached and increase
    the VM size on demand. To make the most out of what Microsoft Azure is offering,
    you need to create a similar rule in the other direction, to scale down once workload
    decreases. Having only a rule to scale up will increase the price of your VM and
    you will end up paying more. To prevent this, you can create a rule that when
    the CPU falls below 40%, a Scale Down VM action is performed and the VM is reverted
    to its original size. This way you will pay for more only when workload demands,
    and pay less for periods when workload isn't high.
  prefs: []
  type: TYPE_NORMAL
- en: The SUPPORT + TROUBLESHOOTING section give us a few additional options. Resource
    health and New support request are options present for all Azure resources. The
    first one gives you information if there is an issue with your VM on the Azure
    Datacenter level, and the second one takes you to the form to submit an Azure
    support ticket. Resource health can be useful to check when your resource isn't
    performing as usual. This can save you time troubleshooting and trying to figure
    out what went wrong when in fact there is a large issue at the Datacenter level
    you can't do anything about. Luckily, this isn't a common occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Boot diagnostics gives you the ability to see the current screen of your VM
    and serial log. It can be very helpful when the VM is unresponsive in order to
    check the current state.
  prefs: []
  type: TYPE_NORMAL
- en: With the Reset password option, you can reset the password for the VM but only
    if you know the correct username. Once you log in to the VM, you'll need to reset
    the password again as the password used here is only temporary. Reset password
    also has the option to reset the remote desktop service configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Serial console (Preview) gives you access to Windows serial console through
    your browser. However, this feature is still in preview so you shouldn't rely
    on it too much.
  prefs: []
  type: TYPE_NORMAL
- en: Redeploy is a very interesting feature. If your VM is unresponsive and you can't
    connect, you can use this feature. Redeploying the VM will migrate your VM to
    a new host in the Azure Datacenter to try to fix your issue. Migration will cause
    the reboot of your VM, which is unresponsive to begin with, so this isn't really
    an issue and may resolve the problem you have.
  prefs: []
  type: TYPE_NORMAL
- en: Features and options listed here are management options specific to Azure Virtual
    Machines. Managing the VM continues with the use of standard administrator tools.
    We can connect to the VM via RDP and perform any kind of task we want. We can
    install roles and features to our VM, add any kind of third-party software or
    our custom software. Other administration tools such as **Remote Server Administration
    Tools** (**RSAT**) or PowerShell are also options.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Load Balancers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Azure Virtual Machines is the first step but what about business critical
    services and applications. For these, we'll probably want to design highly available
    solutions that will have the best possible **service level agreement** (**SLA**)
    and uptime.
  prefs: []
  type: TYPE_NORMAL
- en: The first step for this must be performed during VM creation with the setting
    up of an Availability zone and Availability set. Then we add another VM to our
    solution with a different Availability zone and the same Availability set. This
    will ensure that the VMs are placed in different zones in the Azure Datacenter
    and don't depend on the same power source, networking, and cooling. If there is
    an issue within the Azure Datacenter, there is less chance that both VMs will
    be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the same Availability set will insure that VMs are placed on different physical
    servers, compute racks, storage units, and network switches. If hardware failure
    occurs, there is less chance both VMs will be affected. Another thing availability
    set takes care of is that Microsoft will never perform maintenance that will impact
    both VMs at the same time. To keep Azure Datacenters secure and performing in
    the best possible way, maintenance tasks must be performed periodically to install
    updates to hosts, or upgrade firmware on hardware. Placing VMs in an availability
    set informs Microsoft that these VMs are set up to achieve high availability,
    and maintenance will be performed keeping this in mind and never affecting all
    VMs at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: So, to achieve high availability, we need at least two VMs set up. But what
    about traffic? How do we direct whether something goes to the first or the second
    VM? If the first VM isn't available, how do we direct traffic to the second one?
  prefs: []
  type: TYPE_NORMAL
- en: This is where Azure Load Balancers come into play. This is one of Azure's network
    services that we skipped before and will explain when the time is right. We will
    have similar situations in later chapters as well. Azure Load Balancers distribute
    incoming traffic from frontend to backend pool instances. They can support both
    inbound and outbound scenarios with low latency and high throughput. In this scenario,
    incoming traffic would come to the Load Balancer IP and the Load Balancer would
    distribute traffic to VMs configured in the backend pool. Azure Load Balancer
    can be internal or public, depending on what kind of traffic we need to distribute.
    For web server roles, we probably want public Load Balancers. But in the case
    of a database server, we probably want to use an internal one as we don't want
    databases exposed over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Load Balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a new Azure Load Balancer, we need to select to create a new resource
    and select Azure Load Balancer from the list. This will open the create load Balancer
    blade where we need to provide basic information.
  prefs: []
  type: TYPE_NORMAL
- en: The information that is the same for all resources are Name, Subscription, Resource
    group, and Location.
  prefs: []
  type: TYPE_NORMAL
- en: Options specific to Azure Load Balancer are Type, SKU, and Public IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The Type of Load Balancer can be internal or external, depending on what kind
    of traffic you want to route. A Public type must have the public IP address configured
    and I recommend you place static for this IP address. Optionally, you can enable
    Public IPv6 for your Azure Load Balancer while Public IPv4 is the default.
  prefs: []
  type: TYPE_NORMAL
- en: The **stock keeping unit** (**SKU**) can be Basic or Standard. Standard has
    more options and features available but comes at a price that is formed based
    on the number of load-balancing rules. On the other hand, Basic is free of charge
    and the only fee associated with it comes from reserving public IP addresses and
    outbound traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the information needed to create a new Azure Load Balancer is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e75172d-09fe-4df3-8579-5e84925d8ac3.png)'
  prefs: []
  type: TYPE_IMG
- en: Deployment of most Azure Network features is done in under one minute. Azure
    Load Balancer is no different and deployment should complete very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Azure Load Balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the deployment of the Azure Load Balancer is completed, we can go to the
    resource and find different options. SETTINGS is of most interest to us and we'll
    need it to configure our Load Balancer. We can find standard Azure resource settings
    such as Properties, Locks, and Automation script that can be found for all Azure
    resources. Frontend IP configuration gives us the ability to manage IP addresses
    associated with our Load Balancer, add new IP addresses, or remove existing ones.
    Other settings will be needed to configure our Load Balancer to distribute incoming
    traffic and to configure where that traffic should be directed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to configure the Backend pools for our Load Balancer. I''ll
    select my Load Balancer to be associated to an Availability set. Previously in
    this chapter, I created a VM named `WebSrv1` with an Availability set named `WebSet`.
    Then I added an identical VM named `WebSrv2` and added it to the same Availability
    set. So, I have two identical VMs in the same Availability set and I have associated
    my Azure Load Balancer to this set. Finally, we have to define the network IP
    configuration that will be used and set it up to use both VMs in this availability
    set. If we had more VMs in this Availability set, we could set up more IP configurations
    to be targeted. An example of how to set up a backend pool is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4abd8206-2a47-4604-a6ce-b34f733f36b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second step is to set up health probes. We need to define the Protocol,
    Port, Interval, and Unhealthy threshold. Protocol and Port will define what needs
    to be monitored. As I intend to use `WebSrv1` and `WebSrv2` as web servers, I''ll
    set up monitoring on port `80`. Interval will define how often a check needs to
    be performed in order to make sure the server is responsive. The threshold defines
    how many consecutive intervals must probe and fail to contact the server in order
    to declare it unresponsive. An example of how to set up a health probe on port
    `80` is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c915be24-918e-4423-a05c-55067b47026b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As I want to use the web server role, I''ll repeat the same thing for port
    `443`. In the screenshot here, we can see both probes are created but the USED
    BY information is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf31447c-8b5f-400e-ac4a-92d4c462fc67.png)'
  prefs: []
  type: TYPE_IMG
- en: In the third step, we create a load-balancing rule. We need to provide a Name,
    IP Version, Frontend IP address, Protocol, Frontend port, Backend port, Backend
    pool, Health probe, Session persistence, and Idle timeout (minutes). Name and
    IP Version are self-explanatory options, so let's jump on the rest of them.
  prefs: []
  type: TYPE_NORMAL
- en: For the Frontend IP address, you can choose any of the Load Balancer IP addresses
    as it can be associated with multiple IP addresses. There is a restriction on
    what IP address you can choose based on the IP version selected. If the IP Version
    is set to IPv4, you can select only the IPV4 IP address. If IPv6 is selected,
    only the IP addresses of the same version associated with the Load Balancer can
    be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol and Port are connected, with this option you select what protocol needs
    to be forwarded from the defined port to the defined Backend port. For example,
    TCP on port `80` should be forwarded to port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: With the Backend pool, we define where traffic is forwarded to. As you can have
    multiple backend pools in a single Azure Balancer, you can select any of these
    pools.
  prefs: []
  type: TYPE_NORMAL
- en: Health probe needs to be selected in order to have a check on the VM state.
    You need to select the probe that performs a check on the backend port used in
    the rule you are creating.
  prefs: []
  type: TYPE_NORMAL
- en: Options for Sessions persistence and Idle timeout (minutes) are related to how
    client connections should be handled. As you have at least two VMs in your Backend
    pool, you need to set traffic to be handled by the same VM for the duration of
    one session. If you select that traffic coming from the same client IP over the
    same protocol, this should keep the session alive. The client will be directed
    to the same VM as long as the session is active.
  prefs: []
  type: TYPE_NORMAL
- en: Idle timeout (minutes) determines how long the session will stay active if no
    action is taken. The default value is 4 minutes but it can be changed to up to
    30 minutes. With this setting, you determine how long the session will be active
    if the client isn't using the application, and isn't sending any messages in order
    to keep the session alive.
  prefs: []
  type: TYPE_NORMAL
- en: The option for a Floating IP (direct server return) address is Disabled by default
    and should only be used with SQL AlwaysOn Availability Listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the screenshot here, you can see the options to set up the load-balancing
    rule, HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/361606ca-297e-4c2b-8034-8a978c421af1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll create another rule named HTTPS for port `443`. Note in the screenshot
    here, that probes created earlier are now used by load-balancing rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/729b8657-8a15-4fe2-92e0-70e2efd081f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last option in the Load Balancer settings is the inbound NAT rule. It has
    similar options as the load-balancing rule with one exception. Traffic, in this
    case, isn''t forwarded to the backend pool but to a single VM. In the screenshot
    here, you can see how to set up an inbound NAT rule that will forward traffic
    coming over port `5589` (WinRM) to WebSrv1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd281842-088e-4403-8c24-9458d1c5afad.png)'
  prefs: []
  type: TYPE_IMG
- en: So, let's review what was achieved with setting the Load Balancer and availability set.
    We have two VMs acting as web servers in the backend pool. VMs are placed in different
    availability zones and the same availability set in order to increase the chance
    that at least one of the VMs is running. Health probes are checking if VMs are
    available on the defined port. If any of the VMs is unresponsive to two consecutive
    checks, it will be declared as failed. A load-balancing rule is set up to forward
    traffic that is coming over the Load Balancer public IP address to the backend
    pool. If both VMs in the backend pool are healthy, traffic will be forwarded on
    the round-robin rule. If the health probe declares any of the VMs unresponsive,
    all traffic will be forwarded to the VM that is in a healthy state. Sessions are
    kept alive based on the client IP, protocol, and idle timeout. Sessions from the
    same IP address over the same protocol will be forwarded to the same VM as long
    as a keep-alive signal is sent at least every 4 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure our application is up and running, even if a single VM fails.
    Failures can be caused by hardware or network errors in the Azure Datacenter (the
    availability zone and availability set ensure that both VMs are not affected).
    Placing more VMs in the availability set and backend pool increases the chances
    that at least one VM is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Load Balancer ARM template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the ARM template for creating a new Azure Load Balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Azure Virtual Machine Scale Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticity is one of the big benefits of cloud computing. We have the ability
    to scale up and down based on our workloads and demand. If we have increased workload,
    we scale up. If workload decreases, we scale back down. With a pricing model of
    paying for what you use and billing by the minute, this allow us to save money.
  prefs: []
  type: TYPE_NORMAL
- en: We have already explained how to set up scale up and scale down VMs in Microsoft
    Azure. Scaling up and down means to change the size of the VM to a bigger or smaller
    instance. This is called vertical scaling. This can be very useful, but this approach
    has one consequence—every time a VM size is changed, reboot occurs. So, vertical
    scaling can be helpful as it can increase the size of the VM to handle more workload,
    but it will always cause downtime in the period when the VM is rebooting.
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this is horizontal scaling, and for Azure Virtual Machines
    we can use Azure Virtual Machine Scale Set. Instead of changing the size of the
    VM, scale set creates additional instances of the VM and spreads the workload
    across instances using Azure Load Balancer. This is called horizontal scaling.
    The approach is similar to the high availability scenario but, instead of having
    multiple VMs in the availability set, scale set starts VMs based on workload and
    starts them only when needed. Another difference is that in the availability set,
    VMs are independent and an issue on one VM will not cause an issue on others.
    In scale set, all VMs take a copy of the primary VM, and if the primary VM is
    compromised, the issue will reflect across the scale set. We need to outline that
    the scale set is not a high availability solution but horizontal scaling based
    on workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Virtual Machine Scale Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new Azure Virtual Machine Scale Set and explain all the details
    as we go.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Azure Virtual Machine Scale Set, all information is provided
    in a single screen. In order to make it more visible, I have separated the screen
    into three images—basic and instances, autoscale, and networking.
  prefs: []
  type: TYPE_NORMAL
- en: The basic information for Scale Set is very similar to the basic information
    for VMs. This is only logical as scale set creates a primary VM and then clones
    this VM in order to scale out. We need to provide a Virtual machine scale set
    name, Operating system disk image, Subscription, Resource group, Location, Username,
    Password, and optionally add an Availability zone.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the instance rules. This will determine the size of VMs in Scale
    Set and how many instances scale set is allowed to create. The maximum number
    of instances allowed is 1,000 for Azure-provided OS images and 300 for custom
    OS images. If you have an issue on the application and the application itself
    is causing high CPU or memory, it will cause scale set to scale out and create
    new instances. As new instances are an identical replica of the primary VM, the
    issue will persist on these VMs and scaling out will continue until you reach
    the maximum instance count. It's important to set up an instance count to something
    you are actually ready to pay for, as spinning 1,000 VMs can cause significant
    financial impact, even for a short period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying scale set VMs as low-priority can save you up to 80% in prices. Low-priority
    VMs are created using allocated and unused resources in the Azure Datacenter but
    these resources can be claimed by higher priority resources and can be unavailable
    at any time. So, even if this option can help you save a lot of money, resources
    may not be available when needed. This option shouldn't be used for services that
    are required to be available at any time, or for critical services. The recommendation
    is to use lower priority only for low-priority services or batch processing.
  prefs: []
  type: TYPE_NORMAL
- en: Scale Set creates multiple instances of a VM and all these VMs have a separate
    disk. Managing these disk and storage accounts in a scale-out process, especially
    when we spin up 1,000 instances, can prove to be very challenging. I recommend
    using a managed disk that will be managed by Azure automatically so you don't
    need to worry about this part.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of basic and instance settings is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71462f2b-fd3d-4bb9-a355-caf8117293ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Auto-scale creates a set of rules on how your scale set is going to scale in
    and out. We need to set a minimum and maximum number of VMs in our scale set.
    A maximum number is automatically collected from the instance count previously
    set, but it doesn't have to be the same. The Instance count determines how many
    VMs are going to be created initially but the maximum number determines how many
    VMs can be created in total.
  prefs: []
  type: TYPE_NORMAL
- en: We create scale-out and scale-in rules that will increase and decrease the number
    of VMs in our scale set. For example, if the threshold reaches `75`% of CPU utilization,
    it will spin up additional VM(s). If utilization falls below `25`%, it will decrease
    the number of VM(s) in the scale set. The number of VMs that will be added/removed
    can be set as a separate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we set a minimum number of VMs to `1`, the instance count to
    `10` and the maximum number of VMs to `100`. When the scale set is created, it
    will create `10` copies of the VM and start only one of them, the primary copy.
    When the scale-out threshold is reached, it will add a new VM to Scale Set. This
    VM is one of `10` initially created. If utilization continues to rise, it will
    add new VMs until we reach 10 VMs. If the maximum number of VMs is different from
    the instance count, new VMs will be created and started. The difference between
    the first `10` VMs and later ones is that initial VMs are already created and
    only need to be started. Additional VMs need to be provisioned before being started
    and this makes the process of scaling out slower. However, initial VM comes with
    a cost even when not running, as you pay for the disk even when the VM is turned
    off. It''s good to find a balance between the initial number and maximum number of
    VMs . AUTOSCALE is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/016cc75a-1afb-4c65-83c3-57a003b762a0.png)'
  prefs: []
  type: TYPE_IMG
- en: The NETWORKING part gives us the option to choose between the Application Gateway
    and Load balancer. Whatever you choose, this will be used as the endpoint for
    your users and it will automatically disperse traffic across the Azure Virtual
    Machine Scale Set. The Load balancer in Azure Virtual Machines is free and Application
    Gateway is billed per hour but supports many additional features. Application
    Gateway supports SSL termination, URL-based routing, multisite routing, cookie-based
    session affinity, web application firewalls, and routable IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the Load balancer, the difference between one used in the availibility
    set and scale set is that for scale set no additional management is needed (you
    have the option to set additional rules and settings, but it''s not required).
    Load-balancing rules and adding VMs to the backend pool is done automatically
    and no user action is required. An example of network settings with the Azure
    Load Balancer is shown in the screenshot here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50396904-101b-40e4-80d5-10eb715eaf66.png)'
  prefs: []
  type: TYPE_IMG
- en: Deployment of Azure Virtual Machine Scale Set depends on many different parameters.
    Network services needed for scale set must be deployed prior to the VMs, but this
    process is done very quickly. Then, VMs are deployed and this can take time depending
    on the instance count and VM size. Deploying a few large instances can be done
    relatively quickly, but if we deploy hundreds of small VMs, it can take up to
    an hour.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Azure Virtual Machine Scale Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After deployment is finished, multiple resources are created in our resource
    group and we can see Virtual machine scale set and a set of network-related resources.
    Network resources created are a Load balancer, Public IP address (used by the
    Load Balancer), Virtual network, and Network security group. NSG is applied on
    the subnet level and NSG rules will be effective on all VMs in scale set. This
    makes sense as all VMs are identical, are used by the same application, and have
    the same purpose. We can see in the screenshot here all the resources created
    for our scale set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8c23c8a-bdcf-4340-95d1-671ee9866cda.png)'
  prefs: []
  type: TYPE_IMG
- en: As we have already discussed all the networking features in question, we are
    going to concentrate on Virtual Machine Scale Set and options that are provided
    to manage it. A lot of options are identical to the VM settings such as Size,
    Continuous delivery (Preview), Configuration, Properties, Locks, and Automation
    script. SETTINGS that are unique to scale set are Instances, Scaling, Storage,
    and Operating system. Operating system is only informational and we can see only
    information such as the image and OS version used to create a scale set.
  prefs: []
  type: TYPE_NORMAL
- en: Storage settings also gives us information on the type of storage and disks
    used with only one option to choose—Caching. Options available are None, Read-only,
    and Read/write.
  prefs: []
  type: TYPE_NORMAL
- en: The Instance blade shows us all VMs in our scale set and their state. We can
    see which VMs are running and perform different operations such as Start, Stop,
    De-allocate and Delete. Specially interesting options are Reimage and Upgrade.
    Reimage will reset all settings on a selected VM and restore it to the default
    version. Upgrade will perform a manual upgrade for a selected VM to the latest
    changes. All VMs in scale set are an identical replica of the primary VM and,
    if changes are made on the primary, they will be replicated to all instances in
    time. The Upgrade option gives us the ability to perform upgrades manually and
    force changes immediately. This can be useful when we have a large number of VMs
    in scale set, as replicating changes will take time and change might be critical
    to be applied as soon as possible. However, both the Reimage and Upgrade options
    will reboot the VM in the process, so take that into consideration as well. The
    last option unique to the Azure Virtual Machine Scale Set is scaling, but it will
    take time to explain this option further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scaling blade shows us all the rules for scaling out and scaling in that
    are effective on our scale set. If rules are created during the deployment process,
    they will be shown here and we can edit them or delete them. Additional rules
    can be created as well and we can monitor multiple parameters for our VMs. For
    example, we can create separate rules for CPU, memory, and disk utilization. If
    any of these rules are triggered, it will perform scaling out or scaling in processes,
    accordingly. Creating more scale rules gives us better flexibility and performance
    as we don''t depend on a single point. If we monitor CPU but have issues with
    memory, scaling out will not happen and performance will decrease. If we monitor
    memory but have high disk utilization, again we don''t have automatic scaling
    out and performance will decrease:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fe5643c-5389-4b97-a3b3-8c399b47d153.png)'
  prefs: []
  type: TYPE_IMG
- en: It's important to outline two things when speaking about Azure Virtual Machine
    Scale Set. A scale set is very different to an availability set. In an availability
    set, we have a constant number of VMs in order to increase the chances of at least
    one VM being available at all times and achieving high availability. Scale set
    monitors workload and increases the number of VMs based on demand, but all VMs
    are replicas and an issue can cause all VMs to replicate issue.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we need to outline is scenarios where we can use Azure Virtual
    Machine Scale Set. As all VMs in scale set are replicas of the initial image,
    changes are made from the initial image to all other VMs. But the process is not
    done the other way around, and changes on additional instances are not applied
    anywhere. For this reason, Azure Virtual Machine Scale Set is not good for roles
    like SQL Server or Exchange Server where changes must be applied across all instances.
    Rather use scale set for application scenarios where changes are not made by user
    sessions and data persists over time.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Virtual Machine Scale Set ARM template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition, here is the ARM template to deploy a new Azure Virtual Machine
    Scale Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the basic IaaS concepts and how to set up Azure Virtual Machines.
    The logical step to expand IaaS scenarios was to cover high availability and we
    succeeded in achieving this goal with Azure Load Balancers and availability sets.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key concepts of cloud computing is elasticity and on-demand resources.
    We showed how to achieve both vertical scaling (with alerts and custom actions)
    and horizontal scaling (with Azure Virtual Machine Scale Sets).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will progress to the PaaS model and explore the Azure
    App Service as a more abstract model compared to Azure Virtual Machines. The app
    service gives us some unique options that will help us progress in our cloud journey
    but gives us less control over infrastructure than VMs. We'll compare how IaaS
    features relate to PaaS and how we can achieve scaling and high availability with
    app service.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the oldest Windows Server version supported for Azure VMs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows Server 2003
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows Server 2008 R2 SP1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows Server 2012 R2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What do basic-tier VMs support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lower IOPS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Load Balancers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Auto-scaling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are low-priority VMs intended to be used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Batch processing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Balanced workloads
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Size setting in the Azure Virtual Machine blade is used to...?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale up
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale down
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Runbooks can be used to perform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintenance tasks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling up and down VMs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Load Balancer is used...?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To distribute traffic across VMs in the backend pool
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To isolate traffic and stop attacks on the VM
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Placing VMs in the same availability set will result in...?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: VMs will be created in different Azure Datacenters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VMs will be placed in a different rack
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VMs will be placed in the same rack
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling by creating additional instances of VM is called...?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling up
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling down
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling out
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling out is an example of...?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vertical scaling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Horizontal scaling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Diagonal scaling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For scaling out of Azure VMs we use...?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Availability zone
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Availability set
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale set
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
