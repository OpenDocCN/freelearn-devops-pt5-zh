<html><head></head><body><div><div><p id="_idParaDest-94" class="chapter-number"><a id="_idTextAnchor157"/><em class="italic">Chapter 5</em></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor158"/>Docker Compose</h1>
			<p>In this chapter, we will be taking a look at another core Docker tool called Docker Compose, and also the currently in-development Docker App.</p>
			<p>Both of these tools allow you to easily define, build, and distribute applications that are made up of more than one container, using syntax similar to the commands we have been using to manually launch our containers in previous chapters.</p>
			<p>We are going to break the chapter down into the following sections:</p>
			<ul>
				<li>Exploring the basics of Docker Compose</li>
				<li>Making our first Docker Compose application</li>
				<li><a id="_idTextAnchor159"/>E<a id="_idTextAnchor160"/>xploring Docker Compose commands</li>
				<li>Using Docker App</li>
			</ul>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>As in previous chapters, we will continue to use our local Docker installations, and the screenshots in this chapter will again be from my preferred operating system, macOS. As before, the Docker commands we will be running will work on all three of the operating systems on which we have installed Docker so far. However, some of the supporting commands, which will be few and far between, may only apply to macOS- and Linux-based operating systems—these will be highlighted.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor162"/>Exploring the basics of Docker Compose</h1>
			<p>In <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a><em class="italic">, Docker Overview</em>, we discussed a few of the problems that Docker has been designed<a id="_idIndexMarker342"/> to solve. We explored how Docker addresses the challenges faced by a lot of development and operations teams. One such solution was to run two different application stacks side by side by isolating each application stack's processes into a single container. This lets you run two entirely different versions of the same software stack—let's say PHP 5.6 and PHP 7—on the same host, as we did in <a href="B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a><em class="italic">, Building Container Images</em>.</p>
			<p>Toward the end of <a href="B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 4</em></a><em class="italic">, Managing Containers</em>, we launched an application that was made up of multiple containers rather than running the required software stack in a single container. The example application we started, <code>Moby Counter</code>, is written in Node.js and uses Redis as a backend to store key values, which in our case were the coordinates of the Docker logos on screen.</p>
			<p>To be able to run the Moby Counter application, we had to launch two different containers, one for the Node.js application and one for Redis. While it was quite simple to do this as the application itself was quite basic, there are a number of disadvantages to manually launching single containers.</p>
			<p>For example, if I wanted <a id="_idIndexMarker343"/>a colleague to deploy the same application, I would have to pass them the following commands:</p>
			<pre>$ docker image pull redis:alpine
$ docker image pull russmckendrick/moby-counter
$ docker network create moby-counter
$ docker container run -d --name redis --network moby-counter redis:alpine
$ docker container run -d --name moby-counter --network moby-counter -p 8080:80 russmckendrick/moby-counter</pre>
			<p>Admittedly, I could get away with losing the first two commands as the image would be pulled down during the two <code>docker run</code> commands if the images were not present on my colleague's local machine, but as the applications start to get more complex, I will have to start passing on an ever-growing set of commands and instructions.</p>
			<p>I would also have to make it clear that they would have to take into account the order in which the commands need to be executed. Furthermore, my notes would have to include details of any potential issues to support them through any problems—which could mean we find ourselves in a "worked fine in Dev, Ops problem now" scenario, which we want to avoid at all costs.</p>
			<p>While Docker's responsibility should end at creating the images and launching containers using these images, Docker's creators anticipated such a scenario and sought to overcome this. Thanks to Docker, people no longer have to worry about inconsistencies in the environment in which they are launching their applications, as these can now be<a id="_idIndexMarker344"/> shipped in images.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor163"/>Orchard Laboratories</h2>
			<p>Before we look<a id="_idIndexMarker345"/> at Docker Compose, let's take a quick step <a id="_idIndexMarker346"/>back in time to July 2014, when Docker purchased a small British start-up called Orchard Laboratories who offered two container-based products.</p>
			<p>The first of the two products was a Docker-based hosting platform. From a single command, <code>orchard</code>, you could launch a host machine and then proxy your Docker commands through to the newly launched host; for example, you would use the following commands:</p>
			<pre>$ orchard hosts create
$ orchard docker run -p 6379:6379 -d orchardup/redis</pre>
			<p>These commands would have launched a Docker host on Orchard's platform, and then a Redis container. I say <em class="italic">would have</em>, as one of the first things Docker did when they purchased Orchard Laboratories was to retire the Orchard hosting service.</p>
			<p>The second Orchard Laboratories offering was an open source command-line tool called Fig, and it is this is what Docker had their eyes on when they purchased Orchard Laboratories. Fig, which was written in Python, let you use a YAML file to define how you would like your multi-container application to be structured. Fig took the YAML file and instructed Docker to launch the containers as defined. </p>
			<p>The advantage of this was that because it was a YAML file, it was straightforward for developers to start shipping <code>fig.yml</code> files alongside their Dockerfiles within their code bases. A typical <code>fig.yml</code> file would have looked like the following:</p>
			<pre>web:
  image: web
  links:
   - db
  ports:
   - "8000:8000"
   - "49100:22"
db:
  image: postgres</pre>
			<p>To launch the two containers defined in the <code>fig.yml</code> file, you would have had to have run the following command from inside the same folder where the <code>fig.yml</code> file was stored:</p>
			<pre>$ fig up</pre>
			<p>You may have noticed that I have been referring to Fig in the past tense, and that is because in February 2015, Fig became Docker Compose. In the next section of this chapter, we are <a id="_idIndexMarker347"/>going to be looking at launching our first<a id="_idIndexMarker348"/> Docker Compose application, and one of the first things you will notice is how close the syntax for defining the application is to the original Fig syntax.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor164"/>Making our first Docker Compose application</h1>
			<p>As part of our<a id="_idIndexMarker349"/> installation of Docker for Mac, Docker for Windows, and Docker on Linux in <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a><em class="italic">, Docker Overview</em>, we installed Docker Compose, so rather than discussing what it does any further, let's try to bring up the two-container application we launched manually at the end of the last chapter, using just Docker Compose.</p>
			<p>As already mentioned, Docker Compose uses a YAML file, typically named <code>docker-compose.yml</code>, to define what your multi-container application should look like. The Docker Compose representation of the two-container application we launched in <a href="B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 4</em></a><em class="italic">, Managing Containers</em> is as follows:</p>
			<pre>version: "3.7"
services:
    redis:
        image: redis:alpine
        volumes:
           - redis_data:/data
        restart: always
    mobycounter:
        depends_on: 
            - redis
        image: russmckendrick/moby-counter
        ports:
            - "8080:80"
        restart: always
       
volumes:
    redis_data:</pre>
			<p>Even without <a id="_idIndexMarker350"/>working through each of the lines in the file, it should be quite straightforward to follow along with what is going on based on the commands we have been using throughout the previous chapters—we will be looking at the contents of the <code>docker-compose.yml</code> file in the next section of this chapter.</p>
			<p>To launch our application, we simply change to the folder that <a id="_idTextAnchor165"/>c<a id="_idTextAnchor166"/>ontains your <code>docker-compose.yml</code> file and run the following:</p>
			<pre>$ docker-compose up</pre>
			<p>As you can see from the following Terminal output, quite a bit happened as Docker Compose launched our application:</p>
			<div><div><img src="img/Figure_5.01_B15659.jpg" alt="Figure 5.1 – Output of docker-compose up&#13;&#10;" width="1432" height="943"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 5.1 – Output of docker-compose up</p>
			<p>You can see in the <a id="_idIndexMarker351"/>first few lines that Docker Compose did the following:</p>
			<ul>
				<li>It created a volume called <code>mobycounter_redis_data</code>, using the default driver we defined at the end of the <code>docker-compose.yml</code> file.</li>
				<li>It created a network called <code>mobycounter_default</code> using the default network driver—at no point did we ask Docker Compose to do this.</li>
				<li>It launched two containers, one called <code>mobycounter_redis_1</code> and another called <code>mobycounter_mobycounter_1</code>.</li>
			</ul>
			<p>You may have also spotted that the Docker Compose namespace in our multi-container application has prefixed everything with <code>mobycounter</code>—it took this name from the folder our Docker Compose file was being stored in.</p>
			<p>Once launched, Docker Compose attached to <code>mobycounter_redis_1</code> and <code>mobycounter_mobycounter_1</code> and streamed the output to our Terminal session. On the Terminal screen, you can see both <code>redis_1 and mobycounter_1</code> starting to interact with each other.</p>
			<p>When running <a id="_idIndexMarker352"/>Docker Compose using <code>docker-compose up</code>, it will run in the foreground. Pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> will stop the containers and return access to your Terminal session.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor167"/>Docker Compose YAML file</h2>
			<p>Before we<a id="_idIndexMarker353"/> look at using Docker Compose more, we should have a <a id="_idIndexMarker354"/>deeper dive into <code>docker-compose.yml</code> files as these are at the heart of Docker Compose.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">YAML</strong> is a recursive acronym that stands for <strong class="bold">YAML Ain't Markup Language</strong>. It is used by many different applications for both configuration and for defining data in a human-readable structured data format. The indentation you see in the examples is very important as it helps to define the structure of the data.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor168"/>The Moby counter application</h2>
			<p>The <code>docker-compose.yml</code> file we used to launch our multi-container application is split into <a id="_idIndexMarker355"/>three <a id="_idIndexMarker356"/>separate sections.</p>
			<p>The first section simply specifies which version of the Docker Compose definition language we are using; in our case, as we are running a recent version of Docker and Docker Compose, we are using version 3, as illustrated here:</p>
			<pre>version: "3.7"</pre>
			<p>As already mentioned, Docker Compose has been around since 2015, during which time there have been quite a few different versions of both the Docker client and engine. As the software has been updated to include new features, the existing functionality has been streamlined to make it more performant, and also, some functionality has been split out of the core Docker engine or removed altogether. Docker Compose has been maintained to remain compatible with previsions versions of Docker.</p>
			<p>If the version number is not declared at the start of the <code>docker-compose.yml</code> file, then Docker Compose will default to version 1; this is quite close to the original Fig syntax, meaning that Docker Compose will not be able to read our <code>docker-compose.yml</code> file as containers were defined under the <code>services</code> section and there is no support for volumes, networks, or even build arguments—all of which we will cover later in the chapter.</p>
			<p>The following screenshot shows<a id="_idIndexMarker357"/> an example of what happens if we were to remove the version number:</p>
			<div><div><img src="img/Figure_5.02_B15659.jpg" alt="Figure 5.2 – Output of docker-compose up&#13;&#10;" width="1650" height="261"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Output of docker-compose up</p>
			<p>As you can see, trying to run <code>docker-compose up</code> without the version declared is going to end with errors, as Docker Compose quite literally doesn't know how to interpret the content we have defined. </p>
			<p>The next section is where our containers are defined; this section is the <code>services</code> section. It takes the following format:</p>
			<pre>services:
----&gt; container name:
--------&gt; container options
------------&gt; sub options
----&gt; container name:
--------&gt; container options
------------&gt; sub options</pre>
			<p>As you can see, the <code>services</code> declaration has no indentation at all, and then each container has 4 spaces, with each of the options having 8 spaces; further options would then have 12 spaces. The number of spaces is a personal choice as I find it helps make it more readable—the important thing is to use spaces and not tabs, and make sure that your indentation is consistent throughout the file as this is used to clearly define blocks of information.</p>
			<p>In our example, we defined two containers under the <code>services</code> section. In the following code snippet, they have been separated out to make it easy to read:</p>
			<pre>services:
    redis:
        image: redis:alpine
        volumes:
           - redis_data:/data
        restart: always
    mobycounter:
        depends_on: 
            - redis
        image: russmckendrick/moby-counter
        ports:
            - "8080:80"
        restart: always</pre>
			<p>At first glance, the <a id="_idIndexMarker358"/>syntax for defining the service appears close to<a id="_idIndexMarker359"/> how you would launch a container using the <code>docker container run</code> command. I say "close" because although it makes perfect sense when you read the definition, it is only on closer inspection that you realize there is actually a lot of difference between the Docker Compose syntax and the <code>docker container run</code> command.</p>
			<p>For example, there are no flags for the following when running the <code>docker container run</code> command:</p>
			<ul>
				<li><code>image</code>: This tells Docker Compose which image to download and use. This does not exist as an option when running <code>docker container run</code> on the command line as you can only run a single container; as we have seen in previous chapters, the image is always defined toward the end of the command, without the need for a flag to be passed.</li>
				<li><code>volume</code>: This is the equivalent of the <code>--volume</code> flag, but it can accept multiple volumes. It only<a id="_idIndexMarker360"/> uses the volumes that are declared in the Docker Compose YAML file; more on <a id="_idIndexMarker361"/>that in a moment.</li>
				<li><code>depends_on</code>: This would never work as a <code>docker container run</code> invocation because the command is only targeting a single container. When it comes to Docker Compose, <code>depends_on</code> is used to help build some logic into the order your containers are launched in—for example, only launch container B when container A has successfully started.</li>
				<li><code>ports</code>: This is basically the <code>--publish</code> flag, which accepts a list of ports.</li>
			</ul>
			<p>The only part of the command we used that has an equivalent flag when running <code>docker container run</code> is <code>restart</code>. This is the same as using the <code>--restart</code> flag and accepts the same input.</p>
			<p>The final section of our Docker Compose YAML file is where we declare our volumes, as follows:</p>
			<pre>volumes:
    redis_data:</pre>
			<p>This is the equivalent of running <code>docker volume create redis_data</code> using the Docker command-line client.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor169"/>Example voting application</h2>
			<p>As mentioned<a id="_idIndexMarker362"/> already, the Docker<a id="_idIndexMarker363"/> Compose file for the Moby counter application is quite a simple example. Let's take a look at a more complex Docker Compose file and see how we can introduce building containers and multiple networks.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In the repository for this book, you will find a folder in the <code>chapter05</code> directory called <code>example-voting-app</code>. This is a fork of the voting application from the official Docker sample repository.</p>
			<p>As you can see, if you were to open up the <code>docker-compose.yml</code> file, the application is made up of five containers, two networks, and a single volume. If we were to visualize the application, it would look something like the following:</p>
			<div><div><img src="img/Figure_5.03_B15659.jpg" alt="Figure 5.3 – Container structure for docker-compose.yml&#13;&#10;" width="711" height="401"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Container structure for docker-compose.yml</p>
			<p>Ignore the other files as we will look at some of these in future chapters; let's walk through the <code>docker-compose.yml</code> file as there is a lot going on. Have a look at the following code snippet:</p>
			<pre>version: "3"
services:</pre>
			<p>As you can see, it starts simply enough by defining the version, and then it starts to list the <code>service</code>. Our first container is called vote; it is a Python application that allows users to submit their vote. As you can see from the following definition, rather than downloading <a id="_idIndexMarker364"/>an image that contains the <a id="_idIndexMarker365"/>application, we are actually building an image by deploying our application using <code>build</code> instead of the <code>image</code> definition:</p>
			<pre>    vote:
        build: ./vote
        command: python app.py
        volumes:
            - ./vote:/app
        ports:
            - "5000:80"
        networks:
            - front-tier
            - back-tier</pre>
			<p>The <code>build</code> instruction here tells Docker Compose to build a container using the Dockerfile, which can be found in the <code>./vote</code> folder. The Dockerfile itself is quite straightforward for a Python application.</p>
			<p>Once the container launches, we are then mounting the <code>./vote</code> folder from our host machine into the container, which is achieved by passing the path of the folder we want to mount and where within the container we would like it mounted.</p>
			<p>We are telling the container to run the <code>python app.py</code> command when the container launches; we are mapping port <code>5000</code> on our host machine to port <code>80</code> on the container; and, finally, we are further attaching two networks to the container—one called <code>front-tier</code> and another called <code>back-tier</code>.</p>
			<p>The <code>front-tier</code> network will have the containers that require ports to be mapped to the host machine; the <code>back-tier</code> network is reserved for containers that do not need their ports to be exposed and acts as a private, isolated network.</p>
			<p>Next up, we have another container that is connected to the <code>front-tier</code> network. This container displays the results of the vote. The <code>result</code> container contains a Node.js application that connects to the PostgreSQL database (which we will get to in a moment) and displays<a id="_idIndexMarker366"/> the results in real<a id="_idIndexMarker367"/> time as votes are cast in the <code>vote</code> container. As with the <code>vote</code> container, the image is built locally using a Dockerfile that can be found in the <code>./result</code> folder, as illustrated in the following code snippet:</p>
			<pre>    result:
        build: ./result
        command: nodemon server.js
        volumes:
            - ./result:/app
        ports:
            - "5001:80"
            - "5858:5858"
         networks:
            - front-tier
            - back-tier</pre>
			<p>We are exposing port <code>5001</code>, which is where we can connect to see the results. The next—and final—application container is called <code>worker</code>, as illustrated in the following code snippet:</p>
			<pre>    worker:
        build:
            context: ./worker
        depends_on:
            - "redis"
            - "db"
        networks:
            - back-tier</pre>
			<p>The <code>worker</code> container runs a .NET application whose only job is to connect to Redis and register each vote by transferring it into a PostgreSQL database running on a container called <code>db</code>. The container is again built using a Dockerfile, but this time, rather than passing the path to the folder where the Dockerfile and application are stored, we are using <code>context</code>. This sets the working directory for the<code> docker build</code> command and also allows you to define additional options such as labels and changing the name of the Dockerfile. </p>
			<p>As this container is <a id="_idIndexMarker368"/>doing nothing <a id="_idIndexMarker369"/>other than connecting to <code>redis</code> and the <code>db</code> container, it does not need any ports exposed as it has nothing connecting directly to it; it also does not need to communicate with either of the containers running on the <code>front-tier</code> network, meaning we just have to add the <code>back-tier</code> network.</p>
			<p>So, we now have the <code>vote</code> application, which registers the votes from the end users and sends them to the <code>redis</code> container, where the vote is then processed by the <code>worker</code> container. The service definition for the <code>redis</code> container looks like the following:</p>
			<pre>    redis:
        image: redis:alpine
        container_name: redis
        ports: ["6379"]
        networks:
            - back-tier</pre>
			<p>This container uses the official Redis image and is not built from a Dockerfile; we are making sure that port <code>6379</code> is available, but only on the <code>back-tier</code> network. We are also specifying the name of the container, setting it to <code>redis</code> by using <code>container_name</code>. This is to avoid us having to make any considerations on the default names generated by Docker Compose within our code since, if you remember, Docker Compose uses the folder name to launch the containers in their own application namespace.</p>
			<p>The next—and final—container is the PostgreSQL one (which we have already mentioned), called <code>db</code>, as illustrated in the following code snippet:</p>
			<pre>     db:
        image: postgres:9.4
        container_name: db
        volumes:
            - "db-data:/var/lib/postgresql/data"
        networks:
            - back-tier</pre>
			<p>As you can see, it looks <a id="_idIndexMarker370"/>quite similar to <a id="_idIndexMarker371"/>the <code>redis</code> container in that we are using the official image; however, you may notice that we are not exposing a port, as this is a default option in the official image. We are also specifying the name of the container.</p>
			<p>As this is where our votes will be stored, we are creating and mounting a volume to act as persistent storage for our PostgreSQL database, as follows:</p>
			<pre>volumes:
    db-data:</pre>
			<p>Then, finally, here are the two networks we have been speaking about throughout when defining our application containers:</p>
			<pre>networks:
    front-tier:
    back-tier:</pre>
			<p>Running <code>docker-compose up</code> gives a lot of feedback on what is happening during the launch; it takes about 5 minutes to launch the application for the first time. If you are not following along and launching the application yourself, what follows is an abridged version of the launch.</p>
			<p class="callout-heading">TIP </p>
			<p class="callout">You may get an error that states <code>npm ERR! request to https://registry.npmjs.org/nodemon failed, reason: Hostname/IP doesn't match certificate's altnames</code>. If you do, then run the <code>echo "104.16.16.35 registry.npmjs.org" &gt;&gt; /etc/hosts</code> command as a user with privileges to write to the <code>/etc/hosts</code> file on your machine.</p>
			<p>Docker Compose<a id="_idIndexMarker372"/> starts by creating the <a id="_idIndexMarker373"/>networks and getting the volume ready for our containers to use, as illustrated here:</p>
			<pre>Creating network "example-voting-app_front-tier" with the default driver
Creating network "example-voting-app_back-tier" with the default driver
Creating volume "example-voting-app_db-data" with default driver</pre>
			<p>It then builds the <code>vote</code> container image, as follows:</p>
			<pre>Building vote
Step 1/7 : FROM python:2.7-alpine
2.7-alpine: Pulling from library/python
c9b1b535fdd9: Already exists
fea5c17ab132: Pull complete
5dbe995357bf: Pull complete
b6d238951af6: Pull complete
Digest: sha256:5217b150a5f7eecea55f6224440f3b5 c5f975edc32de7c0bfdf98280ed11d76c
Status: Downloaded newer image for python:2.7-alpine</pre>
			<p>Now that the<a id="_idIndexMarker374"/> images have been <a id="_idIndexMarker375"/>downloaded, the building of the first part of the application can start, as follows:</p>
			<pre> ---&gt; 7ec8514e7bc5
Step 2/7 : WORKDIR /app
 ---&gt; Running in 7d26310faa98
Removing intermediate container 7d26310faa98
 ---&gt; 8930ad501196
Step 3/7 : ADD requirements.txt /app/requirements.txt
 ---&gt; 33ff980bd133
Step 4/7 : RUN pip install -r requirements.txt
 ---&gt; Running in 999e575570ef
[lots of python build output here]
Removing intermediate container 999e575570ef
 ---&gt; 72637119e7df
Step 5/7 : ADD . /app
 ---&gt; 81adb9e92ce4
Step 6/7 : EXPOSE 80
 ---&gt; Running in a5aaf5b9ed1b
Removing intermediate container a5aaf5b9ed1b
 ---&gt; 366d2e32ceb4
Step 7/7 : CMD ["gunicorn", "app:app", "-b", "0.0.0.0:80", "--log-file", "-", "--access-logfile", "-", "--workers", "4", "--keep-alive", "0"]
 ---&gt; Running in 212e82c06cf3
Removing intermediate container 212e82c06cf3
 ---&gt; 4553ffa35ea4
Successfully built 4553ffa35ea4</pre>
			<p>Now that the image has been built it will be tagged, as illustrated here:</p>
			<pre>Successfully tagged example-voting-app_vote:latest
WARNING: Image for service vote was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.</pre>
			<p>Once Docker <a id="_idIndexMarker376"/>Compose has built <a id="_idIndexMarker377"/>the <code>vote</code> image, it starts on building the <code>result</code> image, as follows:</p>
			<pre>Building result
Step 1/9 : FROM node:10-slim
10-slim: Pulling from library/node
619014d83c02: Pull complete
8c5d9aed65fb: Pull complete
ec6ca7c6739a: Pull complete
6da8fc40e075: Pull complete
6161f60894b2: Pull complete
Digest: sha256:10c4d19a2a2fa5ad416bddb3a4b208e 34b0d4263c3978df6aa06d9ba9687bbe8
Status: Downloaded newer image for node:10-slim
 ---&gt; ad4ea09bf0f3
Again, now the images have been downloaded the build of the image containing the application can start:
Step 2/9 : WORKDIR /app
 ---&gt; Running in 040efda3a918
Removing intermediate container 040efda3a918
 ---&gt; 3d3326950331
Step 3/9 : RUN npm install -g nodemon
 ---&gt; Running in a0ce3043aba5
[lots of nodejs build output here]
Removing intermediate container a0ce3043aba5
 ---&gt; 925a30942e5f
Step 4/9 : COPY package*.json ./
 ---&gt; 9fd59fddc0e8
Step 5/9 : RUN npm ci  &amp;&amp; npm cache clean --force  &amp;&amp; mv /app/node_modules /node_modules
 ---&gt; Running in 3c0871538d04
[lots of nodejs build output here]
Removing intermediate container 3c0871538d04
 ---&gt; 8db74baa1959
Step 6/9 : COPY . .
 ---&gt; a47af934177b
Step 7/9 : ENV PORT 80
 ---&gt; Running in 57f80f86faf0
Removing intermediate container 57f80f86faf0
 ---&gt; e5a01939876b
Step 8/9 : EXPOSE 80
 ---&gt; Running in 614bd7bd4ab3
Removing intermediate container 614bd7bd4ab3
 ---&gt; 461355b7e66e
Step 9/9 : CMD ["node", "server.js"]
 ---&gt; Running in 4c64da5f054c
Removing intermediate container 4c64da5f054c
 ---&gt; 65c854a0b292
Successfully built 65c854a0b292
Successfully tagged example-voting-app_result:latest
WARNING: Image for service result was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.</pre>
			<p>This is followed<a id="_idIndexMarker378"/> by the PostgreSQL<a id="_idIndexMarker379"/> image for the <code>db</code> container being pulled down from Docker Hub, as illustrated here:</p>
			<pre>Pulling db (postgres:9.4)...
9.4: Pulling from library/postgres
619014d83c02: Already exists
7ec0fe6664f6: Pull complete
9ca7ba8f7764: Pull complete
9e1155d037e2: Pull complete
febcfb7f8870: Pull complete
8c78c79412b5: Pull complete
5a35744405c5: Pull complete
27717922e067: Pull complete
8e8ebde0a697: Pull complete
f6d85e336541: Pull complete
c802081bbe1e: Pull complete
f35abd4ea98b: Pull complete
50335e437328: Pull complete
a1c34d9ddebb: Pull complete
Digest: sha256:d6bc1739199cc52f038f54e1ab 671f5229d114fb667e9ad08add6cd66e8a9b28
Status: Downloaded newer image for postgres:9.4</pre>
			<p>Finally, the <code>worker</code> image<a id="_idIndexMarker380"/> is <a id="_idIndexMarker381"/>constructed, as follows:</p>
			<pre>Building worker
Step 1/5 : FROM microsoft/dotnet:2.0.0-sdk
2.0.0-sdk: Pulling from microsoft/dotnet
3e17c6eae66c: Pull complete
74d44b20f851: Pull complete
a156217f3fa4: Pull complete
4a1ed13b6faa: Pull complete
18842ff6b0bf: Pull complete
e857bd06f538: Pull complete
b800e4c6f9e9: Pull complete
Digest: sha256:f4ea9cdf980bb9512523a3fb88e 30f2b83cce4b0cddd2972bc36685461081e2f
Status: Downloaded newer image for microsoft/dotnet:2.0.0-sdk
Now that the SDK images have been downloaded Docker Compose can build the application:
 ---&gt; fde8197d13f4
Step 2/5 : WORKDIR /code
 ---&gt; Running in ac782e4c8cb2
Removing intermediate container ac782e4c8cb2
 ---&gt; 3881e09f0d22
Step 3/5 : ADD src/Worker /code/src/Worker
 ---&gt; cf0468608709
Step 4/5 : RUN dotnet restore -v minimal src/Worker     &amp;&amp; dotnet publish -c Release -o "./" "src/Worker/"
 ---&gt; Running in ca04867b0e86
[lots of .net build output here]
  Worker -&gt; /code/src/Worker/bin/Release/netcoreapp2.0/Worker.dll
  Worker -&gt; /code/src/Worker/
Removing intermediate container ca04867b0e86
 ---&gt; 190aee9b4b98
Step 5/5 : CMD dotnet src/Worker/Worker.dll
 ---&gt; Running in 069b5806b25e
Removing intermediate container 069b5806b25e
 ---&gt; 56c488a158bb
Successfully built 56c488a158bb
Successfully tagged example-voting-app_worker:latest
WARNING: Image for service worker was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.</pre>
			<p>You may have noticed that the <code>Redis</code> image being used by the <code>redis</code> container was not pulled—this is because the latest version was already downloaded. Now that all the images have either been built or pulled down and the networking and volumes are in place, Docker Compose can launch our application, as follows:</p>
			<pre>Creating redis                       ... done
Creating db                          ... done
Creating example-voting-app_vote_1   ... done
Creating example-voting-app_result_1 ... done
Creating example-voting-app_worker_1 ... done
Attaching to db, redis, example-voting-app_worker_1, example-voting-app_vote_1, example-voting-app_result_1</pre>
			<p>The <code>result</code> part of <a id="_idIndexMarker382"/>the application can<a id="_idIndexMarker383"/> be accessed at <code>http://localhost:5001</code>. By default, there are no votes and it is split 50/50, as illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_5.04_B15659.jpg" alt="Figure 5.4 – The default voting tally&#13;&#10;" width="854" height="536"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The default voting tally</p>
			<p>The <code>voting</code> part of<a id="_idIndexMarker384"/> the application <a id="_idIndexMarker385"/>can be found at http://localhost:5000, and is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_5.05_B15659.jpg" alt="Figure 5.5 – The voting interface&#13;&#10;" width="1278" height="699"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – The voting interface</p>
			<p>Clicking on<a id="_idIndexMarker386"/> either <strong class="bold">CATS</strong> or <strong class="bold">DOGS</strong> will <a id="_idIndexMarker387"/>register a vote; you should be able to see this logged in the Docker Compose output in your Terminal, as follows:</p>
			<div><div><img src="img/Figure_5.06_B15659.jpg" alt="Figure 5.6 – docker-compute output showing votes&#13;&#10;" width="1650" height="727"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – docker-compute output showing votes</p>
			<p>There are a few<a id="_idIndexMarker388"/> errors, as the Redis table<a id="_idIndexMarker389"/> structure is only created when the vote application registers the first vote; once a vote has been cast, the Redis table structure will be created and the <code>worker</code> container will take that vote and process it by writing to the <code>db</code> container. Once the vote has been cast, the <code>result</code> container will update in real time, as illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_5.07_B15659.jpg" alt="Figure 5.7 – Vote result page after vote was cast&#13;&#10;" width="1175" height="690"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Vote result page after vote was cast</p>
			<p>We will be looking at the Docker Compose YAML files again in the upcoming chapters, when we look at <a id="_idIndexMarker390"/>launching both <a id="_idIndexMarker391"/>Docker Swarm stacks and Kubernetes clusters. For now, let's get back to Docker Compose a<a id="_idTextAnchor170"/>n<a id="_idTextAnchor171"/>d look at some of the commands we can run.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor172"/>Exploring Docker Compose commands</h1>
			<p>We are over<a id="_idIndexMarker392"/> halfway through the chapter, and the only Docker Compose command we have run is <code>docker-compose up</code>. If you have been following along and you run <code>docker container ls -a</code>, you will see something similar to the following Terminal screen:</p>
			<div><div><img src="img/Figure_5.08_B15659.jpg" alt="Figure 5.8 – Output for docker container ls -a&#13;&#10;" width="1650" height="717"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Output for docker container ls -a</p>
			<p>As you can see, we have <a id="_idIndexMarker393"/>a lot of containers with the status of <code>Exited</code>. This is because when we used <em class="italic">Ctrl</em> + <em class="italic">C</em> to return to our Terminal, the Docker Compose containers were stopped.</p>
			<p>Choose one of the Docker Compose applications and change to the folder that contains the <code>docker-compose.yml</code> file, and we will work through some more Docker Compose commands. I will be using the <strong class="bold">Example Vote</strong> application.</p>
			<p>up and ps</p>
			<p>The first<a id="_idIndexMarker394"/> command is <code>docker-compose up</code>, but this<a id="_idIndexMarker395"/> time, we will be adding a flag. In your chosen application folder, run the following:</p>
			<pre>$ docker-compose up -d</pre>
			<p>This will start your application back up, this time in detached mode, which will return you to your Terminal prompt, as follows:</p>
			<div><div><img src="img/Figure_5.09_B15659.jpg" alt="Figure 5.9 – Output for docker-compose up -d&#13;&#10;" width="1650" height="333"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Output for docker-compose up -d</p>
			<p>Once control of your Terminal is returned to you, you should be able to check that the containers are running, using the following command:</p>
			<pre>$ docker-compose ps</pre>
			<p>As you can see from <a id="_idIndexMarker396"/>the following Terminal output, all of the <a id="_idIndexMarker397"/>containers have the state of <code>Up</code>:</p>
			<div><div><img src="img/Figure_5.10_B15659.jpg" alt="Figure 5.10 – Output for docker-compose ps&#13;&#10;" width="1650" height="443"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Output for docker-compose ps</p>
			<p>When running these commands, Docker Compose will only be aware of the containers defined in the <code>services</code> section of your <code>docker-compose.yml</code> file; all other containers will be ignored as they don't belong to our service stack.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor173"/>config</h2>
			<p>Running the following <a id="_idIndexMarker398"/>command will validate our <code>docker-compose.yml</code> file:</p>
			<pre>$ docker-compose config</pre>
			<p>If there are no issues, it will print a rendered copy of your Docker Compose YAML file to screen; this is how Docker Compose will interpret your file. If you don't want to see this output and just want to check for errors, then you can run the following command:</p>
			<pre>$ docker-compose config -q</pre>
			<p>This is shorthand for <code>--quiet</code>. If there are any errors (which the examples we have worked through<a id="_idIndexMarker399"/> so far shouldn't have), they will be displayed as follows:</p>
			<pre>ERROR: yaml.parser.ParserError: while parsing a block mapping in "./docker- compose.yml", line 1, column 1 expected &lt;block end&gt;, but found '&lt;block mapping start&gt;' in "./docker-compose.yml", line 27, column 3</pre>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor174"/>pull, build, and create</h2>
			<p>The next two <a id="_idIndexMarker400"/>commands will help you prepare to launch<a id="_idIndexMarker401"/> your Docker Compose application. The following <a id="_idIndexMarker402"/>command will read your Docker Compose YAML file and pull any of the images it finds:</p>
			<pre>$ docker-compose pull</pre>
			<p>The following command will execute any build instructions it finds in your file:</p>
			<pre>$ docker-compose build</pre>
			<p>These commands are useful when you are first defining your Docker Compose-powered application and want to test it without launching your application. The <code>docker-compose build</code> command can also be used to trigger a build if there are updates to any of the Dockerfiles used to originally build your images.</p>
			<p>The <code>pull</code> and <code>build</code> commands only generate/pull the images needed for our application; they do not configure the containers themselves. For this, we need to use the following command:</p>
			<pre>$ docker-compose create</pre>
			<p>This will create but not launch the containers. As with the <code>docker container create</code> command, they will have an <code>Exited</code> state until you start them. The <code>create</code> command has a few useful flags you can pass, as follows:</p>
			<ul>
				<li><code>--force-recreate</code>: This recreates the container even if there is no need to, as nothing within the configuration has changed.</li>
				<li><code>--no-recreate</code>: This doesn't recreate a container if it already exists; this flag cannot be used with the preceding flag.</li>
				<li><code>--no-build</code>: This<a id="_idIndexMarker403"/> doesn't build the images, even<a id="_idIndexMarker404"/> if an image that needs to be built is<a id="_idIndexMarker405"/> missing.</li>
				<li><code>--build</code>: This builds the images before creating the containers.</li>
			</ul>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor175"/>start, stop, restart, pause, and unpause</h2>
			<p>The following <a id="_idIndexMarker406"/>commands<a id="_idIndexMarker407"/> work <a id="_idIndexMarker408"/>in exactly the<a id="_idIndexMarker409"/> same <a id="_idIndexMarker410"/>way as their <code>docker container</code> counterparts, the only difference being that they effect change on all of the containers:</p>
			<pre>$ docker-compose start
$ docker-compose stop
$ docker-compose restart
$ docker-compose pause
$ docker-compose unpause</pre>
			<p>It is possible to target a single service by passing its name; for example, to pause and unpause the <code>db</code> service, we would run the following:</p>
			<pre>$ docker-compose pause db
$ docker-compose unpause db</pre>
			<p>Now that we know how to stop and start all or part of our Docker Compose application, we can look at how we can see some more information on our application.</p>
			<p>top, logs, events, exec, and run</p>
			<p>The next<a id="_idIndexMarker411"/> three<a id="_idIndexMarker412"/> commands <a id="_idIndexMarker413"/>all give us feedback on<a id="_idIndexMarker414"/> what is happening within our running containers<a id="_idIndexMarker415"/> and Docker Compose.</p>
			<p>The following command, as with its <code>docker container</code> counterpart, displays information on the processes running within each of our Docker Compose-launched containers:</p>
			<pre>$ docker-compose top</pre>
			<p>As you can see from the following Terminal output, each container is split into its own section:</p>
			<div><div><img src="img/Figure_5.11_B15659.jpg" alt="Figure 5.11 – Output for docker-compose top&#13;&#10;" width="1556" height="1059"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Output for docker-compose top</p>
			<p>If you would just like to see one of the services, you simply have to pass its name when running the command, as follows:</p>
			<pre>$ docker-compose top db</pre>
			<p>The following command streams the logs from each of the running containers to screen:</p>
			<pre>$ docker-compose logs</pre>
			<p>As with<a id="_idIndexMarker416"/> the <code>docker container</code> command, you can<a id="_idIndexMarker417"/> pass<a id="_idIndexMarker418"/> flags<a id="_idIndexMarker419"/> such as <code>-f</code> or <code>--follow</code> to keep the <a id="_idIndexMarker420"/>stream flowing until you press <em class="italic">Ctrl</em> + <em class="italic">C</em>. Also, you can stream the logs for a single service by appending its name to the end of your command, as follows:</p>
			<div><div><img src="img/Figure_5.12_B15659.jpg" alt="Figure 5.12 – Log stream&#13;&#10;" width="1625" height="489"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Log stream</p>
			<p>The <code>events</code> command again works like the <code>docker container</code> equivalent; it streams events—such as the ones triggered by the other commands we have been discussing—in real time. For example, run this command:</p>
			<pre>$ docker-compose events</pre>
			<p>Running <code>docker-compose pause</code> in a second Terminal window gives the following output:</p>
			<div><div><img src="img/Figure_5.13_B15659.jpg" alt="Figure 5.13 – Output for docker-compose events&#13;&#10;" width="1650" height="439"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Output for docker-compose events</p>
			<p>These two commands run similarly to their <code>docker container</code> equivalents. Run the following:</p>
			<pre>$ docker-compose exec worker ping -c 3 db</pre>
			<p>This <a id="_idIndexMarker421"/>will<a id="_idIndexMarker422"/> launch<a id="_idIndexMarker423"/> a <a id="_idIndexMarker424"/>new process<a id="_idIndexMarker425"/> in the already running worker container and ping the <code>db</code> container three times, as seen here:</p>
			<div><div><img src="img/Figure_5.14_B15659.jpg" alt="Figure 5.14 – Output for docker-compose exec worker ping -c 3 db&#13;&#10;" width="1637" height="406"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Output for docker-compose exec worker ping -c 3 db</p>
			<p>The <code>run</code> command is useful if you need to run a containerized command as a one-off within your application. For example, if you use a package manager such as <code>composer</code> to update the dependencies of your project that is stored on a volume, you could run something like this:</p>
			<pre>$ docker-compose run --volume data_volume:/app composer install</pre>
			<p>This would run the <code>composer</code> container with the <code>install</code> command and mount the <code>data_volume</code> at the following path <code>/app</code> within the container.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor176"/>scale</h2>
			<p>The <code>scale</code> command <a id="_idIndexMarker426"/>will take the service you pass to the command and scale it to the number you define. For example, to add more <code>worker</code> containers, I just need to run the following:</p>
			<pre>$ docker-compose scale worker=3</pre>
			<p>However, this actually gives the following warning:</p>
			<pre>WARNING: The scale command is deprecated. Use the up command with the - scale flag instead.</pre>
			<p>What we should now be using is the following command:</p>
			<pre>$ docker-compose up -d --scale worker=3</pre>
			<p>While the <code>scale</code> command is in the current version of Docker Compose, it will be removed from future versions of the software.</p>
			<p>You will notice that I chose to scale the number of <code>worker</code> containers. There is a good reason for this, as you will see for yourself if you try running the following command:</p>
			<pre>$ docker-compose up -d --scale vote=3</pre>
			<p>You will notice that while Docker Compose creates the additional two containers, they fail to start, with the following error:</p>
			<div><div><img src="img/Figure_5.15_B15659.jpg" alt="Figure 5.15 – Output for docker-compose up -d --scale vote=3&#13;&#10;" width="1650" height="1012"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Output for docker-compose up -d --scale vote=3</p>
			<p>That is because <a id="_idIndexMarker427"/>we cannot have three individual containers all trying to map to the same port on the host machine; because of this, you should always use the <code>scale</code> command on containers where you haven't explicitly defined a port mapping.kill, rm, and down</p>
			<p>The three<a id="_idIndexMarker428"/> Docker Compose commands<a id="_idIndexMarker429"/> we are going to look at last are the<a id="_idIndexMarker430"/> ones that remove/terminate our Docker Compose application. The first command stops our running containers by immediately stopping running container processes. This is the <code>kill</code> command, as illustrated here:</p>
			<pre>$ docker-compose kill</pre>
			<p>Be careful when running this as it does not wait for containers to gracefully stop, such as when running <code>docker-compose stop</code>, meaning that using the <code>docker-compose kill</code> command may result in data loss.</p>
			<p>Next up is the <code>rm</code> command; this removes any containers with the state of <code>exited</code>, and is shown here:</p>
			<pre>$ docker-compose rm</pre>
			<p>Finally, we have the <code>down</code> command. This, as you might have already guessed, has the opposite effect of running <code>docker-compose up</code>, and is shown here:</p>
			<pre>$ docker-compose down</pre>
			<p>That will<a id="_idIndexMarker431"/> remove the containers and the <a id="_idIndexMarker432"/>networks <a id="_idIndexMarker433"/>created when running <code>docker-compose up</code>. If you want to remove everything, you can do so by running the following:</p>
			<pre>$ docker-compose down --rmi all --volumes</pre>
			<p>This will remove all of the containers, networks, volumes, and images (both pulled and built) when you ran the <code>docker-compose up</code> command; this includes images that may be in use outside of your Docker Compose application. </p>
			<p>There will, however, be an error if the images are in use, and those images will not be removed, as illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_5.16_B15659.jpg" alt="Figure 5.16 – Output of docker-compose down --rmi all --volumes&#13;&#10;" width="1650" height="979"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – Output of docker-compose down --rmi all --volumes</p>
			<p>As you can see<a id="_idIndexMarker434"/> from the preceding output, there is a <a id="_idIndexMarker435"/>container using the <code>redis</code> image, the <a id="_idIndexMarker436"/>Moby counter application, so it was not removed. However, all other images used by the <code>Example Vote</code> application are removed, both the ones built as part of the initial <code>docker- compose up</code> command and the ones downloaded from Docker Hub.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor177"/>Using Docker App</h1>
			<p>Before we <a id="_idIndexMarker437"/>start this section, I should issue the following warning:</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The feature we are going to discuss is very much an experimental one. It is in its very early stages of development and should not be considered any more than a preview of an upcoming feature.</p>
			<p>Because of its experimental nature, I am only going to cover the usage of Docker App on macOS. However, before we enable it, let's discuss what exactly is meant by a Docker app. While Docker Compose files are really useful when it comes to sharing your environment with others, you may have noticed that there is one quite crucial element we have been missing so far in this chapter, and that is the ability to actually distribute your Docker Compose<a id="_idIndexMarker438"/> files in a similar way to how you can distribute your Docker images.</p>
			<p>Docker has acknowledged this and is currently working on a new feature called Docker App, which it hopes will fill this gap.</p>
			<p>Docker App is currently a command-line client plugin that helps you to create an application bundle that can be shared via Docker Hub or a Docker Enterprise Registry. The plugin is built in to Docker 19.03, and all you have to do is open the Docker desktop <strong class="bold">Settings</strong> and toggle on <strong class="bold">Enable experimental features</strong>, as illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_5.17_B15659.jpg" alt="Figure 5.17 – Docker desktop Enable experimental features screen&#13;&#10;" width="1212" height="771"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – Docker desktop Enable experimental features screen</p>
			<p>We are going to be <a id="_idIndexMarker439"/>using the Moby Counter application as its <code>docker-compose.yml</code> file already meets the pre-requisites for a Docker App bundle, as we are using a version of 3.6 and higher—3.7, in our case. </p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor178"/>Defining the application</h2>
			<p>Let's begin by <a id="_idIndexMarker440"/>following these steps:</p>
			<ol>
				<li>We need to create our Docker App configuration. To do this, change to the <code>mobycounter</code> folder and run the following command:<pre><code>mobycounterapp.dockerapp</code>. In that folder, there are three files, as can be seen in the following screenshot:</p><div><img src="img/Figure_5.18_B15659.jpg" alt="Figure 5.18 – Output of ls -lhat mobycounterapp.dockerapp&#13;&#10;" width="1650" height="477"/></div><pre># Version of the application
version: 0.1.0
# Name of the application
name: mobycounterapp
# A short description of the application
description: 
# List of application maintainers with name and email for each
maintainers:
  - name: russ.mckendrick
    email: </pre></li>
				<li>Let's start by updating the <code>metadata.yml</code> file. I updated mine to read as follows:<pre># Version of the application
version: 0.1.0
# Name of the application
name: mobycounterapp
# A short description of the application
description: Places whales on screen wherever you click !!!
# List of application maintainers with name and email for each
maintainers:
  - name: Russ McKendrick
    email: russ@mckendrick.io</pre><p>The preceding <a id="_idIndexMarker442"/>information will be used when we distribute the application. Initially, this will be via the Docker Hub, so please make sure that you are happy for the information to be accessible to other people. </p></li>
				<li>Now that we have our metadata, let's add some parameters to the <code>parameters.yml</code> file, as follows:<pre>{
    "port": "8080"
}</pre></li>
				<li>Finally, update the <code>docker-compose.yml</code> file to make use of the parameters we have just defined, as follows:<pre>version: "3.7"
services:
    redis:
        image: redis:alpine
        volumes:
           - redis_data:/data
        restart: always
    mobycounter:
        depends_on: 
            - redis
        image: russmckendrick/moby-counter
        ports:
            - "${port}:80"
        restart: always
       
volumes:
    redis_data:</pre></li>
			</ol>
			<p>As you can see, I have<a id="_idIndexMarker443"/> added <code>${port}</code> to the <code>docker-compose.yml</code> file. When we launch the application, the values will be populated from the <code>parameters.yml</code> file. </p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor179"/>Validating and inspecting the application</h2>
			<p>We can <a id="_idIndexMarker444"/>double-check that everything we have changed is OK by running the<a id="_idIndexMarker445"/> following commands:</p>
			<pre>$ docker app validate mobycounterapp.dockerapp
$ docker app inspect mobycounterapp.dockerapp</pre>
			<p>If everything is OK, this should display something that looks like the following Terminal output:</p>
			<div><div><img src="img/Figure_5.19_B15659.jpg" alt="Figure 5.19 – Output for docker app inspect mobycounterapp.dockerapp&#13;&#10;" width="1650" height="907"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – Output for docker app inspect mobycounterapp.dockerapp</p>
			<p>Once we've <a id="_idIndexMarker446"/>validated<a id="_idIndexMarker447"/> the app, we can finally move on to launching it.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor180"/>Launching the app</h2>
			<p>For us to be able to <a id="_idIndexMarker448"/>launch the application natively, we need to be running a Docker Swarm cluster (we will be covering Docker Swarm in more detail in a future chapter). To achieve this, proceed as follows: </p>
			<ol>
				<li value="1">Begin by running the following command:<pre><strong class="bold">$ docker swarm init</strong></pre><p>Ignore the output for now—we won't be creating a cluster just yet and only need a single node. </p></li>
				<li>Now that we have Docker Swarm enabled, we can install the application using the following command:<pre><strong class="bold">$ docker app install mobycounterapp.dockerapp --name mobycounterapp</strong></pre></li>
				<li>Once installed, you can run the following command to check the status of the application:<pre><strong class="bold">$ docker app list</strong></pre></li>
			</ol>
			<p>You should see<a id="_idIndexMarker449"/> something like the following Terminal output:</p>
			<div><div><img src="img/Figure_5.20_B15659.jpg" alt="Figure 5.20 – Output for docker app install and docker app list&#13;&#10;" width="1650" height="440"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Output for docker app install and docker app list</p>
			<p>The application should also be accessible on <code>http://localhost:8080</code>.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor181"/>Pushing to Docker Hub</h2>
			<p>While our<a id="_idIndexMarker450"/> application is running, we can publish it to the<a id="_idIndexMarker451"/> Docker Hub. To do this, proceed as follows: </p>
			<ol>
				<li value="1">If you haven't done so already, log in by running the following command:<pre><strong class="bold">$ docker login</strong></pre></li>
				<li>Once logged in, run the following command, making sure that you update the Docker Hub ID (which is russmckendrick in my case) with your own:<pre><strong class="bold">$ docker app push mobycounterapp --platform="linux/amd64" --tag russmckendrick/mobycounterapp:0.1.0</strong></pre></li>
			</ol>
			<p>After a minute, you should see a message that the bundle has been successfully pushed, as illustrated<a id="_idIndexMarker452"/> in<a id="_idIndexMarker453"/> the following screenshot: </p>
			<div><div><img src="img/Figure_5.21_B15659.jpg" alt="Figure 5.21 – hub.docker.com page&#13;&#10;" width="1650" height="1080"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – hub.docker.com page</p>
			<p>Opening https://hub.docker.com/ in your browser should show that the application is there, as seen in <em class="italic">Figure 5.21</em>.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor182"/>Installing from Docker Hub</h2>
			<p>First of all, let's<a id="_idIndexMarker454"/> create a temporary folder and uninstall <a id="_idIndexMarker455"/>the application, as follows:</p>
			<pre>$ mkdir /tmp/testing
$ cd /tmp/testing
$ docker app uninstall mobycounterapp
$ docker app ls</pre>
			<p>As you can see from the output if you are following along, we don't have any applications running, and we have changed folders away from our original <code>docker-compose.yml</code> file and also the <code>mobycounterapp.dockerapp</code> folder, so we know that neither of them will be used.</p>
			<p>Next, we can inspect the application directly from Docker Hub by running the following command (again, make sure to replace the Docker Hub ID with your own):</p>
			<pre>$ docker app inspect russmckendrick/mobycounterapp:0.1.0</pre>
			<p>We should see<a id="_idIndexMarker456"/> information on our application similar to that shown<a id="_idIndexMarker457"/> when we last ran the command locally. First up, let's create a new <code>docker-compose.yml</code> file using the Docker Hub-hosted version of the application. To do this, run the following command:</p>
			<pre>$ docker app render --output docker-compose.yml russmckendrick/mobycounterapp:0.1.0</pre>
			<p>This will create a <code>docker-compose.yml</code> file in the current working folder; from there, we can then run the following:</p>
			<pre>$ docker-compose up -d
$ docker-compose ps</pre>
			<p>You will get a warning that the node is <code>running Swarm</code> mode; again, ignore this for now. You should see the two containers running, and your application will again be accessible at <code>http://localhost:8080</code>. </p>
			<p>Next, let's launch the application again natively, but this time alongside our Docker Compose-launched version. To do this, run the following:</p>
			<pre>$ docker app install russmckendrick/mobycounterapp:0.1.0 --set port=8181 --name mobycounterapp8181 </pre>
			<p>As you can see, we are launching an application named <code>mobycounterapp8181</code>. We are also using the <code>--set</code> command to override the default port of <code>8080</code>, which we originally set in the <code>parameters.yml</code> file, and changing it to <code>8181</code>. If everything went as planned, you should be able to access the application at <code>http://localhost:8181</code>.</p>
			<p>There is more functionality within Docker App. However, we are not quite ready to go into further details. We will return to Docker App in <a href="B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230"><em class="italic">Chapter 8</em></a><em class="italic">, Docker Swarm</em> and <a href="B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294"><em class="italic">Chapter 11</em></a><em class="italic">, Docker and Kubernetes</em>.</p>
			<p>As mentioned at the top of this section, this feature is still in active development, and it is possible that the <a id="_idIndexMarker458"/>commands and functionality we<a id="_idIndexMarker459"/> have discussed so far may change in the future. But even at this development stage, I hope you can see the advantages of Docker App and how it is building on the solid foundations laid by Docker Compose.</p>
			<p>Summary</p>
			<p>I hope you have enjoyed this chapter on Docker Compose, and I hope that, like I did, you can see that it has evolved from being an incredibly useful third-party tool to an extremely important part of the core Docker experience.</p>
			<p>Docker Compose introduces some key concepts as to how you should approach running and managing your containers. We will be taking these concepts one step further in <a href="B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230"><em class="italic">Chapter 8</em></a><em class="italic">, Docker Swarm</em> and <a href="B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294"><em class="italic">Chapter 11</em></a><em class="italic">, Docker and Kubernetes</em>, where we start to look at managing multiple Docker hosts and how we can distribute containers across them.</p>
			<p>In the next chapter, we are going to move away from Linux-based containers and take a whistle-stop tour of Windows containers.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor183"/>Questions</h1>
			<ol>
				<li value="1">Docker Compose files use which open source format?</li>
				<li>In our initial Moby counter Docker Compose file, which was the only flag that works exactly the same as its Docker <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) counterpart?</li>
				<li>True or false: You can only use images from the Docker Hub with your Docker Compose files.</li>
				<li>By default, how does Docker Compose decide on the namespace to use?</li>
				<li>Which flag do you add to docker-compose up to start the containers in the background?</li>
				<li>What is the best way to run a syntax check on your Docker Compose files?</li>
				<li>Explain the basic principle about how Docker App works.</li>
			</ol>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor184"/>Further reading</h1>
			<p>For details on Orchard Laboratories, see the following:</p>
			<ul>
				<li>Orchard Laboratories website: <a href="https://web.archive.org/web/20171020135129/https://www.orchardup.com/">https://web.archive.org/web/20171020135129/https://www.orchardup.com/</a></li>
				<li>Orchard Laboratories joins Docker: <a href="https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/">https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/</a>  </li>
			</ul>
			<p>For a full Docker Compose compatibility matrix, see the following:</p>
			<ul>
				<li>Compose file versions and upgrading: <a href="https://docs.docker.com/compose/compose-file/compose-versioning/">https://docs.docker.com/compose/compose-file/compose-versioning/</a></li>
			</ul>
			<p>For more information on the Docker App project, see the following: </p>
			<ul>
				<li>GitHub repository: <a href="http://github.com/docker/app/">http://github.com/docker/app/</a></li>
			</ul>
			<p>Finally, here are some further links to a number of other topics that we have covered:</p>
			<ul>
				<li>YAML project home page: <a href="http://www.yaml.org/">http://www.yaml.org/</a></li>
				<li>Docker sample repository: <a href="https://github.com/dockersamples/">https://github.com/dockersamples/</a></li>
			</ul>
		</div>
	</div>



  </body></html>