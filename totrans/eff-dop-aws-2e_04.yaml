- en: Infrastructure as Code with Terraform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 实现基础设施即代码
- en: In [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as Code*, we familiarized ourselves with AWS CloudFormation and Ansible. We created
    a CloudFormation template to create an EC2 environment and deployed a HelloWorld
    web application on it. Taking a step further in the world of automation, we then
    introduced the **Ansible **configuration management tool. We learnt about how
    Ansible takes care of application deployment and orchestration so that CloudFormation
    templates remain neat and confined until provisioning. This approach is well accepted
    by the tech giants as far as the AWS cloud is concerned, but when we talk about
    heterogeneous environments where we have multiple cloud platforms such as AWS,
    Azure, Google cloud, OpenStack, and VMware then CloudFormation service, as it
    is a AWS-native service, is not applicable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)《将基础设施视为代码》中，我们熟悉了 AWS CloudFormation
    和 Ansible。我们创建了一个 CloudFormation 模板来创建 EC2 环境，并在其中部署了一个 HelloWorld Web 应用程序。在自动化领域更进一步后，我们引入了**Ansible**配置管理工具。我们了解了
    Ansible 如何处理应用程序部署和编排，以便 CloudFormation 模板在配置之前保持简洁和局限。这种方法在 AWS 云环境中被科技巨头们广泛接受，但当我们谈论具有多个云平台（如
    AWS、Azure、Google Cloud、OpenStack 和 VMware）的异构环境时，作为 AWS 原生服务的 CloudFormation 就不再适用了。
- en: Hence, we need an alternative solution that will not only help us to provision
    compute services but also other cloud native services without much effort. Obviously,
    this is possible using complex, unmanageable scripts in imperative way, but we'd
    end up making the environments even more complex. We need a solution that will
    keep the heterogeneous environment simple and manageable, with a declarative approach
    that follows the recommended guidelines regarding using **Infrastructure as Code**
    (**IaC**). This solution is **Terraform**, a tool for building, changing, and
    versioning infrastructure safely and efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个替代方案，不仅能够帮助我们提供计算服务，还能轻松地提供其他云原生服务。显然，这可以通过使用复杂且难以管理的命令式脚本来实现，但我们最终会使环境更加复杂。我们需要一个能够保持异构环境简单且可管理的解决方案，采用声明性方法，并遵循关于使用**基础设施即代码**（**IaC**）的推荐指南。这个解决方案就是**Terraform**，它是一个安全高效地构建、修改和版本化基础设施的工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is Terraform?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Terraform？
- en: Creating a Terraform repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Terraform 仓库
- en: Integrating AWS, Terraform, and Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 AWS、Terraform 和 Ansible
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求如下：
- en: AWS Console
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 控制台
- en: Git
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: GitHub
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Terraform
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform
- en: Ansible
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: 'The following websites provide further information about Terraform:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下网站提供有关 Terraform 的更多信息：
- en: 'Terraform official website for product information: [https://terraform.io](https://terraform.io)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 官方网站，获取产品信息：[https://terraform.io](https://terraform.io)
- en: 'Terraform supported provide details: [https://www.terraform.io/docs/providers/](https://www.terraform.io/docs/providers/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 支持的提供商详情：[https://www.terraform.io/docs/providers/](https://www.terraform.io/docs/providers/)
- en: 'HashiCorp configuration language details: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp 配置语言详情：[https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)
- en: GitHub link for Terraform template for the first project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个项目的 Terraform 模板 GitHub 链接：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf)
- en: 'GitHub link for Terraform template for the second project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个项目的 Terraform 模板 GitHub 链接：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf)
- en: 'Github link for Terraform template for the third project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个项目的 Terraform 模板 Github 链接：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf)
- en: 'Github link for Terraform template for the fourth project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个项目的 Terraform 模板 Github 链接：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)
- en: What is Terraform?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Terraform？
- en: Terraform is an open-source, IaC software that was released in July 2014 by
    a company named **HashiCorp**. This is the same company that produced tools including
    Vagrant, Packer, and Vault. Terraform was released under the **Mozilla Public
    License** (**MPL**) version 2.0\. The source code for Terraform is available on
    GitHub at [https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform).
    Anyone can use this source code and contribute to Terraform's development.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个开源的基础设施即代码（IaC）软件，于 2014 年 7 月由 **HashiCorp** 公司发布。该公司还生产了包括 Vagrant、Packer
    和 Vault 等工具。Terraform 以 **Mozilla 公共许可证**（**MPL**）2.0 版本发布。Terraform 的源代码可以在 GitHub
    上找到：[https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform)。任何人都可以使用这些源代码并为
    Terraform 的开发做出贡献。
- en: 'Terraform allow users to define a datacenter infrastructure in a high-level
    configuration language called **HashiCorp Configuration Language** (**HCL**).
    HashiCorp also provide the Enterprise version of Terraform, which comes with added
    support. There are lot of features available with Terraform, which makes it a
    perfect high-level infrastructure orchestration tool. It has the following features:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 允许用户使用一种高级配置语言 **HashiCorp 配置语言**（**HCL**）定义数据中心基础设施。HashiCorp 还提供了
    Terraform 的企业版，带有额外的支持功能。Terraform 提供了许多功能，使其成为一个完美的高级基础设施编排工具。它具有以下特点：
- en: It has very easy and minimal installation steps.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的安装步骤非常简单，几乎不需要配置。
- en: It has a declarative approach to write Terraform templates.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它采用声明式的方法来编写 Terraform 模板。
- en: It is available as both open-source and Enterprise offerings.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它既有开源版本，也有企业版。
- en: It has idempotency, which means the Terraform templates provide the same result
    every time you apply them in your environment.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有幂等性，这意味着每次应用 Terraform 模板时，都会在你的环境中提供相同的结果。
- en: It is a perfect match for almost all majorly available cloud platforms such
    as AWS, Azure, GCP, OpenStack, DigitalOcean, and so on. Refer to [https://www.terraform.io/docs/providers/](https://www.terraform.io/docs/providers/)
    for more details.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它几乎与所有主要的云平台完美兼容，如 AWS、Azure、GCP、OpenStack、DigitalOcean 等。更多详情请参阅[https://www.terraform.io/docs/providers/](https://www.terraform.io/docs/providers/)。
- en: '**However, Terraform is not*:***'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**然而，Terraform 不是：**'
- en: A configuration management tool like Puppet, Chef, Ansible, or SaltStack. You
    can install some lightweight programs or software to ship some important configuration
    files inside your instances, but when it comes to the deployment and orchestration
    of more complex applications, you need to use configuration tools like those listed
    in the preceding section.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理工具，如 Puppet、Chef、Ansible 或 SaltStack。你可以安装一些轻量级程序或软件，将一些重要的配置文件推送到你的实例中，但当涉及到更复杂应用程序的部署和编排时，你需要使用前面章节中提到的配置工具。
- en: A low-level tool like Boto for AWS.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个低级工具，如 AWS 的 Boto。
- en: Getting started with Terraform
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 Terraform
- en: In this book, we will focus on open-source Terraform. We will be demonstrating
    the complete Terraform setup on the CentOS 7.x machine that we used in the previous
    chapters. HashiCorp does not provide native packages for operating systems, so
    Terraform is distributed as a single binary, packaged inside a ZIP archive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将重点介绍开源 Terraform。我们将展示如何在前几章中使用的 CentOS 7.x 机器上完整设置 Terraform。HashiCorp 不为操作系统提供原生软件包，因此
    Terraform 作为单个二进制文件分发，并打包在 ZIP 压缩档案中。
- en: 'Let''s set up Terraform on our CentOS server. Follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 CentOS 服务器上设置 Terraform。请按照以下步骤操作：
- en: 'We have to download the Terraform binaries from the official website: [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html).
    In our case, we will be using Linux 64-bit:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须从官方网站下载 Terraform 二进制文件：[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)。在我们的案例中，我们将使用
    Linux 64 位版本：
- en: '![](img/07cd1d07-a578-4c7d-bc18-36f0e93c6fff.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07cd1d07-a578-4c7d-bc18-36f0e93c6fff.png)'
- en: 'Unzip the extracted Terraform `.zip` file. You need to install the unzip package
    if it is not already present:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压提取的 Terraform `.zip` 文件。如果您的系统未安装 unzip 包，您需要先安装它：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will extract the Terraform binary to the `/usr/bin`, which is available
    in the PATH environment variable for your Linux systems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 Terraform 二进制文件提取到 `/usr/bin` 目录，Linux 系统的 PATH 环境变量中可以访问此目录。
- en: 'Finally, check the installed version of Terraform. The latest version of Terraform
    software available at the time of writing is the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查已安装的 Terraform 版本。编写时可用的最新版本 Terraform 软件如下：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can observe, setting up Terraform takes just a matter of minutes and
    it has very lightweight binaries. We are now all set to use the Terraform environment
    for AWS service provisioning.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，设置 Terraform 仅需几分钟，而且它的二进制文件非常轻量。现在我们已准备好使用 Terraform 环境进行 AWS 服务的配置。
- en: Terraform and AWS for automated provisioning
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 和 AWS 进行自动化配置
- en: 'As mentioned previously, Terraform supports multiple providers such as AWS,
    Azure, and GCP for high level infrastructure orchestration. In this book, we will
    use only the AWS platform. As we saw at in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*, we can deploy compute services or any
    AWS service using two modes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Terraform 支持多个提供商，如 AWS、Azure 和 GCP，进行高级基础设施编排。在本书中，我们仅使用 AWS 平台。正如我们在[第二章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中所看到的，*部署您的第一个
    Web 应用程序*，我们可以使用两种模式来部署计算服务或任何 AWS 服务：
- en: AWS Management Console
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 管理控制台
- en: AWS **Command Line Interface** (**CLI**)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS **命令行界面**（**CLI**）
- en: Deployment using AWS Management Console
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS 管理控制台进行部署
- en: 'Here, we will focus on deploying the AWS compute service as we did previously.
    Deploying AWS instances using the AWS Management Console is fairly simple. Follow
    the steps below:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将重点介绍部署 AWS 计算服务，和之前的操作相同。使用 AWS 管理控制台部署 AWS 实例相对简单。请按照以下步骤进行：
- en: Log in into your AWS Management Console at [https://console.aws.amazon.com](https://console.aws.amazon.com)
    or use your IAM user account to log in . We created an IAM user account in [Chapter
    2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First Web Application* at
    `https://AWS-account-ID-or-alias.signin.aws.amazon.com/console`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的 AWS 管理控制台，访问 [https://console.aws.amazon.com](https://console.aws.amazon.com)
    或使用您的 IAM 用户账户登录。我们在[第二章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中创建了一个 IAM
    用户账户，*部署您的第一个 Web 应用程序*，网址为 `https://AWS-account-ID-or-alias.signin.aws.amazon.com/console`。
- en: Select the Services tab, followed by EC2 from the Compute section, and click
    on the Launch Instance button.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 "服务" 标签，接着选择 "计算" 部分中的 EC2，并点击 "Launch Instance" 按钮。
- en: On the next screen, search for and select **Amazon Machine Image** (**AMI**).
    In this book, we are using `ami-cfe4b2b0`, which is Amazon Linux AMI.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，搜索并选择 **Amazon 机器映像**（**AMI**）。在本书中，我们使用的是 `ami-cfe4b2b0`，即 Amazon Linux
    AMI。
- en: 'Select the `t2.micro` type from the Choose an Instance Type step and click
    on the Next: Configure Instance Details button.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从 "选择实例类型" 步骤中选择 `t2.micro` 类型，并点击 "Next: Configure Instance Details" 按钮。'
- en: 'Accept the default settings and click the Next: Add Storage button.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接受默认设置并点击 "Next: Add Storage" 按钮。'
- en: 'Again, accept the default setting for storage and click on the Next: Add tags
    button followed by the Next: Configure Security Group button.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '再次接受存储的默认设置，然后点击 "Next: Add tags" 按钮，接着点击 "Next: Configure Security Group"
    按钮。'
- en: 'Here, select the security group you created in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*, which in my case is `sg-01864b4c`, as
    shown in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此，选择您在[第二章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中创建的安全组，*部署您的第一个 Web
    应用程序*，在我的案例中是 `sg-01864b4c`，如下图所示：
- en: '![](img/84638492-0f99-42cc-9943-fea369e16fc2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84638492-0f99-42cc-9943-fea369e16fc2.png)'
- en: Now, click on the Review and Launch button. Ignore any warnings that appear
    and press the Launch button.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 "Review and Launch" 按钮。忽略出现的任何警告并按 "Launch" 按钮。
- en: Select the key-pair, which in my case is `EffectiveDevOpsAWS`. Click the Launch
    Instances button.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择密钥对，在我的案例中是 `EffectiveDevOpsAWS`。点击 "Launch Instances" 按钮。
- en: 'Within a few minutes, your AWS instance will be up and running. Once the server
    is up, log in to the server from your local instance, which is CentOS in my case.
    Proceed with the following process to deploy the Hello World application manually
    and verify it locally or from the browser:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你的 AWS 实例将启动并运行。服务器启动后，从本地实例（在我的例子中是 CentOS）登录到服务器。按照以下步骤手动部署 Hello World
    应用程序并进行本地或浏览器验证：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember to terminate the instance from the AWS Management Console once you
    are done with the test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，请记得通过 AWS 管理控制台终止该实例。
- en: 'The termination process is also very straightforward. Select the created instance,
    click the Actions drop-down, followed by the Instance State option and then click
    Terminate, as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 终止过程也非常简单。选择创建的实例，点击操作下拉菜单，选择实例状态选项，然后点击“终止”，如下图所示：
- en: '![](img/6d672c5a-97c1-4aa0-8b97-bc792a0d98b5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d672c5a-97c1-4aa0-8b97-bc792a0d98b5.png)'
- en: Deployment using AWS CLI
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS CLI 进行部署
- en: 'The steps for creating an instance and deploying the Hello World web application
    using AWS CLI have already been demonstrated in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*. You need to make sure to install the `awscli`
    utility before proceeding further. Here is a quick overview for deploying the
    Hello World web application using AWS CLI:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS CLI 创建实例并部署 Hello World Web 应用程序的步骤已经在[第 2 章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中演示过，*部署你的第一个
    Web 应用程序*。你需要确保在继续之前安装 `awscli` 工具。以下是使用 AWS CLI 部署 Hello World Web 应用程序的简要概述：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure to replace `i-0eb05adae2bb760c6` with the AWS instance ID that you
    created in the previous command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `i-0eb05adae2bb760c6` 替换为你在前一个命令中创建的 AWS 实例 ID。
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember to terminate the instance using `aws ec2 terminate-instances --instance-ids
    <AWS INSTANCE ID>` once you are done with the testing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，请记得使用 `aws ec2 terminate-instances --instance-ids <AWS 实例 ID>` 终止该实例。
- en: Creating our Terraform repository
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的 Terraform 仓库
- en: 'We have now looked at two modes for creating AWS EC2 instances: using AWS Management
    Console and using AWS CLI. These can be automated using the AWS cloud native service
    called **CloudFormation template**, as we saw in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code. *This is only applicable for use with the
    AWS cloud. In this chapter, we will achieve the same results of provisioning AWS
    instances using Terraform. Refer to [https://www.terraform.io/intro/vs/cloudformation.html](https://www.terraform.io/intro/vs/cloudformation.html)
    to understand the differences between Terraform and CloudFormation.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了两种创建 AWS EC2 实例的方式：使用 AWS 管理控制台和使用 AWS CLI。我们可以通过 AWS 原生服务 **CloudFormation
    模板**来实现自动化，如在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)中所示，*将基础设施视为代码*。这仅适用于
    AWS 云。在本章中，我们将使用 Terraform 达到相同的 AWS 实例配置效果。参考[https://www.terraform.io/intro/vs/cloudformation.html](https://www.terraform.io/intro/vs/cloudformation.html)以了解
    Terraform 和 CloudFormation 的区别。
- en: 'Let''s create a dedicated repository in our GitHub account and start our journey
    with Terraform. Once you''ve logged in to GitHub, create a new repository for
    the Terraform templates by following the steps below:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 GitHub 账户中创建一个专门的仓库，开始我们的 Terraform 之旅。登录 GitHub 后，按照以下步骤为 Terraform 模板创建一个新仓库：
- en: In your browser, open [https://github.com/new](https://github.com/new).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，打开 [https://github.com/new](https://github.com/new)。
- en: 'Call the new repository `EffectiveDevOpsTerraform` as shown in the following
    screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，将新仓库命名为 `EffectiveDevOpsTerraform`：
- en: '![](img/b675f6aa-9701-4ca5-ae8d-de5df2f827e5.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b675f6aa-9701-4ca5-ae8d-de5df2f827e5.png)'
- en: Check the Initialize this repository with a README checkbox.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“初始化此仓库并添加 README”复选框。
- en: Finally, click the Create repository button.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击“创建仓库”按钮。
- en: 'Once your repository is created, you will want to clone it to your system.
    To do this, you need to have Git installed. If you don''t have Git yet, search
    on Google for instructions on how to install it for your operating system. For
    CentOS, you just need to run `yum -y install git` as the Git package is part of
    the Linux distribution now:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完仓库后，你需要将其克隆到你的系统中。为此，你需要安装 Git。如果还没有安装 Git，可以在 Google 上搜索如何为你的操作系统安装它。对于
    CentOS，你只需要运行 `yum -y install git`，因为 Git 包现在已经包含在 Linux 发行版中：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that the repository is cloned, it''s time to start developing Terraform
    templates. Go into the `EffectiveDevOpsTerraform` repository and create a directory
    called `firstproject`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仓库已被克隆，接下来是开始开发 Terraform 模板。进入 `EffectiveDevOpsTerraform` 仓库并创建一个名为 `firstproject`
    的目录：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First Terraform template for AWS instance provisioning
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个用于 AWS 实例配置的 Terraform 模板
- en: Terraform is used to create, manage, and update infrastructure resources such
    as virtual machines, cloud instances, physical machines, containers, and much
    more. Almost any infrastructure type can be represented as a resource in Terraform.
    We are going to create a resource in the next step. Before that, we need to understand
    *Terraform providers,* which are responsible for understanding API interactions
    and exposing resources. A provider could be IaaS (such as AWS, GCP, and so on),
    PaaS (such as Heroku) or SaaS (such as DNSimple). The provider is the first section
    with which we have to start our Terraform templates. Before using Terraform to
    create an instance, we need to configure the AWS provider. This is the first piece
    of code that we are going to write in our template.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 用于创建、管理和更新基础设施资源，例如虚拟机、云实例、物理机器、容器等几乎所有基础设施类型都可以在 Terraform 中作为资源表示。我们将在下一步创建一个资源。在此之前，我们需要了解
    *Terraform 提供者*，它们负责理解 API 交互并暴露资源。提供者可以是 IaaS（如 AWS、GCP 等）、PaaS（如 Heroku）或 SaaS（如
    DNSimple）。提供者是我们必须从头开始编写 Terraform 模板的第一部分。在使用 Terraform 创建实例之前，我们需要配置 AWS 提供者。这将是我们在模板中编写的第一段代码。
- en: 'Templates are written in a special language called HCL. More details about
    HCL can be found at [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl).
    You can also write your templates in JSON, but we will be using HCL here. Terraform
    template files must have the extension `.tf`, which stands for **Terraform file**.
    Let''s create our first template, `ec2.tf`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是用一种叫做 HCL 的特殊语言编写的。关于 HCL 的更多细节可以在 [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)
    找到。你也可以用 JSON 编写模板，但我们这里将使用 HCL。Terraform 模板文件必须以 `.tf` 为扩展名，代表 **Terraform 文件**。让我们创建第一个模板，`ec2.tf`：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Visit [https://www.terraform.io/docs/providers/aws/index.html](https://www.terraform.io/docs/providers/aws/index.html)
    to explore more options about the AWS provider.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://www.terraform.io/docs/providers/aws/index.html](https://www.terraform.io/docs/providers/aws/index.html)
    以探索更多关于 AWS 提供者的选项。
- en: This type of declaration for providers in Terraform is called *configuring providers
    using static credentials. *It is not a secure way of declaring providers; there
    are other options in Terraform, such as environment variables, Terraform variable
    files, AWS native credential files (`~/.aws/credentials`), and so on, for storing
    providers with sensitive information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 中，声明提供者的这种方式叫做 *使用静态凭证配置提供者*。这并不是声明提供者的安全方式；Terraform 还有其他选项，比如环境变量、Terraform
    变量文件、AWS 本地凭证文件（`~/.aws/credentials`）等，用来存储包含敏感信息的提供者。
- en: Do not push your AWS access key or your secret key on GitHub or any other public
    website. Doing so will allow hackers to hack your AWS account.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将你的 AWS 访问密钥或密钥保存在 GitHub 或任何其他公共网站上。这样做将允许黑客攻击你的 AWS 账户。
- en: Before moving on, we need to install the plugin or reinitialize the plugins
    that are related to AWS for Terraform. We don't need to do much here; the configured
    file with the `provider` plugins will perform this task for us.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要安装或重新初始化与 AWS 相关的 Terraform 插件。我们不需要做太多，这个配置文件中的 `provider` 插件会为我们执行这个任务。
- en: 'Run the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/447b2674-ac14-4a99-9492-8cd881d34792.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/447b2674-ac14-4a99-9492-8cd881d34792.png)'
- en: 'The next step is to configure our infrastructure. This is where we start developing
    the `ec2.ft` file with Terraform resources. Resources are components of your infrastructure.
    They can be as complex as a complete virtual server that has multiple other services,
    or as simple as a DNS record. Each resource belongs to a provider and the type
    of the resource is suffixed with the provider name. The configuration of a resource, which
    is called a `resource` block, takes the following form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置我们的基础设施。在这里，我们开始使用 Terraform 资源来开发 `ec2.tf` 文件。资源是基础设施的组件。它们可以像一个完整的虚拟服务器一样复杂，具有多个其他服务，或者像
    DNS 记录一样简单。每个资源都属于一个提供者，资源类型的后缀是提供者的名称。资源的配置，也叫做 `resource` 块，具有以下形式：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our case, we have to create an EC2 instance. The `aws_instance` resource
    in Terraform is responsible for this job. To create an instance, we need to set
    at least two parameters: `ami` and `instance_type`. These two parameters are required,
    whereas the others are optional. In order to get a list and a description of all
    the `aws_instance` resource parameters, check out the following website: [https://www.](https://www.terraform.io/docs/providers/aws/r/instance.html)[terraform.io/docs/providers/aws/r/instance.html](https://www.terraform.io/docs/providers/aws/r/instance.html).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们需要创建一个 EC2 实例。Terraform 中的 `aws_instance` 资源负责完成这项工作。为了创建实例，我们至少需要设置两个参数：`ami`
    和 `instance_type`。这两个参数是必需的，而其他参数是可选的。为了获取所有 `aws_instance` 资源参数的列表和描述，请访问以下网站：[https://www.terraform.io/docs/providers/aws/r/instance.html](https://www.terraform.io/docs/providers/aws/r/instance.html)。
- en: 'In our case we will create an instance with the same details with which we
    created and tested the instance using the AWS Management Console and the AWS CLI
    utility. We have `ami-cfe4b2b0` as AMI and `t2.micro` as our instance type. `EffectiveDevOpsAWS` is
    the key name that we created in the past and `sg-01864b4c` is our security group.
    We are also tagging the instance with the name `helloworld` for easy recognition.
    It''s worth mentioning that like any other scripting or automation language, you
    can put *comments* in the Terraform template with the `#` sign. Our complete file
    should now look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用 AWS 管理控制台和 AWS CLI 工具创建并测试一个实例。我们使用 `ami-cfe4b2b0` 作为 AMI，`t2.micro`
    作为实例类型。`EffectiveDevOpsAWS` 是我们之前创建的密钥名称，`sg-01864b4c` 是我们的安全组。我们还为实例添加了标签 `helloworld`，以便于识别。值得一提的是，像其他任何脚本或自动化语言一样，你可以在
    Terraform 模板中使用 `#` 符号添加 *注释*。我们完整的文件现在应该如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The created file should look like the file at the following website:  [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件应该像以下网站中的文件一样：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf)。
- en: 'Let''s validate the Terraform template first to ensure that the template doesn''t
    have any syntax errors. Terraform has a dedicated `terraform validate` utility, which
    checks the syntax of the Terraform template and provides us with the outputs if
    there are any syntax errors that need our attention:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先验证 Terraform 模板，确保模板没有语法错误。Terraform 提供了一个专门的 `terraform validate` 工具，它检查
    Terraform 模板的语法，并在发现需要注意的语法错误时给出输出：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As there are no outputs, this signifies that our Terraform template is free
    from syntax errors. It''s time to perform a dry run to see what this template
    will execute. This is just a smoke test to find out which changes or implementations
    will be performed by the template we have created. This step in Terraform is known
    as **plan**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有输出，这意味着我们的 Terraform 模板没有语法错误。是时候进行一次干运行，以查看这个模板将执行什么操作。这只是一个烟雾测试，用来找出模板将执行哪些更改或实现。Terraform
    中的这个步骤称为 **plan**：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we didn''t specify an `-out` parameter to save this plan, so Terraform
    can''t guarantee that these actions exactly will be performed if `terraform apply`
    is subsequently run:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有指定 `-out` 参数来保存这个计划，因此 Terraform 无法保证如果后续运行 `terraform apply` 时，这些操作将会
    **完全** 执行。
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our plan stage indicates the same parameters that we want in the real execution
    while creating our instance. Again, don't get confused with the `<computed>` parameters,
    this just signifies that their value will be assigned when the resources are created
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划阶段指示了我们在实际执行时希望创建实例的相同参数。再次强调，不要混淆 ` <computed>` 参数，这只是表示它们的值将在资源创建时分配。
- en: Let's now execute our plan for real and look at how a Terraform template can
    be used to create an AWS instance with the defined resource parameters. Terraform
    does this using the `terraform apply` utility and you can think of this stage
    as **apply**. Once you execute `terraform apply`, it will ask for your approval
    by default for confirmation. Type `yes` to start the resource creation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们真正执行我们的计划，看看如何使用 Terraform 模板创建一个具有定义资源参数的 AWS 实例。Terraform 使用 `terraform
    apply` 工具来执行此操作，你可以把这个阶段看作是 **apply**。一旦执行 `terraform apply`，它默认会要求你确认操作。输入 `yes`
    来开始资源创建。
- en: 'In case you want to skip this interactive approval of the plan before applying
    it, use the `--auto-approve` option with the `terraform apply` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在应用计划之前跳过此交互式审批，可以在`terraform apply`命令中使用`--auto-approve`选项：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s confirm the newly created instance from our AWS console to ensure the
    `helloworld` instance has been created by the Terraform template:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在AWS控制台中确认新创建的实例，确保`helloworld`实例是由Terraform模板创建的：
- en: '![](img/e9a87db7-d720-4773-97d0-ce44f3339c76.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9a87db7-d720-4773-97d0-ce44f3339c76.png)'
- en: 'Terraform didn''t simply create an instance and forget about it. In fact, Terraform
    actually saves everything it knows about the resources (in our case, the instance)
    to a special file, which is known as the **state file** in Terraform. In this
    file, Terraform stores the state of all the resources it has created. It is saved
    to the same directory where the Terraform template is present and with the `.tfstate`
    extension. The format of the state file is a simple JSON format:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform不仅仅创建了一个实例然后就忘记了它。实际上，Terraform会将它所知道的关于资源（在我们的例子中是实例）的所有信息保存到一个特殊的文件中，这个文件在Terraform中被称为**状态文件**。在这个文件中，Terraform存储了它所创建的所有资源的状态。它保存在与Terraform模板相同的目录中，并且文件扩展名为`.tfstate`。状态文件的格式是一个简单的JSON格式：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The special part about Terraform is that you can read this JSON output in a
    human-readable format using the `terraform show` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform的特殊之处在于，你可以通过`terraform show`命令以人类可读的格式读取这个JSON输出：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Up to here, we have created a Terraform template, validated it to ensure there
    are no syntax errors, performed a smoke test in the form of `terraform plan`,
    and then finally applied our Terraform template using `terraform apply` to create
    resources.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个Terraform模板，验证它以确保没有语法错误，并进行了`terraform plan`形式的冒烟测试，最后通过`terraform
    apply`应用了我们的Terraform模板来创建资源。
- en: 'The question remaining is *how can we delete or destroy all of the resources
    that are created by the Terraform template?* Do we need to find and delete resources
    one after another? The answer is No, this will also be taken care of by Terraform.
    By referring to the state file Terraform created during the **apply** phase, any
    resources that have been created by Terraform can be destroyed using the simple
    `terraform destroy` command from the `template` directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的问题是，*我们如何删除或销毁Terraform模板创建的所有资源？*我们是否需要逐一查找并删除资源？答案是否定的，Terraform会自动处理这个问题。通过参考Terraform在**apply**阶段创建的状态文件，任何由Terraform创建的资源都可以使用简单的`terraform
    destroy`命令在`template`目录中销毁：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Check your AWS console to ensure that the instance is in a terminated state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的AWS控制台，确保实例处于终止状态。
- en: Check the `terraform show` command now. It should be empty as none of your resources
    will be available.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查`terraform show`命令。由于没有任何资源可用，它应该为空。
- en: A second Terraform template for deploying a Hello World application
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于部署Hello World应用程序的第二个Terraform模板
- en: 'Go into the EffectiveDevOpsTerraform repository and create a directory called
    `second project`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 进入EffectiveDevOpsTerraform仓库并创建一个名为`second project`的目录：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have created our EC2 instance with the Terraform template in the
    previous section, we are ready to extend the provisioning of our Hello World web
    application. We are going to use **Terraform Provisioner** to recreate the Hello
    World stack that we previously made using the `UserDatablock` field of CloudFormation
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application* and using Ansible roles in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating
    Your Infrastructure as Code*. If you recall, the `UserData` field looked roughly
    like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在上一节中使用Terraform模板创建了EC2实例，接下来我们准备扩展我们Hello World网页应用程序的配置。我们将使用**Terraform
    Provisioner**重新创建我们之前通过[第2章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中CloudFormation的`UserDatablock`字段，*部署你的第一个网页应用*以及在[第3章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)中使用Ansible角色，*将基础设施视为代码*时所创建的Hello
    World堆栈。如果你还记得，`UserData`字段大致如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will observe that there are three different types of operations for the
    deployment of our Hello World web application. First, we prepare the system to
    run our application. To do this, in our example, we are simply installing the
    Node.js package. Next, we copy the different resources that are needed to run
    the application. In our case, these resources include the JavaScript code and
    the upstart configuration. Finally, we start the service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您会观察到，部署我们 Hello World 网络应用程序的操作有三种不同的类型。首先，我们准备系统以运行应用程序。在我们的示例中，我们只是安装 Node.js
    包。接下来，我们复制运行应用程序所需的不同资源。在我们的例子中，这些资源包括 JavaScript 代码和 upstart 配置。最后，我们启动服务。
- en: In order to deploy our Hello World web application, we need to introduce **Terraform
    Provisioner**. Provisioners in Terraform are configuration blocks available for
    several resources that allow you to perform actions after the resource has been
    created. It is mostly used for EC2 instances. Provisioners are primarily used
    as **post build steps** to install lightweight applications or configuration management
    agents such as **Puppet agents** or **chef-clients**. They can even be used to
    run configuration management tools such as** playbooks**, **Puppet modules**,
    **Chef cookbooks,** or **Salt formulas**. In the next section, we’ll look at a
    few examples of how to use Terraform with Ansible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的 Hello World 网络应用程序，我们需要引入**Terraform Provisioner**。Terraform 中的 Provisioners
    是可用于多个资源的配置块，允许您在资源创建后执行操作。它主要用于 EC2 实例。Provisioners 主要用作**构建后步骤**，用于安装轻量级应用程序或配置管理代理，例如**Puppet
    代理**或**chef-client**。它们甚至可以用来运行配置管理工具，如**playbooks**、**Puppet 模块**、**Chef 食谱**或**Salt
    配方**。在接下来的章节中，我们将查看如何将 Terraform 与 Ansible 配合使用的几个示例。
- en: 'Let''s create the `helloworldec2.tf` Terraform template to create the instance
    and then introduce the `provisioner` block with `remote-exec` to establish a connection
    with the newly created instance and download and deploy Hello World application
    on top of it. Our completed Terraform template should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`helloworldec2.tf` Terraform 模板来创建实例，然后引入`provisioner`块，使用`remote-exec`与新创建的实例建立连接，并在其上下载和部署
    Hello World 应用程序。我们完成的 Terraform 模板应如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The created file should look like the file at: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件应如下所示：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf)。
- en: 'As we are creating the Terraform template inside a new directory, `secondproject`,
    we need to install the plugin or reinitialize the plugins that are related to
    AWS for Terraform. The configured file with the `provider` section will perform
    this task for us:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在新目录`secondproject`中创建 Terraform 模板，因此需要安装插件或重新初始化与 AWS 相关的 Terraform 插件。配置了`provider`部分的文件将为我们执行此任务：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, it''s time to validate the Terraform template file to ensure that it doesn''t
    have any syntax errors. Upon successful verification, run the `plan` command followed
    by the complete execution of the template using the `terraform apply` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了验证 Terraform 模板文件的时间，确保它没有任何语法错误。验证成功后，运行`plan`命令，然后使用`terraform apply`命令完整执行模板：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will get the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/74a89c11-cd79-4b49-bf46-d247fa6002c7.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74a89c11-cd79-4b49-bf46-d247fa6002c7.png)'
- en: 'Our Terraform template has been executed successfully. We have provisioned
    our EC2 instance and deployed our Hello World web application. Let''s find the
    public IP of the instance by executing the `terraform show` command followed by
    the `curl` command to ensure the application has deployed correctly:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Terraform 模板已经成功执行。我们已配置好 EC2 实例并部署了 Hello World 网络应用程序。通过执行`terraform show`命令，接着运行`curl`命令，我们可以找到实例的公网
    IP，并确保应用程序已正确部署：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of running the preceding commands is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面命令的输出如下：
- en: '![](img/f4fd6d3b-0d69-4e9a-8008-6d611ecf636e.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4fd6d3b-0d69-4e9a-8008-6d611ecf636e.png)'
- en: 'Let''s verify the application outputs from our browser as well, as shown in
    the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也从浏览器验证应用程序的输出，如下截图所示：
- en: '![](img/3cad4e6c-7026-47ad-a64f-ec111e1b909f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cad4e6c-7026-47ad-a64f-ec111e1b909f.png)'
- en: We have now successfully deployed our Hello World web application using the
    power of Terraform. Once you've tested it, make sure to remove all of the created
    resources before you proceed to the next section. Execute the `terraform destroy` command,
    which will take care of removing all of the created resources by referring to
    the Terraform state file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Integrating AWS, Terraform, and Ansible
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we looked at how to provision a vanilla instance using
    Terraform. We then learnt how to provision a vanilla EC2 instance and execute
    **post builds** using the Terraform `remote-exec` provisioner. Now, we'll look
    at how Terraform can be integrated with Ansible to perform configuration management
    tasks. We will consider two different scenarios. In scenario one, we will provision
    an EC2 instance and run Ansible using **push** mode, which is the primary way
    that we can use Ansible to perform automation. In scenario two, we will provision
    an EC2 instance and run Ansible in **pull** mode using the `ansible pull` approach.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Terraform with Ansible using a push-based approach
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go into the `EffectiveDevOpsTerraform` repository and create a directory called
    `thirdproject`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we will use the recommended practices to create Terraform
    templates. We will remove our AWS `access_key` and our AWS `secret_key` from our
    Terraform template first. We have AWS CLI installed on our system, which means
    that we have already configured this system to talk to our AWS account. If we
    don''t already have AWS CLI installed, we will use the `aws configure` to install
    it. This will create a `credentials` file inside the `/root/.aws` directory, which
    will contain our AWS access and secret keys. We will take the advantage of this
    file for our Terraform template and use the same credentials to build resources
    on our AWS account:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It's now time to start writing our `helloworldansible.tf` Terraform template.
    In this case, we will provision an EC2 instance and wait for the SSH services
    to appear by verifying the connection using the `remote-exec` provisioner. We
    will then use the `local-exec` provisioner to create the inventory with the new
    IP and run the Ansible playbooks on it using the primary push model by executing
    `ansible-playbook` locally from the system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Inside provisioners (and only inside provisioners), we can use a special keyword,
    self, to access the attributes of a resource being provisioned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also using another block in our code, which is called the `output` block.
    Outputs allow you to return data from the Terraform template after it was applied,
    using the Terraform `output` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The created file should look like the file at: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call the `helloworld` role in our `helloworld.yml` Ansible playbook
    to deploy the Hello World web application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Ansible configuration file `ansible.cfg` should look like as follows. It should
    be pointing to the `myinventory` file that is present in our `thirdproject` directory
    structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The complete project should look like the file at: [https://github.com/yogeshraheja/EffectiveDevOpsTerraform/tree/master/thirdproject](https://github.com/yogeshraheja/EffectiveDevOpsTerraform/tree/master/thirdproject).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have created a new directory, `thirdproject`, we again need to install
    the plugin or reinitialize the plugins that are related to AWS for Terraform.
    The configured file with the `provider` section will perform this task for us:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s now time to validate the Terraform template file to ensure that it doesn''t
    have any syntax errors. Upon successful verification, execute the plan followed
    by the real run using `terraform apply`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/6be50f8a-b01b-465e-af98-7a1e7dd6ef3d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'The outputs are clearly showing the logs for Ansible playbook and returning
    the `output` block with the public IP. Let''s use this public IP to verify the
    application deployment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4984bbc-16e4-45eb-947a-cb4cbf246809.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Let''s verify the application outputs from the browser, as shown in the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e2f9158-9806-45fd-bfef-2c74ddcd9c5b.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Upon successful deployment, execute `terraform destroy` to clean up the created
    resources:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Terraform with Ansible using the pull-based approach
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go into the `EffectiveDevOpsTerraform` repository and create a directory called
    `fourthproject`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we will follow the best practices for Terraform templates here and use
    the `credentials` file located in the `/root/.aws` directory, which contains our
    AWS access and secret keys. In this case, we will use Ansible in the inverted
    form: the *Ansible pull-based approach*. To use Ansible in this inverted approach,
    we have to make sure to install Ansible on the provisioned EC2 instance and run
    `ansible-pull` by referring to the Ansible code that is present at the source
    code repository.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case we will be using the same Ansible code that we created in [Chapter
    3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as* *Code*, which is present at [https://github.com/yogeshraheja/ansible](https://github.com/yogeshraheja/ansible).
    In our `helloworldansiblepull.tf` Terraform template, we will be using a `remote-exec` Terraform
    provisioner to establish a connection with the newly created instance. We will
    use the `inline` attribute to execute multiple commands remotely on the newly
    created EC2 installation. Our Terraform template should look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The created file should look like the file at: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)[.](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: As we have again created a new directory, `fourthproject`, we need to install
    the plugin or reinitialize the plugins related to AWS for Terraform. The configured
    file with the `provider` section will perform this task for us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s now time to validate the Terraform template file to ensure that it doesn''t
    have any syntax errors. Upon successful verification, execute the plan followed
    by the real run using `terraform apply`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](img/b1f84de9-d412-4c1d-96cf-c1c1a2c0d646.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'As expected, the Ansible code is running locally on the newly created EC2 instance.
    The `output` block configured in the Terraform template has also returned the
    expected value of the public IP. Let''s verify the outputs using the `curl` command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b18915c9-d5e4-47bd-bb8a-c9024d7053a2.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'Finally, verify the outputs from the browser, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1610102-16ba-4ec7-a870-85205f19eb08.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Great—the application is deployed and verified. Once you are done, don''t forget
    to destroy the resource using the following command, to avoid unwanted AWS bills:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to efficiently manage infrastructure using Terraform
    templates. First, we learned about how Terraform can be used to provision an EC2
    instance in just a few lines. We then looked at how to create Terraform templates
    using Terraform provisioners to deploy lightweight applications. We then extended
    the Terraform templates with Ansible, which allowed us to orchestrate the different
    steps to deploy our web application. Finally, we looked at how Terraform can be
    integrated with Ansible in a pull-based approach, which usually makes more sense
    when managing sizable infrastructures, as we observed in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We now have a good production environment ready to host any application. We
    have seen how to architect it using CloudFormation, Ansible, and Terraform. In
    Chapter 5, *Adding Continuous Integration and Continuous Deployment*, we will
    continue to use CloudFormation and Ansible, but in the context of software delivery,
    as we will learn how to put in place continuous integration testing and continuous
    deployment.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Terraform and how it is different from other configuration management
    tools?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you install Terraform on a Linux-based operating system?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you provision your first AWS instance using a Terraform template?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write a Terraform template to integrate Ansible with a pull-based
    approach?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写Terraform模板以集成基于拉取的Ansible方法？
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Read the following articles for more information:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下文章以获取更多信息：
- en: '**Terraform reference** at [https://terraform.io](https://terraform.io)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform参考** 在 [https://terraform.io](https://terraform.io)'
- en: '**Terraform GitHub reference** at [https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform GitHub参考** 在 [https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform)'
