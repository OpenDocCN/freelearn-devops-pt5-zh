- en: Infrastructure as Code with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as Code*, we familiarized ourselves with AWS CloudFormation and Ansible. We created
    a CloudFormation template to create an EC2 environment and deployed a HelloWorld
    web application on it. Taking a step further in the world of automation, we then
    introduced the **Ansible **configuration management tool. We learnt about how
    Ansible takes care of application deployment and orchestration so that CloudFormation
    templates remain neat and confined until provisioning. This approach is well accepted
    by the tech giants as far as the AWS cloud is concerned, but when we talk about
    heterogeneous environments where we have multiple cloud platforms such as AWS,
    Azure, Google cloud, OpenStack, and VMware then CloudFormation service, as it
    is a AWS-native service, is not applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we need an alternative solution that will not only help us to provision
    compute services but also other cloud native services without much effort. Obviously,
    this is possible using complex, unmanageable scripts in imperative way, but we'd
    end up making the environments even more complex. We need a solution that will
    keep the heterogeneous environment simple and manageable, with a declarative approach
    that follows the recommended guidelines regarding using **Infrastructure as Code**
    (**IaC**). This solution is **Terraform**, a tool for building, changing, and
    versioning infrastructure safely and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Terraform?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Terraform repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating AWS, Terraform, and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following websites provide further information about Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform official website for product information: [https://terraform.io](https://terraform.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform supported provide details: [https://www.terraform.io/docs/providers/](https://www.terraform.io/docs/providers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HashiCorp configuration language details: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub link for Terraform template for the first project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub link for Terraform template for the second project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Github link for Terraform template for the third project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Github link for Terraform template for the fourth project: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Terraform?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is an open-source, IaC software that was released in July 2014 by
    a company named **HashiCorp**. This is the same company that produced tools including
    Vagrant, Packer, and Vault. Terraform was released under the **Mozilla Public
    License** (**MPL**) version 2.0\. The source code for Terraform is available on
    GitHub at [https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform).
    Anyone can use this source code and contribute to Terraform's development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform allow users to define a datacenter infrastructure in a high-level
    configuration language called **HashiCorp Configuration Language** (**HCL**).
    HashiCorp also provide the Enterprise version of Terraform, which comes with added
    support. There are lot of features available with Terraform, which makes it a
    perfect high-level infrastructure orchestration tool. It has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It has very easy and minimal installation steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a declarative approach to write Terraform templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is available as both open-source and Enterprise offerings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has idempotency, which means the Terraform templates provide the same result
    every time you apply them in your environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a perfect match for almost all majorly available cloud platforms such
    as AWS, Azure, GCP, OpenStack, DigitalOcean, and so on. Refer to [https://www.terraform.io/docs/providers/](https://www.terraform.io/docs/providers/)
    for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**However, Terraform is not*:***'
  prefs: []
  type: TYPE_NORMAL
- en: A configuration management tool like Puppet, Chef, Ansible, or SaltStack. You
    can install some lightweight programs or software to ship some important configuration
    files inside your instances, but when it comes to the deployment and orchestration
    of more complex applications, you need to use configuration tools like those listed
    in the preceding section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A low-level tool like Boto for AWS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will focus on open-source Terraform. We will be demonstrating
    the complete Terraform setup on the CentOS 7.x machine that we used in the previous
    chapters. HashiCorp does not provide native packages for operating systems, so
    Terraform is distributed as a single binary, packaged inside a ZIP archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up Terraform on our CentOS server. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to download the Terraform binaries from the official website: [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html).
    In our case, we will be using Linux 64-bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/07cd1d07-a578-4c7d-bc18-36f0e93c6fff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unzip the extracted Terraform `.zip` file. You need to install the unzip package
    if it is not already present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will extract the Terraform binary to the `/usr/bin`, which is available
    in the PATH environment variable for your Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, check the installed version of Terraform. The latest version of Terraform
    software available at the time of writing is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe, setting up Terraform takes just a matter of minutes and
    it has very lightweight binaries. We are now all set to use the Terraform environment
    for AWS service provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform and AWS for automated provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, Terraform supports multiple providers such as AWS,
    Azure, and GCP for high level infrastructure orchestration. In this book, we will
    use only the AWS platform. As we saw at in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*, we can deploy compute services or any
    AWS service using two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Management Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS **Command Line Interface** (**CLI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment using AWS Management Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will focus on deploying the AWS compute service as we did previously.
    Deploying AWS instances using the AWS Management Console is fairly simple. Follow
    the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in into your AWS Management Console at [https://console.aws.amazon.com](https://console.aws.amazon.com)
    or use your IAM user account to log in . We created an IAM user account in [Chapter
    2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First Web Application* at
    `https://AWS-account-ID-or-alias.signin.aws.amazon.com/console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Services tab, followed by EC2 from the Compute section, and click
    on the Launch Instance button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, search for and select **Amazon Machine Image** (**AMI**).
    In this book, we are using `ami-cfe4b2b0`, which is Amazon Linux AMI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `t2.micro` type from the Choose an Instance Type step and click
    on the Next: Configure Instance Details button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Accept the default settings and click the Next: Add Storage button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Again, accept the default setting for storage and click on the Next: Add tags
    button followed by the Next: Configure Security Group button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, select the security group you created in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*, which in my case is `sg-01864b4c`, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84638492-0f99-42cc-9943-fea369e16fc2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Review and Launch button. Ignore any warnings that appear
    and press the Launch button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the key-pair, which in my case is `EffectiveDevOpsAWS`. Click the Launch
    Instances button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within a few minutes, your AWS instance will be up and running. Once the server
    is up, log in to the server from your local instance, which is CentOS in my case.
    Proceed with the following process to deploy the Hello World application manually
    and verify it locally or from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember to terminate the instance from the AWS Management Console once you
    are done with the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The termination process is also very straightforward. Select the created instance,
    click the Actions drop-down, followed by the Instance State option and then click
    Terminate, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d672c5a-97c1-4aa0-8b97-bc792a0d98b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Deployment using AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for creating an instance and deploying the Hello World web application
    using AWS CLI have already been demonstrated in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*. You need to make sure to install the `awscli`
    utility before proceeding further. Here is a quick overview for deploying the
    Hello World web application using AWS CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace `i-0eb05adae2bb760c6` with the AWS instance ID that you
    created in the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Remember to terminate the instance using `aws ec2 terminate-instances --instance-ids
    <AWS INSTANCE ID>` once you are done with the testing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Terraform repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now looked at two modes for creating AWS EC2 instances: using AWS Management
    Console and using AWS CLI. These can be automated using the AWS cloud native service
    called **CloudFormation template**, as we saw in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code. *This is only applicable for use with the
    AWS cloud. In this chapter, we will achieve the same results of provisioning AWS
    instances using Terraform. Refer to [https://www.terraform.io/intro/vs/cloudformation.html](https://www.terraform.io/intro/vs/cloudformation.html)
    to understand the differences between Terraform and CloudFormation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a dedicated repository in our GitHub account and start our journey
    with Terraform. Once you''ve logged in to GitHub, create a new repository for
    the Terraform templates by following the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, open [https://github.com/new](https://github.com/new).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the new repository `EffectiveDevOpsTerraform` as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b675f6aa-9701-4ca5-ae8d-de5df2f827e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the Initialize this repository with a README checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click the Create repository button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your repository is created, you will want to clone it to your system.
    To do this, you need to have Git installed. If you don''t have Git yet, search
    on Google for instructions on how to install it for your operating system. For
    CentOS, you just need to run `yum -y install git` as the Git package is part of
    the Linux distribution now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the repository is cloned, it''s time to start developing Terraform
    templates. Go into the `EffectiveDevOpsTerraform` repository and create a directory
    called `firstproject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First Terraform template for AWS instance provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is used to create, manage, and update infrastructure resources such
    as virtual machines, cloud instances, physical machines, containers, and much
    more. Almost any infrastructure type can be represented as a resource in Terraform.
    We are going to create a resource in the next step. Before that, we need to understand
    *Terraform providers,* which are responsible for understanding API interactions
    and exposing resources. A provider could be IaaS (such as AWS, GCP, and so on),
    PaaS (such as Heroku) or SaaS (such as DNSimple). The provider is the first section
    with which we have to start our Terraform templates. Before using Terraform to
    create an instance, we need to configure the AWS provider. This is the first piece
    of code that we are going to write in our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates are written in a special language called HCL. More details about
    HCL can be found at [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl).
    You can also write your templates in JSON, but we will be using HCL here. Terraform
    template files must have the extension `.tf`, which stands for **Terraform file**.
    Let''s create our first template, `ec2.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Visit [https://www.terraform.io/docs/providers/aws/index.html](https://www.terraform.io/docs/providers/aws/index.html)
    to explore more options about the AWS provider.
  prefs: []
  type: TYPE_NORMAL
- en: This type of declaration for providers in Terraform is called *configuring providers
    using static credentials. *It is not a secure way of declaring providers; there
    are other options in Terraform, such as environment variables, Terraform variable
    files, AWS native credential files (`~/.aws/credentials`), and so on, for storing
    providers with sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Do not push your AWS access key or your secret key on GitHub or any other public
    website. Doing so will allow hackers to hack your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, we need to install the plugin or reinitialize the plugins
    that are related to AWS for Terraform. We don't need to do much here; the configured
    file with the `provider` plugins will perform this task for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/447b2674-ac14-4a99-9492-8cd881d34792.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to configure our infrastructure. This is where we start developing
    the `ec2.ft` file with Terraform resources. Resources are components of your infrastructure.
    They can be as complex as a complete virtual server that has multiple other services,
    or as simple as a DNS record. Each resource belongs to a provider and the type
    of the resource is suffixed with the provider name. The configuration of a resource, which
    is called a `resource` block, takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we have to create an EC2 instance. The `aws_instance` resource
    in Terraform is responsible for this job. To create an instance, we need to set
    at least two parameters: `ami` and `instance_type`. These two parameters are required,
    whereas the others are optional. In order to get a list and a description of all
    the `aws_instance` resource parameters, check out the following website: [https://www.](https://www.terraform.io/docs/providers/aws/r/instance.html)[terraform.io/docs/providers/aws/r/instance.html](https://www.terraform.io/docs/providers/aws/r/instance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case we will create an instance with the same details with which we
    created and tested the instance using the AWS Management Console and the AWS CLI
    utility. We have `ami-cfe4b2b0` as AMI and `t2.micro` as our instance type. `EffectiveDevOpsAWS` is
    the key name that we created in the past and `sg-01864b4c` is our security group.
    We are also tagging the instance with the name `helloworld` for easy recognition.
    It''s worth mentioning that like any other scripting or automation language, you
    can put *comments* in the Terraform template with the `#` sign. Our complete file
    should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The created file should look like the file at the following website:  [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s validate the Terraform template first to ensure that the template doesn''t
    have any syntax errors. Terraform has a dedicated `terraform validate` utility, which
    checks the syntax of the Terraform template and provides us with the outputs if
    there are any syntax errors that need our attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As there are no outputs, this signifies that our Terraform template is free
    from syntax errors. It''s time to perform a dry run to see what this template
    will execute. This is just a smoke test to find out which changes or implementations
    will be performed by the template we have created. This step in Terraform is known
    as **plan**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we didn''t specify an `-out` parameter to save this plan, so Terraform
    can''t guarantee that these actions exactly will be performed if `terraform apply`
    is subsequently run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our plan stage indicates the same parameters that we want in the real execution
    while creating our instance. Again, don't get confused with the `<computed>` parameters,
    this just signifies that their value will be assigned when the resources are created
  prefs: []
  type: TYPE_NORMAL
- en: Let's now execute our plan for real and look at how a Terraform template can
    be used to create an AWS instance with the defined resource parameters. Terraform
    does this using the `terraform apply` utility and you can think of this stage
    as **apply**. Once you execute `terraform apply`, it will ask for your approval
    by default for confirmation. Type `yes` to start the resource creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you want to skip this interactive approval of the plan before applying
    it, use the `--auto-approve` option with the `terraform apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s confirm the newly created instance from our AWS console to ensure the
    `helloworld` instance has been created by the Terraform template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9a87db7-d720-4773-97d0-ce44f3339c76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Terraform didn''t simply create an instance and forget about it. In fact, Terraform
    actually saves everything it knows about the resources (in our case, the instance)
    to a special file, which is known as the **state file** in Terraform. In this
    file, Terraform stores the state of all the resources it has created. It is saved
    to the same directory where the Terraform template is present and with the `.tfstate`
    extension. The format of the state file is a simple JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The special part about Terraform is that you can read this JSON output in a
    human-readable format using the `terraform show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Up to here, we have created a Terraform template, validated it to ensure there
    are no syntax errors, performed a smoke test in the form of `terraform plan`,
    and then finally applied our Terraform template using `terraform apply` to create
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question remaining is *how can we delete or destroy all of the resources
    that are created by the Terraform template?* Do we need to find and delete resources
    one after another? The answer is No, this will also be taken care of by Terraform.
    By referring to the state file Terraform created during the **apply** phase, any
    resources that have been created by Terraform can be destroyed using the simple
    `terraform destroy` command from the `template` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Check your AWS console to ensure that the instance is in a terminated state.
  prefs: []
  type: TYPE_NORMAL
- en: Check the `terraform show` command now. It should be empty as none of your resources
    will be available.
  prefs: []
  type: TYPE_NORMAL
- en: A second Terraform template for deploying a Hello World application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go into the EffectiveDevOpsTerraform repository and create a directory called
    `second project`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created our EC2 instance with the Terraform template in the
    previous section, we are ready to extend the provisioning of our Hello World web
    application. We are going to use **Terraform Provisioner** to recreate the Hello
    World stack that we previously made using the `UserDatablock` field of CloudFormation
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application* and using Ansible roles in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating
    Your Infrastructure as Code*. If you recall, the `UserData` field looked roughly
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You will observe that there are three different types of operations for the
    deployment of our Hello World web application. First, we prepare the system to
    run our application. To do this, in our example, we are simply installing the
    Node.js package. Next, we copy the different resources that are needed to run
    the application. In our case, these resources include the JavaScript code and
    the upstart configuration. Finally, we start the service.
  prefs: []
  type: TYPE_NORMAL
- en: In order to deploy our Hello World web application, we need to introduce **Terraform
    Provisioner**. Provisioners in Terraform are configuration blocks available for
    several resources that allow you to perform actions after the resource has been
    created. It is mostly used for EC2 instances. Provisioners are primarily used
    as **post build steps** to install lightweight applications or configuration management
    agents such as **Puppet agents** or **chef-clients**. They can even be used to
    run configuration management tools such as** playbooks**, **Puppet modules**,
    **Chef cookbooks,** or **Salt formulas**. In the next section, we’ll look at a
    few examples of how to use Terraform with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `helloworldec2.tf` Terraform template to create the instance
    and then introduce the `provisioner` block with `remote-exec` to establish a connection
    with the newly created instance and download and deploy Hello World application
    on top of it. Our completed Terraform template should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The created file should look like the file at: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are creating the Terraform template inside a new directory, `secondproject`,
    we need to install the plugin or reinitialize the plugins that are related to
    AWS for Terraform. The configured file with the `provider` section will perform
    this task for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to validate the Terraform template file to ensure that it doesn''t
    have any syntax errors. Upon successful verification, run the `plan` command followed
    by the complete execution of the template using the `terraform apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74a89c11-cd79-4b49-bf46-d247fa6002c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our Terraform template has been executed successfully. We have provisioned
    our EC2 instance and deployed our Hello World web application. Let''s find the
    public IP of the instance by executing the `terraform show` command followed by
    the `curl` command to ensure the application has deployed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4fd6d3b-0d69-4e9a-8008-6d611ecf636e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s verify the application outputs from our browser as well, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cad4e6c-7026-47ad-a64f-ec111e1b909f.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now successfully deployed our Hello World web application using the
    power of Terraform. Once you've tested it, make sure to remove all of the created
    resources before you proceed to the next section. Execute the `terraform destroy` command,
    which will take care of removing all of the created resources by referring to
    the Terraform state file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Integrating AWS, Terraform, and Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we looked at how to provision a vanilla instance using
    Terraform. We then learnt how to provision a vanilla EC2 instance and execute
    **post builds** using the Terraform `remote-exec` provisioner. Now, we'll look
    at how Terraform can be integrated with Ansible to perform configuration management
    tasks. We will consider two different scenarios. In scenario one, we will provision
    an EC2 instance and run Ansible using **push** mode, which is the primary way
    that we can use Ansible to perform automation. In scenario two, we will provision
    an EC2 instance and run Ansible in **pull** mode using the `ansible pull` approach.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform with Ansible using a push-based approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go into the `EffectiveDevOpsTerraform` repository and create a directory called
    `thirdproject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will use the recommended practices to create Terraform
    templates. We will remove our AWS `access_key` and our AWS `secret_key` from our
    Terraform template first. We have AWS CLI installed on our system, which means
    that we have already configured this system to talk to our AWS account. If we
    don''t already have AWS CLI installed, we will use the `aws configure` to install
    it. This will create a `credentials` file inside the `/root/.aws` directory, which
    will contain our AWS access and secret keys. We will take the advantage of this
    file for our Terraform template and use the same credentials to build resources
    on our AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It's now time to start writing our `helloworldansible.tf` Terraform template.
    In this case, we will provision an EC2 instance and wait for the SSH services
    to appear by verifying the connection using the `remote-exec` provisioner. We
    will then use the `local-exec` provisioner to create the inventory with the new
    IP and run the Ansible playbooks on it using the primary push model by executing
    `ansible-playbook` locally from the system.
  prefs: []
  type: TYPE_NORMAL
- en: Inside provisioners (and only inside provisioners), we can use a special keyword,
    self, to access the attributes of a resource being provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also using another block in our code, which is called the `output` block.
    Outputs allow you to return data from the Terraform template after it was applied,
    using the Terraform `output` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The created file should look like the file at: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call the `helloworld` role in our `helloworld.yml` Ansible playbook
    to deploy the Hello World web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ansible configuration file `ansible.cfg` should look like as follows. It should
    be pointing to the `myinventory` file that is present in our `thirdproject` directory
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The complete project should look like the file at: [https://github.com/yogeshraheja/EffectiveDevOpsTerraform/tree/master/thirdproject](https://github.com/yogeshraheja/EffectiveDevOpsTerraform/tree/master/thirdproject).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have created a new directory, `thirdproject`, we again need to install
    the plugin or reinitialize the plugins that are related to AWS for Terraform.
    The configured file with the `provider` section will perform this task for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to validate the Terraform template file to ensure that it doesn''t
    have any syntax errors. Upon successful verification, execute the plan followed
    by the real run using `terraform apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6be50f8a-b01b-465e-af98-7a1e7dd6ef3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The outputs are clearly showing the logs for Ansible playbook and returning
    the `output` block with the public IP. Let''s use this public IP to verify the
    application deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4984bbc-16e4-45eb-947a-cb4cbf246809.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s verify the application outputs from the browser, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e2f9158-9806-45fd-bfef-2c74ddcd9c5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon successful deployment, execute `terraform destroy` to clean up the created
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Terraform with Ansible using the pull-based approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go into the `EffectiveDevOpsTerraform` repository and create a directory called
    `fourthproject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will follow the best practices for Terraform templates here and use
    the `credentials` file located in the `/root/.aws` directory, which contains our
    AWS access and secret keys. In this case, we will use Ansible in the inverted
    form: the *Ansible pull-based approach*. To use Ansible in this inverted approach,
    we have to make sure to install Ansible on the provisioned EC2 instance and run
    `ansible-pull` by referring to the Ansible code that is present at the source
    code repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case we will be using the same Ansible code that we created in [Chapter
    3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as* *Code*, which is present at [https://github.com/yogeshraheja/ansible](https://github.com/yogeshraheja/ansible).
    In our `helloworldansiblepull.tf` Terraform template, we will be using a `remote-exec` Terraform
    provisioner to establish a connection with the newly created instance. We will
    use the `inline` attribute to execute multiple commands remotely on the newly
    created EC2 installation. Our Terraform template should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The created file should look like the file at: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)[.](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf)
  prefs: []
  type: TYPE_NORMAL
- en: As we have again created a new directory, `fourthproject`, we need to install
    the plugin or reinitialize the plugins related to AWS for Terraform. The configured
    file with the `provider` section will perform this task for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to validate the Terraform template file to ensure that it doesn''t
    have any syntax errors. Upon successful verification, execute the plan followed
    by the real run using `terraform apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b1f84de9-d412-4c1d-96cf-c1c1a2c0d646.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, the Ansible code is running locally on the newly created EC2 instance.
    The `output` block configured in the Terraform template has also returned the
    expected value of the public IP. Let''s verify the outputs using the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b18915c9-d5e4-47bd-bb8a-c9024d7053a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, verify the outputs from the browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1610102-16ba-4ec7-a870-85205f19eb08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great—the application is deployed and verified. Once you are done, don''t forget
    to destroy the resource using the following command, to avoid unwanted AWS bills:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to efficiently manage infrastructure using Terraform
    templates. First, we learned about how Terraform can be used to provision an EC2
    instance in just a few lines. We then looked at how to create Terraform templates
    using Terraform provisioners to deploy lightweight applications. We then extended
    the Terraform templates with Ansible, which allowed us to orchestrate the different
    steps to deploy our web application. Finally, we looked at how Terraform can be
    integrated with Ansible in a pull-based approach, which usually makes more sense
    when managing sizable infrastructures, as we observed in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a good production environment ready to host any application. We
    have seen how to architect it using CloudFormation, Ansible, and Terraform. In
    Chapter 5, *Adding Continuous Integration and Continuous Deployment*, we will
    continue to use CloudFormation and Ansible, but in the context of software delivery,
    as we will learn how to put in place continuous integration testing and continuous
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Terraform and how it is different from other configuration management
    tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you install Terraform on a Linux-based operating system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you provision your first AWS instance using a Terraform template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write a Terraform template to integrate Ansible with a pull-based
    approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the following articles for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terraform reference** at [https://terraform.io](https://terraform.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terraform GitHub reference** at [https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
