<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Useful Recipes</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing a service in JIRA</li><li class="listitem" style="list-style-type: disc">Writing scheduled tasks in JIRA</li><li class="listitem" style="list-style-type: disc">Writing listeners in JIRA</li><li class="listitem" style="list-style-type: disc">Customizing e-mail content</li><li class="listitem" style="list-style-type: disc">Redirecting to different page in webwork actions</li><li class="listitem" style="list-style-type: disc">Adding custom behavior for user details</li><li class="listitem" style="list-style-type: disc">Deploying a servlet in JIRA</li><li class="listitem" style="list-style-type: disc">Adding shared parameters to Servlet Context</li><li class="listitem" style="list-style-type: disc">Writing a ServletContextListener interface</li><li class="listitem" style="list-style-type: disc">Using filters to intercept queries in JIRA</li><li class="listitem" style="list-style-type: disc">Adding and importing components in JIRA</li><li class="listitem" style="list-style-type: disc">Adding new module types to JIRA</li><li class="listitem" style="list-style-type: disc">Enabling access logs in JIRA</li><li class="listitem" style="list-style-type: disc">Enabling SQL logging in JIRA</li><li class="listitem" style="list-style-type: disc">Overriding JIRA's default components in plugins</li><li class="listitem" style="list-style-type: disc">Creating issues and comments from e-mail</li><li class="listitem" style="list-style-type: disc">Internationalization in webwork plugins</li><li class="listitem" style="list-style-type: disc">Sharing common libraries across v2 plugins</li><li class="listitem" style="list-style-type: disc">Operations via direct HTML links</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec138"/>Introduction</h1></div></div></div><p>So far, we have grouped the recipes under common themes as different chapters in this book. We have seen all the important themes but we still are left with some useful recipes and a handful of plugin modules that are not covered in the previous chapters.</p><p>In this chapter, we will look at some of those powerful plugin points and useful tricks in JIRA that are not covered in the earlier chapters. Not all of these recipes are related, but they are all useful in its own ways.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec139"/>Writing a service in JIRA</h1></div></div></div><a id="id1922" class="indexterm"/><p>A service that runs at regular intervals is a much wanted feature in any web application. It is more so if it is the one that can be managed with user-configured parameters and without having to reboot, and so on. JIRA offers a mechanism to add new services on to it that run at regular intervals after every start-up. It lets us do things related to JIRA and things independent of it. It lets us integrate with third-party applications. It lets us do wonders!</p><p>There are built-in services in JIRA. Export Service<a id="id1923" class="indexterm"/>, POP Service<a id="id1924" class="indexterm"/>, Mail Service<a id="id1925" class="indexterm"/>, and so on, to name a few. In this recipe, we are going to see how we can add a custom service on to JIRA.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec361"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using Atlassian Plugin SDK. Note that the <code class="literal">atlassian-plugin.xml</code> file can be removed as it is not used in a service.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec362"/>How to do it...</h2></div></div></div><a id="id1926" class="indexterm"/><a id="id1927" class="indexterm"/><p>As opposed to the other JIRA plug-in modules, services don't need a plugin descriptor. Instead, it uses a configuration XML. It is typically a JAR file with the related classes, files and a configuration XML. Following are the steps to write a simple service that just prints something onto the server console:</p><div><ol class="orderedlist arabic"><li class="listitem">Write the configuration XML. This is the most important part of a service. The following is a simple configuration XML:<div><pre class="programlisting">&lt;someservice id="jtricksserviceid"&gt;
  &lt;description&gt;My New Service&lt;/description&gt;
  &lt;properties&gt;&lt;/properties&gt;
&lt;/someservice&gt;</pre></div><p>This is a simple configuration XML that doesn't take any properties. It has a root element and a unique ID both of which can be custom names of your pick. The root element we have is <code class="literal">someservice</code> and the ID is <code class="literal">jtricksserviceid</code>. The description, as the name suggests, is just a short description of the service. <code class="literal">properties</code> tag holds the different properties you want to associate with the service. These properties will be entered by the user while configuring the service. We will see more on that later.</p></li><li class="listitem">Put the XML file under <code class="literal">src/main/resources/com/jtricks/services</code>.</li><li class="listitem">Create the service class. The class clan be put under any package structure as it will be referenced with the fully qualified name when it is added in JIRA. The class should extend <code class="literal">AbstractService</code>, which implements <code class="literal">JTricksService</code>:<div><pre class="programlisting">public class JTricksService extends AbstractService {
  ...
}</pre></div></li><li class="listitem"><a id="id1928" class="indexterm"/><a id="id1929" class="indexterm"/>Implement the mandatory methods in the service class. The following are the only ones that you need to implement:<div><pre class="programlisting">public void run() {
  System.out.println("Running the JTricks service!!");
}

public ObjectConfiguration getObjectConfiguration() throws ObjectConfigurationException {
  return getObjectConfiguration("MYNEWSERVICE", "com/jtricks/services/myjtricksservice.xml", null);
}</pre></div><p>Here <a id="id1930" class="indexterm"/>
<code class="literal">run</code> is the key method that is executed when the service runs at regular intervals.</p><p>The other key mandatory method is <code class="literal">getObjectConfiguration()</code><a id="id1931" class="indexterm"/>. We get the configurations from the XML we have written earlier (in <em>Step</em> <em>1</em>) in this method. All we need to do here is to call the parent class' <code class="literal">getObjectConfiguration</code> method by passing three arguments. The first argument is a unique<a id="id1932" class="indexterm"/> <strong>ID</strong> (which need not be same as the ID in the XML file). This ID is used as a key while saving the configurations internally. The second one is the<a id="id1933" class="indexterm"/> <strong>path</strong> to the configuration XML file we wrote earlier, and the third argument is a <a id="id1934" class="indexterm"/>
<strong>Map</strong> using which you can add user parameters on to the object configuration.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>The third argument is mostly null in case of services as these user parameters are not used anywhere. It is meaningful in other places of JIRA, such as portlets<a id="id1935" class="indexterm"/>, though not in the case of services.</p></div></div></li><li class="listitem">Compile these two files in to a JAR and drop it under <code class="literal">WEB-INF/lib</code>.</li><li class="listitem">Restart JIRA.</li></ol></div><a id="id1936" class="indexterm"/><a id="id1937" class="indexterm"/><p>Now the service is ready. We can go to <strong>Administration</strong> | <strong>System</strong> | <strong>Services</strong> and add the new service with the appropriate delay. While adding the service, we need to use the fully qualified name of the service class. More about registering a service can be found at: <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Services#Services-RegisteringaService">http://confluence.atlassian.com/display/JIRA/Services#Services-RegisteringaService</a> and is outside the scope of the book.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec363"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding</em> <em>configurable</em> <em>parameters</em> <em>to</em> <em>a</em> <em>service</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec140"/>Adding configurable parameters to a service</h1></div></div></div><a id="id1938" class="indexterm"/><a id="id1939" class="indexterm"/><a id="id1940" class="indexterm"/><p>For a simple service as the one we just wrote, there is only one parameter that can be configured. It is the delay at which the service runs! What if we need to add more parameters? Let's say we want to add the tutorial name in the service which can be changed later if needed.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec364"/>How to do it…</h2></div></div></div><p>Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Modify the service configuration XML to include the configurable properties:<div><pre class="programlisting">&lt;someservice id="jtricksserviceid"&gt;
  &lt;description&gt;My New Service&lt;/description&gt;
  &lt;properties&gt;
    &lt;property&gt;
      &lt;key&gt;Tutorial&lt;/key&gt;
      &lt;name&gt;The tutorial you like&lt;/name&gt;
      &lt;type&gt;string&lt;/type&gt;
    &lt;/property&gt;
  &lt;/properties&gt;
&lt;/someservice&gt;</pre></div><p>Here, we have added a string property with the key: <code class="literal">Tutorial</code>.</p></li><li class="listitem">Override the<a id="id1941" class="indexterm"/> <code class="literal">init()</code> method in the service class to retrieve the new property.<div><pre class="programlisting">@Override
public void init(PropertySet props) throws ObjectConfigurationException {
  super.init(props);
  if (hasProperty(TUTORIAL)) {
    tutorial = getProperty(TUTORIAL);
  } else {
    tutorial = "I don't like tutorials!";
  }
}</pre></div><p>Here, we retrieve the property <code class="literal">Tutorial</code> from the <code class="literal">PropertySet</code> in the <code class="literal">init</code> method.</p></li><li class="listitem">Use the property as appropriately in the<a id="id1942" class="indexterm"/> <code class="literal">run()</code> method. Here, let us just print the tutorial name:<div><pre class="programlisting">@Override
public void run() {
  System.out.println("Running the JTricks service!! Tutorial? " + tutorial);
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec365"/>How it works...</h2></div></div></div><a id="id1943" class="indexterm"/><a id="id1944" class="indexterm"/><a id="id1945" class="indexterm"/><p>The <code class="literal">init</code> method will be called whenever the service is configured or re-configured and the property values we entered on the JIRA Admin GUI are retrieved in this method for use in the <code class="literal">run()</code> method.</p><p>We can also optionally override the destroy method to do anything we want before the service is removed!</p><p>Once the service is deployed and added in the GUI, it prints <strong>Running</strong> <strong>the</strong> <strong>JTricks</strong> <strong>service</strong> <strong>Tutorial?</strong> <strong>I</strong> <strong>don't</strong> <strong>like</strong> <strong>tutorials!</strong> as the tutorial property is not configured yet.</p><div><img src="img/1803-11-01.jpg" alt="How it works..."/></div><p>Go to the <strong>Administration</strong> | <strong>System</strong> | <strong>Services</strong> area, edit the service to enter a value under <strong>The</strong> <strong>tutorial</strong> <strong>you</strong> <strong>like</strong> field. Assuming you entered <strong>JTricks</strong> <strong>Tutorials</strong>, you will see some output <a id="id1946" class="indexterm"/>
<a id="id1947" class="indexterm"/>
<a id="id1948" class="indexterm"/>as shown below:</p><div><img src="img/1803-11-02.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec366"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing</em> <em>a</em> <em>service</em> <em>in</em> <em>JIRA</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec141"/>Writing scheduled tasks in JIRA</h1></div></div></div><p>Have you ever thought of running scheduled tasks within JIRA? Why do we need scheduled tasks when we have the JIRA Services? We have seen how to write a service in the previous recipe. But in spite of all the advantages we discussed so far, these services have a disadvantage. It always starts when JIRA is restarted and runs at regular intervals after that. So, if you have a service that does some heavy memory-intensive operation and if you restart JIRA in the middle of the day, you will suddenly find your instance's performance compromised! If it is scheduled to run every 24 hours, you will find the same service running in the middle of the day from then on until the next restart.</p><a id="id1949" class="indexterm"/><p>Scheduled tasks in JIRA are a good way to make sure all such operations happen at quite times, midnight, for example. In this chapter, we will write a simple scheduled task and see how easy that can be!</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec367"/>How to do it...</h2></div></div></div><p>Let us write a simple scheduled task that prints a line in the console. Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Write a Java class that implements the <code class="literal">Quartz</code> <code class="literal">job</code> interface. JIRA internally uses Quartz for scheduling its tasks and so Quartz comes bundled within JIRA.<div><pre class="programlisting">public class JTricksScheduledJob implements Job{
  ...
}</pre></div></li><li class="listitem">Implement the <code class="literal">execute</code> method<a id="id1950" class="indexterm"/>. This is the method that gets executed every time the job runs. Whatever we do in this method can be as simple as a one liner or as complex as initiating a nuclear explosion! Our scheduled job just prints a line to the console and hence the Java class that we write is as simple as follows:<div><pre class="programlisting">public void execute(JobExecutionContext context) throws JobExecutionException {
  System.out.println("Running the job at "+(new Date()).toString());
}</pre></div></li><li class="listitem">Package the class in a JAR file and deploy it under <code class="literal">WEB-INF/lib</code> folder.</li><li class="listitem"><a id="id1951" class="indexterm"/><a id="id1952" class="indexterm"/>Modify the <code class="literal">scheduler-config.xml</code> file under <code class="literal">WEB-INF/classes</code> folder to let JIRA know of our new scheduled task. JIRA stores all the information about scheduled tasks in this file:<div><ol class="orderedlist loweralpha"><li class="listitem">Define a job under the <code class="literal">&lt;job&gt;</code> tag as shown:<div><pre class="programlisting">&lt;job name="JTricksJob" class="com.jtricks.JTricksScheduledJob" /&gt;</pre></div></li><li class="listitem">Add a trigger that runs the <code class="literal">JTricksJob</code>. This is where we define the <code class="literal">cron</code> expression to run the job at defined timings:<div><pre class="programlisting">&lt;trigger name="JTricksJobTrigger" job="JTricksJob" type="cron"&gt;
  &lt;expression&gt;0 0/2 * * * ?&lt;/expression&gt;&lt;!-- run every 2 minutes --&gt;
&lt;/trigger&gt;</pre></div></li><li class="listitem">The previous trigger schedules the job to run every two minutes. More details about writing a <code class="literal">cron</code> expression can be found at: <a class="ulink" href="http://www.quartz-scheduler.org/docs/tutorial/TutorialLesson06.html">http://www.quartz-scheduler.org/docs/tutorial/TutorialLesson06.html</a>.</li></ol></div></li><li class="listitem">Restart JIRA.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec368"/>How it works...</h2></div></div></div><a id="id1953" class="indexterm"/><a id="id1954" class="indexterm"/><p>Once JIRA is restarted, the new job can be seen at the scheduler details page under <strong>Administration</strong> | <strong>System</strong> | <strong>Scheduler</strong> <strong>Details</strong>. We can also verify the next fire time for the task on the same page, as shown in the following screenshot:</p><div><img src="img/1803-11-03.jpg" alt="How it works..."/></div><p>And when the job runs, you will see the following printed in the console!</p><div><img src="img/1803-11-04.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec142"/>Writing listeners in JIRA</h1></div></div></div><a id="id1955" class="indexterm"/><p><strong>Listeners</strong> are very powerful features in JIRA. JIRA has a mechanism of throwing events whenever something happens on an issue, such as when creating an issue, updating an issue, progressing on the workflows, or in similar events. Using listeners, we can capture these events and do special things based on our requirements.</p><a id="id1956" class="indexterm"/><a id="id1957" class="indexterm"/><p>There are two different ways using which listeners can be implemented in JIRA. The old way of doing it is to extend the <code class="literal">AbstractIssueEventListener</code> class<a id="id1958" class="indexterm"/> which in turn implements the <code class="literal">IssueEventListener</code> interface<a id="id1959" class="indexterm"/>. The <code class="literal">AbstractIssueEventListener</code> class captures the event, identifies its type, and delegates the event to the appropriate method where it is handled. To write a new listener, all we need to do is to extend the <code class="literal">AbstractIssueEventListener</code> class and override the methods of interest!</p><p>The new way of doing it is to use the <code class="literal">atlassian-event</code> library. Here, we register the listener in the plugin descriptor and implement the listener with the help of <code class="literal">@EventListener</code> annotation<a id="id1960" class="indexterm"/>.</p><p>Both ways are supported in JIRA now, though they have their own advantages and disadvantages. For example, it is possible to add properties for a listener in the old way. Adding properties is not supported in the new way but then the new way doesn't need any configuration as it is registered automatically. The new way, on the other hand, can be written as a fully fledged v2.0 plugin.</p><p>In this recipe, we will see how to write listeners in both the ways.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec369"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec370"/>How to do it...</h2></div></div></div><a id="id1961" class="indexterm"/><a id="id1962" class="indexterm"/><p>Writing a listener in the old way, by extending<a id="id1963" class="indexterm"/> <code class="literal">AbstractIssueEventListener</code>, is done as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a listener class that extends the <code class="literal">AbstractIssueEventListener</code> class.<div><pre class="programlisting">public class OldEventListener extends AbstractIssueEventListener {
  ...
}</pre></div></li><li class="listitem">Define the properties for the listener. This is an optional step, needed only if you need to define properties for the listener, which can then be used during execution. An example could be to enter the mail server details, if we have a listener that sends custom e-mail using a specific mail server when an event is fired.<div><ol class="orderedlist loweralpha"><li class="listitem">Override the <code class="literal">getAcceptedParams</code> method<a id="id1964" class="indexterm"/> to return a String array of properties to be defined.<div><pre class="programlisting">@Override
public String[] getAcceptedParams() {
  return new String[] { "prop 1" };
}</pre></div></li><li class="listitem">Here, we define a property named <code class="literal">prop1</code>.</li><li class="listitem">Override the <code class="literal">init</code> method<a id="id1965" class="indexterm"/> and retrieve the property value entered by the user.<div><pre class="programlisting">@Override
public void init(Map params) {
  prop1 = (String) params.get("prop 1");
}</pre></div></li><li class="listitem">The <code class="literal">init</code> method<a id="id1966" class="indexterm"/> is invoked whenever a listener is configured or re-configured. Here, we just retrieve the property value and assigns it to a class variable for future use.</li></ol></div></li><li class="listitem">Override the appropriate listener methods. For example, an issue created event can be captured by overriding <code class="literal">issueCreated</code> method<a id="id1967" class="indexterm"/> as shown next.<div><pre class="programlisting">@Override
public void issueCreated(IssueEvent event) {
  Issue issue = event.getIssue();
  System.out.println("Issue " + issue.getKey() + " has been created and property is:"+prop1);
}</pre></div><a id="id1968" class="indexterm"/><a id="id1969" class="indexterm"/><p>Here, we just retrieve the issue that triggered the event—the issue that is newly created in this case—and just prints the details along with the listener property. We can write even more complex methods in this method. It is also possible to retrieve other things from the event like the change log details if there are any changes involved, for example, in case of <code class="literal">issueUpdated</code> event<a id="id1970" class="indexterm"/> or when entering the comment using a transition.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Note that only a handful of events can be listened to like this and there are events like <code class="literal">project</code> <code class="literal">creation</code>, which do not throw an event at all! In such cases, you might want to extend the respective action and throw a custom event if needed. All the available events can be found at: <a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/event/issue/IssueEventListener.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/event/issue/IssueEventListener.html</a>.</p></div></div></li><li class="listitem">An important method that is worth mentioning here is the <code class="literal">customEvent</code> method<a id="id1971" class="indexterm"/>, which is invoked whenever a custom event is triggered. This happens for all the custom events configured by the user as mentioned in the next recipe. We can capture them as shown next:<div><pre class="programlisting">@Override
public void customEvent(IssueEvent event) {
  Long eventTypeId = event.getEventTypeId();
  Issue issue = event.getIssue();
  if (eventTypeId.equals(10033L)) {
    System.out.println("Custom Event thrown here for issue:" + issue.getKey()+" and property is:"+prop1);
  }
}</pre></div><p>Here, 10033 is the ID of the new event.</p></li><li class="listitem">Package the class into a JAR file and deploy it under the <code class="literal">jira-home/plugins/installed-plugins</code> folder.</li><li class="listitem">Restart JIRA</li><li class="listitem">Configure the listener by going to <strong>Administration</strong> | <strong>System</strong> | <strong>Listeners</strong>.<div><ol class="orderedlist loweralpha"><li class="listitem">Enter name and the fully qualified class name and click on <strong>Add</strong>.</li><li class="listitem">Edit the listener to add properties if there are any!</li></ol></div></li></ol></div><p>A listener created in the new way, that is, using <code class="literal">@EventListener</code> annotation<a id="id1972" class="indexterm"/> is written as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Register the listener in <code class="literal">atlassian-plugin.xml</code>.<div><pre class="programlisting">&lt;component key="eventListener" class="com.jtricks.NewEventListener"&gt;
  &lt;description&gt;Class that processes the new JIRA Event&lt;/description&gt;
&lt;/component&gt;</pre></div><p>Here the <code class="literal">class</code> attribute holds the fully qualified name of the listener class that we are going to write.</p></li><li class="listitem"><a id="id1973" class="indexterm"/><a id="id1974" class="indexterm"/>Import the <code class="literal">EventPublisher</code> component<a id="id1975" class="indexterm"/> using <code class="literal">component-import</code> plugin module.<div><pre class="programlisting">&lt;component-import key="eventPublisher" interface="com.atlassian.event.api.EventPublisher"/&gt;</pre></div></li><li class="listitem">Write the listener class:<div><ol class="orderedlist loweralpha"><li class="listitem">Inject the <code class="literal">EventPublisher</code> component into the class and use the <code class="literal">register</code> method to self register as shown next:<div><pre class="programlisting">public class NewEventListener {
  public NewEventListener(EventPublisher eventPublisher) {
    eventPublisher.register(this);
  }
}</pre></div></li><li class="listitem">Create methods to handle the events using <code class="literal">@EventListener</code> as shown in the following code:<div><pre class="programlisting">@EventListener
public void onIssueEvent(IssueEvent issueEvent) {  
System.out.println("Capturing event with 
ID:"+issueEvent.getEventTypeId()+" here");
  ...
}</pre></div><p>Note that the annotation can be used with any number of public methods in the class and all of them will be invoked when an event is fired in JIRA.</p></li><li class="listitem">Handle the events appropriately.<div><pre class="programlisting">@EventListener
public void onIssueEvent(IssueEvent issueEvent) {  System.out.println("Capturing event with ID:"+issueEvent.getEventTypeId()+" here");
  Long eventTypeId = issueEvent.getEventTypeId();
       Issue issue = issueEvent.getIssue();

  if (eventTypeId.equals(EventType.ISSUE_CREATED_ID)) {
    System.out.println("Issue "+issue.getKey()+" has been created");
        } else if (eventTypeId.equals(10033L)) {
          System.out.println("Custom Event thrown here for issue:"+issue.getKey());
        }
}</pre></div></li></ol></div><p>Here, as we can see, the event ID is checked and then handled as appropriate. First, we handled the issue created event and then the custom event.</p></li><li class="listitem"><a id="id1976" class="indexterm"/><a id="id1977" class="indexterm"/>Package the plugin and deploy it under the <code class="literal">jira-home/plugins/installed-plugins</code> folder.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec371"/>How it works...</h2></div></div></div><p>In both the cases, the listener works exactly the same way once configured. Note that the configuration is applicable only for the old way and when done the listener can be seen under <strong>Administration</strong> | <strong>System</strong> | <strong>Listeners</strong> as follows:</p><div><img src="img/1803-11-05.jpg" alt="How it works..."/></div><p>Note that there is the property <strong>prop</strong> <strong>1</strong> configured in the listener.</p><p>When the event is fired in JIRA, listeners capture them and the appropriate methods are invoked. The old one will print the issue key along with the property name. The new one works the same way, except that there is no property value.</p><div><img src="img/1803-11-06.jpg" alt="How it works..."/></div><a id="id1978" class="indexterm"/><a id="id1979" class="indexterm"/><p>It is possible to add properties to the listener even in the new way but that needs a separate configuration screen to capture and maintain the properties.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec372"/>There's more...</h2></div></div></div><p>It is possible that the plugin maybe disabled and re-enabled by the Administrators while the service is still running. The constructor is invoked when the listener is initially loaded at JIRA startup but we might want to handle the enabling or disabling of plugins separately as they are not captured in the constructor.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec63"/>Handling, enabling, and disabling of plugins</h3></div></div></div><p>Atlassian plugins<a id="id1980" class="indexterm"/>
<a id="id1981" class="indexterm"/>
<a id="id1982" class="indexterm"/> are implemented as Spring dynamic modules, and the <code class="literal">atlassian-plugin.xml</code> is transformed into a Spring XML bean configuration before it is actually loaded by the product. In case of listeners, Event Listener will become a Spring bean and hence we can apply the Spring interfaces—<code class="literal">InitializingBean</code> and <code class="literal">DisposableBean</code>—to capture the creation and destruction of the bean. In our case, the code is modified as follows:</p><div><pre class="programlisting">public class NewEventListenerModified implements InitializingBean, DisposableBean {
  private final EventPublisher eventPublisher;
  public NewEventListenerModified(EventPublisher eventPublisher) {
    this.eventPublisher = eventPublisher;
  }
  @EventListener
  public void onIssueEvent(IssueEvent issueEvent) {
    System.out.println("Capturing event with ID:" + issueEvent.getEventTypeId() + " here");
    Long eventTypeId = issueEvent.getEventTypeId();
    Issue issue = issueEvent.getIssue();
    if (eventTypeId.equals(EventType.ISSUE_CREATED_ID)) {
      System.out.println("Issue " + issue.getKey() + " has been created");
    } else if (eventTypeId.equals(10033L)) {
      System.out.println("Custom Event thrown here for issue:" + issue.getKey());
    }
  }
  public void afterPropertiesSet() throws Exception {
    eventPublisher.register(this);
  
  public void destroy() throws Exception {
    eventPublisher.unregister(this);
  }
}</pre></div><a id="id1983" class="indexterm"/><a id="id1984" class="indexterm"/><a id="id1985" class="indexterm"/><p>As you can see, the registering and un-registering happens in methods <code class="literal">afterPropertiesSet</code> and <code class="literal">destroy</code> events respectively. These methods are invoked during the creation/destruction of the bean and that effectively handles enabling/disabling of the plugin.</p><p>Don't forget to add the <code class="literal">spring-beans</code> JAR in the project build path in this case to avoid compilation issues! Alternatively, the following dependency can be added in the <code class="literal">pom.xml</code>:</p><div><pre class="programlisting">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;2.5.6&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec143"/>Customizing e-mail content</h1></div></div></div><a id="id1986" class="indexterm"/><a id="id1987" class="indexterm"/><p>We have already seen how JIRA throws various events when something happens and how we can handle these events to things ourselves. One such handling of these events includes sending e-mail notifications to users based on the notification schemes that are setup in JIRA. But what if we don't like the default content of JIRA notifications? What if we just want a different wording or maybe even amend the e-mail content?</p><p>In this recipe, we will see how we can customize the e-mail content that is sent as a notification when an event is thrown in JIRA.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec373"/>How to do it...</h2></div></div></div><a id="id1988" class="indexterm"/><a id="id1989" class="indexterm"/><p>JIRA has a set of e-mail templates written using velocity that is rendered when a notification is sent. For each event, a template is configured within JIRA and that template is used when the event is thrown. We can either create new templates and edit the events to use these new templates or modify the existing templates and leave the events as they are!</p><p>In both the cases, the steps are pretty much similar and are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the event for which the notification needs to be changed. The event could be an existing JIRA event such as <code class="literal">Issue</code> <code class="literal">Created</code> and <code class="literal">Issue</code> <code class="literal">Updated</code> or the custom event that the JIRA administrator has created.</li><li class="listitem">Find the template mapped to the event.<p>For each event, be it system-based or custom, there is a template associated to it. We cannot change the templates associated with a system event. For example, an <code class="literal">Issue</code> <code class="literal">Updated</code> event is associated with <code class="literal">Issue</code> <code class="literal">Updated</code> template. We can, however, choose any template for the custom events we have added.</p></li><li class="listitem">The e-mail template mapping for the chosen template can be found at <code class="literal">atlassian-jira/WEB-INF/classes/email-template-id-mappings.xml</code>. In this file, we can find many templates associated to each event. For example, <code class="literal">Issue</code> <code class="literal">Updated</code> event has the following entry:<div><pre class="programlisting">&lt;templatemappings&gt;
  ...
  &lt;templatemapping id="2"&gt;
    &lt;name&gt;Issue Updated&lt;/name&gt;
    &lt;template&gt;issueupdated.vm&lt;/template&gt;
    &lt;templatetype&gt;issueevent&lt;/templatetype&gt;
  &lt;/templatemapping&gt;
  ...
&lt;/templatemappings&gt;</pre></div></li><li class="listitem">Here, we can add new mappings if we are adding new templates as follows:<div><pre class="programlisting">&lt;templatemappings&gt;
  ...
  &lt;templatemapping id="20"&gt;
    &lt;name&gt;Demo Event&lt;/name&gt;
    &lt;template&gt;demoevent.vm&lt;/template&gt;
    &lt;templatetype&gt;issueevent&lt;/templatetype&gt;
  &lt;/templatemapping&gt;
  ...
&lt;/templatemappings&gt;</pre></div><p>Make sure the <code class="literal">id</code> we use here is unique in the file.</p></li><li class="listitem"><a id="id1990" class="indexterm"/><a id="id1991" class="indexterm"/>Identify the template to be edited if we are customizing an existing template or add a new template with the name mentioned in the <code class="literal">email-template-id-mappings.xml </code>file.<p>Email templates are stored under two different locations within JIRA one for HTML mails and another for Text mails. The templates for those can be found at <code class="literal">WEB-INF/classes/templates/email/html and WEB-INF/classes/templates/email/text respectively</code>. In addition to these, the subject of the e-mail can be found under <code class="literal">WEB-INF/classes/templates/email/subject</code>.</p><p>Note that the name of the template is the same in all the three places. In our example, the name of the template being edited is <code class="literal">issueupdated.vm</code> and hence if we need to only modify the subject, we just need to modify the <code class="literal">WEB-INF/classes/templates/email/subject/issueupdated.vm</code> file. Similarly, HTML or text content can be edited at <code class="literal">WEB-INF/classes/templates/email/html/issueupdated.vm</code> or <code class="literal">WEB-INF/classes/templates/email/text/issueupdated.vm</code> respectively.</p><p>If we are adding the template, <code class="literal">demoevent.vm</code> in our case, we need to create three templates one for each subject, HTML body and text body, all with the same name put under the respective folders.</p></li><li class="listitem">Restart JIRA after editing the templates appropriately.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec374"/>How it works...</h2></div></div></div><p>After, a template is newly added and JIRA is restarted, we can associate it with the custom events we have created. When the notification is sent, JIRA will use the updated or newly added templates to render the e-mail content.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec375"/>There's more...</h2></div></div></div><p>It is possible to add more information about an issue, such as custom fields in the notification e-mails by editing the relevant velocity templates.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec64"/>Advanced Customization—adding custom field information</h3></div></div></div><a id="id1992" class="indexterm"/><p>All the VM templates have got the <code class="literal">$issue</code> object in the velocity context along with other variables that are elaborated at: <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates">http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates</a>. It is fairly easy to use this to retrieve the contents on an issue while generating the e-mail content.</p><p>For example, <code class="literal">$issue.summary</code> will retrieve the issue summary and you can see it in the e-mail subject rendered using <code class="literal">WEB-INF/classes/templates/email/subject/issueupdated.vm</code>. Similarly, other information on the issue can be easily accessed. For example, custom field details can be accessed as follows:</p><div><pre class="programlisting">$issue.getCustomFieldValue($customFieldManager.getCustomFieldObject("customfield_10010"))</pre></div><a id="id1993" class="indexterm"/><p>Here, <code class="literal">10010</code> is the unique ID for the custom field.</p><p>You can see various other examples of formatting at: <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Adding+Custom+Fields+to+Email">http://confluence.atlassian.com/display/JIRADEV/Adding+Custom+Fields+to+Email</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec144"/>Redirecting to different page in webwork actions</h1></div></div></div><p>This recipe covers a very simple concept in JIRA web actions. While writing plugins, we often come across scenarios where we need to navigate to a new page such as a Dashboard or to browse a new project or view another issue after the action is executed. <code class="literal">JiraWebActionSupport</code> provides a simple method for doing this, which we will see in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec376"/>How to do it...</h2></div></div></div><a id="id1994" class="indexterm"/><a id="id1995" class="indexterm"/><p>What if we want to navigate to the Dashboard instead of rendering a success view when an action is executed? What if we can't directly link it from the JSP page or the velocity template because we want to perform something in the action class before we redirect?</p><p>All you need here is to return <code class="literal">getRedirect(URL)</code> in the action class's <code class="literal">doExecute</code> method<a id="id1996" class="indexterm"/> (or the appropriate method)! This method will redirect to the specified location when the action method is successfully finished. If there are any errors, it will go to the error page as the <code class="literal">getRedirect()</code> method returns <code class="literal">Action.ERROR</code> in that case.</p><p>You can force redirect to the URL even if there are errors by using <code class="literal">forceRedirect(URL)</code> instead of <code class="literal">getRedirect()</code> method<a id="id1997" class="indexterm"/>. It doesn't clear the return URL and will always go to the redirect URL.</p><p>For example, if we need to return to Dashboard when SUCCESS, we can do it as follows:</p><div><pre class="programlisting">@Override
protected String doExecute() throws Exception {
  System.out.println("Action invoked. Doing something important before redirecting to Dashboard!");
  return getRedirect("/secure/Dashboard.jspa");
}</pre></div><a id="id1998" class="indexterm"/><a id="id1999" class="indexterm"/><p>Replacing <code class="literal">getRedirect</code> with <code class="literal">forceRedirect</code> will take the user to Dashboard irrespective of the result.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec145"/>Adding custom behavior for user details</h1></div></div></div><a id="id2000" class="indexterm"/><a id="id2001" class="indexterm"/><a id="id2002" class="indexterm"/><p>In JIRA, you can see that the user details are formatted with the full name and a link to the users' profile within the application. For example, when the issues are displayed in the issue navigator, the assignee and reporter are displayed as follows:</p><div><img src="img/1803-11-07.jpg" alt="Adding custom behavior for user details"/></div><p>But what if we want to change how the user details are displayed? Say, if we want to display the user avatar alongside? Or, if we want to display their usernames with an external link, like a link to their Twitter profile?</p><p>JIRA provides the User Format plugin module<a id="id2003" class="indexterm"/> to serve this purpose. Using this module, we can define different formats in which the user will be displayed and use them within the existing JIRA displays or within out-custom plugins.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec377"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using the Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec378"/>How to do it...</h2></div></div></div><a id="id2004" class="indexterm"/><a id="id2005" class="indexterm"/><a id="id2006" class="indexterm"/><p>In this recipe, let us try to create a new user profile that will display the username (instead of full name) with a link to their twitter profile to add some spice! The following are the steps to do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the user-profile module in to the <code class="literal">atlassian-plugin.xml</code>:<div><pre class="programlisting">&lt;user-format key="twitter-format" name="Twitter User Format" class="com.jtricks.TwitterUserFormat" system="true"&gt;
  &lt;description&gt;User name linking to twitter&lt;/description&gt;   &lt;type&gt;twitterLink&lt;/type&gt;
  &lt;resource type="velocity" name="view" location="templates/twitterLink.vm"/&gt;
&lt;/user-format&gt;</pre></div><p>As with other plugin modules, user profile module also has a unique <strong>key</strong>. It then points to the <strong>class</strong> that will be used by the user formatter, <code class="literal">TwitterUserFormat</code> in this case.</p><p>The <code class="literal">type</code> element holds the unique profile type name that will be used while formatting the user. Following are the types existing in JIRA by default as on 4.4 version: <code class="literal">profileLink</code>, <code class="literal">fullName</code>, <code class="literal">profileLinkSearcher</code>, <code class="literal">profileLinkExternal</code>, <code class="literal">profileLinkActionHeader</code>, <code class="literal">fullProfile</code>.</p><p>The <code class="literal">resource</code> element points to the velocity template to be used for rendering the view, <code class="literal">twitterLink.vm</code> in this case.</p></li><li class="listitem">Create the formatter class in the previous step. The class should implement the <code class="literal">UserFormat</code> interface.<div><pre class="programlisting">public class TwitterUserFormat implements UserFormat {
  private final UserFormatModuleDescriptor moduleDescriptor;

  public TwitterUserFormat(UserFormatModuleDescriptor moduleDescriptor){
    this.moduleDescriptor = moduleDescriptor;
  }
}</pre></div><p>Here, we inject <code class="literal">UserFormatModuleDescriptor</code> into the class as it will be used in rendering the velocity template, as shown in the next step.</p></li><li class="listitem">Implement the required methods. We will have to implement the two overridden <strong>format</strong> methods.<p>The first method takes a <code class="literal">username</code> and <code class="literal">id</code> where the <code class="literal">username</code> is the name of the user, which can also be <em>null</em>, and <code class="literal">id</code> is an extra argument that can be used to pass an extra context to the renderer. Ideally, an implementation might include this ID in the rendered output such that it can be used for test assertions. An example of how the ID is used can be found in displaying the assignee in the column view (<code class="literal">/WEB-INF/classes/templates/jira/issue/field/assignee-columnview.vm</code>) where the ID is assignee.</p><p>We are not going to use ID in the example, but the method is implemented as follows:</p><div><pre class="programlisting">public String format(String username, String id) {
  final Map&lt;String, Object&gt; params = getInitialParams(username, id);
  return moduleDescriptor.getHtml(VIEW_TEMPLATE, params);
}</pre></div><p>where the <code class="literal">getInitialParams</code> just populates the <code class="literal">params</code> map with the username as shown:</p><div><pre class="programlisting">private Map&lt;String, Object&gt; getInitialParams(final String username, final String id) {
  final Map&lt;String, Object&gt; params = MapBuilder.&lt;String, Object&gt; newBuilder().add("username", username).toMutableMap();
  return params;
}</pre></div><a id="id2007" class="indexterm"/><a id="id2008" class="indexterm"/><a id="id2009" class="indexterm"/><p>We can populate the map with as many things as needed if we want to render the user details in some other way!</p><p>The second method takes <code class="literal">username</code>, <code class="literal">id</code>, and a <code class="literal">map</code> pre-populated with extra values to add more to the context! The method is implemented as follows:</p><div><pre class="programlisting">public String format(String username, String id, Map&lt;String, Object&gt; params) {  
  final Map&lt;String, Object&gt; velocityParams = 
  getInitialParams(username, id);  
  velocityParams.putAll(params);
  return moduleDescriptor.getHtml(VIEW_TEMPLATE, velocityParams);
}</pre></div><p>The only difference is that the extra context is also populated into <code class="literal">params</code> map.</p><p>In both cases, the <code class="literal">moduleDescriptor</code> renders the velocity template, defined by the name <code class="literal">VIEW_TEMPLATE</code> or "view".</p></li><li class="listitem">Write the velocity template that uses the context populated in <code class="literal">params</code> map in the previous step to display the user information:<div><pre class="programlisting">#if ($username)
  #set ($quote = '"')
  #set($author = "&lt;a id=${quote}${textutils.htmlEncode($username)}${quote} href=${quote}http://twitter.com/#!/${username}${quote}&gt;$textutils.htmlEncode($username)&lt;/a&gt;")
#else
    #set($author = $i18n.getText('common.words.anonymous'))
#end
${author}</pre></div><p>In our example, we just display the username as it is with a link <code class="literal">http://twitter.com/#!/${username}</code> that will point to the twitter account with that username. Note that the <code class="literal">quote</code> variable is assigned a double quotation mark inside a single quotation mark. Single quotation here is the velocity syntax and double quotation is the value. It is used to construct the URL where encoded name, href value, and so on are placed between quotes!</p><p>Don't forget to handle the scenario when the user is null. In our case, we just display the name as Anonymous when the user is null.</p></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec379"/>How it works...</h2></div></div></div><a id="id2010" class="indexterm"/><a id="id2011" class="indexterm"/><a id="id2012" class="indexterm"/><p>Once the plugin is deployed, the new user profile, <code class="literal">twitterLink</code> in this case, can be used in various places in JIRA where appropriate. For example, the <code class="literal">assignee-columnview.vm</code> can be modified to include <code class="literal">twitterLink</code> profile instead of the default <code class="literal">profileLink</code> as follows:</p><div><pre class="programlisting">#if($assigneeUsername)
    #if ($displayParams &amp;&amp; $displayParams.nolink)
        $userformat.formatUser($assigneeUsername, 'fullName', 'assignee')
    #else
        &lt;span class="tinylink"&gt;$userformat.formatUser($assigneeUsername, 'twitterLink', 'assignee')&lt;/span&gt;
    #end
#else
    &lt;em&gt;$i18n.getText('common.concepts.unassigned')&lt;/em&gt;
#end</pre></div><p>When you do that, the assignee column in issue navigator will appear as follows with a link to the user's Twitter account:</p><div><img src="img/1803-11-08.jpg" alt="How it works..."/></div><a id="id2013" class="indexterm"/><a id="id2014" class="indexterm"/><a id="id2015" class="indexterm"/><p>We can also use the new profile in the plugins to render user details just by invoking the <code class="literal">formatUser</code> as follows:</p><div><pre class="programlisting">$userformat.formatUser($username, 'twitterLink', 'some_id')</pre></div><p>Or:</p><div><pre class="programlisting">$userformat.formatUser($username, 'twitterLink', 'some_id', $someMapWithExtraContext)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec146"/>Deploying a servlet in JIRA</h1></div></div></div><a id="id2016" class="indexterm"/><a id="id2017" class="indexterm"/><p>We all know how useful a servlet is! JIRA provides an easy way to deploy a JAVA servlet with the help of the Servlet Plugin module. In this recipe, we will see how to write a simple servlet and access it in JIRA.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec380"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using the Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec381"/>How to do it...</h2></div></div></div><p>The following are the steps to deploy a JAVA servlet in JIRA:</p><div><ol class="orderedlist arabic"><li class="listitem">Include the servlet plugin module in the <code class="literal">atlassian-plugin.xml</code>. The Servlet plugin module<a id="id2018" class="indexterm"/> allows the following set of attributes:<div><ol class="orderedlist loweralpha"><li class="listitem"><code class="literal">class</code>: It is the servlet Java class and it must be a subclass of <code class="literal">javax.servlet.http.HttpServlet</code>. This attribute is mandatory.</li><li class="listitem"><code class="literal">disabled</code>: It indicates whether the plugin module should be disabled or enabled by default. By default, the module is enabled.</li><li class="listitem"><code class="literal">i18n-name-key</code>: The localization key for the human-readable name of the plugin module.</li><li class="listitem"><code class="literal">key</code>: It represents the unique key for the plugin module. This attribute is mandatory.</li><li class="listitem"><code class="literal">name</code>: It is the human-readable name of the servlet.</li><li class="listitem"><code class="literal">system</code>: It indicates whether this plugin module is a system plugin module or not. Only available for non-OSGi plugins.</li></ol></div><a id="id2019" class="indexterm"/><a id="id2020" class="indexterm"/><p>The following are the child elements supported:</p><div><ol class="orderedlist loweralpha"><li class="listitem"><code class="literal">description</code>: The description of the plugin module.</li><li class="listitem"><code class="literal">init-param</code>: Initialization parameters for the servlet, specified using <code class="literal">param-name</code> and <code class="literal">param-value</code> subelements, just as in <code class="literal">web.xml</code>. This element and its child elements may be repeated.</li><li class="listitem"><code class="literal">resource</code>: Resources for this plugin module. This element may be repeated.</li><li class="listitem"><code class="literal">url-pattern</code>: The pattern of the URL to match. This element is mandatory and may be repeated.</li></ol></div><p>In our example, let us use only the mandatory fields and some example init-<code class="literal">params</code> as shown:</p><div><pre class="programlisting">&lt;servlet name="Test Servlet" key="jtricksServlet" class="com.jtricks.JTricksServlet"&gt;
    &lt;description&gt;Test Servlet&lt;/description&gt;
    &lt;url-pattern&gt;/myWebsite&lt;/url-pattern&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;siteName&lt;/param-name&gt;
        &lt;param-value&gt;Atlassian&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;siteAddress&lt;/param-name&gt;
        &lt;param-value&gt;http://www.atlassian.com/&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;</pre></div><p>Here <code class="literal">JTricksServlet</code> is the servlet class where as <code class="literal">/myWebsite</code> is the URL pattern. We are also passing a couple of <code class="literal">init</code> params: <code class="literal">siteName</code> and <code class="literal">siteAddress</code>.</p></li><li class="listitem">Create a <code class="literal">servlet</code> class. The class must extend <code class="literal">javax.servlet.http.HttpServlet</code>.<div><pre class="programlisting">public class JTricksServlet extends HttpServlet {
  ...
}</pre></div></li><li class="listitem"><a id="id2021" class="indexterm"/><a id="id2022" class="indexterm"/>Implement the necessary methods:<div><ol class="orderedlist loweralpha"><li class="listitem">We can retrieve the <code class="literal">init</code> params in the <code class="literal">init</code> method as shown next:<div><pre class="programlisting">@Override
public void init(ServletConfig config) throws ServletException {
  super.init(config);
  authenticationContext = ComponentManager.getInstance().getJiraAuthenticationContext();  siteName = config.getInitParameter("siteName");
  siteAddress = config.getInitParameter("siteAddress");
}</pre></div><p>The <code class="literal">init()</code> method is invoked every time the servlet is initialized and this happens when the servlet is first accessed. <code class="literal">init()</code> method is also invoked when the servlet is first accessed after the plugin module is disabled and enabled back.</p><p>As you can see, the <code class="literal">init</code> params we defined in the servlet plugin module can be accessed here from the <code class="literal">ServletConfig</code>. Here, we also initialize the <code class="literal">JiraAuthenticationContext</code> so that we can use it to retrieve the logged-in user details in the servlet. Similarly, we can initialize any JIRA components here.</p></li><li class="listitem">Implement the <code class="literal">doGet()</code> and/or <code class="literal">doPost()</code> methods to do what needs to be implemented. For the example, we will just use the <code class="literal">init</code> params to create a simple HTML page and print a line to the console.<div><pre class="programlisting">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
  resp.setContentType("text/html");
  PrintWriter out = resp.getWriter();

  User user = authenticationContext.getUser();  out.println("Welcome " + (user != null ? user.getFullName() : "Anonymous"));
  out.println("&lt;br&gt;Invoking the servlet...");
  out.println("&lt;br&gt;My Website : &lt;a href=\"" + siteAddress + "\"&gt;" + siteName + "&lt;/a&gt;");

  doSomething();

  out.println("&lt;br&gt;Done!");
}

private void doSomething() {
  System.out.println("Invoked servlet at " + (new Date()));
}</pre></div><p>The <code class="literal">authenticationContext</code> retrieves the current username as mentioned earlier. From JIRA 4.3, <code class="literal">getLoggedInUser()</code> method is used to retrieve the current user and <code class="literal">getDisplayName()</code> gets the user's full name.</p></li></ol></div></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec382"/>How it works...</h2></div></div></div><a id="id2023" class="indexterm"/><a id="id2024" class="indexterm"/><p>Once deployed, the servlet will be accessible at the URL: <code class="literal">http://yourserver/jira/plugins/servlet/${urlPattern}</code>. In our case, the URL is <code class="literal">http://yourserver/jira/plugins/servlet/myWebsite</code>.</p><p>When the servlet is accessed at <code class="literal">/plugins/servlet/myWebsite</code>, the output is as shown in the following screenshot:</p><div><img src="img/1803-11-09.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec147"/>Adding shared parameters to Servlet Context</h1></div></div></div><p>In the previous recipe, we saw how to deploy a servlet and how to make use of the init params. What if we have a set of servlets or servlet filters or context listeners that make use of the same parameters? Do we really need to initialize them in all the plugin modules?</p><p>In this recipe, we will see how we can use the Servlet Context Parameter plugin module to share parameters across servlets, filters, and listeners.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec383"/>Getting ready</h2></div></div></div><a id="id2025" class="indexterm"/><a id="id2026" class="indexterm"/><a id="id2027" class="indexterm"/><p>Create a skeleton plugin using the Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec384"/>How to do it...</h2></div></div></div><p>All we need to do is to define the shared parameters to add a <code class="literal">servlet-context-param</code> module for each shared parameter in the <code class="literal">atlassian-plugin.xml</code>.</p><p>For example, a parameter with key <code class="literal">sharedText</code> can be defined as follows:</p><div><pre class="programlisting">&lt;servlet-context-param key="jtricksContext"&gt;
  &lt;description&gt;Shares this param!&lt;/description&gt;
  &lt;param-name&gt;sharedText&lt;/param-name&gt;
  &lt;param-value&gt;This is a shared Text&lt;/param-value&gt;
&lt;/servlet-context-param&gt; </pre></div><p>Make sure the module has a unique key. Here, the parameter name is <code class="literal">sharedText</code> and it has a value <strong>This</strong> <strong>is</strong> <strong>a</strong> <strong>shared</strong> <strong>Text</strong>. Once the plugin is packaged and deployed, the parameter <strong>sharedText</strong> is available across servlets, filters, and listeners.</p><p>In a servlet, we can access the parameter in the <code class="literal">init</code> method as follows:</p><div><pre class="programlisting">@Override
public void init(ServletConfig config) throws ServletException {
  super.init(config);
  String sharedText = config.getServletContext().getInitParameter("sharedText");
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec385"/>How it works...</h2></div></div></div><p>Once the shared text is retrieved, we can use it anywhere like while constructing the HTML</p><div><pre class="programlisting">out.println("&lt;br&gt;Shared Text:"+sharedText);</pre></div><a id="id2028" class="indexterm"/><a id="id2029" class="indexterm"/><a id="id2030" class="indexterm"/><p>The servlet will be now printing that as well, as shown in the following screenshot:</p><div><img src="img/1803-11-10.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec148"/>Writing a Servlet Context Listener</h1></div></div></div><a id="id2031" class="indexterm"/><a id="id2032" class="indexterm"/><p>We have seen how to write servlets. How about writing a context listener for the same? This will come in handy if you want to integrate with frameworks that use context listeners for initialization.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec386"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using the Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec387"/>How to do it...</h2></div></div></div><p>Following are the steps to write a simple context listener:</p><div><ol class="orderedlist arabic"><li class="listitem">Include the <code class="literal">servlet-context-listener</code> module in the <code class="literal">atlassian-plugin.xml</code>.<div><pre class="programlisting">&lt;servlet-context-listener name="Test Servlet Listener" key="jtricksServletListener" class="com.jtricks.JTricksServletListener"&gt;
  &lt;description&gt;Listener for Test Servlet&lt;/description&gt;
&lt;/servlet-context-listener&gt;</pre></div><p>Here, we have a unique module key and a class that is the servlet context listener's Java class.</p></li><li class="listitem">Write the servlet context listener's class. The class must <code class="literal">javax.servlet.ServletContextListener</code>:<div><pre class="programlisting">public class JTricksServletListener implements ServletContextListener{	  ...
}</pre></div></li><li class="listitem">Implement the context listener methods as appropriate. For example, we just print some statements to the console:<div><pre class="programlisting">public void contextDestroyed(ServletContextEvent event) {  System.out.println("Test Servlet Context is destroyed!");
}

public void contextInitialized(ServletContextEvent event) {  System.out.println("Test Servlet Context is initialized!");
}</pre></div><p>The details of the context that is initialized or destroyed can be found from the <code class="literal">ServletContextEvent</code> object.</p></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec388"/>How it works...</h2></div></div></div><a id="id2033" class="indexterm"/><a id="id2034" class="indexterm"/><p>The <code class="literal">contextInitialized</code> method<a id="id2035" class="indexterm"/> is not invoked at application startup. Instead, it is invoked the first time a servlet or filter in the plugin is accessed after each time it is enabled.</p><div><img src="img/1803-11-11.jpg" alt="How it works..."/></div><p>Similarly the <code class="literal">contextDestroyed</code> method<a id="id2036" class="indexterm"/> is invoked every time the plugin module containing a servlet or filter is disabled.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec149"/>Using filters to intercept queries in JIRA</h1></div></div></div><p>Servlet filters provide a powerful mechanism to intercept queries and do wise things such as profiling, monitoring, content generation, and so on. It works exactly like any normal Java servlet filter and JIRA provides the <strong>Servlet</strong> <strong>Filter</strong> <strong>Plugin</strong> <strong>Module</strong><a id="id2037" class="indexterm"/> to add them using plugins. In this recipe, we will learn about how to use filter to intercept certain queries to JIRA and how we can utilize them!</p><a id="id2038" class="indexterm"/><a id="id2039" class="indexterm"/><p>As with other servlet plugin modules, a <code class="literal">servlet-filter</code> <code class="literal">plugin</code> module also has a unique <code class="literal">key</code> and a <code class="literal">class</code> associated with it. The <code class="literal">name</code> attribute holds the human-readable name of the filter and <code class="literal">weight</code> indicates the order in which the filter will be placed in the filter chain. The higher the weight, the lower the filter's position.</p><p>There is another important attribute <code class="literal">location</code> that denotes the position of the filter in the application's filter chain. Following are the four possible values for the location:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">after-encoding</code>: Very top of the filter chain in the application, but after any filters which ensure the integrity of the request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">before-login</code>: Before the filter that logs in the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">before-decoration</code>: Before the filter which does Sitemesh decoration of the response.</li><li class="listitem" style="list-style-type: disc"><code class="literal">before-dispatch</code>: At the end of the filter chain, before any servlet or filter which handles the request by default.</li></ul></div><p>The <code class="literal">weight</code> attribute is used in conjunction with <code class="literal">location</code>. If two filters have the same location, then they are ordered based on the weight attribute.</p><p><code class="literal">init-param</code> as usual takes the initialisation parameters for the filter.</p><p><code class="literal">url-pattern</code> defines the pattern of the URL to match. This element can be repeated and the filter will be invoked for all the URLs matching any of the patterns specified. Unlike a servlet URL, the <code class="literal">url-pattern</code> here matches <code class="literal">${baseUrl}/${url-pattern}</code>. The pattern can use wild chars <code class="literal">*</code> or <code class="literal">?</code>, the former matching zero or many characters, including directory slashes and the latter matching zero or one character.</p><p><code class="literal">dispatcher</code> is another element that determines when the filter is invoked. You can include multiple dispatcher elements with values <code class="literal">REQUEST</code>, <code class="literal">INCLUDE</code>, <code class="literal">FORWARD</code>, or <code class="literal">ERROR</code>. If not present, the filter will be invoked in all cases.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec389"/>Getting ready</h2></div></div></div><p>Create an skeleton plugin using the Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec390"/>How to do it...</h2></div></div></div><p>Let us try to intercept all the issue views, which has the URLs of the format <code class="literal">${baseUrl}/browse/*-*</code> and log them. The following are the step-by-step procedure to write a filter and implement the given logic.</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <strong>Servlet</strong> <strong>Filter</strong> plugin module into <code class="literal">atlassian-plugin.xml</code>.<div><pre class="programlisting">&lt;servlet-filter name="Browse Issue Filter" key="jtricksServletFilter" class="com.jtricks.JTricksServletFilter" location="before-dispatch" weight="200"&gt;
        &lt;description&gt;Filter for Browse Issue&lt;/description&gt;
        &lt;url-pattern&gt;/browse/*-*&lt;/url-pattern&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;filterName&lt;/param-name&gt;
            &lt;param-value&gt;JTricks Filter&lt;/param-value&gt;
        &lt;/init-param&gt;
&lt;/servlet-filter&gt;</pre></div><p>Here <code class="literal">JTricksServletFilter</code> is the filter class and we have added the filter before dispatch. In our example, <code class="literal">url-pattern</code> will be <code class="literal">/browse/*-*</code> as the URL to browse an issue is of the form <code class="literal">${baseUrl}/browse/*-*.</code> We can use different URL patterns as required in our context.</p></li><li class="listitem"><a id="id2040" class="indexterm"/><a id="id2041" class="indexterm"/>Create the <code class="literal">Filter</code> class. The class should implement <code class="literal">javax.servlet.Filter</code>:<div><pre class="programlisting">public class JTricksServletFilter implements Filter {
  ...
}</pre></div></li><li class="listitem">Implement the appropriate Filter methods:<div><pre class="programlisting">public void destroy() {
  System.out.println("Filter destroyed!");
}

public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request = (HttpServletRequest) req;

  // Get the IP address of client machine.
  String ipAddress = request.getRemoteAddr();

  // Log the user details, IP address , current timestamp and URL.  
System.out.println("Intercepted in filter, request by user:" + authenticationContext.getUser().getFullName()  + " from IP " + ipAddress + " at " + new Date().toString() + ". Accessed URL:"+request.getRequestURI());

  chain.doFilter(req, res);
}

public void init(FilterConfig config) throws ServletException {  System.out.println("Initiating the filter:"+config.getInitParameter("filterName"));
  authenticationContext = ComponentManager.getInstance().getJiraAuthenticationContext();
}</pre></div><p>Here, the <code class="literal">init</code> method is invoked when the filter is initialized, that is, the first time it is accessed after the plugin is enabled. In this method, we can retrieve the <code class="literal">init-param</code> instances defined or parameters defined using Servlet Context Parameter plugin module. In the previous code snippet, use <code class="literal">getLoggedInUser()</code> to retrieve logged user from JIRA 4.3+ and use <code class="literal">getDisplayName()</code> to retrieve the user's full name in that case.</p><p>The <code class="literal">destroy</code> method is invoked whenever a filter is destroyed.</p><p>The <code class="literal">doFilter</code> is the method which is invoked every time the URL matches the <code class="literal">url-pattern</code>. Here, we are just printing the IP address and user details requesting the <strong>View</strong> <strong>Issue</strong> page and logs the time but we can do many things like logging, using the data for profiling or monitoring, so on and so forth.</p></li><li class="listitem"><a id="id2042" class="indexterm"/><a id="id2043" class="indexterm"/>Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec391"/>How it works...</h2></div></div></div><p>Whenever the URL in JIRA matches the <code class="literal">url-pattern</code>, the respective filter is invoked. This can be of huge help when you want to do specific things when a particular operation in JIRA is performed, or if you want to monitor who is doing what and when, or something else based on a specific URL.</p><div><img src="img/1803-11-12.jpg" alt="How it works..."/></div><p>With our code in the example, the details are printed, as shown in the previous screenshot, whenever an issue is viewed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec150"/>Adding and importing components in JIRA</h1></div></div></div><p>JIRA has a component system that has so many Service classes and Manager classes that are registered in PicoContainer<a id="id2044" class="indexterm"/> and are available for use by the core classes and plugins alike. It makes sense sometimes to add custom components to that component system that can then be used with the other modules in the same plugin or shared by other plugins.</p><p>In this recipe, we will see how we can add a new component in JIRA and how we can consume that from within the plugin and from a separate plugin.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec392"/>Getting ready</h2></div></div></div><p>Create a Skeleton plugin using Atlassian Plugin SDK. For the example, we will use the <code class="literal">RedirectAction</code> webwork module<a id="id2045" class="indexterm"/> used in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec393"/>How to do it...</h2></div></div></div><a id="id2046" class="indexterm"/><a id="id2047" class="indexterm"/><a id="id2048" class="indexterm"/><a id="id2049" class="indexterm"/><p>First, let us see how we can define a component and use them in the different modules within the same plugin. In our example, we will define a sample component and use the methods exposed by it in the <code class="literal">RedirectAction</code>. Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an interface with the required method definitions. The component will expose these methods when used elsewhere:<div><pre class="programlisting">package com.jtricks.provider;

public interface MyComponent {
  public void doSomething();
}</pre></div></li><li class="listitem">Create the implementation class and implement the methods.<div><pre class="programlisting">public class MyComponentImpl implements MyComponent{  
  private final JiraAuthenticationContext authenticationContext;

  public MyComponentImpl(JiraAuthenticationContext authenticationContext) {
    this.authenticationContext = authenticationContext;
  }

  public void doSomething() {
    System.out.println("Hey "+authenticationContext.getUser().getFullName()+",  Sample method to check Components");
  }
}</pre></div><p>In the implementation class, we can inject the JIRA components as usual and use them for various things. Here, we inject <code class="literal">JiraAuthenticationContext</code> to retrieve the current user details just to print a personalized message!</p></li><li class="listitem">Declare the component in the <code class="literal">atlassian-plugin.xml</code> file using the Component Plugin module.<div><pre class="programlisting">&lt;component key="myComponent" name="My Component" class="com.jtricks.provider.MyComponentImpl"&gt;  
  &lt;interface&gt;com.jtricks.provider.MyComponent&lt;/interface&gt;
&lt;/component&gt;</pre></div><a id="id2050" class="indexterm"/><a id="id2051" class="indexterm"/><a id="id2052" class="indexterm"/><a id="id2053" class="indexterm"/><p>Here, the component module has a unique key and a class attribute that points to the Implementation class. The element interface points to the component interface we created in <em>Step</em> <em>1</em>.</p></li></ol></div><p>Our component is now ready and available to use within the other plugin modules. For example, we can use this component in the RedirectAction class we saw earlier, as follows:</p><div><pre class="programlisting">public class RedirectAction extends JiraWebActionSupport {
  private final MyComponent myComponent;

  public RedirectAction(MyComponent myComponent) {
    this.myComponent = myComponent;
  }

  @Override
  protected String doExecute() throws Exception {
    System.out.println("Execute the method in component!");
    this.myComponent.doSomething();
    System.out.println("Succesfully executed. Go to dashboard");
    return getRedirect("/secure/Dashboard.jspa");
  }
}</pre></div><p>Here, the component is injected in the constructor as we normally do with a JIRA component (remember the <code class="literal">JiraAuthenticationContext</code> in the component itself!) and invoke the exposed method, <code class="literal">doSomething</code> in this case, where appropriate.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec65"/><strong>Exposing components to other plugins</strong></h3></div></div></div><a id="id2054" class="indexterm"/><a id="id2055" class="indexterm"/><a id="id2056" class="indexterm"/><p>When we create the components as discussed earlier, they remain private and are available only within the plugin even though we can expose these components to other plugins.</p><p>The following are the two things you need to do to expose a component:</p><div><ol class="orderedlist arabic"><li class="listitem">Declare the component as public.</li><li class="listitem">Export the packages required for the plugin so that they are available to the other plugins.</li></ol></div><a id="id2057" class="indexterm"/><a id="id2058" class="indexterm"/><a id="id2059" class="indexterm"/><p>The following are the steps in detail to do the same:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the interface and implementation class as before.</li><li class="listitem">Declare the component in the <code class="literal">atlassian-plugin.xml</code> using the Component Plugin module as a public component. For this, we use the public attribute on the component module, as shown in the following code:<div><pre class="programlisting">&lt;component key="myComponent" name="My Component" class="com.jtricks.provider.MyComponentImpl" public="true"&gt;
  &lt;interface&gt;com.jtricks.provider.MyComponent&lt;/interface&gt;
&lt;/component&gt;</pre></div></li></ol></div><p>Export the packages using <code class="literal">bundle-instructions</code> element under <code class="literal">plugin-info</code> in <code class="literal">atlassian-plugin.xml</code>. This is done as follows:</p><div><pre class="programlisting">&lt;plugin-info&gt;
  &lt;description&gt;Adding and importing components to JIRA&lt;/description&gt;  &lt;version&gt;2.0&lt;/version&gt;
  &lt;vendor name="JTricks" url="http://www.j-tricks.com/" /&gt;
  &lt;bundle-instructions&gt;
    &lt;Export-Package&gt;com.jtricks.provider&lt;/Export-Package&gt;
  &lt;/bundle-instructions&gt;
&lt;/plugin-info&gt;</pre></div><p>Note that the <code class="literal">Export-Package</code> element exports <code class="literal">com.jtricks.provider</code> package that holds the interface and implementation class. More about bundle instructions can be found at: <a class="ulink" href="http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Creating+your+Plugin+Descriptor#CreatingyourPluginDescriptor-{{bundleinstructions}}element">http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Creating+your+Plugin+Descriptor#CreatingyourPluginDescriptor-{{bundleinstructions}}element</a>.</p><p>With that, the component is now ready and available to other plugins.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec66"/>Importing public components</h3></div></div></div><a id="id2060" class="indexterm"/><a id="id2061" class="indexterm"/><p>In order to use the public components in other plugins, we will have to first import them using the <code class="literal">component-import</code> plugin module. The module is entered in <code class="literal">atlassian-plugin.xml</code> as follows:</p><div><pre class="programlisting">&lt;component-import key="myComponent"&gt;         &lt;interface&gt;com.jtricks.provider.MyComponent&lt;/interface&gt;&lt;/component-import&gt;</pre></div><a id="id2062" class="indexterm"/><a id="id2063" class="indexterm"/><p>Now, the component is available as if it is created within the plugin itself. The <code class="literal">RedirectAction</code> class will look exactly the same in the new plugin as well if we want to use the component there.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec67"/>Using service properties in components</h3></div></div></div><a id="id2064" class="indexterm"/><a id="id2065" class="indexterm"/><a id="id2066" class="indexterm"/><p>It is also possible to define a Map of properties for a public component which can then be used while importing the components with other plugins. It uses the <code class="literal">service-properties</code> element to define the properties which has child elements named entry and have key &amp; value attributes. For example, a dictionary service can have the service properties defined with the language as key, as shown in the following code snippet:</p><div><pre class="programlisting">&lt;component key="dictionaryService" class="com.myapp.DefaultDictionaryService" interface="com.myapp.DictionaryService"&gt;
    &lt;description&gt;Provides a dictionary service.&lt;/description&gt;
    &lt;service-properties&gt;
        &lt;entry key="language" value="English" /&gt;
    &lt;/service-properties&gt;
&lt;/component&gt;</pre></div><p>It is now possible to use the <code class="literal">filter</code> attribute on the <code class="literal">component-import</code> module to import component only if the service matches the filter. For example, the dictionary service that has English as the language can be imported as follows:</p><div><pre class="programlisting">&lt;component-import key="dictionaryService" interface="com.myapp.DictionaryService"  filter="(language=English)" /&gt;</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec394"/>How it works...</h2></div></div></div><p>When a component is installed, it generates the <code class="literal">atlassian-plugins-spring.xml</code>. Spring Framework configuration file, transforming Component Plugin modules into Spring bean definitions. The generated file is stored in a temporary plugin JAR file and installed into the framework. If the <code class="literal">public</code> attribute is set to 'true', the component will be turned into an OSGi service under the covers, using <strong>Spring</strong> <strong>Dynamic</strong> modules<a id="id2067" class="indexterm"/> to manage its lifecycle.</p><p>Component imports also generate the <code class="literal">atlassian-plugins-spring.xml</code> Spring Framework configuration file and transforms the Import Plugin Module to OSGi service references using Spring Dynamic modules. The imported component will have its bean name set to the component import key.</p><a id="id2068" class="indexterm"/><a id="id2069" class="indexterm"/><a id="id2070" class="indexterm"/><p>In both cases, it is possible to write our your own Spring configuration file, stored under the folder META-INF/spring in the plugin JAR.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>More details about Component Plugin module and Component Import plugin module can be found in the Atlassian documentation at: <a class="ulink" href="http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Component+Plugin+Module">http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Component+Plugin+Module</a> and <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Component+Import+Plugin+Module">http://confluence.atlassian.com/display/JIRADEV/Component+Import+Plugin+Module</a> respectively.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec151"/>Adding new module types to JIRA</h1></div></div></div><a id="id2071" class="indexterm"/><a id="id2072" class="indexterm"/><p>So far, we have seen a lot of useful plugin module types in JIRA. Custom field module type, webwork module type, servlet module type, and so on. But is it possible to add a custom module type in JIRA, one that can then be used to create different modules?</p><p>JIRA provides the Module Type plugin module using which we can add new module types dynamically to the plugin framework. In this recipe, we will see how we can add such a new plugin module type and use it to create different modules of that type.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec395"/>Getting ready</h2></div></div></div><p>Create a Skeleton plugin using Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec396"/>How to do it...</h2></div></div></div><p>Let us consider the same example Atlassian have used in their online documentation, that is, to create a new dictionary plugin module which can then be used to feed a dictionary service used by other plugins or modules.</p><p>Following are the steps to define a new plugin module type:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the module type definition in the <code class="literal">atlassin-plugin.xml</code> file.<div><pre class="programlisting">&lt;module-type key="dictionary" class="com.jtricks.DictionaryModuleDescriptor" /&gt;</pre></div><p>Here, the key must be unique and will be used as the root element when defining the modules of this type. The class points to the <code class="literal">ModuleDescriptor</code> class<a id="id2073" class="indexterm"/> that is instantiated when a new plugin module of this type is found.</p><p>Other useful attributes of this module type includes <code class="literal">name</code> that holds a human readable name, <code class="literal">i18n-name-key</code> to hold the localization key for the human-readable name, <code class="literal">disabled</code> to indicate if the plugin module is disabled by default or not and <code class="literal">system</code> to indicate whether this plugin module is a system plugin module or not (available only for non-OSGi). You can also have an optional <code class="literal">description</code> as a child element.</p></li><li class="listitem">Create an interface that can be used in the <code class="literal">ModuleDescriptor</code> class. This interface will have all the methods needed for the new module. For example, in the dictionary, we need a method to retrieve the definition of a given text and hence we can define the interface as follows:<div><pre class="programlisting">public interface Dictionary {
  String getDefinition(String text);
}</pre></div><p>The new modules of this particular type will ultimately implement this interface.</p></li><li class="listitem"><a id="id2074" class="indexterm"/><a id="id2075" class="indexterm"/>Create the module descriptor class. The class must extend the <code class="literal">AbstractModuleDescriptor</code> class<a id="id2076" class="indexterm"/> and should use the interface we created as the generic type.<div><pre class="programlisting">public class DictionaryModuleDescriptor extends AbstractModuleDescriptor&lt;Dictionary&gt; {
  ...
}</pre></div></li><li class="listitem">Implement the <code class="literal">getModule</code> method<a id="id2077" class="indexterm"/> to create the module.<div><pre class="programlisting">public class DictionaryModuleDescriptor extends AbstractModuleDescriptor&lt;Dictionary&gt; {
  public DictionaryModuleDescriptor(ModuleFactory moduleFactory) {
    super(moduleFactory);
  }

  public Dictionary getModule() {
    return moduleFactory.createModule(moduleClassName, this);
  }
}</pre></div><p>Here, we have used the <code class="literal">ModuleFactory</code> to create a module of this type.</p></li><li class="listitem">Define the attributes and elements that will be used in the new module type and retrieve them in the <code class="literal">init</code> method. For a dictionary, we need at least one attribute, that is the <code class="literal">language</code>, to differentiate the various dictionary modules. Let us name that attribute as <code class="literal">lang</code> and retrieve it in the <code class="literal">init</code> method. The class will now look similar to the following block of code:<div><pre class="programlisting">public class DictionaryModuleDescriptor extends AbstractModuleDescriptor&lt;Dictionary&gt; {
  private String language;

  public DictionaryModuleDescriptor(ModuleFactory moduleFactory) {
    super(moduleFactory);
  }

  @Override
  public void init(Plugin plugin, Element element) throws PluginParseException {
    super.init(plugin, element);
    language = element.attributeValue("lang");
  }

  public Dictionary getModule() {
    return moduleFactory.createModule(moduleClassName, this);
  }

  public String getLanguage() {
    return language;
  }
}</pre></div><a id="id2078" class="indexterm"/><a id="id2079" class="indexterm"/><p>The <code class="literal">init</code> method takes as argument, <code class="literal">com.atlassian.plugin.Plugin</code> and <code class="literal">org.dom4j.Element</code>, the latter holding the module element. We have retrieved the 'lang' attribute here and assigned it to a local variable which has a getter method that can be used to get the language value in other plugins/modules.</p><p>We can have more attributes or child elements as required by the new module type.</p></li><li class="listitem">With that, the new plugin module is now ready. We can now write new modules of the type dictionary.</li></ol></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec68"/>Creating modules using the new module type</h3></div></div></div><a id="id2080" class="indexterm"/><a id="id2081" class="indexterm"/><p>The new module types will be as simple as the following:</p><div><pre class="programlisting">&lt;dictionary key="myUSEnglishDictionary" lang="us-english" class="com.jtricks.dictionary.USDictionary" /&gt;
&lt;dictionary key="myUKEnglishDictionary" lang="uk-english" class="com.jtricks.dictionary.UKDictionary" /&gt;</pre></div><a id="id2082" class="indexterm"/><a id="id2083" class="indexterm"/><p>Note that the root element is the same as the module types' key, <strong>dictionary</strong> in this case. Each has its own unique <code class="literal">key</code> and has the <code class="literal">lang</code> attribute we defined earlier. Each has a class which will implement the Dictionary interface appropriately. For example:</p><div><pre class="programlisting">public class USDictionary implements Dictionary {
  public String getDefinition(String text) {
    if (text.equals("JIRA")){
      return "JIRA in San Fransisco!";
    } else {
     return "What are you asking? We in US don't know anything other than JIRA!!";
    }
  }
}

public class UKDictionary implements Dictionary {
  public String getDefinition(String text) {
    if (text.equals("JIRA")){
      return "JIRA in London!";
    } else {
      return "What are you asking? We in UK don't know anything other than JIRA!!";
    }
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec69"/>Using the new modules created</h3></div></div></div><p>Once the new modules are defined, <code class="literal">myUSEnglishDictionary</code> and <code class="literal">myUKEnglishDictionary</code> in our example, we can use these in other plugin modules. For example, if we want to use them in a servlet module to find the definition of JIRA in both the dictionaries, it can be done using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Get all the enabled modules that use the dictionary module descriptor.<div><pre class="programlisting">List&lt;DictionaryModuleDescriptor&gt; dictionaryModuleDescriptors = pluginAccessor.getEnabledModuleDescriptorsByClass(DictionaryModuleDescriptor.class);</pre></div><p>Here, <code class="literal">pluginAccessor</code> can be retrieved as follows:</p><div><pre class="programlisting">PluginAccessor pluginAccessor = ComponentManager.getInstance().getPluginAccessor();</pre></div><p>It can also be used to retrieve all the enabled modules that uses the given module descriptor class as shown in the code.</p></li><li class="listitem">For each <code class="literal">DictionaryModuleDescriptor</code>, <code class="literal">getLanguage()</code> method will retrieve the value of the <code class="literal">lang</code> attribute and <code class="literal">getModule()</code> will retrieve the respective Dictionary implementation class. For example, JIRA definition for <code class="literal">uk-english</code> can be retrieved as follows:<div><pre class="programlisting">private String getJIRADescription(String key) {
  // To get all the enabled modules of this module descriptor  List&lt;DictionaryModuleDescriptor&gt; dictionaryModuleDescriptors = pluginAccessor.getEnabledModuleDescriptorsByClass(DictionaryModuleDescriptor.class);
  for (DictionaryModuleDescriptor dictionaryModuleDescriptor : dictionaryModuleDescriptors){
    if (dictionaryModuleDescriptor.getLanguage().equals(key)){
      return dictionaryModuleDescriptor.getModule().getDefinition("JIRA");
    }
  }
  return "Not Found";
}</pre></div><p>Here, the key that is passed will be <code class="literal">uk-english</code>.</p></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec397"/>How it works...</h2></div></div></div><p>If we use a servlet to display all the definitions of the word JIRA in all the dictionaries deployed, US and UK in our case, it will appear as follows:</p><div><img src="img/1803-11-13.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec152"/>Enabling access logs in JIRA</h1></div></div></div><a id="id2084" class="indexterm"/><p>Access logs are a good way to find out who is doing what in your JIRA instance. In this recipe, we will see how we can turn on access logging in JIRA.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec398"/>How to do it...</h2></div></div></div><a id="id2085" class="indexterm"/><a id="id2086" class="indexterm"/><p>As of JIRA 4.1, the list of users who are currently accessing JIRA can be found from <strong>Administration</strong> | <strong>System</strong> | <strong>User</strong> <strong>Sessions</strong> menu. But if you need more detailed information about who is doing what, access logging is the way to go.</p><p>In JIRA 4.x, enabling access logs can be done via the administration screen by going to <strong>Administration</strong> | <strong>System</strong> | <strong>Logging</strong> <strong>&amp;</strong> <strong>Profiling</strong> as shown in the following screenshot:</p><div><img src="img/1803-11-14.jpg" alt="How to do it..."/></div><p>We can turn <strong>ON</strong> <strong>HTTP</strong><a id="id2087" class="indexterm"/> and <strong>SOAP</strong><a id="id2088" class="indexterm"/> access logs separately as shown. There is an additional option to turn ON HTTP dump log and SOAP dump log as well. For HTTP, we can also include images in the HTTP access logs.</p><p>All these logs are disabled by default and if enabled via GUI, it will be disabled again on next restart.</p><p>In order to enable them permanently, we can switch them ON in the <code class="literal">log4j.properties</code> file residing under <code class="literal">WEB-INF/classes</code> folder under the section, <strong>Access</strong> <strong>logs,</strong> as shown next:</p><div><pre class="programlisting">log4j.logger.com.atlassian.jira.soap.axis.JiraAxisSoapLog  = ON, soapaccesslog
log4j.additivity.com.atlassian.jira.soap.axis.JiraAxisSoapLog = false
log4j.logger.com.atlassian.jira.soap.axis.JiraAxisSoapLogDump  = ON, soapdumplog
log4j.additivity.com.atlassian.jira.soap.axis.JiraAxisSoapLogDump = false
log4j.logger.com.atlassian.jira.web.filters.accesslog.AccessLogFilter = ON, httpaccesslog
log4j.additivity.com.atlassian.jira.web.filters.accesslog.AccessLogFilter = false
log4j.logger.com.atlassian.jira.web.filters.accesslog.AccessLogFilterIncludeImages = ON, httpaccesslog
log4j.additivity.com.atlassian.jira.web.filters.accesslog.AccessLogFilterIncludeImages = false
log4j.logger.com.atlassian.jira.web.filters.accesslog.AccessLogFilterDump = ON, httpdumplog
log4j.additivity.com.atlassian.jira.web.filters.accesslog.AccessLogFilterDump = false</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec70"/>Enabling Access logs prior to JIRA 4.x</h3></div></div></div><a id="id2089" class="indexterm"/><p>Prior to JIRA 4.x, Access logs had only a single entry in the <code class="literal">log4j.properties</code> file and we could enable it by changing the log level from WARN to INFO as shown next:</p><div><pre class="programlisting">log4j.category.com.atlassian.jira.web.filters.AccessLogFilter = INFO, console, filelog
log4j.additivity.com.atlassian.jira.web.filters = false</pre></div><p>The same option can be enabled from WARN to INFO on the GUI as well but it will be retained only till the next restart just like it is in 4.x.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec399"/>How it works...</h2></div></div></div><p>Once turned ON, the SOAP access logs will be written to <code class="literal">atlassian-jira-soap-access.log</code>, SOAP dump logs to <code class="literal">atlassian-jira-soap-dump.log</code>, HTTP access logs to <code class="literal">atlassian-jira-http-access.log</code> and HTTP dump logs to atlassian<code class="literal">-jira-http-dump.log</code> files, everything residing under the <code class="literal">logs</code> folder.</p><p>You can find detailed information in the access logs, similar to the following:</p><div><pre class="programlisting">0:0:0:0:0:0:0:1 23x14x1 jobinkk [20/Jul/2011:00:23:43 +0100] "GET /secure/AdminSummary.jspa HTTP/1.1" 200 89148 466 "http://localhost:8080/secure/Dashboard.jspa" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0) Gecko/20100101 Firefox/5.0" "xdtgfh"
0:0:0:0:0:0:0:1 23x15x1 jobinkk [20/Jul/2011:00:23:50 +0100] "GET /secure/admin/ViewLogging.jspa HTTP/1.1" 200 7521 724 "http://localhost:8080/secure/AdminSummary.jspa" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0) Gecko/20100101 Firefox/5.0" "xdtgfh"
0:0:0:0:0:0:0:1 23x16x1 jobinkk [20/Jul/2011:00:23:55 +0100] "POST /secure/admin/WebSudoAuthenticate.jspa HTTP/1.1" 302 - 273 "http://localhost:8080/secure/admin/ViewLogging.jspa" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0) Gecko/20100101 Firefox/5.0" "xdtgfh"</pre></div><p>It is also possible to change the individual log file's name or path in the <code class="literal">log4j.properties</code> by modifying the appropriate properties. For example, the SOAP access log file can be written to <code class="literal">/var/log/soap-access.log</code> by modifying <code class="literal">log4j.appender.soapaccesslog.File</code> property as follows:</p><div><pre class="programlisting">log4j.appender.soapaccesslog.File=/var/log/soap-access.log</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec153"/>Enabling SQL logging in JIRA</h1></div></div></div><a id="id2090" class="indexterm"/><a id="id2091" class="indexterm"/><p>Similar to access logs, another useful piece of logging, especially when debugging an issue, is SQL logging. In this recipe, we will see how to turn on SQL logging.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec400"/>How to do it...</h2></div></div></div><p>SQL logging cannot be turned ON from the user interface. Instead, it can be turned ON in the <code class="literal">WEB-INF/classes/log4j.properties</code> file as we have seen with access logs. In this case, the logging entry to be modified is as follows:</p><div><pre class="programlisting">log4j.logger.com.atlassian.jira.ofbiz.LoggingSQLInterceptor = ON, sqllog
log4j.additivity.com.atlassian.jira.ofbiz.LoggingSQLInterceptor = false
log4j.logger.com.atlassian.jira.security.xsrf.XsrfVulnerabilityDetectionSQLInterceptor = ON, xsrflog
log4j.additivity.com.atlassian.jira.security.xsrf.XsrfVulnerabilityDetectionSQLInterceptor = false</pre></div><p>The latter logs the SQL queries executed for Xsrf vulnerability detection.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec401"/>How it works...</h2></div></div></div><p>Once turned <strong>ON</strong>, the SQL logs will be written to <code class="literal">atlassian-jira-sql.log</code> file under logs folder.</p><p>You can find details of numerous SQLs executed as follows:</p><div><pre class="programlisting">2011-07-20 00:39:31,061 http-8080-6 jobinkk 39x31x1 1ogij3g /secure/EditIssue!default.jspa 0ms "SELECT ID, ENTITY_NAME, ENTITY_ID, PROPERTY_KEY, propertytype FROM PUBLIC.propertyentry WHERE ENTITY_NAME='IssueType' AND ENTITY_ID='3'"
2011-07-20 00:39:31,063 http-8080-6 jobinkk 39x31x1 1ogij3g /secure/EditIssue!default.jspa call stack ...

  at com.opensymphony.module.propertyset.ofbiz.OFBizPropertySet.getKeys(OFBizPropertySet.java:82)  at com.atlassian.jira.propertyset.PropertySetCache.bulkLoad(PropertySetCache.java:313)at com.atlassian.jira.propertyset.JiraCachingPropertySet.init(JiraCachingPropertySet.java:789)  at com.opensymphony.module.propertyset.PropertySetManager.getInstance(PropertySetManager.java:58)  at com.opensymphony.module.propertyset.PropertySetManager.getInstance(PropertySetManager.java:31)</pre></div><a id="id2092" class="indexterm"/><a id="id2093" class="indexterm"/><p>As in the case of Access logs, the SQL log file path can be changed by modifying <code class="literal">log4j.appender.sqllog.file</code> property as follows:</p><div><pre class="programlisting">log4j.appender.sqllog.File=/var/log/sql.log</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec154"/>Overriding JIRA's default components in plugins</h1></div></div></div><p>JIRA uses <strong>PicoContainer</strong><a id="id2094" class="indexterm"/> as a central object factory. Picocontainer is responsible for instantiating objects and resolving their constructor dependencies. Within JIRA a lot of Manager, Service, and Utility classes are already registered with Picocontainer. The registration happens in <code class="literal">ComponentRegistrar</code> class' <code class="literal">registerComponents()</code> method and these classes can be retrieved via <strong>dependency</strong> <strong>injection</strong><a id="id2095" class="indexterm"/> or using <code class="literal">ComponentManager</code> class' getter methods or the <code class="literal">getComponentInstanceOfType()</code> method<a id="id2096" class="indexterm"/>.</p><p>While it is true that most of the plugins can work with these already-registered components and the new ones created using Component Plugins module, sometimes the need arises to override an existing component registered within JIRA. In this recipe, we will see how to do that.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec402"/>Getting ready</h2></div></div></div><a id="id2097" class="indexterm"/><a id="id2098" class="indexterm"/><p>Create a skeleton plugin using Atlassian Plugin SDK. The plugin must be v1.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec403"/>How to do it...</h2></div></div></div><p>The overriding of existing components in JIRA is also done using the <strong>Component</strong> <strong>Plugins</strong> module<a id="id2099" class="indexterm"/>. But you must note that the plugin must be v1 and should be deployed under <code class="literal">WEB-INF/lib</code> folder for the overriding to work. Following are the simple, yet powerful, steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the component that we need to extend and find out the interface associated with it. For example, let us try to override the default JIRA <code class="literal">SubTaskManager</code>. The interface in this case will be <code class="literal">com.atlassian.jira.config.SubTaskManager</code>.</li><li class="listitem">Add a component plugin module in the <code class="literal">atlassian-plugin.xml</code> with the interface in <em>Step 1</em>:<div><pre class="programlisting">&lt;component key="subtaskManager" name="My Subtask Manager" class="com.jtricks.MySubtaskManager"&gt;        &lt;interface&gt;com.atlassian.jira.config.SubTaskManager&lt;/interface&gt;
&lt;/component&gt;</pre></div><p>As usual, the component module has a unique <strong>key</strong> and an optional <strong>name</strong>. Here, the class points to the new component's implementation class.</p></li><li class="listitem">Create the implementation class used in the component plugin module, <code class="literal">com.jtricks.MySubtaskManager</code> in this case.<p>We will need to implement all the methods in the SubTaskManager interface but it is entirely up to us how to implement them. It will be a lot easier if we just need to manipulate only a few methods in them because in that case we can choose to extend the default implementation class in JIRA and override only the methods we are interested in!</p><a id="id2100" class="indexterm"/><a id="id2101" class="indexterm"/><p>For simplicity, let us assume we need to only modify the <code class="literal">createSubTaskIssueLink</code> operation in <code class="literal">SubTaskManager</code> to do some extra bit. For this, we can create the <code class="literal">MySubtaskManager</code> by extending <code class="literal">com.atlassian.jira.config.DefaultSubTaskManager</code>, the default implementation class in JIRA, and override the <code class="literal">createSubTaskIssueLink</code> method:</p><div><pre class="programlisting">public class MySubtaskManager extends DefaultSubTaskManager {
  public MySubtaskManager(ConstantsManager constantsManager, IssueLinkTypeManager issueLinkTypeManager,  IssueLinkManager issueLinkManager, PermissionManager permissionManager, ApplicationProperties applicationProperties, CollectionReorderer collectionReorderer, IssueTypeSchemeManager issueTypeSchemeManager, IssueManager issueManager) {
    super(constantsManager, issueLinkTypeManager, issueLinkManager, permissionManager, applicationProperties,  collectionReorderer, issueTypeSchemeManager, issueManager);
   }

  @Override
  public void createSubTaskIssueLink(GenericValue parentIssue, GenericValue subTaskIssue, User remoteUser)   throws CreateException {              
System.out.println("Creating Subtask link in overriden component using GenericValue!");
    super.createSubTaskIssueLink(parentIssue, subTaskIssue, remoteUser);
  }
}</pre></div><p>In our example, let us just print a line to the logs but we can do harder things here!</p></li><li class="listitem">Package the plugin and deploy it under <code class="literal">WEB-INF/lib</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec404"/>How it works...</h2></div></div></div><p>When JIRA is started, all the default components that are registered with <strong>PicoContainer</strong> are loaded first. But when the plugins are loaded, if there is a component module that uses the same interface and a different implementation class; this class will be registered for that interface. In our example, <code class="literal">MySubtaskManager</code> is registered instead of <code class="literal">DefaultSubTaskManager</code> class.</p><div><div><h3 class="title"><a id="note24"/>Tip</h3><p>This method fails in case of some Manager classes, possibly because of the order in which the classes are loaded. You might want to see the next section in such scenarios!</p></div></div><a id="id2102" class="indexterm"/><a id="id2103" class="indexterm"/><p>After overriding <code class="literal">SubTaskManager</code> as discussed before, we will see the message printed into the server logs every time a subtask is created, as shown in the following screenshot:</p><div><img src="img/1803-11-15.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec405"/>There's more...</h2></div></div></div><p>While overriding a component, using the <strong>Component</strong> <strong>Plugins</strong> module is the recommended way, the same thing can be done in a couple of other ways.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec71"/>Overriding by modifying JIRA code</h3></div></div></div><a id="id2104" class="indexterm"/><p>For people who have modified the JIRA Source distribution, overriding the component can be done in a single line. After creating the new component—implementing the interface that we want to override—we can modify the <code class="literal">registerComponents</code> method<a id="id2105" class="indexterm"/> in <code class="literal">com.atlassian.jira.ContainerRegistrar</code> class to include the new class instead of the default class.</p><p>For example, <code class="literal">SubTaskManager</code> can be overridden by replacing:</p><div><pre class="programlisting">register.implementation(PROVIDED, SubTaskManager.class, DefaultSubTaskManager.class);</pre></div><p>With:</p><div><pre class="programlisting">register.implementation(PROVIDED, SubTaskManager.class, MySubtaskManager.class);</pre></div><p>Note that components can either by <code class="literal">INTERNAL</code> meaning that they will be available only to JIRA itself or <code class="literal">PROVIDED</code> in which case they will also be available to <code class="literal">plugins2</code> plugins.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec72"/>Overriding by extending PicoContainer</h3></div></div></div><a id="id2106" class="indexterm"/><p>Prior to JIRA 4.3, there was a provision in JIRA to extend the PicoContainer and register the custom components in the extended PicoContainer. The following is how it was done:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new <code class="literal">PicoContainer</code> class that implements <code class="literal">ContainerProvider</code> interface.<div><pre class="programlisting">public class MyContainerProvider implements ContainerProvider{
  ...
}</pre></div></li><li class="listitem">Implement the <code class="literal">getContainer</code> method<a id="id2107" class="indexterm"/> that builds a container from the parent and includes the new registrations. For our earlier example, the class will look similar to the following block of code:<div><pre class="programlisting">public class MyContainerProvider implements ContainerProvider{
    private DefaultPicoContainer container;

    public PicoContainer getContainer(PicoContainer parent){
        if (container == null)
            buildContainer(parent);
        return container;
    }

    private void buildContainer(PicoContainer parent){
        this.container = new DefaultPicoContainer(new ProfilingComponentAdapterFactory(), parent);
  container.registerComponentImplementation(SubTaskManager.class, MySubtaskManager.class);
    }
}</pre></div><p>Here, <code class="literal">MySubtaskManager</code> will be created exactly the same way.</p></li><li class="listitem">Register the new container provider in the <code class="literal">jira-application.properties </code>file, residing at <code class="literal">atlassian-jira/WEB-INF/classes</code> folder, using the key <code class="literal">jira.extension.container.provider</code>.<div><pre class="programlisting">jira.extension.container.provider = com.jtricks.MyContainerProvider</pre></div></li><li class="listitem">Deploy the JAR file with the new container class and component class under <code class="literal">WEB-INF/lib</code> folder and restart JIRA.</li></ol></div><p>This works in JIRA 4.3 as well though deprecated. From 4.4, it still works but the <code class="literal">jira.extension.container.provider</code> property must be added in <code class="literal">jpm.xml</code> file instead of <code class="literal">jira-application.properties</code>. The property will be added as follows:</p><div><pre class="programlisting">&lt;property&gt;
    &lt;key&gt;jira.extension.container.provider&lt;/key&gt;
    &lt;default-value&gt;com.jtricks.MyContainerProvider&lt;/default-value&gt;
    &lt;type&gt;string&lt;/type&gt;
    &lt;user-editable&gt;true&lt;/user-editable&gt;
&lt;/property&gt;</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec155"/>Creating issues and comments from e-mail</h1></div></div></div><a id="id2108" class="indexterm"/><a id="id2109" class="indexterm"/><a id="id2110" class="indexterm"/><a id="id2111" class="indexterm"/><p>It is possible to automatically create issues or comments in JIRA based on incoming e-mail messages. This feature is very useful in scenarios such as helpdesks where the users normally send an e-mail to a designated e-mail address and the support team works on issues raised such as this one!</p><p>Once configured correctly, any new e-mail that comes in will create a corresponding issue in JIRA and the replies to the e-mail notifications on that issue will be created as comments on that issue. It is also possible to attach documents on the issue by attaching them on the e-mail provided attachments that are enabled in JIRA. If external user management is not enabled, it is still possible to create a user account—if they don't already have an account.</p><p>In this recipe, we will see how we can configure JIRA to enable this feature.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec406"/>How to do it...</h2></div></div></div><p>The following are the steps to enable issue creation from e-mail.</p><div><ol class="orderedlist arabic"><li class="listitem">Create an e-mail account on the server—typically, one e-mail account for each JIRA project. This mailbox should be accessible via POP, IMAP, or on the local file system. JIRA will periodically scan this mailbox and create issues or comments based on the e-mail.</li><li class="listitem">Navigate to JIRA's <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Mail</strong> <strong>Servers</strong></li><li class="listitem">Click on <strong>Configure new POP / IMAP mail server</strong> link.</li><li class="listitem">Enter the details for the POP or IMAP mail server created in <em>Step</em> <em>1</em> and click on <strong>Add</strong>.</li><li class="listitem">Verify the details on the <strong>Mail</strong> <strong>Servers</strong> page and modify if needed.</li><li class="listitem">Navigate to JIRA <strong>Administration</strong> | <strong>System</strong> | <strong>Services</strong>.</li><li class="listitem">Add a new service with the following details:<div><ol class="orderedlist loweralpha"><li class="listitem"><strong>Name</strong>: Name of the service</li><li class="listitem"><strong>Class</strong>: Pick one from the list of Built-in services. <code class="literal">com.atlassian.jira.service.services.pop.PopService</code> for example.</li><li class="listitem"><strong>Delay</strong>: Choose a delay for the service to run and scan the mails.</li></ol></div></li><li class="listitem">Adding the service will take you to the <strong>Edit</strong> <strong>Service</strong> page. Populate the details as follows and update:<div><ol class="orderedlist loweralpha"><li class="listitem"><strong>Handler</strong> : Select <strong>Create</strong> <strong>Or</strong> <strong>Comment</strong> <strong>Handler</strong> from the drop down box</li><li class="listitem"><strong>Handler</strong> <strong>Parameters</strong>: This is the most important part where we specify the parameters that will be used while creating the issue. Following are the list of important parameters:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">project</code>: Key of the project where the issue should be created</li><li class="listitem" style="list-style-type: disc"><code class="literal">issuetype</code>: Unique ID of the <code class="literal">issuetype</code>. For example, if we want the issue to be created as a Bug, provide <code class="literal">issuetype</code> as 1.</li><li class="listitem" style="list-style-type: disc"><code class="literal">createusers</code>: if set to true, accounts will be created for new senders.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reporterusername</code>: Can be used to create issue with the specified reporter when the sender does not match with an existing user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">notifyusers</code>: Only used if <code class="literal">createusers</code> is true. Indicates whether users should get a mail notification for the new accounts created.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ccassignee</code>: If set, the new issue will be assigned to a matching user in To field or in Cc field if no one matches in To field.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bulk</code>: Determines how to handle "bulk" e-mails. Values possible are:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ignore</code>: Ignore the e-mail and do nothing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">forward</code>: Forward the e-mail to the address set in the "Forward Email" text field.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>: Delete the e-mail permanently.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">catchemail</code>: If added, JIRA will process only e-mails sent to this address. It is used when there are multiple aliases for the same e-mail inbox.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stripquotes</code>: If enabled, it strips previous messages from replies.<div><ol class="orderedlist loweralpha"><li class="listitem">Forward e-mail: Error notifications and un-handled e-mails (used in conjunction with bulk forward handle parameter) will be forwarded to this address.</li><li class="listitem">Uses SSL: Select SSL if used.</li><li class="listitem">Server: Select the e-mail server for this service. It will be the one we added in <em>Step</em> <em>2</em> to <em>Step</em> <em>4</em>.</li><li class="listitem">Port: It is the port to connect to. Leave blank if default.</li></ol></div></li></ul></div></li></ol></div></li></ol></div><a id="id2112" class="indexterm"/><a id="id2113" class="indexterm"/><a id="id2114" class="indexterm"/><a id="id2115" class="indexterm"/><p>JIRA is now configured to receive mails to the newly added mailbox.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec407"/>How it works...</h2></div></div></div><p>The service we have setup here scans the mailbox every <strong>n </strong>minutes as configured in the delay and picks up the new incoming messages. When a new message is received, JIRA scans through the subject to see if there are any mentions of an already existing issue. If there is one, the e-mail is added as a comment on the mentioned issue with the e-mail body as the comment text. If there is no mention of an issue in the subject, JIRA still checks whether the e-mail is a reply to another e-mail that already created an issue or not. If so, the e-mail body is again added as a comment on that issue. This is done by checking the <code class="literal">in-reply-to</code> header in the e-mail.</p><p>If JIRA still couldn't find any matching issues, a new issue is created in the project and of type configured in the handle parameters. The e-mail subject will become the issue, summary and e-mail body, the description.</p><p>Any attachments on an e-mail, new, or replies, will be added as attachments on the issue.</p><p>More information about the creation of issues and comments from an e-mail can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Creating+Issues+and+Comments+from+Email">http://confluence.atlassian.com/display/JIRA/Creating+Issues+and+Comments+from+Email</a>.</p><a id="id2116" class="indexterm"/><a id="id2117" class="indexterm"/><a id="id2118" class="indexterm"/><a id="id2119" class="indexterm"/><p>It is also worth checking the plugin exchange for plugins with extended mail handlers that are capable of adding more details on the issue while creation like custom field values. Some of them have far better filtering mechanisms as well.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec156"/>Internationalization in webwork plugins</h1></div></div></div><p>We have seen in the earlier chapters how to write webwork plugins to create new or extended JIRA actions. In this recipe, we will see how we can personalize the messages in these plugins using <strong>internationalization</strong><a id="id2120" class="indexterm"/> and <strong>localization</strong><a id="id2121" class="indexterm"/>.</p><p>As Wikipedia puts it:</p><div><blockquote class="blockquote"><p>"Internationalization and localization are means of adapting computer software to different languages, regional differences and technical requirements of a target market. Internationalization is the process of designing a software application so that it can be adapted to various languages and regions without engineering changes. Localization is the process of adapting internationalized software for a specific region or language by adding locale-specific components and translating text."</p></blockquote></div><p>The terms internationalization and localization are abbreviated to <strong>i18n</strong> where <strong>18</strong> stands for the number of letters between the first <strong>i</strong> and last <strong>n</strong> in internationalization!</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec408"/>How to do it...</h2></div></div></div><a id="id2122" class="indexterm"/><a id="id2123" class="indexterm"/><p>Internationalization in a webwork plugin is achieved with the help of a resource bundle with the same name as the action that it is associated with. Following are the steps to enable it in a JIRA webwork plugin:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">properties</code> file with the same name as that of the action class under the same package structure under <code class="literal">src/main/resources</code> folder in the plugin.<p>For example, if we consider the <code class="literal">RedirectAction</code> example in the previous recipes, the property file will be <code class="literal">RedirectAction.propertie</code>s residing under <code class="literal">src/main/resources/com/jtricks</code> folder.</p></li><li class="listitem">Add the key value pair of properties that needs to be used in action as follows:<div><pre class="programlisting">good.bye=Good Bye</pre></div><p>Here, <code class="literal">good.bye</code> is the key that will be used and will be same across all language <code class="literal">properties</code> files. The value here "Good Bye" will be used for the default locale but will have the equivalent translations in the other language property files.</p></li><li class="listitem">Create <code class="literal">properties</code> files in the same folder for other required languages in the following format: <code class="literal">${actionName}_${languageCode}_${countryCode}.properties</code>. For example, if we need to personalize the above action for UK and US and French users, following will be the property filenames:<div><pre class="programlisting">RedirectAction_en_US.properties
RedirectAction_en_UK.properties
RedirectAction_fr_FR.properties</pre></div></li><li class="listitem">Add the property <code class="literal">good.bye</code> in each of the property files with the appropriate translation as the values. For example, a property with value <code class="literal">Good</code> <code class="literal">Bye</code> in the English property file will have value <code class="literal">revoir</code> in French!<div><pre class="programlisting">good.bye=Good Bye (in RedirectAction_en_UK.properties)
good.bye=revoir (in RedirectAction_fr_FR.properties)</pre></div></li><li class="listitem">In the action class, use <code class="literal">getText(key)</code> method to retrieve the appropriate message. Keep in mind that the action <code class="literal">class</code> extends the <code class="literal">JiraWebActionSupport</code> class which implements the getText method!<p>For example, the value <code class="literal">Good</code> <code class="literal">Bye</code> can be printed to users in different locales in their own language as follows:</p><div><pre class="programlisting">System.out.println(getText("good.bye"));</pre></div></li></ol></div><p>This magic however is broken in v2 plugins and there is already an issue reported with Atlassian at <a class="ulink" href="https://jira.atlassian.com/browse/JRA-23720">https://jira.atlassian.com/browse/JRA-23720</a>. The workaround is to override the <code class="literal">getTexts</code> method as follows in the action class:</p><div><pre class="programlisting">@Override
public ResourceBundle getTexts(String bundleName) {
  return ResourceBundle.getBundle(bundleName, getLocale(), getClass().getClassLoader());
}</pre></div><p>Here we get the <code class="literal">ResourceBundle</code> using the class loader of the action class and that fixes the above issue in v2 plugins!</p><p>Before we wind up, if you need to get the <code class="literal">i18N</code> texts in the velocity templates, following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem"><a id="id2124" class="indexterm"/><a id="id2125" class="indexterm"/>Add the property files as before.</li><li class="listitem">Add the resource entry in the <code class="literal">atlassian-plugin.xml</code> as follows:<div><pre class="programlisting">&lt;resource name="common-18n" type="i18n" location="com.jtricks.RedirectAction"/&gt;</pre></div><p>Here, the resource points to the property file with the package and name (omitting the country or language code).</p></li><li class="listitem">Use <code class="literal">$i18n</code> object to retrieve the property values as follows:<div><pre class="programlisting">$i18n.getText("good.bye")</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec157"/>Sharing common libraries across v2 plugins</h1></div></div></div><p>We have already explored creating both v1 and v2 plugins throughout this book. One major difference between v1 and v2 plugins is that the v1 plugins has got access to all the libraries and classes available in the application class path whereas v2 plugins can't access them.</p><a id="id2126" class="indexterm"/><a id="id2127" class="indexterm"/><a id="id2128" class="indexterm"/><p>For example, the v1 plugins can access some common utility classes by dropping the JAR file with those classes in the <code class="literal">WEB-INF/lib</code> or adding those classes under <code class="literal">WB-INF/classes</code>. But that won't work with v2 plugins as they need the JAR files embedded with them under <code class="literal">MET-INF/lib</code> or the classes embedded in them. How will we handle this scenario when there is a utility class that we need to share across a few v2 plugins? Should we embed the class in all the plugins? The answer is no, and in this recipe, we will see how we can share those utility classes across v2 plugins by creating an OSGi bundle.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec409"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec410"/>How to do it...</h2></div></div></div><a id="id2129" class="indexterm"/><a id="id2130" class="indexterm"/><a id="id2131" class="indexterm"/><p>Let us assume we have a Number utility class that does summation and multiplication of integer numbers. What should we do if we want to make this class available in all the v2 plugins? The following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the Utility class under the correct package:<div><pre class="programlisting">package com.jtricks.utilities;

public class NumberUtility {
  public static int add(int x, int y) {
    return x + y;
  }
}</pre></div></li><li class="listitem">Export the classes that needs to be shared so that it is visible to other v2 plugins. This step is very important.<p>Even though it is a simple utility class, we need the atlassian-plugin.xml for this step. We can use the <code class="literal">bundle-instructions</code> under <code class="literal">plugin-info</code> element in the <code class="literal">atlassian-plugin.xml</code> for exporting selected packages to other plugins/bundles.</p><p>The bundle-instructions element allows child elements.</p><p><strong>Export</strong>
<strong>-</strong>
<strong>Package</strong>: To export selected packages from the plugin to be shared across other plugins</p><p><strong>Import</strong>
<strong>-</strong>
<strong>Package</strong>: Tom import only selected packages into a plugin. By default it imports all the exported packages from other plugins.</p><p>In this case, we need to modify the atlassian-plugin.xml to export our utility class and this can be done as follows:</p><div><pre class="programlisting">&lt;plugin-info&gt;
  &lt;description&gt;Shared Utilities&lt;/description&gt;
  &lt;version&gt;2.0&lt;/version&gt;
  &lt;vendor name="JTricks" url="http://www.j-tricks.com/" /&gt;
  &lt;bundle-instructions&gt;
    &lt;Export-Package&gt;com.jtricks.utilities&lt;/Export-Package&gt;
  &lt;/bundle-instructions&gt;
&lt;/plugin-info&gt;</pre></div></li><li class="listitem">It is possible to export only selected versions and choose not to export certain packages. More details on this can be found at <a class="ulink" href="http://www.aqute.biz/Bnd/Bnd">http://www.aqute.biz/Bnd/Bnd</a>.</li><li class="listitem"><a id="id2132" class="indexterm"/><a id="id2133" class="indexterm"/><a id="id2134" class="indexterm"/>Optionally, we can use the <strong>Import-Package</strong> element to import the above exported package. By default, it will anyways be imported and hence this step can be omitted. However it will be useful when you want to import only selected packages or make the import mandatory etc. Again, the details can be found in the above link.</li><li class="listitem">Package the plugin and deploy it as a v2 plugin.</li></ol></div><p>Now the utility class is available to all the other v2 plugins. When developing, the other plugins should have this class in the classpath which can be achieved by adding the above plugin as a dependency in the <code class="literal">pom.xml</code> with scope as provided.</p><div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;com.jtricks&lt;/groupId&gt;
  &lt;artifactId&gt;utility-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p>When we do that, the above method, add, can be invoked as if the class is within the same plugin. For example, the <code class="literal">RedirectAction</code> class may have the method as follows:</p><div><pre class="programlisting">@Override
protected String doExecute() throws Exception {
  System.out.println("Action invoked. Doing something important before redirecting to Dashboard!");
  System.out.println("Sum:"+NumberUtility.add(3, 5));
  return getRedirect("/secure/Dashboard.jspa");
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec158"/>Operations using direct HTML links</h1></div></div></div><a id="id2135" class="indexterm"/><p>It probably make sense to wind up this book by giving a little tip on how we can do powerful operations in JIRA by a simple click on a link, either from your e-mail or a from a web form or from within JIRA itself!</p><p>Almost all the actions can be encoded into a single URL provided we have the right parameters to invoke those actions. Make no mistake, it has its own disadvantages because it will override all the pre-processing, validations, and so on, in place in some cases.</p><p>The URL that performs the action is constructed in the following manner:</p><p><code class="literal">${baseUrl}/secure/${action}?${arguments}</code></p><p>where <code class="literal">baseUrl</code> is the JIRA base url, <code class="literal">action</code> is the webwork action to be executed and <code class="literal">arguments</code> is the URL encoded arguments needed for the action. The arguments are constructed as key value pairs separated by <code class="literal">&amp;</code>. Each key value pair will be of the form <code class="literal">key=value</code> and must comply with HTML link syntax—that is, all characters must be escaped. Let us see in detail.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec411"/>How to do it...</h2></div></div></div><a id="id2136" class="indexterm"/><p>Let us consider a simple example to start with, i.e. creating issues. Creating an issue has four stages.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Going to initial create screen</li><li class="listitem" style="list-style-type: disc">Selecting the project and <code class="literal">issuetype</code> and clicking on <strong>Next</strong></li><li class="listitem" style="list-style-type: disc">Entering all the details on the issue</li><li class="listitem" style="list-style-type: disc">Clicking on <strong>Submit</strong> with details</li></ul></div><p>We can execute each of these in single steps provided we know the details in advance. For the example, let us take <code class="literal">http://localhost:8080/ </code>as the base URL for the JIRA instance.</p><div><ol class="orderedlist arabic"><li class="listitem">Going to initial create issue screen can be done via the URL:<p><code class="literal">http://localhost:8080/secure/CreateIssue!default.jspa</code></p><p>Note that the recent <code class="literal">project</code> and <code class="literal">issuetype</code> are pre-selected when you access this link because that is the JIRA default behavior. But what if we want to pre-select some other project? All we need is to add the parameters <code class="literal">pid</code> in the URL as follows:</p><p><code class="literal">http://localhost:8080/secure/CreateIssue!default.jspa?pid=10100</code></p></li><li class="listitem">If we need to go to the second step directly by selecting the project and issuetype, just add the <code class="literal">issuetype</code> parameter as well into the URL separated by <code class="literal">&amp;</code>.<p><code class="literal">http://localhost:8080/secure/CreateIssue!default.jspa?pid=10100&amp;issuetype=1</code></p></li><li class="listitem">If we need to pre-populate create issue dialogue in one click, enter all the details in the URL as shown with the action name as <code class="literal">CreateIssueDetails!init.jspa</code><p><code class="literal">http://localhost:8080/secure/CreateIssueDetails!init.jspa?pid=10100&amp;issuetype=1&amp;priority=1&amp;summary=Emergency+Bug&amp;reporter=jobinkk</code></p><p>Note that all the mandatory fields should be populated to avoid validation errors. The above example also shows how the URL is encoded to comply with HTML syntax by replacing space in the summary with a +. i.e. Emergency Bug is written as Emergency+Bug which can also be written as Emergency%20Bug.</p></li><li class="listitem">And if we want to create the issue in one click with the details above, use <code class="literal">CreateIssueDetails</code> action instead of <code class="literal">CreateIssueDetails!init</code><p><code class="literal">http://localhost:8080/secure/CreateIssueDetails.jspa?pid=10100&amp;issuetype=1&amp;priority=1&amp;summary=Emergency+Bug&amp;reporter=jobinkk</code></p><p>Hopefully that gives as idea about how the operation can be executed via direct links. Make sure the user is logged or Anonymous issue creation is turned on when the above link are clicked.</p></li></ol></div><a id="id2137" class="indexterm"/><p>But how do we find out what is the action class involved or what are the parameters to be passed?</p><p>This you can do easily from the browser URL if the request uses GET method. Create an issue with project and <code class="literal">issuetype</code> selected (case 2 above) is an example as shown next:</p><div><img src="img/1803-11-16.jpg" alt="How to do it..."/></div><p>When the request is <strong>POST</strong><a id="id2138" class="indexterm"/> as in case 4, we can find out the action name from the URL but the parameters needs to be worked out from what is posted when the action is executed. There are multiple ways to do it and an easy way out of them will be to use the browser capabilities. For example, using <strong>Firebug</strong><a id="id2139" class="indexterm"/> with Mozilla Firefox will get you the parameters posted when an action is executed as shown below:</p><div><img src="img/1803-11-17.jpg" alt="How to do it..."/></div><a id="id2140" class="indexterm"/><p>Here we can see the parameters pid, issuetype, priority, summary and reporter getting submitted in the <strong>POST</strong> section. Also, we can see the action name. Once you get the list of parameters, we can user them in the URL with appropriate values separated by &amp; as we saw in <em>Step</em> <em>4</em>.</p><p>This technique opens up  lot of possibilities. For example, we can easily automate the submission of these URLs that we have constructed using command-line tools like <code class="literal">wget</code> or <code class="literal">curl</code>. Read about these more at: <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Creating+Issues+via+direct+HTML+links">http://confluence.atlassian.com/display/JIRA/Creating+Issues+via+direct+HTML+links</a> And: <a class="ulink" href="http://confluence.atlassian.com/display/JIRACOM/Automating+JIRA+operations+via+wget">http://confluence.atlassian.com/display/JIRACOM/Automating+JIRA+operations+via+wget</a>.</p></div></div></body></html>