- en: Playbooks – Beyond the Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we outlined and discussed how to construct Ansible
    playbook's and inventory host files. This knowledge will help us get up and running
    with Ansible quickly and is a great foundation to build from. We looked at how
    to leverage these implementations to target groups of infrastructure and began
    to see some of the power that Ansible provides. While Ansible was designed with
    simplicity as its core design construct, that does not mean it is not highly scalable
    and flexible. In many ways, Ansible's real power and scalability comes from its
    modular design and simplistic implementation standards combined with an effectively
    customizable playbook and role design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: While the implementations we have learned thus far have their place and purpose
    (as basic constructs, and foundational elements), can you imagine how hard a 10,000-line
    single file Ansible playbook would be to create and manage? Or what if half of
    that playbook were designed to simply setup web servers? Could there be a better
    way? Absolutely! A better way of implementing and managing playbook's is to use
    Ansible roles and the includes. These scenarios are where moving beyond a simple
    single-file playbook becomes a reality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to expand our Ansible knowledge and learn how
    to make use of Ansible roles and includes. We will learn how to expand from a
    single playbook file into a playbook hierarchy structure where multiple files
    can be combined and reused to provide an **Object Oriented Programming** (**OOP**)
    playbook implementation. In addition to learning roles and include, we will also
    learn how registers and other more advanced playbook structures work. The specific
    learning objectives of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbook's and Conditional Logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Loops and Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Includes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error Trapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: playbook's and Conditional Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a nice integrated way of performing conditional operations.
    That is to say, a task can be executed when a given condition is met. Some examples
    of this type of requirement might be to only execute a task *if* the target system
    is Ubuntu or only execute a task *if* the target system has a specific processor
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible supports conditionals through the implementation of the when operator.
    In this section, we will take a look at how Ansible manages conditionals and tour
    through an example of managing tasks through a condition. Let''s start with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we conditionally specify the `Debian` family as the requirement
    for the task to run. Simple enough, right? In addition to the example using the
    `Ansible_os_family` implementation, we can also specify variable conditions. Variable
    conditions let us specify that a variable is set or exists as a requirement to
    executing the Ansible task. Look at another example of a snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see that if the when operator is set to `true`, we
    tell the user *hello*. Simple enough logic, right? In addition to this implementation,
    we can also use the inverse of this logic, that is, to execute a task when the
    operator is not set. Let''s take a look at an example of this in inverse operation
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While simple logic can be implemented using these solutions, oftentimes we
    need something a bit more comprehensive. In addition to simple logic conditions
    Ansible provides, we can also perform more complex implementations. One such implementation
    is the use of iterators and conditions. Let''s take a look at an example of how
    to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a simple command of `echo`, which takes an iterator
    array (`with_items`), and we terminate the loop if the item count gets larger
    than `7`. The output of this example should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7974d04b-b200-4c30-8bb3-be0d708a73b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! Now that we know how to do this, let''s take a look at how to use conditionals
    based on the output of previous commands. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the implementation of Ansible 2.0, the kind folks at Ansible provided
    us with a handy way of adding conditionals to Ansible roles. As a result, we can
    now use conditional logic directly within our role declarations. This is accomplished
    via the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So we have learned how useful conditionals can be within an Ansible playbook.
    Now let's move on from conditionals onto iterators and loops. Iterators and loops
    provide us with a really handy way to reduce the amount of code we write and allow
    us to perform repetitive operations easily.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Ansible (and YAML for that matter), there is usually more than one way to
    accomplish any given automation. Automation actions can be implemented in simple
    YAML format or can be potentially grouped together by using the `with_items` iterator.
    In this section, we will take a look at iterators and learn how we can leverage
    them to reduce the amount of YAML code we need to write and organize our playbook
    tasks more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with basic programming concepts, the idea of an iterator
    is not new or novel. In fact, Ansible supports multiple variations of an iterator:
    everything from traditional loops to `Do...Until`, numerical iterators, and many
    more. Iterators in the context of Ansible playbook''s are almost identical in
    nature as traditional programming implementations of iterators, with a few specific
    syntax caveats.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to look at the multiple loop variations that Ansible
    supports. We will begin by looking at standard basic loops and move onto more
    complex implementations as we progress through this section. Let's get moving!
  prefs: []
  type: TYPE_NORMAL
- en: Basic loops using with_items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible''s YAML integration supports a basic loop syntax for reducing duplication
    in code. This can be especially handy when installing packages, copying files,
    or managing sets of items. The Ansible implementation of this is managed via the
    `with_items` iterator. Ansible''s `with_items` iterator allows us to specify the
    task to perform once and a list of items to perform the same task repetitively.
    Let''s look at a comparison of an Ansible task that uses `with_items` and the
    same set of tasks that does not use this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Based on this example, we can see that we can alleviate some tedium when writing
    our playbook's by using a `with_items` iterator. The iterator in this case takes
    a list of items and then repeats the task any number of times with a different
    item substituted during each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to specifying `with_items` directly inline in the task, we can
    also leverage a list defined within a YAML variables file, or the vars section.
    This can be accomplished like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`with_items: "{{ myvarlist }}"`'
  prefs: []
  type: TYPE_NORMAL
- en: Nested loops using with_nested
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the simple loops we described previously, Ansible''s syntax
    also supports the idea of nested looping. Nested loops in many ways are similar
    in nature to a set of arrays that would be iterated over using the `with_nested`
    operator. Nested loops provide us with a succinct way of iterating over multiple
    lists within a single task. This could be useful in cases where multiple data
    items are required (such as creating user accounts with different names and details,
    or maybe seeding a MySQL database). Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from the console when we run this playbook on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48116d26-cb97-4884-9039-74ae1a53ba1e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from this example, we have the ability within our playbook to
    use arrays and iterate over them by simply referring to them using the `with_items`
    clause. Neat, right?
  prefs: []
  type: TYPE_NORMAL
- en: Looping over hashes using with_dict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those of you who are familiar with programming languages, the idea of a
    hash is nothing new. For those of you who are not familiar, a hash is simply a
    set of data points identified by a key. Within a hash can be multiple keys, and
    each key has an associated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a basic example of a hash to get a better idea of how
    this unique but popular data structure works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eebd00a-36a9-4960-bf31-20a2fcdace64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From this, table we can see that a key is simply an identifier, and the value
    that key represents could be any string or data piece stored in the value table
    that is associated with that specific key. So how does this apply to Ansible?
    Ansible provides us a `with_dict` operator, which we can leverage to iterate over
    key/value pairs. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows a way to store hash data within an Ansible playbook and
    then iterate over the results. In this specific case, we iterate over the key,
    which is our looney''s short name, and the associated value, which is the looney''s
    full name. When we run this playbook, the output we will see should be something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2a15eda-3136-4ee0-be56-8178628e540a.png)'
  prefs: []
  type: TYPE_IMG
- en: So we can see from this screenshot that Ansible will neatly iterate over the
    data sets we requested and say *hello* to our favorite Looney Tunes character.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over files using with_file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible''s `with_file` operator provides us with a handy way to iterate over
    the contents of a file. This specific iterator operation provides us with a way
    to iterate over a single file or multiple files in order. To illustrate how this
    works, let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hello.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`favorite_toons.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`iterator_file_contents.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From this example, we should be able to at this point understand basically
    what it is trying to accomplish. The first thing it will do is display the contents
    of `hello.txt`, and subsequently display the contents of `favorite_toons.txt`.
    As such, the output should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0d2d93b-6fcd-4c44-a0ef-866c084a97f8.png)'
  prefs: []
  type: TYPE_IMG
- en: From this screenshot, we can see that the playbook which uses nesting outputs
    the names of our favorite Looney Toons character, prefaced with a greeting.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over sequential numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Counting through a sequential number set is a fundamental programming concept.
    It involves essentially creating a counter that counts forward or backward sequentially
    by a given step. That is to say, we can count up or down from a given number using
    Ansible sequential numerical iterators. We can then pipe the numerical data from
    Ansible into, say, a shell call or a debug message. Let''s take a quick look at
    a brief example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The do until iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Do...Until` iterator has been around for a long time in many programming
    languages. It is probably one of the most widely implemented iterators that exist.
    This specific iteration solution provides the developer with the ability to continuously
    loop through a sequence of code until a specific condition or flag is met. Let''s
    look at a traditional programming example of a `Do...Until` loop versus an Ansible
    implementation of the same operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VB.NET example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible `Do...Until` example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This Ansible `Do` example shows how to tail a log and wait for a specific text
    to appear. This can be really handy when waiting for a system to spin up or an
    execution to throw something in a log file.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over inventory hosts using play_hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inventory hosts are data items too! Each hostname defined within an inventory
    file can be iterated upon. This implementation of the kind folks at Ansible can
    be really handy for performing numerous configuration operations, installation
    items, and much more. In this section, we will look at how to effectively iterate
    through an inventory file and perform an operation with the hosts defined. The
    easiest way to iterate through the inventory is to use the `play_hosts` variable
    in conjunction with `with_items`. While this may be the easiest method, it is
    not the only way to achieve this type of iteration. Let''s get started by looking
    at an example of the `play_hosts` variable in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`iterating_inventory_ex1.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example shows the user a list of all hosts that are currently targeted
    by the execution, in this case, the items in the `webserver` group.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the previously shown example, which uses the `play_hosts` variable,
    we can also implement a similar solution using Ansible group identifiers. Group
    identifiers are a neat way to access the data (hosts in our case) that Ansible
    is using as part of this specific run. This implementation is actually in some
    ways slightly more powerful. The power of this solution comes from the key/value
    pair definition we can specify in the groups variable. Let''s take a look at an
    example of how we can use group identifiers to effect the same output as the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from this example, we can not only target the current hosts targeted
    by the play, but also any specific group defined within the inventory. For example,
    we can fetch a list of *all* hosts by simply specifying `{{ groups[''all''] }}`.
    Or if we wanted to target only the `dbserver` group, we could do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is completely feasible to create a playbook as a single small or large file.
    Many new Ansible developers actually begin developing playbook's this way, and
    generally, this implementation methodology is a perfectly normal way to initially
    learn Ansible playbook creation. Sooner or later though, learning to reuse portions
    of a playbook will become something very useful and will help better organize
    playbook development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: On a fundamentally simplistic level, using an Ansible include statement allows
    us to reuse positions of our automation in one or multiple locations. Consider
    this in some ways like a method or function in programming that we can execute
    over and over, essentially allowing us to write the automation once and then reuse
    it many times.
  prefs: []
  type: TYPE_NORMAL
- en: This is a far more effective way to reuse automation as it removes the need
    for repeating the creation of various portions of an automation or configuration
    management solution. As a result, we can begin to think outside of the scope of
    *step one, step two—*type automation and instead start thinking in terms of *provision
    this as a web server, or provision this as a web and database server*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a pretty critical concept. We might have a top level playbook that
    is nothing than a series of includes that are easy to understand and reusable.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- include: add_users.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- include: install_httpd.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- include: configure_apache.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- include: setup_firewall.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the real power of ansible because the first and last steps there would
    be executed on every box.
  prefs: []
  type: TYPE_NORMAL
- en: Play-level includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most effective ways to modularize and organize an Ansible playbook
    is to use Ansible `include`. Ansible play includes provide an easy way to embed
    `play` from other YAML files. This implementation allows us to effectively modularize
    our playbook''s automation. Let''s take a look at how to leverage a `play` include
    within an Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see that to implement a `play` include, we can simply
    add a `- include: <filename>` directive within our playbook, which will embed
    the contents of an external Ansible playbook (its plays) into the current playbook
    and execute those contents at the appropriate step. Neat, right? So to sum up,
    let''s define an Ansible `play` include succinctly: a play-level include allows
    us to embed additional Ansible plays from external files within our playbook''s
    using the `-include` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the *vanilla* implementation of Ansible includes we just looked
    at, the Ansible `include` directive provides us with the ability to pass parameters
    to our included files upon execution. This can be handy for handing off variables
    to the other YAML files we include. Let''s take a look at how to pass parameters
    using the `include` directive. An example is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the previous example, we can then wield the variable within the target
    included file using the following syntax `{{user}}`. So a more complete example
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a grasp of play-level includes, let's take a look at task includes.
  prefs: []
  type: TYPE_NORMAL
- en: Task-level includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to play includes, Ansible supports an additional implementation
    of the `include` directive. The second implementation is called a **task include**.
    Task includes are different from `play` includes, in that the contents of the
    included file would only be a YAML file containing a static list of tasks to execute.
    To implement a task include, we must specify the include directive at the task
    level. Let''s take a look at an example of a task include solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we can see the `include` statement provided would include
    the contents of the file `additionaltasks.yml`. The important thing to understand
    here is scope. Play-level includes will need to have a complete play or set of
    plays within, whereas `task` includes should only have a YAML-formatted list of
    tasks. Let's look at an example of each for a bit of clarity. Consider the following
    two files, adequately named `additionaltasks.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `additionaltasks.yml` is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, we know that Ansible supports two scopes of the `include` directive:
    the first imports a set of plays, and the second imports a set of tasks. These
    two distinctions are important to understand as they are a powerful feature that
    can be used to modularize automation and configuration management implementations.
    By effectively using includes, we can create highly feature-rich automation and
    configuration management solutions without redundancy in code.'
  prefs: []
  type: TYPE_NORMAL
- en: As of Ansible 2, you can develop unlimited levels of includes. This means that
    one file can include another, and within the second, you can include additional
    ones. There is no limit to the number of includes supported.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In conjunction with the two basic include types that we mentioned before, Ansible
    2.0 supports dynamic task-level includes. A dynamic include is simply a variable
    translation support within an `include`. As a result of this implementation, we
    should note that the inclusion is not actually evaluated by Ansible until the
    moment it is set to be executed. This allows adding variables within an include,
    which was not possible prior to Ansible 2.0\. This implementation can more specifically
    leverage loops and variable use within the `include` statement. This additional
    functionality provides us with a significant amount of flexibility within our
    playbook. Let''s take a look at a few examples of **dynamic includes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows us that it is possible to use variable names within our
    `include` statement. This can be useful for dynamically specifying the file to
    include, or having the `include` file be assigned at runtime. Beyond this implementation,
    we can also use dynamic includes to pass a list of variables between the master
    playbook and child. An example of this is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we can see we are passing `apples`, `oranges`, and the variable
    `{{favorite_fruit}}` to our included playbook using the `with_items` notation
    (more on this later). This should give you a pretty good idea of how to pass information
    from one playbook to an include file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a pretty good grasp of how Ansible can be more dynamic, let's
    take a look at Ansible roles and see how those fit into our implementations and
    development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible works very well with supporting a single-file 10,000-line long playbook
    (please don't actually do that). However, when playbook's grow out of control,
    Ansible provides a very nice way to break automation into multiple files (as illustrated
    before using includes). Yet, as we start to grow the number of files we need to
    include, things can become hairy to manage and maintain. So what is an Ansible
    developer to do? Roles to the rescue! Ansible roles provide us with a really unique
    way of dividing out our automation into uniquely defined responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to providing configuration management modularization, Ansible roles
    provide us with a best-practice approach to organizing automation within a playbook
    and developing reusable solutions. The Ansible *roles* implementation simply represents
    an automated, well-structured implementation of an Ansible includes solution (which
    we discussed in the previous section). This means that the include directives
    are already defined and implemented so long as the predefined directory structure
    is honored within the roles implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So to sum up, let''s consider the following definition for Ansible roles:'
  prefs: []
  type: TYPE_NORMAL
- en: A role is a set of Ansible tasks or configuration management automation grouped
    by a common purpose or responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin understanding how Ansible roles work on a fundamental level, it is
    probably best to start with a simple flat-file Ansible playbook that installs
    and configures a LAMP server (Linux, Apache, MySQL, and PHP) and then implement
    the same solution using Ansible roles and look at the implementation differences.
    This will give us a good apples-to-apples comparison of how roles implementations
    differ from standard playbook''s and how to organize the responsibilities. For
    this tutorial, we will be using an Ubuntu-based Ansible control server. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `AnsibleLAMPwithoutRoles.yml` is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Based on this playbook, we can see we are instructing Ansible to install and
    configure a basic LAMP solution via a single playbook. This includes installing
    Apache2, PHP, MySQL, and so on. With Ansible roles, we can accomplish the same
    tasks with a bit more elegance and modularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, Ansible roles are basically include statements that are
    pre-baked into the Ansible implementation based on a set of predefined directory
    structures. Let''s take a look at this same basic configuration management implementation
    and how the directory structure that makes up Ansible roles would need to be applied.
    On your local system, replicate the following directory and file structure (leave
    the file contents blank for the moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/184e108a-bef1-46fe-9162-489d23761a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the directory and file structure have been created, the next thing we
    need to fill in is the top-level `playbook.yml` file, which we will use to specify
    the roles we want and execute them. Here is the content to add to `playbook.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this file is to simply act as a pointer to the roles we wish
    to execute as part of our Ansible run. The `roles` defined within in this case
    are a `webserver` role and a `dbserver` role. Each role will be defined by naming
    and folder convention. Let's move on to the roles themselves. In our example,
    we have two task files that need to be created/modified (the `webserver` tasks
    file and the `dbserver` tasks file). These are respectively named `main.yml` and
    reside in the tasks folder. Let's fill in each. The contents for each are provided
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `webserver/tasks/main.yml` and `dbserver/tasks/main.yml` is
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When we run this playbook with our roles defined, we can see that Ansible understands
    how to traverse the main playbook and execute the roles required to ensure that
    Apache and MySQL are properly installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Register Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible registers provide us with a nice way of capturing the results of a given
    task and executing a set of additional automations based on the captured results.
    In many ways, this is similar to variable declarations, although registers are
    more global in nature. Ansible registers provide us with a way of storing this
    captured data for later and then conditionalizing future tasks based on the results
    of previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Ansible registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic Ansible register implementations require us to only `register`
    the output of a given operation. An example of how to define a simple register
    is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the register operator to capture the last 100 lines
    of the system's MOTD file and store it in a global `register` variable, `motd_contents`.
    Ansible registers essentially create a new Ansible fact at runtime, which can
    be then used later within the play as part of a conditional.
  prefs: []
  type: TYPE_NORMAL
- en: But how exactly do we leverage stored registers later? Good question! Let's
    explore.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accessing Ansible registers later within the same `play` as they were created
    can be accomplished fairly easily: all we need to do is use the the `when` conditional.
    We learned about the basics of how to leverage the `when` conditional earlier
    in this chapter. But in this context it lets us access registers. Let''s look
    at an example of how to use the `when` conditional to access our `register`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The important line in this playbook is the `when` line (obviously). The interesting
    portion of it is the idea of `.stdout.find`, which is attached to the end of our
    register variable. This extension in many ways looks like a set of OOP methods.
    That would be an accurate way to identify those specific calls.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we told Ansible to look at the contents of `STDOUT` (standard
    command-line output) and find a specific text. If Ansible were able to properly
    find the text, only then would the task have been executed. Nifty, right?
  prefs: []
  type: TYPE_NORMAL
- en: Additional conditional logic with registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible registers are not limited only by the find method of `STDOUT`. In addition
    to basic search criteria, we can also apply many other comparisons. In this section,
    we will identify the more common methods that can be attached to a `register`
    variable and learn what other comparisons we can perform.
  prefs: []
  type: TYPE_NORMAL
- en: Null or empty comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Null or empty string comparisons are common in most programming languages,
    and Ansible is no different. Applying a null or empty string check to an Ansible
    register can be accomplished via the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this specific implementation, we can also apply other variables
    to our conditionals with registers. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Vars and Ansible registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible registers also support the use of regular predefined variable comparisons
    within an Ansible register `when` clause. This implementation lets us say something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This plain English comparison could be represented in Ansible YAML form via
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This conditional simply specifies that if the contents of `varfoo` exist within
    the `stdout` of register `varfoo`, then execute the task.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over register contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the contents of the register can be iterated over to create new things
    and adapt existing system solutions. This type of implementation might be something
    like creating a list of directories, touching a set of files, or creating a list
    of users. Basically, it means we can use the contents of the register as a list.
    Let''s take a look at a quick example provided by [https://www.Ansible.com/](https://www.ansible.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Based on this example, we can see that our `with_items` clause is now used to
    create a set of files and folders. However, the `home_dirs` variable is set through
    a register instead of a standard Ansible variable.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible handlers by default are run at the end of the actual execution of a
    playbook. They are different from registers in that they provide us with a way
    of creating a set of automation that can be executed once (and only once) at the
    end of a playbook based on a set of conditions provided during the execution.
    Logically, this could look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run role `foo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run role `bar`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If role `bar`'s service start failed, trigger a flag
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute handlers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a trigger was flagged, do something
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While this example may seem similar in some ways to conditionals, it is in many
    ways very different. That is to say, the handler would only get executed the one
    time regardless of how many times the flag was tripped. In addition, the other
    variance would be that a handler is more global in nature. That is to say, regardless
    of which role tripped the flag of the handler, it would still get executed, thus
    making the solution non-modular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? Let''s take a look at an example of an Ansible handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'From this example, we can see we have two new concepts: the `notify` operator
    and the `handlers` operator. Notify in some ways represents a global event system,
    which throws an event out when triggered. The handlers on the other hand represent
    listeners to those events.'
  prefs: []
  type: TYPE_NORMAL
- en: So essentially, we can use the `notify` solution to trigger a set of tasks downstream
    after the main playbook has completed its execution. Nice, right?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered a number of new techniques of developing and
    managing playbook's. We learned how to leverage `includes` to modularize our playbook
    structures and provide us with a level of reusability within our implementations.
    We learned how to implement conditional logic within our playbook's. We found
    out how to deal with iterators and loops. We discovered how to implement roles
    in Ansible and how we can use this structure to organize and better manage complex
    configuration management and automation tasks. We learned how to best organize
    our playbook's for reusability. We learned how handlers and registers work and
    discovered ways we can make our automation solutions more fault tolerant, and
    we discussed how to effectively enforce basic configuration management implementations.
  prefs: []
  type: TYPE_NORMAL
- en: This information represents the basic cursory information you will need to become
    a successful Ansible developer and pave the way for success in configuration management.
    To assist you on your way, the [https://www.Ansible.com/](https://www.ansible.com/)
    documentation can be of great use. As such, this resource should become your go-to
    guide for all things Ansible related.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover Jinja2\. Jinja provides Ansible with a
    huge amount of flexibility as it allows conditionals, loops, variables, and so
    much more. By the time we complete the next chapter, we should have a pretty good
    idea of how we can develop playbook's and leverage Jinja to support our implementations.
  prefs: []
  type: TYPE_NORMAL
