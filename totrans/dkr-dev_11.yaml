- en: '*Chapter 9*: Cloud-Native Continuous Deployment Using Spinnaker'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用Spinnaker进行云原生持续部署'
- en: Deploying Docker containers as cloud-native applications to Kubernetes poses
    challenges that a specialized container-centric continuous deployment system can
    solve. Instead of writing custom deployment logic in those scripts that Jenkins
    runs, as we did when we deployed to a single host, we can use Spinnaker to deploy
    to Kubernetes. Because Spinnaker works with Jenkins, we can continue to use the
    Jenkins server that we already set up to build the Docker containers and prepare
    the Helm Charts for deployment. Using Spinnaker, we will deploy an application
    using its built-in support for Helm Charts and Kubernetes deployments. We will
    also explore some of Spinnaker's specialized deployment strategies and see how
    they apply to Kubernetes-centric environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将Docker容器作为云原生应用程序部署到Kubernetes面临着挑战，这些挑战可以通过专门的容器中心持续部署系统来解决。与我们之前在部署到单一主机时通过Jenkins运行自定义部署逻辑不同，我们可以使用Spinnaker来部署到Kubernetes。因为Spinnaker可以与Jenkins配合使用，我们可以继续使用已经设置好的Jenkins服务器来构建Docker容器并准备部署的Helm
    Charts。通过Spinnaker，我们将使用其内置的Helm Charts和Kubernetes部署支持来部署应用程序。我们还将探讨Spinnaker的一些专门部署策略，看看它们如何应用于以Kubernetes为中心的环境。
- en: In this chapter, we are going to learn when and why you would use Spinnaker
    in addition to Jenkins. We will learn how to improve your setup for supporting
    the deployment and maintenance of Kubernetes applications by learning to configure
    Spinnaker and integrating it with GitHub, Docker Hub, and Jenkins. We will learn
    how to deploy an app to Kubernetes using a Spinnaker pipeline and AWS **Elastic
    Container Registry** (**ECR**), as well as learn a bit about how Spinnaker's support
    for different deployment and testing strategies may or may not apply when you
    use it in conjunction with Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习在什么情况下以及为什么你会选择除了Jenkins之外还使用Spinnaker。我们将学习如何通过配置Spinnaker并将其与GitHub、Docker
    Hub和Jenkins集成，来改进你的环境以支持Kubernetes应用程序的部署和维护。我们将学习如何通过Spinnaker管道和AWS **Elastic
    Container Registry** (**ECR**)将应用程序部署到Kubernetes，同时也将了解当你将Spinnaker与Kubernetes结合使用时，Spinnaker支持不同部署和测试策略的方式是否适用。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主题：
- en: Improving your setup for Kubernetes application maintenance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进你的Kubernetes应用程序维护环境
- en: Spinnaker – when and why you might need more sophisticated deployments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spinnaker —— 你何时以及为什么可能需要更复杂的部署
- en: Setting up Spinnaker in your AWS EKS cluster with Helm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS EKS集群中使用Helm设置Spinnaker
- en: Deploying ShipIt Clicker with a simple deployment strategy in Spinnaker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spinnaker中使用简单的部署策略部署ShipIt Clicker
- en: Learning about Spinnaker's support for different deployment and testing strategies
    with respect to Kubernetes applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Spinnaker在Kubernetes应用程序中支持不同部署和测试策略的情况
- en: Let's get started by reviewing the technical requirements for this chapter,
    and then we will move on to learning about the Spinnaker platform.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下本章的技术要求，然后继续学习Spinnaker平台。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have a working Kubernetes cluster in the cloud, as set up in
    the previous chapter. You could reuse that cluster or set up a new one for this
    chapter using the same method or by using `eksctl`. Please note that the Spinnaker
    version described in this chapter is not compatible with Kubernetes 1.16 and later;
    be sure to install this on a Kubernetes 1.15 cluster. You will also need to have
    a current version of the AWS `kubectl`, and `helm` 3.x installed on your local
    workstation, as described in the previous chapter. The Helm commands in this chapter
    use the `helm` 3.x syntax. The AWS **Elastic Kubernetes Service** (**EKS**) cluster
    must have a working **Application Load Balancer** (**ALB**) Ingress Controller
    setup. We will also use the AWS ECR Docker repository set up in the previous chapter.
    You will also need to have the Jenkins server that was set up in [*Chapter 7*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126),
    *Continuous Deployment with Jenkins*, available as Spinnaker relies on Jenkins
    for building software artifacts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在云中拥有一个可用的Kubernetes集群，如前一章所述。你可以复用该集群，或者使用相同的方法或`eksctl`为本章设置一个新的集群。请注意，本章所描述的Spinnaker版本与Kubernetes
    1.16及以后的版本不兼容；务必在Kubernetes 1.15集群上安装此版本。你还需要在本地工作站上安装当前版本的AWS `kubectl`和`helm`
    3.x，正如前一章所述。本章中的Helm命令使用的是`helm` 3.x语法。AWS **弹性Kubernetes服务**（**EKS**）集群必须配置有工作中的**应用负载均衡器**（**ALB**）Ingress
    Controller。我们还将使用前一章中设置的AWS ECR Docker仓库。你还需要具备在[*第7章*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126)中设置的Jenkins服务器，因为Spinnaker依赖Jenkins构建软件制品。
- en: Spinnaker requires more resources than might be available on your local workstation,
    and we will want to connect it to outside services, such as Jenkins and GitHub,
    in a way that might not work with a local Kubernetes learning environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker比本地工作站可用的资源要求更多，我们还需要将其连接到外部服务，如Jenkins和GitHub，这种方式可能无法与本地Kubernetes学习环境兼容。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际应用：
- en: '[https://bit.ly/2DUGumq](https://bit.ly/2DUGumq)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2DUGumq](https://bit.ly/2DUGumq)'
- en: Using the updated ShipIt Clicker v5
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的ShipIt Clicker v5
- en: 'We will use the version of ShipIt Clicker in the `chapter9` directory in the
    following GitHub repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下GitHub仓库中的`chapter9`目录中的ShipIt Clicker版本：
- en: '[https://github.com/PacktPublishing/Docker-for-Developers/](https://github.com/PacktPublishing/Docker-for-Developers/)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Docker-for-Developers/](https://github.com/PacktPublishing/Docker-for-Developers/)'
- en: 'This version has some changes from the previous version. It only has one copy
    of the Helm Charts in `chapter9/shipitclicker`, with several override YAML files
    for cluster deployment: `values-eks.yaml` and `values-spin.yaml`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与前一个版本有所不同。它只包含一个Helm Charts副本，位于`chapter9/shipitclicker`，并包含几个用于集群部署的覆盖YAML文件：`values-eks.yaml`和`values-spin.yaml`。
- en: In the previous chapter, we kept multiple directories of redundant template
    and configuration files, but the only differences in the Helm Charts were the
    overrides in the `values` file. The copy in this chapter uses a more concise strategy.
    It turns out that you can use multiple YAML config files that override just the
    settings that have to change for each deployment or environment. In this chapter,
    we will transition the container repository for the sample application from Docker
    Hub to ECR, deploy it once manually, and then switch to deploying ShipIt Clicker
    using Spinnaker.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们保持了多个冗余的模板和配置文件目录，但在Helm Charts中的唯一差异是`values`文件中的覆盖内容。本章中的示例采用了更简洁的策略。事实证明，你可以使用多个YAML配置文件，这些文件只覆盖每个部署或环境中需要更改的设置。在本章中，我们将把示例应用程序的容器仓库从Docker
    Hub迁移到ECR，先手动部署一次，然后切换到使用Spinnaker部署ShipIt Clicker。
- en: Improving your setup for Kubernetes application maintenance
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进Kubernetes应用程序维护的设置
- en: In order to deploy and maintain Spinnaker, we need to be able to talk to the
    Kubernetes cluster from our local workstation. We also want to be able to use
    **Secure Sockets Layer** (**SSL**)-protected communications to Kubernetes-hosted
    resources. Let's take this step by step in order to prepare your local workstation
    and AWS account for more advanced deployments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署和维护Spinnaker，我们需要能够从本地工作站与Kubernetes集群进行通信。我们还希望能够使用**安全套接字层**（**SSL**）保护的通信与Kubernetes托管的资源进行交互。让我们一步步进行，以便为你的本地工作站和AWS账户准备更多的高级部署。
- en: Managing the EKS cluster from your local workstation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地工作站管理EKS集群
- en: In order to make it easier to administer the EKS cluster and work with it, you
    will want to set up your local workstation to talk to the cluster. In the previous
    chapter, we set up the AWS CLI with an AWS IAM administrator account and then
    used it to set up an EKS cluster. We will build on that in this chapter to make
    sure that we can efficiently manage the cluster and the applications in it from
    our local workstation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更轻松地管理 EKS 集群并与其一起工作，您需要设置本地工作站以与集群通信。在上一章中，我们使用 AWS CLI 配置了 AWS IAM 管理员帐户，并使用它设置了
    EKS 集群。在本章中，我们将进一步构建，以确保能够从本地工作站高效管理集群及其内部的应用程序。
- en: 'Follow the instructions here on your local workstation to get `kubectl` and
    the rest of the Kubernetes utilities talking with your EKS cluster:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地工作站上执行以下操作，以使`kubectl`和其他 Kubernetes 实用程序能够与您的 EKS 集群通信，请按照这里的说明进行操作：
- en: '[https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection](https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection](https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection)'
- en: 'The essential parts of the instructions in the preceding link involve executing
    an `aws cli` command from your local workstation. Issue this command to update
    `.kube/config` with an entry that will let you connect to the EKS cluster, but
    replace `EKS-VIVLKQ5X` with the name of your EKS cluster:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的链接中，关于执行从本地工作站发出的`aws cli`命令的重要部分涉及。执行此命令以更新 `.kube/config`，并添加一个条目，使您能够连接到
    EKS 集群，但请用您的 EKS 集群名称替换 `EKS-VIVLKQ5X`：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, test whether you can communicate with the cluster:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试您是否能够与集群通信：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this works, you will see a list of EC2 hosts that comprise your EKS cluster
    nodes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，您将看到组成您的 EKS 集群节点的 EC2 主机列表。
- en: Troubleshooting kubectl connection failures
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除 kubectl 连接失败
- en: 'If the preceding `aws eks` command yielded an error message or an access denied
    message, or it failed to complete, you will need to troubleshoot before proceeding.
    Follow the steps in the following sections, and also look at the AWS guide for
    troubleshooting this communication failure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的`aws eks`命令产生错误消息或访问被拒绝消息，或者未能完成操作，则需要先进行故障排除。请按照以下部分的步骤进行操作，并查看 AWS 指南以解决此通信失败问题：
- en: '[https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection/](https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection/)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection/](https://aws.amazon.com/premiumsupport/knowledge-center/eks-cluster-connection/)'
- en: Making sure you have the right AWS CLI profile active
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保您已激活正确的 AWS CLI 配置文件
- en: 'If you have multiple AWS CLI profiles, your default user might not match the
    one expected. You can either explicitly tell the AWS CLI to use a profile with
    the `--profile` parameter or you can set the `AWS_DEFAULT_PROFILE` variable to
    force it to use a particular profile, as follows, before issuing the `aws eks`
    command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个 AWS CLI 配置文件，则默认用户可能与预期的用户不匹配。您可以通过`--profile`参数显式告知 AWS CLI 使用配置文件，或者在执行`aws
    eks`命令之前通过设置`AWS_DEFAULT_PROFILE`变量来强制使用特定配置文件：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have set up the AWS CLI with the profile, we must double-check that
    we can still reach our EKS cluster by checking the CloudFormation template access
    control list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用配置文件设置了 AWS CLI，我们必须再次检查我们是否可以通过检查 CloudFormation 模板访问控制列表来到达我们的 EKS
    集群。
- en: Ensuring that your CloudFormation template is configured to allow access
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保您的 CloudFormation 模板已配置为允许访问
- en: In the previous chapter, when we set up the EKS cluster, we entered our IPv4
    address in `192.2.0.15/32`. Double-check your address with [https://whatismyip.com/](https://whatismyip.com/)
    to be sure. If these are not set correctly, update the CloudFormation stack with
    these values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们设置 EKS 集群时，我们在 `192.2.0.15/32` 中输入了我们的 IPv4 地址。请通过 [https://whatismyip.com/](https://whatismyip.com/)
    仔细检查您的地址。如果这些设置不正确，请使用这些值更新 CloudFormation 堆栈。
- en: The CLI profile must match the IAM user that you used to create the EKS cluster
    with the AWS Quick Start.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 配置文件必须与您用于创建 EKS 集群的 AWS Quick Start 中使用的 IAM 用户匹配。
- en: This will configure IAM and EKS appropriately.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适当地配置 IAM 和 EKS。
- en: Switching between local and cluster contexts
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地和集群上下文之间切换
- en: 'When you have multiple Kubernetes contexts configured, you can switch between
    them via the `kubectl config get-contexts` and `kubectl config use-context` commands,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当您配置了多个 Kubernetes 上下文时，您可以通过以下命令切换它们：`kubectl config get-contexts` 和 `kubectl
    config use-context`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding listing, we can see all the contexts we have defined. We can
    also see that when we use the `docker-desktop` context, we only see one node,
    but when we use the EKS context, we see multiple EC2 server nodes. For the rest
    of the chapter, we are going to target the EKS context for the Kubernetes-related
    commands.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们可以看到所有已定义的上下文。我们还可以看到，当我们使用`docker-desktop`上下文时，只会看到一个节点，但当我们使用EKS上下文时，我们可以看到多个EC2服务器节点。在本章的剩余部分，我们将针对EKS上下文执行与Kubernetes相关的命令。
- en: Verifying that you have a working ALB Ingress Controller
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证你是否拥有一个工作正常的ALB Ingress Controller
- en: In the previous chapter, we set up an EKS cluster with an ALB Ingress Controller
    in order to grant the world access to the ShipIt Clicker application. If you are
    reusing that EKS cluster and the ALB Ingress Controller is working OK, you can
    skip to the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了一个带有ALB Ingress Controller的EKS集群，以便让外界能够访问ShipIt Clicker应用。如果你重新使用那个EKS集群，并且ALB
    Ingress Controller正常工作，你可以跳到下一节。
- en: If you have set up a new cluster, you can either follow the instructions in
    the last chapter in order to get the ALB Ingress Controller working, or you can
    run one of the shell scripts included in this chapter as a shortcut if the new
    cluster lacks an ALB Ingress Controller.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置了一个新集群，你可以按照上一章的说明来使ALB Ingress Controller工作，或者你可以运行本章中提供的其中一个Shell脚本，作为快捷方式，如果新集群没有ALB
    Ingress Controller。
- en: To use the ALB Ingress Controller setup script, make a note of your EKS cluster
    name, and make sure you have installed both Helm and `eksctl`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ALB Ingress Controller安装脚本，记下你的EKS集群名称，并确保已安装Helm和`eksctl`。
- en: 'Then, run the `deploy-alb-ingress-controller.sh` script from your local workstation
    to set up the ALB Ingress Controller (replace `EKS-8PWG76O8` with the name of
    your EKS cluster):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从你的本地工作站运行`deploy-alb-ingress-controller.sh`脚本来设置ALB Ingress Controller（将`EKS-8PWG76O8`替换为你的EKS集群名称）：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you have the ALB Ingress Controller installed, you can proceed to get
    a domain managed in AWS and generate an SSL certificate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了ALB Ingress Controller，可以继续在AWS中获取一个域名并生成SSL证书。
- en: Preparing a Route 53 domain and certificate
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Route 53域名和证书
- en: 'In order to secure the communications between your EKS cluster and the outside
    world, we are going to use the following services to manage **Domain Name Server**
    (**DNS**) entries and server certificates:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的EKS集群与外部世界之间的通信安全，我们将使用以下服务来管理**域名服务器**（**DNS**）条目和服务器证书：
- en: '**AWS Route 53**: [https://aws.amazon.com/route53/](https://aws.amazon.com/route53/)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Route 53**：[https://aws.amazon.com/route53/](https://aws.amazon.com/route53/)'
- en: '**AWS Certificate Manager** (**ACM**): [https://aws.amazon.com/certificate-manager/](https://aws.amazon.com/certificate-manager/)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS证书管理器**（**ACM**）：[https://aws.amazon.com/certificate-manager/](https://aws.amazon.com/certificate-manager/)'
- en: In [*Chapter 7*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126), *Continuous
    Deployment with Jenkins*, we configured Jenkins to use domain names to map entries
    for staging and production for ShipIt Clicker. In this chapter, we are going to
    use Route 53 to manage DNS entries and ACM to manage certificates to help secure
    communication.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126)《使用Jenkins进行持续部署》中，我们配置了Jenkins，使用域名映射ShipIt
    Clicker的暂存和生产环境条目。在本章中，我们将使用Route 53来管理DNS条目，并使用ACM管理证书，以帮助确保通信的安全。
- en: 'You can either transfer the top-level domain you are using to Route 53, or
    you can delegate a subdomain of an existing domain you control, such as `eks.example.com`,
    to Route 53\. See this AWS guide on delegating a subdomain to Route 53:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你正在使用的顶级域名转移到Route 53，或者你可以将你控制的现有域名的子域名（例如`eks.example.com`）委托给Route 53。请参阅AWS指南，了解如何将子域名委托给Route
    53：
- en: '[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html)'
- en: 'Once you have delegated the domain to Route 53, verify that you can view the
    SOA record for that domain (substituting your domain for eks.example.com):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将域名委托给Route 53，验证你是否能够查看该域名的SOA记录（将你的域名替换为eks.example.com）：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this returns an SOA record similar to the preceding log, you are set. If
    it yields a not found error, you need to troubleshoot more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的SOA记录与前面的日志类似，那么你已经设置好了。如果出现未找到错误，你需要进一步排查问题。
- en: Once your domain is resolving OK, go to the ACM console at https://us-east-2.console.aws.amazon.com/acm/home?region=us-east-2#/
    and generate a new public certificate containing both of the domain names – `*.eks.example.com`  and
    `eks.example.com` (replacing `example.com` with your domain). The domain name
    starting with `*` is known as a wildcard certificate because it matches any domain
    name that has the same domain suffixes. Using that will allow us to have one certificate
    covering many domain names.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的域名解析正常，前往 ACM 控制台 https://us-east-2.console.aws.amazon.com/acm/home?region=us-east-2#/
    并生成包含两个域名的新的公共证书 – `*.eks.example.com` 和 `eks.example.com`（将 `example.com` 替换为你的域名）。以
    `*` 开头的域名称为通配符证书，因为它匹配所有具有相同域名后缀的域名。使用这个证书可以让我们拥有一个覆盖多个域名的证书。
- en: 'Use the DNS method of validation. Since you have that domain managed in Route
    53, you can expand the domain and hit the shortcut **Create record in Route 53**
    button, which should look similar to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DNS 验证方法。由于你的域名已经在 Route 53 中进行管理，你可以展开该域名并点击快捷按钮**在 Route 53 中创建记录**，该按钮应该类似于以下内容：
- en: '![](img/B11641_09_001.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_001.jpg)'
- en: Figure 9.1 – Requesting a certificate in ACM
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 在 ACM 中请求证书
- en: This will add validation records to your Route 53 zone, which will speed up
    the issuance of the certificates. The certificate might take from 5 minutes to
    1 hour to get issued, unless there is a problem with the DNS validation records,
    such as the domain not being properly delegated from the name servers that are
    one level above it. Wait for the certificate to be issued and note the ARN of
    the certificate – you will need it later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向你的 Route 53 区域添加验证记录，从而加速证书的颁发。证书可能需要 5 分钟到 1 小时才能颁发，除非 DNS 验证记录有问题，比如域名没有正确地从上一级的名称服务器委派过来。等待证书颁发，并记下证书的
    ARN —— 你稍后会用到它。
- en: Building and deploying ShipIt Clicker v5
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建并部署 ShipIt Clicker v5
- en: In order to verify that we have support for SSL-protected sites, we are going
    to deploy ShipIt Clicker to EKS and enable ALB load balancer support for HTTPS.
    In order to demonstrate that we can use the AWS ECR container registry, we will
    also push the container to ECR and use that registry to deploy the application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们是否支持 SSL 保护的网站，我们将把 ShipIt Clicker 部署到 EKS 并启用 ALB 负载均衡器对 HTTPS 的支持。为了演示我们可以使用
    AWS ECR 容器注册表，我们还将把容器推送到 ECR，并使用该注册表部署应用程序。
- en: 'Copy `chapter9/values-eks.yaml` to `chapter9/values.yaml`, and then edit the
    `values.yaml` file, as follows. Start by changing the name of the image at the
    start of the file and prefix it with the name of your ECR container registry (replace
    `143970405955` with your AWS account ID and make sure the region – here, `us-east-2`
    – matches the region you are using):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `chapter9/values-eks.yaml` 复制到 `chapter9/values.yaml`，然后编辑 `values.yaml` 文件，如下所示。首先更改文件开头的镜像名称，并将其前缀设置为你的
    ECR 容器注册表名称（将 `143970405955` 替换为你的 AWS 账户 ID，并确保区域——在此为 `us-east-2`——与你使用的区域匹配）：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the `values.yaml` file has annotations indicating that the ALB should
    listen on both port `80` and `443`, and that it has a fully qualified domain name
    in the `host` setting. Edit the values in the following host entry so that the
    `shipit-v5.eks.example.com` domain name matches a domain name that would match
    the wildcard SSL certificate you have in ACM:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`values.yaml` 文件中有注释，表明 ALB 应该监听 `80` 和 `443` 端口，并且它在 `host` 设置中有一个完全限定的域名。编辑以下主机条目中的值，以便
    `shipit-v5.eks.example.com` 域名与 ACM 中的通配符 SSL 证书匹配的域名一致：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have prepared the `values.yml` file, we will build the container
    and push it to EKS.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好 `values.yml` 文件，我们将构建容器并将其推送到 EKS。
- en: 'Change the directory to `Docker-for-Developers/chapter9` and issue these commands
    to build and deploy the ShipIt Clicker to the cluster to test the ALB integration
    (replace `143970405955.dkr.ecr.us-east-2.amazonaws.com` with your ECR registry):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `Docker-for-Developers/chapter9` 目录并执行以下命令来构建并部署 ShipIt Clicker 到集群中，以测试
    ALB 集成（将 `143970405955.dkr.ecr.us-east-2.amazonaws.com` 替换为你的 ECR 注册表）：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After a few minutes, you should be able to verify that the Ingress Controller
    is working:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你应该能够验证 Ingress Controller 是否正常工作：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If this does not appear, check the Ingress Controller logs, as follows, for
    troubleshooting clues:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示，请检查 Ingress Controller 日志，以下是一些排错线索：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to create a DNS address-mapping record, also known as an `HOSTS`
    column in the preceding output of `kubectl get ingress`. Go to the Route 53 AWS
    console for your domain and create a new record of type A for `shipit-v5.eks`.
    Make this record an alias record and enter the DNS name from the `HOSTS` column
    of the ALB listed in the `kubectl get ingress` output. The form to do that should
    look something like the one in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个DNS地址映射记录，也就是前面`kubectl get ingress`输出中的`HOSTS`列。进入AWS Route 53控制台，选择你的域名，创建一个类型为A的新记录，指向`shipit-v5.eks`。将此记录设置为别名记录，并输入`kubectl
    get ingress`输出中ALB的`HOSTS`列中的DNS名称。执行此操作的表单应如下图所示：
- en: '![](img/B11641_09_002.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_002.jpg)'
- en: Figure 9.2 – Creating an A record as an alias in AWS Route 53
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 在AWS Route 53中创建作为别名的A记录
- en: Press the `example.com` with your domain name) to verify that you can view it
    over HTTPS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按下`example.com`（使用你自己的域名）来验证你是否可以通过HTTPS访问它。
- en: Now that you've made sure that you can administer the EKS cluster from your
    local environment, pushed the demo application's container to ECR, deployed the
    demo application to Kubernetes using Helm, and configured the HTTPS support to
    secure an ALB Ingress Controller to reach a service hosted in EKS, you are ready
    to proceed with a Spinnaker installation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经确保可以从本地环境管理EKS集群，将演示应用程序的容器推送到ECR，使用Helm将演示应用程序部署到Kubernetes，并配置HTTPS支持以安全地访问一个托管在EKS中的服务，你可以继续进行Spinnaker的安装。
- en: Spinnaker – when and why you might need more sophisticated deployments
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spinnaker – 你可能需要更复杂部署的时机和原因
- en: In order to reliably deploy your application, you could write many scripts by
    hand and use a continuous integration system. However, many people have thought
    about the problems inherent in deploying applications in Kubernetes. Kubernetes
    does have significant deployment capabilities, especially when you use the deployment
    controller. But this approach does not meet everyone's needs. Some people have
    developed specialized systems that reduce the complexity of handling these tasks.
    Systems such as Jenkins-X, Weaveworks, CodeFresh, and Spinnaker fit this niche.
    We are going to examine Spinnaker, a continuous deployment toolset, in more detail
    ([https://www.spinnaker.io/](https://www.spinnaker.io/)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠地部署你的应用程序，你可以手动编写许多脚本并使用持续集成系统。然而，许多人已经考虑到在Kubernetes中部署应用程序所固有的问题。Kubernetes确实具有强大的部署能力，尤其是当你使用部署控制器时。但这种方法并不适合所有人。一些人开发了专门的系统来减少处理这些任务的复杂性。像Jenkins-X、Weaveworks、CodeFresh和Spinnaker这样的系统适合这一需求。我们将更详细地研究Spinnaker，这是一个持续部署工具集([https://www.spinnaker.io/](https://www.spinnaker.io/))。
- en: We will begin by walking through Spinnaker's core concepts and highlighting
    where it shares terminology with other platforms, such as Kubernetes, including
    where the meanings are different.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍Spinnaker的核心概念，并强调它与其他平台（如Kubernetes）共享的术语，特别是它们的含义不同之处。
- en: Introduction to Spinnaker
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spinnaker简介
- en: 'Spinnaker is a **continuous delivery** (**CD**) platform that works across
    cloud vendors and is open source. Netflix originally wrote Spinnaker to help manage
    their multi-cloud deployments, using the immutable server pattern (see [https://martinfowler.com/bliki/ImmutableServer.html](https://martinfowler.com/bliki/ImmutableServer.html)).
    Spinnaker features an image bakery that involves combining application code with
    an operating system image and supporting libraries, and then saving (baking) an
    immutable machine image, such as an AWS **Amazon Machine Image** (**AMI**) or
    VMware **Virtual Machine Disk** (**VMDK**) image, to speed up deployments and
    minimize runtime configuration. Read more about the image bakery and its use in
    Spinnaker in the following articles:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker是一个**持续交付**（**CD**）平台，跨多个云提供商工作，并且是开源的。Netflix最初编写Spinnaker是为了帮助管理他们的多云部署，采用不可变服务器模式（请参见[https://martinfowler.com/bliki/ImmutableServer.html](https://martinfowler.com/bliki/ImmutableServer.html)）。Spinnaker具有一个镜像工厂功能，涉及将应用程序代码与操作系统镜像及支持库结合，然后保存（烘焙）成一个不可变的机器镜像，例如AWS的**Amazon机器镜像**（**AMI**）或VMware的**虚拟机磁盘**（**VMDK**）镜像，以加速部署并最小化运行时配置。可以阅读更多关于镜像工厂及其在Spinnaker中的使用的相关文章：
- en: '[https://netflixtechblog.com/how-we-build-code-at-netflix-c5d9bd727f15](https://netflixtechblog.com/how-we-build-code-at-netflix-c5d9bd727f15)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://netflixtechblog.com/how-we-build-code-at-netflix-c5d9bd727f15](https://netflixtechblog.com/how-we-build-code-at-netflix-c5d9bd727f15)'
- en: '[https://docs.armory.io/spinnaker-install-admin-guides/packer/](https://docs.armory.io/spinnaker-install-admin-guides/packer/)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.armory.io/spinnaker-install-admin-guides/packer/](https://docs.armory.io/spinnaker-install-admin-guides/packer/)'
- en: This pattern works well at a scale, but the advent of Docker and container-centric
    runtimes, such as Kubernetes, provides a different approach to reach the same
    goals.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在大规模应用中表现良好，但 Docker 和以容器为中心的运行时（如 Kubernetes）的出现，提供了一种不同的方法来实现相同的目标。
- en: 'Spinnaker has been adapted to work with Kubernetes and Docker, as well as supporting
    its original deployment strategy of using an image bakery and the immutable server
    pattern. You can find the source code for the platform among other projects at
    the official GitHub repository:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 已被调整为支持 Kubernetes 和 Docker，并且支持其原始的部署策略——使用镜像工厂和不可变服务器模式。你可以在官方 GitHub
    仓库中找到该平台的源代码及其他项目：
- en: '[https://github.com/spinnaker](https://github.com/spinnaker)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/spinnaker](https://github.com/spinnaker)'
- en: Before we install the application, we should familiarize ourselves with some
    of the core concepts of this technology. The first one we will look at is application
    management.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装应用程序之前，我们应当熟悉一些该技术的核心概念。我们首先要了解的概念是应用程序管理。
- en: Application management
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序管理
- en: 'We can use the management feature to administer and view our cloud resources.
    Using Spinnaker, we model our applications around concepts such as server groups
    and clusters. Refer to the Spinnaker documentation for a complete overview of
    these concepts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用管理功能来管理和查看我们的云资源。通过 Spinnaker，我们围绕服务器组和集群等概念来建模我们的应用程序。有关这些概念的完整概述，请参阅
    Spinnaker 文档：
- en: '[https://spinnaker.io/concepts/](https://spinnaker.io/concepts/)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://spinnaker.io/concepts/](https://spinnaker.io/concepts/)'
- en: An application is the top-level container, which can be deployed on the infrastructure
    that Spinnaker maintains, including clusters and server groups. Each cluster then
    acts as a mechanism to organize server groups. Spinnaker considers Docker containers
    running in Kubernetes in pods as members of a server group. These Docker images
    may contain services such as ShipIt Clicker and any associated tools, such as
    the Datadog monitoring agents featured in [*Chapter 15*](B11641_15_Final_NM_ePub.xhtml#_idTextAnchor329),
    *Scanning, Monitoring, and Using Third-Party Tools*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是顶级容器，可以部署在 Spinnaker 维护的基础设施上，包括集群和服务器组。每个集群作为组织服务器组的机制。Spinnaker 将在 Kubernetes
    中以 Pod 形式运行的 Docker 容器视为服务器组的成员。这些 Docker 镜像可能包含诸如 ShipIt Clicker 之类的服务以及任何相关工具，如在[*第15章*](B11641_15_Final_NM_ePub.xhtml#_idTextAnchor329)中介绍的
    Datadog 监控代理，*扫描、监控和使用第三方工具*。
- en: Now that we understand how a containerized project is represented in Spinnaker,
    we should consider how we can deploy it to our EKS cluster in AWS via this framework.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了容器化项目在 Spinnaker 中的表现形式，我们应考虑如何通过该框架将其部署到我们 AWS 中的 EKS 集群。
- en: Application deployment
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序部署
- en: The application deployment piece of the puzzle is represented graphically in
    the Spinnaker user interface with a pipeline. A pipeline can either be started
    manually or kicked off automatically as part of a process triggered by other events,
    such as a source code control-system push. A pipeline tells us all the steps (called
    **stages**) along the way that need to be completed – for example, to take a Docker
    container, install it, and make subsequent updates to it in our cloud environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序部署这一环节在 Spinnaker 用户界面中通过管道图形化呈现。管道可以手动启动，也可以作为其他事件触发的一部分自动启动，比如源代码控制系统的推送。管道会告诉我们完成过程中需要执行的所有步骤（称为**阶段**）——例如，如何获取
    Docker 容器，安装它，并在我们的云环境中对其进行后续更新。
- en: 'The following screenshot demonstrates what a deployment pipeline and its various
    stages look like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了部署管道及其各个阶段的样子：
- en: '![](img/B11641_09_003.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_003.jpg)'
- en: Figure 9.3 – Spinnaker pipeline
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Spinnaker 管道
- en: Each of the stages in this pipeline can be thought of as a discrete task. Each
    task is executed in sequence or in parallel, depending on whether the pipeline
    forks. As we will see shortly, Spinnaker comes with a number of predefined stages
    that we can incorporate into our custom pipeline.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道中的每个阶段可以视为一个独立的任务。每个任务按照顺序或并行执行，具体取决于管道是否分叉。正如我们接下来会看到的，Spinnaker 提供了多个预定义的阶段，我们可以将它们融入到自定义管道中。
- en: It is advantageous to tie the pipeline to your build server and your source
    code control repository so that when you push changes to your application and
    its Helm Charts, Spinnaker can package, test, and deploy them appropriately.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将管道与构建服务器和源代码控制库绑定是有优势的，这样，当你将更改推送到应用程序及其 Helm Charts 时，Spinnaker 可以适当地打包、测试和部署它们。
- en: Now that we have briefly walked through the two major concepts of Spinnaker,
    let's get stuck into building out some infrastructure and a pipeline so that we
    can get a better handle of how the stages work and the types of deployment strategies
    that are possible.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们简要介绍了 Spinnaker 的两个主要概念，接下来让我们着手构建一些基础设施和管道，以便更好地理解各个阶段是如何工作的，以及可能的部署策略类型。
- en: Setting up Spinnaker in an AWS EKS cluster using Helm
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 在 AWS EKS 集群中设置 Spinnaker
- en: Setting up a production-grade Spinnaker cluster requires some careful planning,
    but for learning purposes, we are going to use one of the simplified approaches.
    The complete Spinnaker setup guide can be found at [https://www.spinnaker.io/setup/](https://www.spinnaker.io/setup/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个生产级的 Spinnaker 集群需要一些精心的规划，但为了学习的目的，我们将使用其中一种简化的方法。完整的 Spinnaker 设置指南可以在
    [https://www.spinnaker.io/setup/](https://www.spinnaker.io/setup/) 找到。
- en: 'In order to demonstrate the proof of concept of using Spinnaker, we are going
    to use the Helm Chart found at the following link to deploy Spinnaker:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用 Spinnaker 的概念验证，我们将使用以下链接中的 Helm Chart 来部署 Spinnaker：
- en: '[https://github.com/helm/charts/tree/master/stable/spinnaker](https://github.com/helm/charts/tree/master/stable/spinnaker)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/helm/charts/tree/master/stable/spinnaker](https://github.com/helm/charts/tree/master/stable/spinnaker)'
- en: The Spinnaker Helm Chart warns against production use
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker Helm Chart 警告不适合用于生产环境
- en: Although this Helm Chart states that it is not suitable for production use,
    we can use it to demonstrate the proof of concept for building, testing, and deploying
    applications. The Spinnaker setup guide gives guidance for setting up production-grade
    Spinnaker systems. Most importantly, that includes making the Spinnaker installation
    separate from the cluster that also hosts the applications that end users consume.
    We are going to ignore that advice to save time and money in this chapter and
    make it easier to demonstrate. If you are going to adopt Spinnaker at scale, please
    take this advice to heart and set up Spinnaker according to their best practices
    documentation in a separate cluster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个 Helm Chart 声明它不适合用于生产环境，但我们可以使用它来演示构建、测试和部署应用程序的概念验证。Spinnaker 设置指南提供了设置生产级
    Spinnaker 系统的指导。最重要的是，这包括将 Spinnaker 安装与托管最终用户消费应用程序的集群分开。为了节省时间和金钱，也为了便于演示，我们将在本章忽略这一建议。如果你打算大规模采用
    Spinnaker，请务必认真采纳这一建议，并根据他们的最佳实践文档，在单独的集群中设置 Spinnaker。
- en: 'Ensure you are connected to the correct Kubernetes context targeting your EKS
    cluster, and enter the following command to deploy Spinnaker to its own namespace:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你连接到正确的 Kubernetes 上下文，目标是你的 EKS 集群，并输入以下命令将 Spinnaker 部署到它自己的命名空间中：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It may take several minutes for the Spinnaker deployment to complete. When
    it is done, you should see an output similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 部署可能需要几分钟才能完成。当它完成时，你应该看到类似以下内容的输出：
- en: '![](img/B11641_09_004.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_004.jpg)'
- en: Figure 9.4 – Spinnaker Helm Chart installation
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Spinnaker Helm Chart 安装
- en: Next, we will connect to the freshly installed Spinnaker system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将连接到刚刚安装的 Spinnaker 系统。
- en: Connecting to Spinnaker through the kubectl proxy
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 kubectl proxy 连接到 Spinnaker
- en: To carry out preliminary testing, pay attention to the advice in the output
    you receive from the `helm install` command you ran to create port forwarding
    tunnels in the previous section. It should be similar to the output shown in the
    preceding section. You should set up two separate console windows or tabs on your
    local workstation, and then run the pairs of commands listed in the output of
    the `helm install spinnaker` command in the `NOTES` section to set up the port
    forwarding tunnels, one per console window or tab. You can then go to [http://127.0.0.1:9000](http://127.0.0.1:9000)
    in your browser to verify that Spinnaker is up and running.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行初步测试，请注意你从运行 `helm install` 命令（在上一节中创建端口转发隧道）中收到的输出中的建议。它应该类似于前一节中显示的输出。你应该在本地工作站上设置两个单独的控制台窗口或标签页，然后运行
    `helm install spinnaker` 命令输出中 `NOTES` 部分列出的命令对，以设置端口转发隧道，每个控制台窗口或标签页执行一对命令。然后，你可以在浏览器中访问
    [http://127.0.0.1:9000](http://127.0.0.1:9000) 来验证 Spinnaker 是否已启动并运行。
- en: Exposing Spinnaker via ALB Ingress Controllers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 ALB Ingress 控制器公开 Spinnaker
- en: 'The directions for integrating Spinnaker with EKS ([https://www.spinnaker.io/setup/install/providers/kubernetes-v2/aws-eks/](https://www.spinnaker.io/setup/install/providers/kubernetes-v2/aws-eks/))
    describe a solution using services with a LoadBalancer annotation to expose the
    services. However, since we have our ALB Ingress Controller, Route 53, and ACM
    already configured, it would be better to expose them using the ALB Ingress Controller.
    Edit the `chapter9/spinnaker-alb-ingress.yaml` file, and make the following changes
    in the ingress configuration for both `spin-deck` and `spin-gate` (there are two
    sets of configurations in the file):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spinnaker 与 EKS 集成的说明（[https://www.spinnaker.io/setup/install/providers/kubernetes-v2/aws-eks/](https://www.spinnaker.io/setup/install/providers/kubernetes-v2/aws-eks/)）描述了使用具有
    LoadBalancer 注释的服务来公开服务的解决方案。然而，由于我们已经配置了 ALB Ingress 控制器、Route 53 和 ACM，因此最好通过
    ALB Ingress 控制器来公开它们。编辑 `chapter9/spinnaker-alb-ingress.yaml` 文件，并对 `spin-deck`
    和 `spin-gate` 的 ingress 配置做以下更改（文件中有两组配置）：
- en: Replace eks.example.com with the domain name you have configured with the ACM
    wildcard certificate.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 eks.example.com 替换为你已使用 ACM 通配符证书配置的域名。
- en: Replace `192.2.0.10/32` with your public IP address in CIDR format (the same
    format you used to lock down the EKS API).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `192.2.0.10/32` 替换为你的公共 IP 地址（CIDR 格式）（与你用于锁定 EKS API 的格式相同）。
- en: Replace `192.2.0.200/32` with the public IP address of your Jenkins server.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `192.2.0.200/32` 替换为你的 Jenkins 服务器的公共 IP 地址。
- en: Security notice
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安全通知
- en: It is important to add the preceding IP address restriction because, out of
    the box, Spinnaker's user interface runs as the cluster administrator user. If
    you allowed `0.0.0.0/0` (the entire internet) access, someone could run processes
    as the cluster administrator and modify or take over your cluster. If you have
    a dynamic IP address, you might have to change this several times, starting with
    the CloudFormation template.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加前述的 IP 地址限制非常重要，因为默认情况下，Spinnaker 的用户界面以集群管理员身份运行。如果你允许 `0.0.0.0/0`（整个互联网）访问，那么有人可能会以集群管理员身份运行进程，并修改或接管你的集群。如果你有动态
    IP 地址，你可能需要多次更改，首先从 CloudFormation 模板开始。
- en: 'Then, apply the config template to create the ALB Ingress Controllers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用配置模板以创建 ALB Ingress 控制器：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After a few seconds, issue the following command to verify that this worked
    (look for your domain name instead of eks.example.com):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，执行以下命令以验证是否成功（请查找你的域名，而不是 eks.example.com）：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The DNS names that this lists under the `HOSTS` column are the names we intend
    to use to call the services. The DNS addresses under the `ADDRESS` column are
    the actual DNS names that the ALB Ingress Controller has created using the AWS
    ALBs. To connect these two names, we need to create two DNS records in our domain
    in order to reach the Spinnaker services with the friendlier names. Note the DNS
    names of the ingress controllers from the `ADDRESS` column in this listing. Then,
    go to the AWS Route 53 console for your domain and create two new DNS entries
    of type A. Make them alias records.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表中 `HOSTS` 列下列出的 DNS 名称是我们打算用来调用服务的名称。`ADDRESS` 列下的 DNS 地址是 ALB Ingress 控制器通过
    AWS ALB 创建的实际 DNS 名称。为了将这两个名称连接起来，我们需要在我们的域中创建两个 DNS 记录，以便使用更友好的名称访问 Spinnaker
    服务。请注意从该列表中 `ADDRESS` 列下的 Ingress 控制器的 DNS 名称。然后，进入 AWS Route 53 控制台，为你的域创建两个新的
    A 类型 DNS 记录，并将它们设置为别名记录。
- en: Name the first one `spinnaker` and give it the value shown in the `ADDRESS`
    column for the entry named `spin-deck`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个命名为 `spinnaker`，并将 `spin-deck` 条目中 `ADDRESS` 列显示的值作为其值。
- en: Name the second entry `spinnaker-gate` and give it the value shown in the `ADDRESS`
    column for the entry named `spin-gate`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将第二个条目的名称命名为 `spinnaker-gate`，并将 `spin-gate` 条目中 `ADDRESS` 列显示的值作为其值。
- en: 'The result of this will be two new DNS entries similar to the following (with
    your domain name instead of example.com):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的结果将是两个新的 DNS 记录，类似于以下内容（将你的域名替换为 example.com）：
- en: spinnaker.eks.example.com
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spinnaker.eks.example.com
- en: spinnaker-gate.eks.example.com
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spinnaker-gate.eks.example.com
- en: While you are waiting for 5 minutes or so for the DNS records to become available
    and the ALB to be fully activated, use Halyard to configure Spinnaker with the
    HTTPS version of these URLs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待大约 5 分钟，直到 DNS 记录可用并且 ALB 完全激活时，使用 Halyard 配置 Spinnaker，并使用这些 URL 的 HTTPS
    版本。
- en: Configuring Spinnaker using Halyard
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Halyard 配置 Spinnaker
- en: 'Now that we have assigned friendly DNS names to our Spinnaker installation,
    we need to configure Spinnaker to make it understand that it must respect these
    names. From your local workstation, connect to the Halyard maintenance pod:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 Spinnaker 安装分配了友好的 DNS 名称，我们需要配置 Spinnaker 使其理解必须遵守这些名称。从你的本地工作站，连接到
    Halyard 维护 pod：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you have connected to the pod, you will see a `spinnaker@spinnaker-spinnaker-halyard-0:/workdir$`
    prompt. Then, enter these commands, replacing `example.com` with your domain name:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接到 pod，你将看到 `spinnaker@spinnaker-spinnaker-halyard-0:/workdir$` 提示符。然后，输入这些命令，将
    `example.com` 替换为你的域名：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last `hal` command will redeploy the Spinnaker application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `hal` 命令将重新部署 Spinnaker 应用程序。
- en: 'Wait 5 minutes for the DNS records to activate and the ALBs to be fully created.
    Once this is done, visit the Spinnaker site via its fully qualified domain name,
    replacing example.com with your domain name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 5 分钟，以便 DNS 记录激活并且 ALB 完全创建。一旦完成，使用其完全合格的域名访问 Spinnaker 网站，将 example.com
    替换为你的域名：
- en: '[http://spinnaker.eks.example.com/](http://spinnaker.eks.example.com/)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://spinnaker.eks.example.com/](http://spinnaker.eks.example.com/)'
- en: You should be redirected to the HTTPS version of the site.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该被重定向到网站的 HTTPS 版本。
- en: Connecting Spinnaker to Jenkins
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Spinnaker 连接到 Jenkins
- en: In order to get Spinnaker to receive artifacts from Jenkins, we must connect
    it using a Jenkins administrator API token. Spinnaker has instructions on this
    that can be found at [https://www.spinnaker.io/setup/ci/jenkins/](https://www.spinnaker.io/setup/ci/jenkins/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Spinnaker 接收来自 Jenkins 的工件，我们必须通过 Jenkins 管理员 API 令牌将其连接。Spinnaker 提供了相关说明，可以在
    [https://www.spinnaker.io/setup/ci/jenkins/](https://www.spinnaker.io/setup/ci/jenkins/)
    上找到。
- en: 'Go to the Jenkins server you used in a previous chapter. Sign in and go to
    the user configuration page at a URL similar to [https://jenkins.example.com/user/admin/configure](https://jenkins.example.com/user/admin/configure)
    (substitute your Jenkins URL for jenkins.example.com). Then, generate an API token
    for Spinnaker:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 进入你在前一章节中使用的 Jenkins 服务器。登录后，转到类似于 [https://jenkins.example.com/user/admin/configure](https://jenkins.example.com/user/admin/configure)
    的用户配置页面（将 jenkins.example.com 替换为你的 Jenkins URL）。然后，生成 Spinnaker 的 API 令牌：
- en: '![](img/B11641_09_005.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_005.jpg)'
- en: Figure 9.5 – Jenkins API token generation
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – Jenkins API 令牌生成
- en: 'As shown in the *Configuring Spinnaker using Halyard* section, connect to the
    `hal` maintenance pod from your local workstation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *使用 Halyard 配置 Spinnaker* 部分所示，从你的本地工作站连接到 `hal` 维护 pod：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, issue these commands in the shell of that pod to configure Jenkins, replacing
    the values to the right of the equals sign for the `BASEURL`, `APIKEY`, and `USERNAME`
    values with those for your installation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在该 pod 的终端中执行这些命令来配置 Jenkins，将 `BASEURL`、`APIKEY` 和 `USERNAME` 右侧的值替换为你安装的相应值：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that Spinnaker is set up to talk to Jenkins, we will move on to configuring
    Jenkins with an additional set of build jobs that Spinnaker will use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Spinnaker 已经配置为与 Jenkins 通信，我们将继续为 Jenkins 配置一组 Spinnaker 将使用的额外构建任务。
- en: Setting up Jenkins to integrate with both Spinnaker and ECR
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Jenkins 与 Spinnaker 和 ECR 的集成
- en: In order to run the Spinnaker-specific jobs and integrate Jenkins with ECR,
    we are going to need to configure Jenkins with additional plugins and credentials
    so that it can push containers to AWS ECR, and also set up a new multi-branch
    pipeline item in order to use the Jenkinsfile for this chapter, stored in the
    GitHub repository as `chapter9/Jenkinsfile`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行 Spinnaker 特定的任务并将 Jenkins 与 ECR 集成，我们需要为 Jenkins 配置额外的插件和凭据，以便它能够将容器推送到
    AWS ECR，并且还需要设置一个新的多分支流水线项目，以便使用存储在 GitHub 仓库中的此章节的 `chapter9/Jenkinsfile`。
- en: In the following sections, we will make all the changes needed to make Jenkins
    work with both ECR and Spinnaker.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进行所有必要的更改，使 Jenkins 能够同时与 ECR 和 Spinnaker 配合使用。
- en: Installing the AWS ECR Jenkins plugin
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 AWS ECR Jenkins 插件
- en: 'Sign in to your Jenkins server as the admin user, and then navigate in the
    left menu to `ECR` into the **Filter** box. You will see something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以管理员身份登录到你的 Jenkins 服务器，然后在左侧菜单中进入 `ECR`，并在 **Filter** 框中查看类似这样的内容：
- en: '![](img/B11641_09_006.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_006.jpg)'
- en: Figure 9.6 – Installing the Amazon ECR plugin through Jenkins Plugin Manager
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 通过 Jenkins 插件管理器安装 Amazon ECR 插件
- en: 'Click on the **Install** checkbox next to the **Amazon ECR** plugin and select
    the **Download now and install after restart** button. You will see something
    as in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **安装** 复选框，选择 **Amazon ECR** 插件旁的 **立即下载并在重启后安装** 按钮。您将看到如下截图：
- en: '![](img/B11641_09_007.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_007.jpg)'
- en: Figure 9.7 – Installation in progress for the Amazon ECR Jenkins plugin
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 正在安装 Amazon ECR Jenkins 插件
- en: It might take Jenkins 5–15 minutes to restart before it is available again.
    Once it is available, sign in again as the Jenkins admin user. Next, we will create
    an AWS IAM user with limited privileges and configure Jenkins with those credentials.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 可能需要 5 到 15 分钟的时间才能重新启动并再次可用。一旦它可用，再次以 Jenkins 管理员用户身份登录。接下来，我们将创建一个具有有限权限的
    AWS IAM 用户，并使用这些凭证配置 Jenkins。
- en: Creating a limited AWS IAM user for Jenkins
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Jenkins 创建一个受限的 AWS IAM 用户
- en: 'In a previous chapter, we used the AWS console to create an administrator IAM
    user for the account. This time, we will use the AWS CLI in order to create a
    Jenkins user, with more limited permissions than the administrator user so that
    it can only manage ECR repositories and push Docker images to those repositories.
    This is in line with the security principle of granting the *least privilege*
    access required for a system only. To create the user, attach the appropriate
    policy, create the access keys, and issue the three `aws iam` commands in the
    following listing to set up the Jenkins user (the output that you should expect
    to see is in line with these commands):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 AWS 控制台为账户创建了一个管理员 IAM 用户。这一次，我们将使用 AWS CLI 来创建一个 Jenkins 用户，赋予其比管理员用户更有限的权限，以便它仅能管理
    ECR 仓库并将 Docker 镜像推送到这些仓库中。这符合最小权限原则，系统应仅授予所需的*最小权限*。要创建该用户，请附加适当的策略，创建访问密钥，并执行以下列出的三个
    `aws iam` 命令来设置 Jenkins 用户（您应预期看到的输出与这些命令一致）：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the values associated with `AccessKeyId` and `SecretAccessKey` in the output
    of your commands. You will need those to configure a Jenkins credential for AWS
    access in the next section. Next, let's configure Jenkins with AWS credentials.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意您命令输出中与 `AccessKeyId` 和 `SecretAccessKey` 相关的值。您需要这些值来在下一节配置 Jenkins 的 AWS
    访问凭证。接下来，让我们使用 AWS 凭证来配置 Jenkins。
- en: Configuring Jenkins with credentials for AWS and ECR
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AWS 和 ECR 凭证配置 Jenkins
- en: We need to tell Jenkins what our AWS credentials are so that it can push the
    Docker containers it builds to ECR. Furthermore, we also need to configure Jenkins
    to know what ECR registry to use. In [*Chapter 6*](B11641_06_Final_NM_ePub.xhtml#_idTextAnchor102),
    *Deploying Applications with Docker Compose*, we configured Jenkins with credentials
    for GitHub and Docker Hub. Now, we will configure additional credentials for the
    AWS IAM user and the ECR container registry.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉 Jenkins 我们的 AWS 凭证，以便它可以将构建的 Docker 容器推送到 ECR。此外，我们还需要配置 Jenkins 以知道使用哪个
    ECR 注册表。在 [*第六章*](B11641_06_Final_NM_ePub.xhtml#_idTextAnchor102)，*使用 Docker Compose
    部署应用程序* 中，我们为 Jenkins 配置了 GitHub 和 Docker Hub 的凭证。现在，我们将为 AWS IAM 用户和 ECR 容器注册表配置额外的凭证。
- en: 'While you are signed into the Jenkins server with the admin user, go to its
    home page and then navigate in the left menu to the `shipit.aws.key` ID, the `ShipIt
    Clicker AWS API Keys` description, and the access key ID and secret access key
    from the previous section. You should see a credential form that looks like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用管理员用户登录 Jenkins 服务器时，进入首页，在左侧菜单中找到 `shipit.aws.key` ID，`ShipIt Clicker AWS
    API Keys` 描述，以及上一节中的访问密钥 ID 和密钥访问密钥。您应该会看到如下的凭证表单：
- en: '![](img/B11641_09_008.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_008.jpg)'
- en: Figure 9.8 – Configuring AWS credentials in Jenkins
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 配置 Jenkins 中的 AWS 凭证
- en: 'Once you have done this, add an additional credential of the `dockerfordevelopers/shipitclicker:0.5.0`
    reference at the end:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在最后添加一个额外的凭证，引用 `dockerfordevelopers/shipitclicker:0.5.0`：
- en: '**Scope**: **Global**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**：**全局**'
- en: '`143970405955.dkr.ecr.us-east-2.amazonaws.com`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`143970405955.dkr.ecr.us-east-2.amazonaws.com`'
- en: '`shipit.ecr.container.id`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shipit.ecr.container.id`'
- en: '`ShipIt Clicker ECR container ID`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShipIt Clicker ECR 容器 ID`'
- en: Save this credential by pressing the **OK** button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 **确定** 按钮保存此凭证。
- en: Now that we have configured Jenkins with the credentials needed to connect to
    AWS and ECR, let's configure a new multi-branch pipeline for the code in this
    chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 Jenkins 配置了连接 AWS 和 ECR 所需的凭证，接下来让我们为本章的代码配置一个新的多分支流水线。
- en: Configuring Jenkins with a multi-branch pipeline for the Jenkinsfile
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Jenkins 使用多分支流水线进行 Jenkinsfile 配置
- en: 'Next, we will configure Jenkins to use an additional multi-branch pipeline
    item that pulls from the same GitHub repository but is configured to use `chapter9/Jenkinsfile`
    instead of the Jenkinsfile at the root of the repository. Sign in to Jenkins,
    and from the home page, navigate to `Spinnaker`, and then configure it with your
    GitHub repo credentials, similar to what is included in the following screenshot
    (replace `PacktPublishing/Docker-for-Developers`with the GitHub organization and
    name of the forked copy of the repository that you set up in [*Chapter 7*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126),
    *Continuous Deployment with Jenkins*):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置 Jenkins 使用一个额外的多分支管道项目，该项目从同一个 GitHub 仓库拉取代码，但配置为使用 `chapter9/Jenkinsfile`，而不是仓库根目录下的
    Jenkinsfile。登录 Jenkins，并从主页导航到 `Spinnaker`，然后使用你的 GitHub 仓库凭证进行配置，类似于以下截图所示（将
    `PacktPublishing/Docker-for-Developers` 替换为你在 [*第 7 章*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126)
    中设置的 GitHub 组织和仓库名称，*使用 Jenkins 进行持续部署*）：
- en: '![](img/B11641_09_009.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_009.jpg)'
- en: Figure 9.9 – Jenkins multi-branch pipeline setup
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – Jenkins 多分支管道设置
- en: After you configure this, the new item should connect to the GitHub repository
    and build and push a container to AWS ECR. Inspect the console output from the
    master branch in this new item to make sure the build succeeds and that the Docker
    image gets pushed to the AWS ECR repository.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，新的项目应能连接到 GitHub 仓库，并将容器构建并推送到 AWS ECR。检查该新项目中的主分支的控制台输出，确保构建成功，并且 Docker
    镜像已推送到 AWS ECR 仓库。
- en: Now that you have configured Jenkins with the ECR plugin, created a Jenkins
    IAM user, configured Jenkins with the credentials for that user, configured Jenkins
    with new credentials to reflect the AWS integration, and added the new Jenkins
    multi-branch setup, you can proceed to connect other services to Spinnaker. Next,
    we will connect GitHub.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用 ECR 插件配置了 Jenkins，创建了一个 Jenkins IAM 用户，配置了该用户的凭证，并且配置了新的凭证以反映 AWS 集成，同时还添加了新的
    Jenkins 多分支设置，那么你可以继续将其他服务连接到 Spinnaker。接下来，我们将连接 GitHub。
- en: Connecting Spinnaker to GitHub
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Spinnaker 连接到 GitHub
- en: We will follow the guidance from [https://www.spinnaker.io/setup/artifacts/github/](https://www.spinnaker.io/setup/artifacts/github/)
    to connect Spinnaker to Jenkins so that it can read artifacts from GitHub. Go
    to your GitHub user account and, in **Developer Settings**, generate an access
    token for Spinnaker with repo scope.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照 [https://www.spinnaker.io/setup/artifacts/github/](https://www.spinnaker.io/setup/artifacts/github/)
    上的指导，将 Spinnaker 连接到 Jenkins，以便它能够从 GitHub 读取工件。前往你的 GitHub 用户账户，在 **Developer
    Settings** 中生成一个带有 repo 范围的访问 token，供 Spinnaker 使用。
- en: 'From your local workstation, connect to the Halyard maintenance pod, as shown
    in the *Configuring Spinnaker using Halyard* section, put the GitHub token in
    a file in the home directory, and then issue the following commands (replacing
    `xxxx` with your GitHub token and `my-github-user` with your GitHub username):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的本地工作站，连接到 Halyard 维护 pod，如 *使用 Halyard 配置 Spinnaker* 部分所示，将 GitHub token
    放入主目录下的一个文件中，然后执行以下命令（将 `xxxx` 替换为你的 GitHub token，将 `my-github-user` 替换为你的 GitHub
    用户名）：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you have done this, Spinnaker should be able to talk to GitHub. Next, we
    will connect Spinnaker to Docker Hub.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，Spinnaker 应该能够与 GitHub 通信。接下来，我们将把 Spinnaker 连接到 Docker Hub。
- en: Connecting Spinnaker to Docker Hub
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Spinnaker 连接到 Docker Hub
- en: You will also need to connect Spinnaker to Docker Hub so that it can read your
    repository and the `library/redis` repository. Integrating Spinnaker with Docker
    Hub requires you to whitelist all the repositories that your templates will use.
    The default Docker Hub integration has a short whitelist of the most common libraries.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将 Spinnaker 连接到 Docker Hub，以便它可以读取你的仓库和 `library/redis` 仓库。将 Spinnaker 集成到
    Docker Hub 需要你将所有模板使用的仓库列入白名单。默认的 Docker Hub 集成有一个短小的白名单，包含最常用的库。
- en: We will follow the guidance from [https://www.spinnaker.io/setup/install/providers/docker-registry/](https://www.spinnaker.io/setup/install/providers/docker-registry/)
    in order to add Docker Hub to Spinnaker.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照 [https://www.spinnaker.io/setup/install/providers/docker-registry/](https://www.spinnaker.io/setup/install/providers/docker-registry/)
    上的指导，将 Docker Hub 添加到 Spinnaker。
- en: Log in to your Docker Hub account and generate a new API token for the Spinnaker
    installation from [https://hub.docker.com/settings/security](https://hub.docker.com/settings/security).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到你的 Docker Hub 账户，并从 [https://hub.docker.com/settings/security](https://hub.docker.com/settings/security)
    为 Spinnaker 安装生成一个新的 API token。
- en: 'From your local workstation, connect to the Halyard maintenance pod:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的本地工作站，连接到 Halyard 维护 pod：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, issue the following commands (replacing `xxxx` with your Docker Hub token
    and `my-dockerhub-user` with your Docker Hub username):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下命令（将 `xxxx` 替换为您的 Docker Hub 令牌，将 `my-dockerhub-user` 替换为您的 Docker Hub
    用户名）：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once Docker Hub is connected, you are ready to start setting up an application
    and pipeline in Spinnaker. But before we do that, let's talk about how to troubleshoot
    Spinnaker issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接了 Docker Hub，您就可以开始在 Spinnaker 中设置应用程序和流水线。但在此之前，让我们谈谈如何排除 Spinnaker 问题。
- en: Troubleshooting Spinnaker issues
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除 Spinnaker 问题
- en: If you have any difficulties getting a Spinnaker pipeline execution to work,
    or have other issues setting up and configuring Spinnaker, the user interface
    has minimal error-reporting capabilities. It can seem opaque and daunting.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使 Spinnaker 流水线执行工作时遇到任何困难，或者在设置和配置 Spinnaker 方面有其他问题，用户界面具有最少的错误报告能力。它可能看起来不透明且令人生畏。
- en: For example, let's imagine you have a typo in one of your artifact definitions
    – for example, [gitgub.com](http://gitgub.com) instead of [github.com](http://github.com).
    The pipeline might fail when it tries to retrieve that artifact due to a hostname
    failure lookup.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您在其中一个 artifact 定义中有拼写错误 – 例如，[gitgub.com](http://gitgub.com) 而不是 [github.com](http://github.com)。由于主机名查找失败，当流水线尝试检索该
    artifact 时可能会导致流水线失败。
- en: 'Rather than trying to figure out which of the Spinnaker pods might have recorded
    an error, you can just tail all the logs of all the Spinnaker pods at once:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是尝试找出 Spinnaker pods 中可能记录了错误的哪一个，您可以同时查看所有 Spinnaker pods 的所有日志：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you search your console output for the word `exception`, you may find a
    clue, such as this one found when troubleshooting Spinnaker:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在控制台输出中搜索 `exception` 这个词，您可能会找到一些线索，比如在排除 Spinnaker 问题时找到的这个：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Analyzing log files like this can really get you out of a jam. Next up, we will
    deploy ShipIt Clicker with Spinnaker.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 分析类似这样的日志文件确实可以帮助您摆脱困境。接下来，我们将使用 Spinnaker 部署 ShipIt Clicker。
- en: Deploying ShipIt Clicker with a simple deployment strategy in Spinnaker
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单的部署策略在 Spinnaker 中部署 ShipIt Clicker
- en: Let's get our hands dirty with Spinnaker by deploying our ShipIt Clicker application.
    For this, we will be using Helm Charts, and we will use the version of the application
    in the `chapter9` directory.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过部署我们的 ShipIt Clicker 应用程序来深入了解 Spinnaker。为此，我们将使用 Helm Charts，并使用 `chapter9`
    目录中的应用程序版本。
- en: Spinnaker requires Helm archive files to operate
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 需要 Helm 存档文件来运行
- en: In order to simplify the deployment of the Helm Charts, we have created an archive
    of the `chapter9/shipitclicker` Helm Chart directory in `chapter9/helm.tar.gz`,
    as Spinnaker expects an archive in this format as one of its inputs. We could
    instead output this archive to an AWS S3 object, or even as a GitHub release artifact,
    but that is beyond the scope of this chapter. If you change the Helm Charts in
    the `chapter9/shipitclicker` directory, be sure to update the `helm.tar.gz` archive
    and commit and push it before building with Spinnaker.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Helm Charts 的部署，我们已经在 `chapter9/helm.tar.gz` 中创建了 `chapter9/shipitclicker`
    Helm Chart 目录的归档文件，因为 Spinnaker 期望将此格式的归档文件作为其输入之一。我们也可以将此归档文件输出到 AWS S3 对象，甚至作为
    GitHub 发布 artifact，但这超出了本章的范围。如果您更改 `chapter9/shipitclicker` 目录中的 Helm Charts，请务必更新
    `helm.tar.gz` 归档文件并在使用 Spinnaker 构建之前进行提交和推送。
- en: Adding a Spinnaker application
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个 Spinnaker 应用程序
- en: 'Go to your Spinnaker installation in the web browser at [https://spinnaker.eks.example.com](https://spinnaker.eks.example.com)
    (replacing example.com with your domain). Add an application called `shipandspin`,
    then, in `Docker-for-Developers` code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中转到您的 Spinnaker 安装地址 [https://spinnaker.eks.example.com](https://spinnaker.eks.example.com)（将
    example.com 替换为您的域名）。添加一个名为 `shipandspin` 的应用程序，然后，在 `Docker-for-Developers` 代码中：
- en: '![](img/B11641_09_010.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_010.jpg)'
- en: Figure 9.10 – The New Application dialog in Spinnaker
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – Spinnaker 中的新应用对话框
- en: When you submit this form, it will take you to an infrastructure definition
    form. Stop here, and do not fill in or submit the infrastructure definition form.
    This form is intended for other types of Spinnaker deployments, not for Kubernetes-centric
    deployments. When you deploy your application, it will define infrastructure in
    Kubernetes that Spinnaker understands.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提交此表单时，它将带您进入一个基础设施定义表单。在此停止，并不要填写或提交基础设施定义表单。此表单适用于其他类型的 Spinnaker 部署，而不是专注于
    Kubernetes 的部署。当您部署应用程序时，它将定义 Spinnaker 在 Kubernetes 中理解的基础设施。
- en: Adding a Spinnaker pipeline
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个 Spinnaker 流水线
- en: 'Navigate to the **PIPELINES** screen:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 **流水线** 屏幕：
- en: '![](img/B11641_09_011.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_011.jpg)'
- en: Figure 9.11 – A PIPELINES screen example in Spinnaker
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – Spinnaker中的PIPELINES屏幕示例
- en: Create a pipeline called `shipit-eks-staging`, and then add two artifacts –
    one for the Helm Chart and one for a `values-spin.yaml` override.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`shipit-eks-staging`的管道，然后添加两个工件——一个是Helm Chart，另一个是`values-spin.yaml`覆盖。
- en: 'For the first one, pick the GitHub account, give it the `chapter9/helm.tar.gz`
    Helm artifact, and click **Use Default Artifact**. Then, give it the full URL
    of the artifact from the API, changing this to match your account and repository
    name (double-check that this is correct before submitting):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个，选择GitHub帐户，给它`chapter9/helm.tar.gz` Helm工件，并点击**使用默认工件**。然后，提供该工件的完整API
    URL，并将其更改为匹配你的帐户和仓库名称（提交前请仔细检查是否正确）：
- en: '[https://api.github.com/repos/PacktPublishing/Docker-for-Developers/contents/chapter9/helm.tar.gz](https://api.github.com/repos/PacktPublishing/Docker-for-Developers/contents/chapter9/helm.tar.gz)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://api.github.com/repos/PacktPublishing/Docker-for-Developers/contents/chapter9/helm.tar.gz](https://api.github.com/repos/PacktPublishing/Docker-for-Developers/contents/chapter9/helm.tar.gz)'
- en: 'Tell it to use the `staging` branch. It will look something like this when
    you have defined it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉它使用`staging`分支。定义后，它应该看起来像这样：
- en: '![](img/B11641_09_012.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_012.jpg)'
- en: 'Figure 9.12 – Overriding the artifact: Helm Chart archive in Spinnaker'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – Spinnaker中覆盖工件：Helm Chart归档
- en: 'Give it another artifact for the `chapter9/values-spin.yaml` override file.
    Set the `chapter9/values-spin.yaml` file path and the `values-spin.yaml` display
    name, select `staging` for the branch (replace`PacktPublishing/Docker-for-Developers`with
    the GitHub organization and name of the forked copy of the repository that you
    set up in [*Chapter 7*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126), *Continuous
    Deployment with Jenkins*):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为`chapter9/values-spin.yaml`覆盖文件添加另一个工件。设置`chapter9/values-spin.yaml`文件路径和`values-spin.yaml`显示名称，选择`staging`分支（将`PacktPublishing/Docker-for-Developers`替换为你在[*第7章*](B11641_07_Final_AM_ePub.xhtml#_idTextAnchor126)中设置的GitHub组织和分叉仓库的名称，*使用Jenkins进行持续部署*）：
- en: '![](img/B11641_09_013.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_013.jpg)'
- en: 'Figure 9.13 – Overriding the artifact: Helm Chart archive in Spinnaker'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – Spinnaker中覆盖工件：Helm Chart归档
- en: 'Then, configure `build.properties` for **Property File**, which is a Jenkins
    archived file that this will use to get the version of the container that Jenkins
    built:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，配置`build.properties`文件用于**属性文件**，这是一个Jenkins归档文件，Spinnaker将使用它来获取Jenkins构建的容器版本：
- en: '![](img/B11641_09_014_New.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_014_New.jpg)'
- en: Figure 9.14 – The Jenkins Automated Triggers screen in Spinnaker
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – Spinnaker中Jenkins自动触发器屏幕
- en: Go to the bottom of the form and save the **Configuration** stage.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前往表单底部并保存**配置**阶段。
- en: Now, let's add the next stage, which creates the Kubernetes manifest from the
    Helm Charts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加下一个阶段，创建来自Helm Charts的Kubernetes清单。
- en: Adding the Bake (Manifest) stage
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加Bake（Manifest）阶段
- en: After you have saved the configuration stage, you will still be at the bottom
    of the very long stage-definition web form. Go back to the top of the form and
    add an additional stage of the `shipit-staging` name and tell it to deploy to
    the default namespace. Give it a **Template Artifact** setting of **helm.tar.gz**.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 保存配置阶段后，你仍然会停留在非常长的阶段定义网页表单底部。返回表单顶部，添加一个名为`shipit-staging`的额外阶段，并告诉它部署到默认命名空间。为它设置一个**模板工件**，值为**helm.tar.gz**。
- en: For `image.repository` name and the `${trigger["properties"]["imageName"]}`
    value. Add an override key-value pair with the `ingress.hosts[0].host` name and
    the shipit-stage.eks.example.com value, replacing example.com with your domain
    name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`image.repository`名称和`${trigger["properties"]["imageName"]}`值，添加一个覆盖键值对，键为`ingress.hosts[0].host`，值为shipit-stage.eks.example.com，将example.com替换为你的域名。
- en: 'We will set up a Route 53 DNS entry for the Ingress Controller that this creates
    as soon as it is deployed. The form should look something like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此部署的Ingress Controller上设置一个Route 53 DNS条目。表单应该类似于以下内容：
- en: '![](img/B11641_09_015.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_015.jpg)'
- en: Figure 9.15 – The Bake (Manifest) template renderer configuration screen in
    Spinnaker
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – Spinnaker中Bake（Manifest）模板渲染器配置屏幕
- en: 'Then, at the bottom of the form, in the `kube-templates.yaml` and save the
    form. It should look something like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在表单底部，编辑`kube-templates.yaml`并保存表单。它应该看起来像这样：
- en: '![](img/B11641_09_016.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_016.jpg)'
- en: Figure 9.16 – The Bake (Manifest) Produces Artifacts section in Spinnaker
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – Spinnaker中的Bake（Manifest）生成工件部分
- en: Configuring this stage will set up the Helm template-rendering process. Then,
    save the form. Next, we will set up the **Deploy (Manifest)** stage.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 配置此阶段将设置 Helm 模板渲染过程。然后保存表单。接下来，我们将设置 **Deploy (Manifest)** 阶段。
- en: Adding the Deploy (Manifest) stage
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加部署（Manifest）阶段
- en: 'After you have saved the previous configuration change, go to the top of the
    configuration form again and add another stage, `kube-templates.yaml` for **Manifest
    Artifact** to deploy. Do not select the **Rollout Strategy Options** setting,
    as this only works if you have one ReplicaSet and forego using **Deployments**
    as a Kubernetes controller. It will look something like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存了上述配置更改之后，再次返回配置表单顶部，添加另一个阶段，`kube-templates.yaml` 用于 **Manifest Artifact**
    进行部署。不要选择 **Rollout Strategy Options** 设置，因为这仅适用于只有一个 ReplicaSet 并放弃使用 **Deployments**
    作为 Kubernetes 控制器的情况。它会类似于这样：
- en: '![](img/B11641_09_017.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_017.jpg)'
- en: Figure 9.17 – Deploy (Manifest) Configuration in Spinnaker
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – Spinnaker 中部署（Manifest）配置
- en: Now, we are ready to trigger a deployment. Click on **PIPELINES** at the top
    of the screen and click on the **Start Manual Execution** link. It should reach
    out to GitHub for the latest build, and then bake the manifest using Helm Charts
    and deploy.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备触发部署。在屏幕顶部单击 **PIPELINES**，然后单击 **Start Manual Execution** 链接。它应该会从 GitHub
    获取最新构建，然后使用 Helm Charts 烘焙清单并部署。
- en: 'Because we used Jenkins to emit a `build.properties` file and used a `image.repository`
    field in the template, we will be using the specific container that the Jenkins
    job connected to the trigger built. Refer to the following link for more information
    on SPEL expressions and Spinnaker pipelines:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用 Jenkins 发布了一个 `build.properties` 文件，并在模板中使用了 `image.repository` 字段，所以我们将使用
    Jenkins 作业连接的触发器构建的特定容器。有关 SPEL 表达式和 Spinnaker 流水线的更多信息，请参考以下链接：
- en: '[https://www.spinnaker.io/guides/user/pipeline/expressions/](https://www.spinnaker.io/guides/user/pipeline/expressions/)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.spinnaker.io/guides/user/pipeline/expressions/](https://www.spinnaker.io/guides/user/pipeline/expressions/)'
- en: 'There might be some issues that you need to troubleshoot, particularly if you
    have made a typo in some of the required configurations. If all goes well, it
    should look something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在某些必需配置中有拼写错误，可能需要解决一些问题。如果一切顺利，它应该看起来类似于这样：
- en: '![](img/B11641_09_018.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_09_018.jpg)'
- en: Figure 9.18 – Pipelines showing a completed job in Spinnaker
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – Spinnaker 中显示已完成作业的流水线
- en: You can then explore the **Execution Details** and **INFRASTRUCTURE** panes,
    as Spinnaker will show you some information about the running application. It
    can even show you the logs from your running pods.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看 **Execution Details** 和 **INFRASTRUCTURE** 面板，因为 Spinnaker 将显示有关正在运行的应用程序的一些信息。它甚至可以显示您运行的
    Pod 的日志。
- en: Setting up a DNS entry for the Ingress Controller
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Ingress 控制器设置 DNS 记录条目
- en: To see the running application from the outside, you will need to set up a DNS
    entry. Issue the `kubectl get ingress` command to determine the DNS alias of the
    Ingress Controller for `shipit-eks-staging`, and then set up the DNS alias in
    Route 53 for your domain to match the override you set up for shipit-stage.eks.example.com
    (replacing example.com with your domain).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要从外部查看正在运行的应用程序，您需要设置 DNS 记录。发出 `kubectl get ingress` 命令以确定 `shipit-eks-staging`
    的 Ingress 控制器的 DNS 别名，然后在 Route 53 中设置 DNS 别名，以匹配您为 shipit-stage.eks.example.com
    设置的覆盖（将 example.com 替换为您的域名）。
- en: You should be able to visit [https://shipit-stage.eks.example.com/](https://shipit-staging.eks.example.com/)
    (replacing example.com with your domain) once this is complete and see the running
    ShipIt Clicker game.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该能够访问 [https://shipit-stage.eks.example.com/](https://shipit-staging.eks.example.com/)（将
    example.com 替换为您的域名），并查看运行中的 ShipIt Clicker 游戏。
- en: Next up, we will learn about Spinnaker's support for different types of deployments
    and how they apply (or don't apply) to Kubernetes deployments.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解 Spinnaker 对不同类型部署的支持及其在 Kubernetes 部署中的应用（或不适用）。
- en: Surveying Spinnaker's deployment and testing features
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览 Spinnaker 的部署和测试功能
- en: In the introduction to Spinnaker earlier in this chapter, we noted that you
    would have the opportunity to learn more about the various deployment methodologies
    available to you. Let's now dig into these concepts, including canary and red/black
    deployments, and describe their relevance to Spinnaker when used to manage Kubernetes
    deployments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候关于 Spinnaker 的介绍中，我们指出您将有机会了解可用的各种部署方法。现在让我们深入探讨这些概念，包括金丝雀和红/黑部署，并描述它们在使用
    Spinnaker 管理 Kubernetes 部署时的相关性。
- en: Canary deployments
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: Canary deployment is a method of exposing an application to its users where
    you run a subset of the traffic for the application through a new deployment while
    keeping most of the traffic for the application going to the currently deployed
    version. This can help you test whether the new version is suitable for production
    use without immediately funneling all the traffic through.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀部署是一种将应用程序暴露给用户的方法，你可以在新版本的部署中运行一部分流量，同时大部分流量仍然流向当前部署的版本。这可以帮助你测试新版本是否适合生产环境，而无需立即将所有流量都导向新版本。
- en: The Kubernetes v2 Spinnaker provider does not support canary deployments
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes v2 Spinnaker 提供程序不支持金丝雀部署。
- en: Although this is one of Spinnaker's most desired features, the Kubernetes v2
    cloud provider does not support canary deployments, so we won't use it for ShipIt
    Clicker. If we were using a non-Kubernetes cloud provider, such as the AWS, Google
    Compute Engine, or an Azure provider, this would be a more natural pattern to
    use. See [https://spinnaker.io/setup/install/providers/](https://spinnaker.io/setup/install/providers/)
    for the full list of Spinnaker cloud providers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是 Spinnaker 最受欢迎的特性之一，但 Kubernetes v2 云提供程序不支持金丝雀部署，因此我们不会在 ShipIt Clicker
    中使用它。如果我们使用的是非 Kubernetes 云提供程序，例如 AWS、Google Compute Engine 或 Azure 提供程序，那么这将是一个更自然的模式。有关
    Spinnaker 云提供程序的完整列表，请参阅 [https://spinnaker.io/setup/install/providers/](https://spinnaker.io/setup/install/providers/)。
- en: Red/black deployments
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红/黑部署
- en: Let's now look at how the red/black deployment methodologies work. This is another
    name for the better-known blue/green deployment strategy. With a red/black strategy,
    you keep two sets of servers or containers available during a deployment, with
    traffic flowing to only one at a time. Let's say red is taking traffic when the
    deployment begins. During the deployment, you would deploy to black. Once the
    health checks pass, you switch traffic to black, but keep red around so that if
    anything goes wrong, you can switch traffic back to red without having to redeploy.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看红/黑部署方法是如何工作的。这是另一种为人熟知的蓝/绿部署策略的名称。在红/黑策略中，部署期间会保持两组服务器或容器可用，流量每次只会流向其中一个。假设在部署开始时，红组接收流量。在部署过程中，你将部署到黑组。一旦健康检查通过，你就会将流量切换到黑组，但仍保留红组，以便如果出现问题，你可以将流量切换回红组，而无需重新部署。
- en: 'Spinnaker announced support for red/black deployments through the Kubernetes
    v2 provider in 2019:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 于 2019 年宣布通过 Kubernetes v2 提供程序支持红/黑部署：
- en: '[https://blog.spinnaker.io/introducing-rollout-strategies-in-the-kubernetes-v2-provider-8bbffea109a](https://blog.spinnaker.io/introducing-rollout-strategies-in-the-kubernetes-v2-provider-8bbffea109a)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blog.spinnaker.io/introducing-rollout-strategies-in-the-kubernetes-v2-provider-8bbffea109a](https://blog.spinnaker.io/introducing-rollout-strategies-in-the-kubernetes-v2-provider-8bbffea109a)'
- en: 'However, this has some significant limitations. It means you can''t use the
    Kubernetes deployment objects and must instead use the lower-level ReplicaSet
    annotations. The Helm Chart generator produces a skeleton with a deployment in
    it that sits atop ReplicaSets, so if you want to use the Spinnaker red/black support
    with Kubernetes, you will have to alter your Helm Charts significantly. Refer
    to this advice on the Kubernetes v2 provider:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有一些显著的限制。它意味着你不能使用 Kubernetes 部署对象，而必须改用低级别的 ReplicaSet 注释。Helm Chart 生成器会生成一个带有部署的框架，它是建立在
    ReplicaSets 之上的，因此如果你希望使用 Spinnaker 的红/黑支持与 Kubernetes 配合使用，你将需要对 Helm Charts
    进行大幅度的修改。请参考关于 Kubernetes v2 提供程序的建议：
- en: https://www.spinnaker.io/guides/user/kubernetes-v2/traffic-management/#you-must-use-replica-sets
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.spinnaker.io/guides/user/kubernetes-v2/traffic-management/#you-must-use-replica-sets
- en: 'What Spinnaker *does* support for Kubernetes deployments that only use ReplicaSets
    are the following deployment strategies:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker *确实*支持的 Kubernetes 部署（仅使用 ReplicaSets）部署策略如下：
- en: '**Dark**: Deploy to a new ReplicaSet that is not connected to the live load
    balancer.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暗部署**：部署到一个新的 ReplicaSet，该 ReplicaSet 不连接到实时负载均衡器。'
- en: '**Red/black**: Deploy a new ReplicaSet and switch back and forth between the
    new and old sets using Spinnaker.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红/黑**：部署一个新的 ReplicaSet，并使用 Spinnaker 在新旧两组之间来回切换。'
- en: '**Highlander**: Deploy a new ReplicaSet and destroy the old one as soon as
    the new one starts taking traffic (there can be only one ReplicaSet).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Highlander**：部署一个新的 ReplicaSet，并在新的 ReplicaSet 开始接收流量时销毁旧的 ReplicaSet（只能有一个
    ReplicaSet）。'
- en: If you are using the Kubernetes deployment controller, the behavior you will
    get is very similar to the Spinnaker Highlander strategy. So, you may not need
    to use the Spinnaker support for advanced deployment strategies if you are using
    Kubernetes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Kubernetes 部署控制器，那么你将获得类似于 Spinnaker Highlander 策略的行为。因此，如果你使用 Kubernetes，可能不需要使用
    Spinnaker 支持的高级部署策略。
- en: Rolling back
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚
- en: So, what happens if a deployment fails? Well, we will need to roll back to our
    previous release in a safe fashion. For the style of deployment where Spinnaker
    manages deploying machine images, it orchestrates this rollback. However, with
    the Kubernetes operator, it relies on the Kubernetes deployment mechanisms that
    use liveness and readiness probes in order to check that a deployment is valid.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果部署失败会发生什么呢？我们将需要以安全的方式回滚到之前的版本。对于 Spinnaker 管理机器镜像部署的方式，它会协调此回滚。然而，对于 Kubernetes
    操作员，它依赖于 Kubernetes 部署机制，使用存活和就绪探针来检查部署是否有效。
- en: 'Spinnaker does have some support for undoing a rollout of a set of templates
    directly through its interface. However, this may not work if all the resources
    in the templates do not have independent revisions, such as separately versioned
    and tagged Docker containers. See here for more information about rollbacks with
    Spinnaker and Kubernetes:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 确实支持通过其界面直接撤销一组模板的发布。然而，如果模板中的所有资源没有独立的版本修订（例如，单独版本和标记的 Docker 容器），这可能不起作用。有关
    Spinnaker 和 Kubernetes 回滚的更多信息，请参见此处：
- en: '[https://www.spinnaker.io/guides/user/kubernetes-v2/automated-rollbacks/](https://www.spinnaker.io/guides/user/kubernetes-v2/automated-rollbacks/)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.spinnaker.io/guides/user/kubernetes-v2/automated-rollbacks/](https://www.spinnaker.io/guides/user/kubernetes-v2/automated-rollbacks/)'
- en: Testing with Spinnaker
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spinnaker 进行测试
- en: With Spinnaker, you can either use a manual judgement stage to provide time
    for people to do a manual test on an application or you can use a scripted pipeline
    stage to run an automated test suite in Jenkins versus your application. If you
    are deploying to multiple environments or using the red/black strategies, this
    can give you a better opportunity to execute tests versus your application before
    deploying it to production or exposing it to the world.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spinnaker 时，你可以使用手动判断阶段为人员提供时间对应用程序进行手动测试，或者使用脚本化流水线阶段在 Jenkins 中运行自动化测试套件以测试你的应用程序。如果你在多个环境中部署或使用红/黑策略，这能给你更好的机会在将应用程序部署到生产环境或公开给世界之前执行测试。
- en: You can find more information on testing using either one of these strategies
    in their respective Spinnaker documentation at [https://www.spinnaker.io/guides/tutorials/codelabs/safe-deployments/](https://www.spinnaker.io/guides/tutorials/codelabs/safe-deployments/)
    and [https://www.spinnaker.io/setup/features/script-stage/](https://www.spinnaker.io/setup/features/script-stage/).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在各自的 Spinnaker 文档中找到更多关于使用这两种策略进行测试的信息，文档地址为 [https://www.spinnaker.io/guides/tutorials/codelabs/safe-deployments/](https://www.spinnaker.io/guides/tutorials/codelabs/safe-deployments/)
    和 [https://www.spinnaker.io/setup/features/script-stage/](https://www.spinnaker.io/setup/features/script-stage/)。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored the topic of continuous deployment in AWS using
    the Spinnaker framework. We started by configuring Spinnaker to work with Jenkins,
    GitHub, AWS ECR, and Docker Hub. Then, we used it to deploy the ShipIt Clicker
    application to Kubernetes on EKS, securing both Spinnaker and the ShipIt Clicker
    application with SSL.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 Spinnaker 框架在 AWS 中进行持续部署的主题。我们首先配置了 Spinnaker，使其与 Jenkins、GitHub、AWS
    ECR 和 Docker Hub 配合使用。然后，我们使用它将 ShipIt Clicker 应用程序部署到 EKS 上的 Kubernetes，同时为 Spinnaker
    和 ShipIt Clicker 应用程序配置了 SSL 安全。
- en: Following this, we learned about some advanced deployment strategies that Spinnaker
    offers, and what some of the trade-offs are that you would have to make when configuring
    your Kubernetes-driven Docker application to take advantage of them. We also learned
    how you can trigger the execution of tests (manual or automated) via Spinnaker.
    By using the lessons learned in this chapter in practice, you can construct continuous
    deployment systems that use a combination of simple Jenkins build jobs and Spinnaker
    pipelines to deploy Docker applications to Kubernetes. The skills you have acquired
    related to integrating Spinnaker with Kubernetes are also applicable to integrating
    other software packages with Kubernetes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们了解了 Spinnaker 提供的一些高级部署策略，以及在配置基于 Kubernetes 的 Docker 应用程序以利用这些策略时可能需要做出的一些权衡。我们还了解了如何通过
    Spinnaker 触发测试的执行（手动或自动）。通过实践中学到的这些章节中的经验，你可以构建使用简单 Jenkins 构建任务和 Spinnaker 流水线将
    Docker 应用程序部署到 Kubernetes 的持续部署系统。你所掌握的关于将 Spinnaker 与 Kubernetes 集成的技能也适用于将其他软件包与
    Kubernetes 集成。
- en: In the next chapter, we will explore monitoring our Docker containers with Prometheus,
    Grafana, and Jaeger.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 Prometheus、Grafana 和 Jaeger 监控我们的 Docker 容器。
- en: Further reading
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Use the following resources to expand your knowledge of Spinnaker and EKS:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下资源扩展你对 Spinnaker 和 EKS 的知识：
- en: 'Spinnaker is not a build server, and other misconceptions: [https://www.armory.io/blog/spinnaker-is-not-a-build-server-and-other-misconceptions/](https://www.armory.io/blog/spinnaker-is-not-a-build-server-and-other-misconceptions/)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spinnaker 不是一个构建服务器，以及其他误解：[https://www.armory.io/blog/spinnaker-is-not-a-build-server-and-other-misconceptions/](https://www.armory.io/blog/spinnaker-is-not-a-build-server-and-other-misconceptions/)
- en: 'An AWS blog post describing a full installation of Kubernetes and Spinnaker
    with Jenkins and ECR: [https://aws.amazon.com/blogs/opensource/deployment-pipeline-spinnaker-kubernetes/](https://aws.amazon.com/blogs/opensource/deployment-pipeline-spinnaker-kubernetes/)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 的一篇博客文章，描述了如何使用 Jenkins 和 ECR 完全安装 Kubernetes 和 Spinnaker 的部署流水线：[https://aws.amazon.com/blogs/opensource/deployment-pipeline-spinnaker-kubernetes/](https://aws.amazon.com/blogs/opensource/deployment-pipeline-spinnaker-kubernetes/)
- en: 'A good article on how Kubernetes services are exposed to the world: [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇关于如何将 Kubernetes 服务暴露给世界的好文章：[https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
- en: 'The AWS official documentation on the ALB Ingress Controller: [https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html](https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 官方文档关于 ALB Ingress 控制器：[https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html](https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html)
- en: 'The Spinnaker CLI: [https://www.spinnaker.io/guides/spin/](https://www.spinnaker.io/guides/spin/)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spinnaker CLI：[https://www.spinnaker.io/guides/spin/](https://www.spinnaker.io/guides/spin/)
- en: 'A Kubernetes external DNS provider that you can use to annotate your templates
    to avoid having to manually set up DNS aliases: [https://github.com/kubernetes-sigs/external-dns](https://github.com/kubernetes-sigs/external-dns)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 外部 DNS 提供者，你可以使用它来注释你的模板，以避免手动设置 DNS 别名：[https://github.com/kubernetes-sigs/external-dns](https://github.com/kubernetes-sigs/external-dns)
- en: 'Spinnaker is not the only advanced Kubernetes-aware CD system you should be
    aware of; you might consider these other alternatives as well, and carry out fresh
    research on this topic as this landscape is changing rapidly:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 不是你应该了解的唯一先进的 Kubernetes 感知 CD 系统；你还应考虑其他替代方案，并在这个领域进行新的研究，因为这个领域变化迅速：
- en: 'Jenkins-X – an opinionated Kubernetes-focused CI/CD system: [https://jenkins-x.io/](https://jenkins-x.io/)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins-X – 一个以 Kubernetes 为中心的 CI/CD 系统的权威性意见：[https://jenkins-x.io/](https://jenkins-x.io/)
- en: 'Argo Project – workflows, CD, and more. A CNCF project at the incubating stage
    as of July 2020: [https://argoproj.github.io/](https://argoproj.github.io/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo Project – 工作流、CD 等。作为 2020 年 7 月孵化阶段的 CNCF 项目：[https://argoproj.github.io/](https://argoproj.github.io/)
- en: 'WeaveWorks – a GitOps system for CD using Kubernetes: [https://www.weave.works/technologies/ci-cd-for-kubernetes/](https://www.weave.works/technologies/ci-cd-for-kubernetes/)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeaveWorks – 一个使用 Kubernetes 进行 CD 的 GitOps 系统：[https://www.weave.works/technologies/ci-cd-for-kubernetes/](https://www.weave.works/technologies/ci-cd-for-kubernetes/)
