<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Application Container Management</h1></div></div></div><p>In this lesson, we will scale one of the containers we built into a multi-tier setup. This will involve splitting the application into different logical sections. For example, we could have an application running on a Docker container and the application's data in a separate database container; however, both should work as a single entity. For this, we will use Docker's tool for running multi-container applications. The tool goes by the name <code class="literal">docker-compose</code>. In summary, <code class="literal">docker-compose</code> is the tool used for defining and running multi-container Docker applications.</p><div><div><div><div><h1 class="title"><a id="ch03lvl4sec06"/>Lesson Objectives</h1></div></div></div><p>By the end of this lesson, you will be able to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get an overview of a multi-container application setup</li><li class="listitem" style="list-style-type: disc">Work through the <code class="literal">docker-compose</code> file and CLI</li><li class="listitem" style="list-style-type: disc">Manage multiple containers and distributed application bundles</li><li class="listitem" style="list-style-type: disc">Set up a network with <code class="literal">docker-compose</code></li><li class="listitem" style="list-style-type: disc">Handle and debug the different application layers</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>The docker-compose Tool</h1></div></div></div><p>Let's begin the lesson by looking at what <a class="indexterm" id="id47"/>a multi-container setup is, why it is important, and how Docker, with the tool <code class="literal">docker-compose</code>, works like a charm in such scenarios.</p><p>We have recently been introduced to how applications work, with their separate elements: frontend, backend, and database.</p><p>To run <a class="indexterm" id="id48"/>such a multi-tier application using Docker, one would need to run the following commands to spin up the containers in different terminal sessions:</p><div><pre class="programlisting">
<code class="literal">- docker run &lt;front-end&gt;</code>
- docker run &lt;back-end&gt;
- docker run &lt;database&gt;</pre></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>You can run <code class="literal">docker run</code> with (<code class="literal">-d</code>) as detached to prevent us from running the three commands in separate sessions, for example: <code class="literal">docker run &lt;front-end&gt; -d</code>
</p><p>That said, it even becomes particularly tasking linking different containers (networking).</p><p>
<code class="literal">docker-compose</code> comes in to save the day. We can define and run multi-containers from one file - <code class="literal">docker-compose.yml</code>. In the following topics, we'll discuss this further. First, let's install it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Installing docker-compose</h2></div></div></div><p>If you went <a class="indexterm" id="id49"/>through the installation of Docker in <em>Lesson 1</em>, <em>Images and Containers,</em> <code class="literal">docker-compose</code> was most likely installed with Docker. To confirm this, run <code class="literal">docker-compose</code> in your terminal.</p><p>If the command is recognized, you should have an output like the following:</p><div><img alt="Installing docker-compose" src="img/image02_01.jpg"/></div><p>Windows users<a class="indexterm" id="id50"/> should install the Community Edition of Docker to install <code class="literal">docker-compose</code> alongside it. Docker Toolbox includes <code class="literal">docker-compose</code> in its installation.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>For further <code class="literal">docker-compose </code>installation steps, check out the documentation at: <a class="ulink" href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a>.</p><p>While on this subject, please note the various ways of uninstalling it. In order to uninstall the program:</p><p>Go to <strong>Programs and Features</strong>.</p><p>Look for Docker, right-click, and <strong>Uninstall</strong>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Overview of a Multi-Container Application Setup</h1></div></div></div><p>In the <a class="indexterm" id="id51"/>previous lesson, we introduced Docker and containerization. We ran sample Python and JavaScript scripts as demonstrations of how applications can be containerized and how images can be built. We are now ready to run an application that goes beyond that.</p><p>In a Dockerfile, every line describes a layer. The union filesystem used in Docker allows different directories to transparently overlay, forming a single, coherent filesystem. The foundational layer is always an image which you build upon. Each additional line with a command, say, RUN, CMD, and so on, adds a layer to it. The advantage of layers is that as long as the layer has not been modified, it will not bother building that part of the image. Secondly, as an image is pulled from a Docker image registry, it is pulled in layers, therefore mitigating issues such as connection cuts during pulling and pushing of images.</p><p>Many applications are built under a common structure: <strong>frontend, backend</strong>, and <strong>database</strong>. Let's break this down further and understand how we can set this up.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>The Frontend</h2></div></div></div><p>When you open a web application, the page that you see is part of the frontend. Sometimes, the frontend has the controller (the logical end) and the view layer (the dumb end). The styling of the layout and content (Read, HTML, and CSS) is the view layer. The content here is managed by the controller.</p><p>The controller<a class="indexterm" id="id52"/> influences what is presented in the view layer based on the user's action and/or database changes. Take, for example, an application like Twitter: if someone follows you, your data has changed. The controller will pick up this change and update the view layer with the new number of followers.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>The Backend</h2></div></div></div><p>You might have <a class="indexterm" id="id53"/>heard of the term Model-view-controller (MVC)
<strong>.</strong> The <a class="indexterm" id="id54"/>model sits on the backend side of things in an application. With the earlier example of Twitter, the model does not concern itself with the HTML or its layout. It handles the state of the application: the number of followers and people you are following, the tweets, images, videos, and so on.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>This is a summary of what the backend layer includes. The backend mainly deals with the application's logic. This includes the code that is manipulating the database; that means all queries come from the backend. However, requests come from the <strong>frontend</strong>. This happens when a user clicks a button, for example.</p></div></div><p>You might have also heard of the term API. API is an acronym standing for <strong>Application Program Interface</strong>. This <a class="indexterm" id="id55"/>also sits at the backend. APIs expose the internal workings of an application.</p><p>This means the API can also be an application's backend or logical layer.</p><p>Let's use the Twitter example so that this is clear. Actions such as posting a tweet and searching for tweets can easily be in an API as methods which can be called from any frontend application if the API is made public.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>The Docker and <code class="literal">docker-compose</code> CLIs are actually API calls, for instance when interacting with external resources or content, such as Docker Hub.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>The Database</h2></div></div></div><p>The database contains<a class="indexterm" id="id56"/> organized data (information) that is easily accessible, managed, and updated. We have file-based databases and server-based databases. </p><p>Server-based databases involve a server process running, accepting requests and reading and writing the database files themselves. The databases could be in the cloud, for example.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Server-based databases are hosted on virtual hosts, mostly on cloud platforms such as Google Cloud Platform and Amazon Web Services. Examples are Amazon RDS and Google Cloud SQL for PostgreSQL.</p></div></div><p>Obtain server-based databases from the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://aws.amazon.com/rds/postgresql/">https://aws.amazon.com/rds/postgresql/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://cloud.google.com/sql/docs/postgres">https://cloud.google.com/sql/docs/postgres</a></li></ul></div><p>In a nutshell, development has always involved building application layers, and shipping has always been a hassle considering the price of the cloud platforms and development and operations (DevOps, for short) involved. </p><p>Docker and <code class="literal">docker-compose</code> help us manage all our application components as a single bundle, which is cheaper, faster, and easier to manage. <code class="literal">docker-compose</code> helps us coordinate all the application layers through a single file and in very simple definitions.</p><p>As we conclude this overview, it is important to know that developers, over time, have coined different stack variations to summarize the frontend, backend, and database structure of their apps. Here's a list of them with their meaning (we will not delve further than this during this course):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">PREN - PostgresDB, React, Express, Node.js</li><li class="listitem" style="list-style-type: disc">MEAN - MongoDB, Express, Angular, Node.js</li><li class="listitem" style="list-style-type: disc">VPEN - VueJS, PostgresDB, Express, Node.js</li><li class="listitem" style="list-style-type: disc">LAMP - Linux, Apache, MySQL, PHP</li></ul></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>It is<a class="indexterm" id="id57"/> important to know that applications are structured in this manner to manage separation of concerns.</p></div></div><p>With the knowledge of application structures, we can get to the <code class="literal">docker-compose</code> CLI and put this knowledge to work.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Using docker-compose</h2></div></div></div><p>Using <code class="literal">docker-compose</code> requires<a class="indexterm" id="id58"/> three steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Build an application's environment as an image using a <code class="literal">Dockerfile</code>.</li><li class="listitem">Use the <code class="literal">docker-compose.yml</code> file to define the services your app requires to run.</li><li class="listitem">Run <code class="literal">docker-compose up</code> to run the app.</li></ol></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>
<code class="literal">docker-compose</code> is <a class="indexterm" id="id59"/>a <strong>command-line interface (CLI)</strong> just like the Docker CLI. Running <code class="literal">docker-compose</code> gives a list of commands and how to use each.</p><p>We went through images in the previous lesson, so step 1 is checked off.</p><p>Some <code class="literal">docker-compose</code> versions are incompatible with some Docker versions.</p><p>We'll dwell on step 2 for some time.</p></div></div><p>Here is the <code class="literal">docker-compose</code> file: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One that runs the two images we created in our previous lesson:</li></ul></div><div><img alt="Using docker-compose" src="img/image02_02.jpg"/></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Refer the complete code placed at <code class="literal">Code/Lesson-2/example-docker-compose.yml</code>.</p><p>Go to <a class="ulink" href="https://goo.gl/11rwXV">https://goo.gl/11rwXV</a> to access the code.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec11"/>docker-compose first run</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new directory and name it <code class="literal">py-js</code>; you can have a different directory name if you prefer. </li><li class="listitem">Create a new file in the directory and name it <code class="literal">docker-compose.yml</code>. Copy the content of the image above or the example shared on example-<code class="literal">docker-compose.yml</code>.</li><li class="listitem">Run the command <code class="literal">docker-compose up</code> from the directory.</li></ol></div><p>Notice the<a class="indexterm" id="id60"/> outputs of running both <code class="literal">js-docker </code>and <code class="literal">python-docker</code>. This is also because we have both images built locally from the previous lesson.</p><p>If you do not have the images, running <code class="literal">docker-compose up</code> will result in an error or an attempt to pull it from Docker Hub if it exists online:</p><div><img alt="docker-compose first run" src="img/image02_03.jpg"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">docker-compose.yml</code> that runs <strong>WordPress</strong>. WordPress is a free and open<a class="indexterm" id="id61"/> source <strong>content </strong><a class="indexterm" id="id62"/><strong>management system</strong> <strong>(CMS)</strong> based on PHP and MySQL.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Activity 1 — Running WordPress Using docker-compose</h2></div></div></div><p>To get you conversant with running <code class="literal">docker-compose</code> commands.</p><p>You have been<a class="indexterm" id="id63"/> asked to build a WordPress website using <code class="literal">docker-compose</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new directory and name it <code class="literal">sandbox</code>.</li><li class="listitem">Create a<a class="indexterm" id="id64"/> new file and name it <code class="literal">docker-compose.yml.</code> Add the code in <code class="literal">wordpress-docker-compose.yml</code> or copy the following figure:<div><img alt="Activity 1 — Running WordPress Using docker-compose" src="img/image02_04.jpg"/></div></li></ol></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Refer the complete code placed at <code class="literal">Code/Lesson-2/wordpress-docker-compose.yml</code>.</p><p>Go to <a class="ulink" href="https://goo.gl/t7UGvy">https://goo.gl/t7UGvy</a> to access the code.</p></div></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>Take heed of the<a class="indexterm" id="id65"/> indentation in the file. It is advised to use an equal number <a class="indexterm" id="id66"/>of tabs and spaces when indenting the lines. </p></div></div><p>Run <code class="literal">docker-compose up</code> in the <code class="literal">sandbox </code>directory:</p><div><img alt="Activity 1 — Running WordPress Using docker-compose" src="img/image02_05.jpg"/></div><div><div><h3 class="title"><a id="note25"/>Note</h3><p>You'll notice that, based on one file, we have an application running. This example is the perfect showcase of the power of <code class="literal">docker-compose</code>.</p></div></div><p>Run <code class="literal">docker ps</code>. You'll see the containers running:</p><div><img alt="Activity 1 — Running WordPress Using docker-compose" src="img/image02_06.jpg"/></div><p>Open your <a class="indexterm" id="id67"/>browser and go to the address at: <code class="literal">http://0.0.0.0:8000/</code>. We'll have the WordPress website set up ready.</p><p>Proceed with the set up and, in an instant, you have a WordPress site up and ready.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec12"/>The docker-compose file: docker-compose.yml</h3></div></div></div><p>
<code class="literal">docker-compose.yml</code> is a YAML file. It defines <strong>services, networks</strong>, and <strong>volumes</strong>.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>Services are<a class="indexterm" id="id68"/> application container definitions that include all components that relate to an application, for example, <strong>DB, frontend</strong>, or <strong>backend</strong>. What really weighs in when defining services is the components, which are networks, volumes, and environment variables.</p><p>The first line of any <code class="literal">docker-compose.yml</code> defines the version of the <code class="literal">docker-compose </code>file format.</p></div></div><p>By running <code class="literal">docker -v</code>, you can tell which Docker version is running and thus know which version to put on the first line of the file. </p><p>For <code class="literal">docker-compose</code> file format 1.0, the first line was not necessary. Each <code class="literal">docker-compose</code> file introduced a new configuration or deprecated an earlier one.</p><p>We will use version 3.3 and the program should be compatible with version 3.0 and above.</p><p>Make sure <a class="indexterm" id="id69"/>everyone is running version 3 and at least a Docker that's 1.13.0+.</p><p>Next up is <strong>services</strong>. Let's use this simplified skeleton:</p><div><img alt="The docker-compose file: docker-compose.yml" src="img/image02_07.jpg"/></div><div><div><h3 class="title"><a id="note27"/>Note</h3><p>Take heed of the indentation.</p><p>In the above example, we have two services, that is, <code class="literal">db</code>  and <code class="literal">web</code>. These two are indented just once.</p></div></div><p>The next lines after defining the services defines the image or the Dockerfile from which the image is to be built.</p><p>Line 4 will specify the image from which the <code class="literal">db </code>service container will run from. We earlier mentioned a number of stacks; the <code class="literal">db</code> image can be any of the server-based databases.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>To confirm whether a stack you want to use exists, run the following:<code class="literal">docker search &lt;image or name of your preferred stack</code>&gt; (for example, <code class="literal">docker search mongo or docker search postgres</code>).</p></div></div><p>Line 6 explains<a class="indexterm" id="id70"/> that the web services image will be built from the Dockerfile in the location (<code class="literal">.</code>) relative to the <code class="literal">docker-compose.yml</code>.</p><p>We can also define the name of the Dockerfile in line 6. <code class="literal">docker-compose</code> will search for the file with a name as listed, for example, in the <code class="literal">docker-compose.yml</code>:</p><div><pre class="programlisting">Line 5| web:build: Dockerfilevolumes:</pre></div><p>Lines 7 to 10 gives more definition to the web services.</p><p>As evidenced in the <code class="literal">docker-compose.yml</code> we used to build and run WordPress, there are two services: <code class="literal">db</code> and <code class="literal">wordpress</code>. In the output of <code class="literal">docker ps,</code> these are the container names: <code class="literal">sandbox_wordpress_1</code> and <code class="literal">sandbox_db_1</code>.</p><p>The first word before the underscore signifies the name of the directory holding the <code class="literal">docker-compose.yml</code>. The second word in that container name is the service name, as defined in <code class="literal">docker-compose.yml</code>.</p><p>We'll go into more context in the following topic.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec13"/>The docker-compose CLI</h3></div></div></div><p>As soon<a class="indexterm" id="id71"/> as <code class="literal">docker-compose</code> is installed, I mentioned that you expect a list of options when you run <code class="literal">docker-compose</code>. Run <code class="literal">docker-compose –v</code>.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>These two <a class="indexterm" id="id72"/>commands, <code class="literal">docker-compose</code> and <code class="literal">docker-compose -v</code>, are the only ones that can be ran from whichever working directory is open on your terminal command line or Git bash.</p></div></div><p>Otherwise, the other options in <code class="literal">docker-compose </code>are only run in the presence of the <code class="literal">docker-compose.yml </code>file.</p><p>Let's dig deep into the common commands: <code class="literal">docker-compose build</code>.</p><p>This command builds images referenced in the <code class="literal">docker-compose line: (build: .)</code>  in the template <code class="literal">docker-compose.ym</code>.</p><p>Building images can also be achieved through the command <code class="literal">docker-compose up</code>. Take note that this doesn't happen unless the image has not been built yet, or there has been a recent change that affects the container to be run.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>This command will also work for the WordPress example, even though both services run from images in the Docker registry and not Dockerfiles within the directory. This would be <strong>pulling</strong> an image and <strong>not building</strong> because we build from a Dockerfile.</p></div></div><p>This command lists the services as configured in the <code class="literal">docker-compose.yml</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"> <code class="literal">docker-compose config --services</code></li></ul></div><p>This command lists the images used by the created containers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"> <code class="literal">docker-compose images</code></li></ul></div><p>This command<a class="indexterm" id="id73"/> lists the logs from the services:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"> <code class="literal">docker-compose logs</code></li></ul></div><p>
<code class="literal">docker-compose logs &lt;service&gt;</code> lists the logs of a specific service, for example, <code class="literal">docker-compose logs db</code>.</p><p>This command lists the containers running based on the <code class="literal">docker-compose</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"> docker-compose ps</code></li></ul></div><p>Note that in most cases, there is a difference between the results of <code class="literal">docker-compose ps</code> and <code class="literal">docker ps</code>. Containers that were not running in the context of <code class="literal">docker-compose</code> will not be displayed by the command <code class="literal">docker-compose ps</code>.</p><p>This command builds, creates, recreates, and runs services:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"> <code class="literal">docker-compose up</code></li></ul></div><div><div><h3 class="title"><a id="note31"/>Note</h3><p>When running <code class="literal">docker-compose up</code>, if one service exits, the entire command exits.</p></div></div><p>Running <code class="literal">docker-compose up -d</code> is running <code class="literal">docker-compose up</code> in detached mode. That is, the command will be running in the background.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Activity 2 —  Analyzing the docker- compose CLI</h2></div></div></div><p>To get you conversant with the <code class="literal">docker-compose</code> CLI.</p><p>You have <a class="indexterm" id="id74"/>been asked to demonstrate the difference in changes resulting from running two containers.</p><p>While still within the directory with the WordPress <code class="literal">docker-compose.yml</code>-- in my case, sandbox -- run the commands of <em>Activity B-1</em>, then the following commands:</p><div><pre class="programlisting">docker-compose up -d
docker-compose stop
docker-compose rm
docker-compose start
docker-compose up -d
docker-compose stop
docker-compose start</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Managing Multiple Containers and Distributed Application Bundles</h1></div></div></div><p>This is the <code class="literal">docker-compose.yml</code> for running a Django application. A similar application <a class="indexterm" id="id75"/>can be found in the <code class="literal">docker-compose</code> documentation <a class="indexterm" id="id76"/>under the Django example.</p><p>Download the Django example from: <a class="ulink" href="https://docs.docker.com/compose/django/">ttps://docs.docker.com/compose/django/</a>:
</p><div><img alt="Managing Multiple Containers and Distributed Application Bundles" src="img/image02_08.jpg"/></div><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Refer the complete code placed at <code class="literal">Code/Lesson-2/django-docker-compose.yml</code>.</p><p>Go to <a class="ulink" href="https://goo.gl/H624J1">https://goo.gl/H624J1</a> to access the code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Improve a Docker Workflow</h2></div></div></div><p>To give more context on how <code class="literal">docker-compose</code> is involved and how it improves  a Docker workflow.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new directory and name it <code class="literal">django_docker</code>.</li><li class="listitem">In the <code class="literal">django-docker</code> directory, create a new <code class="literal">docker-compose.yml</code> and add the information in the figure above, or in the <code class="literal">django-docker-compose.yml</code> script provided.</li><li class="listitem">Create a<a class="indexterm" id="id77"/> new Dockerfile and add the content in the Dockerfile script provided.</li><li class="listitem">Create a <a class="indexterm" id="id78"/>requirements file; simply copy the <code class="literal">django-requirements.txt</code> file provided.</li><li class="listitem">Run <code class="literal">docker-compose</code> up and observe the logs.</li></ol></div><p>Notice that we are able to spin up both containers with one simple command, docker-compose up.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>No prior experience with Django is needed; this is for basic demo purposes. <code class="literal">Code/Lesson-2/django-requirements.txt</code>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec14"/>
<strong>The Django Compose File Broken Down</strong>
</h3></div></div></div><p>First things first, how many services does this file have? Yes, two: <code class="literal">db</code> and <code class="literal">web</code>. The service <code class="literal">db</code> is based on the Postgres image. The service web is built from the Dockerfile in the same directory that contains this <code class="literal">docker-compose.yml</code>.</p><p>Without<a class="indexterm" id="id79"/> the <code class="literal">docker-compose</code> file, the <code class="literal">db</code> service container would have otherwise <a class="indexterm" id="id80"/>been run in this way:</p><div><img alt="The Django Compose File Broken Down" src="img/image02_09.jpg"/></div><p>This command is translated to the following:</p><div><img alt="The Django Compose File Broken Down" src="img/image02_10.jpg"/></div><p>Open <a class="indexterm" id="id81"/>another tab or window in the terminal and run <code class="literal">docker ps</code>. You'll see<a class="indexterm" id="id82"/> the container running.</p><p>On the other hand, the <code class="literal">web</code> service container as per the example would be run in the following steps:</p><div><img alt="The Django Compose File Broken Down" src="img/image02_11.jpg"/></div><p>The second command, broken down, is in the following format:</p><div><pre class="programlisting">docker run (the command)
          -p  shows the &lt;workstation-port&gt;:&lt;container-port&gt;   (8000:8000)
          -v: shows the &lt;present-working-directory&gt;  `pwd` &lt;working-directory-in-container&gt;  (:/django_docker)
          &lt;docker image&gt; (django-web)
          &lt;command-to-run-when-the-container-starts&gt; (python3 manage.py runserver 0.0.0.0.8000)</pre></div><p>Therefore, the aforementioned command is translated to the following:</p><div><img alt="The Django Compose File Broken Down" src="img/image02_12.jpg"/></div><p>One advantage of using <code class="literal">docker-compose.yml</code> is that instead of running the commands in the terminal again and again, you <a class="indexterm" id="id83"/>have one command to <a class="indexterm" id="id84"/>run as many containers as you've included in the file.</p><p>We did not cover volumes and ports in the last lesson. I'll take time to help us understand this.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec15"/>Endure Data Using Volumes</h3></div></div></div><p>Volumes are <a class="indexterm" id="id85"/>used to persist data generated and used by Docker containers. </p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>Volumes persist any update to a local file or script. This makes an equal change on the container side. </p></div></div><p>In this case, the command is the following: </p><div><img alt="Endure Data Using Volumes" src="img/image02_13.jpg"/></div><p>In the docker run options, which comes after the main command:</p><div><pre class="programlisting">-v .:/django_docker</pre></div><p>This is in the <code class="literal">docker-compose.yml </code>file.</p><div><img alt="Endure Data Using Volumes" src="img/image02_14.jpg"/></div><div><div><h3 class="title"><a id="note35"/>Note</h3><p>As long as<a class="indexterm" id="id86"/> volumes is defined in the <code class="literal">docker-compose</code> file, when a local change is made, such as a file update, the changes will be automatically synced to the files in the container(s). </p></div></div><div><img alt="Endure Data Using Volumes" src="img/image02_15.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec16"/>Ports</h3></div></div></div><p>Django, as other <a class="indexterm" id="id87"/>web servers do, runs on specific ports. The Dockerfile used to build the Django image has a similar command to this: <code class="literal">EXPOSE 8000</code>.This port remains open when the container is run and is open for connection.</p><p>In the Django Dockerfile, we defined our port as <code class="literal">8000</code> and prefixed the number with an address <code class="literal">(0.0.0.0):</code>
</p><div><img alt="Ports" src="img/image02_16.jpg"/></div><p>The number <code class="literal">0.0.0.0 </code>defines the host address running the container.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>The address tells <code class="literal">docker-compose</code> to run the container on our machine or, in short, localhost. If we were to skip the address and just expose the port, our set up would have unexpected results like a blank page. </p></div></div><p>Consider the following line in the <code class="literal">docker run</code> options:</p><div><pre class="programlisting">	-p 8000:8000</pre></div><div><img alt="Ports" src="img/image02_17.jpg"/></div><p>And the following lines in the <code class="literal">do‑cker-compose.yml</code>:</p><div><img alt="Ports" src="img/image02_18.jpg"/></div><p>The <code class="literal">docker-compose</code> port format maps the local workstation port to container port. The format is as follows:</p><div><pre class="programlisting">-p &lt;workstation-port&gt;:&lt;container-port&gt;</pre></div><p>This allows us from our local machine to access the port 8000 which was mapped from the container port. </p><p>There's one option at the end, <code class="literal">depends_on</code>, that is specific to <code class="literal">docker-compose.yml</code>. The <code class="literal">depends_on</code> specifies the order in which the containers are spun up as soon as we run <code class="literal">docker-compose</code> run.</p><p>In our case, the <code class="literal">depends_on</code> option is under the web service. This means that the web service container depends on the <code class="literal">db</code> service container:</p><div><img alt="Ports" src="img/image02_19.jpg"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Activity 3 —  Running the docker-compose File</h2></div></div></div><p>To get you conversant with the <code class="literal">docker-compose</code> syntax and commands.</p><p>You have been<a class="indexterm" id="id88"/> asked to build and run a simple Python application which exposes port 5000 from the image <code class="literal">josephmuli/flask-app</code>. Define a <code class="literal">docker-compose</code> file and extend the Postgres image as the database. Make sure the database relates to the application.</p><div><ol class="orderedlist arabic"><li class="listitem">I have prebuilt an image with the name <code class="literal">josephmuli/flask-app</code>. Extend this image in your <code class="literal">docker-compose.yml</code> file.</li><li class="listitem">Make sure to write a version 3 <code class="literal">docker-compose</code> and define the two services.</li><li class="listitem">Run the application on port <code class="literal">5000</code>.</li><li class="listitem">Open your browser and check the listening port.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Networking with docker-compose</h1></div></div></div><p>By default, <code class="literal">docker-compose</code> sets <a class="indexterm" id="id89"/>up a single network for your application(s) where each container can reach and discover other containers. </p><p>The network is given a name based on the name of the directory it lives in. Thus, if your directory is called <code class="literal">py_docker</code>, when your run <code class="literal">docker-compose up</code>, the network created is called <code class="literal">py_docker_default</code>.</p><p>We mentioned ports in the previous topic, when creating the WordPress container. To explain networking better, we'll use the <code class="literal">docker-compose.yml</code> used to spin up a WordPress application:</p><div><img alt="Networking with docker-compose" src="img/image02_20.jpg"/></div><p>In this file, we have two services: <code class="literal">db</code> and <code class="literal">wordpress</code>.</p><p>In the<a class="indexterm" id="id90"/> WordPress service, we have the <code class="literal">ports</code> option mapping port <code class="literal">80</code> to port <code class="literal">8000</code>. No wonder, the WordPress app runs on <code class="literal">0.0.0.0:8000</code> on our browsers.</p><p>The ports option is not in the <code class="literal">db</code> service. However, if you go to the <code class="literal">docker hub page for mysql</code>, you'll notice that port <code class="literal">3306</code> is exposed. This is the standard port for MySQL. You can obtain more information on MySQL from: <a class="ulink" href="https://hub.docker.com/r/library/mysql">https://hub.docker.com/r/library/mysql</a>.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>We don't have port mapping for DB because we don't necessarily need the port mapped to our computer; instead, we want the WordPress app mapped to the DB for communication.</p></div></div><p>We don't have port mapping for <code class="literal">db</code> because we don't necessarily need the port mapped to our local workstation or computer. We only<a class="indexterm" id="id91"/> need it to be exposed in the container environment and thus it can be connected from the web service as in line 23: <code class="literal">WORDPRESS_DB_HOST: db:3306</code>.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>In the <code class="literal">docker-compose</code> file, this is how you connect one container to another:</p><div><ol class="orderedlist arabic"><li class="listitem">Note the port exposed by the image(s) you want to connect.</li><li class="listitem">Reference the container under the service that is connecting to it; in our case, the <code class="literal">db</code> service is connected to by the WordPress service.<p>Since we named the service <code class="literal">db</code>, we reference this connection as <code class="literal">db:3306</code>.</p><p>Therefore, the format is <code class="literal">&lt;service&gt;:&lt;port</code> exposed by that <code class="literal">service&gt;</code>.</p></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Run the WordPress Containers </h2></div></div></div><p>To give more context on how containers are connected, sync, and communicate.</p><p>In the compose file, did you notice the restart option? The available values for this option are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">no</li><li class="listitem" style="list-style-type: disc">always</li><li class="listitem" style="list-style-type: disc">on-failure </li><li class="listitem" style="list-style-type: disc">unless-stopped</li></ul></div><div><img alt="Run the WordPress Containers" src="img/image02_21.jpg"/></div><p>If it is not specified, the <a class="indexterm" id="id92"/>default is <code class="literal">no</code>. This means that the container will not be restarted under any circumstance. However, the <code class="literal">db</code> service here has been specified as restart: always, so the container always restarts.</p><p>Let's look at the Django example and see how networking works out there. This is the <code class="literal">docker-c</code>
<code class="literal">ompose.yml</code>:</p><div><img alt="Run the WordPress Containers" src="img/image02_22.jpg"/></div><p>Immediately, you might not see the networking section present in the WordPress site.  Here's a snippet:</p><div><pre class="programlisting">DATABASES = {
'default': {
'ENGINE': 'django.db.backends.postgresql',
'NAME': 'postgres',
'USER': 'postgres',
'HOST': 'db',
'PORT': 5432,
}
}</pre></div><p>The <a class="indexterm" id="id93"/>question here is, how did we know that the name and user is <code class="literal">postgres</code>, the HOST is <code class="literal">db</code>, and the port is <code class="literal">5432</code>?</p><p>These are the default values set in the <code class="literal">postgres</code> image and containers we run.</p><p>For more clarity, you can take a look at this line, in the official Postgres Docker library: </p><p>You can obtain a Postgres Docker sample from GitHub at: <a class="ulink" href="https://github.com/docker-library/postgres/blob/master/10/docker-entrypoint.sh#L101.">https://github.com/docker-library/postgres/blob/master/10/docker-entrypoint.sh#L101.</a>
</p><div><img alt="Run the WordPress Containers" src="img/image02_23.jpg"/></div><p>As earlier explained, the Host is <code class="literal">DB</code> because the service name is <code class="literal">db</code> that is created by running the <code class="literal">postgres</code> image.</p><p>You can obtain a Postgres Docker example from GitHub at: <a class="ulink" href="https://github.com/docker-library/postgres/blob/master/10/Dockerfile#L132:">https://github.com/docker-library/postgres/blob/master/10/Dockerfile#L132:</a>
</p><div><img alt="Run the WordPress Containers" src="img/image02_24.jpg"/></div><p>Indirectly, it proves why the <code class="literal">settings.py</code> was configured in that manner.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this lesson, we have done the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discussed and displayed a multi-container setup</li><li class="listitem" style="list-style-type: disc">Walked through <code class="literal">docker-compose</code> commands to build and run multiple containers in a parallel manner</li><li class="listitem" style="list-style-type: disc">Gained a high-level understanding of networking containers and how data is persisted in a container from local machines</li><li class="listitem" style="list-style-type: disc">Built and run applications without even setting them up, via Docker Hub</li></ul></div></div></body></html>