- en: Chapter 8. Debugging and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like software code, testing infrastructure code is an all-important task. There
    should ideally be no code floating around in production that has not been tested,
    especially when you have strict customer SLAs to meet, and this is true even for
    the infrastructure. In this chapter, we''ll look at syntactic checks, testing
    without applying the code on the machines (the no-op mode), and functional testing
    for playbooks, which are at the core of Ansible and trigger the various tasks
    you want to perform on the remote hosts. It is recommended that you integrate
    some of these into your **Continuous Integration** (**CI**) system that you have
    for Ansible to better test your playbooks. We''ll be looking at the following
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the mode with and without diff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As part of functional testing, we will be looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: Assertions on the end state of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverspec (a different tool, but can work wonderfully with Ansible)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `--syntax-check` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whenever you run a playbook, Ansible first checks the syntax of the playbook
    file. If an error is encountered, Ansible will error out saying there was a syntax
    error and will not proceed unless you fix that error. This syntax checking is
    performed only when you run the `ansible-playbook` command. When writing a big
    playbook or if you have included task files, it might be difficult to fix all
    of the errors; this might end up wasting more time. In order to deal with such
    situations, Ansible provides a way to check your YAML syntax as you keep progressing
    with your playbook. For this example, we will need to create the file `playbooks/setup_apache.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our example file, we need to run it with the `--syntax-check`
    parameter, so you will invoke Ansible as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ansible-playbook` command checked the YAML syntax of the `setup_apache.yml`
    playbook and showed that the syntax of the playbook was correct. Let''s look at
    the resulting errors from the invalid syntax in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The error shows that there is an indentation error in the `Enable Apache` task.
    Ansible also gives you the line number, column number, and the filename where
    this error is found (even if this is not a guarantee of the exact location of
    the error). This should definitely be one of the basic tests that you should run
    as part of your CI for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The check mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The check mode (also known as the **dry run** or **no-op mode**) will run your
    playbook in a no-operation mode, that is, it will not apply any changes to the
    remote host; instead, it will just show the changes that will be introduced when
    a task is run. Whether the check mode is actually enabled or not depends on each
    task. There are few commands that you may find interesting. All those modules
    will have to be run in `/usr/lib/python2.7/site-packages/ansible/modules` or where
    your Ansible module folder is (different paths could be possible based on the
    operating system you are using as well as the way you installed Ansible).
  prefs: []
  type: TYPE_NORMAL
- en: 'To count the number of available modules on your installation, you can perform
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With Ansible 2.1.1, the result of this command is `569`, since Ansible has that
    many modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see how many of these support the check mode, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With Ansible 2.1.1 the result of this command is `242`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also find the following command useful for listing all modules that
    support the check mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This helps you test how your playbook will behave and check if there may be
    any failures before running it on your production server. You run a playbook in
    the check mode by simply passing the `--check` option to your `ansible-playbook`
    command. Let''s see how the check mode works with the `setup_apache.yml` playbook,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding run, instead of making the changes on the target host, Ansible
    highlighted all the changes that would have occurred during the actual run. From
    the preceding run, you can find that `httpd` service was already installed on
    the target host, because of which, Ansible's exit message for that task was ok.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, with the second task, it found that `httpd` service was not running
    on the target host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding playbook again without the check mode enabled, Ansible
    will make sure that the service state is running.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating differences between files using --diff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the check mode, you can use the `--diff` option to show the changes that
    would be applied to a file. To be able to see the `--diff` option in use, we need
    to change our `playbooks/setup_apache.yaml` playbook to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added a task, which will ensure a certain state of the `/etc/httpd/conf.d/userdir.conf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a template file placed in `templates/userdir.conf` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this template, we only changed the `UserDir enabled` line, which by default
    is `UserDir disabled`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `--diff` option doesn't work with the file module; you will have to use
    the template module only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now test the result of this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using the `--check` parameter that will ensure this
    will be a dry-run. We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Ansible compares the current file of the remote host with the
    source file; a line starting with `+` indicates that a line was added to the file,
    whereas `-` indicates that a line was removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use `--diff` without the `--check` option, which will allow Ansible
    to make the specified changes and show the difference between two files.
  prefs: []
  type: TYPE_NORMAL
- en: Using `--diff` and `--check` modes together is a test step that can potentially
    be used as part of your CI tests to assert how many steps have changed as part
    of the run. Another case where you can use those features together is the part
    of the deployment process that checks what exactly will change when you run Ansible
    on that machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are also cases - that should not happen, but sometimes happen-where you
    have not run a playbook on a machine for a very long time and you are worried
    that running it again will break something. Using those options together should
    help you understand if it was just you worrying or if this is a real risk.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wikipedia says functional testing is a **Quality Assurance (QA) process** and
    a type of black-box testing that bases its test cases on the specifications of
    the software component under the test. **Functions are tested by feeding them
    input and examining the output**; the internal program structure is rarely considered.
    Functional testing is as important as code when it comes to infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: From an infrastructure perspective, with respect to functional testing, we test
    output of our Ansible runs on the actual machines. Ansible provides multiple ways
    to perform the functional testing of your playbook; let's look at some of the
    most commonly used methods.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing using assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The check mode will only work when you want to check whether a task will change
    anything on the host or not. This will not help when you want to check whether
    the output of your module is what you expected. For example, let's say you wrote
    a module that will check if a port is up or not. In order to test this, you might
    need to check the output of your module and see whether it matches the desired
    output or not. To perform such tests, Ansible provides a way to directly compare
    the output of a module with the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works creating the file `playbooks/assert_ls.yaml` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding playbook, we''re running the `ls` command on the target host
    and registering the output of that command in the `list_files` variable. Further,
    we ask Ansible to check whether the output of the `ls` command has the expected
    result. We do this using the `assert` module, which uses some conditional checks
    to verify if the `stdout` value of a task meets the expected output of the user.
    Let''s run the preceding playbook to see what output Ansible returns with the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we don''t have the file, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we re-run the playbook after we create the expected file, it will not fail
    and therefore this will be the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, the task passed with an ok message as `testfile.txt` was present
    in the `list_files` variable. Likewise, you can match multiple strings in a variable
    or multiple variables using the `and` and `or` operators. The assertion feature
    is quite powerful, and users who have written either unit or integration tests
    in their projects will be quite happy to see this feature!
  prefs: []
  type: TYPE_NORMAL
- en: Testing with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are a great way to test a bunch of tasks without running an entire playbook.
    We can use tags to run actual tests on the nodes to verify the state that the
    user intended to be in, the playbook. We can treat this as another way to run
    integration tests for Ansible on the actual box. The tag method to test can be
    run on the actual machines where you run Ansible, and also, it can be used primarily
    during deployments to test the state of your end systems. In this section, we'll
    first look at how to use tags in general, their features that can possibly help
    us, not just with testing but even otherwise, and finally for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add tags in your playbook, use the tags parameter followed by one or more
    tag names separated by commas. Let''s create a simple playbook in `playbooks/tags_example.yaml`
    to see how the tags work with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the playbook, the file will be created and destroyed. We can
    see it running with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give us this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since this is not an idempotent playbook, if we run it over and over, we will
    always see the same result, as the playbook will create and delete the file every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now simply pass the `file_present` tag or the `file_absent` tag to
    only perform one of the actions, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the `-t file_present` part, only the tasks with the `file_present`
    tag will be executed, in fact this will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can also use tags to perform a set of tasks on the remote host just like
    taking a server out of a load balancer and adding it back to the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `--check` option with tags. By doing this, you can test
    your tasks without actually running them on your hosts. This allows you to test
    a bunch of individual tasks directly, instead of copying your tasks to a temporary
    playbook and running it from there.
  prefs: []
  type: TYPE_NORMAL
- en: The --skip-tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible also provides a way to skip some tags in a playbook. If you have a
    long playbook with multiple tags, like 10, and you want to execute them all but
    one, then it would not be a good idea to pass nine tags to Ansible. The situation
    would be more difficult if you forgot to pass a tag and the `ansible-playbook`
    command fails. To overcome such situations, Ansible provides a way to skip a couple
    of tags, instead of passing multiple tags. It''s functioning is pretty straightforward,
    and can be triggered in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all tasks have been executed except the one with the `file_present`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Managing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many cases, where for one reason or another, you want your playbook
    and roles to carry on in the case one or more tasks fail. A typical example of
    this could be that you want to check if software is installed or not. Let''s see
    the following example to install Java. In the `roles/java/tasks/main.ymal` file,
    we are going to put the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going forward with the other parts that are needed to execute this role,
    I''d like to spend some words on the various parts of this role task list, since
    there are many new things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this task, we execute an `rpm` command that could have two different outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the complete name of the JDK package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we only want to check if the package exists or not and then to go forward,
    we register the output (*third* line) and ignore eventual failures (*fourth* line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part, we use the `uri` module that allows us to hit a remote URI with
    an HTTP request. This module is very nice since it allows you to use all HTTP
    methods as well as to customize HTTP headers. This makes this module very flexible.
    Since in the last line we have `when: java|failed`, this will only be executed
    if Java is not installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use `dnf` to install the Java package. Since in the last line we have
    `when: java|failed`, this will only be executed if Java is not installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here we are going to set new alternatives, in case we are installing Java. `alternatives`
    is an Ansible module that allows us to manage the configuration of the Linux `alternatives`
    program. This program is often used to manage which version of a program should
    be run by default in case you have multiple versions installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we create the role, we will need the `hosts` file containing the host
    machine, in my case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And a playbook to apply the role, placed in `playbooks/hosts/j01.fale.io.yaml`
    and with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the installation check failed since Java was not installed on
    the machine, and for this reason all other tasks have been executed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are cases when you want to trigger a failure directly. This can happen
    for multiple reasons, even if there are disadvantages doing so, since when you
    trigger the failure, the playbook will be brutally interrupted and this could
    leave your machine in an inconsistent state if you are not careful. One case where
    I have seen it work very well, is when you are running a non-idempotent playbook
    (for instance building of a newer version of an application) and you need a variable
    (for instance: the version/branch to deploy) set. In this case, you can check
    that the expected variable is correctly configured before starting to run the
    operations to ensure that everything will work as expected later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the following code in `playbooks/maven_build.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we expect the user to add `--extra-vars "version=$[TAG/BRANCH]"`
    in the script to call the command. We could have put a branch to use by default
    but this is too risky because the user may lose focus and forget to add the right
    branch name themselves, which would lead to compiling (and deploying) the wrong
    version of the application. The `fail` module also allows us to specify a message
    that will be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I think that the `fail` task is far more useful in playbooks that are run manually
    since when a playbook is automatically run, managing the exception is often better
    than failing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to debug Ansible playbooks using multiple
    techniques. Then we moved to the management of failures and lastly we saw how
    to trigger failures intentionally.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss multi-tier environments as well as deployment
    methodologies.
  prefs: []
  type: TYPE_NORMAL
