- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: I started my career as a developer. During those early days, all I knew (and
    thought I should know) was to write code. I believed that a great software designer
    is a person that is proficient in writing code and that the path to the mastery
    of the craft was to know everything about a single programming language of choice.
    Later on, that changed and I started taking an interest in different programming
    languages. I switched from Pascal to Basic and then ASP. When Java and, later
    on, .Net came into existence, I learned benefits of object oriented programming.
    Python, Perl, Bash, HTML, JavaScript, Scala. Each programming language brought
    something new and taught me how to think differently and how to pick the right
    tool for the task at hand. With each new language I learned, I felt like I was
    closer to being an expert. All I wanted was to become a senior programmer. That
    desire changed with time. I learned that if I was to do my job well, I had to
    become a *software craftsman*. I had to learn much more than to type code. Testing
    became my obsession for some time, and now I consider it an integral part of development.
    Except in very special cases, each line of code I write is done with **test-driven
    development** (**TDD**). It became an indispensable part of my tool-belt. I also
    learned that I had to be close to the customer and work with him side by side
    while defining what should be done. All that and many other things led me to *software
    architecture*. Understanding the big picture and trying to fit different pieces
    into one big system was the challenge that I learned to like.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始我的职业生涯时是一名开发者。在那些早期的日子里，我所知道的（并且认为我应该知道的）就是编写代码。我相信，一个优秀的软件设计师是一个擅长编写代码的人，通往精通这项技术的道路就是深入了解自己选择的编程语言的所有内容。后来，这种想法发生了变化，我开始对不同的编程语言产生兴趣。我从
    Pascal 转到 Basic，再到 ASP。当 Java 和后来 .Net 出现时，我学习了面向对象编程的好处。Python、Perl、Bash、HTML、JavaScript、Scala。每一种编程语言都带来了新的东西，教会我如何以不同的方式思考，以及如何为当前任务选择合适的工具。每学会一门新语言，我就感觉离成为专家更近了一步。我当时唯一的目标就是成为一名资深程序员。随着时间的推移，这个愿望发生了变化。我学到，如果我想做好我的工作，就必须成为一名*软件工匠*。我必须学习的不仅仅是打代码。测试一度成了我的执念，而现在我认为它是开发过程中不可或缺的一部分。除非在非常特殊的情况下，我写的每一行代码都是基于**测试驱动开发**（**TDD**）的。它已经成为我工具带中不可或缺的一部分。我还学到，我必须与客户保持紧密联系，和他们并肩工作，共同定义要做的事情。所有这些，以及其他许多事情，最终让我走上了*软件架构*的道路。理解全局，努力将不同的部分融合成一个完整的系统，这个挑战我逐渐学会了喜欢。
- en: Throughout all the years I've been working in the software industry, there was
    no single tool, framework or practice that I admired more than **continuous integration**
    (**CI**) and, later on, **continuous delivery** (**CD**). The real meaning of
    that statement hides behind the scope of what CI/CD envelops. In the beginning,
    I thought that CI/CD means that I knew *Jenkins* and was able to write scripts.
    As the time passed I got more and more involved and learned that CI/CD relates
    to almost every aspect of software development. That knowledge came at a cost.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我多年来从事软件行业的过程中，没有任何工具、框架或实践比**持续集成**（**CI**）以及后来的**持续交付**（**CD**）更让我钦佩。这句话的真正含义，隐藏在
    CI/CD 所涵盖的广泛范围中。最开始，我以为 CI/CD 就是我懂得使用*Jenkins*并能编写脚本。随着时间的推移，我越来越深入地了解，发现 CI/CD
    涉及软件开发的几乎每个方面。这些知识的获得是有代价的。
- en: I failed (more than once) to create a successful CI pipeline with applications
    I worked with at the time. Even though others considered the result a success,
    now I know that it was a failure because the approach I took was wrong. CI/CD
    cannot be done without making architectural decisions. Similar can be said for
    tests, configurations, environments, fail-over, and so on. To create a successful
    implementation of CI/CD, we need to make a lot of changes that, on the first look,
    do not seem to be directly related. We need to apply some patterns and practices
    from the very beginning. We have to think about architecture, testing, coupling,
    packaging, fault tolerance, and many other things. CI/CD requires us to influence
    almost every aspect of software development. That diversity is what made me fall
    in love with it. By practicing CI/CD we are influencing and improving almost every
    aspect of the software development life cycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经（不止一次）未能成功创建与当时所用应用程序配合的 CI 流水线。尽管其他人认为结果是成功的，但现在我知道那是失败的，因为我采取的方法是错误的。没有做出架构决策，CI/CD
    是无法完成的。测试、配置、环境、故障转移等方面也可以说类似。要创建成功的 CI/CD 实施，我们需要做很多改变，初看起来这些改变似乎与 CI/CD 没有直接关系。我们需要从一开始就应用一些模式和实践。我们必须考虑架构、测试、耦合、打包、容错等许多其他事情。CI/CD
    要求我们影响几乎所有的软件开发方面。正是这种多样性让我爱上了它。通过实践 CI/CD，我们正在影响并改善软件开发生命周期的几乎每个方面。
- en: To be truly proficient with CI/CD, we need to be much more than experts in operations.
    The DevOps movement was a significant improvement that combined traditional operations
    with advantages that development could bring. I think that is not enough. We need
    to know and influence architecture, testing, development, operations and even
    customer negotiations if we want to gain all the benefits that CI/CD can bring.
    Even the name DevOps as the driving force behind the CI/CD is not suitable since
    it's not only about development and operations but everything related to software
    development. It should also include architects, testers, and even managers. DevOps
    was a vast improvement when compared to the traditional operations by combining
    them with development. The movement understood that manually running operations
    is not an option given current business demands and that there is no automation
    without development. I think that the time came to redefine DevOps by extending
    its scope. Since the name *DevOpsArchTestManageAndEverythingElse* is too cumbersome
    to remember and close to impossible to pronounce, I opt for **DevOps 2.0**. It's
    the next generation that should drop the heavy do-it-all products for smaller
    tools designed to do very specific tasks. It's the switch that should go back
    to the beginning and not only make sure that operations are automated but that
    the whole system is designed in a way that it can be automated, fast, scalable,
    fault-tolerant, with zero-downtime, easy to monitor, and so on. We cannot accomplish
    this by simply automating manual procedures and employing a single do-it-all tool.
    We need to go much deeper than that and start refactoring the whole system both
    on the technological as well as the procedural level.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正精通 CI/CD，我们需要远不止是操作方面的专家。DevOps 运动是一个重要的改进，它将传统操作与开发所能带来的优势结合在一起。但我认为这还不够。如果我们想要获得
    CI/CD 带来的所有好处，我们需要了解并影响架构、测试、开发、操作，甚至客户谈判。即使作为 CI/CD 驱动力的 DevOps 这个名称也不合适，因为它不仅仅是关于开发和运维，更是与软件开发相关的一切。它还应包括架构师、测试人员，甚至是管理人员。与传统操作相比，DevOps
    是一个巨大的改进，通过将其与开发相结合，DevOps 运动认识到，手动运行操作在当前的商业需求下已不可行，而且没有开发就没有自动化。我认为是时候通过扩大其范围来重新定义
    DevOps 了。由于名称 *DevOpsArchTestManageAndEverythingElse* 太复杂，不仅难以记住，几乎无法发音，我选择 **DevOps
    2.0**。它是下一代，应该放弃那种包罗万象的工具，转而使用设计来执行非常具体任务的较小工具。这是一个应该回到起点的转变，不仅要确保操作自动化，还要确保整个系统的设计可以自动化，快速、可扩展、容错、零停机、易于监控，等等。我们无法仅通过自动化手动过程和使用单一的全能工具来实现这一目标。我们需要深入挖掘，从技术层面和过程层面开始重构整个系统。
- en: Overview
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This book is about different techniques that help us architect software in a
    better and more efficient way with *microservices* packed as *immutable containers*,
    *tested* and *deployed continuously* to servers that are *automatically provisioned*
    with *configuration management* tools. It's about fast, reliable and continuous
    deployments with *zero-downtime* and ability to *roll-back*. It's about *scaling*
    to any number of servers, design of *self-healing systems* capable of recuperation
    from both hardware and software failures and about *centralized logging and monitoring*
    of the cluster.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书介绍了不同的技术，帮助我们以更好的方式、更高效地架构软件，采用*微服务*，打包成*不可变容器*，*经过测试*并*持续部署*到通过*配置管理*工具*自动配置*的服务器上。这是关于快速、可靠和持续部署的内容，具有*零停机*和回滚能力。它讲述了如何*扩展*到任意数量的服务器，设计能够从硬件和软件故障中恢复的*自愈系统*，以及*集中的日志记录和监控*集群。
- en: In other words, this book envelops the whole microservices development and deployment
    lifecycle using some of the latest and greatest practices and tools. We'll use
    Docker, Kubernetes, Ansible, Ubuntu, Docker Swarm and Docker Compose, Consul,
    etcd, Registrator, confd, Jenkins, and so on. We'll go through many practices
    and, even more, tools.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，本书涵盖了使用一些最新和最优秀的实践和工具来进行微服务开发和部署的整个生命周期。我们将使用Docker、Kubernetes、Ansible、Ubuntu、Docker
    Swarm和Docker Compose、Consul、etcd、Registrator、confd、Jenkins等工具。我们将深入实践，甚至更多工具。
- en: Finally, while there will be a lot of theory, this is a hands-on book. You won't
    be able to complete it by reading it in a metro on a way to work. You'll have
    to read this book while in front of a computer getting your hands dirty. Eventually,
    you might get stuck and in need of help. Or you might want to write a review or
    comment on the book's content. Please post your thoughts on the The DevOps 2.0
    Toolkit channel in Disqus. If you prefer one-on-one discussion, feel free to send
    me an email to `<[viktor@farcic.com](mailto:viktor@farcic.com)>`, or to contact
    me on HangOuts, and I'll give my best to help you out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管本书有很多理论内容，但它是一本实践性很强的书。你不能仅仅通过在地铁上看它就完成它。你必须在电脑前阅读这本书，动手实践。最终，你可能会遇到困惑并需要帮助，或者你可能想要写书评或评论本书的内容。请在Disqus上的The
    DevOps 2.0 Toolkit频道发布你的想法。如果你更喜欢一对一的讨论，随时发送电子邮件到`<viktor@farcic.com>`，或者通过HangOuts与我联系，我会尽力提供帮助。
- en: Audience
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者群体
- en: This book is for professionals interested in the full microservices lifecycle
    combined with continuous deployment and containers. Due to the very broad scope,
    target audience could be *architects* who want to know how to design their systems
    around microservices. It could be *DevOps* wanting to know how to apply modern
    configuration management practices and continuously deploy applications packed
    in containers. It is for *developers* who would like to take the process back
    into their hands as well as for *managers* who would like to gain a better understanding
    of the process used to deliver software from the beginning to the end. We'll speak
    about scaling and monitoring systems. We'll even work on the design (and implementation)
    of self-healing systems capable of recuperation from failures (be it of hardware
    or software nature). We'll deploy our applications continuously directly to production
    without any downtime and with the ability to rollback at any time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向那些对完整的微服务生命周期感兴趣的专业人士，结合了持续部署和容器技术。由于内容范围非常广泛，目标读者可能是*架构师*，他们希望了解如何围绕微服务设计自己的系统。也可能是*DevOps*，他们希望了解如何应用现代配置管理实践并持续部署打包在容器中的应用程序。它还适用于*开发者*，他们希望将过程掌控在自己手中，以及*管理者*，他们希望更好地理解从开始到结束交付软件的过程。我们将讨论如何扩展和监控系统。我们甚至会设计（并实现）能够从故障中恢复的自愈系统（无论是硬件故障还是软件故障）。我们将直接将应用程序持续部署到生产环境中，做到零停机，并随时能够回滚。
- en: This book is for *everyone wanting to know more about the software development
    lifecycle* starting from requirements and design, through development and testing
    all the way until deployment and post-deployment phases. We'll create the processes
    taking into account best practices developed by and for some of the biggest companies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书适合*任何想要了解软件开发生命周期的人*，从需求和设计开始，通过开发和测试，一直到部署和部署后的阶段。我们将创建这些过程，借鉴一些最大型公司开发的最佳实践。
