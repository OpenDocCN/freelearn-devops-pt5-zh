- en: Chapter 4. Programming Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a workflow condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a workflow validator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a workflow post function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing an active workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making issue editable/non-editable based on workflow status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including/excluding resolutions for specific transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions based on workflow status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization in workflow transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting available workflow actions programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically progressing on workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting workflow history from database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-ordering workflow actions in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating common transitions in workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jelly escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Workflows are one standout feature which help users to transform JIRA into
    a user-friendly system. It helps users to define a lifecycle for the issues, depending
    on the issue type, the purpose for which they are using JIRA, and so on. As the
    Atlassian documentation says at [http://confluence.atlassian.com/display/JIRA/Configuring+Workflow](http://confluence.atlassian.com/display/JIRA/Configuring+Workflow):'
  prefs: []
  type: TYPE_NORMAL
- en: A JIRA workflow is the set of steps and transitions an issue goes through during
    its lifecycle. Workflows typically represent business processes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JIRA uses Opensymphony's OSWorkflow which is highly configurable, and more importantly
    pluggable, to cater for the various requirements. JIRA uses three different plugin
    modules to add extra functionalities into its workflow, which we will see in detail
    through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, JIRA ships with a default workflow. We can't modify the
    default workflow, but can copy it into a new workflow and amend it to suit our
    needs. Before we go into the development aspect of a workflow, it makes sense
    to understand the various components of a workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The two most important components of a JIRA workflow are **Step** and **Transition**.
    At any point of time, an **Issue** will be in a step. Each step in the workflow
    is linked to a workflow Status ([http://confluence.atlassian.com/display/JIRA/Defining+%27Status%27+Field+Values](http://confluence.atlassian.com/display/JIRA/Defining+%27Status%27+Field+Values))
    and it is this status that you will see on the issue at every stage. A transition,
    on the other hand, is a link between two steps. It allows the user to move an
    issue from one step to another (which essentially moves the issue from one status
    to another).
  prefs: []
  type: TYPE_NORMAL
- en: 'Few key points to remember or understand about a workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: An issue can exist in only one step at any point in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A status can be mapped to only one step in the workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transition is always one-way. So if you need to go back to the previous step,
    you need a different transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transition can optionally specify a screen to be presented to the user with
    the right fields on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OSWorkflow, and hence JIRA, provides us with the option of adding various elements
    into a workflow transition which can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditions**: A set of conditions that need to be satisfied before the user
    can actually see the workflow action (transition) on the issue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validators**: A set of validators which can be used to validate the user
    input before moving to the destination step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post Functions**: A set of actions which will be performed after the issue
    is successfully moved to the destination step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three elements give us the flexibility of handling the various use cases
    when an issue is moved from one status to another. JIRA ships with a few built-in
    conditions, validators, and post functions. There are plugins out there which
    also provide a wide variety of useful workflow elements. And if you still don't
    find the one you are looking for, JIRA lets us write them as plugins. We will
    see how to do it in the various recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, that gives you a fair idea about the various workflow elements. A
    lot more on JIRA workflows can be found in the JIRA documentation at [http://confluence.atlassian.com/display/JIRA/Configuring+Workflow](http://confluence.atlassian.com/display/JIRA/Configuring+Workflow),
  prefs: []
  type: TYPE_NORMAL
- en: Writing a workflow condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are workflow conditions? They determine whether a workflow action is available
    or not. Considering the importance of a workflow in installations and how there
    is a need to restrict the actions either to a set of people, roles, and so on,
    or based on some criteria (for example, the field is not empty!), writing workflow
    conditions is inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow conditions are created with the help of the `workflow-condition` module.
    The following are the key attributes and elements supported. See [http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Conditions](http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Conditions)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | This should be unique within the plugin. |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Class to provide contexts for rendered velocity templates. Must
    implement the `com.atlassian.jira.plugin.workflow.WorkflowPluginConditionFactory`
    interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `i18n-name-key` | The localization key for the human-readable name of the
    plugin module. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Human-readable name of the workflow condition. |'
  prefs: []
  type: TYPE_TB
- en: '**Elements**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | Description of the workflow condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `condition-class` | Class to determine whether the user can see the workflow
    transition. Must implement `com.opensymphony.workflow.Condition`. Recommended
    to extend the `com.atlassian.jira.workflow.condition.AbstractJiraCondition` class.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `resource type="velocity"` | Velocity templates for the workflow condition
    views. |'
  prefs: []
  type: TYPE_TB
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, create a skeleton plugin. Create an eclipse project using the skeleton
    plugin and we are good to go!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, let''s assume we are going to develop a workflow condition
    that limits a transition only to the users belonging to a specific project role.
    The following are the steps to write our condition:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the inputs needed to configure the workflow condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to implement the `WorkflowPluginFactory` interface, which mainly exists
    to provide velocity parameters to the templates. It will be used to extract the
    input parameters that are used in defining the condition. To make it clear, the
    inputs here are not the inputs while performing the workflow action, but the inputs
    in defining the condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The condition factory class, `RoleConditionFactory` in this case, extends the
    `AbstractWorkflowPluginFactory`, which implements the `WorkflowPluginFactory`
    interface. There are three abstract methods that we should implement, that is,
    `getVelocityParamsForInput`, `getVelocityParamsForEdit`, and `getVelocityParamsForView`.
    All of them, as the name suggests, are used for populating the velocity parameters
    for the different scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our example, we need to limit the workflow action to a certain project role,
    and so we need to select the project role while defining the condition. The three
    methods will be implemented as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s look at the methods in detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVelocityParamsForInput`: This method defines the velocity parameters for
    input scenario, that is, when the user initially configures the workflow. In our
    example, we need to display all the project roles so that the user can select
    one to define the condition. The method `getProjectRoles` merely returns all the
    project roles and the collection of roles is then put into the velocity parameters
    with the key `ROLES`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getVelocityParamsForView`: This method defines the velocity parameters for
    the view scenario, that is, how the user sees the condition after it is configured.
    In our example, we have defined a role and so we should display it to the user
    after retrieving it back from the workflow descriptor. If you have noticed, the
    descriptor, which is an instance of `AbstractDescriptor`, is available as an argument
    in the method. All we need is to extract the role from the descriptor, which can
    be done as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Just check if the descriptor is a condition descriptor or not, and then extract
    the role as shown in the preceding snippet.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVelocityParamsForEdit`: This method defines the velocity parameters for
    the edit scenario, that is, when the user modifies the existing condition. Here
    we need both the options and the selected value. Hence, we put both the project
    roles collection and the selected role on to the velocity parameters.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second step is to define the velocity templates for each of the three aforementioned
    scenarios: **input**, **view**, and **edit**. We can use the same template here
    for input and edit with a simple check to keep the old role selected for the edit
    scenario. Let us look at the templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`edit-roleCondition.vm`: Displays all project roles and highlights the already-selected
    one in the edit mode. In the input mode, the same template is reused, but the
    selected role will be null and hence a null check is done:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`view-roleCondition.vm`: Displays the selected role:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The third step is to write the actual condition. The condition class should
    extend the `AbstractJiraCondition` class. Here we need to implement the `passesCondition`
    method. In our case, we retrieve the project from the issue, check if the user
    has the appropriate project role, and return true if the user does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The issue on which the condition is checked can be retrieved using the `getIssue`
    method implemented in the `AbstractJiraCondition` class. Similarly, the user can
    be retrieved using the `getCaller` method. In the preceding method, `projectRoleManager`
    is injected in the constructor, as we have seen before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can see that the `ROLE` key is used to retrieve the project role ID from
    the `args` parameter in the `passesCondition` method. In order for the `ROLE`
    key to be available in the `args` map, we need to override the `getDescriptorParams`
    method in the condition factory class, `RoleConditionFactory` in this case. The
    `getDescriptorParams` method returns a map of sanitized parameters, which will
    be passed into workflow plugin instances from the values in an array form submitted
    by velocity, given a set of `name:value` parameters from the plugin configuration
    page (that is, the ''input-parameters'' velocity template). In our case, the method
    is overridden as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method here builds a map of the `key:value` pair, where key is `ROLE` and
    the value is the role value entered in the input configuration page. The `extractSingleParam`
    method is implemented in the `AbstractWorkflowPluginFactory` class. The `extractMultipleParams`
    method can be used if there is more than one parameter to be extracted!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that is left now is to populate the `atlassian-plugin.xml` file with the
    aforementioned components. We use the `workflow-condition` module and it looks
    like the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package the plugin and deploy it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the plugin is deployed, we need to modify the workflow to include the
    condition. The following screenshot is how the condition looks when it is added
    initially. This, as you now know, is rendered using the input template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the condition is added (that is, after selecting the **Developers** role),
    the view is rendered using the view template and looks as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you try to edit it, the screen will be rendered using the edit template,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the **Developers** role is already selected.
  prefs: []
  type: TYPE_NORMAL
- en: After the workflow is configured, when the user goes to an issue, he/she will
    be presented with the transition only if he/she is a member of the project role
    where the issue belongs. It is while viewing the issue that the `passesCondition`
    method in the `condition` class is executed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a skeleton plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process"), *Plugin Development Process*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying your plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a workflow validator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workflow validators are specific validators that check whether some pre-defined
    constraints are satisfied or not while progressing on a workflow. The constraints
    are configured in the workflow and the user will get an error if some of them
    are not satisfied. A typical example would be to check if a particular field is
    present or not before the issue is moved to a different status.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow validators are created with the help of the `workflow- validator` module.
    The following are the key attributes and elements supported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | This should be unique within the plugin. |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Class to provide contexts for rendered velocity templates. Must
    implement the `com.atlassian.jira.plugin.workflow.WorkflowPluginValidatorFactory`
    interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `i18n-name-key` | The localization key for the human-readable name of the
    plugin module. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Human-readable name of the workflow validator. |'
  prefs: []
  type: TYPE_TB
- en: '**Elements**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | Description of the workflow validator. |'
  prefs: []
  type: TYPE_TB
- en: '| `validator-class` | Class which does the validation. Must implement `com.opensymphony.workflow.Validator`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `resource type="velocity"` | Velocity templates for the workflow validator
    views. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Validators](http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Validators)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, create a skeleton plugin. Create an eclipse project using the skeleton
    plugin and we are good to go!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider writing a validator that checks whether a particular field
    has a value entered on the issue or not! We can do this using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the inputs needed to configure the workflow validator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to implement the `WorkflowPluginValidatorFactory` interface, which mainly
    exists to provide velocity parameters to the templates. It will be used to extract
    the input parameters that are used in defining the validator. To make it clear,
    the inputs here are not the input while performing the workflow action, but the
    inputs in defining the validator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The validator factory class, `FieldValidatorFactory` in this case, extends the
    `AbstractWorkflowPluginFactory` interface and implements the `WorkflowPluginValidatorFactory`
    interface. Just like conditions, there are three abstract methods that we should
    implement. They are `getVelocityParamsForInput`, `getVelocityParamsForEdit`, and
    `getVelocityParamsForView`. All of them, as the names suggest, are used for populating
    the velocity parameters in different scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our example, we have a single input field, which is the name of a custom
    field. The three methods will be implemented as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may have noticed that the methods look quite similar to the ones in a workflow
    condition, except for the business logic! Let us look at the methods in detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVelocityParamsForInput`: This method defines the velocity parameters for
    input scenario, that is, when the user initially configures the workflow. In our
    example, we need to display all the custom fields, so that the user can select
    one to use in the validator. The method `getCFFields` returns all the custom fields
    and the collection of fields is then put into the velocity parameters with the
    key fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getVelocityParamsForView`: This method defines the velocity parameters for
    the view scenario, that is, how the user sees the validator after it is configured.
    In our example, we have defined a field and so we should display it to the user
    after retrieving it back from the workflow descriptor. You may have noticed that
    the descriptor, which is an instance of `AbstractDescriptor`, is available as
    an argument in the method. All we need is to extract the field name from the descriptor,
    which can be done as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Just check if the descriptor is a validator descriptor or not and then extract
    the field as shown in the preceding snippet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVelocityParamsForEdit`: This method defines the velocity parameters for
    the edit scenario, that is, when the user modifies the existing validator. Here
    we need both the options and the selected value. Hence we put both the custom
    fields'' collection and the field name onto the velocity parameters.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second step is to define the velocity templates for each of the three aforementioned
    scenarios, namely, input, view, and edit. We can use the same template here for
    input and edit with a simple checking to keep the old field selected for the edit
    scenario. Let us look at the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`edit-fieldValidator.vm`: Displays all custom fields and highlights the already
    selected one in edit mode. In input mode, the field variable will be null, and
    so nothing is pre-selected:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`view-fieldValidator.vm`: Displays the selected field:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The third step is to write the actual validator. The validator class should
    implement the `Validator` interface. All we need here is to implement the `validate`
    method. In our example, we retrieve the custom field value from the issue and
    throw an `InvalidInputException` if the value is null (empty):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The issue on which the validation is done can be retrieved from the `transientVars`
    map. `customFieldManager` is injected in the constructor as usual.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that is left now is to populate the `atlassian-plugin.xml` file with these
    components. We use the `workflow-validator` module, and it looks like the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package the plugin and deploy it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we have stored the role name instead of the ID in the workflow, unlike
    what we did in the workflow condition. However, it is safe to use the ID because
    administrators can rename the roles, which would then need changes in the workflows.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the plugin is deployed, we need to modify the workflow to include the
    validator. The following screenshot is how the validator looks when it is added
    initially. This, as you now know, is rendered using the input template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the validator is added (after selecting the **Test Number** field), it
    is rendered using the view template and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you try to edit it, the screen will be rendered using the edit template,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the **Test Number** field is already selected.
  prefs: []
  type: TYPE_NORMAL
- en: After the workflow is configured, when the user goes to an issue and tries to
    progress it, the validator will check if the **Test Number** field has a value
    or not. It is at this point that the `validate` method in the `FieldValidator`
    class is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value is missing, you will see an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a skeleton plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying your plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a workflow post function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now look at workflow post functions. Workflow post functions are very
    effective and heavily used. They allow you to do a lot of things when you progress
    on the workflow on an issue. A lot of customizations and workarounds take this
    route!
  prefs: []
  type: TYPE_NORMAL
- en: Workflow post functions are created with the help of the `workflow-function`
    module. The following are the key attributes and elements supported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | This should be unique within the plugin. |'
  prefs: []
  type: TYPE_TB
- en: '| `Class` | Class to provide contexts for rendered velocity templates. Must
    implement the `com.atlassian.jira.plugin.workflow.WorkflowNoInputPluginFactory`
    interface if the function doesn''t need input, or `com.atlassian.jira.plugin.workflow.WorkflowPluginFunctionFactory`
    if it needs input. |'
  prefs: []
  type: TYPE_TB
- en: '| `i18n-name-key` | The localization key for the human-readable name of the
    plugin module. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Human-readable name of the workflow function. |'
  prefs: []
  type: TYPE_TB
- en: '**Elements**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | Description of the workflow function. |'
  prefs: []
  type: TYPE_TB
- en: '| `function-class` | Class which does the validation. Must implement `com.opensymphony.workflow.FunctionProvider`.
    Recommended to extend `com.atlassian.jira.workflow.function.issue.AbstractJiraFunctionProvider`,
    as it already implements many useful methods. |'
  prefs: []
  type: TYPE_TB
- en: '| `resource type="velocity"` | Velocity templates for the workflow function
    views. |'
  prefs: []
  type: TYPE_TB
- en: 'There are three other elements that can be used with a post function. They
    are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`orderable` – (true/false) Specifies if this function can be re-ordered within
    the list of functions associated with a transition. The position within the list
    determines when the function actually executes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique` – (true/false) Specifies if this function is unique, that is, if it
    is possible to add multiple instances of this post function on a single transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deletable` – (true/false) Specifies if this function can be removed from a
    transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: See [http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Functions](http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Functions)
    for more details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, create a skeleton plugin. Create an eclipse project using the skeleton
    plugin and we are good to go!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume we have a user custom field and we want to set the current user or a
    specified user name on to the custom field when a particular transition happens.
    A typical use case for this will be to store the name of the user who last resolved
    an issue. The following are the steps to write a generic post function that sets
    the current username or a username provided by the user on a user custom field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the inputs needed to configure the workflow post function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As opposed to workflow conditions and validators, there are two interfaces available
    for a workflow post function factory class. If there are no inputs needed to configure
    the function, the factory class must implement `WorkflowNoInputPluginFactory`.
    An example will be to set the current user's name as the custom field value instead
    of the user configured name. If inputs are needed to configure the post function,
    the factory class must implement `WorkflowPluginFunctionFactory`. In our example,
    we take the username as the input.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Both the interfaces mainly exist to provide velocity parameters to the templates.
    They will be used to extract the input parameters that are used in defining the
    functions. To make it clear, the inputs here are not the input while performing
    the workflow action, but the inputs in defining the post function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The function factory class, `SetUserCFFunctionFactory` in this case, extends
    the `AbstractWorkflowPluginFactory` and implements the `WorkflowPluginFunctionFactory`
    interface. Just like conditions, there are three abstract methods that we should
    implement, namely, `getVelocityParamsForInput`, `getVelocityParamsForEdit`, and
    `getVelocityParamsForView`. All of them, as the names suggest, are used for populating
    the velocity parameters for the different scenarios:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may have noticed that the methods look very similar to the ones in workflow
    conditions or validators, except for the business logic! Let us look at the methods
    in detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVelocityParamsForInput` : This method defines the velocity parameters for
    input scenario, that is, when the user initially configures the workflow. In our
    example, we need to use a text field that captures the username to be added on
    the issue.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getVelocityParamsForView`: This method defines the velocity parameters for
    the view scenario, that is, how the user sees the post function after it is configured.
    In our example, we have defined a field, and so we should display it to the user
    after retrieving it from the workflow descriptor. You may have noticed that the
    descriptor, which is an instance of `AbstractDescriptor`, is available as an argument
    in the method. All we need is to extract the username from the descriptor, which
    can be done as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Just check if the descriptor is a validator descriptor or not, and then extract
    the field as shown in the preceding snippet.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVelocityParamsForEdit`: This method defines the velocity parameters for
    the edit scenario, that is, when the user modifies the existing validator. Here
    we need both the options and the selected value. Hence, we put both the custom
    fields'' collection and the field name on to the velocity parameters.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second step is to define the velocity templates for each of the three scenarios:
    input, view, and edit. We can use the same template here for input and edit with
    a simple checking to keep the old field selected for the edit scenario. Let us
    look at the templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`edit-userCFFunction.vm`: Displays all custom fields and highlights the already
    selected one in the edit mode:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`view-userCFFunction.vm` .displays the selected field:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The third step is to write the actual function. The function class must extend
    the `AbstractJiraFunctionProvider` interface. All we need here is to implement
    the `execute` method. In our example, we retrieve the username from the issue
    and set it on the `Test User` custom field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like a validator, the issue on which the post function is executed can be retrieved
    using the `transientVars` map. The user can be retrieved from the `args` map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here the `setUserValue` method simply sets the username on the passed custom
    field, as shown in the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that is left now is to populate the `atlassian-plugin.xml` file with these
    components. We use the `workflow-condition` module and it looks like the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package the plugin and deploy it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the plugin is deployed, we need to modify the workflow to include the
    function. The following is where the function appears along with the built-in
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on our post function takes us to the configuration page, shown next.
    This, as you now know, is rendered using the input template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the function is added (after entering in the **UserName** field), it
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you try to edit, the screen will be rendered using the edit template, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the **UserName** field is already populated.
  prefs: []
  type: TYPE_NORMAL
- en: After the workflow is configured, when the user executes the workflow action,
    the **Test User** custom field is set with the value **jobinkk**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a skeleton plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying your plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing an active workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how the workflow plays an important role in configuring our JIRA
    and how we can write plugins to add more workflow conditions, validators, and
    post functions. Once these plugins are added, we need to modify the workflow to
    include the newly created components at the appropriate transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an inactive workflow or creating a new workflow is pretty easy. You
    can add the conditions/validators/post functions when you create the transition
    or just click on the transition to modify them. But to edit an active workflow,
    there are a few more steps involved which we will see in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: A workflow is active when it is being used in an active workflow scheme that
    is tied to a project. You can check whether a workflow is active by navigating
    to **Administration** | **Global** **Settings** | **Workflows**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to edit an active workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Login as a JIRA Administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Administration** | **Global** **Settings** | **Workflows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create a draft workflow** link on the workflow you want to edit.
    The link can be found under the **Operations** column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *step* or *transition* that you want to modify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the changes. The changes won't be effective until the workflow is published.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all the changes are made, click on the **publish this draft** link at
    the top of the page if you are still viewing the modified workflow. You can also
    click on **Publish** under the **Operations** column while viewing all the workflows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of the old workflow, when prompted, if you need a backup, and click
    on **Publish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After making changes on the draft and clicking on **Publish**, the new workflow
    will be active. However, there are some limitations to this procedure, which are
    detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't delete an existing workflow step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't edit the status associated with an existing step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an existing step has no outgoing transitions, you can't add any new outgoing
    transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't change the step IDs for any existing steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to overcome these limitations, you need to copy the workflow, modify
    the copy, and make it active by migrating the projects on to the new workflow.
  prefs: []
  type: TYPE_NORMAL
- en: After the new workflow is active, any transitions on the issue will be based
    on the new workflow.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to modify an active workflow, thus overcoming some of the limitations
    aforementioned but don't want to go through the pain of migrating all the projects
    involved, you might want to look at modifying it directly in the JIRA database.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we should be careful about the workflow changes when we do this. For
    example, if there are issues in a status that is removed in the modified workflow,
    those issues will be stuck at the removed status. The same can happen for the
    removed steps.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying workflows in JIRA database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the steps to modify the workflows in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Export the workflow that needs to be modified into XML. You can do it using
    the XML link under the **Operations** column of a workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the XML to include your changes (or alternatively, make changes in a
    copy of the JIRA workflow and export that as XML).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the JIRA instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to your JIRA database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a backup of the existing database. We can revert to this backup if anything
    goes wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `JIRAWORKFLOWS` table to modify the `descriptor` column with the
    new XML file for the appropriate workflow. When the workflow XML is huge, it might
    be useful to rely on database-specific methods to update the table. For example,
    we can use Oracle XML database utilities ([http://download.oracle.com/docs/cd/B12037_01/appdev.101/b10790/xdb01int.htm](http://download.oracle.com/docs/cd/B12037_01/appdev.101/b10790/xdb01int.htm)),
    if JIRA is connected to the Oracle database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the changes and disconnect from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the JIRA instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-index JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making an issue editable/non-editable based on workflow status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that the edit permission on an issue is controlled through the **Edit
    Issue** **Permission**. This is used within the permissions schemes tied to a
    project and it blocks/allows editing of the issue, irrespective of which status
    it is in! But many a times the need arises to block an issue being edited at a
    specific status. An example would be to prevent editing on a closed issue.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a quick look at how to achieve this using workflow properties.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make an issue editable or non-editable using the `jira.issue.editable`
    workflow property. The following is the step-by-step procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Login as a JIRA Administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Administration** | **Global** **Settings** | **Workflows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a draft of the workflow, if it is active. Navigate to the *step* which
    needs to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **View step's properties** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **jira.issue.editable** into the **Property Key** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **false** in the **Property Value** field, if you want to prevent editing
    on the issue after this transition is performed. Use **true** as the value, if
    you want to make it as editable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back and publish the workflow if it was active. If not, associate the workflow
    with the appropriate schemes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the property is added on a workflow *step* and not a *transition*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an issue is viewed, the edit operation is available only if you have the
    edit permission and the workflow manager passes the issue as editable. The workflow
    manager retrieves the list of properties added onto the issue's current status
    (that is, the step linked to the status) and checks the value of the `jira.issue.editable`
    property to see if it set to `false` or not before passing the issue as editable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties against an issue workflow step are retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `jira.issue.editable` property value is retrieved as `properties.get(JiraWorkflow.JIRA_META_ATTRIBUTE_EDIT_ALLOWED)`,
    where `JiraWorkflow.JIRA_META_ATTRIBUTE_EDIT_ALLOWED = "jira.issue.editable"`.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach can be used to retrieve any other property added on a workflow
    step.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Permissions based on workflow status*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including/excluding resolutions for specific transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't noticed already, resolutions in JIRA are global. If you have
    a resolution **Resolved**, it appears whenever the resolution field is added on
    a transition screen. This might not make sense in some cases. For example, it
    doesn't make sense to add the resolution **Resolved** when you are rejecting an
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how we can pick and choose resolutions based on workflow transitions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can include/exclude specific resolutions on workflow transitions using the
    `jira.field.resolution.include` and `jira.field.resolution.exclude` properties.
    The following is the step-by-step procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Login as a JIRA Administrator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Administration** | **Global** **Settings** | **Workflows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a draft of the workflow, if it is active. Navigate to the transition
    which needs to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **View properties of this transition** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **jira.field.resolution.include** or **jira.field.resolution.exclude**
    into the **Property Key** field, depending on whether you want to include or exclude
    a specific resolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the comma-separated list of resolution IDs that you want to include/exclude,
    under the **Property Value** field. The resolution ID can be obtained by navigating
    to **Administration** | **Issue** **Settings** | **Resolutions**, and hovering
    over the **Edit** link:![How to do it...](img/1803-04-12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also find the resolution ID by querying the `resolutions` table in the
    database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back and publish the workflow if it was active. If not, associate the workflow
    with the appropriate schemes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the property is added on a workflow *transition* and not a *step*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `jira.field.resolution.exclude` property is added, all the resolutions
    whose IDs are entered as a comma-separated values under the `Property Value` field
    are excluded from the screen during that transition.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if `jira.field.resolution.include` is added, only the resolutions
    whose IDs are entered as a comma-separated values under the `Property Value` field
    are shown in the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions based on workflow status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to restrict editing on an issue based on the workflow status.
    JIRA gives us an even bigger set of options to restrict many of these operations
    (such as edit, comment, and so on) on the issue or its subtasks, depending on
    the issue status.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is done in a similar way to making an issue editable/non-editable. Here,
    also, we add a property on the concerned workflow step. The following are the
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in as a JIRA Administrator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Administration** | **Global** **Settings** | **Workflows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a draft of the workflow, if it is active. Navigate to the step which
    needs to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **View step's properties** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the permission property into the **Property Key** field. The property
    is of the form – `jira.permission.[subtasks.]{permission}.{type}[.suffix]` where:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`subtasks` – This is optional. If included, the permission is applied on the
    issue''s subtasks. If not, the permission is applied on the actual issue.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permission` – A short name specified in the `Permissions` ([http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/security/Permissions.html](http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/security/Permissions.html))
    class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the permitted values, as of JIRA 4.2: `admin`, `use`, `sysadmin`,
    `project`, `browse`, `create`, `edit`, `scheduleissue`, `assign`, `assignable`,
    `attach`, `resolve`, `close`, `comment`, `delete`, `work`, `worklogdeleteall`,
    `worklogdeleteown`, `worklogeditall`, `worklogeditown`, `link`, `sharefilters`,
    `groupsubscriptions`, `move`, `setsecurity`, `pickusers`, `viewversioncontrol`,
    `modifyreporter`, `viewvotersandwatchers`, `managewatcherlist`, `bulkchange`,
    `commenteditall`, `commenteditown`, `commentdeleteall`, `commentdeleteown`, `attachdeleteall`,
    `attachdeleteown`.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`type` – Type of permission granted/denied. The values can be `group`, `user`,
    `assignee`, `reporter`, `lead`, `userCF`, `projectrole`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suffix` – An optional suffix to make the property unique when you have the
    same type added more than once! `jira.permission.edit.group.1`, `jira.permission.edit.group.2`,
    and so on. This is because of the OSWorkflow restriction that the property value
    should be unique.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the appropriate value in the **Property Value** field. If the type is
    group, enter a group. If it is a user, enter a username, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It might be useful to give a few examples here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`jira.permission.comment.group=some-group`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jira.permission.comment=denied`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jira.permission.edit.group.1=some-group-one`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jira.permission.edit.group.2=some-group-two`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jira.permission.modifyreporter.user=username`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jira.permission.delete.projectrole=10000`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jira.permission.subtasks.delete.projectrole=10000`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can even use the value as 'denied' when the type is not used. For example,
    `jira.permission.comment=denied` means the comment feature is disabled at this
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go back and publish the workflow, if it was active. If not, associate the workflow
    with the appropriate schemes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a particular permission property is tied to a workflow status, JIRA looks
    at it and enforces it. It is to be noted that workflow permissions can only restrict
    permissions set in the permission scheme, not grant permissions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have the edit permission restricted to `jira-administrators`
    in the permission scheme, adding `jira.permission.edit.group=jira-users` wouldn't
    grant the permission to `jira-users`.
  prefs: []
  type: TYPE_NORMAL
- en: But instead, if you had both of these groups with the edit permission, only
    `jira-users` will be allowed to edit, as defined in the workflow permission.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Making an issue editable/non-editable based on workflow status*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization in workflow transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your JIRA instance is used by people around the world speaking different
    languages, it is likely that you use internationalization to convert JIRA into
    their own language. But things like the workflow action name, button name, and
    so on are configured in the workflows and not as i18n properties. And therefore,
    they are limited to a single language.
  prefs: []
  type: TYPE_NORMAL
- en: This is where workflow properties come to our rescue, again!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can modify the workflow action submit button name or the action name using
    the properties `jira.i18n.submit` or `jira.i18n.title` respectively. The following
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the jar file `atlassian-jira/WEB-INF/lib/language_<language code>_<country
    code>.jar`. From JIRA 4.3, the jar filename is of the form `jira-lang-<language
    code>_<country code>-<jira version>.jar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the file `\com\atlassian\jira\web\action\JiraWebActionSupport_<language
    code>_<country code>.properties` inside the jar. You can use a utility such as
    7zip to edit the file inside the jar. Alternatively, you can extract the jar,
    modify the file, and archive it again!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add your i18n property and its value: `my.submit.button=My Submit Button in
    English`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the file and restart JIRA to pick up the new property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in as a JIRA Administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Administration** | **Global** **Settings** | **Workflows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a draft of the workflow, if it is active. Navigate to the transition
    which needs to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **View properties of this transition** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **jira.i18n.submit** or **jira.i18n.title** into the **Property Key**
    field, depending on whether you want to modify submit button name or action name.
    Let us consider the example of the Submit button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter i18n key that we used in the property file, under the **Property Value**
    field. In our example, the key is **my.submit.button**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back and publish the workflow, if it was active. If not, associate the workflow
    with the appropriate schemes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the workflow is published, JIRA will populate the submit button name from
    the i18n property file the next time the transition happens. In our example, the
    transition screen will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the button name is changed to **My Submit Button in English**.
    All you need to do now is modify the other language jars to include the proper
    translations!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Internationalization in v2 plugins*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining available workflow actions programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often in our programs, we may come across the need to retrieve the current workflow
    actions, available on the issue. Let us have a look at how to do this using the
    JIRA API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the JIRA workflow object associated with the issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, issue is the current issue, which is an instance of `com.atlassian.jira.issue.Issue`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get the issue status and use it to retrieve the current workflow step linked
    to the issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the set of available actions from the current step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `actions` is a list of `com.opensymphony.workflow.loader.ActionDescriptor`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Iterate on the `ActionDescriptors` and get the details for each action, depending
    on the requirement! The name of the available action can be printed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**WorkflowManager** is used to perform a lot of operations related to workflows
    such as creating/updating/deleting a workflow, copying it, creating a draft, and
    so on. Here we use it to retrieve the workflow object, based on the issue selected.
    Please check the API ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowManager.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowManager.html))
    for a full list of available operations using `WorkflowManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we retrieve the JIRA workflow, we get the current step using the status.
    As you have seen before in this chapter, a workflow *status* is linked to one
    and only one workflow *step*. Once we get the *step*, we can get a load of information
    from it, including the available actions from that *step*.
  prefs: []
  type: TYPE_NORMAL
- en: Jolly good?
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's more to it…
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Action IDs, given name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same method can be used to retrieve the action ID, given an action name.
    Remember, it is the action ID that we use while programmatically progressing on
    the workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the action name is available, you can easily retrieve the action ID by
    iterating on the list of actions, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Programmatically progressing on workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another operation that we perform normally on workflows is to programmatically
    transit the issues through its workflows. Let us have a look at how to do this
    using the JIRA API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since JIRA 4.1, transitioning issues is done using the `IssueService` ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/issue/IssueService.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/issue/IssueService.html)).
    Here''s is how you do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the `IssueService` object either by injecting it in the constructor or
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find out the action ID for the action to be executed. You can either get it
    by looking at the workflows (the number within brackets alongside the transition
    name), if you know it is not going to change or retrieve it using the action name
    (refer to the previous recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the `IssueInputParameters` if you want to modify anything on the issue
    such as assignee, reporter, resolution, and so on! It represents an issue builder
    and is used to provide parameters that can be used to update the issue during
    the transition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A full list of supported fields can be found at [http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/IssueInputParameters.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/IssueInputParameters.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Validate the transition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`User` – The current user or the user who will be performing the transition'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`12345L` – The issue ID'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10000L` – The action ID'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issueInputParameters` – The parameters we populated in the previous step'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `transitionValidationResult` is valid, invoke the transition operation. Handle
    it if it is not valid. Make sure you use the same user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to do a final check on the result as well to see if it is valid!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That will transit the issue to the appropriate state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prior to `IssueService`, the transition was done using `WorkflowTransitionUtil`
    ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowTransitionUtil.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowTransitionUtil.html)).
    It is still supported, but `IssueService` is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the transitioning is done using `WorkflowTransitionUtil`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the `WorkflowTransitionUtil` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a map of parameters that need to be updated on the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the `workflowTransitionUtil` with the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Validate the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no error, progress with the workflow. Handle the errors, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And we should have the issue in its new status! Check the error collection to
    handle errors, if any.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the action ID is correct and the parameters are validated properly, `IssueService`
    or `WorkflowTransitionUtil` will do the background work of transitioning the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining workflow history from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA captures changes on an issue in its "change history". It is pretty easy
    to find them by going to the change history tab on the view issue page.
  prefs: []
  type: TYPE_NORMAL
- en: But often, we would like to find out specific details about the various workflow
    statuses that an issue has gone through in its lifecycle. Going through the change
    history and identifying the status changes is a painful task when there are tens
    of hundreds of changes on an issue. People normally write plugins to get around
    this or go directly to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Even when it is achieved using plugins, the background logic is to look at the
    tables in the database. In this recipe, we will look at the tables involved and
    writing the SQL query to extract workflow changes for a given issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have an SQL client installed and configured that will help you
    to connect to the JIRA database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the JIRA database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find out the `id` of the issue for which you want to extract the workflow changes.
    If you don''t have the ID in hand, you can get it from the database using the
    issue key as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where `JIRA-123` is the issue key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract all the change groups created for the issue. Every set of changes made
    on an issue during a single operation (for example, edit, workflow transition,
    and so on) are grouped in to a single `changegroup` by JIRA. It is on the `changegroup`
    record that JIRA stores the associated `issueid` and the `created` date (date
    when the change was made):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where `10010` is the `issue` `id`, the ID we extracted in the previous step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While extracting the change groups, we can even mention the created date if
    you want to see only changes on a specific date! Use the author field to restrict
    this to changes made by a user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract `status` changes for the group/groups selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here the `groupid` `10000`, `10010`, and so on are IDs extracted in the previous
    step. Here, `oldstring` is the original value on the issue and `newstring` is
    the updated value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Include `oldvalue` and `newvalue`, if you want to get the status IDs as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can write it in a single query, as shown next, or modify it to include more
    details. But hopefully, this gives you a starting point!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example to extract the details along with the created date is to use
    inner join as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Over to you DBAs now!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, the changes at any single operation on an issue are stored as
    a `changegroup` record in the JIRA database. The main three columns `issueid`,
    `author`, and `created` are all parts of this table.
  prefs: []
  type: TYPE_NORMAL
- en: The actual changes are stored in the `changeitem` table with its foreign key
    `groupid` pointing to the `changegroup` record.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are looking specifically at the workflow statuses, and hence
    we query for records that have the `fieldtype` value of `jira` and `field` of
    `status`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the query (that uses an inner join) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Retrieving workflow details from a table*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-ordering workflow actions in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a JIRA workflow, the available actions that appear in the **View Issue**
    page are normally ordered in the sequence those transitions were created. This
    works fine most of the time, but in some cases, we will want to change the order
    in which it appears on the issue screen!
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this logical ordering of workflow actions on the **View Issue** page,
    JIRA provides us with a workflow property named `opsbar-sequence`. Let us see
    how we modify the ordering using this property instead of tampering with the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in as a JIRA Administrator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Administration** | **Global** **Settings** | **Workflows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a draft of the workflow, if it is active. Navigate to the transition
    which needs to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **View properties of this transition** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **opsbar-sequence** into the **Property Key** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **sequence** value under the **Property Value** field. This value
    should be relative to the values entered in the other transitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back and publish the workflow, if it was active. If not, associate the workflow
    with the appropriate schemes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the property is added on a workflow *transition* and not a *step*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider the following example where the **Reject this** workflow action
    appears first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Normally, people would want to see this as the last option because it is most
    likely the least used operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are four operations here, we can order them as shown in the following
    table with the sequence values against them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Workflow action | Sequence |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Start Progress** | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| **Resolve Issue** | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| **Close Issue** | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| **Reject this** | 40 |'
  prefs: []
  type: TYPE_TB
- en: Note that the sequence numbers can even be 1, 2, 3, and 4\. There are no restrictions
    on how and where the numbers should start. It is advised to keep 10, 20, and so
    on so that we can insert new transitions in between, if required in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we modify the workflow using the property and the aforementioned sequence
    numbers, as we saw in the previous section, the actions are ordered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-04-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember, the order of the workflow actions is changed only in the **View Issue**
    page and not in the **View Workflow Steps** page, where you modify the workflow
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating common transitions in workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring workflows can be a painful thing. Especially when there are similar
    transitions used in 10 different places and those get changed every now and then.
    The change might be the simplest thing possible, such as editing just the name
    of the transition, but we end up modifying it in 10 places.
  prefs: []
  type: TYPE_NORMAL
- en: This is where OSWorkflow's common actions come to our rescue. A little bit on
    the theory can be read at [http://www.opensymphony.com/osworkflow/3.3%20Common%20and%20Global%20Actions.html](http://www.opensymphony.com/osworkflow/3.3%20Common%20and%20Global%20Actions.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'JIRA already makes use of common actions in its default workflow. We can''t
    modify the default workflow, but if we make a copy of it and rename the **Resolve**
    transition to **New Resolve**, it appears as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating common transitions in workflows](img/1803-04-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the transition is renamed at all the three places where it appears!
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, let us look at adding a new common transition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways of adding common transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the JIRA default workflow and modify it to suit our needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create workflow using XML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first one is useful only if our workflow needs are limited, that is, only
    if we can live by modifying the existing transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to configure a bigger workflow with new common transitions, we need
    to take the XML route. Let us see the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, export the existing workflow that needs to be modified
    into an XML. You can do this using the XML link on the view workflows page. You
    could create a workflow XML from scratch, but that needs lot of effort and knowledge
    of OSWorkflow. In this case, we export the standard JIRA workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the `common-actions` section in the workflow XML. It comes in the starting
    immediately after `initial-actions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our new `common-action`. There are a few things that we need to notice here.
    The action ID should be a unique ID within the XML. You will find examples of
    all this in the standard workflow XML or you can read more about them in the OSWorkflow
    documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is how a simple action looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you modify the name, description, status, step, eventTypeId, and the
    post functions. Here we used `Finished` as the `old-status` as it is used in the
    other common actions in the JIRA standard workflow. You can also add new meta
    attributes, conditions, validators, and so on, but it probably is a good idea
    to start simple and modify everything else in the JIRA UI once it is imported
    to JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the common action in the other steps, wherever required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the ID here should be the action ID of the `common-action` we added
    in the previous steps. Also, the `common-actions` should appear before the `action`
    elements in the *step* in order to comply with the OSWorkflow syntax.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Import the modified XML as a workflow to JIRA. You can do this using the **Import
    a Workflow from XML** link. Check out [http://confluence.atlassian.com/display/JIRA/Configuring+Workflow#ConfiguringWorkflow-UsingXMLtocreateaworkflow](http://confluence.atlassian.com/display/JIRA/Configuring+Workflow#ConfiguringWorkflow-UsingXMLtocreateaworkflow)
    for details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The workflow is now ready to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How i works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA workflows are fundamentally using OpenSymphony's OSWorkflow, as we saw
    in [Chapter 2](ch02.html "Chapter 2. Understanding Plugin Framework"), *Understanding
    Plugin Framework*. OSWorkflow gives us the flexibility to add common actions by
    modifying the workflow XML. We have used this feature by modifying the existing
    workflow XML and importing it back in to JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is how the updated workflow looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How i works...](img/1803-04-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the new transition **Start Again** is added to all the steps other
    than the last one. Suppose we want to modify the name to **Start Again & Again**,
    it can be done just by editing one of these transitions. The modified workflow
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How i works...](img/1803-04-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can similarly modify any attributes on the transition, and it will be reflected
    in all the places where the transition is used.
  prefs: []
  type: TYPE_NORMAL
- en: Jelly escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before winding up this chapter, let us have a quick look at how we can use one
    of the useful features of JIRA to escalate inactive issues by transitioning them
    to a pre-defined workflow status.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jelly Service** is a built-in service in JIRA using which we can run useful
    Jelly scripts at regular intervals. Atlassian explains in its documentation at
    [http://confluence.atlassian.com/display/JIRA/Jelly+Escalation](http:// http://confluence.atlassian.com/display/JIRA/Jelly+Escalation)
    about running a Jelly script to move issues that were not updated in the last
    seven days to an inactive status.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us have a look at this recipe at how to modify the script and transition
    issues in to different workflow statuses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure Jelly is turned on in your JIRA instance. It is disabled by default
    due to security concerns. You can turn it ON by setting the `jira.jelly.on` property
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the property by adding `-Djira.jelly.on=true` into the `JAVA_OPTS`
    variable. Adding this variable depends on the server and operating system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the property can be set on the Tomcat server in Windows by adding
    it into `setenv.bat` under the `/bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to close issues that have been inactive for the
    last 15 days:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a filter that displays issues that are not updated for the last 15 days.
    You can do this by executing the following JQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the filter with some name and make a note of the filter ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-04-20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can find the filter ID by hovering over the **Edit** link, as shown. The
    URL will be like `http://localhost:8080/secure/EditFilter!default.jspa?atl_token=084b891405e500819d6443d8378ed37a5bbe4c72&filterId=10010&returnUrl=ManageFilters.jspa`
    where `filterId` is `10010`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the Jelly script provided by Atlassian in order to include the new filter
    ID, workflow step name, username, and password. Also modify the comment accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the modified script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and put it under some location in the server where JIRA is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Administration** | **System** | **Services** **in** **JIRA**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the escalation service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name**: Escalation Task'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Click on **Built-in services** and select **Run Jelly Script**.
    The class will be selected as `com.atlassian.jira.jelly.service.JellyService`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delay**: Select a suitable delay, in minutes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Add Service**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the **Add Service** page, enter the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Input File**: Path to the script file we saved in the server'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output File**: Path to an output log file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delay**: Modify if required.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The script will now run the configured delay.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JIRA has its own API for the **Jelly Scripting**. As you can see from the script,
    following are the steps executed:'
  prefs: []
  type: TYPE_NORMAL
- en: The script runs the search request on the filter we saved in the first step
    using the `RunSearchRequest` method. It then stores the retrieved results in variable
    issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Script then iterates on the issues and transitions each of them in the workflow
    using the `TransitionWorkflow` method. It makes use of the key from the issue,
    the workflow user we configured, and the workflow action. It also adds the comment
    we entered in the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the workflow action should be available on the issue from its current
    status. If it is not, the transition will not work. For example, Close workflow
    action will throw an error if attempted on an issue that is already Closed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can modify the script to transition the issue to any workflow status based
    on any filter criteria.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of other useful things about Jelly Scripting can be found at [http://confluence.atlassian.com/display/JIRA/Jelly+Tags](http://confluence.atlassian.com/display/JIRA/Jelly+Tags).
  prefs: []
  type: TYPE_NORMAL
