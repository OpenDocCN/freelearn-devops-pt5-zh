<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Gitolite</h1></div></div></div><p>Git is one of the most <a id="id0" class="indexterm"/>popular version control systems currently available, and several thousands of projects, new and old, have started using it in the past few years. You might have also used it, and shortly after, realized that Git does not do much for Access Control by itself. You need an access control system that is simple and quick to install and get running, yet flexible and powerful enough for your future needs.</p><p>This chapter will describe what Gitolite<a id="id1" class="indexterm"/> is, and why you might need it. It shows a few examples of the basic features, and also shows you how you can try out Gitolite safely. It assumes that you have some basic knowledge of Git, and have used Git both locally and with a remote repository.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Common Access Control needs</h1></div></div></div><p>Git server administrators face a bit of a challenge. The high uptake rate of Git means that there are thousands of developers who are not really familiar with Git, and who therefore may be running Git<a id="id2" class="indexterm"/> commands that cause irreversible or highly disruptive changes to the Git repository. Furthermore, Git itself does not help much with this; whatever access controls it has, apply to the entire repository, and cannot be made more fine-grained.</p><p>For instance, the<a id="id3" class="indexterm"/> master branch in most projects represents the most stable code. Yet, a junior developer can easily run a command such as <code class="literal">git push origin +master</code>, (which pushes the developer's local branch onto the server) and thus overwrite weeks or months of hardwork by the rest of the team. People with deeper Git expertise can probably recover the lost commits, but it would certainly take time and effort.</p><p>Worse, Git's command syntax sometimes makes it worse. For example, the command to delete the master branch is only slightly different from a normal push, that is, <code class="literal">git push origin :master</code> (notice the extra colon?).</p><p>The most common need, therefore, is to prevent these kinds of accidents: overwriting (or rewinding) one or more commits, and deleting a branch or a tag.</p><p>Git itself does provide some measure of protection. You can set the config items <code class="literal">receive.denyDeletes</code> and <code class="literal">receive.denyNonFastForwards</code> to <code class="literal">true</code>. Unfortunately, this is a bit of a blunt instrument—now no one can delete or rewind <em>any</em> branch!</p><p>In larger setups <a id="id4" class="indexterm"/>with several repositories and several developers, you may also be concerned about allowing everyone to read all repositories. Or<a id="id5" class="indexterm"/> it may be that some roles (such as a test engineer) should not need to write to the repository; read-only access is sufficient. Up to a certain point, this problem can be solved with Unix permissions and user/group permissions applied judiciously. Perhaps even POSIX ACLs can be used if you're comfortable with that sort of thing.</p><p>However, using POSIX ACLs<a id="id6" class="indexterm"/> and user/group permissions has several disadvantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each Git user needs a corresponding Unix user ID on the server.</li><li class="listitem" style="list-style-type: disc">Managing access rights can only be done by using the <code class="literal">usermod</code> and <code class="literal">setfacl</code> commands.</li><li class="listitem" style="list-style-type: disc">Checking the current set of permissions is not straightforward. You will need to run multiple commands and correlate their output manually.</li><li class="listitem" style="list-style-type: disc">Auditing changes in permissions over time is impossible because no history is kept by the system.</li></ul></div><p>These disadvantages require a lot of effort to manage even a few repositories and users, and even a modestly sized setup would quickly become unmanageable.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Access Control example with Gitolite</h1></div></div></div><p>We will see<a id="id7" class="indexterm"/> how simple Access Control can be with Gitolite. First,<a id="id8" class="indexterm"/> here's an example where the junior developers (let's call them Alice and Bob here) should be prevented from rewinding or deleting any branches, while the senior developers (Carol and David) are allowed to do so:</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>We will see this in more detail in later chapters, but Gitolite uses a plain text file to specify the configuration, and these access rules are placed in that file.</p></div></div><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>  RW    =  alice bob</strong>
<strong>  RW+   =  carol david</strong>
</pre></div><p>You probably guessed that the <code class="literal">RW</code> stands for read and write. The <code class="literal">+</code> in the second rule stands for <em>force</em>, just as it does in the <code class="literal">push</code> command, and allows you to rewind or delete a branch.</p><p>Now, suppose <a id="id9" class="indexterm"/>we want the junior developers to have some <a id="id10" class="indexterm"/>specific set of branches that they should be allowed to rewind or delete, a sort of "sandbox", if you will. The following command will help you to implement that:</p><div><pre class="programlisting">
<strong>  RW+  sandbox/  =  alice bob</strong>
</pre></div><p>Alice and Bob can now push, rewind, or delete any branches whose names start with <code class="literal">sandbox/</code>.</p><p>Access Control at the repository level is even easier, and you may even have guessed what that looks like:</p><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>    RW+     =   alice</strong>
<strong>    R       =   bob</strong>

<strong>repo bar</strong>
<strong>    RW+     =   bob</strong>
<strong>    R       =   alice</strong>

<strong>repo baz</strong>
<strong>    RW+     =   carol</strong>
<strong>    R       =   alice bob</strong>
</pre></div><p>As you can see, you have three users with different access permissions for each of the three repositories. Doing this using the file systems' permissions mechanisms or POSIX ACLs would be doable, but quite cumbersome to set up and to audit/review.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Sampling of Gitolite's power features</h1></div></div></div><p>The access control examples <a id="id11" class="indexterm"/>show the most commonly used feature of Gitolite, the repository and branch level access control, but of course Gitolite has many more features. In this section, we will briefly look at a few of them while noting that there are many more waiting in the wings for you to find as you read this book.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Creating groups</h2></div></div></div><p>Gitolite<a id="id12" class="indexterm"/> allows<a id="id13" class="indexterm"/> you to create groups of users or repositories for convenience. Think back to Alice and Bob, our junior developers. Let's say you had several rules that Alice and Bob needed to be mentioned in. Clearly, this is too cumbersome; every time a new developer joined the team, you'd have<a id="id14" class="indexterm"/> to change all the rules to add him or her.</p><p>Gitolite lets <a id="id15" class="indexterm"/>you do this by using the following command:</p><div><pre class="programlisting">
<strong>@junior-devs    =  alice bob</strong>
</pre></div><p>Later, it lets you do this by using the following command:</p><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>  RW                    =  @junior-devs</strong>
<strong>  RW+                   =  carol david</strong>
<strong>  RW+  sandbox/         =  @junior-devs</strong>
</pre></div><p>This allows you to add the junior developer in just one place at the top of the configuration file instead of potentially several places all over. More importantly, from the administrator's point of view, it serves as excellent documentation for the rules themselves; isn't it easier to reason about the rules when a descriptive group name is used rather than actual usernames?</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Personal branches</h2></div></div></div><p>Gitolite <a id="id16" class="indexterm"/>allows the administrator to give each developer a <a id="id17" class="indexterm"/>unique set of branches, called personal branches, that only he or she can create, push, or delete. This is a very convenient way to allow quick backups of work-in-progress branches, or share code for preliminary review.</p><p>We saw how the sandbox area was defined:</p><div><pre class="programlisting">
<strong>  RW+  sandbox/  =  alice bob</strong>
</pre></div><p>However, this does nothing to prevent one junior developer from accidentally wiping out another's branches. For example, Alice could delete a branch called <code class="literal">sandbox/bob/work</code> that Bob may have pushed. You can use the special word <code class="literal">USER</code> as a directory name to solve this problem:</p><div><pre class="programlisting">
<strong>  RW+  sandbox/USER/  =  alice bob</strong>
</pre></div><p>This works as if you had specified each user individually, like this:</p><div><pre class="programlisting">
<strong>  RW+  sandbox/alice/   =  alice</strong>
<strong>  RW+  sandbox/bob/     =  bob</strong>
</pre></div><p>Now, the set of branches that Alice is allowed to push is limited to those starting with <code class="literal">sandbox/alice/</code>, and she can no longer push or delete a branch called, say, <code class="literal">sandbox/bob/work</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Personal repositories</h2></div></div></div><p>With Gitolite, the<a id="id18" class="indexterm"/> administrator can choose to let the user create <a id="id19" class="indexterm"/>their own repositories, in addition to the ones that the administrator themselves creates. For this example, ignore the syntax, which will be explained in a much later chapter, but just focus on the functionality now:</p><div><pre class="programlisting">
<strong>repo dev/CREATOR/[a-z].*</strong>
<strong>  C       =  @staff</strong>
<strong>  RW+     =  CREATOR</strong>
</pre></div><p>This allows members of the <code class="literal">@staff</code> group to create repositories whose names match the pattern supplied, which just means <code class="literal">dev/&lt;username&gt;/&lt;anything starting with a lowercase alphabetic character&gt;</code>. For example, a user called <code class="literal">alice</code> will be able to create repositories such as <code class="literal">dev/alice/foo</code> and <code class="literal">dev/alice/bar</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Gitolite and the Git control flow</h1></div></div></div><p>Conceptually,<a id="id20" class="indexterm"/> Gitolite is <a id="id21" class="indexterm"/>a very simple program. To see how it controls access to a Git repository, let us first look at how control flows from the client to the server in a normal git operation (say <code class="literal">git fetch</code>) when using plain <code class="literal">ssh</code>:</p><div><img src="img/2371OS_01_01.jpg" alt="Gitolite and the Git control flow"/></div><p>When the user executes a <strong>git clone</strong>, <strong>fetch</strong>, or <strong>push</strong>, the <strong>Git client</strong> invokes <code class="literal">ssh</code>, passing it a command (either <code class="literal">git-upload-pack</code> or <code class="literal">git-receive-pack</code>, depending on whether the user is reading or writing). The <a id="id22" class="indexterm"/>local ssh client passes this to the server, and assuming authentication succeeds, that command gets executed on the server.</p><p>With Gitolite<a id="id23" class="indexterm"/> installed, the <code class="literal">ssh</code> daemon does not invoke the <code class="literal">git-upload-pack</code> or <code class="literal">git-receive-pack</code> directly. Instead, it calls a program called <code class="literal">gitolite-shell</code>, which changes the control flow as follows:</p><div><img src="img/2371OS_01_02.jpg" alt="Gitolite and the Git control flow"/></div><p>First, notice that nothing changes on the <strong>Git client</strong> side<a id="id24" class="indexterm"/> in any way; the changes are only on the server side. In fact, unless an access violation happens and an error message needs to be sent to the user, the user may not even <em>know</em> that Gitolite is installed!</p><p>Second, notice the red link from Gitolite's shell program to the <code class="literal">git-upload-pack</code> program. This call does not happen if Gitolite determines that the user does not have the appropriate access to the repo concerned. This access check happens for both read (that is, <code class="literal">git fetch</code> and <code class="literal">git clone</code> commands) and write (<code class="literal">git push</code>) operations; although for writes, there are more checks that happen later.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Trying out Gitolite</h1></div></div></div><p>It's very <a id="id25" class="indexterm"/>easy to try out Gitolite in a safe environment without affecting anything else in the system in any permanent manner. Gitolite has a fairly complete set of test scripts, and the officially supported method of trying out Gitolite simply uses a couple of these test scripts to automatically install and set up Gitolite.</p><p>At the end of this process, you will have a version of Gitolite all set up and ready to use. You will also have an "admin" user, and six "normal" users, using which you can try out most of the features of Gitolite (with the exception of some advanced features such as mirroring).</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Preparing for the setup</h2></div></div></div><p>You will need the <a id="id26" class="indexterm"/>following in order to try out Gitolite:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Unix (Linux, BSD, HP-UX, AIX, Solaris, and so on) server</li><li class="listitem" style="list-style-type: disc">Git version 1.7.1 or later installed on the server</li><li class="listitem" style="list-style-type: disc">Perl 5.8.8 or later version installed on the server</li><li class="listitem" style="list-style-type: disc">An OpenSSH-compatible SSH daemon installed and running on the server</li><li class="listitem" style="list-style-type: disc">Root access to the server in order to create a new throw away user to do the testing in</li></ul></div><p>At the time of writing this book, Git 1.7.1 is over three years old, and Perl 5.8.8 is quite a bit older than that, so almost any recent Linux or BSD system should work fine.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Installing and setting up a test instance</h2></div></div></div><p>With the<a id="id27" class="indexterm"/> prerequisites at hand, here's how you would get yourself a<a id="id28" class="indexterm"/> <code class="literal">test</code> instance of Gitolite to try out:</p><div><ol class="orderedlist arabic"><li class="listitem">Log in as root (using whatever commands your OS/distro requires to do that) and create a new throw away user. You can call this anything you want, but we will use the name <code class="literal">gitolite-test</code> here. <em>Please do not use an existing user for this!</em></li><li class="listitem">Log in as the <code class="literal">gitolite-test</code> user.</li><li class="listitem">Get the Gitolite sources from the official repository, <code class="literal">git clone</code> <code class="literal">git://github.com/gitolite/gitolite</code>.<p>You can get this from any other clone of the gitolite sources if your server cannot directly access the internet. Just substitute the URL you have in the preceding <code class="literal">clone</code> command.</p></li><li class="listitem">Switch to the directory that was just cloned using the following command:<div><pre class="programlisting">
<strong>cd gitolite</strong>
</pre></div></li><li class="listitem">Install and set up Gitolite in test mode using the following command:<div><pre class="programlisting">
<strong>env GITOLITE_TEST=y prove t/ssh*</strong>
</pre></div></li><li class="listitem">Go back to the HOME directory:<div><pre class="programlisting">
<strong>cd</strong>
</pre></div></li></ol></div><p>This will <a id="id29" class="indexterm"/>churn through two of the test scripts. You will see a warning about an <code class="literal">authorized_keys</code> file being created, which you can ignore, and finally a message saying <code class="literal">All tests successful</code>, with some statistics on the test run.</p><p>At the end of that process, you should have the following: one "admin" user (called <code class="literal">admin</code>) and six normal users (named <code class="literal">u1</code> through <code class="literal">u6</code>). These users are simulated using an <code class="literal">ssh</code> feature. If you are familiar with <code class="literal">ssh</code>, you can look in <code class="literal">~/.ssh/config</code> to see how this is done.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Playing with Gitolite</h2></div></div></div><p>You can now <a id="id30" class="indexterm"/>use the test setup of gitolite from the previous section. Here's a sample set of commands with notes to start you off:</p><p>Clone the special <code class="literal">gitolite-admin</code> repository:</p><div><pre class="programlisting">
<strong>$ git clone admin:gitolite-admin </strong>
<strong>Cloning into 'gitolite-admin'... </strong>
<strong>remote: Counting objects: 8, done. </strong>
<strong>remote: Compressing objects: 100% (4/4), done. </strong>
<strong>remote: Total 8 (delta 1), reused 0 (delta 0) </strong>
<strong>Receiving objects: 100% (8/8), done. </strong>
<strong>Resolving deltas: 100% (1/1), done. </strong>
</pre></div><p>Examine the contents of the clone:</p><div><pre class="programlisting">
<strong>$ cd gitolite-admin/ </strong>
<strong>$ ls -a </strong>
<strong>.  ..  conf  .git </strong>
<strong>$ ls -a conf </strong>
<strong>.  ..  gitolite.conf </strong>
</pre></div><p>Edit the <code class="literal">conf/gitolite.conf</code> file and add the following lines, which tell Gitolite to create a new repository called <code class="literal">bar</code> and allow users <code class="literal">u1</code> and <code class="literal">u2</code> all rights to it:</p><div><pre class="programlisting">
<strong>repo bar</strong>
<strong>  RW+  =  u1 u2</strong>
</pre></div><p>Save the file, then add the change (<code class="literal">git add</code>) and commit the file (<code class="literal">git commit</code>):</p><div><pre class="programlisting">
<strong>$ git add conf/gitolite.conf </strong>
<strong>$ git commit -m 'added repo bar' </strong>
<strong>[master 1111cee] added repo bar </strong>
<strong> 1 file changed, 3 insertions(+) </strong>
<strong>$ git push </strong>
<strong>Counting objects: 7, done. </strong>
<strong>Delta compression using up to 4 threads. </strong>
<strong>Compressing objects: 100% (2/2), done. </strong>
<strong>Writing objects: 100% (4/4), 338 bytes | 0 bytes/s, done. </strong>
<strong>Total 4 (delta 1), reused 0 (delta 0) </strong>
<strong>remote: Initialized empty Git repository in /home/gitolite-test/repositories/bar.git/ </strong>
<strong>To admin:gitolite-admin </strong>
<strong>   f226f28..1111cee  master -&gt; master</strong>
</pre></div><p>As you can <a id="id31" class="indexterm"/>see, we've just created a new repository called <code class="literal">bar</code>. If you look at the output carefully, you might notice, among the familiar output of a <code class="literal">git push</code> command, a line saying that an empty Git repository was initialized on the server. This is useful because you don't have to log on to the server to create the repository—Gitolite takes care of it.</p><p>Let's look at some access rights. Running ssh against the server and supplying <code class="literal">info</code> as the command will show you what repositories you have access to:</p><div><pre class="programlisting">
<strong>$ ssh admin info </strong>
<strong>hello admin, this is gitolite-test@server running gitolite3 v3.5.3.1-6-g5bdc750 on git 1.8.3.1 </strong>

<strong> R W  gitolite-admin </strong>
<strong> R W  testing </strong>
<strong>$ ssh u1 info </strong>
<strong>hello u1, this is gitolite-test@server running gitolite3 v3.5.3.1-6-g5bdc750 on git 1.8.3.1 </strong>

<strong> R W  bar </strong>
<strong> R W  foo </strong>
<strong> R W  testing </strong>
<strong>$ ssh u3 info </strong>
<strong>hello u3, this is gitolite-test@server running gitolite3 v3.5.3.1-6-g5bdc750 on git 1.8.3.1 </strong>

<strong> R W  foo </strong>
<strong> R W  testing </strong>
</pre></div><p>The preceding command shows you a list of the repositories you have access to, and for each of them, whether <a id="id32" class="indexterm"/>you can read and write to the repository, or you have read-only access.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>A note on command and URL syntax</strong>
</p><p>Remember that we are running the Gitolite server, as well as simulating the seven different users, on the same Unix user (which is <code class="literal">gitolite-test</code>). As a result, you are able to use commands such as <code class="literal">git clone admin:gitolite-admin</code> and <code class="literal">ssh u1</code> info. In a real setup, you will represent yourself, and the server will be elsewhere. The commands will be of the form <code class="literal">git clone gitolite-test@server:gitolite-admin</code> and <code class="literal">ssh gitolite-test@server info</code>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter, we learned why Gitolite is useful, saw an example of access control rules, and got a glimpse of some of its features.  We also learned the basic ideas behind Gitolite, and created a test instance of Gitolite in order to try it out safely.</p><p>In the next chapter, we will install Gitolite properly and learn the basics of administering Gitolite.</p></div></body></html>