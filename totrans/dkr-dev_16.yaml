- en: '*Chapter 13*: Docker Security Fundamentals and Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we wish to ensure that our containers are hardened for both development and
    production environments, there are many techniques and best practices we can implement
    to achieve this task. In many cases, it is simply a case of modifying existing
    commands or behaviors you've learned throughout this book to add an extra layer
    of security to your practices.
  prefs: []
  type: TYPE_NORMAL
- en: Within this chapter, we will be building upon the foundational knowledge we
    have of Docker and container security. This will involve hands-on exercises in
    building and modifying containers. Covering subjects as varied as image security
    through the usage of Docker commands and signed images, upon completing the following
    exercises, you should feel comfortable in applying these skills in a real-world
    development and DevOps environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker image security**: Here, we will learn about image security, including
    using minimal base images, signed and verified images, and avoiding data leakage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY` instead of `ADD` when building out Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security around the build process**: Here, we will learn about the best practices
    for build processes, including multi-stage builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started by looking at Docker image security and some best practices
    we can implement.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, you will need an account on Docker Hub in order to access
    images located there. If you have not already set one up, you can do so at [https://hub.docker.com](https://hub.docker.com).
  prefs: []
  type: TYPE_NORMAL
- en: If you have an existing container or service running SSH, this can be used later
    in this chapter. If not, do not worry. We provide a link to an example Dockerfile
    from the official Docker documentation you can use instead if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/30WkOPE](https://bit.ly/30WkOPE)'
  prefs: []
  type: TYPE_NORMAL
- en: Docker image security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have worked through the material in this book, you will have become increasingly
    familiar with images. These are a fundamental building block in the Docker ecosystem.
    An image is the combination of the filesystem and parameters that, when run by
    Docker, becomes your container.
  prefs: []
  type: TYPE_NORMAL
- en: Having made sure Docker itself is patched and secured, that our application
    code is robust, and that when we run the containers they will have limited privileges,
    we also want to ensure that the image itself is secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the benefits of Docker is that services such as Docker Hub allow us
    to share and reuse container images. However, we need to be careful that what
    we are downloading is secure and has not been uploaded by a malicious party:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Docker Hub displaying example repositories
  prefs: []
  type: TYPE_NORMAL
- en: You should always be cautious, however, even with legitimate/official websites.
  prefs: []
  type: TYPE_NORMAL
- en: There have been several cases in the past where malicious images have been uploaded
    to Docker Hub, with the hope that these will be downloaded by unsuspecting parties.
    Examples of malicious code have included images purporting to be related to **tomcat**,
    **mysql**, and **cron**. A compromised container containing a kernel exploit,
    for example, could lead to an attack on the underlying host.
  prefs: []
  type: TYPE_NORMAL
- en: Kromtech Security Center in one particular time frame in 2018 found 17 malicious
    Docker images on Docker Hub. You can read about this situation in their report,
    *Cryptojacking invades cloud. How modern containerization trend is exploited by
    attackers*, at [https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers](https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers).
  prefs: []
  type: TYPE_NORMAL
- en: Your first step, therefore, in any project when using third-party tools and
    code should be to verify that the source of these artifacts is trustworthy. It
    is also important to stay on top of security alerts to make sure you do not inadvertently
    download images with damaging flaws.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Docker images, once you are confident of the validity of origin,
    you can then add additional verification processes to check the artifact itself
    is safe. In fact, you may be familiar with this concept with other technologies
    you use, such as verifying a file integrity hash when downloading an OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'One mechanism to help ensure that the source of what we are downloading is
    legitimate is to use the signed Docker Certified images served from Docker Hub.
    As we saw with the Kromtech report, we can never be too careful, even with legitimate
    hosts like Docker Hub. These certified images have been reviewed by the host and
    certified as authentic. Many popular application environments are available on
    Docker Hub, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Splunk Enterprise Edition: [https://hub.docker.com/_/splunk-enterprise](https://hub.docker.com/_/splunk-enterprise)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datadog: [https://hub.docker.com/_/datadog-agent](https://hub.docker.com/_/datadog-agent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynatrace: [https://hub.docker.com/_/dynatrace](https://hub.docker.com/_/dynatrace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Java 8 SE (Server JRE): [https://hub.docker.com/_/oracle-serverjre-8](https://hub.docker.com/_/oracle-serverjre-8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more at the Docker Hub website here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hub.docker.com/search?q=&type=image&certification_status=certified](https://hub.docker.com/search?q=&type=image&certification_status=certified)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a hands-on approach to checking the legitimacy of an image, including
    interacting with Docker Hub. Load up your command-line tool and then move on to
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Image verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first concept we need to understand is that of content trust. This is the
    security model in Docker applied to images.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker''s Content Trust** (**DCT**) model at its heart is a mechanism to
    use digital signatures to prove the integrity of images hosted on platforms such
    as Docker Hub. With DCT enabled, users can then ensure they do not pull untrusted
    images (that is, unsigned images) unless they make explicit exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Docker has DCT disabled, which will allow you to pull images without
    verifying the safety of them. This opens you up to the risk of downloading an
    artifact that is infected with malware or another security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we can use the `DOCKER_CONTENT_TRUST` flag to ensure that when
    we pull an image, it is verified. This works by checking whether the image has
    been signed by its creator or whether we are using an explicit hash associated
    with an image. To enable it system-wide, include it in your `.bashrc` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If, for any reason, you wish to interact with an untagged image, you can temporarily
    disable the setting by using the `--disable-content-trust` flag in your command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DOCKER_CONTENT_TRUST` flag can be limited to a single shell in addition
    to system-wide coverage. To quickly enable it in a new shell when you spawn, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Just remember that when you close the shell, you will need to enable the flag
    again, or set the system-wide property as explained earlier in the `.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, with this setting enabled system-wide (or in an individual shell),
    it means that command-line operations that interact with a tagged image will need
    to have one of two things. These can be either content hashes appended to the
    image or the image itself will need to be one that has already been signed in
    advance through the use of signing keys.
  prefs: []
  type: TYPE_NORMAL
- en: Signing keys
  prefs: []
  type: TYPE_NORMAL
- en: Signing keys are a set of components that are used to sign an image. They consist
    of an offline key, which forms the basis for DCT to trust an image tag, along
    with a tagging key for signing tags themselves and finally, a set of server-managed
    keys for enforcing security guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: So, from a practical perspective, what exactly does this result in when running
    commands? Let's see a quick example using the image called `shipitclicker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to pull the `shipitclicker` image while the `DOCKER_CONTENT_TRUST`
    flag is enabled, we can append a hash to the image using the `@` symbol. Consider
    the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as the content hash `sha256:b20caa037ac2c36a9845f719ebb12952bbb3e749d4b05fcdcd8d382
    01a7de795` exists, the command will succeed. Otherwise, imagine that we wanted
    to pull the latest version of this image or version number, such as the following,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, we then would need to ensure that the image had been signed,
    or the command will fail. The `pull` command is not the only operation that interacts
    with trusted content. Others include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$docker push`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$docker build`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$docker create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$docker run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can test this out now. We've created the `shipitclicker` image in advance
    for you to pull from Docker Hub, located in the Packt Docker book repository at
    [https://hub.docker.com/r/dockerfordevelopers/shipitclicker](https://hub.docker.com/r/dockerfordevelopers/shipitclicker).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can attempt to pull this image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see a *request denied* error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ensuring that this flag is enabled in an automated build process is also a must,
    as it prevents unverified images from making their way into your environments
    by accident.
  prefs: []
  type: TYPE_NORMAL
- en: This very simple approach of using DCT can go a long way to ensuring you avoid
    using untrusted content from Docker Hub. Now let's look at the base images a little
    closer.
  prefs: []
  type: TYPE_NORMAL
- en: Using minimal base images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we know that we are pulling in signed images or specific hashes, but is there
    anything we need to consider around the type of image we are using in our containers?
    The answer to this is *yes*.
  prefs: []
  type: TYPE_NORMAL
- en: You should ask yourself when using an image whether the whole OS, complete with
    all its pre-installed packages, is required? In some cases, this can introduce
    vulnerabilities, as you may be including unpatched libraries and other code in
    your container. The best approach, therefore, is to start with something basic
    and then build up from there. This will help to reduce your overall attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's grab a minimal image from Docker Hub now so we can work with it throughout
    the rest of this chapter. The image we are going to use is `shipitclicker:v0.1`,
    which we just tested with `DOCKER_CONTENT_TRUST` and is based on Alpine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in checking it out and haven't already done so, the Alpine
    image is only 5 MB in size and is part of the Official Images program on Docker
    Hub. These are a set of repositories that provide all the essential basics, while
    also ensuring all security patches are applied regularly. In addition to this,
    the official Docker images are also signed, so can therefore guarantee some of
    the security precautions that were just discussed around image verification in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will need to do is disable `DOCKER_CONTENT_TRUST` in your
    current shell, or grab the hash of the image so that you can now pull it. If you
    wish to disable `DOCKER_CONTENT_TRUST`, you can do this via the following command
    in your current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just remember, if you shut the shell down and create a new one, you will need
    to run this command again. We recommend you leave the flag set to `1` and instead
    pull the hash version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the hash under the **Tags** tab for the repository, as the following
    link demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags](https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags)'
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, select the digest value displayed under the version you are interested
    in. This will then display the `sha256` hash, such as the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows where you can find the hash for use in your
    `docker pull` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Information on a Docker image
  prefs: []
  type: TYPE_NORMAL
- en: 'The portion of the string containing `sha256` onward can then be used in the
    pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see something similar to the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running the `docker images` command should now show it present on your system.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to building your own images, another consideration is using the
    `.dockerignore` file to help keep the overall container size down.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `.dockerignore` file included in the build context directory, any
    files listed in the file will not be added to the image. This, as you will see
    shortly, has another handy benefit. From an image size perspective, and in light
    of our general drive cleanliness as a best practice, we can use it to avoid binaries
    such as Python `.pyc` files and similar being accidentally added to the image.
    The following example `.dockerignore` file demonstrates how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach is very simple, and if you are used to using `.gitignore` files,
    it will already be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our minimal base image, we should take a look at some methods to
    restrict privileges when we create containers, so as to prevent accidental security
    breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at assigning a user and a group to restrict
    privilege escalation when starting the image. We can build on this by also using
    a useful parameter called `no-new-privileges`.
  prefs: []
  type: TYPE_NORMAL
- en: The flag leverages a feature of the underlying Linux kernel known as `no_new_privs`.
    The basic idea of this feature was to ensure that any processes, including child
    processes, cannot gain additional privileges when spawned. With this option enabled,
    applications will not be able to use features such as `setuid`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `setuid` feature allows users to run and execute certain programs with escalated
    privileges. This poses a security threat, as an attacker can exploit it to execute
    code and programs they would not normally have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Processes spawned via this feature also cannot unset the `no_new_privs` flag
    on themselves, thus preventing an attacker from disabling this feature and escalating
    privileges via `setgid` or `setuid`.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the `no-new-privileges` feature when running a container, you will
    need to include the `--security-opt` flag and add it as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out with the image we just downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The image should now be running in this mode. Remember that we can get the
    container name by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Disabling the ability for a container to gain further privileges can also help
    us to prevent container breakout. The term **breakout** is used to refer to a
    case when a compromised container can access sensitive data on the underlying
    host. In a scenario where a container is exploited and the exploit allows the
    attacker to elevate privileges (if, for example, the previously discussed flag
    wasn't included), they may then attempt to pivot and compromise other containers
    through Docker, or exploit the host itself for some other gain.
  prefs: []
  type: TYPE_NORMAL
- en: As we will learn later in this chapter, there are ways to harden our system
    further, by restricting the privileges (known as capabilities) of a container
    when we run it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now look at some more flags we can add, along with some other techniques
    to ensure that the data we are using remains safe.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding data leakages from your image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Linux, we can implement users and groups to ensure that only those who need
    access to read and write files can do so. This fine-tuned system of access permissions
    is important to help prevent data leakage. Another useful method we can use to
    protect the filesystem used by the image is to set the filesystems and any volumes
    to a read-only state.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at a volume we may want to mount. We're going to run
    a new container based off the `shipitclicker` image and mount a local filesystem
    to it. In order to achieve this, in addition to the `--mount` flag, we will include
    a `readonly` statement within the `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an empty folder on your local OS, which we can use to mount
    the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try running the following command. It will mount the local folder and
    run the container and attempt to write a file to the `/mnt/testfiles` directory
    called `test.file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see an error informing you that the filesystem is read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using this mechanism, we can read files mounted to the container, but avoid
    a situation where the container can write files back to it, thus accidentally
    writing keys or other data into a directory on the host where they should not
    be located.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An important point to remember is that the root account can override any file
    permissions and thus can read any files in the container. If somebody gets root
    access, they can exfiltrate your data!
  prefs: []
  type: TYPE_NORMAL
- en: What about protecting the filesystem in the container itself, for example, the
    `/tmp` directory? Thankfully, Docker provides us with an easy method to do this,
    via the `--read-only` flag. We can try this out and see how it works in practice.
    First, stop the container we just created. Remember, you can get the container's
    name when you run the `docker ps -a` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the container name, stop the container. We''ve used `nervous_sinoussi`
    here to represent the name; replace this with your container''s own unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are going to recreate the container using the `--read-only` flag. Included
    in the `run` command will be an example of trying to write a file called `test`
    to the `/tmp` directory. With the `--read-only` flag enabled, we should get an
    error informing us this is not permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove the container we created previously in order to keep our environment
    clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, try running the following command, including your container name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see an error such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the list of Docker processes running, you will see the command executed
    and exited. Let''s clear this container out and try rerunning the command without
    the flag and echo out the contents of the file we create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirmation that the filesystem was written to will now be displayed via the
    `echo` command, which prints the contents of `/tmp/test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, to avoid this second scenario where the filesystem can be written
    to, always include the `--read-only` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, remember not to include sensitive information such as private
    keys and API tokens inside the Dockerfile. There are a number of services you
    can use to avoid this situation including HashiCorpVault, Docker Swarm, and services
    built into cloud providers like AWS, such as SSM. [*Chapter 14*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316),
    *Advanced Docker Security – Secrets, Secret Commands, Tagging, and Labels*, will
    cover these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: With some of these best practices in mind, now let's look at the commands we
    would use to build our own images and what security concerns we need to take into
    consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Security around Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will shortly be exploring the build process and how we can harden this from
    a security perspective. In order to do this, however, we will first dig into some
    of the commands we will use in a little more detail so we know which ones are
    safe to use, and which pose a potential threat. Let's start by looking at the
    `COPY` and `ADD` commands.
  prefs: []
  type: TYPE_NORMAL
- en: COPY versus ADD – what's the story?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you come to build an image, you will want to copy files from the host over
    to it. Typically, there are two methods for doing this. If you've done any research
    online, you may have seen comments along the lines of "don't use the `ADD` command."
    So why is this?
  prefs: []
  type: TYPE_NORMAL
- en: The `ADD` command allows us to recursively copy files over to the image, much
    like a `cp -r` command might do in Linux if we also piped it through `zip` when
    necessary. In short, it expands archive files and creates any directories that
    don't exist on the target.
  prefs: []
  type: TYPE_NORMAL
- en: The input to the command is provided as a URL that can reference either a local
    or remote (archive) file. As you can imagine, when pulling from a remote location,
    there are a number of risks to consider
  prefs: []
  type: TYPE_NORMAL
- en: Has the file been modified on the remote host and compromised?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you know the origin of the file on the remote host?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What considerations are there regarding **Man-In-The-Middle** (**MITM**) attacks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of how this command might be used in a Dockerfile can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the zipped version of the repository hosted on this book's GitHub
    account would be downloaded and expanded into the `tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we discussed using the `.dockerignore` file to help keep image sizes
    small. In addition to this benefit, they can help to prevent files accidentally
    being added if you include the `ADD` command. For example, you can ensure that
    configuration `.ENV` files or similar are not copied over.
  prefs: []
  type: TYPE_NORMAL
- en: The `COPY` command works slightly differently to `ADD`. Like `ADD`, it copies
    files recursively. However, you must provide an explicit source and destination
    folder. This means you have to declare the locations the files are coming from
    and going to. A ZIP file copied from A to B will still remain a ZIP file, and
    not be expanded while avoiding any unintended consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an example of the syntax for this command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It is safer to break down the process of adding files into multiple steps, such
    as downloading the files, scanning them, and then copying them over. When accessing
    remote content, you should always use an SSL/TLS connection as well. This can
    prevent MITM attacks being a problem by implementing a cryptographically secure
    and authenticated communication route.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An MITM attack is one where a malicious party secretly eavesdrops, relays, or
    alters communications between two parties.
  prefs: []
  type: TYPE_NORMAL
- en: We've just looked at how the `COPY` command can avoid some of the issues of
    `ADD`, but what about recursive copying? Are there risks here?
  prefs: []
  type: TYPE_NORMAL
- en: Recursive COPY – use with caution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursive copying, as you may be aware, copies the contents of one location
    to another, and includes all the nested subfolders and files.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to accidentally copy files into the image you did not mean to
    when using the recursive copy command in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. In this following screenshot, we can see an example
    directory, and included in it is a folder called `oops` and a `my_secret` file.
    This file contains a hypothetical secret such as an API token that has been accidentally
    left in the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Example of a secret accidentally left in the source code
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we were to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Along with the parent directory in which all the folders reside, this secret
    file would also be copied over, as the command will recursively copy everything,
    including the `oops` directory and our nested file.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid these negative effects, it is always a good practice to update
    your `.dockerignore` file to ensure that sensitive file types are excluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we noted earlier, if you are familiar with `.gitignore`, adding file types
    to your `.dockerignore` file should be simple. Here are some quick rules to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using these mechanisms, you can ensure a variety of files are excluded from
    the container, such as `*.pem` and `*.ENV` files.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you do plan to use recursive copying in your Dockerfile, ensure
    the `.dockerignore` file is up to date and that you have audited your application
    to ensure that everything being copied over is as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now turn our attention to the build process and how we can improve security
    at this stage. Here, we will see how commands such as `COPY` come into play as
    part of a larger process.
  prefs: []
  type: TYPE_NORMAL
- en: Security around the build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how we can pull images and run them in a secure fashion. But what
    about building our own container images? As you are now familiar with, some commands
    pose additional risks when added to the Dockerfile. In this section of the chapter,
    we will look at how we can secure the build process using the techniques we have
    learned so far. This will include using a minimal base image (`shipitclicker`)
    as a starting point and then using the security tweaks we have tested against
    this image when running it as a container.
  prefs: []
  type: TYPE_NORMAL
- en: Using multi-stage builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we previously covered, we need to be careful about secrets and ensure they
    are not accidentally leaked. One way to avoid this is to not include them in the
    Dockerfile. However, what about at the build stage? It's likely you will need
    to use private keys in conjunction with the build process from time to time, for
    example, to pull code from a remote service that is protected with public key
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: One method to use keys securely is through the use of multi-stage builds. This
    process uses a disposable intermediate layer, which ensures that data isn't accidentally
    leaked into the final build process. Let's look at a simple example. If you wish
    to run this code, you will need to have an SSH server running and add your public
    key to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have one running already, to build a container that runs SSH, you
    can reuse the Dockerfile located at [https://docs.docker.com/engine/examples/running_ssh_service/](https://docs.docker.com/engine/examples/running_ssh_service/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at an example of the multi-stage build process and how
    we can use it in conjunction with accessing an SSH service.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the following code to a new Dockerfile you can work with. On your container
    running the SSH server, add a file called `file.txt` and then update the Dockerfile
    code to include your user, IP/hostname, and the path to the file you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a quick walkthrough of what is going on here before we build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code does a number of things. First, it takes our `shipitclicker` image
    as an intermediate build step.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, it sets the `WORKDIR` to test and creates an `ARG` value called
    `ssh_prv_key`. This `ARG` value will allow us to pass in the path to the RSA private
    key that will be needed to connect to the remote SSH server.
  prefs: []
  type: TYPE_NORMAL
- en: Based upon our input, we echo it out as a file and then set permissions on the
    file to `600`. Then, we install `openssh` so we can use the `scp` command-line
    feature. The interesting bit comes next.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN scp` command takes the private key we injected and uses it to connect
    to the remote server to retrieve a file called `file.txt`, which is then copied
    back to the present directory. This step completes the first stage of the build.
  prefs: []
  type: TYPE_NORMAL
- en: In the second stage, we once again use the `shipitclicker` image and use the
    same `WORKDIR`, that is, `test`. The final line, however, is where the magic happens.
    It copies from the intermediate step we completed in step 1, the file that was
    retrieved from the remote server, and replicates it to the final build stage.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the result, the final container does not contain the private
    key we used to retrieve the file from the remote SSH server, and thus will not
    accidentally end up in the final container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build out this Dockerfile once you have a remote location to copy the file
    from, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably guess from looking at this, the `ssh_prv_key` build argument
    is simply the value of our private key concatenated out into the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built our container, when we run it, we want to ensure that it
    does not consume more resources than required. This can help to mitigate damage
    in the case of an unfortunate security breach.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, multi-stage builds can also aid in keeping the images small,
    which is a desirable quality, as already discussed. Let's now take a look at how
    we limit capabilities and resource usage in Docker further.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting resources and capabilities when deploying your builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can limit a variety of resources available to your container, including
    CPU usage and memory. This can help prevent denial-of-service attacks. In this
    scenario, the container is exploited to use up the underlying resources of the
    host, thus causing overall performance degradation, or worse, the underlying host
    to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, access control mechanisms are an important piece of the puzzle
    to ensure that as well as limiting the resources used by a container, we also
    limit privileges and access.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to avoid the types of DOS attacks mentioned earlier, we can use a combination
    of flags to restrict how much of the underlying host resources a container can
    consume.
  prefs: []
  type: TYPE_NORMAL
- en: The first area we will look at is memory. Docker gives us the ability to restrict
    how much memory a container can use through a combination of hard and soft limits.
  prefs: []
  type: TYPE_NORMAL
- en: We can set a hard limit on a container using the `-m`/`--memory` flag. This
    will set aside the amount you specify and will not allow the container to exceed
    this. In the case that a container does become compromised, the hard limit feature
    will prevent a runaway malicious process from consuming more and more of the underlying
    host's RAM.
  prefs: []
  type: TYPE_NORMAL
- en: When setting the memory limit, ensure that you adjust it in line with what your
    application is intended to do. Too little memory may prevent an issue if the container
    were compromised, but may, in turn, not be enough to run your application.
  prefs: []
  type: TYPE_NORMAL
- en: The `–memory` flag can also be combined with the `–memory-reservation` flag.
    This second feature allows you to specify a soft limit smaller than the `–memory`
    one. When Docker discovers that the underlying host has an issue, such as low
    memory, it will activate this feature. Once activated, Docker will attempt to
    restrict the amount of memory available to the container.
  prefs: []
  type: TYPE_NORMAL
- en: As with memory, we also need to be aware that an exploited container can also
    consume more CPU resources than expected, which can, in turn, have negative side
    effects for the host.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Docker 1.12 or lower, you will need to use the `–cpu-period`
    and `–cpu-quota` flags instead of the `–cpus` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `–cpus` flag, you can define how many CPUs a container has access
    to. If you have multiple CPUs (for example, four) and set the value to `–cpus="2"`,
    the container is restricted to only being able to use up to two CPUs and no more.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how we can use some flags to restrict the resources a container has
    available to it at runtime. Let's look at some additional flags we can use to
    further restrict potential security risks when we run our container.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some techniques you can use to help avoid other risks include dropping capabilities
    when running containers. Capabilities are a feature of Linux that divide privileges
    associated with the root/super user account into individual components.
  prefs: []
  type: TYPE_NORMAL
- en: The list of capabilities that a container usually has are `chown`, `dac_override`,
    `fowner`, `fsetid`, `kill`, `setgid`, `setuid`, `setpcap`, `net_bind_service`,
    `net_raw`, `sys_chroot`, `mknod`, `audit_write`, and `setfcap`. To understand
    what each capability allows, please refer to the Linux man-pages documentation
    at [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove capabilities such as `chown`, you can use the `–cap-drop` flag when
    running a container. Refer to the following for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Removing powerful capabilities that your production containers do not need can
    help harden you against attacks that seek to break out of the container.
  prefs: []
  type: TYPE_NORMAL
- en: That ends this chapter on techniques to improve your fundamental security posture.
    Before we move on to some more advanced techniques, let's quickly re-cap what
    we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed some basic steps you can take to ensure that
    when you pull images and build and run containers, your attack surface will be
    reduced.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about how to ensure that we only pull safe images from Docker Hub.
    Additionally, we saw how we can use read-only permissions to prevent write access
    to filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage builds were discussed to show how we can break down our container
    build process into steps to ensure that SSH keys and similar are not accidentally
    included in the final product. The `.dockerignore` file was briefly reviewed from
    a security perspective, and finally, we discussed how to restrict system resources
    and implement access control through removing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can automate some of the security
    processes by using scanning tools and implement monitoring.
  prefs: []
  type: TYPE_NORMAL
