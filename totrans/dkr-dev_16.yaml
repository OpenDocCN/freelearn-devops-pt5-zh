- en: '*Chapter 13*: Docker Security Fundamentals and Best Practices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：Docker 安全基础和最佳实践'
- en: As we wish to ensure that our containers are hardened for both development and
    production environments, there are many techniques and best practices we can implement
    to achieve this task. In many cases, it is simply a case of modifying existing
    commands or behaviors you've learned throughout this book to add an extra layer
    of security to your practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的容器在开发和生产环境中都能得到加固，我们可以实施许多技术和最佳实践来实现这一目标。在许多情况下，这仅仅是修改你在本书中学到的现有命令或行为，为你的实践添加额外的安全层。
- en: Within this chapter, we will be building upon the foundational knowledge we
    have of Docker and container security. This will involve hands-on exercises in
    building and modifying containers. Covering subjects as varied as image security
    through the usage of Docker commands and signed images, upon completing the following
    exercises, you should feel comfortable in applying these skills in a real-world
    development and DevOps environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于我们对 Docker 和容器安全的基础知识进行扩展。这将涉及构建和修改容器的实践操作。内容涵盖了诸如通过使用 Docker 命令和签名镜像来保障镜像安全等主题。完成以下练习后，你应该能够在实际的开发和
    DevOps 环境中自如地应用这些技能。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要主题：
- en: '**Docker image security**: Here, we will learn about image security, including
    using minimal base images, signed and verified images, and avoiding data leakage.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 镜像安全性**：在这里，我们将学习镜像安全性，包括使用最小基础镜像、签名和验证过的镜像以及避免数据泄露。'
- en: '`COPY` instead of `ADD` when building out Docker images.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建 Docker 镜像时使用 `COPY` 而不是 `ADD`。
- en: '**Security around the build process**: Here, we will learn about the best practices
    for build processes, including multi-stage builds.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建过程的安全性**：在这里，我们将学习构建过程的最佳实践，包括多阶段构建。'
- en: Let's get started by looking at Docker image security and some best practices
    we can implement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过了解 Docker 镜像安全性和一些最佳实践开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要你有一台运行 Docker 的 Linux 机器。我们建议你使用本书中一直在使用的设置。
- en: In addition to this, you will need an account on Docker Hub in order to access
    images located there. If you have not already set one up, you can do so at [https://hub.docker.com](https://hub.docker.com).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要在 Docker Hub 上有一个帐户，以便访问其中的镜像。如果你还没有设置，可以在[https://hub.docker.com](https://hub.docker.com)上进行设置。
- en: If you have an existing container or service running SSH, this can be used later
    in this chapter. If not, do not worry. We provide a link to an example Dockerfile
    from the official Docker documentation you can use instead if you wish.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个正在运行 SSH 的容器或服务，可以在本章后续部分使用。如果没有，别担心，我们提供了一个来自官方 Docker 文档的示例 Dockerfile，你可以使用它。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码实践：
- en: '[https://bit.ly/30WkOPE](https://bit.ly/30WkOPE)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/30WkOPE](https://bit.ly/30WkOPE)'
- en: Docker image security
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 镜像安全性
- en: As you have worked through the material in this book, you will have become increasingly
    familiar with images. These are a fundamental building block in the Docker ecosystem.
    An image is the combination of the filesystem and parameters that, when run by
    Docker, becomes your container.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本书中逐步学习时，你会越来越熟悉镜像。这是 Docker 生态系统中的一个基础构建模块。镜像是文件系统和参数的组合，当 Docker 运行时，它会变成你的容器。
- en: Having made sure Docker itself is patched and secured, that our application
    code is robust, and that when we run the containers they will have limited privileges,
    we also want to ensure that the image itself is secure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保 Docker 本身已经打上补丁并得到加固，确保我们的应用代码健壮，以及确保我们运行容器时它们具有限制权限的情况下，我们还需要确保镜像本身是安全的。
- en: 'One of the benefits of Docker is that services such as Docker Hub allow us
    to share and reuse container images. However, we need to be careful that what
    we are downloading is secure and has not been uploaded by a malicious party:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的一大优点是，像 Docker Hub 这样的服务允许我们共享和重用容器镜像。然而，我们需要小心下载的内容是安全的，且未被恶意方上传：
- en: '![](img/B11641_13_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_13_001.jpg)'
- en: Figure 13.1 – Docker Hub displaying example repositories
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – Docker Hub 显示示例仓库
- en: You should always be cautious, however, even with legitimate/official websites.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是合法/官方的网站，你也应该始终保持谨慎。
- en: There have been several cases in the past where malicious images have been uploaded
    to Docker Hub, with the hope that these will be downloaded by unsuspecting parties.
    Examples of malicious code have included images purporting to be related to **tomcat**,
    **mysql**, and **cron**. A compromised container containing a kernel exploit,
    for example, could lead to an attack on the underlying host.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 过去曾有几起恶意镜像被上传到 Docker Hub 的案例，恶意上传者希望这些镜像能被毫无防备的用户下载。恶意代码的例子包括伪装成 **tomcat**、**mysql**
    和 **cron** 相关的镜像。例如，包含内核漏洞的被攻击容器可能导致对底层主机的攻击。
- en: Kromtech Security Center in one particular time frame in 2018 found 17 malicious
    Docker images on Docker Hub. You can read about this situation in their report,
    *Cryptojacking invades cloud. How modern containerization trend is exploited by
    attackers*, at [https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers](https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kromtech 安全中心在 2018 年的某一时间段内发现了 Docker Hub 上的 17 个恶意 Docker 镜像。你可以阅读他们的报告《*加密劫持侵袭云端：现代容器化趋势如何被攻击者利用*》，链接：[https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers](https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers)。
- en: Your first step, therefore, in any project when using third-party tools and
    code should be to verify that the source of these artifacts is trustworthy. It
    is also important to stay on top of security alerts to make sure you do not inadvertently
    download images with damaging flaws.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在任何项目中使用第三方工具和代码时，你的第一步应该是验证这些工件的来源是否可信。保持关注安全警报也很重要，确保你不会不小心下载带有漏洞的镜像。
- en: In the case of Docker images, once you are confident of the validity of origin,
    you can then add additional verification processes to check the artifact itself
    is safe. In fact, you may be familiar with this concept with other technologies
    you use, such as verifying a file integrity hash when downloading an OS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Docker 镜像，一旦你确认来源的有效性，就可以添加额外的验证过程，检查工件本身是否安全。事实上，你可能已经在使用的其他技术中熟悉这个概念，比如在下载操作系统时验证文件完整性哈希。
- en: 'One mechanism to help ensure that the source of what we are downloading is
    legitimate is to use the signed Docker Certified images served from Docker Hub.
    As we saw with the Kromtech report, we can never be too careful, even with legitimate
    hosts like Docker Hub. These certified images have been reviewed by the host and
    certified as authentic. Many popular application environments are available on
    Docker Hub, including the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个帮助确保我们下载的源是合法的机制是使用 Docker Hub 提供的签名 Docker 认证镜像。正如我们在 Kromtech 报告中看到的，即使是像
    Docker Hub 这样的合法主机，我们也永远不能太小心。这些认证镜像已由主机审查并认证为真实。许多流行的应用环境可以在 Docker Hub 上找到，包括以下内容：
- en: 'Splunk Enterprise Edition: [https://hub.docker.com/_/splunk-enterprise](https://hub.docker.com/_/splunk-enterprise)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Splunk 企业版： [https://hub.docker.com/_/splunk-enterprise](https://hub.docker.com/_/splunk-enterprise)
- en: 'Datadog: [https://hub.docker.com/_/datadog-agent](https://hub.docker.com/_/datadog-agent)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Datadog: [https://hub.docker.com/_/datadog-agent](https://hub.docker.com/_/datadog-agent)'
- en: 'Dynatrace: [https://hub.docker.com/_/dynatrace](https://hub.docker.com/_/dynatrace)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dynatrace: [https://hub.docker.com/_/dynatrace](https://hub.docker.com/_/dynatrace)'
- en: 'Oracle Java 8 SE (Server JRE): [https://hub.docker.com/_/oracle-serverjre-8](https://hub.docker.com/_/oracle-serverjre-8)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Java 8 SE（服务器 JRE）：[https://hub.docker.com/_/oracle-serverjre-8](https://hub.docker.com/_/oracle-serverjre-8)
- en: 'You can find more at the Docker Hub website here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Docker Hub 网站上找到更多内容：
- en: '[https://hub.docker.com/search?q=&type=image&certification_status=certified](https://hub.docker.com/search?q=&type=image&certification_status=certified)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/search?q=&type=image&certification_status=certified](https://hub.docker.com/search?q=&type=image&certification_status=certified)'
- en: Let's now take a hands-on approach to checking the legitimacy of an image, including
    interacting with Docker Hub. Load up your command-line tool and then move on to
    the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们采取实际操作的方法来检查镜像的合法性，包括与 Docker Hub 的互动。启动你的命令行工具，然后继续下一部分。
- en: Image verification
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像验证
- en: The first concept we need to understand is that of content trust. This is the
    security model in Docker applied to images.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解的第一个概念是内容信任。这是 Docker 在镜像上应用的安全模型。
- en: '**Docker''s Content Trust** (**DCT**) model at its heart is a mechanism to
    use digital signatures to prove the integrity of images hosted on platforms such
    as Docker Hub. With DCT enabled, users can then ensure they do not pull untrusted
    images (that is, unsigned images) unless they make explicit exceptions.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 内容信任** (**DCT**) 模型的核心是使用数字签名来证明托管在 Docker Hub 等平台上的镜像的完整性。启用 DCT
    后，用户可以确保不拉取不可信的镜像（即未签名的镜像），除非他们明确做出例外。'
- en: By default, Docker has DCT disabled, which will allow you to pull images without
    verifying the safety of them. This opens you up to the risk of downloading an
    artifact that is infected with malware or another security vulnerability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 禁用了 DCT，这允许你在不验证镜像安全性的情况下拉取镜像。这使得你面临下载包含恶意软件或其他安全漏洞的制品的风险。
- en: 'Thankfully, we can use the `DOCKER_CONTENT_TRUST` flag to ensure that when
    we pull an image, it is verified. This works by checking whether the image has
    been signed by its creator or whether we are using an explicit hash associated
    with an image. To enable it system-wide, include it in your `.bashrc` file as
    follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用 `DOCKER_CONTENT_TRUST` 标志来确保在拉取镜像时进行验证。这通过检查镜像是否已由创建者签名，或我们是否正在使用与镜像相关的显式哈希来工作。要在系统范围内启用它，将其包含在
    `.bashrc` 文件中，如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If, for any reason, you wish to interact with an untagged image, you can temporarily
    disable the setting by using the `--disable-content-trust` flag in your command.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你希望与未标签的镜像交互，可以通过在命令中使用 `--disable-content-trust` 标志临时禁用此设置。
- en: 'The `DOCKER_CONTENT_TRUST` flag can be limited to a single shell in addition
    to system-wide coverage. To quickly enable it in a new shell when you spawn, type
    the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`DOCKER_CONTENT_TRUST` 标志可以仅限于单个 shell，而不仅仅是系统范围的覆盖。要在新 shell 中快速启用它，输入以下内容：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just remember that when you close the shell, you will need to enable the flag
    again, or set the system-wide property as explained earlier in the `.bashrc` file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，当你关闭 shell 时，你需要重新启用该标志，或按前述方式在 `.bashrc` 文件中设置系统范围属性。
- en: In practice, with this setting enabled system-wide (or in an individual shell),
    it means that command-line operations that interact with a tagged image will need
    to have one of two things. These can be either content hashes appended to the
    image or the image itself will need to be one that has already been signed in
    advance through the use of signing keys.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当此设置在系统范围内（或在单个 shell 中）启用时，这意味着与带标签镜像交互的命令行操作需要具备两项内容之一。这些可以是附加到镜像上的内容哈希，或者镜像本身需要是已经通过使用签名密钥预先签名的镜像。
- en: Signing keys
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 签名密钥
- en: Signing keys are a set of components that are used to sign an image. They consist
    of an offline key, which forms the basis for DCT to trust an image tag, along
    with a tagging key for signing tags themselves and finally, a set of server-managed
    keys for enforcing security guarantees.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 签名密钥是一组用于签署镜像的组件。它们包括一个离线密钥，它是 DCT 信任镜像标签的基础，以及一个用于签署标签的标签密钥，最后是一个用于强制执行安全保证的服务器管理密钥集合。
- en: So, from a practical perspective, what exactly does this result in when running
    commands? Let's see a quick example using the image called `shipitclicker`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从实际的角度来看，运行命令时到底会有什么结果？让我们通过一个使用 `shipitclicker` 镜像的简单示例来看一看。
- en: 'If we wish to pull the `shipitclicker` image while the `DOCKER_CONTENT_TRUST`
    flag is enabled, we can append a hash to the image using the `@` symbol. Consider
    the following, for example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在启用 `DOCKER_CONTENT_TRUST` 标志时拉取 `shipitclicker` 镜像，可以使用 `@` 符号将哈希附加到镜像。比如以下示例：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As long as the content hash `sha256:b20caa037ac2c36a9845f719ebb12952bbb3e749d4b05fcdcd8d382
    01a7de795` exists, the command will succeed. Otherwise, imagine that we wanted
    to pull the latest version of this image or version number, such as the following,
    for example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只要内容哈希 `sha256:b20caa037ac2c36a9845f719ebb12952bbb3e749d4b05fcdcd8d382 01a7de795`
    存在，命令就会成功。否则，假设我们想拉取该镜像的最新版本或版本号，比如以下示例：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this scenario, we then would need to ensure that the image had been signed,
    or the command will fail. The `pull` command is not the only operation that interacts
    with trusted content. Others include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要确保镜像已经被签名，否则命令将会失败。`pull` 命令并不是唯一与可信内容交互的操作，其他包括以下内容：
- en: '`$docker push`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$docker push`'
- en: '`$docker build`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$docker build`'
- en: '`$docker create`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$docker create`'
- en: '`$docker run`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$docker run`'
- en: We can test this out now. We've created the `shipitclicker` image in advance
    for you to pull from Docker Hub, located in the Packt Docker book repository at
    [https://hub.docker.com/r/dockerfordevelopers/shipitclicker](https://hub.docker.com/r/dockerfordevelopers/shipitclicker).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进行测试了。我们已提前为你创建了 `shipitclicker` 镜像，你可以从 Docker Hub 拉取，位于 Packt Docker
    书籍仓库中的 [https://hub.docker.com/r/dockerfordevelopers/shipitclicker](https://hub.docker.com/r/dockerfordevelopers/shipitclicker)。
- en: 'You can attempt to pull this image using the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用以下命令拉取此镜像：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should now see a *request denied* error similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该会看到一个类似于 *请求被拒绝* 的错误：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ensuring that this flag is enabled in an automated build process is also a must,
    as it prevents unverified images from making their way into your environments
    by accident.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在自动化构建过程中启用此标志也是必须的，因为它可以防止未经验证的镜像意外进入你的环境。
- en: This very simple approach of using DCT can go a long way to ensuring you avoid
    using untrusted content from Docker Hub. Now let's look at the base images a little
    closer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非常简单的 DCT 使用方法对于确保你避免使用来自 Docker Hub 的不信任内容非常有效。现在，让我们更仔细地看看基础镜像。
- en: Using minimal base images
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最小化基础镜像
- en: So we know that we are pulling in signed images or specific hashes, but is there
    anything we need to consider around the type of image we are using in our containers?
    The answer to this is *yes*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道我们正在拉取签名镜像或特定的哈希值，但我们是否需要考虑我们在容器中使用的镜像类型？答案是 *是的*。
- en: You should ask yourself when using an image whether the whole OS, complete with
    all its pre-installed packages, is required? In some cases, this can introduce
    vulnerabilities, as you may be including unpatched libraries and other code in
    your container. The best approach, therefore, is to start with something basic
    and then build up from there. This will help to reduce your overall attack surface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用镜像时，你应该问问自己，是否真的需要整个操作系统，包括所有预装的包？在某些情况下，这可能会引入漏洞，因为你可能会在容器中包含未修补的库和其他代码。因此，最好的方法是从简单的镜像开始，然后逐步构建。这将有助于减少整体攻击面。
- en: Let's grab a minimal image from Docker Hub now so we can work with it throughout
    the rest of this chapter. The image we are going to use is `shipitclicker:v0.1`,
    which we just tested with `DOCKER_CONTENT_TRUST` and is based on Alpine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从 Docker Hub 拉取一个最小化的镜像，这样我们可以在本章其余部分进行操作。我们将使用的镜像是 `shipitclicker:v0.1`，它刚刚通过
    `DOCKER_CONTENT_TRUST` 进行了测试，并基于 Alpine。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in checking it out and haven't already done so, the Alpine
    image is only 5 MB in size and is part of the Official Images program on Docker
    Hub. These are a set of repositories that provide all the essential basics, while
    also ensuring all security patches are applied regularly. In addition to this,
    the official Docker images are also signed, so can therefore guarantee some of
    the security precautions that were just discussed around image verification in
    this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣查看，并且还没有这样做，Alpine 镜像仅有 5 MB 大小，并且是 Docker Hub 官方镜像计划的一部分。这些镜像是一些仓库，提供所有基本的必要内容，同时确保所有安全补丁定期应用。除此之外，官方
    Docker 镜像也是签名的，因此可以保证本章讨论的镜像验证安全措施。
- en: 'The first thing you will need to do is disable `DOCKER_CONTENT_TRUST` in your
    current shell, or grab the hash of the image so that you can now pull it. If you
    wish to disable `DOCKER_CONTENT_TRUST`, you can do this via the following command
    in your current shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在当前的 shell 中禁用 `DOCKER_CONTENT_TRUST`，或者获取镜像的哈希值，以便你现在可以拉取它。如果你希望禁用 `DOCKER_CONTENT_TRUST`，可以通过在当前
    shell 中执行以下命令来实现：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just remember, if you shut the shell down and create a new one, you will need
    to run this command again. We recommend you leave the flag set to `1` and instead
    pull the hash version.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住，如果你关闭了 shell 并创建了一个新的，你需要再次运行此命令。我们建议你将标志保留为 `1`，而是拉取哈希版本。
- en: 'You can find the hash under the **Tags** tab for the repository, as the following
    link demonstrates:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在仓库的 **Tags** 标签下找到哈希值，如以下链接所示：
- en: '[https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags](https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags](https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags)'
- en: 'From here, select the digest value displayed under the version you are interested
    in. This will then display the `sha256` hash, such as the following, for example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，选择你感兴趣的版本下显示的摘要值。这将显示 `sha256` 哈希值，例如以下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows where you can find the hash for use in your
    `docker pull` commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了你可以找到用于 `docker pull` 命令的哈希位置：
- en: '![](img/B11641_13_002.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_13_002.jpg)'
- en: Figure 13.2 – Information on a Docker image
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Docker 镜像的信息
- en: 'The portion of the string containing `sha256` onward can then be used in the
    pull request:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `sha256` 之后的字符串部分可以在拉取请求中使用：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should now see something similar to the following in your terminal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在终端中看到类似以下内容：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running the `docker images` command should now show it present on your system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `docker images` 命令应该能看到它已出现在你的系统中。
- en: When it comes to building your own images, another consideration is using the
    `.dockerignore` file to help keep the overall container size down.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自己的镜像时，另一个需要考虑的因素是使用 `.dockerignore` 文件帮助减少整个容器的大小。
- en: 'With the `.dockerignore` file included in the build context directory, any
    files listed in the file will not be added to the image. This, as you will see
    shortly, has another handy benefit. From an image size perspective, and in light
    of our general drive cleanliness as a best practice, we can use it to avoid binaries
    such as Python `.pyc` files and similar being accidentally added to the image.
    The following example `.dockerignore` file demonstrates how we can do this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建上下文目录中包含 `.dockerignore` 文件时，文件中列出的任何文件将不会被添加到镜像中。正如你将很快看到的，这还有一个方便的好处。从镜像大小的角度来看，考虑到我们提倡的最佳实践——保持干净，我们可以利用这一点避免像
    Python `.pyc` 文件和类似的二进制文件被意外添加到镜像中。以下示例的 `.dockerignore` 文件演示了我们如何做到这一点：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach is very simple, and if you are used to using `.gitignore` files,
    it will already be familiar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常简单，如果你习惯使用 `.gitignore` 文件的话，应该已经非常熟悉了。
- en: Now we have our minimal base image, we should take a look at some methods to
    restrict privileges when we create containers, so as to prevent accidental security
    breaches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了最小的基础镜像，我们应该看看在创建容器时限制权限的一些方法，以防止意外的安全漏洞。
- en: Restricting privileges
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制权限
- en: In the previous chapter, we looked at assigning a user and a group to restrict
    privilege escalation when starting the image. We can build on this by also using
    a useful parameter called `no-new-privileges`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了分配用户和组来限制启动镜像时的权限提升。我们可以在此基础上，进一步使用一个有用的参数 `no-new-privileges`。
- en: The flag leverages a feature of the underlying Linux kernel known as `no_new_privs`.
    The basic idea of this feature was to ensure that any processes, including child
    processes, cannot gain additional privileges when spawned. With this option enabled,
    applications will not be able to use features such as `setuid`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志利用了底层 Linux 内核的 `no_new_privs` 功能。这个功能的基本思想是确保任何进程，包括子进程，在生成时无法获得额外的权限。启用此选项后，应用程序将无法使用
    `setuid` 等功能。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `setuid` feature allows users to run and execute certain programs with escalated
    privileges. This poses a security threat, as an attacker can exploit it to execute
    code and programs they would not normally have access to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuid` 功能允许用户以提升的权限运行和执行某些程序。这构成了一个安全威胁，因为攻击者可以利用它执行他们通常无法访问的代码和程序。'
- en: Processes spawned via this feature also cannot unset the `no_new_privs` flag
    on themselves, thus preventing an attacker from disabling this feature and escalating
    privileges via `setgid` or `setuid`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此功能生成的进程也无法取消 `no_new_privs` 标志，因此防止攻击者通过 `setgid` 或 `setuid` 禁用此功能并提升权限。
- en: To enable the `no-new-privileges` feature when running a container, you will
    need to include the `--security-opt` flag and add it as a parameter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行容器时启用 `no-new-privileges` 功能，你需要包括 `--security-opt` 标志并将其作为参数添加。
- en: 'Let''s try this out with the image we just downloaded:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试刚刚下载的镜像：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The image should now be running in this mode. Remember that we can get the
    container name by running the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像现在应该已经以这种模式运行。记住，我们可以通过运行以下命令获取容器名称：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Disabling the ability for a container to gain further privileges can also help
    us to prevent container breakout. The term **breakout** is used to refer to a
    case when a compromised container can access sensitive data on the underlying
    host. In a scenario where a container is exploited and the exploit allows the
    attacker to elevate privileges (if, for example, the previously discussed flag
    wasn't included), they may then attempt to pivot and compromise other containers
    through Docker, or exploit the host itself for some other gain.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用容器获取更高权限的能力也有助于防止容器突破。**突破**这个术语是用来指代一个已被攻破的容器能够访问底层主机上的敏感数据的情况。在容器被利用且漏洞允许攻击者提升权限（例如，如果之前讨论的标志未包含在内）的场景下，他们可能会尝试转移攻击并通过Docker进一步攻破其他容器，或者利用主机本身获得其他利益。
- en: As we will learn later in this chapter, there are ways to harden our system
    further, by restricting the privileges (known as capabilities) of a container
    when we run it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面学习的那样，通过限制容器的权限（称为能力），在运行时可以进一步加固我们的系统。
- en: We'll now look at some more flags we can add, along with some other techniques
    to ensure that the data we are using remains safe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些可以添加的标志，以及其他一些确保我们使用的数据保持安全的技术。
- en: Avoiding data leakages from your image
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免你的镜像数据泄露
- en: In Linux, we can implement users and groups to ensure that only those who need
    access to read and write files can do so. This fine-tuned system of access permissions
    is important to help prevent data leakage. Another useful method we can use to
    protect the filesystem used by the image is to set the filesystems and any volumes
    to a read-only state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，我们可以实现用户和组的管理，以确保只有需要读取和写入文件的用户才能执行这些操作。这种精细化的访问权限系统对于防止数据泄露非常重要。另一个保护镜像文件系统的方法是将文件系统和所有卷设置为只读状态。
- en: Let's start by looking at a volume we may want to mount. We're going to run
    a new container based off the `shipitclicker` image and mount a local filesystem
    to it. In order to achieve this, in addition to the `--mount` flag, we will include
    a `readonly` statement within the `run` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个可能想要挂载的卷开始。我们将基于`shipitclicker`镜像运行一个新容器，并将本地文件系统挂载到其中。为了实现这一点，除了`--mount`标志，我们还将在`run`命令中加入一个`readonly`语句。
- en: 'Start by creating an empty folder on your local OS, which we can use to mount
    the filesystem:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的本地操作系统上创建一个空文件夹，我们可以用它来挂载文件系统：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, try running the following command. It will mount the local folder and
    run the container and attempt to write a file to the `/mnt/testfiles` directory
    called `test.file`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试运行以下命令。它将挂载本地文件夹并运行容器，并尝试向`/mnt/testfiles`目录写入一个名为`test.file`的文件：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should now see an error informing you that the filesystem is read-only:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该会看到一个错误，告知你文件系统是只读的：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using this mechanism, we can read files mounted to the container, but avoid
    a situation where the container can write files back to it, thus accidentally
    writing keys or other data into a directory on the host where they should not
    be located.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种机制，我们可以读取挂载到容器上的文件，但避免容器能够将文件写回，从而防止意外地将密钥或其他数据写入主机上不应存放的目录。
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An important point to remember is that the root account can override any file
    permissions and thus can read any files in the container. If somebody gets root
    access, they can exfiltrate your data!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，root账户可以覆盖任何文件权限，因此可以读取容器中的任何文件。如果有人获得了root访问权限，他们可以窃取你的数据！
- en: What about protecting the filesystem in the container itself, for example, the
    `/tmp` directory? Thankfully, Docker provides us with an easy method to do this,
    via the `--read-only` flag. We can try this out and see how it works in practice.
    First, stop the container we just created. Remember, you can get the container's
    name when you run the `docker ps -a` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何保护容器本身的文件系统呢，例如`/tmp`目录？幸运的是，Docker提供了一个简单的方法来实现这一点，通过`--read-only`标志。我们可以尝试一下，看看它在实践中的效果。首先，停止我们刚才创建的容器。记住，你可以在运行`docker
    ps -a`命令时获取容器的名称。
- en: 'Once you have the container name, stop the container. We''ve used `nervous_sinoussi`
    here to represent the name; replace this with your container''s own unique name:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了容器名称，停止容器。我们这里使用了`nervous_sinoussi`作为示例名称；请用你容器的唯一名称替换它：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are going to recreate the container using the `--read-only` flag. Included
    in the `run` command will be an example of trying to write a file called `test`
    to the `/tmp` directory. With the `--read-only` flag enabled, we should get an
    error informing us this is not permitted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`--read-only`标志重新创建容器。在`run`命令中将包括尝试将名为`test`的文件写入`/tmp`目录的示例。启用`--read-only`标志后，我们应该会看到一个错误，提示此操作不被允许。
- en: 'Let''s remove the container we created previously in order to keep our environment
    clean:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除之前创建的容器，以保持环境的清洁：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, try running the following command, including your container name:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尝试运行以下命令，记得包括你的容器名称：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should now see an error such as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该会看到如下错误：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Checking the list of Docker processes running, you will see the command executed
    and exited. Let''s clear this container out and try rerunning the command without
    the flag and echo out the contents of the file we create:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 检查正在运行的Docker进程列表时，你将看到命令已执行并退出。让我们清理这个容器并尝试重新运行不带标志的命令，同时回显我们创建的文件内容：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Confirmation that the filesystem was written to will now be displayed via the
    `echo` command, which prints the contents of `/tmp/test`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过`echo`命令显示文件系统已写入的确认信息，`echo`命令会打印`/tmp/test`的内容：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Therefore, to avoid this second scenario where the filesystem can be written
    to, always include the `--read-only` flag.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了避免文件系统可以被写入的第二种情况，始终包括`--read-only`标志。
- en: Additionally, remember not to include sensitive information such as private
    keys and API tokens inside the Dockerfile. There are a number of services you
    can use to avoid this situation including HashiCorpVault, Docker Swarm, and services
    built into cloud providers like AWS, such as SSM. [*Chapter 14*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316),
    *Advanced Docker Security – Secrets, Secret Commands, Tagging, and Labels*, will
    cover these in more detail.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记得不要在Dockerfile中包含敏感信息，如私钥和API令牌。你可以使用一些服务来避免这种情况，包括HashiCorp Vault、Docker
    Swarm以及云提供商（如AWS）内置的服务，例如SSM。[*第14章*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316)，*高级Docker安全——机密、机密命令、标记和标签*，将更详细地讲解这些内容。
- en: With some of these best practices in mind, now let's look at the commands we
    would use to build our own images and what security concerns we need to take into
    consideration.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记一些最佳实践后，让我们来看看我们将用来构建自己镜像的命令，以及需要考虑的安全问题。
- en: Security around Docker commands
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker命令的安全性
- en: We will shortly be exploring the build process and how we can harden this from
    a security perspective. In order to do this, however, we will first dig into some
    of the commands we will use in a little more detail so we know which ones are
    safe to use, and which pose a potential threat. Let's start by looking at the
    `COPY` and `ADD` commands.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将探讨构建过程以及如何从安全角度加强这一过程。为了做到这一点，然而，我们首先需要更详细地了解一些我们将要使用的命令，以便知道哪些是安全的，哪些可能构成潜在威胁。让我们从`COPY`和`ADD`命令开始。
- en: COPY versus ADD – what's the story?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COPY与ADD——这其中有什么区别？
- en: When you come to build an image, you will want to copy files from the host over
    to it. Typically, there are two methods for doing this. If you've done any research
    online, you may have seen comments along the lines of "don't use the `ADD` command."
    So why is this?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建镜像时，你需要将文件从主机复制到镜像中。通常，做这件事有两种方法。如果你做过一些在线研究，你可能见过类似“不要使用`ADD`命令”的评论。那么，为什么呢？
- en: The `ADD` command allows us to recursively copy files over to the image, much
    like a `cp -r` command might do in Linux if we also piped it through `zip` when
    necessary. In short, it expands archive files and creates any directories that
    don't exist on the target.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`命令允许我们递归地将文件复制到镜像中，类似于Linux中的`cp -r`命令，如果需要，我们还可以通过`zip`命令来压缩。简而言之，它扩展归档文件并创建目标位置不存在的目录。'
- en: The input to the command is provided as a URL that can reference either a local
    or remote (archive) file. As you can imagine, when pulling from a remote location,
    there are a number of risks to consider
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输入是一个URL，可以引用本地或远程（归档）文件。正如你可以想象的那样，从远程位置拉取时，有很多风险需要考虑。
- en: Has the file been modified on the remote host and compromised?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上的文件是否已被修改并遭到破坏？
- en: Do you know the origin of the file on the remote host?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道远程主机上的文件来源吗？
- en: What considerations are there regarding **Man-In-The-Middle** (**MITM**) attacks?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于**中间人攻击**（**MITM**）有哪些考虑因素？
- en: 'An example of how this command might be used in a Dockerfile can be seen here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在 Dockerfile 中的使用示例如下：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, the zipped version of the repository hosted on this book's GitHub
    account would be downloaded and expanded into the `tmp` directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将下载并解压缩本书 GitHub 账户上托管的仓库的压缩版本到 `tmp` 目录。
- en: Previously, we discussed using the `.dockerignore` file to help keep image sizes
    small. In addition to this benefit, they can help to prevent files accidentally
    being added if you include the `ADD` command. For example, you can ensure that
    configuration `.ENV` files or similar are not copied over.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了使用 `.dockerignore` 文件来帮助保持镜像大小小巧。除了这个好处，它们还可以防止文件在使用 `ADD` 命令时被意外添加。例如，你可以确保像配置
    `.ENV` 文件或类似文件不会被复制过去。
- en: The `COPY` command works slightly differently to `ADD`. Like `ADD`, it copies
    files recursively. However, you must provide an explicit source and destination
    folder. This means you have to declare the locations the files are coming from
    and going to. A ZIP file copied from A to B will still remain a ZIP file, and
    not be expanded while avoiding any unintended consequences.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 命令的工作方式与 `ADD` 略有不同。像 `ADD` 一样，它会递归地复制文件。然而，你必须明确提供源文件夹和目标文件夹。这意味着你必须声明文件的来源和去向。例如，从
    A 复制到 B 的 ZIP 文件仍然是一个 ZIP 文件，不会展开，从而避免了任何意外后果。'
- en: 'We can see an example of the syntax for this command as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个命令语法的示例如下：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is safer to break down the process of adding files into multiple steps, such
    as downloading the files, scanning them, and then copying them over. When accessing
    remote content, you should always use an SSL/TLS connection as well. This can
    prevent MITM attacks being a problem by implementing a cryptographically secure
    and authenticated communication route.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将添加文件的过程分解为多个步骤是更安全的做法，比如先下载文件、扫描文件，然后再复制文件。当访问远程内容时，你还应始终使用 SSL/TLS 连接。这可以通过实现加密安全和经过身份验证的通信路径，防止
    MITM 攻击成为问题。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An MITM attack is one where a malicious party secretly eavesdrops, relays, or
    alters communications between two parties.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: MITM 攻击是指恶意方秘密窃听、转发或篡改两方之间的通信。
- en: We've just looked at how the `COPY` command can avoid some of the issues of
    `ADD`, but what about recursive copying? Are there risks here?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看过 `COPY` 命令如何避免一些 `ADD` 命令的问题，但递归复制呢？这里是否存在风险？
- en: Recursive COPY – use with caution
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归 COPY – 使用时请谨慎
- en: Recursive copying, as you may be aware, copies the contents of one location
    to another, and includes all the nested subfolders and files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能知道的，递归复制会将一个位置的内容复制到另一个位置，并包括所有嵌套的子文件夹和文件。
- en: It's possible to accidentally copy files into the image you did not mean to
    when using the recursive copy command in Docker.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Docker 的递归复制命令时，有可能不小心将文件复制到镜像中，这是你并不打算复制的文件。
- en: 'Let''s look at an example. In this following screenshot, we can see an example
    directory, and included in it is a folder called `oops` and a `my_secret` file.
    This file contains a hypothetical secret such as an API token that has been accidentally
    left in the folder:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。在下面的截图中，我们可以看到一个示例目录，里面包含一个名为 `oops` 的文件夹和一个 `my_secret` 文件。这个文件包含了一个假设的秘密，比如一个
    API 令牌，它被意外地留在了文件夹中：
- en: '![](img/B11641_13_003.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_13_003.jpg)'
- en: Figure 13.3 – Example of a secret accidentally left in the source code
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 示例：秘密被意外地留在源代码中
- en: 'Imagine that we were to run the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行以下命令：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Along with the parent directory in which all the folders reside, this secret
    file would also be copied over, as the command will recursively copy everything,
    including the `oops` directory and our nested file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以及所有文件夹所在的父目录，这个秘密文件也会被复制过去，因为命令会递归复制所有内容，包括 `oops` 目录和我们的嵌套文件。
- en: In order to avoid these negative effects, it is always a good practice to update
    your `.dockerignore` file to ensure that sensitive file types are excluded.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些负面影响，更新你的 `.dockerignore` 文件，确保排除敏感文件类型总是一个好习惯。
- en: 'As we noted earlier, if you are familiar with `.gitignore`, adding file types
    to your `.dockerignore` file should be simple. Here are some quick rules to remember:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，如果你熟悉 `.gitignore` 文件，将文件类型添加到 `.dockerignore` 文件应该很简单。以下是一些需要记住的快捷规则：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using these mechanisms, you can ensure a variety of files are excluded from
    the container, such as `*.pem` and `*.ENV` files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些机制，你可以确保各种文件被排除在容器之外，比如 `*.pem` 和 `*.ENV` 文件。
- en: Therefore, if you do plan to use recursive copying in your Dockerfile, ensure
    the `.dockerignore` file is up to date and that you have audited your application
    to ensure that everything being copied over is as intended.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你确实计划在 Dockerfile 中使用递归复制，请确保 `.dockerignore` 文件是最新的，并且已经审计过你的应用程序，确保所有被复制的内容都是按预期进行的。
- en: Let's now turn our attention to the build process and how we can improve security
    at this stage. Here, we will see how commands such as `COPY` come into play as
    part of a larger process.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注构建过程以及如何在这个阶段提升安全性。在这里，我们将看到 `COPY` 等命令如何作为更大过程的一部分发挥作用。
- en: Security around the build process
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建过程的安全性
- en: We've seen how we can pull images and run them in a secure fashion. But what
    about building our own container images? As you are now familiar with, some commands
    pose additional risks when added to the Dockerfile. In this section of the chapter,
    we will look at how we can secure the build process using the techniques we have
    learned so far. This will include using a minimal base image (`shipitclicker`)
    as a starting point and then using the security tweaks we have tested against
    this image when running it as a container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何拉取镜像并以安全的方式运行它们。那么，自己构建容器镜像呢？正如你现在已经熟悉的那样，某些命令在加入到 Dockerfile 时会带来额外的风险。在本章的这一部分，我们将探讨如何使用我们迄今为止学到的技巧来确保构建过程的安全。这将包括使用一个最小的基础镜像（`shipitclicker`）作为起点，然后在运行容器时，使用我们已对该镜像进行过安全测试的调整。
- en: Using multi-stage builds
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多阶段构建
- en: As we previously covered, we need to be careful about secrets and ensure they
    are not accidentally leaked. One way to avoid this is to not include them in the
    Dockerfile. However, what about at the build stage? It's likely you will need
    to use private keys in conjunction with the build process from time to time, for
    example, to pull code from a remote service that is protected with public key
    encryption.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们需要小心处理机密信息，确保它们不会被意外泄露。避免这种情况的一种方法是不要将它们包含在 Dockerfile 中。然而，在构建阶段呢？你很可能会不时需要使用私钥来配合构建过程，例如，从一个使用公钥加密保护的远程服务中拉取代码。
- en: One method to use keys securely is through the use of multi-stage builds. This
    process uses a disposable intermediate layer, which ensures that data isn't accidentally
    leaked into the final build process. Let's look at a simple example. If you wish
    to run this code, you will need to have an SSH server running and add your public
    key to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥的一个安全方法是通过使用多阶段构建。这个过程使用一个一次性中间层，确保数据不会意外泄露到最终的构建过程中。让我们看一个简单的示例。如果你希望运行这段代码，你需要运行一个
    SSH 服务器并将你的公钥添加到它。
- en: If you don't have one running already, to build a container that runs SSH, you
    can reuse the Dockerfile located at [https://docs.docker.com/engine/examples/running_ssh_service/](https://docs.docker.com/engine/examples/running_ssh_service/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有运行 SSH 服务器，可以重复使用位于 [https://docs.docker.com/engine/examples/running_ssh_service/](https://docs.docker.com/engine/examples/running_ssh_service/)
    的 Dockerfile 来构建一个运行 SSH 的容器。
- en: Next, let's take a look at an example of the multi-stage build process and how
    we can use it in conjunction with accessing an SSH service.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个多阶段构建过程的示例，以及如何将其与访问 SSH 服务结合使用。
- en: Copy the following code to a new Dockerfile you can work with. On your container
    running the SSH server, add a file called `file.txt` and then update the Dockerfile
    code to include your user, IP/hostname, and the path to the file you just created.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码复制到一个新的 Dockerfile 中，以便你进行操作。在运行 SSH 服务器的容器上，添加一个名为 `file.txt` 的文件，然后更新
    Dockerfile 代码，包含你的用户、IP/主机名，以及你刚创建的文件的路径。
- en: 'Let''s do a quick walkthrough of what is going on here before we build it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建之前，先快速了解一下这里发生了什么：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code does a number of things. First, it takes our `shipitclicker` image
    as an intermediate build step.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了几件事情。首先，它将我们的 `shipitclicker` 镜像作为一个中间构建步骤。
- en: Following this, it sets the `WORKDIR` to test and creates an `ARG` value called
    `ssh_prv_key`. This `ARG` value will allow us to pass in the path to the RSA private
    key that will be needed to connect to the remote SSH server.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将 `WORKDIR` 设置为 test，并创建一个名为 `ssh_prv_key` 的 `ARG` 值。这个 `ARG` 值将允许我们传入连接远程
    SSH 服务器所需的 RSA 私钥的路径。
- en: Based upon our input, we echo it out as a file and then set permissions on the
    file to `600`. Then, we install `openssh` so we can use the `scp` command-line
    feature. The interesting bit comes next.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的输入，我们将其作为文件输出，然后设置该文件的权限为 `600`。接着，我们安装 `openssh`，以便可以使用 `scp` 命令行功能。接下来才是有趣的部分。
- en: The `RUN scp` command takes the private key we injected and uses it to connect
    to the remote server to retrieve a file called `file.txt`, which is then copied
    back to the present directory. This step completes the first stage of the build.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN scp`命令将注入的私钥用于连接远程服务器，以检索名为`file.txt`的文件，并将其复制回当前目录。这一步完成了构建的第一阶段。'
- en: In the second stage, we once again use the `shipitclicker` image and use the
    same `WORKDIR`, that is, `test`. The final line, however, is where the magic happens.
    It copies from the intermediate step we completed in step 1, the file that was
    retrieved from the remote server, and replicates it to the final build stage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，我们再次使用`shipitclicker`镜像，并使用相同的`WORKDIR`，即`test`。然而，最后一行才是魔法发生的地方。它从我们在第一阶段完成的中间步骤中复制出从远程服务器检索到的文件，并将其复制到最终的构建阶段。
- en: As you can see from the result, the final container does not contain the private
    key we used to retrieve the file from the remote SSH server, and thus will not
    accidentally end up in the final container.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看到，最终的容器并不包含我们用来从远程SSH服务器检索文件的私钥，因此它不会意外地进入最终的容器中。
- en: 'To build out this Dockerfile once you have a remote location to copy the file
    from, you can use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个远程位置来复制文件，可以使用以下命令来构建这个Dockerfile：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can probably guess from looking at this, the `ssh_prv_key` build argument
    is simply the value of our private key concatenated out into the variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这个可以猜到的，`ssh_prv_key`构建参数实际上只是我们的私钥的值，连接到变量中。
- en: Once we have built our container, when we run it, we want to ensure that it
    does not consume more resources than required. This can help to mitigate damage
    in the case of an unfortunate security breach.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建好了容器，当我们运行它时，我们希望确保它不会消耗超过所需的资源。这有助于在发生不幸的安全漏洞时减轻损害。
- en: As a final note, multi-stage builds can also aid in keeping the images small,
    which is a desirable quality, as already discussed. Let's now take a look at how
    we limit capabilities and resource usage in Docker further.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的是，多阶段构建还可以帮助保持镜像的小巧，这是一种理想的特性，正如前面所讨论的。接下来让我们来看看如何进一步限制Docker中的功能和资源使用。
- en: Limiting resources and capabilities when deploying your builds
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在部署构建时限制资源和能力
- en: You can limit a variety of resources available to your container, including
    CPU usage and memory. This can help prevent denial-of-service attacks. In this
    scenario, the container is exploited to use up the underlying resources of the
    host, thus causing overall performance degradation, or worse, the underlying host
    to crash.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以限制容器可用的各种资源，包括CPU使用率和内存。这有助于防止拒绝服务攻击。在这种情况下，容器会被利用去消耗主机的底层资源，从而导致整体性能下降，甚至更糟，导致底层主机崩溃。
- en: Additionally, access control mechanisms are an important piece of the puzzle
    to ensure that as well as limiting the resources used by a container, we also
    limit privileges and access.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，访问控制机制是确保容器不仅限制使用的资源，还限制权限和访问的重要组成部分。
- en: Limiting resources
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制资源
- en: In order to avoid the types of DOS attacks mentioned earlier, we can use a combination
    of flags to restrict how much of the underlying host resources a container can
    consume.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免前面提到的DOS攻击类型，我们可以使用一组合适的标志来限制容器可以消耗的底层主机资源。
- en: The first area we will look at is memory. Docker gives us the ability to restrict
    how much memory a container can use through a combination of hard and soft limits.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先关注的领域是内存。Docker使我们能够通过硬限制和软限制的结合，限制容器能够使用的内存。
- en: We can set a hard limit on a container using the `-m`/`--memory` flag. This
    will set aside the amount you specify and will not allow the container to exceed
    this. In the case that a container does become compromised, the hard limit feature
    will prevent a runaway malicious process from consuming more and more of the underlying
    host's RAM.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-m`/`--memory`标志为容器设置硬限制。这将为指定的内存量预留，并且不允许容器超过此限制。如果容器被攻破，硬限制功能将防止恶意进程不断消耗底层主机的内存。
- en: When setting the memory limit, ensure that you adjust it in line with what your
    application is intended to do. Too little memory may prevent an issue if the container
    were compromised, but may, in turn, not be enough to run your application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 设置内存限制时，确保它与你的应用程序预期的功能相匹配。内存过少可能会防止在容器被攻破时发生问题，但可能不足以运行你的应用程序。
- en: The `–memory` flag can also be combined with the `–memory-reservation` flag.
    This second feature allows you to specify a soft limit smaller than the `–memory`
    one. When Docker discovers that the underlying host has an issue, such as low
    memory, it will activate this feature. Once activated, Docker will attempt to
    restrict the amount of memory available to the container.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`–memory` 标志也可以与 `–memory-reservation` 标志一起使用。第二个特性允许你指定一个比 `–memory` 更小的软限制。当
    Docker 发现底层宿主机出现问题，例如内存不足时，它会激活此特性。激活后，Docker 将尝试限制容器可用的内存量。'
- en: As with memory, we also need to be aware that an exploited container can also
    consume more CPU resources than expected, which can, in turn, have negative side
    effects for the host.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存类似，我们也需要意识到被利用的容器可能会消耗比预期更多的 CPU 资源，这反过来可能会对宿主机产生负面影响。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using Docker 1.12 or lower, you will need to use the `–cpu-period`
    and `–cpu-quota` flags instead of the `–cpus` flag.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Docker 1.12 或更低版本，你需要使用 `–cpu-period` 和 `–cpu-quota` 标志，而不是 `–cpus`
    标志。
- en: Using the `–cpus` flag, you can define how many CPUs a container has access
    to. If you have multiple CPUs (for example, four) and set the value to `–cpus="2"`,
    the container is restricted to only being able to use up to two CPUs and no more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `–cpus` 标志，你可以定义容器可访问的 CPU 数量。如果你有多个 CPU（例如，四个），并且将值设置为 `–cpus="2"`，容器将被限制为最多只能使用两个
    CPU，而不能更多。
- en: We've seen how we can use some flags to restrict the resources a container has
    available to it at runtime. Let's look at some additional flags we can use to
    further restrict potential security risks when we run our container.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用一些标志来限制容器在运行时可用的资源。接下来，我们来看看一些其他的标志，可以进一步限制运行容器时可能的安全风险。
- en: Dropping capabilities
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除能力
- en: Some techniques you can use to help avoid other risks include dropping capabilities
    when running containers. Capabilities are a feature of Linux that divide privileges
    associated with the root/super user account into individual components.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以帮助避免其他风险的技术包括在运行容器时删除能力。能力是 Linux 的一个特性，它将与 root/超级用户账户相关的权限分割成独立的组件。
- en: The list of capabilities that a container usually has are `chown`, `dac_override`,
    `fowner`, `fsetid`, `kill`, `setgid`, `setuid`, `setpcap`, `net_bind_service`,
    `net_raw`, `sys_chroot`, `mknod`, `audit_write`, and `setfcap`. To understand
    what each capability allows, please refer to the Linux man-pages documentation
    at [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常具有的能力列表包括`chown`、`dac_override`、`fowner`、`fsetid`、`kill`、`setgid`、`setuid`、`setpcap`、`net_bind_service`、`net_raw`、`sys_chroot`、`mknod`、`audit_write`和`setfcap`。要了解每项能力的具体功能，请参考
    Linux man-pages 文档：[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)。
- en: 'To remove capabilities such as `chown`, you can use the `–cap-drop` flag when
    running a container. Refer to the following for an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除像 `chown` 这样的能力，你可以在运行容器时使用 `–cap-drop` 标志。请参考以下示例：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Removing powerful capabilities that your production containers do not need can
    help harden you against attacks that seek to break out of the container.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 删除生产容器不需要的强大能力，可以帮助防止攻击者突破容器进行攻击。
- en: That ends this chapter on techniques to improve your fundamental security posture.
    Before we move on to some more advanced techniques, let's quickly re-cap what
    we have learned so far.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容到此结束，关于提高基础安全态势的技术。我们在进入更高级的技术之前，快速回顾一下到目前为止学到的内容。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reviewed some basic steps you can take to ensure that
    when you pull images and build and run containers, your attack surface will be
    reduced.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了一些基本步骤，确保在拉取镜像、构建和运行容器时，能够减少攻击面。
- en: We learned about how to ensure that we only pull safe images from Docker Hub.
    Additionally, we saw how we can use read-only permissions to prevent write access
    to filesystems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何确保从 Docker Hub 拉取的镜像是安全的。此外，我们还了解了如何使用只读权限来防止对文件系统的写入访问。
- en: Multi-stage builds were discussed to show how we can break down our container
    build process into steps to ensure that SSH keys and similar are not accidentally
    included in the final product. The `.dockerignore` file was briefly reviewed from
    a security perspective, and finally, we discussed how to restrict system resources
    and implement access control through removing capabilities.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了多阶段构建，以展示如何将容器构建过程拆分为多个步骤，从而确保不会意外地将 SSH 密钥等包含在最终产品中。我们从安全角度简要回顾了 `.dockerignore`
    文件，最后，我们讨论了如何通过移除能力来限制系统资源并实施访问控制。
- en: In the next chapter, we will look at how we can automate some of the security
    processes by using scanning tools and implement monitoring.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过使用扫描工具和实施监控来自动化一些安全流程。
