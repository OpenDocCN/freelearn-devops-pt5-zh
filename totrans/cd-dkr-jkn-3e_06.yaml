- en: '*Chapter 4*: Continuous Integration Pipeline'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know how to configure Jenkins. In this chapter, we will see how to
    use it effectively, focusing on the feature that lies at the heart of Jenkins
    – pipelines. By building a complete continuous integration process from scratch,
    we will describe all aspects of modern team-oriented code development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commit pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code quality stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers and notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team development strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you''ll need the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java JDK 8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and solutions to the exercises can be found at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3r9lbmG](https://bit.ly/3r9lbmG).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **pipeline** is a sequence of automated operations that usually represents
    a part of the software delivery and quality assurance process. It can be seen
    as a chain of scripts that provide the following additional benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation grouping**: Operations are grouped together into stages (also known
    as **gates** or **quality gates**) that introduce a structure into a process and
    clearly define a rule – if one stage fails, no further stages are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility**: All aspects of a process are visualized, which helps in quick
    failure analysis and promotes team collaboration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: Team members learn about problems as soon as they occur so that
    they can react quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The concept of pipelining is similar to most continuous integration tools. However,
    the naming can differ. In this book, we will stick to the Jenkins terminology.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's first describe the Jenkins pipeline structure and then how it works in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Jenkins pipeline consists of two kinds of elements – a **stage** and a **step**.
    The following diagram shows how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Jenkins pipeline structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – The Jenkins pipeline structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the basic pipeline elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step**: A single operation that tells Jenkins what to do – for example, check
    out code from the repository and execute a script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage**: A logical separation of steps that groups conceptually distinct sequences of
    steps – for example, **build**, **test**, and **deploy**, used to visualize the
    Jenkins pipeline progress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technically, it's possible to create parallel steps; however, it's better to
    treat them as an exception that is only used for optimization purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A multi-stage Hello World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, let''s extend the `Hello World` pipeline to contain two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The pipeline has no special requirements in terms of environment, and it executes
    three steps inside two stages. When we click on **Build Now**, we should see a
    visual representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The multi-stage pipeline build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The multi-stage pipeline build
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline succeeded, and we can see the step execution details by clicking on
    the console. If any of the steps failed, processing would stop, and no further
    steps would run. Actually, the sole reason for a pipeline is to prevent all further
    steps from execution and visualize the point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've discussed the pipeline elements and already used a few of the pipeline
    steps – for example, `echo`. *What other operations can we use inside the pipeline
    definition?*
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we use the declarative syntax that is recommended for all new
    projects. The other options are a Groovy-based DSL and (prior to Jenkins 2) XML
    (created through the web interface).
  prefs: []
  type: TYPE_NORMAL
- en: The declarative syntax was designed to make it as simple as possible to understand
    the pipeline, even by people who do not write code on a daily basis. This is why
    the syntax is limited only to the most important keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an experiment, but before we describe all the details, please read
    the following pipeline definition and try to guess what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, the pipeline didn''t scare you. It is quite complex. Actually, it
    is so complex that it contains most available Jenkins instructions. To answer
    the experiment puzzle, let''s see what the pipeline does instruction by instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses any available agent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executes automatically every minute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stops if the execution takes more than 5 minutes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asks for the Boolean input parameter before starting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets `Rafal` as the `NAME` environment variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Does the following, only in the case of the `true` input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prints `Hello from Rafal`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints `Testing the chrome browser`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints `Testing the firefox browser`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints `I will always say Hello again!`, regardless of whether there are any
    errors during the execution
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's describe the most important Jenkins keywords. A declarative pipeline
    is always specified inside the `pipeline` block and contains sections, directives,
    and steps. We will walk through each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The complete pipeline syntax description can be found on the official Jenkins
    page at [https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/).
  prefs: []
  type: TYPE_NORMAL
- en: Sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sections define the pipeline structure and usually contain one or more directives
    or steps. They are defined with the following keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stages**: This defines a series of one or more stage directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**: This defines a series of one or more step instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post**: This defines a series of one or more step instructions that are run
    at the end of the pipeline build; they are marked with a condition (for example,
    always, success, or failure) and are usually used to send notifications after
    the pipeline build (we will cover this in detail in the *Triggers and notifications* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label` to match the equally labeled agents, or `docker` to specify a container
    that is dynamically provisioned to provide an environment for the pipeline execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Directives express the configuration of a pipeline or its parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cron` to set the time-based scheduling, or `pollSCM` to check the repository
    for changes (we will cover this in detail in the *Triggers and notifications* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout` (the maximum time of a pipeline run) or `retry` (the number of times
    the pipeline should be rerun after failure).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: This defines a set of key values used as environment variables
    during the build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: This defines a list of user-input parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage**: This allows for the logical grouping of steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This determines whether the stage should be executed, depending on
    the given condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input**: This allows us to prompt the input parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel**: This allows us to specify stages that are run in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matrix**: This allows us to specify combinations of parameters for which
    the given stages run in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Steps are the most fundamental part of the pipeline. They define the operations
    that are executed, so they actually tell Jenkins *what to do*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sh`: This executes the shell command; actually, it''s possible to define almost
    any operation using `sh`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custom`: Jenkins offers a lot of operations that can be used as steps (for
    example, `echo`); many of them are simply wrappers over the `sh` command used
    for convenience. Plugins can also define their own operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script`: This executes a block of Groovy-based code that can be used for some
    non-trivial scenarios where flow control is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complete specification of the available steps can be found at [https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the pipeline syntax is very generic and, technically, can be used
    for almost any automation process. This is why the pipeline should be treated
    as a method of structuing and visualization. However, the most common use case
    is to implement the continuous integration server, which we will look at in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: The commit pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic continuous integration process is called a `commit` (or `push`
    in Git) to the main repository and results in a report about the build success
    or failure. Since it runs after each change in the code, the build should take
    no more than 5 minutes and should consume a reasonable amount of resources. The
    commit phase is always the starting point of the continuous delivery process and
    provides the most important feedback cycle in the development process – constant
    information if the code is in a healthy state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commit phase works as follows: a developer checks in the code to the repository,
    the continuous integration server detects the change, and the build starts. The
    most fundamental commit pipeline contains three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkout**: This stage downloads the source code from the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile**: This stage compiles the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit test**: This stage runs a suite of unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a sample project and see how to implement the commit pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a pipeline for a project that uses technologies such as
    Git, Java, Gradle, and Spring Boot. Nevertheless, the same principles apply to
    any other technology.
  prefs: []
  type: TYPE_NORMAL
- en: Checkout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Checking out code from the repository is always the first operation in any pipeline.
    In order to see this, we need to have a repository. Then, we are able to create
    a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a repository on the GitHub server takes just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://github.com/](https://github.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an account if you don't have one yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New**, next to **Repositories**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it a name – `calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick **Initialize this repository with a README**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create repository**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should see the address of the repository – for example, [https://github.com/leszko/calculator.git](https://github.com/leszko/calculator.git).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a checkout stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a new pipeline called `calculator`, and as it is a `Checkout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The pipeline can be executed on any of the agents, and its only step does nothing
    more than download code from the repository. We can click on **Build Now** to
    see whether it was executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The Git toolkit needs to be installed on the node where the build is executed.
  prefs: []
  type: TYPE_NORMAL
- en: When we have the checkout, we're ready for the second stage.
  prefs: []
  type: TYPE_NORMAL
- en: Compile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to compile a project, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push it to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Compile` stage to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Java Spring Boot project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's create a very simple Java project using the Spring Boot framework built
    by Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is a Java framework that simplifies building enterprise applications.
    Gradle is a build automation system that is based on the concepts of Apache Maven.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a Spring Boot project is to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://start.spring.io/](http://start.spring.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Gradle Project** instead of **Maven Project** (you can choose Maven
    if you prefer it to Gradle).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill `com.leszko` and `calculator`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **Web** to **Dependencies**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Generate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated skeleton project should be downloaded (the `calculator.zip` file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the [http://start.spring.io/](http://start.spring.io/) page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – spring initializr'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – spring initializr
  prefs: []
  type: TYPE_NORMAL
- en: After the project is created, we can push it into the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing code to GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the Git tool to perform the `commit` and `push` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In order to run the `git` command, you need to have the Git toolkit installed
    (it can be downloaded from [https://git-scm.com/downloads](https://git-scm.com/downloads)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first clone the repository to the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Extract the project downloaded from [http://start.spring.io/](http://start.spring.io/) into
    the directory created by Git.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer, you can import the project into IntelliJ, Visual Studio Code,
    Eclipse, or your favorite IDE tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the `calculator` directory should have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform the Gradle operations locally, you need to have the Java
    JDK installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compile the project locally using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the case of Maven, you can run `./mvnw compile`. Both Gradle and Maven compile
    the Java classes located in the `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can commit and push to the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code is already in the GitHub repository. If you want to check it, you can
    go to the GitHub page and see the files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Compile stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add a `Compile` stage to the pipeline using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used exactly the same command locally and in the Jenkins pipeline,
    which is a very good sign because the local development process is consistent
    with the continuous integration environment. After running the build, you should
    see two green boxes. You can also check that the project was compiled correctly
    in the console log.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to add the last stage, which is the unit test; it checks whether
    our code does what we expect it to do. We have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the source code for the calculator logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test for the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Jenkins stage to execute the unit test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's elaborate more on these steps next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating business logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first version of the calculator will be able to add two numbers. Let''s
    add the business logic as a class in the `src/main/java/com/leszko/calculator/Calculator.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the business logic, we also need to add the web service controller
    in a separate file: `src/main/java/com/leszko/calculator/CalculatorController.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This class exposes business logic as a web service. We can run the application
    and see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This should start our web service, and we can check that it works by navigating
    to the browser and opening `http://localhost:8080/sum?a=1&b=2`. This should sum
    two numbers (`1` and `2`) and show `3` in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already have the working application. *How can we ensure that the logic works
    as expected?* We tried it once, but in order to know that it will work consistently,
    we need a unit test. In our case, it will be trivial, maybe even unnecessary;
    however, in real projects, unit tests can save you from bugs and system failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a unit test in the `src/test/java/com/leszko/calculator/CalculatorTest.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test uses the JUnit library, so we need to add it as a dependency in the
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the test locally using the `./gradlew test` command. Then, let''s commit the
    code and push it to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Unit test stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can add a `Unit test` stage to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Maven, use the `./mvnw test` command instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we build the pipeline again, we should see three boxes, which means that
    we''ve completed the continuous integration pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – A continuous integration pipeline build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – A continuous integration pipeline build
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our pipeline prepared, let's look at how to achieve exactly
    the same result using Jenkinsfile.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkinsfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've created all the pipeline code directly in Jenkins. This is, however,
    not the only option. We can also put the pipeline definition inside a file called `Jenkinsfile` and commit it
    to the repository, together with the source code. This method is even more consistent
    because the way your pipeline looks is strictly related to the project itself.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you don't need the code compilation because your programming
    language is interpreted (and not compiled), you won't have the `Compile` stage.
    The tools you use also differ, depending on the environment. We used Gradle/Maven
    because we've built a Java project; however, in the case of a project written
    in Python, you can use PyBuilder. This leads to the idea that the pipelines should
    be created by the same people who write the code – the developers. Also, the pipeline
    definition should be put together with the code, in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach brings immediate benefits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a Jenkins failure, the pipeline definition is not lost (because
    it's stored in the code repository, not in Jenkins).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The history of the pipeline changes is stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline changes go through the standard code development process (for example,
    they are subjected to code reviews).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the pipeline changes is restricted in exactly the same way as access
    to the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how it all looks in practice by creating a `Jenkinsfile` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Jenkins file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can create the `Jenkinsfile` file and push it into our GitHub repository.
    Its content is almost the same as the commit pipeline we wrote. The only difference
    is that the checkout stage becomes redundant because Jenkins has to first check
    out the code (together with `Jenkinsfile`) and then read the pipeline structure
    (from `Jenkinsfile`). This is why Jenkins needs to know the repository address
    before it reads `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `Jenkinsfile` in the `root` directory of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now commit the added files and push them to the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running the pipeline from Jenkinsfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When `Jenkinsfile` is in the repository, all we have to do is to open the pipeline
    configuration and do the following in the `Pipeline` section:'
  prefs: []
  type: TYPE_NORMAL
- en: Change **Definition** from **Pipeline script** to **Pipeline script from SCM**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Git** in **SCM**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put [https://github.com/leszko/calculator.git](https://github.com/leszko/calculator.git) in **Repository
    URL**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `*/main` as **Branch Specifier**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The Jenkinsfile pipeline configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – The Jenkinsfile pipeline configuration
  prefs: []
  type: TYPE_NORMAL
- en: After saving, the build will always run from the current version of `Jenkinsfile` in
    the repository.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created the first complete commit pipeline. It can be treated
    as a minimum viable product, and actually, in many cases, this suffices as the
    continuous integration process. In the following sections, we will see what improvements
    can be done to make the commit pipeline even better.
  prefs: []
  type: TYPE_NORMAL
- en: Code-quality stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend the three classic steps of continuous integration with additional
    steps. The most popular are code coverage and static analysis. Let's look at each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think about the following scenario: you have a well-configured continuous integration
    process; however, nobody in your project writes unit tests. It passes all the
    builds, but it doesn''t mean that the code is working as expected. *What do we
    do then?* *How do we ensure that the code is tested?*'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to add a code coverage tool that runs all tests and verifies
    which parts of the code have been executed. Then, it can create a report that
    shows the untested sections. Moreover, we can make the build fail when there is
    too much untested code.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of tools available to perform the test coverage analysis; for
    Java, the most popular are JaCoCo, OpenClover, and Cobertura.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use JaCoCo and show how the coverage check works. In order to do this,
    we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add JaCoCo to the Gradle configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the code coverage stage to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, publish JaCoCo reports in Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JaCoCo to Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to run JaCoCo from Gradle, we need to add the `jacoco` plugin to the `build.gradle` file
    by inserting the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, if we want to make Gradle fail in the case of low code coverage, we can
    add the following configuration to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration sets the minimum code coverage to 20%. We can run it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command checks whether the code coverage is at least 20%. You can play
    with the minimum value to see the level at which the build fails. We can also
    generate a test coverage report using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check out the full coverage report in the `build/reports/jacoco/test/html/index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – JaCoCo code coverage report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – JaCoCo code coverage report
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add the coverage stage in our pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a code coverage stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a code coverage stage to the pipeline is as simple as the previous stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After adding this stage, if anyone commits code that is not well covered with
    tests, the build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the code coverage report
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When coverage is low and the pipeline fails, it is useful to look at the code
    coverage report and find what parts are not yet covered with tests. We can run
    Gradle locally and generate the coverage report; however, it is more convenient
    if Jenkins shows the report for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to publish the code coverage report in Jenkins, we require the following
    stage definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This stage copies the generated JaCoCo report to the Jenkins output. When we
    run the build again, we should see a link to the code coverage reports (in the
    menu on the left-hand side, below **Build Now**).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the `publishHTML` step, you need to have the HTML Publisher plugin
    installed in Jenkins. You can read more about the plugin at [https://www.jenkins.io/doc/pipeline/steps/htmlpublisher/](https://www.jenkins.io/doc/pipeline/steps/htmlpublisher/).
    Note also that if the report is generated but not displayed properly in Jenkins,
    you may need to configure Jenkins Security, as described here: [https://www.jenkins.io/doc/book/security/configuring-content-security-policy/](https://www.jenkins.io/doc/book/security/configuring-content-security-policy/).'
  prefs: []
  type: TYPE_NORMAL
- en: We have created the code coverage stage, which shows the code that is not tested
    and therefore vulnerable to bugs. Let's see what else can be done in order to
    improve the code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you need code coverage that is stricter, you can check the concept of mutation
    testing and add the PIT framework stage to the pipeline. Read more at [http://pitest.org/](http://pitest.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your code coverage may work perfectly fine; however, *what about the quality
    of the code itself?* *How do we ensure it is maintainable and written in a good
    style?*
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is an automatic process of checking code without actually
    executing it. In most cases, it implies checking a number of rules on the source
    code. These rules may apply to a wide range of aspects; for example, all public
    classes need to have a Javadoc comment, the maximum length of a line is 120 characters,
    or if a class defines the `equals()` method, it has to define the `hashCode()` method
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular tools to perform static analysis on Java code are Checkstyle,
    FindBugs, and PMD. Let''s look at an example and add the static code analysis
    stage using Checkstyle. We will do this in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Checkstyle configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the Checkstyle stage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, publishing the Checkstyle report in Jenkins
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will walk through each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Checkstyle configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to add the Checkstyle configuration, we need to define the rules against
    which the code is checked. We can do this by specifying the `config/checkstyle/checkstyle.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The configuration contains only one rule – checking whether all Java constants
    follow the naming convention and consist of uppercase characters only.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The complete Checkstyle description can be found at [https://checkstyle.sourceforge.io/config.html](https://checkstyle.sourceforge.io/config.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add the `checkstyle` plugin to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run `checkstyle` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our project, this command should complete successfully because
    we didn''t use any constants so far. However, you can try adding a constant with
    the wrong name and checking whether the build fails. For example, if you add the
    following constant to the `src/main/java/com/leszko/calculator/CalculatorApplication.java` file,
    `checkstyle` fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adding a Static code analysis stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add a `Static code analysis` stage to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, if anyone commits any code that does not follow the Java constant naming
    convention, the build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing static code analysis reports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Very similar to JaCoCo, we can add the Checkstyle report to Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This generates a link to the Checkstyle report.
  prefs: []
  type: TYPE_NORMAL
- en: We have now added the static code analysis stage, which can help to find bugs
    and standardize the code style inside a team or organization.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see one more option we have when it comes to implementing code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SonarQube is the most widespread source code quality management tool. It supports multiple
    programming languages and can be treated as an alternative to the code coverage
    and static code analysis steps we looked at. Actually, it is a separate server
    that aggregates different code analysis frameworks, such as Checkstyle, FindBugs,
    and JaCoCo. It has its own dashboards and integrates well with Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adding code quality steps to the pipeline, we can install SonarQube,
    add plugins there, and add a *sonar* stage to the pipeline. The advantage of this
    solution is that SonarQube provides a user-friendly web interface to configure
    rules and show code vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about SonarQube on its official page at [https://www.sonarqube.org/](https://www.sonarqube.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the code quality stages, let's focus on triggers and
    notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers and notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have always built the pipeline manually by clicking on the **Build
    Now** button. It works completely fine but may not be very convenient in practice.
    All team members would have to remember that after committing to the repository,
    they need to open Jenkins and start the build. The same applies to pipeline monitoring;
    so far, we have manually opened Jenkins and checked the build status. In this
    section, we will see how to improve the process so that the pipeline will start
    automatically and, when completed, notify team members regarding its status.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An automatic action to start the build is called the pipeline trigger. In Jenkins,
    there are many options to choose from; however, they all boil down to three types:'
  prefs: []
  type: TYPE_NORMAL
- en: External
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling **Source Control Management** (**SCM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A scheduled build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: External
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External triggers are easy to understand. They mean that Jenkins starts the
    build after it's called by the **notifier**, which can be the other pipeline build,
    the SCM system (for example, GitHub), or any remote script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram presents the communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – An external trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – An external trigger
  prefs: []
  type: TYPE_NORMAL
- en: GitHub triggers Jenkins after a push to the repository and the build is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the system this way, we need the following setup steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the GitHub plugin in Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a secret key for Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the GitHub webhook and specify the Jenkins address and key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of the most popular SCM providers, dedicated Jenkins plugins are
    always provided.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a more generic way to trigger Jenkins via the REST call to the `<jenkins_url>/job/<job_name>/build?token=<token>` endpoint.
    For security reasons, it requires setting `token` in Jenkins and then using it
    in the remote script.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins must be accessible from the SCM server. In other words, if we use the
    public GitHub repository to trigger Jenkins, our Jenkins server must be public
    as well. This also applies to the REST call solution, in which case, the `<jenkins_url>` address
    must be accessible from the script that triggers it.
  prefs: []
  type: TYPE_NORMAL
- en: Polling SCM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Polling the SCM trigger is a little less intuitive. The following diagram presents
    the communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Polling the SCM trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Polling the SCM trigger
  prefs: []
  type: TYPE_NORMAL
- en: 'Jenkins periodically calls GitHub and checks whether there was any push to
    the repository. Then, it starts the build. It may sound counter-intuitive, but
    there are at least two good cases for using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is inside the firewalled network (which GitHub does not have access
    to).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commits are frequent and the build takes a long time, so executing a build after
    every commit would cause an overload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration of `pollSCM` is also somehow simpler because the way to connect
    from Jenkins to GitHub is already set up (Jenkins checks out the code from GitHub,
    so it knows how to access it). In the case of our calculator project, we can set
    up an automatic trigger by adding the `triggers` declaration (just after `agent`)
    to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After running the pipeline manually for the first time, the automatic trigger
    is set. Then, it checks GitHub every minute, and for new commits, it starts a
    build. To test that it works as expected, you can commit and push anything to
    the GitHub repository and see that the build starts.
  prefs: []
  type: TYPE_NORMAL
- en: We used the mysterious `* * * * *` as an argument to `pollSCM`. It specifies
    how often Jenkins should check for new source changes and is expressed in the `cron`-style
    string format.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The `cron` string format is described (together with the cron tool) at [https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron).
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scheduled trigger means that Jenkins runs the build periodically, regardless
    of whether there were any commits to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the following screenshot shows, no communication with any system is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The scheduled build trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – The scheduled build trigger
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `cron` keyword is used instead of `pollSCM`. This trigger
    method is rarely used for the commit pipeline but applies well to nightly builds
    (for example, complex integration testing executed at night).
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jenkins provides a lot of ways to announce its build status. What's more, as
    with everything in Jenkins, new notification types can be added using plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through the most popular types so that you can choose the one that
    fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most classic way to notify users about the Jenkins build status is to send
    emails. The advantage of this solution is that everybody has a mailbox, everybody knows how
    to use it, and everybody is used to receiving information in it. The drawback
    is that, usually, there are simply too many emails, and the ones from Jenkins
    quickly become filtered out and never read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the email notification is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Have the **SMTP** (**Simple Mail Transfer Protocol**) server configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its details in Jenkins (in **Manage Jenkins** | **Configure System**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `mail to` instruction in the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The pipeline configuration can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all notifications are usually called in the `post` section of the
    pipeline, which is executed after all steps, no matter whether the build succeeded
    or failed. We used the `always` keyword; however, there are different options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`always`: Execute regardless of the completion status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changed`: Execute only if the pipeline changed its status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed`: Execute only if the pipeline changed its status from failed to success.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regression`: Execute only if the pipeline changed its status from success
    to failed, unstable, or aborted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aborted`: Execute only if the pipeline was manually aborted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failure`: Execute only if the pipeline has the `failed` status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success`: Execute only if the pipeline has the `success` status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unstable`: Execute only if the pipeline has the `unstable` status (usually
    caused by test failures or code violations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsuccessful`: Execute only if the pipeline has any status other than `success`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group chats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a group chat (for example, Slack) is the first method of communication in
    your team, it''s worth considering adding the automatic build notifications there.
    No matter which tool you use, the procedure to configure it is always the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Find and install the plugin for your group chat tool (for example, the **Slack
    Notification** plugin).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the plugin (the server URL, channel, authorization token, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the sending instruction to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see a sample pipeline configuration for Slack to send notifications
    after the build fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Team spaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Together with the agile culture came the idea that it's better to have everything
    happening in a team space. Instead of writing emails, meet together; instead of
    online messaging, come and talk; instead of task tracking tools, have a whiteboard.
    The same idea came to continuous delivery and Jenkins. Currently, it's very common
    to install big screens (also called **build radiators**) in the team space. Then,
    when you come to the office, the first thing you see is the current status of
    the pipeline. Build radiators are considered one of the most effective notification
    strategies. They ensure that everyone is aware of failing builds and, as a beneficial
    side effect, they boost team spirit and favor in-person communication.
  prefs: []
  type: TYPE_NORMAL
- en: Since developers are creative beings, they invented a lot of other ideas that
    play the same role as the radiators. Some teams hang large speakers that beep
    when the pipeline fails. Others have toys that blink when the build is done. One
    of my favorites is Pipeline State UFO, which is provided as an open source project
    on GitHub. On its page, you can find a description of how to print and configure
    a UFO that hangs off the ceiling and signals the pipeline state. You can find
    more information at [https://github.com/Dynatrace/ufo](https://github.com/Dynatrace/ufo).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Since Jenkins is extensible by plugins, its community wrote a lot of different
    ways to inform users about the build statuses. Among them, you can find RSS feeds,
    SMS notifications, mobile applications, and desktop notifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered triggers and notifications, let's focus on one more
    important aspect – team development strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Team development strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered everything regarding how the continuous integration pipeline
    should look. However, *when exactly should it be run?* Of course, it is triggered
    after the commit to the repository, but *after the commit to which branch?* *Only
    to the trunk or to every branch?* Or, *maybe it should run before, not after,
    committing so that the repository will always be healthy?* Or, *how about the
    crazy idea of having no branches at all?*
  prefs: []
  type: TYPE_NORMAL
- en: There is no single best answer to these questions. Actually, the way you use
    the continuous integration process depends on your team development workflow.
    So, before we go any further, let's describe the possible workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Development workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A development workflow is the way your team puts code into the repository. It
    depends, of course, on many factors, such as the SCM tool, the project specifics,
    and the team size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, each team develops the code in a slightly different manner. We
    can, however, classify them into three types: a **trunk-based workflow**, a **branching
    workflow**, and a **forking workflow**.'
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: All workflows are described in detail, with examples, at [https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows).
  prefs: []
  type: TYPE_NORMAL
- en: The trunk-based workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The trunk-based workflow is the simplest possible strategy. It is presented in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The trunk-based workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – The trunk-based workflow
  prefs: []
  type: TYPE_NORMAL
- en: There is one central repository with a single entry for all changes to the project,
    which is called the **trunk** or **master**. Every member of the team clones the
    central repository to have their own local copies. The changes are committed directly
    to the central repository.
  prefs: []
  type: TYPE_NORMAL
- en: The branching workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The branching workflow, as its name suggests, means that the code is kept in
    many different branches. The idea is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The branching workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – The branching workflow
  prefs: []
  type: TYPE_NORMAL
- en: When developers start to work on a new feature, they create a dedicated branch
    from the trunk and commit all feature-related changes there. This makes it easy
    for multiple developers to work on a feature without breaking the main code base.
    This is why, in the case of the branching workflow, there is no problem in keeping
    the master healthy. When the feature is completed, a developer rebases the feature
    branch from the master and creates a pull request that contains all feature-related
    code changes. It opens the code review discussions and makes space to check whether
    the changes disturb the master. When the code is accepted by other developers
    and automatic system checks, it is merged into the main code base. The build is
    run again on the master but should almost never fail, since it didn't fail on
    the branch.
  prefs: []
  type: TYPE_NORMAL
- en: The forking workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The forking workflow is very popular among open source communities. It is presented in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The forking workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – The forking workflow
  prefs: []
  type: TYPE_NORMAL
- en: Each developer has their own server-side repository. It may or may not be the
    official repository, but technically, each repository is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forking** means literally creating a new repository from another repository.
    Developers push to their own repositories, and when they want to integrate code,
    they create a pull request to the other repository.'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of the forking workflow is that the integration is not necessarily
    via a central repository. It also helps with ownership because it allows the acceptance
    of pull requests from others without giving them write access.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of requirement-oriented commercial projects, a team usually works
    on one product and therefore has a central repository, so this model boils down
    to having a branching workflow with good ownership assignment; for example, only
    project leads can merge pull requests into the central repository.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have described different development workflows, but *how do they influence
    the continuous integration configuration?*
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each development workflow implies a different continuous integration approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trunk-based workflow**: This implies constantly struggling against the broken
    pipeline. If everyone commits to the main code base, the pipeline often fails.
    In this case, the old continuous integration rule says, *If the build is broken,
    the development team stops whatever they are doing and fixes the problem immediately*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branching workflow**: This solves the broken trunk issue but introduces another
    one: if everyone develops in their own branches, *where is the integration?* A
    feature usually takes weeks or months to develop, and for all this time, the branch
    is not integrated into the main code. Therefore, it cannot really be called continuous
    integration – not to mention that there is a constant need for merging and resolving
    conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forking workflow**: This implies managing the continuous integration process
    by every repository owner, which isn''t usually a problem. It does share, however,
    the same issues as the branching workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no silver bullet, and different organizations choose different strategies.
    The solution that is the closest to perfection uses the technique of the branching
    workflow and the philosophy of the trunk-based workflow. In other words, we can
    create very small branches and integrate them frequently into the master. This
    seems to take the best aspects of both. However, it requires either having tiny
    features or using feature toggles. Since the concept of feature toggles fits very
    well into continuous integration and continuous delivery, let's take a moment
    to explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feature toggles is a technique that is an alternative to maintaining multiple
    source code branches, such that the feature can be tested before it is completed
    and ready for release. It is used to disable the feature for users but enable
    it for developers while testing. Feature toggles are essentially variables used
    in conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest implementation of feature toggles are flags and the `if` statements.
    A development using feature toggles, as opposed to a feature branching development,
    appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new feature has to be implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new flag or a configuration property – `feature_toggle` (instead of
    the `feature` branch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All feature-related code is added inside the `if` statement (instead of committing
    to the `feature` branch), such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'During the feature development, the following takes place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coding is done in the master with `feature_toggle = true` (instead of coding
    in the feature branch).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The release is done from the master with `feature_toggle = false`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the feature development is completed, all `if` statements are removed and `feature_toggle` is
    removed from the configuration (instead of merging `feature` to the master and
    removing the `feature` branch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The benefit of feature toggles is that all development is done in the trunk,
    which facilitates real continuous integration and mitigates problems with merging
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins multi-branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you decide to use branches in any form, either the long-feature branches or
    the recommended short-lived branches, it is convenient to know that the code is
    healthy before merging it into the master. This approach results in always keeping
    the main code base green, and luckily, there is an easy way to do it with Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use multi-branch in our calculator project, let''s proceed with
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the main Jenkins page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `calculator-branches` as the item name, select **Multibranch Pipeline**,
    and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Branch Sources** section, click on **Add source**, and select **Git**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the repository address in the **Project Repository** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – The multi-branch pipeline configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – The multi-branch pipeline configuration
  prefs: []
  type: TYPE_NORMAL
- en: Tick **Periodically if not otherwise run** and set **1 minute** as the interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every minute, this configuration checks whether there were any branches added
    (or removed) and creates (or deletes) the dedicated pipeline defined by `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new branch and see how it works. Let''s create a new branch
    called `feature` and push it into the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After a moment, you should see a new branch pipeline automatically created
    and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – The multi-branch pipeline build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – The multi-branch pipeline build
  prefs: []
  type: TYPE_NORMAL
- en: Now, before merging the feature branch to the master, we can check whether it's
    green. This approach should never break the master build.
  prefs: []
  type: TYPE_NORMAL
- en: A very similar approach is to build a pipeline per pull request instead of a
    pipeline per branch, which gives the same result – the main code base is always
    healthy.
  prefs: []
  type: TYPE_NORMAL
- en: Non-technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last but not least, continuous integration is not all about technology. On the
    contrary, technology comes second. James Shore, in his *Continuous Integration
    on a Dollar a Day* article, described how to set up the continuous integration
    process without any additional software. All he used was a rubber chicken and
    a bell. The idea is to make the team work in one room and set up a separate computer
    with an empty chair. Put the rubber chicken and the bell in front of that computer.
    Now, when you plan to check in the code, take the rubber chicken, check in the
    code, go to the empty computer, check out the fresh code, run all tests there,
    and if everything passes, put back the rubber chicken, and ring the bell so that
    everyone knows that something has been added to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous Integration on a Dollar a Day* by *James Shore* can be found at [http://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day](http://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is a little oversimplified, and automated tools are useful; however,
    the main message is that without each team member''s engagement, even the best
    tools won''t help. In his book, Jez Humble outlines the prerequisites for continuous
    integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check in regularly**: To quote Mike Roberts, *continuously is more often
    than you think*; the minimum is once a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create comprehensive unit tests**: It''s not only about high test coverage;
    it''s possible to have no assertions and still keep 100% coverage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep the process quick**: Continuous integration must take a short time,
    preferably under 5 minutes. 10 minutes is already a lot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor the builds**: This can be a shared responsibility, or you can adapt
    the **build master** role that rotates weekly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered all aspects of the continuous integration pipeline,
    which is always the first step for continuous delivery. Here are the key takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline provides a general mechanism for organizing any automation processes;
    however, the most common use cases are continuous integration and continuous delivery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins accepts different ways of defining pipelines, but the recommended one
    is the declarative syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commit pipeline is the most basic continuous integration process, and as
    its name suggests, it should be run after every commit to the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipeline definition should be stored in the repository as a `Jenkinsfile`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commit pipeline can be extended with the code quality stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter what the project build tool, Jenkins commands should always be consistent
    with local development commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins offers a wide range of triggers and notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development workflow should be carefully chosen inside a team or organization
    because it affects the continuous integration process and defines the way code
    is developed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the next phase of the continuous delivery
    process – automated acceptance testing. This can be considered the most important
    and, in many cases, the most difficult step to implement. We will explore the
    idea of acceptance testing and a sample implementation using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve learned a lot about how to configure the continuous integration process.
    Since *practice makes perfect*, I recommend doing the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python program that multiplies two numbers passed as command-line
    parameters. Add unit tests and publish the project on GitHub:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create two files: `calculator.py` and `test_calculator.py`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the `unittest` library at [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the program and the unit test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the continuous integration pipeline for the Python calculator project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Jenkinsfile` to specify the pipeline.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the trigger so that the pipeline runs automatically in case of any
    commits to the repository.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The pipeline doesn't need the `Compile` step since Python is an interpretable
    language.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the pipeline and observe the results.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to commit the code that breaks the pipeline build and observe how it is
    visualized in Jenkins.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify the knowledge acquired from this chapter, please answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a *stage* and a *step* in the pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `post` section in the Jenkins pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three most fundamental stages of the commit pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Jenkinsfile`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the code coverage stage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the following Jenkins triggers – external and
    polling SCM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most common Jenkins notification methods? Name at least three.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three most common development workflows?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a feature toggle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read more about the continuous integration topic, please refer to the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous Delivery*, *Jez Humble and David Farley*: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous Integration: Improving Software Quality and Reducing Risk*, *Andrew
    Glover, Steve Matyas, and Paul M. Duvall*: [https://www.oreilly.com/library/view/continuous-integration-improving/9780321336385/](https://www.oreilly.com/library/view/continuous-integration-improving/9780321336385/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
