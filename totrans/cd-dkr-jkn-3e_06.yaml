- en: '*Chapter 4*: Continuous Integration Pipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：持续集成流水线'
- en: We already know how to configure Jenkins. In this chapter, we will see how to
    use it effectively, focusing on the feature that lies at the heart of Jenkins
    – pipelines. By building a complete continuous integration process from scratch,
    we will describe all aspects of modern team-oriented code development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何配置Jenkins。在本章中，我们将看到如何有效地使用它，重点介绍Jenkins的核心特性——流水线。通过从头构建一个完整的持续集成过程，我们将描述现代团队导向的代码开发的各个方面。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括以下主题：
- en: Introducing pipelines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入流水线
- en: The commit pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交流水线
- en: Code quality stages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码质量阶段
- en: Triggers and notifications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器和通知
- en: Team development strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队开发策略
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you''ll need the following software:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章，你需要以下软件：
- en: Jenkins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: Java JDK 8+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java JDK 8+
- en: All the examples and solutions to the exercises can be found at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例和练习的解决方案可以在[https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter04)找到。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3r9lbmG](https://bit.ly/3r9lbmG).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码演示视频可以在[https://bit.ly/3r9lbmG](https://bit.ly/3r9lbmG)观看。
- en: Introducing pipelines
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入流水线
- en: 'A **pipeline** is a sequence of automated operations that usually represents
    a part of the software delivery and quality assurance process. It can be seen
    as a chain of scripts that provide the following additional benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**流水线**是由一系列自动化操作组成的，通常表示软件交付和质量保证过程的一部分。它可以看作是一个脚本链，提供以下额外的好处：'
- en: '**Operation grouping**: Operations are grouped together into stages (also known
    as **gates** or **quality gates**) that introduce a structure into a process and
    clearly define a rule – if one stage fails, no further stages are executed.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作分组**：操作被分组为阶段（也称为**关卡**或**质量关卡**），这些阶段为流程引入了结构，并清晰地定义了规则——如果一个阶段失败，则后续阶段不会执行。'
- en: '**Visibility**: All aspects of a process are visualized, which helps in quick
    failure analysis and promotes team collaboration.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视性**：流程的所有方面都会被可视化，这有助于快速分析故障并促进团队协作。'
- en: '**Feedback**: Team members learn about problems as soon as they occur so that
    they can react quickly.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈**：团队成员会在问题发生时立即了解到，以便快速做出反应。'
- en: Information
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: The concept of pipelining is similar to most continuous integration tools. However,
    the naming can differ. In this book, we will stick to the Jenkins terminology.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流水线的概念类似于大多数持续集成工具。然而，命名可能会有所不同。在本书中，我们将坚持使用Jenkins的术语。
- en: Let's first describe the Jenkins pipeline structure and then how it works in
    action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们描述Jenkins流水线结构，然后说明它是如何在实际中运作的。
- en: The pipeline structure
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线结构
- en: 'A Jenkins pipeline consists of two kinds of elements – a **stage** and a **step**.
    The following diagram shows how they are used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Jenkins流水线由两种元素组成——**阶段**和**步骤**。下图展示了它们的使用方式：
- en: '![Figure 4.1 – The Jenkins pipeline structure'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – Jenkins流水线结构'
- en: '](img/B18223_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_01.jpg)'
- en: Figure 4.1 – The Jenkins pipeline structure
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – Jenkins流水线结构
- en: 'The following are the basic pipeline elements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基本的流水线元素：
- en: '**Step**: A single operation that tells Jenkins what to do – for example, check
    out code from the repository and execute a script'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：告诉Jenkins需要做什么的单一操作——例如，从仓库中检出代码并执行脚本'
- en: '**Stage**: A logical separation of steps that groups conceptually distinct sequences of
    steps – for example, **build**, **test**, and **deploy**, used to visualize the
    Jenkins pipeline progress'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段**：将步骤进行逻辑分隔，将概念上不同的步骤序列分组——例如，**构建**、**测试**和**部署**，用于可视化Jenkins流水线的进度'
- en: Information
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: Technically, it's possible to create parallel steps; however, it's better to
    treat them as an exception that is only used for optimization purposes.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从技术上讲，可以创建并行步骤；然而，最好将其视为仅用于优化目的的例外情况。
- en: A multi-stage Hello World
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多阶段的Hello World
- en: 'As an example, let''s extend the `Hello World` pipeline to contain two stages:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将扩展`Hello World`流水线，加入两个阶段：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The pipeline has no special requirements in terms of environment, and it executes
    three steps inside two stages. When we click on **Build Now**, we should see a
    visual representation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道在环境方面没有特殊要求，并且在两个阶段内执行了三个步骤。当我们点击**立即构建**时，我们应该看到一个可视化表示：
- en: '![Figure 4.2 – The multi-stage pipeline build'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 多阶段管道构建'
- en: '](img/B18223_04_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_02.jpg)'
- en: Figure 4.2 – The multi-stage pipeline build
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 多阶段管道构建
- en: The pipeline succeeded, and we can see the step execution details by clicking on
    the console. If any of the steps failed, processing would stop, and no further
    steps would run. Actually, the sole reason for a pipeline is to prevent all further
    steps from execution and visualize the point of failure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 管道执行成功，我们可以通过点击控制台查看步骤执行的详细信息。如果任何步骤失败，处理将停止，后续步骤将不再执行。实际上，管道的唯一目的是防止后续步骤执行，并可视化失败的发生点。
- en: The pipeline syntax
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道语法
- en: We've discussed the pipeline elements and already used a few of the pipeline
    steps – for example, `echo`. *What other operations can we use inside the pipeline
    definition?*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了管道的元素，并且已经使用了几个管道步骤——例如，`echo`。*我们还能在管道定义中使用哪些其他操作？*
- en: Information
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In this book, we use the declarative syntax that is recommended for all new
    projects. The other options are a Groovy-based DSL and (prior to Jenkins 2) XML
    (created through the web interface).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的是推荐用于所有新项目的声明式语法。其他选项包括基于 Groovy 的 DSL 和（在 Jenkins 2 之前的版本）XML（通过 Web
    界面创建）。
- en: The declarative syntax was designed to make it as simple as possible to understand
    the pipeline, even by people who do not write code on a daily basis. This is why
    the syntax is limited only to the most important keywords.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式语法的设计目的是使理解管道尽可能简单，即使是那些并非每天编写代码的人。这也是为什么语法仅限于最重要的关键字。
- en: 'Let''s try an experiment, but before we describe all the details, please read
    the following pipeline definition and try to guess what it does:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个实验，但在描述所有细节之前，请阅读以下管道定义并尝试猜测它的作用：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Hopefully, the pipeline didn''t scare you. It is quite complex. Actually, it
    is so complex that it contains most available Jenkins instructions. To answer
    the experiment puzzle, let''s see what the pipeline does instruction by instruction:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 希望管道没有吓到你。它确实很复杂。实际上，它复杂到包含了大多数可用的 Jenkins 指令。为了回答实验谜题，让我们逐条查看管道指令的执行过程：
- en: Uses any available agent
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何可用的代理
- en: Executes automatically every minute
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每分钟自动执行
- en: Stops if the execution takes more than 5 minutes
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果执行时间超过 5 分钟，则停止执行
- en: Asks for the Boolean input parameter before starting
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前请求布尔类型输入参数
- en: Sets `Rafal` as the `NAME` environment variable
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Rafal`设置为`NAME`环境变量
- en: 'Does the following, only in the case of the `true` input parameter:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在`true`输入参数的情况下执行以下操作：
- en: Prints `Hello from Rafal`
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`来自 Rafal 的问候`
- en: Prints `Testing the chrome browser`
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`测试 Chrome 浏览器`
- en: Prints `Testing the firefox browser`
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`测试 Firefox 浏览器`
- en: Prints `I will always say Hello again!`, regardless of whether there are any
    errors during the execution
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`我将永远再次说你好！`，无论执行过程中是否有任何错误
- en: Now, let's describe the most important Jenkins keywords. A declarative pipeline
    is always specified inside the `pipeline` block and contains sections, directives,
    and steps. We will walk through each of them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述最重要的 Jenkins 关键字。声明式管道始终在`pipeline`块内指定，并包含部分、指令和步骤。我们将逐一讲解它们。
- en: Information
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The complete pipeline syntax description can be found on the official Jenkins
    page at [https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的管道语法描述可以在官方 Jenkins 页面上找到，地址为 [https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/)。
- en: Sections
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分
- en: 'Sections define the pipeline structure and usually contain one or more directives
    or steps. They are defined with the following keywords:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 部分定义了管道的结构，通常包含一个或多个指令或步骤。它们使用以下关键字定义：
- en: '**Stages**: This defines a series of one or more stage directives.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段**：这定义了一系列一个或多个阶段指令。'
- en: '**Steps**: This defines a series of one or more step instructions.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：这定义了一系列一个或多个步骤指令。'
- en: '**Post**: This defines a series of one or more step instructions that are run
    at the end of the pipeline build; they are marked with a condition (for example,
    always, success, or failure) and are usually used to send notifications after
    the pipeline build (we will cover this in detail in the *Triggers and notifications* section).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Post**：这定义了一系列在管道构建结束时运行的步骤指令；它们带有一个条件（例如，总是、成功或失败），通常用于在管道构建后发送通知（我们将在 *触发器和通知*
    部分详细讲解）。'
- en: '`label` to match the equally labeled agents, or `docker` to specify a container
    that is dynamically provisioned to provide an environment for the pipeline execution.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label` 用于匹配具有相同标签的代理，或者 `docker` 用于指定动态提供的容器，以为管道执行提供环境。'
- en: Directives
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令
- en: 'Directives express the configuration of a pipeline or its parts:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 指令表达了管道或其部分的配置：
- en: '`cron` to set the time-based scheduling, or `pollSCM` to check the repository
    for changes (we will cover this in detail in the *Triggers and notifications* section).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cron` 用于设置基于时间的调度，或者 `pollSCM` 用于检查仓库中的更改（我们将在 *触发器和通知* 部分详细讲解此内容）。'
- en: '`timeout` (the maximum time of a pipeline run) or `retry` (the number of times
    the pipeline should be rerun after failure).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`（管道运行的最大时间）或 `retry`（在失败后管道应重新运行的次数）。'
- en: '**Environment**: This defines a set of key values used as environment variables
    during the build.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Environment**：这定义了一组作为构建过程中环境变量使用的键值。'
- en: '**Parameters**: This defines a list of user-input parameters.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parameters**：这定义了一个用户输入参数的列表。'
- en: '**Stage**: This allows for the logical grouping of steps.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stage**：这允许对步骤进行逻辑分组。'
- en: '**When**: This determines whether the stage should be executed, depending on
    the given condition.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**When**：这决定了是否应该执行该阶段，取决于给定的条件。'
- en: '`PATH`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`。'
- en: '**Input**: This allows us to prompt the input parameters.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Input**：这允许我们提示输入参数。'
- en: '**Parallel**: This allows us to specify stages that are run in parallel.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parallel**：这允许我们指定并行运行的阶段。'
- en: '**Matrix**: This allows us to specify combinations of parameters for which
    the given stages run in parallel.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matrix**：这允许我们指定一组参数组合，以便在并行中运行给定的阶段。'
- en: Steps
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤
- en: 'Steps are the most fundamental part of the pipeline. They define the operations
    that are executed, so they actually tell Jenkins *what to do*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤是管道中最基本的部分。它们定义了要执行的操作，因此实际上告诉 Jenkins *做什么*：
- en: '`sh`: This executes the shell command; actually, it''s possible to define almost
    any operation using `sh`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sh`：这执行 Shell 命令；实际上，几乎可以使用 `sh` 定义任何操作。'
- en: '`custom`: Jenkins offers a lot of operations that can be used as steps (for
    example, `echo`); many of them are simply wrappers over the `sh` command used
    for convenience. Plugins can also define their own operations.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`custom`：Jenkins 提供了许多可以用作步骤的操作（例如，`echo`）；其中许多只是 `sh` 命令的包装器，旨在便捷操作。插件也可以定义自己的操作。'
- en: '`script`: This executes a block of Groovy-based code that can be used for some
    non-trivial scenarios where flow control is needed.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`：这执行一块基于 Groovy 的代码，可用于一些需要流程控制的复杂场景。'
- en: Information
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: The complete specification of the available steps can be found at [https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/).
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可用步骤的完整规范可以在 [https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/)找到。
- en: Note that the pipeline syntax is very generic and, technically, can be used
    for almost any automation process. This is why the pipeline should be treated
    as a method of structuing and visualization. However, the most common use case
    is to implement the continuous integration server, which we will look at in the
    following section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，管道语法非常通用，从技术上讲，可以用于几乎任何自动化过程。这就是为什么管道应被视为一种结构化和可视化的方法。然而，最常见的使用场景是实现持续集成服务器，接下来我们将详细介绍这一部分。
- en: The commit pipeline
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交管道
- en: The most basic continuous integration process is called a `commit` (or `push`
    in Git) to the main repository and results in a report about the build success
    or failure. Since it runs after each change in the code, the build should take
    no more than 5 minutes and should consume a reasonable amount of resources. The
    commit phase is always the starting point of the continuous delivery process and
    provides the most important feedback cycle in the development process – constant
    information if the code is in a healthy state.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的持续集成过程被称为`commit`（或在Git中称为`push`）到主代码库，并生成关于构建成功或失败的报告。由于它在每次代码更改后运行，构建应不超过5分钟，并且应消耗合理的资源。提交阶段始终是持续交付过程的起点，并且提供了开发过程中最重要的反馈循环——如果代码处于健康状态，能够不断获得信息。
- en: 'The commit phase works as follows: a developer checks in the code to the repository,
    the continuous integration server detects the change, and the build starts. The
    most fundamental commit pipeline contains three stages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提交阶段的工作原理如下：开发者将代码提交到仓库，持续集成服务器检测到变更并启动构建。最基本的提交管道包含三个阶段：
- en: '**Checkout**: This stage downloads the source code from the repository.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检出**：此阶段从仓库下载源代码。'
- en: '**Compile**: This stage compiles the source code.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译**：此阶段编译源代码。'
- en: '**Unit test**: This stage runs a suite of unit tests.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：此阶段运行一套单元测试。'
- en: Let's create a sample project and see how to implement the commit pipeline.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例项目，看看如何实现提交管道。
- en: Information
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: This is an example of a pipeline for a project that uses technologies such as
    Git, Java, Gradle, and Spring Boot. Nevertheless, the same principles apply to
    any other technology.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Git、Java、Gradle和Spring Boot等技术的项目管道示例。然而，相同的原则适用于任何其他技术。
- en: Checkout
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检出
- en: Checking out code from the repository is always the first operation in any pipeline.
    In order to see this, we need to have a repository. Then, we are able to create
    a pipeline.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库检出代码始终是任何管道中的第一操作。为了看到这一点，我们需要一个仓库。然后，我们才能创建管道。
- en: Creating a GitHub repository
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个GitHub仓库
- en: 'Creating a repository on the GitHub server takes just a few steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub服务器上创建一个仓库只需几个步骤：
- en: Go to [https://github.com/](https://github.com/).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://github.com/](https://github.com/)。
- en: Create an account if you don't have one yet.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有账户，请创建一个账户。
- en: Click on **New**, next to **Repositories**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建**，在**仓库**旁边。
- en: Give it a name – `calculator`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它起个名字——`calculator`。
- en: Tick **Initialize this repository with a README**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**用README初始化此仓库**。
- en: Click on **Create repository**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建仓库**。
- en: Now, you should see the address of the repository – for example, [https://github.com/leszko/calculator.git](https://github.com/leszko/calculator.git).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能看到仓库的地址——例如，[https://github.com/leszko/calculator.git](https://github.com/leszko/calculator.git)。
- en: Creating a checkout stage
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建检出阶段
- en: 'We can create a new pipeline called `calculator`, and as it is a `Checkout`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为`calculator`的新管道，并且它是一个`检出`：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The pipeline can be executed on any of the agents, and its only step does nothing
    more than download code from the repository. We can click on **Build Now** to
    see whether it was executed successfully.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道可以在任何代理上执行，其唯一的步骤只是从仓库下载代码。我们可以点击**立即构建**来查看它是否成功执行。
- en: Information
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The Git toolkit needs to be installed on the node where the build is executed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Git工具包需要安装在构建执行的节点上。
- en: When we have the checkout, we're ready for the second stage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成检出后，我们就准备好进入第二阶段。
- en: Compile
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: 'In order to compile a project, we need to do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译一个项目，我们需要执行以下操作：
- en: Create a project with the source code.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含源代码的项目。
- en: Push it to the repository.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其推送到仓库。
- en: Add the `Compile` stage to the pipeline.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`编译`阶段添加到管道中。
- en: Let's look at these steps in detail.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这些步骤。
- en: Creating a Java Spring Boot project
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个Java Spring Boot项目
- en: Let's create a very simple Java project using the Spring Boot framework built
    by Gradle.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用由Gradle构建的Spring Boot框架创建一个非常简单的Java项目。
- en: Information
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Spring Boot is a Java framework that simplifies building enterprise applications.
    Gradle is a build automation system that is based on the concepts of Apache Maven.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是一个简化企业应用构建的Java框架。Gradle是一个基于Apache Maven概念的构建自动化系统。
- en: 'The simplest way to create a Spring Boot project is to perform the following
    steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Spring Boot项目的最简单方法是执行以下步骤：
- en: Go to [http://start.spring.io/](http://start.spring.io/).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://start.spring.io/](http://start.spring.io/)。
- en: Select **Gradle Project** instead of **Maven Project** (you can choose Maven
    if you prefer it to Gradle).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Gradle Project** 而不是 **Maven Project**（如果你更喜欢 Maven 而不是 Gradle，可以选择 Maven）。
- en: Fill `com.leszko` and `calculator`).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写 `com.leszko` 和 `calculator`。
- en: Add **Web** to **Dependencies**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Web** 添加到 **Dependencies**。
- en: Click on **Generate**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Generate**。
- en: The generated skeleton project should be downloaded (the `calculator.zip` file).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的骨架项目应该已下载（`calculator.zip` 文件）。
- en: 'The following screenshot shows the [http://start.spring.io/](http://start.spring.io/) page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 [http://start.spring.io/](http://start.spring.io/) 页面：
- en: '![Figure 4.3 – spring initializr'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.3 – spring initializr](img/B18223_04_03.jpg)'
- en: '](img/B18223_04_03.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.3 – spring initializr](img/B18223_04_03.jpg)'
- en: Figure 4.3 – spring initializr
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – spring initializr
- en: After the project is created, we can push it into the GitHub repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，我们可以将其推送到 GitHub 仓库。
- en: Pushing code to GitHub
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码推送到 GitHub
- en: We will use the Git tool to perform the `commit` and `push` operations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Git 工具执行 `commit` 和 `push` 操作。
- en: Information
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In order to run the `git` command, you need to have the Git toolkit installed
    (it can be downloaded from [https://git-scm.com/downloads](https://git-scm.com/downloads)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行 `git` 命令，你需要安装 Git 工具包（可以从 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    下载）。
- en: 'Let''s first clone the repository to the filesystem:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们将仓库克隆到文件系统：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Extract the project downloaded from [http://start.spring.io/](http://start.spring.io/) into
    the directory created by Git.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将从 [http://start.spring.io/](http://start.spring.io/) 下载的项目解压到 Git 创建的目录中。
- en: Tip
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you prefer, you can import the project into IntelliJ, Visual Studio Code,
    Eclipse, or your favorite IDE tool.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，你可以将项目导入到 IntelliJ、Visual Studio Code、Eclipse 或你最喜欢的 IDE 工具中。
- en: 'As a result, the `calculator` directory should have the following files:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，`calculator` 目录应该包含以下文件：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Information
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In order to perform the Gradle operations locally, you need to have the Java
    JDK installed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地执行 Gradle 操作，你需要安装 Java JDK。
- en: 'We can compile the project locally using the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码在本地编译项目：
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the case of Maven, you can run `./mvnw compile`. Both Gradle and Maven compile
    the Java classes located in the `src` directory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Maven，你可以运行 `./mvnw compile`。Gradle 和 Maven 都会编译位于 `src` 目录中的 Java 类。
- en: 'Now, we can commit and push to the GitHub repository:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以提交并推送到 GitHub 仓库：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code is already in the GitHub repository. If you want to check it, you can
    go to the GitHub page and see the files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经在 GitHub 仓库中了。如果你想检查它，可以访问 GitHub 页面查看文件。
- en: Creating a Compile stage
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个编译阶段
- en: 'We can add a `Compile` stage to the pipeline using the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码将 `Compile` 阶段添加到流水线中：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we used exactly the same command locally and in the Jenkins pipeline,
    which is a very good sign because the local development process is consistent
    with the continuous integration environment. After running the build, you should
    see two green boxes. You can also check that the project was compiled correctly
    in the console log.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在本地和 Jenkins 流水线中使用的命令完全相同，这是一个非常好的迹象，因为本地开发过程与持续集成环境一致。运行构建后，你应该看到两个绿色的框。你也可以在控制台日志中检查项目是否正确编译。
- en: Unit tests
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'It''s time to add the last stage, which is the unit test; it checks whether
    our code does what we expect it to do. We have to do the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是添加最后阶段的时候了，那就是单元测试；它检查我们的代码是否按预期执行。我们需要做以下操作：
- en: Add the source code for the calculator logic.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加计算器逻辑的源代码。
- en: Write a unit test for the code.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为代码编写单元测试。
- en: Add a Jenkins stage to execute the unit test.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 Jenkins 阶段来执行单元测试。
- en: Let's elaborate more on these steps next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将详细讲解这些步骤。
- en: Creating business logic
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建业务逻辑
- en: 'The first version of the calculator will be able to add two numbers. Let''s
    add the business logic as a class in the `src/main/java/com/leszko/calculator/Calculator.java` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的第一个版本将能够执行两个数字的加法。让我们在 `src/main/java/com/leszko/calculator/Calculator.java`
    文件中添加业务逻辑作为一个类：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To execute the business logic, we also need to add the web service controller
    in a separate file: `src/main/java/com/leszko/calculator/CalculatorController.java`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行业务逻辑，我们还需要在一个单独的文件中添加 Web 服务控制器：`src/main/java/com/leszko/calculator/CalculatorController.java`：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This class exposes business logic as a web service. We can run the application
    and see how it works:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将业务逻辑暴露为 Web 服务。我们可以运行应用程序，看看它是如何工作的：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This should start our web service, and we can check that it works by navigating
    to the browser and opening `http://localhost:8080/sum?a=1&b=2`. This should sum
    two numbers (`1` and `2`) and show `3` in the browser.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该启动我们的 Web 服务，我们可以通过在浏览器中打开 `http://localhost:8080/sum?a=1&b=2` 来检查它是否正常工作。这个链接应该将两个数字（`1`
    和 `2`）相加并在浏览器中显示 `3`。
- en: Writing a unit test
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: We already have the working application. *How can we ensure that the logic works
    as expected?* We tried it once, but in order to know that it will work consistently,
    we need a unit test. In our case, it will be trivial, maybe even unnecessary;
    however, in real projects, unit tests can save you from bugs and system failures.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了可工作的应用程序。*我们如何确保逻辑按预期工作？*我们尝试过一次，但为了确保它始终如一地工作，我们需要单元测试。在我们的例子中，这将是微不足道的，甚至可能是不必要的；然而，在真实项目中，单元测试可以帮助你避免错误和系统故障。
- en: 'Let''s create a unit test in the `src/test/java/com/leszko/calculator/CalculatorTest.java` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src/test/java/com/leszko/calculator/CalculatorTest.java` 文件中创建一个单元测试：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our test uses the JUnit library, so we need to add it as a dependency in the
    `build.gradle` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试使用了 JUnit 库，因此我们需要在 `build.gradle` 文件中将其作为依赖项添加：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can run the test locally using the `./gradlew test` command. Then, let''s commit the
    code and push it to the repository:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `./gradlew test` 命令在本地运行测试。然后，让我们提交代码并推送到代码库：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a Unit test stage
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建单元测试阶段
- en: 'Now, we can add a `Unit test` stage to the pipeline:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在管道中添加一个 `单元测试` 阶段：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In the case of Maven, use the `./mvnw test` command instead.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maven 的情况下，使用 `./mvnw test` 命令代替。
- en: 'When we build the pipeline again, we should see three boxes, which means that
    we''ve completed the continuous integration pipeline:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次构建管道时，我们应该看到三个框，这意味着我们已经完成了持续集成管道：
- en: '![Figure 4.4 – A continuous integration pipeline build'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 持续集成管道构建'
- en: '](img/B18223_04_04.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_04.jpg)'
- en: Figure 4.4 – A continuous integration pipeline build
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 持续集成管道构建
- en: Now that we have our pipeline prepared, let's look at how to achieve exactly
    the same result using Jenkinsfile.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了管道，让我们看看如何使用 Jenkinsfile 达到完全相同的结果。
- en: Jenkinsfile
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkinsfile
- en: So far, we've created all the pipeline code directly in Jenkins. This is, however,
    not the only option. We can also put the pipeline definition inside a file called `Jenkinsfile` and commit it
    to the repository, together with the source code. This method is even more consistent
    because the way your pipeline looks is strictly related to the project itself.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经直接在 Jenkins 中创建了所有的管道代码。然而，这并不是唯一的选择。我们还可以将管道定义放在一个名为 `Jenkinsfile`
    的文件中，并将其与源代码一起提交到代码库中。这种方法更一致，因为你的管道结构严格与项目本身相关。
- en: For example, if you don't need the code compilation because your programming
    language is interpreted (and not compiled), you won't have the `Compile` stage.
    The tools you use also differ, depending on the environment. We used Gradle/Maven
    because we've built a Java project; however, in the case of a project written
    in Python, you can use PyBuilder. This leads to the idea that the pipelines should
    be created by the same people who write the code – the developers. Also, the pipeline
    definition should be put together with the code, in the repository.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你不需要代码编译，因为你的编程语言是解释型语言（而不是编译型语言），那么你就不会有 `编译` 阶段。你使用的工具也会有所不同，取决于环境。我们使用了
    Gradle/Maven，因为我们构建的是 Java 项目；然而，在 Python 项目中，你可以使用 PyBuilder。这引出了一个观点，即管道应该由编写代码的人来创建——即开发者。此外，管道定义应该与代码一起放在代码库中。
- en: 'This approach brings immediate benefits, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了即时的好处，如下所示：
- en: In the case of a Jenkins failure, the pipeline definition is not lost (because
    it's stored in the code repository, not in Jenkins).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins 失败的情况下，管道定义不会丢失（因为它存储在代码库中，而不是 Jenkins 中）。
- en: The history of the pipeline changes is stored.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道更改的历史记录已被存储。
- en: Pipeline changes go through the standard code development process (for example,
    they are subjected to code reviews).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道更改经过标准的代码开发流程（例如，代码审查）。
- en: Access to the pipeline changes is restricted in exactly the same way as access
    to the source code.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对管道更改的访问权限与对源代码的访问权限完全相同。
- en: Let's see how it all looks in practice by creating a `Jenkinsfile` file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个 `Jenkinsfile` 文件，看看它在实践中的表现。
- en: Creating the Jenkins file
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Jenkins 文件
- en: We can create the `Jenkinsfile` file and push it into our GitHub repository.
    Its content is almost the same as the commit pipeline we wrote. The only difference
    is that the checkout stage becomes redundant because Jenkins has to first check
    out the code (together with `Jenkinsfile`) and then read the pipeline structure
    (from `Jenkinsfile`). This is why Jenkins needs to know the repository address
    before it reads `Jenkinsfile`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `Jenkinsfile` 文件，并将其推送到我们的 GitHub 仓库。其内容几乎与我们写的提交管道相同。唯一的区别是，checkout
    阶段变得多余，因为 Jenkins 必须首先检出代码（连同 `Jenkinsfile`），然后读取管道结构（来自 `Jenkinsfile`）。这就是为什么
    Jenkins 在读取 `Jenkinsfile` 之前需要知道仓库地址的原因。
- en: 'Let''s create a file called `Jenkinsfile` in the `root` directory of our project:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的 `root` 目录中创建一个名为 `Jenkinsfile` 的文件：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now commit the added files and push them to the GitHub repository:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以提交已添加的文件并将它们推送到 GitHub 仓库：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the pipeline from Jenkinsfile
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Jenkinsfile 运行管道
- en: 'When `Jenkinsfile` is in the repository, all we have to do is to open the pipeline
    configuration and do the following in the `Pipeline` section:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Jenkinsfile` 存在于仓库中时，我们需要做的就是打开管道配置，并在 **管道** 部分执行以下操作：
- en: Change **Definition** from **Pipeline script** to **Pipeline script from SCM**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **定义** 从 **管道脚本** 更改为 **来自 SCM 的管道脚本**。
- en: Select **Git** in **SCM**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SCM** 中选择 **Git**。
- en: Put [https://github.com/leszko/calculator.git](https://github.com/leszko/calculator.git) in **Repository
    URL**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 [https://github.com/leszko/calculator.git](https://github.com/leszko/calculator.git)
    放入 **仓库 URL**。
- en: Use `*/main` as **Branch Specifier**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `*/main` 作为 **分支说明符**。
- en: '![Figure 4.5 – The Jenkinsfile pipeline configuration'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – Jenkinsfile 管道配置'
- en: '](img/B18223_04_05.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_05.jpg)'
- en: Figure 4.5 – The Jenkinsfile pipeline configuration
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Jenkinsfile 管道配置
- en: After saving, the build will always run from the current version of `Jenkinsfile` in
    the repository.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，构建将始终从仓库中的当前版本的 `Jenkinsfile` 运行。
- en: We have successfully created the first complete commit pipeline. It can be treated
    as a minimum viable product, and actually, in many cases, this suffices as the
    continuous integration process. In the following sections, we will see what improvements
    can be done to make the commit pipeline even better.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了第一个完整的提交管道。它可以作为最小可行产品来对待，实际上，在许多情况下，这足够作为持续集成过程。在接下来的章节中，我们将看到如何改进，以使提交管道更加完善。
- en: Code-quality stages
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量阶段
- en: We can extend the three classic steps of continuous integration with additional
    steps. The most popular are code coverage and static analysis. Let's look at each
    of them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加额外的步骤来扩展持续集成的三个经典步骤。最流行的步骤是代码覆盖和静态分析。让我们来看看每个步骤。
- en: Code coverage
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖
- en: 'Think about the following scenario: you have a well-configured continuous integration
    process; however, nobody in your project writes unit tests. It passes all the
    builds, but it doesn''t mean that the code is working as expected. *What do we
    do then?* *How do we ensure that the code is tested?*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下场景：你有一个配置良好的持续集成过程，但项目中的任何人都没有编写单元测试。它通过了所有构建，但这并不意味着代码按预期工作。*那么我们该怎么办呢？*
    *我们如何确保代码已经经过测试？*
- en: The solution is to add a code coverage tool that runs all tests and verifies
    which parts of the code have been executed. Then, it can create a report that
    shows the untested sections. Moreover, we can make the build fail when there is
    too much untested code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是添加一个代码覆盖工具，它会运行所有测试并验证代码中哪些部分已经执行。然后，它可以生成报告，显示未测试的部分。此外，当未测试的代码过多时，我们可以使构建失败。
- en: There are a lot of tools available to perform the test coverage analysis; for
    Java, the most popular are JaCoCo, OpenClover, and Cobertura.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可以执行测试覆盖率分析；对于 Java，最流行的工具是 JaCoCo、OpenClover 和 Cobertura。
- en: 'Let''s use JaCoCo and show how the coverage check works. In order to do this,
    we need to perform the following steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 JaCoCo 并展示覆盖率检查如何工作。为此，我们需要执行以下步骤：
- en: Add JaCoCo to the Gradle configuration.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JaCoCo 添加到 Gradle 配置中。
- en: Add the code coverage stage to the pipeline.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码覆盖阶段添加到管道中。
- en: Optionally, publish JaCoCo reports in Jenkins.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在 Jenkins 中发布 JaCoCo 报告。
- en: Let's look at these steps in detail.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这些步骤。
- en: Adding JaCoCo to Gradle
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 JaCoCo 添加到 Gradle 中
- en: 'In order to run JaCoCo from Gradle, we need to add the `jacoco` plugin to the `build.gradle` file
    by inserting the following line:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 Gradle 运行 JaCoCo，我们需要通过插入以下行将 `jacoco` 插件添加到 `build.gradle` 文件中：
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, if we want to make Gradle fail in the case of low code coverage, we can
    add the following configuration to the `build.gradle` file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们希望在代码覆盖率较低的情况下让 Gradle 构建失败，可以在`build.gradle`文件中添加以下配置：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This configuration sets the minimum code coverage to 20%. We can run it with
    the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置将最小代码覆盖率设置为 20%。我们可以使用以下命令运行它：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command checks whether the code coverage is at least 20%. You can play
    with the minimum value to see the level at which the build fails. We can also
    generate a test coverage report using the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令检查代码覆盖率是否至少为 20%。你可以调整最小值，查看构建在哪个覆盖率水平下失败。我们还可以使用以下命令生成测试覆盖报告：
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can check out the full coverage report in the `build/reports/jacoco/test/html/index.html` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`build/reports/jacoco/test/html/index.html`文件中查看完整的覆盖报告：
- en: '![Figure 4.6 – JaCoCo code coverage report'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – JaCoCo 代码覆盖报告'
- en: '](img/B18223_04_06.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_06.jpg)'
- en: Figure 4.6 – JaCoCo code coverage report
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – JaCoCo 代码覆盖报告
- en: Let's now add the coverage stage in our pipeline.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在管道中添加覆盖阶段。
- en: Adding a code coverage stage
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码覆盖阶段
- en: 'Adding a code coverage stage to the pipeline is as simple as the previous stages:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 向管道中添加代码覆盖阶段与之前的阶段一样简单：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After adding this stage, if anyone commits code that is not well covered with
    tests, the build will fail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此阶段后，如果有人提交了测试覆盖不足的代码，构建将会失败。
- en: Publishing the code coverage report
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布代码覆盖报告
- en: When coverage is low and the pipeline fails, it is useful to look at the code
    coverage report and find what parts are not yet covered with tests. We can run
    Gradle locally and generate the coverage report; however, it is more convenient
    if Jenkins shows the report for us.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当覆盖率较低且管道失败时，查看代码覆盖报告并找出哪些部分尚未被测试是很有用的。我们可以在本地运行 Gradle 并生成覆盖报告；但是，如果 Jenkins
    为我们显示报告，则会更方便。
- en: 'In order to publish the code coverage report in Jenkins, we require the following
    stage definition:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Jenkins 中发布代码覆盖报告，我们需要以下阶段定义：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This stage copies the generated JaCoCo report to the Jenkins output. When we
    run the build again, we should see a link to the code coverage reports (in the
    menu on the left-hand side, below **Build Now**).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此阶段将生成的 JaCoCo 报告复制到 Jenkins 输出中。当我们再次运行构建时，我们应该能在左侧菜单中的**立即构建**下方看到指向代码覆盖报告的链接。
- en: Information
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'To perform the `publishHTML` step, you need to have the HTML Publisher plugin
    installed in Jenkins. You can read more about the plugin at [https://www.jenkins.io/doc/pipeline/steps/htmlpublisher/](https://www.jenkins.io/doc/pipeline/steps/htmlpublisher/).
    Note also that if the report is generated but not displayed properly in Jenkins,
    you may need to configure Jenkins Security, as described here: [https://www.jenkins.io/doc/book/security/configuring-content-security-policy/](https://www.jenkins.io/doc/book/security/configuring-content-security-policy/).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`publishHTML`步骤，你需要在 Jenkins 中安装 HTML Publisher 插件。你可以在[https://www.jenkins.io/doc/pipeline/steps/htmlpublisher/](https://www.jenkins.io/doc/pipeline/steps/htmlpublisher/)查看更多关于该插件的信息。还需要注意的是，如果报告已生成但未正确显示在
    Jenkins 中，你可能需要配置 Jenkins 安全设置，具体操作可以参考这里：[https://www.jenkins.io/doc/book/security/configuring-content-security-policy/](https://www.jenkins.io/doc/book/security/configuring-content-security-policy/)。
- en: We have created the code coverage stage, which shows the code that is not tested
    and therefore vulnerable to bugs. Let's see what else can be done in order to
    improve the code quality.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了代码覆盖阶段，显示了未经过测试的代码，因此容易出现漏洞。让我们看看还可以做些什么来提高代码质量。
- en: Tip
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you need code coverage that is stricter, you can check the concept of mutation
    testing and add the PIT framework stage to the pipeline. Read more at [http://pitest.org/](http://pitest.org/).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更严格的代码覆盖要求，可以了解突变测试的概念，并将 PIT 框架阶段添加到管道中。阅读更多内容请访问[http://pitest.org/](http://pitest.org/)。
- en: Static code analysis
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Your code coverage may work perfectly fine; however, *what about the quality
    of the code itself?* *How do we ensure it is maintainable and written in a good
    style?*
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码覆盖率可能非常完美；然而，*那代码本身的质量呢？* *我们如何确保它是可维护的，并且写得风格良好？*
- en: Static code analysis is an automatic process of checking code without actually
    executing it. In most cases, it implies checking a number of rules on the source
    code. These rules may apply to a wide range of aspects; for example, all public
    classes need to have a Javadoc comment, the maximum length of a line is 120 characters,
    or if a class defines the `equals()` method, it has to define the `hashCode()` method
    as well.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是一个无需实际执行代码的自动检查过程。在大多数情况下，它意味着检查源代码上的多个规则。这些规则可以应用于广泛的方面；例如，所有公共类需要有
    Javadoc 注释，一行的最大长度为 120 个字符，或者如果一个类定义了 `equals()` 方法，它也必须定义 `hashCode()` 方法。
- en: 'The most popular tools to perform static analysis on Java code are Checkstyle,
    FindBugs, and PMD. Let''s look at an example and add the static code analysis
    stage using Checkstyle. We will do this in three steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Java 代码静态分析的最流行工具是 Checkstyle、FindBugs 和 PMD。让我们看一个例子，并使用 Checkstyle 添加静态代码分析阶段。我们将分三步来完成：
- en: Adding the Checkstyle configuration
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Checkstyle 配置
- en: Adding the Checkstyle stage
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Checkstyle 阶段
- en: Optionally, publishing the Checkstyle report in Jenkins
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的，在 Jenkins 中发布 Checkstyle 报告
- en: We will walk through each of them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一讲解它们。
- en: Adding the Checkstyle configuration
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 Checkstyle 配置
- en: 'In order to add the Checkstyle configuration, we need to define the rules against
    which the code is checked. We can do this by specifying the `config/checkstyle/checkstyle.xml` file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加 Checkstyle 配置，我们需要定义检查代码的规则。我们可以通过指定 `config/checkstyle/checkstyle.xml`
    文件来完成：
- en: '[PRE23]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The configuration contains only one rule – checking whether all Java constants
    follow the naming convention and consist of uppercase characters only.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中只包含一个规则——检查所有 Java 常量是否遵循命名约定，并且仅由大写字母组成。
- en: Information
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The complete Checkstyle description can be found at [https://checkstyle.sourceforge.io/config.html](https://checkstyle.sourceforge.io/config.html).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Checkstyle 描述可以在 [https://checkstyle.sourceforge.io/config.html](https://checkstyle.sourceforge.io/config.html)
    查找。
- en: 'We also need to add the `checkstyle` plugin to the `build.gradle` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `checkstyle` 插件添加到 `build.gradle` 文件中：
- en: '[PRE24]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can run `checkstyle` with the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令运行 `checkstyle`：
- en: '[PRE25]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the case of our project, this command should complete successfully because
    we didn''t use any constants so far. However, you can try adding a constant with
    the wrong name and checking whether the build fails. For example, if you add the
    following constant to the `src/main/java/com/leszko/calculator/CalculatorApplication.java` file,
    `checkstyle` fails:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目来说，这个命令应该能够成功完成，因为我们到目前为止没有使用任何常量。然而，您可以尝试添加一个命名错误的常量，并检查构建是否失败。例如，如果您将以下常量添加到
    `src/main/java/com/leszko/calculator/CalculatorApplication.java` 文件中，`checkstyle`
    将会失败：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding a Static code analysis stage
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加静态代码分析阶段
- en: 'We can add a `Static code analysis` stage to the pipeline:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在流水线中添加一个 `Static code analysis` 阶段：
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, if anyone commits any code that does not follow the Java constant naming
    convention, the build will fail.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人提交不遵循 Java 常量命名约定的代码，构建将会失败。
- en: Publishing static code analysis reports
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布静态代码分析报告
- en: 'Very similar to JaCoCo, we can add the Checkstyle report to Jenkins:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JaCoCo 非常相似，我们可以将 Checkstyle 报告添加到 Jenkins 中：
- en: '[PRE28]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This generates a link to the Checkstyle report.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个指向 Checkstyle 报告的链接。
- en: We have now added the static code analysis stage, which can help to find bugs
    and standardize the code style inside a team or organization.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已添加静态代码分析阶段，它可以帮助查找错误并标准化团队或组织内部的代码风格。
- en: Let's see one more option we have when it comes to implementing code analysis.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现代码分析时的另一个选择。
- en: SonarQube
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SonarQube
- en: SonarQube is the most widespread source code quality management tool. It supports multiple
    programming languages and can be treated as an alternative to the code coverage
    and static code analysis steps we looked at. Actually, it is a separate server
    that aggregates different code analysis frameworks, such as Checkstyle, FindBugs,
    and JaCoCo. It has its own dashboards and integrates well with Jenkins.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 是最广泛使用的源代码质量管理工具。它支持多种编程语言，并且可以作为我们之前提到的代码覆盖率和静态代码分析步骤的替代方案。实际上，它是一个独立的服务器，汇聚了不同的代码分析框架，如
    Checkstyle、FindBugs 和 JaCoCo。它拥有自己的仪表盘，并且能够与 Jenkins 良好集成。
- en: Instead of adding code quality steps to the pipeline, we can install SonarQube,
    add plugins there, and add a *sonar* stage to the pipeline. The advantage of this
    solution is that SonarQube provides a user-friendly web interface to configure
    rules and show code vulnerabilities.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安装 SonarQube，在那里添加插件，并在流水线中添加 *sonar* 阶段，而不是将代码质量步骤添加到流水线中。此解决方案的优点是，SonarQube
    提供了一个用户友好的 Web 界面，用于配置规则并显示代码漏洞。
- en: Information
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read more about SonarQube on its official page at [https://www.sonarqube.org/](https://www.sonarqube.org/).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在其官方网站查看有关 SonarQube 的更多信息：[https://www.sonarqube.org/](https://www.sonarqube.org/)。
- en: Now that we have covered the code quality stages, let's focus on triggers and
    notifications.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了代码质量阶段，让我们关注触发器和通知。
- en: Triggers and notifications
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器和通知
- en: So far, we have always built the pipeline manually by clicking on the **Build
    Now** button. It works completely fine but may not be very convenient in practice.
    All team members would have to remember that after committing to the repository,
    they need to open Jenkins and start the build. The same applies to pipeline monitoring;
    so far, we have manually opened Jenkins and checked the build status. In this
    section, we will see how to improve the process so that the pipeline will start
    automatically and, when completed, notify team members regarding its status.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是通过点击 **立即构建** 按钮手动构建流水线。这完全没问题，但在实际操作中可能不太方便。所有团队成员都需要记住，在提交到仓库后，他们需要打开
    Jenkins 并启动构建。流水线监控也是如此；到目前为止，我们一直是手动打开 Jenkins 并检查构建状态。在本节中，我们将看到如何改进这个流程，使得流水线能够自动启动，并在完成时通知团队成员其状态。
- en: Triggers
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发器
- en: 'An automatic action to start the build is called the pipeline trigger. In Jenkins,
    there are many options to choose from; however, they all boil down to three types:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 启动构建的自动动作被称为流水线触发器。在 Jenkins 中，有许多选项可以选择；然而，它们都归结为三种类型：
- en: External
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部
- en: Polling **Source Control Management** (**SCM**)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取 **源代码管理** (**SCM**)
- en: A scheduled build
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时构建
- en: Let's take a look at each of them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看它们。
- en: External
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部
- en: External triggers are easy to understand. They mean that Jenkins starts the
    build after it's called by the **notifier**, which can be the other pipeline build,
    the SCM system (for example, GitHub), or any remote script.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 外部触发器易于理解。它们意味着 Jenkins 在被 **通知者** 调用后启动构建，通知者可以是其他流水线构建、SCM 系统（例如 GitHub）或任何远程脚本。
- en: 'The following diagram presents the communication:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了通信过程：
- en: '![Figure 4.7 – An external trigger'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 外部触发器'
- en: '](img/B18223_04_07.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_07.jpg)'
- en: Figure 4.7 – An external trigger
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 外部触发器
- en: GitHub triggers Jenkins after a push to the repository and the build is started.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 在推送到仓库后触发 Jenkins 并启动构建。
- en: 'To configure the system this way, we need the following setup steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式配置系统，我们需要以下设置步骤：
- en: Install the GitHub plugin in Jenkins.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 中安装 GitHub 插件。
- en: Generate a secret key for Jenkins.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Jenkins 生成一个密钥。
- en: Set the GitHub webhook and specify the Jenkins address and key.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 GitHub webhook，并指定 Jenkins 地址和密钥。
- en: In the case of the most popular SCM providers, dedicated Jenkins plugins are
    always provided.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最流行的 SCM 提供商，总是会提供专用的 Jenkins 插件。
- en: There is also a more generic way to trigger Jenkins via the REST call to the `<jenkins_url>/job/<job_name>/build?token=<token>` endpoint.
    For security reasons, it requires setting `token` in Jenkins and then using it
    in the remote script.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更通用的方式，通过 REST 调用 ` <jenkins_url>/job/<job_name>/build?token=<token>` 端点来触发
    Jenkins。出于安全原因，需要在 Jenkins 中设置 `token`，然后在远程脚本中使用它。
- en: Information
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Jenkins must be accessible from the SCM server. In other words, if we use the
    public GitHub repository to trigger Jenkins, our Jenkins server must be public
    as well. This also applies to the REST call solution, in which case, the `<jenkins_url>` address
    must be accessible from the script that triggers it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 必须能够从 SCM 服务器访问。换句话说，如果我们使用公共 GitHub 仓库来触发 Jenkins，那么我们的 Jenkins 服务器也必须是公开的。这也适用于
    REST 调用方案，在这种情况下，`<jenkins_url>` 地址必须能够从触发它的脚本访问。
- en: Polling SCM
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉取 SCM
- en: 'Polling the SCM trigger is a little less intuitive. The following diagram presents
    the communication:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取 SCM 触发器的直观性稍差。以下图示展示了通信过程：
- en: '![Figure 4.8 – Polling the SCM trigger'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 拉取 SCM 触发器'
- en: '](img/B18223_04_08.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_08.jpg)'
- en: Figure 4.8 – Polling the SCM trigger
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 拉取 SCM 触发器
- en: 'Jenkins periodically calls GitHub and checks whether there was any push to
    the repository. Then, it starts the build. It may sound counter-intuitive, but
    there are at least two good cases for using this method:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 定期调用 GitHub 检查是否有推送到代码库的内容。然后，它启动构建。乍一听这可能有些反直觉，但实际上有至少两种情况适合使用这种方法：
- en: Jenkins is inside the firewalled network (which GitHub does not have access
    to).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 位于防火墙内的网络中（GitHub 无法访问该网络）。
- en: Commits are frequent and the build takes a long time, so executing a build after
    every commit would cause an overload.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交频繁且构建时间较长，因此在每次提交后执行构建会导致系统负载过重。
- en: 'The configuration of `pollSCM` is also somehow simpler because the way to connect
    from Jenkins to GitHub is already set up (Jenkins checks out the code from GitHub,
    so it knows how to access it). In the case of our calculator project, we can set
    up an automatic trigger by adding the `triggers` declaration (just after `agent`)
    to the pipeline:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`pollSCM`的配置也相对简单，因为 Jenkins 到 GitHub 的连接已经配置好了（Jenkins 从 GitHub 检出代码，所以它知道如何访问）。以我们的计算器项目为例，我们可以通过在管道中添加`triggers`声明（紧跟`agent`之后）来设置自动触发：'
- en: '[PRE29]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After running the pipeline manually for the first time, the automatic trigger
    is set. Then, it checks GitHub every minute, and for new commits, it starts a
    build. To test that it works as expected, you can commit and push anything to
    the GitHub repository and see that the build starts.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次手动运行管道后，自动触发器已设置好。接下来，它每分钟检查一次 GitHub，如果有新提交，就启动构建。为了测试它是否按预期工作，你可以向 GitHub
    仓库提交并推送任意内容，看看构建是否启动。
- en: We used the mysterious `* * * * *` as an argument to `pollSCM`. It specifies
    how often Jenkins should check for new source changes and is expressed in the `cron`-style
    string format.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将神秘的`* * * * *`作为`pollSCM`的参数。它指定 Jenkins 应该多久检查一次新源代码的更改，采用的是`cron`风格的字符串格式。
- en: Information
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The `cron` string format is described (together with the cron tool) at [https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron`字符串格式的说明（以及 cron 工具）可见于[https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron)。'
- en: Scheduled builds
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时构建
- en: The scheduled trigger means that Jenkins runs the build periodically, regardless
    of whether there were any commits to the repository.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 定时触发意味着 Jenkins 定期运行构建，不管代码库是否有提交。
- en: 'As the following screenshot shows, no communication with any system is required:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，不需要与任何系统进行通信：
- en: '![Figure 4.9 – The scheduled build trigger'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 定时构建触发器'
- en: '](img/B18223_04_09.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_09.jpg)'
- en: Figure 4.9 – The scheduled build trigger
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 定时构建触发器
- en: The implementation of `cron` keyword is used instead of `pollSCM`. This trigger
    method is rarely used for the commit pipeline but applies well to nightly builds
    (for example, complex integration testing executed at night).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`cron`关键字，而不是`pollSCM`。这种触发方式通常不会用于提交管道，但适用于夜间构建（例如，晚上执行复杂的集成测试）。
- en: Notifications
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知
- en: Jenkins provides a lot of ways to announce its build status. What's more, as
    with everything in Jenkins, new notification types can be added using plugins.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 提供了许多方式来宣布其构建状态。更重要的是，像 Jenkins 中的所有其他功能一样，可以通过插件添加新的通知类型。
- en: Let's walk through the most popular types so that you can choose the one that
    fits your needs.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解最流行的几种类型，这样你可以选择最适合自己需求的那种。
- en: Email
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 邮件
- en: The most classic way to notify users about the Jenkins build status is to send
    emails. The advantage of this solution is that everybody has a mailbox, everybody knows how
    to use it, and everybody is used to receiving information in it. The drawback
    is that, usually, there are simply too many emails, and the ones from Jenkins
    quickly become filtered out and never read.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通知用户 Jenkins 构建状态的最经典方式是发送电子邮件。这个方案的优点是每个人都有邮箱，每个人都知道如何使用它，而且每个人都习惯在邮箱中接收信息。缺点是，通常电子邮件太多，而来自
    Jenkins 的邮件很快就会被过滤掉，根本没人阅读。
- en: 'The configuration of the email notification is very simple:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件通知的配置非常简单：
- en: Have the **SMTP** (**Simple Mail Transfer Protocol**) server configured.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置**SMTP**（**简单邮件传输协议**）服务器。
- en: Set its details in Jenkins (in **Manage Jenkins** | **Configure System**).
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jenkins 中设置其详细信息（在**管理 Jenkins** | **配置系统**中）。
- en: Use the `mail to` instruction in the pipeline.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管道中使用`mail to`指令。
- en: 'The pipeline configuration can be as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 管道配置可以如下：
- en: '[PRE30]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that all notifications are usually called in the `post` section of the
    pipeline, which is executed after all steps, no matter whether the build succeeded
    or failed. We used the `always` keyword; however, there are different options:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有通知通常都在管道的`post`部分调用，该部分在所有步骤执行完毕后执行，无论构建是成功还是失败。我们使用了`always`关键字；不过，还有其他不同的选项：
- en: '`always`: Execute regardless of the completion status.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：无论完成状态如何，都会执行。'
- en: '`changed`: Execute only if the pipeline changed its status.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changed`：仅当管道的状态发生变化时执行。'
- en: '`fixed`: Execute only if the pipeline changed its status from failed to success.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed`：仅当管道的状态从失败变为成功时执行。'
- en: '`regression`: Execute only if the pipeline changed its status from success
    to failed, unstable, or aborted.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regression`：仅当管道的状态从成功变为失败、不稳定或中止时执行。'
- en: '`aborted`: Execute only if the pipeline was manually aborted.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aborted`：仅当管道被手动中止时执行。'
- en: '`failure`: Execute only if the pipeline has the `failed` status.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failure`：仅当管道的状态为`failed`时执行。'
- en: '`success`: Execute only if the pipeline has the `success` status.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success`：仅当管道的状态为`success`时执行。'
- en: '`unstable`: Execute only if the pipeline has the `unstable` status (usually
    caused by test failures or code violations).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unstable`：仅当管道的状态为`unstable`时执行（通常由测试失败或代码违规引起）。'
- en: '`unsuccessful`: Execute only if the pipeline has any status other than `success`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsuccessful`：仅当管道的状态不是`success`时执行。'
- en: Group chats
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 群组聊天
- en: 'If a group chat (for example, Slack) is the first method of communication in
    your team, it''s worth considering adding the automatic build notifications there.
    No matter which tool you use, the procedure to configure it is always the same:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果群组聊天（例如Slack）是你团队中的首选沟通方式，那么考虑在其中添加自动构建通知是值得的。无论你使用哪种工具，配置它的过程都是一样的：
- en: Find and install the plugin for your group chat tool (for example, the **Slack
    Notification** plugin).
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并安装适用于你的群组聊天工具的插件（例如，**Slack Notification**插件）。
- en: Configure the plugin (the server URL, channel, authorization token, and so on).
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置插件（服务器URL、频道、授权令牌等）。
- en: Add the sending instruction to the pipeline.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将发送指令添加到管道中。
- en: 'Let''s see a sample pipeline configuration for Slack to send notifications
    after the build fails:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在构建失败后发送通知的Slack管道配置示例：
- en: '[PRE31]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Team spaces
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 团队空间
- en: Together with the agile culture came the idea that it's better to have everything
    happening in a team space. Instead of writing emails, meet together; instead of
    online messaging, come and talk; instead of task tracking tools, have a whiteboard.
    The same idea came to continuous delivery and Jenkins. Currently, it's very common
    to install big screens (also called **build radiators**) in the team space. Then,
    when you come to the office, the first thing you see is the current status of
    the pipeline. Build radiators are considered one of the most effective notification
    strategies. They ensure that everyone is aware of failing builds and, as a beneficial
    side effect, they boost team spirit and favor in-person communication.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 随着敏捷文化的兴起，出现了一个观念：最好所有事情都在团队空间内进行。与其写电子邮件，不如聚在一起；与其在线聊天，不如面对面交流；与其使用任务跟踪工具，不如有一块白板。这个理念同样也影响了持续交付和Jenkins。目前，在团队空间安装大屏幕（也叫**构建散热器**）已经非常普遍。因此，当你来到办公室时，首先看到的是管道的当前状态。构建散热器被认为是最有效的通知策略之一。它们确保每个人都意识到构建失败，并且作为一种积极的副作用，它们促进了团队精神并支持面对面的沟通。
- en: Since developers are creative beings, they invented a lot of other ideas that
    play the same role as the radiators. Some teams hang large speakers that beep
    when the pipeline fails. Others have toys that blink when the build is done. One
    of my favorites is Pipeline State UFO, which is provided as an open source project
    on GitHub. On its page, you can find a description of how to print and configure
    a UFO that hangs off the ceiling and signals the pipeline state. You can find
    more information at [https://github.com/Dynatrace/ufo](https://github.com/Dynatrace/ufo).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发人员是富有创造力的存在，他们发明了很多其他的创意，起着与散热器相同的作用。有些团队挂上了大扬声器，当管道失败时会发出蜂鸣声。其他团队则有玩具，当构建完成时会闪烁。我的一个最喜欢的例子是Pipeline
    State UFO，这是一个在GitHub上提供的开源项目。在它的页面上，你可以找到如何打印和配置一个悬挂在天花板上的UFO，来显示管道状态的描述。你可以在[https://github.com/Dynatrace/ufo](https://github.com/Dynatrace/ufo)找到更多信息。
- en: Information
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Since Jenkins is extensible by plugins, its community wrote a lot of different
    ways to inform users about the build statuses. Among them, you can find RSS feeds,
    SMS notifications, mobile applications, and desktop notifiers.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jenkins 可通过插件扩展，其社区编写了许多不同的方法来通知用户构建状态。其中包括 RSS 源、短信通知、移动应用程序和桌面通知器。
- en: Now that we have covered triggers and notifications, let's focus on one more
    important aspect – team development strategies.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了触发器和通知，让我们关注另一个重要方面——团队开发策略。
- en: Team development strategies
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队开发策略
- en: We have covered everything regarding how the continuous integration pipeline
    should look. However, *when exactly should it be run?* Of course, it is triggered
    after the commit to the repository, but *after the commit to which branch?* *Only
    to the trunk or to every branch?* Or, *maybe it should run before, not after,
    committing so that the repository will always be healthy?* Or, *how about the
    crazy idea of having no branches at all?*
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了有关持续集成流水线应如何构建的所有内容。然而，*究竟什么时候应该运行它？* 当然，它是在提交到仓库后触发的，但*提交到哪个分支后？* *仅仅提交到主干，还是每个分支都提交？*
    或者，*也许应该在提交之前运行，以确保仓库始终处于健康状态？* 或者，*如果没有分支，那个疯狂的想法怎么样？*
- en: There is no single best answer to these questions. Actually, the way you use
    the continuous integration process depends on your team development workflow.
    So, before we go any further, let's describe the possible workflows.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题没有唯一正确的答案。实际上，你如何使用持续集成过程取决于你的团队开发工作流。因此，在我们进一步讨论之前，让我们先描述一下可能的工作流。
- en: Development workflows
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发工作流
- en: A development workflow is the way your team puts code into the repository. It
    depends, of course, on many factors, such as the SCM tool, the project specifics,
    and the team size.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工作流是指团队如何将代码提交到仓库。它当然取决于多个因素，比如 SCM 工具、项目特点和团队规模。
- en: 'As a result, each team develops the code in a slightly different manner. We
    can, however, classify them into three types: a **trunk-based workflow**, a **branching
    workflow**, and a **forking workflow**.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，每个团队以略有不同的方式开发代码。然而，我们可以将它们分为三种类型：**基于主干的工作流**、**分支工作流**和**分叉工作流**。
- en: Information
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: All workflows are described in detail, with examples, at [https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作流的详细描述和示例，可以在[https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows)找到。
- en: The trunk-based workflow
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主干的工作流
- en: 'The trunk-based workflow is the simplest possible strategy. It is presented in
    the following diagram:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的工作流是最简单的策略。该策略在下图中展示：
- en: '![Figure 4.10 – The trunk-based workflow'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 基于主干的工作流'
- en: '](img/B18223_04_10.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_10.jpg)'
- en: Figure 4.10 – The trunk-based workflow
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 基于主干的工作流
- en: There is one central repository with a single entry for all changes to the project,
    which is called the **trunk** or **master**. Every member of the team clones the
    central repository to have their own local copies. The changes are committed directly
    to the central repository.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个中央仓库，所有项目的更改都通过该仓库进行提交，这个仓库被称为**主干**或**主分支**。团队的每个成员都克隆该中央仓库，以便拥有自己的本地副本。更改直接提交到中央仓库。
- en: The branching workflow
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支工作流
- en: 'The branching workflow, as its name suggests, means that the code is kept in
    many different branches. The idea is presented in the following diagram:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 分支工作流，顾名思义，意味着代码保存在多个不同的分支中。这个概念在下图中展示：
- en: '![Figure 4.11 – The branching workflow'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 分支工作流'
- en: '](img/B18223_04_11.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_11.jpg)'
- en: Figure 4.11 – The branching workflow
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 分支工作流
- en: When developers start to work on a new feature, they create a dedicated branch
    from the trunk and commit all feature-related changes there. This makes it easy
    for multiple developers to work on a feature without breaking the main code base.
    This is why, in the case of the branching workflow, there is no problem in keeping
    the master healthy. When the feature is completed, a developer rebases the feature
    branch from the master and creates a pull request that contains all feature-related
    code changes. It opens the code review discussions and makes space to check whether
    the changes disturb the master. When the code is accepted by other developers
    and automatic system checks, it is merged into the main code base. The build is
    run again on the master but should almost never fail, since it didn't fail on
    the branch.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者开始开发新功能时，他们会从主干创建一个专用的分支，并在该分支上提交所有与功能相关的更改。这使得多个开发者可以在不破坏主代码库的情况下共同开发一个功能。这也是为什么在分支工作流中，保持主干健康没有问题。当功能完成时，开发者会从主干对功能分支进行
    rebase，并创建一个包含所有功能相关代码更改的拉取请求。这样会启动代码审查讨论，并提供检查更改是否破坏主干的空间。当其他开发者和自动化系统检查接受代码后，它会被合并到主代码库中。构建会在主干上重新运行，但几乎不应该失败，因为它在分支上没有失败。
- en: The forking workflow
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Forking 工作流
- en: 'The forking workflow is very popular among open source communities. It is presented in
    the following diagram:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Forking 工作流在开源社区中非常受欢迎。它在以下图示中展示：
- en: '![Figure 4.12 – The forking workflow'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – Forking 工作流](img/B18223_04_12.jpg)'
- en: '](img/B18223_04_12.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_12.jpg)'
- en: Figure 4.12 – The forking workflow
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – Forking 工作流
- en: Each developer has their own server-side repository. It may or may not be the
    official repository, but technically, each repository is exactly the same.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者都有自己的服务器端代码仓库。这个仓库可能是官方仓库，也可能不是，但从技术上讲，每个仓库是完全相同的。
- en: '**Forking** means literally creating a new repository from another repository.
    Developers push to their own repositories, and when they want to integrate code,
    they create a pull request to the other repository.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**Forking** 字面意思是从另一个仓库创建一个新仓库。开发者推送到他们自己的仓库，当他们想要集成代码时，他们会创建一个拉取请求到另一个仓库。'
- en: The main advantage of the forking workflow is that the integration is not necessarily
    via a central repository. It also helps with ownership because it allows the acceptance
    of pull requests from others without giving them write access.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Forking 工作流的主要优点是，集成不一定需要通过中央仓库。它还帮助管理所有权，因为它允许接受来自其他人的拉取请求而不授予他们写权限。
- en: In the case of requirement-oriented commercial projects, a team usually works
    on one product and therefore has a central repository, so this model boils down
    to having a branching workflow with good ownership assignment; for example, only
    project leads can merge pull requests into the central repository.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需求导向的商业项目，一个团队通常会专注于一个产品，因此会有一个中央仓库， 所以这种模型最终归结为具有良好所有权分配的分支工作流；例如，只有项目负责人可以将拉取请求合并到中央仓库中。
- en: Adopting continuous integration
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用持续集成
- en: We have described different development workflows, but *how do they influence
    the continuous integration configuration?*
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了不同的开发工作流，但 *它们如何影响持续集成配置？*
- en: Branching strategies
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支策略
- en: 'Each development workflow implies a different continuous integration approach:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 每种开发工作流都暗示了不同的持续集成方法：
- en: '**Trunk-based workflow**: This implies constantly struggling against the broken
    pipeline. If everyone commits to the main code base, the pipeline often fails.
    In this case, the old continuous integration rule says, *If the build is broken,
    the development team stops whatever they are doing and fixes the problem immediately*.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于主干的工作流**：这意味着需要不断与破坏的流水线作斗争。如果每个人都提交到主代码库，流水线往往会失败。在这种情况下，旧的持续集成规则是，*如果构建失败，开发团队会停止手头的工作，立即修复问题*。'
- en: '**Branching workflow**: This solves the broken trunk issue but introduces another
    one: if everyone develops in their own branches, *where is the integration?* A
    feature usually takes weeks or months to develop, and for all this time, the branch
    is not integrated into the main code. Therefore, it cannot really be called continuous
    integration – not to mention that there is a constant need for merging and resolving
    conflicts.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支工作流**：它解决了破坏主干的问题，但引入了另一个问题：如果每个人都在自己的分支上开发，*那么集成在哪里？* 一个功能通常需要几周或几个月的时间来开发，在这段时间里，分支并没有被集成到主代码中。因此，这种情况不能真正称为持续集成——更不用说持续需要合并和解决冲突的问题。'
- en: '**Forking workflow**: This implies managing the continuous integration process
    by every repository owner, which isn''t usually a problem. It does share, however,
    the same issues as the branching workflow.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分叉工作流**：这意味着每个仓库所有者都管理持续集成过程，这通常不是问题。然而，它确实与分支工作流面临相同的问题。'
- en: There is no silver bullet, and different organizations choose different strategies.
    The solution that is the closest to perfection uses the technique of the branching
    workflow and the philosophy of the trunk-based workflow. In other words, we can
    create very small branches and integrate them frequently into the master. This
    seems to take the best aspects of both. However, it requires either having tiny
    features or using feature toggles. Since the concept of feature toggles fits very
    well into continuous integration and continuous delivery, let's take a moment
    to explore it.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 没有银弹，不同的组织选择不同的策略。最接近完美的解决方案使用了分支工作流的技术和基于主干的工作流哲学。换句话说，我们可以创建非常小的分支，并频繁地将它们集成到主分支中。这似乎结合了两者的最佳特点。然而，它需要有小功能或者使用特性开关。由于特性开关的概念非常适合持续集成和持续交付，我们可以稍作停顿来探讨它。
- en: Feature toggles
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特性开关
- en: Feature toggles is a technique that is an alternative to maintaining multiple
    source code branches, such that the feature can be tested before it is completed
    and ready for release. It is used to disable the feature for users but enable
    it for developers while testing. Feature toggles are essentially variables used
    in conditional statements.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 特性开关是一种替代维护多个源代码分支的技术，使得特性可以在完成并准备发布之前进行测试。它用于禁用用户的特性，但允许开发人员在测试时启用该特性。特性开关本质上是用于条件语句中的变量。
- en: 'The simplest implementation of feature toggles are flags and the `if` statements.
    A development using feature toggles, as opposed to a feature branching development,
    appears as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 特性开关的最简单实现是标志和 `if` 语句。使用特性开关进行开发，与使用特性分支的开发方式相比，结果如下：
- en: A new feature has to be implemented.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要实现一个新特性。
- en: Create a new flag or a configuration property – `feature_toggle` (instead of
    the `feature` branch).
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的标志或配置属性 – `feature_toggle`（而不是 `feature` 分支）。
- en: 'All feature-related code is added inside the `if` statement (instead of committing
    to the `feature` branch), such as the following:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有与特性相关的代码都添加在 `if` 语句中（而不是提交到 `feature` 分支），例如以下内容：
- en: '[PRE32]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'During the feature development, the following takes place:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在功能开发过程中，会发生以下情况：
- en: Coding is done in the master with `feature_toggle = true` (instead of coding
    in the feature branch).
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在主分支中编写，`feature_toggle = true`（而不是在功能分支中编写代码）。
- en: The release is done from the master with `feature_toggle = false`.
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布工作从主分支进行，`feature_toggle = false`。
- en: When the feature development is completed, all `if` statements are removed and `feature_toggle` is
    removed from the configuration (instead of merging `feature` to the master and
    removing the `feature` branch).
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当功能开发完成时，所有的 `if` 语句会被移除，`feature_toggle` 会从配置中删除（而不是将 `feature` 合并到主分支并删除 `feature`
    分支）。
- en: The benefit of feature toggles is that all development is done in the trunk,
    which facilitates real continuous integration and mitigates problems with merging
    the code.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 特性开关的好处在于所有的开发工作都在主干中进行，这有助于实现真正的持续集成，并减轻了合并代码时的问题。
- en: Jenkins multi-branch
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins 多分支
- en: If you decide to use branches in any form, either the long-feature branches or
    the recommended short-lived branches, it is convenient to know that the code is
    healthy before merging it into the master. This approach results in always keeping
    the main code base green, and luckily, there is an easy way to do it with Jenkins.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用任何形式的分支，无论是长时间的功能分支，还是推荐的短生命周期分支，了解代码在合并到主分支之前是健康的会很方便。这种方法的结果是始终保持主代码库绿色，幸运的是，可以通过
    Jenkins 很容易做到这一点。
- en: 'In order to use multi-branch in our calculator project, let''s proceed with
    the following steps:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的计算器项目中使用多分支，我们可以按照以下步骤进行：
- en: Open the main Jenkins page.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Jenkins 主页面。
- en: Click on **New Item**.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **New Item**。
- en: Enter `calculator-branches` as the item name, select **Multibranch Pipeline**,
    and click on **OK**.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `calculator-branches` 作为项目名称，选择 **Multibranch Pipeline**，然后点击 **OK**。
- en: In the **Branch Sources** section, click on **Add source**, and select **Git**.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Branch Sources** 部分，点击 **Add source**，然后选择 **Git**。
- en: 'Enter the repository address in the **Project Repository** field:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目仓库** 字段中输入仓库地址：
- en: '![Figure 4.13 – The multi-branch pipeline configuration'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 多分支流水线配置'
- en: '](img/B18223_04_13.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_13.jpg)'
- en: Figure 4.13 – The multi-branch pipeline configuration
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 多分支管道配置
- en: Tick **Periodically if not otherwise run** and set **1 minute** as the interval.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**周期性运行（如果没有其他设置）**并设置**1分钟**作为间隔。
- en: Click on **Save**.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**。
- en: Every minute, this configuration checks whether there were any branches added
    (or removed) and creates (or deletes) the dedicated pipeline defined by `Jenkinsfile`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 每分钟，这个配置会检查是否添加（或删除）了任何分支，并根据 `Jenkinsfile` 创建（或删除）相应的专用管道。
- en: 'We can create a new branch and see how it works. Let''s create a new branch
    called `feature` and push it into the repository:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新分支并观察其工作原理。让我们创建一个名为`feature`的新分支，并将其推送到仓库中：
- en: '[PRE33]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After a moment, you should see a new branch pipeline automatically created
    and run:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，您应该看到一个新的分支管道自动创建并运行：
- en: '![Figure 4.14 – The multi-branch pipeline build'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 多分支管道构建'
- en: '](img/B18223_04_14.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_04_14.jpg)'
- en: Figure 4.14 – The multi-branch pipeline build
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 多分支管道构建
- en: Now, before merging the feature branch to the master, we can check whether it's
    green. This approach should never break the master build.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在将功能分支合并到主分支之前，我们可以检查它是否通过测试。这种方式永远不应该破坏主分支构建。
- en: A very similar approach is to build a pipeline per pull request instead of a
    pipeline per branch, which gives the same result – the main code base is always
    healthy.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常相似的方法是为每个拉取请求建立管道，而不是为每个分支建立管道，这样也能达到相同的结果——主代码库始终保持健康。
- en: Non-technical requirements
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非技术要求
- en: Last but not least, continuous integration is not all about technology. On the
    contrary, technology comes second. James Shore, in his *Continuous Integration
    on a Dollar a Day* article, described how to set up the continuous integration
    process without any additional software. All he used was a rubber chicken and
    a bell. The idea is to make the team work in one room and set up a separate computer
    with an empty chair. Put the rubber chicken and the bell in front of that computer.
    Now, when you plan to check in the code, take the rubber chicken, check in the
    code, go to the empty computer, check out the fresh code, run all tests there,
    and if everything passes, put back the rubber chicken, and ring the bell so that
    everyone knows that something has been added to the repository.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，持续集成并不仅仅是技术问题。相反，技术排在第二位。James Shore在他的*《每天一美元的持续集成》*文章中描述了如何在没有任何额外软件的情况下设置持续集成过程。他所使用的仅仅是一只橡胶鸡和一只铃铛。其想法是让团队在一个房间里工作，并设置一台带有空椅子的计算机。把橡胶鸡和铃铛放在那台计算机前面。现在，当你计划提交代码时，拿起橡胶鸡，提交代码，去空的计算机，拉取最新代码，在那里运行所有测试，如果一切通过，就把橡胶鸡放回去，并响铃通知大家已经有新内容被提交到仓库。
- en: Information
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: '*Continuous Integration on a Dollar a Day* by *James Shore* can be found at [http://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day](http://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*《每天一美元的持续集成》* 由*James Shore* 撰写，可以在 [http://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day](http://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day)
    上找到。'
- en: 'The idea is a little oversimplified, and automated tools are useful; however,
    the main message is that without each team member''s engagement, even the best
    tools won''t help. In his book, Jez Humble outlines the prerequisites for continuous
    integration:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法有点过于简化，自动化工具是有用的；然而，主要的信息是：没有每个团队成员的参与，即使是最好的工具也没有帮助。在他的书中，Jez Humble 概述了持续集成的先决条件：
- en: '**Check in regularly**: To quote Mike Roberts, *continuously is more often
    than you think*; the minimum is once a day.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期提交**：引用 Mike Roberts 的话，*持续集成比你想象的要更频繁*；最少的频率是一天一次。'
- en: '**Create comprehensive unit tests**: It''s not only about high test coverage;
    it''s possible to have no assertions and still keep 100% coverage.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建全面的单元测试**：这不仅仅是关于高测试覆盖率；即使没有任何断言，仍然可以保持 100% 的覆盖率。'
- en: '**Keep the process quick**: Continuous integration must take a short time,
    preferably under 5 minutes. 10 minutes is already a lot.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持过程快捷**：持续集成必须在短时间内完成，最好是在 5 分钟以内，10 分钟已经算长了。'
- en: '**Monitor the builds**: This can be a shared responsibility, or you can adapt
    the **build master** role that rotates weekly.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控构建**：这可以是共享责任，或者您可以适应每周轮换的**构建负责人**角色。'
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered all aspects of the continuous integration pipeline,
    which is always the first step for continuous delivery. Here are the key takeaways:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们涵盖了持续集成管道的各个方面，持续集成是持续交付的第一步。以下是关键要点：
- en: The pipeline provides a general mechanism for organizing any automation processes;
    however, the most common use cases are continuous integration and continuous delivery.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道提供了一个通用机制，用于组织任何自动化过程；然而，最常见的用例是持续集成和持续交付。
- en: Jenkins accepts different ways of defining pipelines, but the recommended one
    is the declarative syntax.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 接受定义管道的不同方式，但推荐使用声明性语法。
- en: The commit pipeline is the most basic continuous integration process, and as
    its name suggests, it should be run after every commit to the repository.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交管道是最基本的持续集成过程，顾名思义，它应该在每次提交代码到仓库后运行。
- en: The pipeline definition should be stored in the repository as a `Jenkinsfile`
    file.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道定义应该作为 `Jenkinsfile` 文件存储在仓库中。
- en: The commit pipeline can be extended with the code quality stages.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交管道可以通过增加代码质量阶段来扩展。
- en: No matter what the project build tool, Jenkins commands should always be consistent
    with local development commands.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论项目构建工具是什么，Jenkins 命令都应该与本地开发命令保持一致。
- en: Jenkins offers a wide range of triggers and notifications.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 提供了广泛的触发器和通知功能。
- en: The development workflow should be carefully chosen inside a team or organization
    because it affects the continuous integration process and defines the way code
    is developed.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发工作流应该在团队或组织内部谨慎选择，因为它影响持续集成过程并定义了代码的开发方式。
- en: In the next chapter, we will focus on the next phase of the continuous delivery
    process – automated acceptance testing. This can be considered the most important
    and, in many cases, the most difficult step to implement. We will explore the
    idea of acceptance testing and a sample implementation using Docker.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注持续交付过程的下一阶段——自动化验收测试。这可以被视为最重要的步骤，并且在许多情况下，是最难实现的步骤。我们将探讨验收测试的概念，并通过
    Docker 进行样例实现。
- en: Exercises
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'You''ve learned a lot about how to configure the continuous integration process.
    Since *practice makes perfect*, I recommend doing the following exercises:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多关于如何配置持续集成过程的知识。因为 *熟能生巧*，我建议做以下练习：
- en: 'Create a Python program that multiplies two numbers passed as command-line
    parameters. Add unit tests and publish the project on GitHub:'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Python 程序，用于乘法运算，接收命令行参数传入的两个数字。添加单元测试并将项目发布到 GitHub 上：
- en: Create two files: `calculator.py` and `test_calculator.py`.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个文件：`calculator.py` 和 `test_calculator.py`。
- en: You can use the `unittest` library at [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `unittest` 库，参考 [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。
- en: Run the program and the unit test.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序和单元测试。
- en: 'Build the continuous integration pipeline for the Python calculator project:'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Python 计算器项目构建持续集成管道：
- en: Use `Jenkinsfile` to specify the pipeline.
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Jenkinsfile` 来指定管道。
- en: Configure the trigger so that the pipeline runs automatically in case of any
    commits to the repository.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置触发器，使得在每次提交到仓库时管道自动运行。
- en: The pipeline doesn't need the `Compile` step since Python is an interpretable
    language.
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Python 是一种解释性语言，管道不需要 `Compile` 步骤。
- en: Run the pipeline and observe the results.
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行管道并观察结果。
- en: Try to commit the code that breaks the pipeline build and observe how it is
    visualized in Jenkins.
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试提交破坏管道构建的代码，并观察在 Jenkins 中如何显示。
- en: Questions
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To verify the knowledge acquired from this chapter, please answer the following
    questions:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证本章学到的知识，请回答以下问题：
- en: What is a pipeline?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是管道？
- en: What is the difference between a *stage* and a *step* in the pipeline?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道中的 *stage* 和 *step* 有什么区别？
- en: What is the `post` section in the Jenkins pipeline?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post` 部分在 Jenkins 管道中是什么？'
- en: What are the three most fundamental stages of the commit pipeline?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交管道的三个最基本阶段是什么？
- en: What is `Jenkinsfile`?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `Jenkinsfile`？
- en: What is the purpose of the code coverage stage?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖阶段的目的是什么？
- en: What is the difference between the following Jenkins triggers – external and
    polling SCM?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 Jenkins 触发器——外部触发和轮询 SCM——有什么区别？
- en: What are the most common Jenkins notification methods? Name at least three.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 最常见的通知方法有哪些？请至少列举三种。
- en: What are the three most common development workflows?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三种最常见的开发工作流是什么？
- en: What is a feature toggle?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是特性开关（Feature Toggle）？
- en: Further reading
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To read more about the continuous integration topic, please refer to the following
    resources:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于持续集成的内容，请参考以下资源：
- en: '*Continuous Delivery*, *Jez Humble and David Farley*: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续交付*，*杰兹·汉布尔和大卫·法利*：[https://continuousdelivery.com/](https://continuousdelivery.com/)'
- en: '*Continuous Integration: Improving Software Quality and Reducing Risk*, *Andrew
    Glover, Steve Matyas, and Paul M. Duvall*: [https://www.oreilly.com/library/view/continuous-integration-improving/9780321336385/](https://www.oreilly.com/library/view/continuous-integration-improving/9780321336385/)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续集成：提高软件质量并降低风险*，*安德鲁·格洛弗、史蒂夫·马提亚斯和保罗·杜瓦尔*：[https://www.oreilly.com/library/view/continuous-integration-improving/9780321336385/](https://www.oreilly.com/library/view/continuous-integration-improving/9780321336385/)'
