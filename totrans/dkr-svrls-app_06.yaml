- en: OpenWhisk on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will discuss another player in the serverless space, OpenWhisk.
    The chapter will start with an overview of the OpenWhisk platform, its design
    rationale, and features. After that, the chapter will go through the steps of
    deploying a local instance of OpenWhisk for function development, how to use its
    command-line interface, its components and architecture, and how to prepare functions
    to deploy on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: What is OpenWhisk?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Donated to the Apache foundation, OpenWhisk is a robust FaaS platform originally
    developed by IBM and Adobe. Built atop Docker container technologies, OpenWhisk
    can be deployed in the cloud or on on-premises hardware. It is a platform that
    frees developers from worrying about managing the life cycle of their code or
    operations of the container runtimes that execute the code. OpenWhisk is designed
    to be scalable and to support massive numbers of function invocations. Currently,
    OpenWhisk is the engine behind IBM Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenWhisk scaling mechanism is not built on top of Docker Swarm or Kubernetes
    schedulers. It plugs directly into each Docker instance to start and scale function
    containers. With this design, OpenWhisk fits better with the plain Docker infrastructure
    than Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For developers, OpenWhisk provides a number of compelling features via its
    high-level programming model surrounding functions. Its event triggering mechanism
    is shown in Figure 6.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f10236a1-723f-41aa-8756-1fe01f159c0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: OpenWhisk''s flow of event triggering'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other platforms, OpenWhisk's smallest deployment unit is a function.
    In OpenWhisk, a function is referred to as an action. An action can be executed
    in response to an event. An event, in the form of a trigger, will be processed
    through a rule, where it selects an appropriate action to execute. After the action
    is executed, its result will be stored in the result storage before being emitted
    back to the source of the event.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk natively supports many language runtimes out of the box. However,
    this chapter focuses only on its Docker runtime, which allows developers to pack
    any kind of workload into a container and let OpenWhisk do the rest. An action
    in OpenWhisk can be invoked synchronously, asynchronously, or even on a schedule.
    Besides an action, OpenWhisk provides a declarative programming construct, such
    as a sequence to allow multiple actions to be chained and executed as a flow.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, the quickest way to install OpenWhisk on a local machine
    is to use Docker and Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Docker Compose, we can follow instructions from [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the version of Docker Compose, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use Docker Compose 1.17.1 in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also check if the Git is installed already. If so, now we are ready to install
    a local OpenWhisk instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, clone the OpenWhisk Dev tools repository from GitHub ([https://github.com/apache/incubator-openwhisk-devtools](https://github.com/apache/incubator-openwhisk-devtools))
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `--depth=1` tells `git` to shallow clone the repository, which means that
    only the latest revision of the Git history will be there to save time and space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, move into the directory `incubator-openwhisk-devtools/docker-compose`.
    This directory contains `docker-compose.yml` and the required environment variables
    to start a single node OpenWhisk instance. Look for a `Makefile` there; it contains
    the `quick-start` target to provision an instance, set up the initial data, and
    invoke an example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The command will be doing the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it will download the latest source of OpenWhisk from the `master` branch
    of its GitHub repository, along with the `wsk` CLI binary. Second, it will start
    an OpenWhisk local cluster and initialize the data with the Ansible playbooks
    that came with the OpenWhisk source tree. Then it will register the `hello-world`
    function and finally invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, when the process is up and running, the instance becomes flaky. Simply
    press *Ctrl* + *C* and issue the command `make run` instead of `make quick-start` to
    try to start the instance again. If you'd like to start over, simply run the `make
    destroy` command to destroy the instance. After destroying it, you can start over
    with `make quick-start`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the output ends like this, OpenWhisk is now ready to serve at `localhost:443`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `docker ps` command to double check that all OpenWhisk
    containers are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the wsk client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wsk` client will have already been installed by the `make quick-start`
    command. The `wsk` binary can be found at `openmaster/bin/wsk`. We usually copy
    the `wsk` CLI to `/usr/local/bin` and set up bash completion for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first sub-command introduced here is `wsk property get`. It is to display
    OpenWhisk information, including the current namespace, the authentication key,
    and the build number. For example, we use `-i` or `--insecure` for insecurely
    connecting to the OpenWhisk instance as the generated certificate is self-signed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What does the information tell us? We are currently at the guest `namespace`
    using API version 1 and the long string, starting with `23bc`, is our API key
    for authentication. Any OpenWhisk client, including the `wsk` itself, needs this
    key to connect to the OpenWhisk instance. Our current API gateway is at `localhost:443`,
    which will forward all requests to the underlying controllers. The overview of
    each OpenWhisk component and the architecture will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Components and architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discuss the architecture and components of OpenWhisk. OpenWhisk
    is designed to be a rock-solid FaaS platform as it is powering IBM Cloud Function,
    one of the FaaS production systems already launched by IBM. The key of this rock-solid
    architecture is Kafka. OpenWhisk cleverly uses Kafka as its backbone to guarantee
    that every single function request accepted by Kafka will be delivered to the
    invoker layer. Let's start by looking its overall architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram in *Figure 6.2* shows the overall architecture of OpenWhisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c783eee1-e45d-4c01-9f39-ac503a26052d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The overview architecture of OpenWhisk.'
  prefs: []
  type: TYPE_NORMAL
- en: The edge component is the API gateway built on top of NGINX and OpenResty. The
    API gateway optionally uses Redis for caching. The API gateway sits in front of
    one or more controllers. The controller stores all configuration in a CouchDB
    cluster. Behind the controller, there is a Kafka cluster coordinated by a ZooKeeper
    quorum. The Kafka cluster is very important; every invocation is guaranteed to
    be executed. Kafka acts as a resilient buffer between controllers and invokers.
    Each invoker is responsible for invoking real implementations of functions, in
    this case Docker containers. Therefore, an invoker requires a special privilege
    to connect to the host's Docker socket. An invoker is optionally able to use `docker-runc`
    to improve the performance of the invocation process. Every single component of
    OpenWhisk is able to run inside a container, such as when we deployed it with
    Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will proceed to the details of each component.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API gateway component of OpenWhisk is built atop NGINX and OpenResty technologies.
    The main reason NGINX is chosen is because it provides high performance as the
    edge component of the platform. NGINX sits in front of every other component in
    the system. The API gateway is capable of caching the request with OpenResty talking
    to a Redis cluster on its side. However, Redis is an optional component. It can
    easily be disabled by removing it from the Docker Compose configuration. The API
    gateway is also responsible for severing the secured HTTPS protocol from users.
  prefs: []
  type: TYPE_NORMAL
- en: The current version of the API gateway is `adobeapiplatform/apigateway:1.1.0`.
    It is the version of the API gateway under joint development by Adobe and IBM.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A controller is one of the most important components of OpenWhisk. As the name
    implies, it mainly controls the invocation process of the cluster. Controllers
    can work without having the API gateway in front of them. A controller serves
    the HTTP protocol directly, in an insecure form, as the HTTPS part is the function
    of the API gateway. Basically, a controller source is a part of the OpenWhisk
    project. The configuration used in this chapter is the latest Docker image published
    by OpenWhisk.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The storage component of OpenWhisk is CouchDB. CouchDB is highly available,
    document-based data storage. The controller talks to CouchDB to store every entity
    related to the function invocation. The most important entity stored in CouchDB
    is the activation data. The activation data contains information of each invocation
    process. The progress of actions and their results are stored in the form of *activation
    documents*.
  prefs: []
  type: TYPE_NORMAL
- en: The official CouchDB version 1.6, `couchdb:1.6`, is used in the current configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kafka plays a very important role in the system. By nature, Kafka is a message
    broker that stores every received message and replays them reliably. With Kafka
    as the backbone, requests for action invocation will be reliably delivered to
    the invokers.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka is formed as a cluster using the ZooKeeper quorum. Kafka is running on
    port `9092` within the default network. We use the `wurstmeister/kafka:0.11.0.1`
    image for the configuration in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Invoker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The invoker is the component that is responsible for receiving invocation requests
    from Kafka topics, message queues that consumers could subscribe to receive messages.
    After receiving the messages, the invoker executes the functions using a backend
    runtime. OpenWhisk supports both native and Docker runtimes. The Docker runtime
    is internally called **blackbox**.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk also has an option to use Docker's `runc` directly to improve the
    function performance. With this architecture, the invoker requires access to `/var/run/docker.sock`
    of the local Docker host. This limitation prevents OpenWhisk from scaling efficiently
    in Swarm mode. We will discuss the new architecture for OpenWhisk over Swarm in
    a later chapter, when we discuss the deployment of OpenWhisk in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Action runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several kinds of runtime provided by OpenWhisk. Java, Node.js, and
    Python are native runtimes, for example. As previously mentioned, the Docker runtime
    is called blackbox.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime takes the Docker image registered by the process of action creation.
    Then it starts the Docker container to accept the request. The runtime can keep
    the container running so subsequent calls can be significantly faster.
  prefs: []
  type: TYPE_NORMAL
- en: Function preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discuss how to prepare a function using the Docker template
    called **Docker skeleton**, provided by OpenWhisk.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk Docker SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the Docker skeleton, normally we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But if the file does not exist on your local OpenWhisk, you can download it
    directly from [https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz](https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are to download SDK, extract the SDK, change its directory
    from `dockerSkeleton` to `docker_c`, and change into the `docker_c` directory
    to check its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The skeleton contains a Dockerfile, a simple C program, a bash script for building
    and pushing the finished function to Docker's Hub, and a `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the content of the C program to see what it is for. The C program
    that came with the Docker skeleton SDK contains only the `main` function with
    a couple of `printf` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last `printf` line tells us the whole story of OpenWhisk's action. This
    action returns JSON data by printing it out to STDOUT. The action accepts arguments,
    also in the form of JSON, through the main function's `argv`. It is the action's
    responsibility to decode the arguments and encode the output.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at its `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: The file starts by declaring `openwhisk/dockerskeleton` as the base image. In
    the next line, the environment variable `FLASK_PROXY_PORT` is defined as `8080`.
    You may guess here that the framework used as the wrapper of every Docker function
    is `Flask`, a Python web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to the next two lines, they add the C program into the building container,
    install the GCC compiler, and then compile the program. The output binary is named
    `exec`. It must be placed at `/action/exec`. This is the mandatory location of
    the executable needed by OpenWhisk's `actionproxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is `actionproxy`? It is the OpenWhisk version of a function wrapping server.
    The server accepts a web request through its exposed port, `8080`. As mentioned
    earlier, it is written in Python with the Flask framework, so every OpenWhisk
    function requires Python and Flask dependencies in order to start the `actionproxy`.
    This kind of setup is already there by inheriting from the base image, `openwhisk/dockerskeleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the provided script, we will build it ourselves using the
    `docker build` command. Please recall that you need to use your own `<DOCKER ID>`
    as the repository name to allow you to push the built image onto Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If everything was done correctly, don't forget to use the `docker push` command
    to store this image on the Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a Go function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will write a function using the Go programming language to show you
    how to decode JSON parameters using the Go built-in library. Of course, we will
    modify OpenWhisk's Docker skeleton by adding Go compilers and use a multi-stage
    build to optimize the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll untar the Docker skeleton again, and this time we rename the `dockerSkeleton`
    directory `docker_go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `docker_go` directory, we will write a Go program to decode the
    JSON `params` of the action, rearrange them, encode them back to JSON, and write
    them to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We save this program as `main.go` before continuing to the next step, writing
    our Dockerfile for multi-stage builds to compile the Go program, and pack it as
    an OpenWhisk action. Here''s the new version of `Dockerfile`. Its first build
    stage is to compile the Go program using Go 1.9.2\. Please note that we compile
    it into a statically linked binary so that it can run independently inside the
    OpenWhisk base image. In the second build stage, we copy the binary `/go/src/app/main`
    from the first stage as `/action/exec`, the binary location required for OpenWhisk
    `actionproxy` to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `Dockerfile` is ready. Let''s build it using the `docker build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The action image is now ready as `chanwit/whisk_go`. Again, please use your
    Docker Hub's ID, not mine, as the image repository and don't forget to push it
    to the Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the internal flow of how OpenWhisk invokes its actions.
    We will learn how to create (or register) a Docker container as an OpenWhisk action
    and how to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: Invocation flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As OpenWhisk is an event-driven platform, any kind of event fired to it could
    be intercepted and interpreted. However, in this example, we will show you only
    the event triggered by sending a direct request to the gateway.
  prefs: []
  type: TYPE_NORMAL
- en: The invocation flow starts with an invocation request in the form of an HTTP-based
    request and is sent to the API gateway. For example, we can use the wsk CLI to
    initiate this kind of request. After the API gateway receives the request, it
    will forward that call to a controller behind it.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important components of OpenWhisk is the controller. The controller
    is a component written in Scala using the infamous framework Akka and Spray to
    implement a set of REST APIs. The controller accepts all kinds of requests; if
    it accepts a POST request, it will interpret it as an invocation of an OpenWhisk
    action.
  prefs: []
  type: TYPE_NORMAL
- en: The controller then starts to authenticate and authorize the access of the requested
    action.
  prefs: []
  type: TYPE_NORMAL
- en: The controller will look up the credential information and verify it against
    the data stored in an instance of CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: If the action is not found, the controller simply returns 404 back to the caller,
    for example. Also, if access is denied after verification of the credentials,
    the controller will send a chunk of JSON back to the caller saying that they are
    not allowed to access the action.
  prefs: []
  type: TYPE_NORMAL
- en: If everything is granted, the controller goes to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller then again looks up the information about the action: what it
    is, what kind it is, and how to invoke it.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we use Docker as an action primitive. So, the controller will find
    that our action is a blackbox. Now it's ready to invoke the action.
  prefs: []
  type: TYPE_NORMAL
- en: The controller will not make a request to an invoker directly; instead, it will
    make a request to a Kafka cluster, the backbone of the messaging system. As previously
    mentioned, using Kafka could prevent the loss of the invocation, as well as make
    the system robust by queuing the invocation when the system is busy under heavy
    load.
  prefs: []
  type: TYPE_NORMAL
- en: So the controller publishes a message to Kafka. The request message contains
    all information needed to invoke an action. This message is also persisted by
    Kafka so that it can be replayed when the system crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Once Kafka gets the message, the controller is responded to with an activation
    ID to later obtain the result of invocation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of Kafka, a set of invokers subscribe to the requested messages.
    Once a message is available in the queue, an invoker will be notified. Then the
    invoker will do the real job, invoking the real Docker container. After it gets
    the results, the invoker stores them in the instance of CouchDB under the same
    activation ID.
  prefs: []
  type: TYPE_NORMAL
- en: Action invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, now we are ready to try out both newly created C and Go functions built
    in the previous sections. First, we will create an action using the `wsk action
    create` command starting with the C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If things go correctly, `wsk` will tell us `ok: created action`. Next, we will
    invoke the action using the `wsk action invoke` command. The `invoke` command
    accepts one or more `--param` to pass parameters to the action. We can also pass
    `--result` to obtain the result synchronously. The result is, of course returned
    as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try once more, this time with the Go program. First, create the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, invoke the action using `wsk action invoke`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, we pack actions with Docker and it basically simplifies the
    whole process, starting with action preparation, creation, and invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining activation results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time an action is invoked, OpenWhisk creates an activation record for
    it. To see the activation record, we may invoke an action without the `--result`
    parameter, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The ID `6ba2c0fd6f4348b8a2c0fd6f4388b864` is called an activation ID. We can
    now obtain the activation record using the `wsk activation get` command. Putting
    a field name after the activation ID will filter it to display only that field.
    The following example shows only the field `response` of the activation record
    `6ba2c0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the activation record, the JSON result is placed under the `result` key.
    You may observe that all the data is correctly serialized to JSON and recorded
    there.
  prefs: []
  type: TYPE_NORMAL
- en: User interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no open source portal for OpenWhisk at the time of writing. To make
    it easier for developers to use OpenWhisk, I'm developing a UI portal for it.
    SuraWhisk is an open source project hosted on GitHub. Its source can be found
    at [https://github.com/surawhisk/ui](https://github.com/surawhisk/ui). If you
    do not want to look at the source code, you can just start the UI from a ready-to-use
    Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a volume to store the settings data. Endpoints and their API
    keys for authentication will be stored there in the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the UI can be run using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After SuraWhisk UI starts, point the browser to `http://localhost:8080`. The
    UI''s navigation bar on the left-hand side currently contains three basic items:
    settings, actions, and namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Settings page, as shown in *Figure 6.3*, is for setting up an OpenWhisk
    endpoint and its API key. The SuraWhisk container is running on a bridge network;
    therefore, it can access the OpenWhisk''s API gateway via the Docker''s gateway
    bridge IP, `172.17.0.1`. That is, the endpoint to our local OpenWhisk''s instance
    will be `https://172.17.0.1/api/v1`. The API key for the current guest namespace
    can be obtained by running the `wsk` CLI with the following command. If the bridge
    IP is not working, you may try the local IP of the local machine, as the OpenWhisk''s
    API gateway is exposed over the machine''s IP as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command provides a long string saying that it is a `whisk
    auth`. Copy and paste the whole string, `23b...IwP`, into the API Key textbox
    of the Settings page, and click the Save button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75d7fbc7-5239-4f73-a0c5-60fc73b2e420.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The Settings screen of SuraWhisk for specifying the Endpoint and
    API Key'
  prefs: []
  type: TYPE_NORMAL
- en: Now the SuraWhisk Portal will be able to communicate with the OpenWhisk instance.
    We will proceed to the step of defining a new function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function, an action in OpenWhisk, can be defined on the Actions/Create page,
    as in *Figure 6.4*. The Docker image built earlier in this chapter will be used
    here. In the following example, we create a function named `hello` as a Docker
    container, whose image is `chanwit/whisk_c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be85fc16-34ac-471b-9443-d8773018f01f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The Action Creation screen which allows us to define a new action
    in OpenWhisk'
  prefs: []
  type: TYPE_NORMAL
- en: When everything is ready, click the Create button. The portal will connect to
    the OpenWhisk instance and request creation of a new action. The Docker image
    is not pulled during this stage, so the step will be finished quickly. If the
    `hello` action is created successfully, dialog will pop up, as in Figure 6.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89cee774-b1d3-4241-8f2f-8db3cf5936aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Dialog showing that an action was successfully created'
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke the action, go to the menu Actions/Invoke on the left-hand side navigation
    bar, as in *Figure 6.6*. All actions in the current namespace will be listed in
    the Action combo box. Each invocation accepts key/value pairs as the action''s
    parameters. They can be added by clicking the Add button. In the following example,
    the `book` parameter is set to contain the value `serverless`. A parameter can
    be removed at any time by clicking the Remove button of each pair. These parameters
    will be encoded into JSON before being passed to the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a143defb-24f0-4456-8f78-0b5555578352.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The Invoke Action screen in SuraWhisk showing the result'
  prefs: []
  type: TYPE_NORMAL
- en: After selecting the action to be invoked, clicking the invoke button will start
    the invocation process. In the previous example, the `hello` action is in the
    form of a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are more questions to help you review the contents of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the strengths of OpenWhisk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please describe OpenWhisk's architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the OpenWhisk controller?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of Kafka? Why is it important for OpenWhisk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an invoker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there any reason why the controller and invoker are not connected directly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could we define and invoke an action on the OpenWhisk platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could we improve the performance of the invoker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced OpenWhisk, especially when we utilized Docker as parts
    of its ecosystem. OpenWhisk is a fully featured, fault-tolerant, and polyglot
    serverless platform that allows you to virtually run functions written in any
    language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter walked through its components and architecture, and discussed how
    to use the `wsk` CLI to prepare, create, and invoke OpenWhisk functions. This
    chapter also introduced SuraWhisk, a web UI for OpenWhisk to help us manage and
    invoke OpenWhisk's actions more easily.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned all about three major FaaS platforms. In the next chapter, we
    will discuss how to prepare and operate a Docker cluster to provision and administrate
    FaaS platforms on it.
  prefs: []
  type: TYPE_NORMAL
