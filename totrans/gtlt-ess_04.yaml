- en: Chapter 4. Adding and Removing Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git supports two remote transports for general use—the ssh transport and the
    HTTP transport. Of these, the ssh transport is much easier to set up, since most
    systems already have an ssh server package installed, configured, and ready to
    accept authenticated connections. This is generally not true for HTTP, and even
    if an HTTP server was available, you'd still have to configure it for Gitolite.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will explore adding and removing users for a server using the
    ssh transport. Some of the earlier chapters have already shown you the basics
    of how to add a user. It is now time to dig a little deeper into this and explore
    a few nuances and special cases.
  prefs: []
  type: TYPE_NORMAL
- en: Adding users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strictly speaking, Gitolite doesn't know where users come from. If you recall
    the section on authentication and authorization from the previous chapter, you
    learned that Gitolite does not even do authentication—it leaves it up to the ssh
    server (or perhaps the HTTP server). However, Gitolite does help with ssh-based
    authentication, since that is the most common use of Gitolite, and the server
    and its configuration are fairly standard and predictable, in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of warning: do *not* add new users manually on the server. Gitolite
    users, repositories, and access rules are maintained by making changes to a special
    repository called `gitolite-admin` and pushing those changes to the server, as
    explained in [Chapter 2](ch02.html "Chapter 2. Installing Gitolite"), *Installing
    Gitolite*. Thus, almost everything you do will be within a clone of the `gitolite-admin`
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: To add a user, say Alice, obtain her public key (typically `$HOME/.ssh/id_rsa.pub`
    on her workstation). Then copy it to the directory called `keydir` (in your clone
    of the `gitolite-admin` repository), with the username as the basename (for example,
    `alice.pub` for user alice). Finally, add the key using git add `keydir/alice.pub`,
    then commit and push.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some additional points to note in order to do this correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: All public key files must have names ending in `.pub`, and must be in openssh's
    default format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usernames must start with an alpha-numeric character, and can then contain alpha-numerics,
    hyphens, underscores, periods, and the @ sign. Examples of valid usernames are
    `sitaram`, `sitaram.chamarty`, `sitaramc@gmail.com`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behind the scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's how Gitolite on the server processes users and keys. These actions are
    initiated from within a post-update hook for the `gitolite-admin` repository that
    Gitolite installs.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite reads the authorized keys file `($HOME/.ssh/authorized_keys`), and
    makes a note of all the non-Gitolite keys (that is, keys that did not come from
    Gitolite).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then reads all the public keys in the `keydir` directory of the gitolite-admin
    repository. This is recursive; you can have keys in subdirectories to any level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As it reads each public key, it compares it to each of the public keys it has
    processed so far, including the non-Gitolite keys. If there is a match, it prints
    a warning to the effect that the ssh server will be ignoring the second and subsequent
    occurrences of the key in the authorized keys file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then adds `ssh` options to each public key line. The options added are `no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty`.
    These security options are generally recommended for any ssh server that is *not*
    meant to be serving interactive or shell users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `command` option is added, pointing to the installed `gitolite-shell` location,
    along with an additional argument: the Gitolite username. The username is usually
    the basename of the public key file (that is, removing any directory prefixes,
    and the `.pub` suffix); see the section on *Users with multiple key pairs* later
    when this may not be quite true.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you recall from *Figure 1* in [Chapter 2](ch02.html "Chapter 2. Installing
    Gitolite"), *Installing Gitolite* (reproduced below for convenience), this ensures
    that when the user accesses the server and offers the corresponding public key
    for authentication, his connection, after the ssh daemon has successfully authenticated
    him, will be passed onto the `gitolite-shell` program, with his Gitolite username
    as a command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![Behind the scenes](img/2371OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Users with multiple key pairs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some users have multiple key pairs. For instance, they use a laptop as well
    as a desktop at work. Some may have another machine at home, or work directly
    on a server.
  prefs: []
  type: TYPE_NORMAL
- en: You might think it's best to use the same key pair on each machine—after all,
    they all belong to the same user—but this is not a good idea. The risk of a private
    key compromise increases with the number of machines that it is installed on,
    and that would not be a good thing at all.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Gitolite allows a user to have multiple public keys. There are
    in fact two ways to associate multiple public key files to the same Gitolite user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to use subdirectories. Here''s an example tree structure of
    the gitolite-admin repository showing a set of keys in the `keydir` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Users with multiple key pairs](img/2371OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are two files called `carol.pub`. Both of these will generate
    lines in the authorized keys file as described earlier, with the username set
    to `carol`. Whichever key she uses, Gitolite will see the authenticated Gitolite
    username as `carol`, and authorize her access accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The second way to allow multiple public keys is to use a location suffix. A
    location suffix is an `@` sign followed by a single word consisting of alphanumerics,
    hyphens, or underscores. For example, if Alice had one key for her laptop and
    one for her desktop, she might send you the keys as `alice@laptop.pub` and `alice@desktop.pub`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The location suffix must *not* contain a period; otherwise it looks like an
    e-mail address. As far as Gitolite is concerned, a public key file called `alice@laptop.pub`
    pertains to a user called alice, but a file called `alice@lap.top.pub` pertains
    to a user called `alice@lap.top`, which is a perfectly valid email address at
    least as far as syntax is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: Giving some users a shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of your users may have a legitimate need to log on to the server as the
    hosting user and use a shell command line. If this is required for just one or
    two users, the simplest way to deal with this is to have them use two different
    keys—one for Gitolite access and one for shell access. The second key would be
    installed manually in the authorized keys file on the server, and would not have
    the `command` and other options that Gitolite keys have.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Non-Gitolite keys must be added right at the start of the authorized keys file,
    or at least before the marker line that says `# gitolite start`. Keys added in
    between Gitolite's start and end marker lines will be deleted the next time the
    `gitolite-admin` repository is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: However, this requires careful handling of the second key on both the server
    side, as well as the client side. Some users may not be interested in learning
    how to handle multiple keys on their side, and how to present the correct key
    for each access.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to handle this problem, using a single key. Here's what
    you need to do in order to give any user shell access.
  prefs: []
  type: TYPE_NORMAL
- en: First, determine who is to get this access and make a list of those users. The
    username should be the bare username as used in the `gitolite.conf` file, for
    example, `alice` and `bob`. Do not use `alice.pub`, `alice@laptop.pub`, or any
    such variants.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add all these names to a simple file called `$HOME/.gitolite.shell-users`
    on the server. Put just one name on each line, without any extra spaces before
    or after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, edit the file `$HOME/.gitolite.rc` on the server, and uncomment the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Managing keys outside Gitolite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You do not have to let Gitolite manage the keys if you have a different method
    of managing them that you prefer. For example, you may be using an LDAP-backed
    ssh daemon, which manages users' keys centrally for several enterprise applications
    and systems, and therefore you wish to take advantage of that for Gitolite user
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitolite will work fine with any method as long as you ensure that these points
    are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SSH_ORIGINAL_COMMAND` environment variable should contain the original
    Git command that the client sent out. Typically, this will be something like `git-upload-pack
    'repo.git'` (including the single quotes) or, for pushes, `git-receive-pack 'repo.git`'.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This variable is automatically set by the ssh daemon when the ssh configuration
    specifies a forced command of some kind (please see the ssh documentation for
    details on how to force commands).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The command that is thus forced to run should be the full path to the gitolite-shell
    program, wherever you may have installed it. For example, it could be `/home/git/gitolite/src/gitolite-shell`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This program should get exactly one argument: the Gitolite username of the
    ssh-authenticated user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting user group information from LDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gitolite makes it possible to make some limited use of user data that may already
    be available in the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case for this is that the enterprise already has an LDAP
    database that contains all the users and their roles in the organization. What
    the administrator would like to do is to use this information to reduce the burden
    of giving users rights to Gitolite repositories. It would be great if the administrator
    could merely specify rights in terms of group-names and Gitolite were to somehow
    figure out which groups a user is a member of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitolite can facilitate the querying of the LDAP database and somehow acquire
    the information it needs. The solution involves writing a helper program, which
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept one Gitolite user ID as the first (and only) argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If necessary, convert this user ID in some unspecified manner to make it suitable
    for the LDAP query. For example, you may have to add specific components to the
    name for the query to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this user ID as a query parameter and query the LDAP database to get user
    details. The program that does this will need to have credentials and permission
    to query the LDAP database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the query returns, extract the user's role/group information from the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If required, again convert this group information to the names that you have
    used in Gitolite's access rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the list of groups that result, all on one line and separated by spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this program is done, save it as `$HOME/bin/ldap-query-groups` and test
    it. It's only taking one command-line argument and printing results to the terminal
    so there is no real harm in doing so, as far as Gitolite is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'After testing it, edit Gitolite''s rc file (`$HOME/.gitolite.rc`) and add the
    following line (including the trailing comma) somewhere within the definition
    of the `%RC` variable, preferably close to the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Removing users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing Gitolite users is pretty simple. Just remove all the keys pertaining
    to the user (in case they have more than one, as discussed in an earlier section)
    from a clone of the gitolite-admin repository. This should be done using the `git
    rm` command, not a plain `rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: After that, commit the change and push it.
  prefs: []
  type: TYPE_NORMAL
- en: You can confirm the removal in a couple of different ways. First, the keys you
    just removed should no longer be available in `$HOME/.gitolite/keydir` on the
    server. Second, the user should not be found if you search for the name in the
    authorized keys file (`$HOME/.ssh/authorized_keys`).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to add and remove users, as well as how to handle
    several other unusual requirements that may come up once in a while. In the next
    chapter, we will talk about adding and removing repositories.
  prefs: []
  type: TYPE_NORMAL
