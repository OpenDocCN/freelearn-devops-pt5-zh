- en: Chapter 5. Be a Puppet Master – Learn Fancy Features to Control Git's Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Having laid a perfect base by learning, practicing, and validating the concepts
    covered so far, we are ready to learn some fancy features that will build on our
    base knowledge to extend the functional usage.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn concepts that will help you to perform the following
    with respect to the content in your repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: Shortlog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why learn such fancy features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why would you need the "S" power in *Contra* or an M4 rifle in *Counter-Strike*
    when you have the default weapons?
  prefs: []
  type: TYPE_NORMAL
- en: Though you will be able to achieve the ultimate goal of killing the opponent
    even with the basic tools given to you, usage of those specialized tools facilitate
    the ease of achieving the said goal, that's why.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly these functions that we are about to learn are going to provide us
    with easy ways of controlling Git to provide data according to the various situations
    which you can decide where it fits in, based on your job role. And moreover, it's
    fun to have some ready-made tricks in your pocket to pull out when the need arises,
    making you the apt person for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn these concepts better, we need to have a repository where there are
    quite a few commits and multiple people involved in the development of the repository's
    content. So we shall download any repository from famous Git hosting sites like
    GitHub or Bitbucket itself.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I have downloaded a project called cappuccino and reduced the repository
    to fit our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: You can also download your own from the Git hosting sites specified previously
    to carry out your learning.
  prefs: []
  type: TYPE_NORMAL
- en: Shortlog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though information is wealth, sometimes Too Much Information kills the purpose
    it serves. Think about the value that is associated with the **filter option**
    in a spreadsheet application. Shortlog is one such function to command Git to
    limit the information it shows when viewing logs. It arranges all the users who
    were involved in building the data of the repository in alphabetical order mentioning
    the number of commits they made along with their commit descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – getting acquainted with shortlog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly fire up your CLI window from our `cappuccino` repository and
    try out the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – getting acquainted with shortlog](img/7522_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just listed out comments of 24 commits segregated by the authors who were
    responsible for those commits; the authors were arranged in alphabetical order
    in a single shot. Sounds compact and presentable, right?
  prefs: []
  type: TYPE_NORMAL
- en: It's not over yet! Shortlog has a few defined parameters which can be used to
    reorder or narrow down your search to extract a particular set of information
    from your logs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – parameterizing shortlog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just add the parameter `–n` toyour earlier command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – parameterizing shortlog](img/7522_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding the `–n` (numbered) parameter, what you have is an output that is
    weighted based on the number of commits instead of alphabetical ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have got the idea, let's quickly run through the remaining parameters
    which we can put to use. To get metadata such as the e-mail of the author appended
    to the existing output, we shall use the `–e` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can expect an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/7522_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wondering how you can quickly get the number of stages/commits that the repository
    has gone through from different users? Allow me to introduce the `-s` parameter,
    which should give us the count history for each user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![What just happened?](img/7522_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To summarize the parameters with their functions, refer to the following tabulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Action description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Short form | Full form |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | `--numbered` | Sorts output according to the number of commits per
    author instead of alphabetical order |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | `--summary` | Provides commit count history for each user |'
  prefs: []
  type: TYPE_TB
- en: '| `-e` | `--email` | Gets the e-mail address of each author involved in committing
    to our repository |'
  prefs: []
  type: TYPE_TB
- en: '| `-h` | `--help` | Prints a short usage message |'
  prefs: []
  type: TYPE_TB
- en: Log search – git log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In continuation with the shortlog, add a few more weapons to your arsenal that
    will aid in data extraction as per your needs. What you know about Git log from
    earlier chapters might be as a command to view commit ID and related meta-information
    alone. But what you will learn here is how flexible the logging command is by
    itself and a glimpse of what it packs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – skip commit logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly try out the following in the CLI window that we opened earlier
    from the `cappuccino` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – skip commit logs](img/7522_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though the output might look similar to the usual `git log` ones at first, when
    they are compared you will see that you have skipped off the last two commits
    from listing.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/7522_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `--skip=number` makes this possible. The `number` parameter can take any
    integer value to skip that number of commits for you.
  prefs: []
  type: TYPE_NORMAL
- en: There would be numerous situations where you would want to filter content based
    on date. This can be done with the `since`/`after` and `until`/`before` operators
    with `git log`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – filter logs with date range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After performing a `git log`, select two dates, which we shall use to filter
    in our following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – filter logs with date range](img/7522_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `--since=date` operator filters the logs starting from the specified
    date and limits it before the date specified using the `–until` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can also specify relative dates like `–since=2.days` or `--since=3.months`
    to filter the output.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering if there is a way to perform a search based on a keyword
    across commits – yes you can, with the `–grep` parameter of `git log`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – searching for a word/character match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type the following command in your CLI window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – searching for a word/character match](img/7522_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the `grep` utility associated with `git log` to search for a given
    keyword, "Merge" in our case, across the commit messages provided for different
    commits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform a search without being case sensitive, the `-i` option can be appended
    at the end of the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the parameters with their functions, refer to the following tabulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Action description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--skip=number` | Skips the number of commits in showing the log output |'
  prefs: []
  type: TYPE_TB
- en: '| `--since,after=<date>` | Shows commits made since the given date |'
  prefs: []
  type: TYPE_TB
- en: '| `--until,before=<date>` | Shows commits made until the given date |'
  prefs: []
  type: TYPE_TB
- en: '| `--grep=<pattern>` | Limits the log output matching the commit message with
    the given pattern |'
  prefs: []
  type: TYPE_TB
- en: Clean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several situations where we would need to *Ctrl* + *Z* our bloopers
    away when handling files. One classic example is in the middle of working when
    you unzip a ZIP package inside a directory that already contains some files, only
    to discover that the ZIP package straight away put those files inside the directory
    without creating a separate directory for the files which were unpacked. I see
    you nodding, and I know you're smiling.
  prefs: []
  type: TYPE_NORMAL
- en: Well, situations like these can be easily handled if the directory where you
    unzipped the zip package was watched by Git (a Git repository). Let's reproduce
    this scenario and see how it can be handled within seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – emulate the mess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP package named `readme_package.zip` from [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and place it in the `cappuccino` repository on which we have been working to learn
    these commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the contents of the ZIP right inside the `cappuccino` directory in a way
    so you see seven README files as shown in the following screenshot:![Time for
    action – emulate the mess](img/7522_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open your CLI window and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give you the current status as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – emulate the mess](img/7522_05_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully emulated the scenario of accidental unpacking as discussed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: But under Git, the files that you have unpacked are listed down as untracked
    files. This means that irrespective of the number of files that have got mixed
    because of the unzip action with your original files, Git can easily identify
    them and let you know about it.
  prefs: []
  type: TYPE_NORMAL
- en: We can remove either all or a selected few files by specifying a pattern, which
    when matched, the clean command will skip them from removal. We shall get to know
    more about this in the following *Time for action* items.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – clean up your mess with pattern match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s skip those README files from deletion and first remove the ZIP package
    which we copied and pasted inside our repository. Type the following command in
    your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – clean up your mess with pattern match](img/7522_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Git clean` needs a `force` (`–f`) operator to be specified to remove files
    that are not monitored by it, whereasthe `–e` operator takes a pattern following
    it and excludes the files matching the specified criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case `*.txt` was the pattern, which matched all the `.txt` files that
    were created in the repository as a result of unpacking, therefore the only file
    left out was the `readme_package.zip` file, which got removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can avoid specifying the `–f` parameter every time we run a `git clean` command
    if we set the `clean.requireForce` configuration variable to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – wipe out your mess completely, no exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To remove these files, which have been populated in our repository unwantedly,
    you just call for a napalm strike on them! That's right, from the earlier command
    you just exclude the exclusion part.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – wipe out your mess completely, no exceptions](img/7522_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `clean` command removes all untracked files from your current repository.
    The `–f` parameter forces `git clean` to remove those untracked files from your
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of parameters you can put to use with `git clean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Action description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Short form | Full form |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | `--force` | Removes untracked files |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` |   | Removes untracked directories along with files |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | `--dry-run` | Doesn''t remove anything, but show what will be done
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | `--quiet` | Stays quiet and only reports errors but not the files
    that were successfully removed |'
  prefs: []
  type: TYPE_TB
- en: '| `-e<pattern>` | `--exclude=<pattern>` | Excludes the files matching the specified
    pattern along with the ones specified in `.gitignore` (per directory) |'
  prefs: []
  type: TYPE_TB
- en: Tagging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tagging comes in handy when you want to mark a specific point in your history
    with some metadata and refer to it henceforth with the same tag. We have two types
    of tags in Git.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight**: This method of tagging tracks the tag name alone without worrying
    about by whom or when the tag was created. This might come in handy when you have
    only one person working on the files in your repository or if the tags that you
    create are just for simple reference of different phases that your project files
    in the repository have gone through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Annotated**: This method of tagging tracks the author''s name, time of tag
    creation, and the tag name with a description, if given. This might come in handy
    when you want a retracement to be done on the attained milestones or when you
    have multiple people working on the same repository, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you use Annotated tags, it is possible for the project owner to maintain
    authorization access over the tagging process; in advanced setups it is even possible
    to have control over who tags, when they do, and mark their authorization identity
    for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: Having said enough, let's understand it better by trying it out.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – lightweight/unannotated tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's list out the existing tags with the `cappuccino` repository by
    executing `git tag` in your CLI window. This should produce an output like the
    following:![Time for action – lightweight/unannotated tagging](img/7522_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The supplied `git tag` command has retrieved all the tags available in the repository
    and lists them in alphabetical order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s create a lightweight tag in our `cappuccino` repository by executing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there are no errors returned, your tag should have been created. You can
    verify it by doing a tag listing, which we learned in the previous step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – lightweight/unannotated tagging](img/7522_05_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Or you can visualize it by opening gitk, which will give you the following
    appearance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can open gitk either from Git Gui's repository menu or by just typing `gitk`
    in your CLI window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – lightweight/unannotated tagging](img/7522_05_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If you want to browse the changes to the files for a given commit that is tagged,
    you can either look at the bottom left of the gitk window or use `git show <tagname>`
    as shown in the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give an output as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – lightweight/unannotated tagging](img/7522_05_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully created and attached a lightweight/unannotated tag to a
    specific commit. We also learned to list out all the tags available in the repository
    and if needed, view granular level changes associated with any given tag.
  prefs: []
  type: TYPE_NORMAL
- en: We read about referencing a commit with the tag names instead of the commit
    SHA1 ID. Let's understand what this means, practically.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – referencing tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned `git checkout` as a function to travel back in history. As
    you know, this process needs the SHA1 ID of the commit, which you would like to
    visit. Now let''s see how it can be done when it comes to handling tags. Type
    the following commands in your CLI window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – referencing tags](img/7522_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We checked out to a commit made at an earlier date using the usual checkout
    (`git checkout SHA1 ID`) method but came back to the latest commit with the usage
    of the tag name associated with the commit (`edge_v1.1`).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – annotated tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having learned the method for creating an unannotated/lightweight tag, the
    process of creating an annotated tag is as simple as adding the `–a` parameter
    to it. Let''s type the following in the CLI window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the command does not return any error upon execution, it indicates that your
    annotated command has been created successfully. We have created an annotated
    tag called `Ann_v1.1`. Here `–a` denotes the annotated tag name and `–m` takes
    a string value as the description for the created tag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have created both the annotated and unannotated tag for the same
    commit so that they can be compared later.
  prefs: []
  type: TYPE_NORMAL
- en: Simple exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To verify the creation process, do a tag listing and verify that the tag that
    you created exists there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the content changes associated with the commit for which you have
    created an annotated tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To understand the difference between the lightweight and annotated tag, their
    outputs are shown side by side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple exercise](img/7522_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While creation differs a little bit, the procedure for the deletion of both
    the annotated and unannotated tags is identical. You just associate the `–d` parameter
    followed by the tag name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce an affirmation as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple exercise](img/7522_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just deleted the tags `edge_v1.1` and `Ann_v1.1`, which we created in the
    process of learning about tags inside the `cappuccino` repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `–d` parameter will delete the tag whose name is passed as an argument to
    it, irrespective of it being an annotated or unannotated tag. You can perform
    a tag list to verify this as shown in the previous image after the deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned what is and how to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use shortlog:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To sort and quantify commits made per author
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize commit logs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get metadata like e-mail addresses for each author performing commits to
    our repository
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use different parameters with `git log`, which enables us to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip the specified number of commits while displaying log entries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract data from commit logs within a date range
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for a string value across commit messages to identify commits
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we have also learned how to clean our repository in case we or
    anybody else has messed it up by injecting files into it that do not belong there.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, we also saw, in practice, how to mark the milestones of our repositories'
    content using annotated and lightweight tags.
  prefs: []
  type: TYPE_NORMAL
