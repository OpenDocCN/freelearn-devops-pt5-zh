- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and Managing Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned what containers are and how to run, stop,
    remove, list, and inspect them. We extracted the logging information of some containers,
    ran other processes inside an already running container, and finally, we dived
    deep into the anatomy of containers. Whenever we ran a container, we created it
    using a container image. In this chapter, we will familiarize ourselves with these
    container images. We will learn what they are, how to create them, and how to
    distribute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are images?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lift and shift – containerizing a legacy app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing or shipping images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name three of the most important characteristics of a container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom image by interactively changing the container layer and committing
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author a simple Dockerfile to generate a custom image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export an existing image using `docker image save` and import it into another
    Docker host using `docker` `image load`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a two-step Dockerfile that minimizes the size of the resulting image by
    only including the resulting artifacts in the final image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are images?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux, everything is a file. The whole operating system is a filesystem with
    files and folders stored on the local disk. This is an important fact to remember
    when looking at what container images are. As we will see, an image is a big tarball
    containing a filesystem. More specifically, it contains a layered filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Tarball
  prefs: []
  type: TYPE_NORMAL
- en: A tarball (also known as a `.tar` archive) is a single file that contains multiple
    files or directories. It is a common archive format that is used to distribute
    software packages and other collections of files. The `.tar` archive is usually
    compressed using gzip or another compression format to reduce its size. Tarballs
    are commonly used in Unix-like operating systems, including Linux and macOS, and
    can be unpacked using the `tar` command.
  prefs: []
  type: TYPE_NORMAL
- en: The layered filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Container images are templates from which containers are created. These images
    are not made up of just one monolithic block but are composed of many layers.
    The first layer in the image is also called the **base layer**. We can see this
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The image as a stack of layers](img/B19199_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The image as a stack of layers
  prefs: []
  type: TYPE_NORMAL
- en: Each layer contains files and folders. Each layer only contains the changes
    to the filesystem concerning the underlying layers. Docker uses a Union filesystem
    – as discussed in [*Chapter 3*](B19199_03.xhtml#_idTextAnchor057), *Mastering
    Containers* – to create a virtual filesystem out of the set of layers. A storage
    driver handles the details regarding the way these layers interact with each other.
    Different storage drivers are available that have advantages and disadvantages
    in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: The layers of a container image are all immutable. Immutable means that once
    generated, the layer cannot ever be changed. The only possible operation affecting
    the layer is its physical deletion. This immutability of layers is important because
    it opens up a tremendous number of opportunities, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we can see what a custom image for a web application,
    using Nginx as a web server, could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A sample custom image based on Alpine and Nginx](img/B19199_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A sample custom image based on Alpine and Nginx
  prefs: []
  type: TYPE_NORMAL
- en: Our base layer here consists of the Alpine Linux distribution. Then, on top
    of that, we have an **Add Nginx** layer where Nginx is added on top of Alpine.
    Finally, the third layer contains all the files that make up the web application,
    such as HTML, CSS, and JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: As has been said previously, each image starts with a base image. Typically,
    this base image is one of the official images found on Docker Hub, such as a Linux
    distro, Alpine, Ubuntu, or CentOS. However, it is also possible to create an image
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub is a public registry for container images. It is a central hub ideally
    suited for sharing public container images. The registry can be found here: [https://hub.docker.com/](https://hub.docker.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Each layer only contains the delta of changes regarding the previous set of
    layers. The content of each layer is mapped to a special folder on the host system,
    which is usually a subfolder of `/var/lib/docker/`.
  prefs: []
  type: TYPE_NORMAL
- en: Since layers are immutable, they can be cached without ever becoming stale.
    This is a big advantage, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: The writable container layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have discussed, a container image is made of a stack of immutable or
    read-only layers. When Docker Engine creates a container from such an image, it
    adds a writable container layer on top of this stack of immutable layers. Our
    stack now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The writable container layer](img/B19199_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The writable container layer
  prefs: []
  type: TYPE_NORMAL
- en: 'The container layer is marked as **read/write** (**r/w**). Another advantage
    of the immutability of image layers is that they can be shared among many containers
    created from this image. All that is needed is a thin, writable container layer
    for each container, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Multiple containers sharing the same image layers](img/B19199_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Multiple containers sharing the same image layers
  prefs: []
  type: TYPE_NORMAL
- en: This technique, of course, results in a tremendous reduction in the resources
    that are consumed. Furthermore, this helps decrease the loading time of a container
    since only a thin container layer has to be created once the image layers have
    been loaded into memory, which only happens for the first container.
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-write
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker uses the copy-on-write technique when dealing with images. Copy-on-write
    is a strategy for sharing and copying files for maximum efficiency. If a layer
    uses a file or folder that is available in one of the low-lying layers, then it
    just uses it. If, on the other hand, a layer wants to modify, say, a file from
    a low-lying layer, then it first copies this file up to the target layer and then
    modifies it. In the following figure, we can see what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Docker image using copy-on-write](img/B19199_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Docker image using copy-on-write
  prefs: []
  type: TYPE_NORMAL
- en: The second layer wants to modify **File 2**, which is present in the base layer.
    Thus, it copies it up and then modifies it. Now, let’s say that we’re sitting
    in the top layer of the preceding graphic. This layer will use **File 1** from
    the base layer and **File 2** and **File 3** from the second layer.
  prefs: []
  type: TYPE_NORMAL
- en: Graph drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph drivers are what enable the Union filesystem. Graph drivers are also called
    storage drivers and are used when dealing with layered container images. A graph
    driver consolidates multiple image layers into a root filesystem for the mount
    namespace of the container. Or, put differently, the driver controls how images
    and containers are stored and managed on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Docker supports several different graph drivers using a pluggable architecture.
    The preferred driver is **overlay2,** followed by **overlay.**
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what images are, we will learn how we can create a Docker
    image ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three ways to create a new container image on your system. The first
    one is by interactively building a container that contains all the additions and
    changes you desire, and then committing those changes into a new image. The second,
    and most important, way is to use a Dockerfile to describe what’s in the new image,
    and then build the image using that Dockerfile as a manifest. Finally, the third
    way of creating an image is by importing it into the system from a tarball.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at these three ways in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive image creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way we can create a custom image is by interactively building a container.
    That is, we start with a base image that we want to use as a template and run
    a container of it interactively. Let’s say that this is the Alpine image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to run the container would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command runs a container based on the `alpine:3.17` image.
  prefs: []
  type: TYPE_NORMAL
- en: We run the container interactively with an attached `-it` parameter, name it
    `sample` with the `--name` parameter, and finally run a shell inside the container
    using `/bin/sh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Terminal window where you ran the preceding command, you should see
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Alpine container in interactive mode](img/B19199_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Alpine container in interactive mode
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Alpine container does not have the `curl` tool installed. Let’s
    assume we want to create a new custom image that has `curl` installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, we can then run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command first updates the Alpine package manager, `apk`, and
    then it installs the `curl` tool. The output of the preceding command should look
    approximately like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Installing curl on Alpine](img/B19199_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Installing curl on Alpine
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can indeed use `curl`, as the following code snippet shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Using curl from within the container](img/B19199_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Using curl from within the container
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding command, we have contacted the Google home page, and with
    the `-I` parameter, we have told `curl` to only output the response headers.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished our customization, we can quit the container by typing
    `exit` at the prompt or hitting Ctrl + D.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if we list all containers with the `docker container ls -a` command, we
    will see that our sample container has a status of `Exited`, but still exists
    on the system, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should output something similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to see what has changed in our container concerning the base image,
    we can use the `docker container diff` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should present a list of all modifications done on the filesystem
    of the container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Output of the docker diff command (truncated)](img/B19199_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Output of the docker diff command (truncated)
  prefs: []
  type: TYPE_NORMAL
- en: We have shortened the preceding output for better readability. In the list,
    `A` stands for added, and `C` stands for changed. If we had any deleted files,
    then those would be prefixed with `D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the `docker container commit` command to persist our modifications
    and create a new image from them, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output generated by the preceding command on the author’s computer is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, we have specified that the new image will be called
    `my-alpine`. The output generated by the preceding command corresponds to the
    ID of the newly generated image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by listing all the images on our system, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see this image ID as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Listing all Docker images](img/B19199_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Listing all Docker images
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the image named `my-alpine` has the expected ID of `5287bccbb301`
    (corresponding to the first part of the full hash code) and automatically got
    a tag of `latest` assigned. This happened since we did not explicitly define a
    tag ourselves. In this case, Docker always defaults to the `latest` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to see how our custom image has been built, we can use the `history`
    command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print a list of the layers our image consists of, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – History of the my-alpine Docker image](img/B19199_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – History of the my-alpine Docker image
  prefs: []
  type: TYPE_NORMAL
- en: The top layer – marked in red – in the preceding output is the one that we just
    created by adding the `curl` package. The other two lines stem from the original
    build of the Alpine 3.17 Docker image. It was created and uploaded 4 days ago.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how we can interactively create a Docker image, let’s
    look into how we can do the same declaratively using a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dockerfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Manually creating custom images, as shown in the previous section of this chapter,
    is very helpful when doing exploration, creating prototypes, or authoring feasibility
    studies. But it has a serious drawback: it is a manual process and thus is not
    repeatable or scalable. It is also error-prone, just like any other task executed
    manually by humans. There must be a better way.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the so-called Dockerfile comes into play. A `Dockerfile` is a
    text file that, by default, is called `Dockerfile`. It contains instructions on
    how to build a custom container image. It is a declarative way of building images.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative versus imperative
  prefs: []
  type: TYPE_NORMAL
- en: In computer science in general, and with Docker specifically, you often use
    a declarative way of defining a task. You describe the expected outcome and let
    the system figure out how to achieve this goal, rather than giving step-by-step
    instructions to the system on how to achieve this desired outcome. The latter
    is an imperative approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a sample Dockerfile, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a Dockerfile as it is used to containerize a Python 3.12 application.
    As we can see, the file has six lines, each starting with a keyword such as `FROM`,
    `RUN`, or `COPY`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is a convention to write the keywords in all caps, but that is not a must.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of the Dockerfile results in a layer in the resulting image. In the
    following figure, the image is drawn upside down compared to the previous figures
    in this chapter, showing an image as a stack of layers. Here, the base layer is
    shown on top. Don’t let yourself be confused by this. In reality, the base layer
    is always the lowest in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The relationship between a Dockerfile and the layers in an
    image](img/B19199_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The relationship between a Dockerfile and the layers in an image
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the individual keywords in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The FROM keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every Dockerfile starts with the `FROM` keyword. With it, we define which base
    image we want to start building our custom image from. If we want to build starting
    with CentOS 7, for example, we would have the following line in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On Docker Hub, there are curated or official images for all major Linux distros,
    as well as for all important development frameworks or languages, such as Python,
    Node.js, Ruby, Go, and many more. Depending on our needs, we should select the
    most appropriate base image.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I want to containerize a Python 3.12 application, I might want
    to select the relevant official `python:3.12` image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to start from scratch, we can also use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful in the context of building super-minimal images that only –
    for example – contain a single binary: the actual statically linked executable,
    such as `Hello-World`. The scratch image is an empty base image.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM scratch`, in reality, is a no-op in the Dockerfile, and as such does
    not generate a layer in the resulting container image.'
  prefs: []
  type: TYPE_NORMAL
- en: The RUN keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next important keyword is `RUN`. The argument for `RUN` is any valid Linux
    command, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is using the `yum` CentOS package manager to install
    the `wget` package into the running container. This assumes that our base image
    is CentOS or **Red Hat Enterprise Linux** (**RHEL**). If we had Ubuntu as our
    base image, then the command would look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It would look like this because Ubuntu uses `apt-get` as a package manager.
    Similarly, we could define a line with `RUN`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the former creates an `/app` folder in the container and navigates to
    it, and the latter un-tars a file to a given location. It is completely fine,
    and even recommended, for you to format a Linux command using more than one physical
    line, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we use more than one line, we need to put a backslash (`\`) at the end of
    the lines to indicate to the shell that the command continues on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Try to find out what the preceding command does.
  prefs: []
  type: TYPE_NORMAL
- en: The COPY and ADD keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `COPY` and `ADD` keywords are very important since, in the end, we want
    to add some content to an existing base image to make it a custom image. Most
    of the time, these are a few source files of – say – a web application, or a few
    binaries of a compiled application.
  prefs: []
  type: TYPE_NORMAL
- en: These two keywords are used to copy files and folders from the host into the
    image that we’re building. The two keywords are very similar, with the exception
    that the `ADD` keyword also lets us copy and unpack `TAR` files, as well as provide
    an URI as a source for the files and folders to copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a few examples of how these two keywords can be used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding lines of code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line copies all files and folders from the current directory recursively
    to the `app` folder inside the container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line copies everything in the `web` subfolder to the target folder,
    `/app/web`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line copies a single file, `sample.txt`, into the target folder, `/data`,
    and at the same time, renames it `my-sample.txt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth statement unpacks the `sample.tar` file into the target folder, `/app/bin`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last statement copies the remote file, `sample.txt`, into the target
    file, `/data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wildcards are allowed in the source path. For example, the following statement
    copies all files starting with `sample` to the `mydir` folder inside the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'From a security perspective, it is important to know that, by default, all
    files and folders inside the image will have a `ADD` and `COPY`, we can change
    the ownership that the files will have inside the image using the optional `--chown`
    flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement will copy all files starting with `web` and put them
    into the `/app/data` folder in the image, and at the same time assign user 11
    and group 22 to these files.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of numbers, we could also use names for the user and group, but then
    these entities would have to be already defined in the root filesystem of the
    image at `/etc/passwd` and `/etc/group`, respectively; otherwise, the build of
    the image would fail.
  prefs: []
  type: TYPE_NORMAL
- en: The WORKDIR keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `WORKDIR` keyword defines the working directory or context that is used
    when a container is run from our custom image. So, if I want to set the context
    to the `/app/bin` folder inside the image, my expression in the Dockerfile would
    have to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All activity that happens inside the image after the preceding line will use
    this directory as the working directory. It is very important to note that the
    following two snippets from a Dockerfile are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the preceding code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The former will create the file in the root of the image filesystem, while the
    latter will create the file at the expected location in the `/app/bin` folder.
    Only the `WORKDIR` keyword sets the context across the layers of the image. The
    `cd` command alone is not persisted across layers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is completely fine to change the current working directory multiple times
    in a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The CMD and ENTRYPOINT keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CMD` and `ENTRYPOINT` keywords are special. While all other keywords defined
    for a Dockerfile are executed at the time the image is built by the Docker builder,
    these two are definitions of what will happen when a container is started from
    the image we define. When the container runtime starts a container, it needs to
    know what the process or application will be that has to run inside that container.
    That is exactly what `CMD` and `ENTRYPOINT` are used for – to tell Docker what
    the start process is and how to start that process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the differences between `CMD` and `ENTRYPOINT` are subtle, and honestly,
    most users don’t fully understand them or use them in the intended way. Luckily,
    in most cases, this is not a problem and the container will run anyway; it’s just
    handling it that is not as straightforward as it could be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how to use these two keywords, let’s analyze what a typical
    Linux command or expression looks like. Let’s take the `ping` utility as an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding expression, `ping` is the command, and `-c 3 8.8.8.8` are
    the parameters of this com[mand. Let’s look at another expression](http://example.com/downloads/script.sh)
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, in the preceding expression, `wget` is the command, and `-O - http://example.com/downloads/script.sh`
    are the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have dealt with this, we can get back to `CMD` and `ENTRYPOINT`.
    `ENTRYPOINT` is used to define the command of the expression, while `CMD` is used
    to define the parameters for the command. Thus, a Dockerfile using Alpine as the
    base image and defining `ping` as the process to run in the container could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For both `ENTRYPOINT` and `CMD`, the values are formatted as a JSON array of
    strings, where the individual items correspond to the tokens of the expression
    that are separated by whitespace. This is the preferred way of defining `CMD`
    and `ENTRYPOINT`. It is also called the exec form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use what’s called the shell form, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build an image called `pinger` from the preceding Dockerfile, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output generated by the preceeding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Building the pinger Docker image](img/B19199_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Building the pinger Docker image
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can run a container from the pinger image we just created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.14 – Output of the pinger container](img/B19199_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Output of the pinger container
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding command, we are using the `--rm` parameter, which defines that
    the container is automatically removed once the applications inside the container
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of this is that I can now override the CMD part that I have defined
    in the Dockerfile (remember, it was `["-c", "3","8.8.8.8"]`) when I create a new
    container by adding the new values at the end of the `docker container run` expression,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the container to ping the loopback IP address (`127.0.0.1`)
    for 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to override what’s defined in `ENTRYPOINT` in the Dockerfile, we
    need to use the `--entrypoint` parameter in the `docker container run` expression.
    Let’s say we want to execute a shell in the container instead of the `ping` command.
    We could do so by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will then find ourselves inside the container. Type `exit` or press *Ctrl
    + D* to leave the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I already mentioned, we do not necessarily have to follow best practices
    and define the command through `ENTRYPOINT` and the parameters through `CMD`;
    instead, we can enter the whole expression as a value of `CMD` and it will work,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I have even used the shell form to define CMD. But what happens in this
    situation if `ENTRYPOINT` is undefined? If you leave `ENTRYPOINT` undefined, then
    it will have the default value of `/bin/sh -c`, and whatever the value of `CMD`
    is will be passed as a string to the shell command. The preceding definition would
    thereby result in entering the following code to run the process inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, `/bin/sh` is the main process running inside the container, and
    it will start a new child process to run the `wget` utility.
  prefs: []
  type: TYPE_NORMAL
- en: A complex Dockerfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have discussed the most important keywords commonly used in Dockerfiles.
    Now, let’s look at a realistic and somewhat complex example of a Dockerfile. Those
    of you who are interested might note that it looks very similar to the first Dockerfile
    that we presented in this chapter. Here is its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: OK; so, what is happening here? This is a Dockerfile that is used to build an
    image for a Node.js application; we can deduce this from the fact that the `node:19-buster-slim`
    base image is used. Then, the second line is an instruction to create an `/app`
    folder in the filesystem of the image. The third line defines the working directory
    or context in the image to be this new `/app` folder. Then, on line four, we copy
    a `package.json` file into the `/app` folder inside the image. After this, on
    line five, we execute the `npm install` command inside the container; remember,
    our context is the `/app` folder, so `npm` will find the `package.json` file there
    that we copied on line four.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the Node.js dependencies have been installed, we copy the rest of the
    application files from the current folder of the host into the `/app` folder of
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last two lines, we define what the startup command will be when
    a container is run from this image. In our case, it is `npm start`, which will
    start the Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Building an image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example and build a simple Docker image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the sample code repository. Normally, this should be located in
    your home folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new subfolder for [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083)
    and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding folder, create a `sample1` subfolder and navigate to it, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your favorite editor to create a file called `Dockerfile` inside this sample
    folder, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and exit your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in the Terminal window, we can now build a new container image using the
    preceding Dockerfile as a manifest or construction plan, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please note that there is a period (`.`) at the end of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Building our first custom image from CentOS](img/B19199_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Building our first custom image from CentOS
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous command means that the Docker builder creates a new image called
    `my-centos` using the Dockerfile that is present in the current directory. Here,
    the period at the end of the command specifies the current directory. We could
    also write the preceding command as follows, with the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can omit the `-f` parameter since the builder assumes that the Dockerfile
    is called `Dockerfile`. We only ever need the `-f` parameter if our Dockerfile
    has a different name or is not located in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the output shown in *Figure 4**.15*. This output is created by
    the Docker build kit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line is generated at the end of the build process, although it appears
    as the first line. It tells us that the building took approximately 22 seconds
    and was executed in 7 steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s skip the next few lines until we reach this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line tells us which line of the Dockerfile the builder is currently executing
    (1 of 2). We can see that this is the `FROM centos:7` statement in our Dockerfile.
    This is the declaration of the base image, on top of which we want to build our
    custom image. What the builder then does is pull this image from Docker Hub, if
    it is not already available in the local cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow the next step. I have shortened it even more than the preceding
    one to concentrate on the essential part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is our second line in the Dockerfile, where we want to use the `yum` package
    manager to install the `wget` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last few lines are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the builder finalizes building the image and provides the image with the
    `sha256` code of `8eb6daefac9...`.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that the resulting custom image has been given an ID of `8eb6daefac9...`
    and has been tagged with `my-centos:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have analyzed how the build process of a Docker image works and
    what steps are involved, let’s talk about how to further improve this by introducing
    multi-step builds.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-step builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate why a Dockerfile with multiple build steps is useful, let’s
    make an example Dockerfile. Let’s take a Hello World application written in C:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal window and navigate to this chapter’s folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new folder called `multi-step-build` in your chapter folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code for this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `hello.c` in this folder and add the following code to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we want to containerize this application and write a Dockerfile with this
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s build this image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives us a fairly long output since the builder has to install the Alpine
    **Software Development Kit** (**SDK**), which, among other tools, contains the
    C++ compiler we need to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build is done, we can list the image and see the size that’s been
    shown, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the author’s case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With a size of 215 MB, the resulting image is way too big. In the end, it is
    just a Hello World application. The reason for it being so big is that the image
    not only contains the Hello World binary but also all the tools to compile and
    link the application from the source code. But this is not desirable when running
    the application, say, in production. Ideally, we only want to have the resulting
    binary in the image and not a whole SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is precisely for this reason that we should define Dockerfiles as multi-stage.
    We have some stages that are used to build the final artifacts, and then a final
    stage, where we use the minimal necessary base image and copy the artifacts into
    it. This results in very small Docker images. Let’s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Dockerfile to your folder called `Dockerfile.multi-step` with
    this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have the first stage with an alias called `build`, which is used to
    compile the application; then, the second stage uses the same `alpine:3.12` base
    image but does not install the SDK, and only copies the binary from the `build`
    stage, using the `--from` parameter, into this final image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the image again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s compare the sizes of the images with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We have been able to reduce the size from 215 MB down to 5.34 MB. This is a
    reduction in size by a factor of approximately 40\. A smaller image has many advantages,
    such as a smaller attack surface area for hackers, reduced memory and disk consumption,
    faster startup times for the corresponding containers, and a reduction of the
    bandwidth needed to download the image from a registry, such as Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few recommended best practices to consider when authoring a Dockerfile,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we need to consider that containers are meant to be ephemeral.
    By ephemeral, we mean that a container can be stopped and destroyed, and a new
    one built and put in place with the absolute minimum setup and configuration.
    That means that we should try hard to keep the time that is needed to initialize
    the application running inside the container at a minimum, as well as the time
    needed to terminate or clean up the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next best practice tells us that we should order the individual commands
    in the Dockerfile so that we leverage caching as much as possible. Building a
    layer of an image can take a considerable amount of time – sometimes many seconds,
    or even minutes. While developing an application, we will have to build the container
    image for our application multiple times. We want to keep the build times at a
    minimum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we’re rebuilding a previously built image, the only layers that are rebuilt
    are the ones that have changed, but if one layer needs to be rebuilt, all subsequent
    layers also need to be rebuilt. This is very important to remember. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `npm install` command on line five of the Dockerfile usually
    takes the longest. A classical Node.js application has many external dependencies,
    and those are all downloaded and installed in this step. It can take minutes until
    it is done. Therefore, we want to avoid running `npm install` each time we rebuild
    the image, but a developer changes their source code all the time during the development
    of an application. That means that line four, the result of the `COPY` command,
    changes every time, and thus this layer has to be rebuilt. But as we discussed
    previously, that also means that all subsequent layers have to be rebuilt, which
    – in this case – includes the `npm install` command. To avoid this, we can slightly
    modify the Dockerfile and have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, on line four, we only copied the single file that the `npm install` command
    needs as a source, which is the `package.json` file. This file rarely changes
    in a typical development process. As a consequence, the `npm install` command
    also has to be executed only when the `package.json` file changes. All the remaining
    frequently changed content is added to the image after the `npm` `install` command.
  prefs: []
  type: TYPE_NORMAL
- en: A further best practice is to keep the number of layers that make up your image
    relatively small. The more layers an image has, the more the graph driver needs
    to work to consolidate the layers into a single root filesystem for the corresponding
    container. Of course, this takes time, and thus the fewer layers an image has,
    the faster the startup time for the container can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we keep our number of layers low? Remember that in a Dockerfile,
    each line that starts with a keyword such as `FROM`, `COPY`, or `RUN` creates
    a new layer. The easiest way to reduce the number of layers is to combine multiple
    individual `RUN` commands into a single one. For example, say that we had the
    following in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We could combine these into a single concatenated expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The former will generate three layers in the resulting image, while the latter
    will only create a single layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three best practices all result in smaller images. Why is this important?
    Smaller images reduce the time and bandwidth needed to download the image from
    a registry. They also reduce the amount of disk space needed to store a copy locally
    on the Docker host and the memory needed to load the image. Finally, smaller images
    also mean a smaller attack surface for hackers. Here are the best practices mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: The first best practice that helps reduce the image size is to use a `.dockerignore`
    file. We want to avoid copying unnecessary files and folders into an image, to
    keep it as lean as possible. A `.dockerignore` file works in the same way as a
    `.gitignore` file, for those who are familiar with Git. In a `.dockerignore` file,
    we can configure patterns to exclude certain files or folders from being included
    in the context when building the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next best practice is to avoid installing unnecessary packages into the
    filesystem of the image. Once again, this is to keep the image as lean as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, it is recommended that you use multi-stage builds so that
    the resulting image is as small as possible and only contains the absolute minimum
    needed to run your application or application service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to create a Docker image from
    a previously saved image. In fact, it may look like restoring an image.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third way to create a new container image is by importing or loading it
    from a file. A container image is nothing more than a tarball. To demonstrate
    this, we can use the `docker image save` command to export an existing image to
    a tarball, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command takes our `my-alpine` image that we previously built
    and exports it into a file called `./backup/my-alpine.tar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Exporting an image as a tarball](img/B19199_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Exporting an image as a tarball
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we have an existing tarball and want to import it as
    an image into our system, we can use the `docker image load` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have learned how to build a Docker image in three different ways.
    We can do so interactively, by defining a Dockerfile, or by importing it into
    our system from a tarball.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how we can create Docker images for existing
    legacy applications, and thus run them in a container and profit from this.
  prefs: []
  type: TYPE_NORMAL
- en: Lift and shift – containerizing a legacy app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can’t always start from scratch and develop a brand-new application. More
    often than not, we find ourselves with a huge portfolio of traditional applications
    that are up and running in production and provide mission-critical value to the
    company or the customers of the company. Often, those applications are organically
    grown and very complex. Documentation is sparse, and nobody wants to touch such
    an application. Often, the saying “*Never touch a running system”* applies. Yet,
    the market needs change, and with that arises the need to update or rewrite those
    apps. Often, a complete rewrite is not possible due to the lack of resources and
    time, or due to the excessive cost. What are we going to do about those applications?
    Could we possibly Dockerize them and profit from the benefits introduced by containers?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out we can. In 2017, Docker introduced a program called **Modernize
    Traditional Apps** (**MTA**) to their enterprise customers, which in essence promised
    to help those customers take their existing or traditional Java and .NET applications
    and containerize them, without the need to change a single line of code. The focus
    of MTA was on Java and .NET applications since those made up the lion’s share
    of the traditional applications in a typical enterprise. But it can also be used
    for any application that was written in – say – C, C++, Python, Node.js, Ruby,
    PHP, or Go, to name just a few other languages and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine such a legacy application for a moment. Let’s assume we have an
    old Java application that was written 10 years ago and that was continuously updated
    during the following 5 years. The application is based on Java SE 6, which came
    out in December 2006\. It uses environment variables and property files for configuration.
    Secrets such as usernames and passwords used in the database connection strings
    are pulled from a secrets keystore, such as HashiCorp Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s describe each of the required steps to lift and shift a legacy application
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing external dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first steps in the modernization process is to discover and list
    all external dependencies of the legacy application:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it use a database? If so, which one? What does the connection string look
    like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it use external APIs such as credit card approval or geo-mapping APIs?
    What are the API keys and key secrets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it consuming from or publishing to an **Enterprise Service** **Bus** (**ESB**)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few possible dependencies that come to mind. Many more exist.
    These are the seams of the application to the outer world, and we need to be aware
    of them and create an inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Source code and build instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to locate all the source code and other assets, such as images
    and CSS and HTML files that are part of the application. Ideally, they should
    be located in a single folder. This folder will be the root of our project and
    can have as many subfolders as needed. This project root folder will be the context
    during the build of the container image we want to create for our legacy application.
    Remember, the Docker builder only includes files in the build that are part of
    that context; in our case, that is the root project folder.
  prefs: []
  type: TYPE_NORMAL
- en: There is, though, an option to download or copy files during the build from
    different locations, using the `COPY` or `ADD` commands. Please refer to the online
    documentation for the exact details on how to use these two commands. This option
    is useful if the sources for your legacy application cannot be easily contained
    in a single, local folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are aware of all the parts that contribute to the final application,
    we need to investigate how the application is built and packaged. In our case,
    this is most probably done by using `make` would most likely be used.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, let’s extend our inventory and write down the exact build commands
    used. We will need this information later on when authoring the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications need to be configured. Information provided during configuration
    could be – for example – the type of application logging to use, connection strings
    to databases, and hostnames to services such as ESBs or URIs to external APIs,
    to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can differentiate a few types of configurations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build time**: This is the information needed during the build of the application
    and/or its Docker image. It needs to be available when we create the Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEVELOPMENT` versus `STAGING` or `PRODUCTION`. This kind of configuration
    is applied to the application when a container with the app starts – for example,
    in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: This is information that the application retrieves during runtime,
    such as secrets to access an external API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every mission-critical enterprise application needs to deal with secrets in
    some form or another. The most familiar secrets are part of the connection information
    needed to access databases that are used to persist the data produced by or used
    by the application. Other secrets include the credentials needed to access external
    APIs, such as a credit score lookup API. It is important to note that, here, we
    are talking about secrets that have to be provided by the application itself to
    the service providers the application uses or depends on, and not secrets provided
    by the users of the application. The actor here is our application, which needs
    to be authenticated and authorized by external authorities and service providers.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways traditional applications got their secrets. The worst
    and most insecure way of providing secrets is by hardcoding them or reading them
    from configuration files or environment variables, where they are available in
    cleartext. A much better way is to read the secrets during runtime from a special
    secret store that persists the secrets encrypted and provides them to the application
    over a secure connection, such as **Transport Layer** **Security** (**TLS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we need to create an inventory of all the secrets that our application
    uses and the way it procures them. Thus, we need to ask ourselves where we can
    get our secrets from: is it through environment variables or configuration files,
    or is it by accessing an external keystore, such as HashiCorp Vault, AWS Secrets
    Manager, or Azure Key Vault?'
  prefs: []
  type: TYPE_NORMAL
- en: Authoring the Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have a complete inventory of all the items we discussed in the previous
    few sections, we are ready to author our Dockerfile. But I want to warn you: don’t
    expect this to be a one-shot-and-go task. You may need several iterations until
    you have crafted your final Dockerfile. The Dockerfile may be rather long and
    ugly-looking, but that’s not a problem, so long as we get a working Docker image.
    We can always fine-tune the Dockerfile once we have a working version.'
  prefs: []
  type: TYPE_NORMAL
- en: The base image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by identifying the base image we want to use and build our image
    from. Is there an official Java image available that is compatible with our requirements?
    Remember that our application is based on Java SE 6\. If such a base image is
    available, then we should use that one. Otherwise, we will want to start with
    a Linux distro such as Red Hat, Oracle, or Ubuntu. In the latter case, we will
    use the appropriate package manager of the distro (`yum`, `apt`, or another) to
    install the desired versions of Java and Maven. For this, we can use the `RUN`
    keyword in the Dockerfile. Remember, `RUN` allows us to execute any valid Linux
    command in the image during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this step, we make sure all the source files and other artifacts needed
    to successfully build the application are part of the image. Here, we mainly use
    the two keywords of the Dockerfile: `COPY` and `ADD`. Initially, the structure
    of the source inside the image should look the same as on the host, to avoid any
    build problems. Ideally, you would have a single `COPY` command that copies all
    of the root project folders from the host into the image. The corresponding Dockerfile
    snippet could then look as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to also provide a `.dockerignore` file, which is located in the
    project root folder, which lists all the files and (sub)folders of the project
    root folder that should not be part of the build context.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, you can also use the `ADD` keyword to download sources
    and other artifacts into the Docker image that are not located in the build context
    but somewhere reachable by a URI, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This would create a `foobar` folder in the image’s working folder and copy all
    the contents from the URI.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this step, we make sure to create the final artifacts that make up our executable
    legacy application. Often, this is a `JAR` or `WAR` file, with or without some
    satellite JARs. This part of the Dockerfile should mimic the way you traditionally
    used to build an application before containerizing it. Thus, if you’re using Maven
    as your build automation tool, the corresponding snippet of the Dockerfile could
    look as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step, we may also want to list the environment variables the application
    uses and provide sensible defaults. But never provide default values for environment
    variables that provide secrets to the application, such as the database connection
    string! Use the `ENV` keyword to define your variables, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, declare all ports that the application is listening on and that need
    to be accessible from outside of the container via the `EXPOSE` keyword, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will explain the `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the start command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, a Java application is started with a command such as `java -jar <mainapplication
    jar>` if it is a standalone application. If it is a WAR file, then the `start`
    command may look a bit different. Therefore, we can either define `ENTRYPOINT`
    or `CMD` to use this command. Thus, the final statement in our Dockerfile could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, though, this is too simplistic, and we need to execute a few pre-run
    tasks. In this case, we can craft a script file that contains the series of commands
    that need to be executed to prepare the environment and run the application. Such
    a file is often called `docker-entrypoint``.sh`, but you are free to name it however
    you want. Make sure the file is executable – for example, run the following command
    on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of the Dockerfile would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have been given hints on how to containerize a legacy application,
    it is time to recap and ask ourselves, is it worth the effort?
  prefs: []
  type: TYPE_NORMAL
- en: Why bother?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, I can see you scratching your head and asking yourself: why
    bother? Why should you take on this seemingly huge effort just to containerize
    a legacy application? What are the benefits?'
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the **return on investment** (**ROI**) is huge. Enterprise
    customers of Docker have publicly disclosed at conferences such as DockerCon 2018
    and 2019 that they are seeing these two main benefits of Dockerizing traditional
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: More than a 50% saving in maintenance costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to a 90% reduction in the time between the deployments of new releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The costs saved by reducing the maintenance overhead can be directly reinvested
    and used to develop new features and products. The time saved during new releases
    of traditional applications makes a business more agile and able to react to changing
    customer or market needs more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed how to build Docker images at length, it is time
    to learn how we can ship those images through the various stages of the software
    delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing or shipping images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to ship our custom image to other environments, we need to give it
    a globally unique name. This action is often called **tagging an image**. We then
    need to publish the image to a central location from which other interested or
    entitled parties can pull it. These central locations are called **image registries**.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will describe how this works in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging an image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each image has a so-called tag. A tag is often used to version images, but
    it has a broader reach than just being a version number. If we do not explicitly
    specify a tag when working with images, then Docker automatically assumes we’re
    referring to the latest tag. This is relevant when pulling an image from Docker
    Hub, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will pull the `alpine:latest` image from Docker Hub.
    If we want to explicitly specify a tag, we can do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will pull the Alpine image that has been tagged with `3.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying image namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have pulled various images and haven’t worried so much about where
    those images originated from. Your Docker environment is configured so that, by
    default, all images are pulled from Docker Hub. We also only pulled so-called
    official images from Docker Hub, such as `alpine` or `busybox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to widen our horizons a bit and learn about how images are
    namespaced. The most generic way to define an image is by its fully qualified
    name, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at this in a bit more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `<``registry URL>` | This is the URL to the registry from which we want to
    pull the image. By default, this is `docker.io`. More generally, this could be
    [https://registry.acme.com](https://registry.acme.com).Other than Docker Hub,
    there are quite a few public registries out there that you could pull images from.
    The following is a list of some of them, in no particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: Google, at [https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon AWS Amazon **Elastic Container Registry** (**ECR**), at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure, at [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat, at [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artifactory, at [https://jfrog.com/integration/artifactorydocker-registry/](https://jfrog.com/integration/artifactorydocker-registry/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `<User>` or `<Org>` | This is the private Docker ID of either an individual
    or an organization defined on Docker Hub – or any other registry, for that matter,
    such as `microsoft` or `oracle`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<``name>` | This is the name of the image, which is often also called a
    repository. |'
  prefs: []
  type: TYPE_TB
- en: '| `<``tag>` | This is the tag of the image. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an image, `web-app`, that is tagged with version `1.0` and belongs
    to the `engineering` organization on the private registry at `https://registry.acme.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are some special conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: If we omit the registry URL, then Docker Hub is automatically taken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we omit the tag, then the `latest` tag is taken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is an official image on Docker Hub, then no user or organization namespace
    is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few samples in tabular form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Image** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `alpine` | The official `alpine` image on Docker Hub with the `latest` tag.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ubuntu:22.04` | The official `ubuntu` image on Docker Hub with the `22.04`
    tag or version. |'
  prefs: []
  type: TYPE_TB
- en: '| `hashicorp/vault` | The `vault` image of an organization called `hashicorp`
    on Docker Hub with the `latest` tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `acme/web-api:12.0` | The `web-api` image version of `12.0` that’s associated
    with the `acme` org. The image is on Docker Hub. |'
  prefs: []
  type: TYPE_TB
- en: '| `gcr.io/jdoe/sample-app:1.1` | The `sample-app` image with the `1.1` tag
    belonging to an individual with the `jdoe` ID in Google’s container registry.
    |'
  prefs: []
  type: TYPE_TB
- en: Now that we know how the fully qualified name of a Docker image is defined and
    what its parts are, let’s talk about some special images we can find on Docker
    Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining official images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding table, we mentioned “official image” a few times. This needs
    an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Images are stored in repositories on the Docker Hub registry. Official repositories
    are a set of repositories hosted on Docker Hub that are curated by individuals
    or organizations that are also responsible for the software packaged inside the
    image. Let’s look at an example of what that means. There is an official organization
    behind the Ubuntu Linux distro. This team also provides official versions of Docker
    images that contain their Ubuntu distros.
  prefs: []
  type: TYPE_NORMAL
- en: Official images are meant to provide essential base OS repositories, images
    for popular programming language runtimes, frequently used data storage, and other
    important services.
  prefs: []
  type: TYPE_NORMAL
- en: Docker sponsors a team whose task is to review and publish all those curated
    images in public repositories on Docker Hub. Furthermore, Docker scans all official
    images for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images to a registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating custom images is all well and good, but at some point, we want to share
    or ship our images to a target environment, such as a test, **quality assurance**
    (**QA**), or production system. For this, we typically use a container registry.
    One of the most popular public registries out there is Docker Hub. It is configured
    as a default registry in your Docker environment, and it is the registry from
    which we have pulled all our images so far.
  prefs: []
  type: TYPE_NORMAL
- en: In a registry, we can usually create personal or organizational accounts. For
    example, the author’s account at Docker Hub is `gnschenker`. Personal accounts
    are good for personal use. If we want to use the registry professionally, then
    we’ll probably want to create an organizational account, such as `acme`, on Docker
    Hub. The advantage of the latter is that organizations can have multiple teams.
    Teams can have differing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to push an image to my account on Docker Hub, I need to tag it accordingly.
    Let’s say I want to push the latest version of the Alpine image to my account
    and give it a tag of `1.0`. I can do this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tag the existing image, `alpine:latest`, with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, Docker does not create a new image but creates a new reference to the
    existing image, `alpine:latest`, and names it `gnschenker/alpine:1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to be able to push the image, I have to log in to my account, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace `gnschenker` with your own Docker Hub username and `<my
    secret password>` with your password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a successful login, I can then push the image, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I will see something similar to this in the Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: For each image that we push to Docker Hub, we automatically create a repository.
    A repository can be private or public. Everyone can pull an image from a public
    repository. From a private repository, an image can only be pulled if you are
    logged in to the registry and have the necessary permissions configured.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what container images are and how we can build
    and ship them. As we have seen, there are three different ways that an image can
    be created – either manually, automatically, or by importing a tarball into the
    system. We also learned some of the best practices commonly used when building
    custom images. Finally, we got a quick introduction to how to share or ship custom
    images by uploading them to a container image registry such as Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to introduce Docker volumes, which can be used
    to persist the state of a container. We’ll also show you how to define individual
    environment variables for the application running inside the container, as well
    as how to use files containing whole sets of configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please try to answer the following questions to assess your learning progress:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you create a Dockerfile that inherits from Ubuntu version 22.04, and
    that installs `ping` and runs `ping` when a container starts? The default address
    used to ping should be `127.0.0.1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you create a new container image that uses `alpine:latest` as a base
    image and installs `curl` on top of it? Name the new image `my-alpine:1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Dockerfile that uses multiple steps to create an image of a Hello World
    app of minimal size, written in C or Go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three essential characteristics of a Docker container image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to push an image named `foo:1.0` to your `jdoe` personal account on
    Docker Hub. Which of the following is the right solution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker container` `push foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image` `push jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker login -u jdoe -p <``your password>`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image` `push jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker login -u jdoe -p <``your password>`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker container tag` `foo:1.0 jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker container` `push jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker login -u jdoe -p <``your password>`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image push` `foo:1.0 jdoe/foo:1.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are possible answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that in Ubuntu, the `ping` tool is part of the `iputils-ping` package.
    You can build the image called pinger – for example – with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dockerfile could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the image with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dockerfile for a Go application could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find the full solution in the `~/The-Ultimate-Docker-Container-Book/sample-solutions/ch04/answer03`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Docker image has the following characteristics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is immutable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It consists of one-to-many layers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains the files and folders needed for the packaged application to run
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct answer is *C*. First, you need to log in to Docker Hub; then, you
    must tag your image correctly with the username. Finally, you must push the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
