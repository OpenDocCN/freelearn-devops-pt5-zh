- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and Managing Container Images
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned what containers are and how to run, stop,
    remove, list, and inspect them. We extracted the logging information of some containers,
    ran other processes inside an already running container, and finally, we dived
    deep into the anatomy of containers. Whenever we ran a container, we created it
    using a container image. In this chapter, we will familiarize ourselves with these
    container images. We will learn what they are, how to create them, and how to
    distribute them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What are images?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lift and shift – containerizing a legacy app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing or shipping images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Name three of the most important characteristics of a container image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom image by interactively changing the container layer and committing
    it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author a simple Dockerfile to generate a custom image
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export an existing image using `docker image save` and import it into another
    Docker host using `docker` `image load`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a two-step Dockerfile that minimizes the size of the resulting image by
    only including the resulting artifacts in the final image
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are images?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux, everything is a file. The whole operating system is a filesystem with
    files and folders stored on the local disk. This is an important fact to remember
    when looking at what container images are. As we will see, an image is a big tarball
    containing a filesystem. More specifically, it contains a layered filesystem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Tarball
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: A tarball (also known as a `.tar` archive) is a single file that contains multiple
    files or directories. It is a common archive format that is used to distribute
    software packages and other collections of files. The `.tar` archive is usually
    compressed using gzip or another compression format to reduce its size. Tarballs
    are commonly used in Unix-like operating systems, including Linux and macOS, and
    can be unpacked using the `tar` command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The layered filesystem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Container images are templates from which containers are created. These images
    are not made up of just one monolithic block but are composed of many layers.
    The first layer in the image is also called the **base layer**. We can see this
    in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The image as a stack of layers](img/B19199_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The image as a stack of layers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Each layer contains files and folders. Each layer only contains the changes
    to the filesystem concerning the underlying layers. Docker uses a Union filesystem
    – as discussed in [*Chapter 3*](B19199_03.xhtml#_idTextAnchor057), *Mastering
    Containers* – to create a virtual filesystem out of the set of layers. A storage
    driver handles the details regarding the way these layers interact with each other.
    Different storage drivers are available that have advantages and disadvantages
    in different situations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The layers of a container image are all immutable. Immutable means that once
    generated, the layer cannot ever be changed. The only possible operation affecting
    the layer is its physical deletion. This immutability of layers is important because
    it opens up a tremendous number of opportunities, as we will see.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we can see what a custom image for a web application,
    using Nginx as a web server, could look like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A sample custom image based on Alpine and Nginx](img/B19199_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A sample custom image based on Alpine and Nginx
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Our base layer here consists of the Alpine Linux distribution. Then, on top
    of that, we have an **Add Nginx** layer where Nginx is added on top of Alpine.
    Finally, the third layer contains all the files that make up the web application,
    such as HTML, CSS, and JavaScript files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: As has been said previously, each image starts with a base image. Typically,
    this base image is one of the official images found on Docker Hub, such as a Linux
    distro, Alpine, Ubuntu, or CentOS. However, it is also possible to create an image
    from scratch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub is a public registry for container images. It is a central hub ideally
    suited for sharing public container images. The registry can be found here: [https://hub.docker.com/](https://hub.docker.com/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Each layer only contains the delta of changes regarding the previous set of
    layers. The content of each layer is mapped to a special folder on the host system,
    which is usually a subfolder of `/var/lib/docker/`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Since layers are immutable, they can be cached without ever becoming stale.
    This is a big advantage, as we will see.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The writable container layer
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have discussed, a container image is made of a stack of immutable or
    read-only layers. When Docker Engine creates a container from such an image, it
    adds a writable container layer on top of this stack of immutable layers. Our
    stack now looks as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The writable container layer](img/B19199_04_03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The writable container layer
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The container layer is marked as **read/write** (**r/w**). Another advantage
    of the immutability of image layers is that they can be shared among many containers
    created from this image. All that is needed is a thin, writable container layer
    for each container, as shown in the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Multiple containers sharing the same image layers](img/B19199_04_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Multiple containers sharing the same image layers
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This technique, of course, results in a tremendous reduction in the resources
    that are consumed. Furthermore, this helps decrease the loading time of a container
    since only a thin container layer has to be created once the image layers have
    been loaded into memory, which only happens for the first container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-write
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker uses the copy-on-write technique when dealing with images. Copy-on-write
    is a strategy for sharing and copying files for maximum efficiency. If a layer
    uses a file or folder that is available in one of the low-lying layers, then it
    just uses it. If, on the other hand, a layer wants to modify, say, a file from
    a low-lying layer, then it first copies this file up to the target layer and then
    modifies it. In the following figure, we can see what this means:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Docker image using copy-on-write](img/B19199_04_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Docker image using copy-on-write
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The second layer wants to modify **File 2**, which is present in the base layer.
    Thus, it copies it up and then modifies it. Now, let’s say that we’re sitting
    in the top layer of the preceding graphic. This layer will use **File 1** from
    the base layer and **File 2** and **File 3** from the second layer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Graph drivers
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph drivers are what enable the Union filesystem. Graph drivers are also called
    storage drivers and are used when dealing with layered container images. A graph
    driver consolidates multiple image layers into a root filesystem for the mount
    namespace of the container. Or, put differently, the driver controls how images
    and containers are stored and managed on the Docker host.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Docker supports several different graph drivers using a pluggable architecture.
    The preferred driver is **overlay2,** followed by **overlay.**
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what images are, we will learn how we can create a Docker
    image ourselves.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Creating Docker images
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three ways to create a new container image on your system. The first
    one is by interactively building a container that contains all the additions and
    changes you desire, and then committing those changes into a new image. The second,
    and most important, way is to use a Dockerfile to describe what’s in the new image,
    and then build the image using that Dockerfile as a manifest. Finally, the third
    way of creating an image is by importing it into the system from a tarball.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at these three ways in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Interactive image creation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way we can create a custom image is by interactively building a container.
    That is, we start with a base image that we want to use as a template and run
    a container of it interactively. Let’s say that this is the Alpine image:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to run the container would be as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command runs a container based on the `alpine:3.17` image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We run the container interactively with an attached `-it` parameter, name it
    `sample` with the `--name` parameter, and finally run a shell inside the container
    using `/bin/sh`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Terminal window where you ran the preceding command, you should see
    something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Alpine container in interactive mode](img/B19199_04_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Alpine container in interactive mode
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Alpine container does not have the `curl` tool installed. Let’s
    assume we want to create a new custom image that has `curl` installed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, we can then run the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command first updates the Alpine package manager, `apk`, and
    then it installs the `curl` tool. The output of the preceding command should look
    approximately like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Installing curl on Alpine](img/B19199_04_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Installing curl on Alpine
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can indeed use `curl`, as the following code snippet shows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Using curl from within the container](img/B19199_04_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Using curl from within the container
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding command, we have contacted the Google home page, and with
    the `-I` parameter, we have told `curl` to only output the response headers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished our customization, we can quit the container by typing
    `exit` at the prompt or hitting Ctrl + D.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if we list all containers with the `docker container ls -a` command, we
    will see that our sample container has a status of `Exited`, but still exists
    on the system, as shown in the following code block:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should output something similar to this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to see what has changed in our container concerning the base image,
    we can use the `docker container diff` command, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should present a list of all modifications done on the filesystem
    of the container, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Output of the docker diff command (truncated)](img/B19199_04_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Output of the docker diff command (truncated)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: We have shortened the preceding output for better readability. In the list,
    `A` stands for added, and `C` stands for changed. If we had any deleted files,
    then those would be prefixed with `D`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the `docker container commit` command to persist our modifications
    and create a new image from them, like this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output generated by the preceding command on the author’s computer is as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the preceding command, we have specified that the new image will be called
    `my-alpine`. The output generated by the preceding command corresponds to the
    ID of the newly generated image.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by listing all the images on our system, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see this image ID as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Listing all Docker images](img/B19199_04_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Listing all Docker images
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the image named `my-alpine` has the expected ID of `5287bccbb301`
    (corresponding to the first part of the full hash code) and automatically got
    a tag of `latest` assigned. This happened since we did not explicitly define a
    tag ourselves. In this case, Docker always defaults to the `latest` tag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to see how our custom image has been built, we can use the `history`
    command, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will print a list of the layers our image consists of, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – History of the my-alpine Docker image](img/B19199_04_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – History of the my-alpine Docker image
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The top layer – marked in red – in the preceding output is the one that we just
    created by adding the `curl` package. The other two lines stem from the original
    build of the Alpine 3.17 Docker image. It was created and uploaded 4 days ago.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how we can interactively create a Docker image, let’s
    look into how we can do the same declaratively using a Dockerfile.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Using Dockerfiles
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Manually creating custom images, as shown in the previous section of this chapter,
    is very helpful when doing exploration, creating prototypes, or authoring feasibility
    studies. But it has a serious drawback: it is a manual process and thus is not
    repeatable or scalable. It is also error-prone, just like any other task executed
    manually by humans. There must be a better way.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: This is where the so-called Dockerfile comes into play. A `Dockerfile` is a
    text file that, by default, is called `Dockerfile`. It contains instructions on
    how to build a custom container image. It is a declarative way of building images.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Declarative versus imperative
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In computer science in general, and with Docker specifically, you often use
    a declarative way of defining a task. You describe the expected outcome and let
    the system figure out how to achieve this goal, rather than giving step-by-step
    instructions to the system on how to achieve this desired outcome. The latter
    is an imperative approach.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a sample Dockerfile, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a Dockerfile as it is used to containerize a Python 3.12 application.
    As we can see, the file has six lines, each starting with a keyword such as `FROM`,
    `RUN`, or `COPY`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: It is a convention to write the keywords in all caps, but that is not a must.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of the Dockerfile results in a layer in the resulting image. In the
    following figure, the image is drawn upside down compared to the previous figures
    in this chapter, showing an image as a stack of layers. Here, the base layer is
    shown on top. Don’t let yourself be confused by this. In reality, the base layer
    is always the lowest in the stack:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The relationship between a Dockerfile and the layers in an
    image](img/B19199_04_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The relationship between a Dockerfile and the layers in an image
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the individual keywords in more detail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The FROM keyword
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every Dockerfile starts with the `FROM` keyword. With it, we define which base
    image we want to start building our custom image from. If we want to build starting
    with CentOS 7, for example, we would have the following line in the Dockerfile:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On Docker Hub, there are curated or official images for all major Linux distros,
    as well as for all important development frameworks or languages, such as Python,
    Node.js, Ruby, Go, and many more. Depending on our needs, we should select the
    most appropriate base image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I want to containerize a Python 3.12 application, I might want
    to select the relevant official `python:3.12` image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想将一个Python 3.12应用程序容器化，我可能会选择相关的官方`python:3.12`镜像。
- en: 'If we want to start from scratch, we can also use the following statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从头开始，也可以使用以下语句：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is useful in the context of building super-minimal images that only –
    for example – contain a single binary: the actual statically linked executable,
    such as `Hello-World`. The scratch image is an empty base image.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建超简小镜像时非常有用，这些镜像仅包含一个二进制文件——例如——实际的静态链接可执行文件，如`Hello-World`。`scratch`镜像是一个空的基础镜像。
- en: '`FROM scratch`, in reality, is a no-op in the Dockerfile, and as such does
    not generate a layer in the resulting container image.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM scratch`实际上在Dockerfile中是一个无操作命令，因此不会在最终的容器镜像中生成层。'
- en: The RUN keyword
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RUN关键字
- en: 'The next important keyword is `RUN`. The argument for `RUN` is any valid Linux
    command, such as the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的关键字是`RUN`。`RUN`的参数是任何有效的Linux命令，例如以下内容：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding command is using the `yum` CentOS package manager to install
    the `wget` package into the running container. This assumes that our base image
    is CentOS or **Red Hat Enterprise Linux** (**RHEL**). If we had Ubuntu as our
    base image, then the command would look similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用`yum` CentOS包管理器将`wget`包安装到正在运行的容器中。假设我们的基础镜像是CentOS或**红帽企业Linux**（**RHEL**）。如果我们的基础镜像是Ubuntu，那么命令会类似如下：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It would look like this because Ubuntu uses `apt-get` as a package manager.
    Similarly, we could define a line with `RUN`, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它会像这样，因为Ubuntu使用`apt-get`作为包管理器。同样，我们也可以使用`RUN`定义一个类似的命令，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We could also do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样做：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, the former creates an `/app` folder in the container and navigates to
    it, and the latter un-tars a file to a given location. It is completely fine,
    and even recommended, for you to format a Linux command using more than one physical
    line, such as this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，前者在容器中创建一个`/app`文件夹并切换到该目录，后者将一个文件解包到指定位置。完全可以，并且推荐你使用多行物理行来格式化Linux命令，例如这样：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we use more than one line, we need to put a backslash (`\`) at the end of
    the lines to indicate to the shell that the command continues on the next line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用多行命令，我们需要在行末加上反斜杠（`\`），以指示shell命令将在下一行继续。
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Try to find out what the preceding command does.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出前面的命令在做什么。
- en: The COPY and ADD keywords
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: COPY和ADD关键字
- en: The `COPY` and `ADD` keywords are very important since, in the end, we want
    to add some content to an existing base image to make it a custom image. Most
    of the time, these are a few source files of – say – a web application, or a few
    binaries of a compiled application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`和`ADD`关键字非常重要，因为最终我们想在现有的基础镜像上添加一些内容，使其成为一个自定义镜像。通常，这些内容可能是一些源文件——比如说——一个Web应用程序，或者一些已编译应用程序的二进制文件。'
- en: These two keywords are used to copy files and folders from the host into the
    image that we’re building. The two keywords are very similar, with the exception
    that the `ADD` keyword also lets us copy and unpack `TAR` files, as well as provide
    an URI as a source for the files and folders to copy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个关键字用于将文件和文件夹从主机复制到我们正在构建的镜像中。两个关键字非常相似，唯一的区别是`ADD`关键字还允许我们复制并解包`TAR`文件，并可以提供URI作为复制文件和文件夹的源。
- en: 'Let’s look at a few examples of how these two keywords can be used, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些这两个关键字使用的示例，如下所示：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding lines of code, the following applies:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，以下内容适用：
- en: The first line copies all files and folders from the current directory recursively
    to the `app` folder inside the container image
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将当前目录中的所有文件和文件夹递归地复制到容器镜像中的`app`文件夹。
- en: The second line copies everything in the `web` subfolder to the target folder,
    `/app/web`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行将`web`子文件夹中的所有内容复制到目标文件夹`/app/web`。
- en: The third line copies a single file, `sample.txt`, into the target folder, `/data`,
    and at the same time, renames it `my-sample.txt`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行将单个文件`sample.txt`复制到目标文件夹`/data`，同时将其重命名为`my-sample.txt`。
- en: The fourth statement unpacks the `sample.tar` file into the target folder, `/app/bin`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四条语句将`sample.tar`文件解包到目标文件夹`/app/bin`。
- en: Finally, the last statement copies the remote file, `sample.txt`, into the target
    file, `/data`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一条语句将远程文件`sample.txt`复制到目标文件`/data`。
- en: 'Wildcards are allowed in the source path. For example, the following statement
    copies all files starting with `sample` to the `mydir` folder inside the image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From a security perspective, it is important to know that, by default, all
    files and folders inside the image will have a `ADD` and `COPY`, we can change
    the ownership that the files will have inside the image using the optional `--chown`
    flag, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding statement will copy all files starting with `web` and put them
    into the `/app/data` folder in the image, and at the same time assign user 11
    and group 22 to these files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Instead of numbers, we could also use names for the user and group, but then
    these entities would have to be already defined in the root filesystem of the
    image at `/etc/passwd` and `/etc/group`, respectively; otherwise, the build of
    the image would fail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The WORKDIR keyword
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `WORKDIR` keyword defines the working directory or context that is used
    when a container is run from our custom image. So, if I want to set the context
    to the `/app/bin` folder inside the image, my expression in the Dockerfile would
    have to look as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All activity that happens inside the image after the preceding line will use
    this directory as the working directory. It is very important to note that the
    following two snippets from a Dockerfile are not the same:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compare the preceding code with the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The former will create the file in the root of the image filesystem, while the
    latter will create the file at the expected location in the `/app/bin` folder.
    Only the `WORKDIR` keyword sets the context across the layers of the image. The
    `cd` command alone is not persisted across layers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: It is completely fine to change the current working directory multiple times
    in a Dockerfile.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The CMD and ENTRYPOINT keywords
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CMD` and `ENTRYPOINT` keywords are special. While all other keywords defined
    for a Dockerfile are executed at the time the image is built by the Docker builder,
    these two are definitions of what will happen when a container is started from
    the image we define. When the container runtime starts a container, it needs to
    know what the process or application will be that has to run inside that container.
    That is exactly what `CMD` and `ENTRYPOINT` are used for – to tell Docker what
    the start process is and how to start that process.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Now, the differences between `CMD` and `ENTRYPOINT` are subtle, and honestly,
    most users don’t fully understand them or use them in the intended way. Luckily,
    in most cases, this is not a problem and the container will run anyway; it’s just
    handling it that is not as straightforward as it could be.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how to use these two keywords, let’s analyze what a typical
    Linux command or expression looks like. Let’s take the `ping` utility as an example,
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding expression, `ping` is the command, and `-c 3 8.8.8.8` are
    the parameters of this com[mand. Let’s look at another expression](http://example.com/downloads/script.sh)
    here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，`ping` 是命令，`-c 3 8.8.8.8` 是该命令的参数。我们在这里看另一个表达式：[点击这里查看](http://example.com/downloads/script.sh)：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, in the preceding expression, `wget` is the command, and `-O - http://example.com/downloads/script.sh`
    are the parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，`wget` 是命令，`-O - http://example.com/downloads/script.sh` 是参数。
- en: 'Now that we have dealt with this, we can get back to `CMD` and `ENTRYPOINT`.
    `ENTRYPOINT` is used to define the command of the expression, while `CMD` is used
    to define the parameters for the command. Thus, a Dockerfile using Alpine as the
    base image and defining `ping` as the process to run in the container could look
    like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这个之后，我们可以回到 `CMD` 和 `ENTRYPOINT`。`ENTRYPOINT` 用于定义表达式的命令，而 `CMD` 用于定义命令的参数。因此，一个使用
    Alpine 作为基础镜像并将 `ping` 定义为容器中运行的进程的 Dockerfile 可能如下所示：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For both `ENTRYPOINT` and `CMD`, the values are formatted as a JSON array of
    strings, where the individual items correspond to the tokens of the expression
    that are separated by whitespace. This is the preferred way of defining `CMD`
    and `ENTRYPOINT`. It is also called the exec form.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ENTRYPOINT` 和 `CMD`，其值格式化为一个字符串的 JSON 数组，其中每个项对应于通过空格分隔的表达式中的各个令牌。这是定义 `CMD`
    和 `ENTRYPOINT` 的推荐方式，也称为 exec 形式。
- en: 'Alternatively, we can use what’s called the shell form, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用所谓的 shell 形式，如下所示：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now build an image called `pinger` from the preceding Dockerfile, as
    follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以根据前面的 Dockerfile 构建一个名为 `pinger` 的镜像，如下所示：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is the output generated by the preceeding command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面命令生成的输出：
- en: '![Figure 4.13 – Building the pinger Docker image](img/B19199_04_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 构建 pinger Docker 镜像](img/B19199_04_13.jpg)'
- en: Figure 4.13 – Building the pinger Docker image
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 构建 pinger Docker 镜像
- en: 'Then, we can run a container from the pinger image we just created, like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从刚才创建的 pinger 镜像中运行一个容器，像这样：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure 4.14 – Output of the pinger container](img/B19199_04_14.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – pinger 容器的输出](img/B19199_04_14.jpg)'
- en: Figure 4.14 – Output of the pinger container
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – pinger 容器的输出
- en: In the preceding command, we are using the `--rm` parameter, which defines that
    the container is automatically removed once the applications inside the container
    end.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了 `--rm` 参数，定义了容器在其中的应用程序结束后会自动删除。
- en: 'The beauty of this is that I can now override the CMD part that I have defined
    in the Dockerfile (remember, it was `["-c", "3","8.8.8.8"]`) when I create a new
    container by adding the new values at the end of the `docker container run` expression,
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，现在我可以在创建新容器时，通过在 `docker container run` 表达式的末尾添加新值来覆盖我在 Dockerfile 中定义的
    CMD 部分（记住，它是 `["-c", "3","8.8.8.8"]`），像这样：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will cause the container to ping the loopback IP address (`127.0.0.1`)
    for 5 seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使容器对回环 IP 地址（`127.0.0.1`）进行 5 秒的 ping 操作。
- en: 'If we want to override what’s defined in `ENTRYPOINT` in the Dockerfile, we
    need to use the `--entrypoint` parameter in the `docker container run` expression.
    Let’s say we want to execute a shell in the container instead of the `ping` command.
    We could do so by using the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想覆盖 Dockerfile 中 `ENTRYPOINT` 定义的内容，我们需要在 `docker container run` 表达式中使用
    `--entrypoint` 参数。假设我们想在容器中执行一个 shell，而不是 `ping` 命令。我们可以使用以下命令：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will then find ourselves inside the container. Type `exit` or press *Ctrl
    + D* to leave the container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将进入容器内。输入 `exit` 或按 *Ctrl + D* 退出容器。
- en: 'As I already mentioned, we do not necessarily have to follow best practices
    and define the command through `ENTRYPOINT` and the parameters through `CMD`;
    instead, we can enter the whole expression as a value of `CMD` and it will work,
    as shown in the following code block:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们不一定要遵循最佳实践，通过 `ENTRYPOINT` 定义命令，通过 `CMD` 定义参数；相反，我们可以将整个表达式作为 `CMD`
    的值，它也能正常工作，如以下代码块所示：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, I have even used the shell form to define CMD. But what happens in this
    situation if `ENTRYPOINT` is undefined? If you leave `ENTRYPOINT` undefined, then
    it will have the default value of `/bin/sh -c`, and whatever the value of `CMD`
    is will be passed as a string to the shell command. The preceding definition would
    thereby result in entering the following code to run the process inside the container:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Consequently, `/bin/sh` is the main process running inside the container, and
    it will start a new child process to run the `wget` utility.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: A complex Dockerfile
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have discussed the most important keywords commonly used in Dockerfiles.
    Now, let’s look at a realistic and somewhat complex example of a Dockerfile. Those
    of you who are interested might note that it looks very similar to the first Dockerfile
    that we presented in this chapter. Here is its content:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: OK; so, what is happening here? This is a Dockerfile that is used to build an
    image for a Node.js application; we can deduce this from the fact that the `node:19-buster-slim`
    base image is used. Then, the second line is an instruction to create an `/app`
    folder in the filesystem of the image. The third line defines the working directory
    or context in the image to be this new `/app` folder. Then, on line four, we copy
    a `package.json` file into the `/app` folder inside the image. After this, on
    line five, we execute the `npm install` command inside the container; remember,
    our context is the `/app` folder, so `npm` will find the `package.json` file there
    that we copied on line four.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Once all the Node.js dependencies have been installed, we copy the rest of the
    application files from the current folder of the host into the `/app` folder of
    the image.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last two lines, we define what the startup command will be when
    a container is run from this image. In our case, it is `npm start`, which will
    start the Node.js application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Building an image
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example and build a simple Docker image, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the sample code repository. Normally, this should be located in
    your home folder:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new subfolder for [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083)
    and navigate to it:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding folder, create a `sample1` subfolder and navigate to it, like
    this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use your favorite editor to create a file called `Dockerfile` inside this sample
    folder, with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save the file and exit your editor.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in the Terminal window, we can now build a new container image using the
    preceding Dockerfile as a manifest or construction plan, like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Please note that there is a period (`.`) at the end of the preceding command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Building our first custom image from CentOS](img/B19199_04_15.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Building our first custom image from CentOS
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous command means that the Docker builder creates a new image called
    `my-centos` using the Dockerfile that is present in the current directory. Here,
    the period at the end of the command specifies the current directory. We could
    also write the preceding command as follows, with the same result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we can omit the `-f` parameter since the builder assumes that the Dockerfile
    is called `Dockerfile`. We only ever need the `-f` parameter if our Dockerfile
    has a different name or is not located in the current directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the output shown in *Figure 4**.15*. This output is created by
    the Docker build kit:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the following line:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This line is generated at the end of the build process, although it appears
    as the first line. It tells us that the building took approximately 22 seconds
    and was executed in 7 steps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s skip the next few lines until we reach this one:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This line tells us which line of the Dockerfile the builder is currently executing
    (1 of 2). We can see that this is the `FROM centos:7` statement in our Dockerfile.
    This is the declaration of the base image, on top of which we want to build our
    custom image. What the builder then does is pull this image from Docker Hub, if
    it is not already available in the local cache.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow the next step. I have shortened it even more than the preceding
    one to concentrate on the essential part:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is our second line in the Dockerfile, where we want to use the `yum` package
    manager to install the `wget` utility.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The last few lines are as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the builder finalizes building the image and provides the image with the
    `sha256` code of `8eb6daefac9...`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that the resulting custom image has been given an ID of `8eb6daefac9...`
    and has been tagged with `my-centos:latest`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have analyzed how the build process of a Docker image works and
    what steps are involved, let’s talk about how to further improve this by introducing
    multi-step builds.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Multi-step builds
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate why a Dockerfile with multiple build steps is useful, let’s
    make an example Dockerfile. Let’s take a Hello World application written in C:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal window and navigate to this chapter’s folder:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a new folder called `multi-step-build` in your chapter folder:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open VS Code for this folder:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a file called `hello.c` in this folder and add the following code to
    it:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we want to containerize this application and write a Dockerfile with this
    content:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, let’s build this image:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This gives us a fairly long output since the builder has to install the Alpine
    **Software Development Kit** (**SDK**), which, among other tools, contains the
    C++ compiler we need to build the application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build is done, we can list the image and see the size that’s been
    shown, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the author’s case, the output is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With a size of 215 MB, the resulting image is way too big. In the end, it is
    just a Hello World application. The reason for it being so big is that the image
    not only contains the Hello World binary but also all the tools to compile and
    link the application from the source code. But this is not desirable when running
    the application, say, in production. Ideally, we only want to have the resulting
    binary in the image and not a whole SDK.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'It is precisely for this reason that we should define Dockerfiles as multi-stage.
    We have some stages that are used to build the final artifacts, and then a final
    stage, where we use the minimal necessary base image and copy the artifacts into
    it. This results in very small Docker images. Let’s do this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Dockerfile to your folder called `Dockerfile.multi-step` with
    this content:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have the first stage with an alias called `build`, which is used to
    compile the application; then, the second stage uses the same `alpine:3.12` base
    image but does not install the SDK, and only copies the binary from the `build`
    stage, using the `--from` parameter, into this final image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the image again, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s compare the sizes of the images with this command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we get the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have been able to reduce the size from 215 MB down to 5.34 MB. This is a
    reduction in size by a factor of approximately 40\. A smaller image has many advantages,
    such as a smaller attack surface area for hackers, reduced memory and disk consumption,
    faster startup times for the corresponding containers, and a reduction of the
    bandwidth needed to download the image from a registry, such as Docker Hub.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile best practices
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few recommended best practices to consider when authoring a Dockerfile,
    which are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we need to consider that containers are meant to be ephemeral.
    By ephemeral, we mean that a container can be stopped and destroyed, and a new
    one built and put in place with the absolute minimum setup and configuration.
    That means that we should try hard to keep the time that is needed to initialize
    the application running inside the container at a minimum, as well as the time
    needed to terminate or clean up the application.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next best practice tells us that we should order the individual commands
    in the Dockerfile so that we leverage caching as much as possible. Building a
    layer of an image can take a considerable amount of time – sometimes many seconds,
    or even minutes. While developing an application, we will have to build the container
    image for our application multiple times. We want to keep the build times at a
    minimum.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we’re rebuilding a previously built image, the only layers that are rebuilt
    are the ones that have changed, but if one layer needs to be rebuilt, all subsequent
    layers also need to be rebuilt. This is very important to remember. Consider the
    following example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In this example, the `npm install` command on line five of the Dockerfile usually
    takes the longest. A classical Node.js application has many external dependencies,
    and those are all downloaded and installed in this step. It can take minutes until
    it is done. Therefore, we want to avoid running `npm install` each time we rebuild
    the image, but a developer changes their source code all the time during the development
    of an application. That means that line four, the result of the `COPY` command,
    changes every time, and thus this layer has to be rebuilt. But as we discussed
    previously, that also means that all subsequent layers have to be rebuilt, which
    – in this case – includes the `npm install` command. To avoid this, we can slightly
    modify the Dockerfile and have the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, on line four, we only copied the single file that the `npm install` command
    needs as a source, which is the `package.json` file. This file rarely changes
    in a typical development process. As a consequence, the `npm install` command
    also has to be executed only when the `package.json` file changes. All the remaining
    frequently changed content is added to the image after the `npm` `install` command.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: A further best practice is to keep the number of layers that make up your image
    relatively small. The more layers an image has, the more the graph driver needs
    to work to consolidate the layers into a single root filesystem for the corresponding
    container. Of course, this takes time, and thus the fewer layers an image has,
    the faster the startup time for the container can be.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we keep our number of layers low? Remember that in a Dockerfile,
    each line that starts with a keyword such as `FROM`, `COPY`, or `RUN` creates
    a new layer. The easiest way to reduce the number of layers is to combine multiple
    individual `RUN` commands into a single one. For example, say that we had the
    following in a Dockerfile:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We could combine these into a single concatenated expression, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The former will generate three layers in the resulting image, while the latter
    will only create a single layer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three best practices all result in smaller images. Why is this important?
    Smaller images reduce the time and bandwidth needed to download the image from
    a registry. They also reduce the amount of disk space needed to store a copy locally
    on the Docker host and the memory needed to load the image. Finally, smaller images
    also mean a smaller attack surface for hackers. Here are the best practices mentioned:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The first best practice that helps reduce the image size is to use a `.dockerignore`
    file. We want to avoid copying unnecessary files and folders into an image, to
    keep it as lean as possible. A `.dockerignore` file works in the same way as a
    `.gitignore` file, for those who are familiar with Git. In a `.dockerignore` file,
    we can configure patterns to exclude certain files or folders from being included
    in the context when building the image.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next best practice is to avoid installing unnecessary packages into the
    filesystem of the image. Once again, this is to keep the image as lean as possible.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, it is recommended that you use multi-stage builds so that
    the resulting image is as small as possible and only contains the absolute minimum
    needed to run your application or application service.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to create a Docker image from
    a previously saved image. In fact, it may look like restoring an image.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading images
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third way to create a new container image is by importing or loading it
    from a file. A container image is nothing more than a tarball. To demonstrate
    this, we can use the `docker image save` command to export an existing image to
    a tarball, like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding command takes our `my-alpine` image that we previously built
    and exports it into a file called `./backup/my-alpine.tar`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Exporting an image as a tarball](img/B19199_04_16.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Exporting an image as a tarball
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we have an existing tarball and want to import it as
    an image into our system, we can use the `docker image load` command, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of the preceding command should be as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With this, we have learned how to build a Docker image in three different ways.
    We can do so interactively, by defining a Dockerfile, or by importing it into
    our system from a tarball.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how we can create Docker images for existing
    legacy applications, and thus run them in a container and profit from this.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Lift and shift – containerizing a legacy app
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can’t always start from scratch and develop a brand-new application. More
    often than not, we find ourselves with a huge portfolio of traditional applications
    that are up and running in production and provide mission-critical value to the
    company or the customers of the company. Often, those applications are organically
    grown and very complex. Documentation is sparse, and nobody wants to touch such
    an application. Often, the saying “*Never touch a running system”* applies. Yet,
    the market needs change, and with that arises the need to update or rewrite those
    apps. Often, a complete rewrite is not possible due to the lack of resources and
    time, or due to the excessive cost. What are we going to do about those applications?
    Could we possibly Dockerize them and profit from the benefits introduced by containers?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: It turns out we can. In 2017, Docker introduced a program called **Modernize
    Traditional Apps** (**MTA**) to their enterprise customers, which in essence promised
    to help those customers take their existing or traditional Java and .NET applications
    and containerize them, without the need to change a single line of code. The focus
    of MTA was on Java and .NET applications since those made up the lion’s share
    of the traditional applications in a typical enterprise. But it can also be used
    for any application that was written in – say – C, C++, Python, Node.js, Ruby,
    PHP, or Go, to name just a few other languages and platforms.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine such a legacy application for a moment. Let’s assume we have an
    old Java application that was written 10 years ago and that was continuously updated
    during the following 5 years. The application is based on Java SE 6, which came
    out in December 2006\. It uses environment variables and property files for configuration.
    Secrets such as usernames and passwords used in the database connection strings
    are pulled from a secrets keystore, such as HashiCorp Vault.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s describe each of the required steps to lift and shift a legacy application
    in more detail.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing external dependencies
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first steps in the modernization process is to discover and list
    all external dependencies of the legacy application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Does it use a database? If so, which one? What does the connection string look
    like?
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it use external APIs such as credit card approval or geo-mapping APIs?
    What are the API keys and key secrets?
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it consuming from or publishing to an **Enterprise Service** **Bus** (**ESB**)?
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few possible dependencies that come to mind. Many more exist.
    These are the seams of the application to the outer world, and we need to be aware
    of them and create an inventory.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Source code and build instructions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to locate all the source code and other assets, such as images
    and CSS and HTML files that are part of the application. Ideally, they should
    be located in a single folder. This folder will be the root of our project and
    can have as many subfolders as needed. This project root folder will be the context
    during the build of the container image we want to create for our legacy application.
    Remember, the Docker builder only includes files in the build that are part of
    that context; in our case, that is the root project folder.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: There is, though, an option to download or copy files during the build from
    different locations, using the `COPY` or `ADD` commands. Please refer to the online
    documentation for the exact details on how to use these two commands. This option
    is useful if the sources for your legacy application cannot be easily contained
    in a single, local folder.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Once we are aware of all the parts that contribute to the final application,
    we need to investigate how the application is built and packaged. In our case,
    this is most probably done by using `make` would most likely be used.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Once again, let’s extend our inventory and write down the exact build commands
    used. We will need this information later on when authoring the Dockerfile.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications need to be configured. Information provided during configuration
    could be – for example – the type of application logging to use, connection strings
    to databases, and hostnames to services such as ESBs or URIs to external APIs,
    to name just a few.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'We can differentiate a few types of configurations, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '**Build time**: This is the information needed during the build of the application
    and/or its Docker image. It needs to be available when we create the Docker images.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEVELOPMENT` versus `STAGING` or `PRODUCTION`. This kind of configuration
    is applied to the application when a container with the app starts – for example,
    in production.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: This is information that the application retrieves during runtime,
    such as secrets to access an external API.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every mission-critical enterprise application needs to deal with secrets in
    some form or another. The most familiar secrets are part of the connection information
    needed to access databases that are used to persist the data produced by or used
    by the application. Other secrets include the credentials needed to access external
    APIs, such as a credit score lookup API. It is important to note that, here, we
    are talking about secrets that have to be provided by the application itself to
    the service providers the application uses or depends on, and not secrets provided
    by the users of the application. The actor here is our application, which needs
    to be authenticated and authorized by external authorities and service providers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways traditional applications got their secrets. The worst
    and most insecure way of providing secrets is by hardcoding them or reading them
    from configuration files or environment variables, where they are available in
    cleartext. A much better way is to read the secrets during runtime from a special
    secret store that persists the secrets encrypted and provides them to the application
    over a secure connection, such as **Transport Layer** **Security** (**TLS**).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we need to create an inventory of all the secrets that our application
    uses and the way it procures them. Thus, we need to ask ourselves where we can
    get our secrets from: is it through environment variables or configuration files,
    or is it by accessing an external keystore, such as HashiCorp Vault, AWS Secrets
    Manager, or Azure Key Vault?'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Authoring the Dockerfile
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have a complete inventory of all the items we discussed in the previous
    few sections, we are ready to author our Dockerfile. But I want to warn you: don’t
    expect this to be a one-shot-and-go task. You may need several iterations until
    you have crafted your final Dockerfile. The Dockerfile may be rather long and
    ugly-looking, but that’s not a problem, so long as we get a working Docker image.
    We can always fine-tune the Dockerfile once we have a working version.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The base image
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by identifying the base image we want to use and build our image
    from. Is there an official Java image available that is compatible with our requirements?
    Remember that our application is based on Java SE 6\. If such a base image is
    available, then we should use that one. Otherwise, we will want to start with
    a Linux distro such as Red Hat, Oracle, or Ubuntu. In the latter case, we will
    use the appropriate package manager of the distro (`yum`, `apt`, or another) to
    install the desired versions of Java and Maven. For this, we can use the `RUN`
    keyword in the Dockerfile. Remember, `RUN` allows us to execute any valid Linux
    command in the image during the build process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the sources
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this step, we make sure all the source files and other artifacts needed
    to successfully build the application are part of the image. Here, we mainly use
    the two keywords of the Dockerfile: `COPY` and `ADD`. Initially, the structure
    of the source inside the image should look the same as on the host, to avoid any
    build problems. Ideally, you would have a single `COPY` command that copies all
    of the root project folders from the host into the image. The corresponding Dockerfile
    snippet could then look as simple as this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to also provide a `.dockerignore` file, which is located in the
    project root folder, which lists all the files and (sub)folders of the project
    root folder that should not be part of the build context.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, you can also use the `ADD` keyword to download sources
    and other artifacts into the Docker image that are not located in the build context
    but somewhere reachable by a URI, as shown here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This would create a `foobar` folder in the image’s working folder and copy all
    the contents from the URI.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this step, we make sure to create the final artifacts that make up our executable
    legacy application. Often, this is a `JAR` or `WAR` file, with or without some
    satellite JARs. This part of the Dockerfile should mimic the way you traditionally
    used to build an application before containerizing it. Thus, if you’re using Maven
    as your build automation tool, the corresponding snippet of the Dockerfile could
    look as simple as this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this step, we may also want to list the environment variables the application
    uses and provide sensible defaults. But never provide default values for environment
    variables that provide secrets to the application, such as the database connection
    string! Use the `ENV` keyword to define your variables, like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Also, declare all ports that the application is listening on and that need
    to be accessible from outside of the container via the `EXPOSE` keyword, like
    this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, we will explain the `start` command.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Defining the start command
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, a Java application is started with a command such as `java -jar <mainapplication
    jar>` if it is a standalone application. If it is a WAR file, then the `start`
    command may look a bit different. Therefore, we can either define `ENTRYPOINT`
    or `CMD` to use this command. Thus, the final statement in our Dockerfile could
    look like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Often, though, this is too simplistic, and we need to execute a few pre-run
    tasks. In this case, we can craft a script file that contains the series of commands
    that need to be executed to prepare the environment and run the application. Such
    a file is often called `docker-entrypoint``.sh`, but you are free to name it however
    you want. Make sure the file is executable – for example, run the following command
    on the host:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The last line of the Dockerfile would then look like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that you have been given hints on how to containerize a legacy application,
    it is time to recap and ask ourselves, is it worth the effort?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Why bother?
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, I can see you scratching your head and asking yourself: why
    bother? Why should you take on this seemingly huge effort just to containerize
    a legacy application? What are the benefits?'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the **return on investment** (**ROI**) is huge. Enterprise
    customers of Docker have publicly disclosed at conferences such as DockerCon 2018
    and 2019 that they are seeing these two main benefits of Dockerizing traditional
    applications:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: More than a 50% saving in maintenance costs
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to a 90% reduction in the time between the deployments of new releases
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The costs saved by reducing the maintenance overhead can be directly reinvested
    and used to develop new features and products. The time saved during new releases
    of traditional applications makes a business more agile and able to react to changing
    customer or market needs more quickly.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed how to build Docker images at length, it is time
    to learn how we can ship those images through the various stages of the software
    delivery pipeline.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Sharing or shipping images
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to ship our custom image to other environments, we need to give it
    a globally unique name. This action is often called **tagging an image**. We then
    need to publish the image to a central location from which other interested or
    entitled parties can pull it. These central locations are called **image registries**.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will describe how this works in more detail.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Tagging an image
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each image has a so-called tag. A tag is often used to version images, but
    it has a broader reach than just being a version number. If we do not explicitly
    specify a tag when working with images, then Docker automatically assumes we’re
    referring to the latest tag. This is relevant when pulling an image from Docker
    Hub, as shown in the following example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding command will pull the `alpine:latest` image from Docker Hub.
    If we want to explicitly specify a tag, we can do so like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will pull the Alpine image that has been tagged with `3.5`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying image namespaces
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have pulled various images and haven’t worried so much about where
    those images originated from. Your Docker environment is configured so that, by
    default, all images are pulled from Docker Hub. We also only pulled so-called
    official images from Docker Hub, such as `alpine` or `busybox`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to widen our horizons a bit and learn about how images are
    namespaced. The most generic way to define an image is by its fully qualified
    name, which looks as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s look at this in a bit more detail:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace part** | **Description** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `<``registry URL>` | This is the URL to the registry from which we want to
    pull the image. By default, this is `docker.io`. More generally, this could be
    [https://registry.acme.com](https://registry.acme.com).Other than Docker Hub,
    there are quite a few public registries out there that you could pull images from.
    The following is a list of some of them, in no particular order:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Google, at [https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon AWS Amazon **Elastic Container Registry** (**ECR**), at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure, at [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat, at [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artifactory, at [https://jfrog.com/integration/artifactorydocker-registry/](https://jfrog.com/integration/artifactorydocker-registry/)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '| `<User>` or `<Org>` | This is the private Docker ID of either an individual
    or an organization defined on Docker Hub – or any other registry, for that matter,
    such as `microsoft` or `oracle`. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `<``name>` | This is the name of the image, which is often also called a
    repository. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| `<``tag>` | This is the tag of the image. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at an example, as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we have an image, `web-app`, that is tagged with version `1.0` and belongs
    to the `engineering` organization on the private registry at `https://registry.acme.com`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are some special conventions:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: If we omit the registry URL, then Docker Hub is automatically taken
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we omit the tag, then the `latest` tag is taken
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is an official image on Docker Hub, then no user or organization namespace
    is needed
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few samples in tabular form:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '| **Image** | **Description** |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| `alpine` | The official `alpine` image on Docker Hub with the `latest` tag.
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| `ubuntu:22.04` | The official `ubuntu` image on Docker Hub with the `22.04`
    tag or version. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| `hashicorp/vault` | The `vault` image of an organization called `hashicorp`
    on Docker Hub with the `latest` tag. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| `acme/web-api:12.0` | The `web-api` image version of `12.0` that’s associated
    with the `acme` org. The image is on Docker Hub. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| `gcr.io/jdoe/sample-app:1.1` | The `sample-app` image with the `1.1` tag
    belonging to an individual with the `jdoe` ID in Google’s container registry.
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: Now that we know how the fully qualified name of a Docker image is defined and
    what its parts are, let’s talk about some special images we can find on Docker
    Hub.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Explaining official images
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding table, we mentioned “official image” a few times. This needs
    an explanation.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Images are stored in repositories on the Docker Hub registry. Official repositories
    are a set of repositories hosted on Docker Hub that are curated by individuals
    or organizations that are also responsible for the software packaged inside the
    image. Let’s look at an example of what that means. There is an official organization
    behind the Ubuntu Linux distro. This team also provides official versions of Docker
    images that contain their Ubuntu distros.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Official images are meant to provide essential base OS repositories, images
    for popular programming language runtimes, frequently used data storage, and other
    important services.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Docker sponsors a team whose task is to review and publish all those curated
    images in public repositories on Docker Hub. Furthermore, Docker scans all official
    images for vulnerabilities.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images to a registry
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating custom images is all well and good, but at some point, we want to share
    or ship our images to a target environment, such as a test, **quality assurance**
    (**QA**), or production system. For this, we typically use a container registry.
    One of the most popular public registries out there is Docker Hub. It is configured
    as a default registry in your Docker environment, and it is the registry from
    which we have pulled all our images so far.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: In a registry, we can usually create personal or organizational accounts. For
    example, the author’s account at Docker Hub is `gnschenker`. Personal accounts
    are good for personal use. If we want to use the registry professionally, then
    we’ll probably want to create an organizational account, such as `acme`, on Docker
    Hub. The advantage of the latter is that organizations can have multiple teams.
    Teams can have differing permissions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to push an image to my account on Docker Hub, I need to tag it accordingly.
    Let’s say I want to push the latest version of the Alpine image to my account
    and give it a tag of `1.0`. I can do this in the following way:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Tag the existing image, `alpine:latest`, with this command:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, Docker does not create a new image but creates a new reference to the
    existing image, `alpine:latest`, and names it `gnschenker/alpine:1.0`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to be able to push the image, I have to log in to my account, as follows:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Make sure to replace `gnschenker` with your own Docker Hub username and `<my
    secret password>` with your password.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a successful login, I can then push the image, like this:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'I will see something similar to this in the Terminal window:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: For each image that we push to Docker Hub, we automatically create a repository.
    A repository can be private or public. Everyone can pull an image from a public
    repository. From a private repository, an image can only be pulled if you are
    logged in to the registry and have the necessary permissions configured.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what container images are and how we can build
    and ship them. As we have seen, there are three different ways that an image can
    be created – either manually, automatically, or by importing a tarball into the
    system. We also learned some of the best practices commonly used when building
    custom images. Finally, we got a quick introduction to how to share or ship custom
    images by uploading them to a container image registry such as Docker Hub.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to introduce Docker volumes, which can be used
    to persist the state of a container. We’ll also show you how to define individual
    environment variables for the application running inside the container, as well
    as how to use files containing whole sets of configuration settings.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: How would you create a Dockerfile that inherits from Ubuntu version 22.04, and
    that installs `ping` and runs `ping` when a container starts? The default address
    used to ping should be `127.0.0.1`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you create a new container image that uses `alpine:latest` as a base
    image and installs `curl` on top of it? Name the new image `my-alpine:1.0`.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Dockerfile that uses multiple steps to create an image of a Hello World
    app of minimal size, written in C or Go.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three essential characteristics of a Docker container image.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to push an image named `foo:1.0` to your `jdoe` personal account on
    Docker Hub. Which of the following is the right solution?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker container` `push foo:1.0`'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image` `push jdoe/foo:1.0`'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker login -u jdoe -p <``your password>`'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image tag` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image` `push jdoe/foo:1.0`'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker login -u jdoe -p <``your password>`'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker container tag` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker container` `push jdoe/foo:1.0`'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker login -u jdoe -p <``your password>`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ docker image push` `foo:1.0 jdoe/foo:1.0`'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are possible answers to this chapter’s questions:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile could look like this:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that in Ubuntu, the `ping` tool is part of the `iputils-ping` package.
    You can build the image called pinger – for example – with the following command:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The Dockerfile could look like this:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Build the image with the following command:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The Dockerfile for a Go application could look like this:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can find the full solution in the `~/The-Ultimate-Docker-Container-Book/sample-solutions/ch04/answer03`
    folder.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'A Docker image has the following characteristics:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is immutable
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It consists of one-to-many layers
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains the files and folders needed for the packaged application to run
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct answer is *C*. First, you need to log in to Docker Hub; then, you
    must tag your image correctly with the username. Finally, you must push the image.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
