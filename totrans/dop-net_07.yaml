- en: Chapter 7. Using Continuous Integration Builds for Network Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：使用持续集成构建进行网络配置
- en: This chapter will focus on continuous integration, what the process entails,
    and why it is applicable to network operations. We will look at why continuous
    integration processes are vitally important when automating network operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍持续集成，过程内容，以及为什么它适用于网络操作。我们将讨论在自动化网络操作时，为什么持续集成过程至关重要。
- en: This chapter will discuss the benefits of configuration management tooling and
    we will look at practical configuration management processes that can be used
    to set up continuous integration processes and tooling that is available to support
    continuous integration processes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论配置管理工具的好处，并将介绍一些实用的配置管理流程，这些流程可用于设置持续集成过程，以及支持持续集成过程的可用工具。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Continuous integration overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成概述
- en: Continuous integration tooling available
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的持续集成工具
- en: Network continuous integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络持续集成
- en: Continuous integration overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成概述
- en: Continuous integration is a process used to improve the quality of development
    changes. A continuous integration process, when applied to developers, takes new
    code changes and integrates it with the rest of the code base. This is done early
    in the development lifecycle, creating an instant feedback loop and associated
    pass or failure against the change.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是一个用于提高开发更改质量的过程。应用于开发人员时，持续集成过程将新的代码更改与其余代码库集成。这是在开发生命周期的早期进行的，创建了即时反馈循环，并针对更改提供通过或失败的结果。
- en: Within the remits of DevOps, continuous integration is a key component as it
    uses centralized tooling to make changes visible to other users and promotes collaboration
    and integration of changes earlier in the software development lifecycle. Continuous
    integration is often coupled with Continuous Delivery processes, where continuous
    integration is used as the first part of the software delivery lifecycle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps的范畴内，持续集成是一个关键组成部分，因为它使用集中化的工具，使更改对其他用户可见，并促进软件开发生命周期早期的更改协作和集成。持续集成通常与持续交付过程一起使用，其中持续集成作为软件交付生命周期的第一部分。
- en: Prior to continuous integration being implemented, developers would sometimes
    only find out that code changes did not work when a release needed to be packaged.
    At this point, all developer changes were combined by a release management or
    operations team. By the time the release was ready to be packaged, a developer
    would have moved on to new tasks and not have been currently working on that piece
    of work anymore, meaning fixing the issue incurred more time delaying the release
    schedule.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施持续集成之前，开发人员有时只有在需要打包发布时，才会发现代码更改没有生效。此时，所有开发人员的更改由发布管理或运维团队进行合并。当发布准备好打包时，开发人员可能已经转向新的任务，并且不再处理该部分工作，这意味着修复问题会消耗更多时间，延误发布计划。
- en: A good continuous integration process should be triggered every time a developer
    commits a change, meaning that they have a prompt feedback cycle to tell them
    if their change is good, rather than finding out weeks or months later that their
    commit had an issue that will slow down the release process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的持续集成过程应该在每次开发人员提交更改时触发，意味着他们有一个及时的反馈周期，能够告知他们更改是否正确，而不是在几周或几个月后才发现提交存在问题，导致发布过程变慢。
- en: Continuous integration works on the premise of fixing as far left as possible,
    meaning at development time, with the furthest right being production. What this
    phrase really means is that if an issue is found earlier in the development cycle
    then it will cost less to fix and have less of an impact to the business as it
    will ideally never reach production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成基于尽早解决问题的前提，意味着在开发阶段进行修复，最远的右侧是生产环境。这个短语的意思是，如果在开发周期的早期发现问题，修复的成本较低，并且对业务的影响较小，因为理想情况下它永远不会进入生产环境。
- en: 'A continuous integration process follows the following steps, **Commit Change**
    to **Source Control Management** (**SCM**), the repository change is validated,
    and a pass or failure is issued back to the user:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成过程遵循以下步骤：**提交更改**到**源代码管理**（**SCM**），然后验证仓库中的更改，并将结果（通过或失败）反馈给用户：
- en: '![Continuous integration overview](img/B05559_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成概述](img/B05559_07_01.jpg)'
- en: The output of the continuous integration process should be what is shipped to
    test environments and production servers. It is important to make sure that the
    same binary artifacts that have been through continuous integration and relative
    testing are the same ones that will eventually be deployed onto the production
    servers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成过程的输出应该是被发送到测试环境和生产服务器的内容。确保通过持续集成和相关测试的相同二进制文件与最终部署到生产服务器上的文件一致，这一点非常重要。
- en: Processes such as continuous integration are used to create feedback loops that
    show issues as soon as they occur, which saves cost. This means the change is
    fresh in the implementers mind and they will be able to fix it or revert the change
    quickly, with developers currently iterating the code collaboratively and fixing
    issues as soon as they occur.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 像持续集成这样的流程用于创建反馈循环，能够在问题发生时立即显示出来，从而节省成本。这意味着变更刚刚在实施者的脑海中出现，他们可以迅速修复或撤销该变更，目前开发人员正通过协作迭代代码，并在问题发生时及时修复。
- en: Although all IT staff may not follow identical deployment strategies, feedback
    loops and validation should not be unique to just developers. Sure, a compilation
    process may not be required when making network changes, but other validations
    can be done against a network device or a change on an SDN controller or load
    balancer to validate the changes are correct.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有IT人员都遵循相同的部署策略，但反馈循环和验证过程不应仅限于开发人员。当然，进行网络更改时可能不需要编译过程，但可以通过网络设备或SDN控制器、负载均衡器上的更改来验证变更是否正确。
- en: Developer continuous integration
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者持续集成
- en: A continuous integration process in its purest form takes a developer code change,
    integrates it with other developers' latest changes and makes sure it compiles
    correctly. The continuous integration process can then optionally run a set of
    unit or integration tests on the code base, package the compiled binaries, and
    then upload the build package to an artifact repository, tagging the code repository
    and package with a unique version number.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最纯粹的形式中，持续集成过程将开发人员的代码变更与其他开发人员的最新变更进行集成，并确保它正确编译。持续集成过程还可以选择性地对代码库运行一组单元测试或集成测试，打包编译后的二进制文件，然后将构建包上传到工件库，并用唯一的版本号标记代码仓库和构建包。
- en: 'So, a simple continuous integration process can be summarized as the following
    feedback loop:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个简单的持续集成过程可以总结为以下反馈循环：
- en: The developer commits code change to the **SCM System** and integrates it with
    the code base.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员将代码变更提交到**SCM系统**并将其与代码库进行集成。
- en: The code base is pulled down to a **CI Build Server**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码库被拉取到**CI构建服务器**。
- en: The code is compiled to check that the new commit is valid and non-breaking
    and the repository is tagged with the build version number.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码被编译以检查新的提交是否有效且不破坏，并且仓库会被标记为构建版本号。
- en: Return **Pass** or **Fail** exit conditions and **Feedback result** to users.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**通过**或**失败**的退出条件，并将**反馈结果**传递给用户。
- en: Repeat steps 1-5 for the next code change.![Developer continuous integration](img/B05559_07_02.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对下一个代码变更重复步骤1-5。![开发者持续集成](img/B05559_07_02.jpg)
- en: Steps 1 (developer commit) and step 2 (creating a copy of the repository on
    the **CI Build Server**) are processes taken care of by **SCM Systems**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1（开发者提交）和步骤2（在**CI构建服务器**上创建仓库副本）是由**SCM系统**处理的过程。
- en: Some of the popular SCM systems over the past 10 years have been Subversion,
    IBM Rational ClearCase, Microsoft Team Foundation Server, Perforce, and Telelogic
    CM Synergy. While distributed source control management systems have moved from
    centralized to distributed source control management systems such as Git and Mercurial
    in recent years.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 过去10年中，一些流行的版本控制管理系统（SCM）包括Subversion、IBM Rational ClearCase、Microsoft Team
    Foundation Server、Perforce和Telelogic CM Synergy。近年来，分布式源代码控制管理系统逐渐从集中式系统转向Git和Mercurial等分布式系统。
- en: Steps 3 (code compilation), 4 (code compilation feedback to users), and 5 (repetition
    of the process) in the process are carried out by a continuous integration building
    servers, which act as a scheduling agent for the continuous build process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中的步骤3（代码编译）、步骤4（代码编译反馈给用户）和步骤5（重复过程）由持续集成构建服务器执行，这些服务器充当持续构建过程的调度代理。
- en: Tools such as Cruise Control, Hudson, or more recently Jenkins, Travis, and
    Thoughtworks Go are used to schedule continuous integration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如Cruise Control、Hudson，或最近的Jenkins、Travis和Thoughtworks Go等工具用于调度持续集成。
- en: 'Step 4 (code compilation feedback to users) can be carried out using compilation
    tools such as:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步（将编译反馈给用户）可以使用如下编译工具进行：
- en: Maven [https://maven.apache.org/](https://maven.apache.org/)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven [https://maven.apache.org/](https://maven.apache.org/)
- en: Ant [http://ant.apache.org/](http://ant.apache.org/)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ant [http://ant.apache.org/](http://ant.apache.org/)
- en: MsBuild [https://msdn.microsoft.com/en-us/library/ms171452(v=vs.90).aspx](https://msdn.microsoft.com/en-us/library/ms171452(v=vs.90).aspx)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MsBuild [https://msdn.microsoft.com/en-us/library/ms171452(v=vs.90).aspx](https://msdn.microsoft.com/en-us/library/ms171452(v=vs.90).aspx)
- en: Rake [http://rake.rubyforge.org/](http://rake.rubyforge.org/)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rake [http://rake.rubyforge.org/](http://rake.rubyforge.org/)
- en: Make [http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make [http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
- en: All these tools, and many more, can be used as the main validation step in the
    process depending on the type of code compilation that is required.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具，以及更多工具，可以根据所需的代码编译类型，作为过程中的主要验证步骤使用。
- en: The continuous integration process is carried out, polling for every new developer
    commit, and carrying out the code compilation and repeating the same process over
    and over to provide a continuous feedback loop. If a developer breaks the CI build
    they need to immediately fix it so that it doesn't block other development changes
    from being compiled and validated. So developers use continuous integration to
    collaborate and make sure their changes successfully integrate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成过程会持续进行，轮询每次新的开发者提交，进行代码编译并重复相同的过程，以提供持续的反馈循环。如果开发者破坏了持续集成构建，他们需要立即修复，以免阻碍其他开发变更的编译和验证。因此，开发人员使用持续集成来协作，并确保他们的变更成功集成。
- en: Additional steps such as unit or integration tests can be subsequently bolted
    on to the process after the compilation is successful for increased validation
    of the change. Just because code compiles, it doesn't mean it is always functional.
    When all compilation and tests are packaged a sixth step may be introduced to
    package the software and deploy it to an artifact repository.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的步骤，如单元测试或集成测试，可以在编译成功后加入到过程中，以增加对变更的验证。仅仅因为代码编译通过，并不意味着它总是能正常工作。当所有编译和测试完成并打包后，可能会引入第六步，将软件打包并部署到工件库。
- en: All good continuous integration processes should work on the premise of compile,
    test, and package. So a code release should be packaged once and the same package
    should be distributed to all servers at deployment time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有良好的持续集成过程都应该基于编译、测试和打包的前提。因此，代码发布应该只打包一次，并在部署时将同一包分发到所有服务器。
- en: Database continuous integration
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库持续集成
- en: After continuous integration was set up to help improve the quality of code
    releases, developers that controlled database changes generally thought about
    doing similar processes for database changes. As database changes are always a
    big part of any enterprise release process having broken database releases can
    prevent software being deployed and released to customers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好持续集成以帮助提高代码发布质量之后，控制数据库变更的开发人员通常会考虑对数据库变更做类似的处理。由于数据库变更总是企业发布过程中的重要组成部分，数据库发布出现故障会阻碍软件的部署和发布给客户。
- en: As a result, database schema changes or database programmatic stored procedures
    would equally benefit from being integrated earlier on in the continuous integration
    process and tested in a similar way using quick validation and feedback loops.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，数据库架构更改或数据库编程存储过程也应该在持续集成过程中尽早集成，并以类似的方式通过快速验证和反馈循环进行测试。
- en: In a way, developers have it easy when considering continuous integration as
    the compilation process is a binary pass or fail metric that is easy to understand.
    Scripting languages are of course the exception to this rule, but these can be
    supplemented using unit tests to provide the code validation on various code operations
    and both codes are improved by good test coverage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种程度上来说，开发人员在考虑持续集成时比较轻松，因为编译过程是一个二元的通过或失败的度量，易于理解。当然，脚本语言是这个规则的例外，但可以通过单元测试来补充，以提供对各种代码操作的验证，并且良好的测试覆盖率能够提升代码质量。
- en: When doing database schema changes, a number of test criteria need to be met
    prior to pushing the code to production. Good database developers will provide
    roll forward and roll-back scripts when making SQL changes, which will be applied
    to production databases and they normally test these on their development machines
    prior to checking them into a source control management system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据库模式更改时，需要满足一系列测试标准，才能将代码推送到生产环境。优秀的数据库开发人员在进行 SQL 更改时会提供前进和回滚脚本，并将其应用到生产数据库，通常会在将其提交到源代码管理系统之前在开发机器上进行测试。
- en: Database developers implement database changes using a roll-forward and roll-back
    release script and store them in SCM systems. The roll-back is only performed
    in the case of an emergency when it is being applied to production if the roll-forward
    for any reason fails.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库开发人员通过使用前进和回滚发布脚本来实现数据库变更，并将其存储在 SCM 系统中。回滚仅在紧急情况下执行，通常是在生产环境中应用时，如果前进脚本由于某种原因失败。
- en: 'So a typical database release process will have the two following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个典型的数据库发布过程将包含以下两个步骤：
- en: Apply SQL table or column creation, update, deletion, or stored procedure using
    release script.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用发布脚本应用 SQL 表或列的创建、更新、删除或存储过程。
- en: If this fails, roll-back SQL table or column creation, update, deletion or stored
    procedure using the roll-back release script.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果此步骤失败，请使用回滚发布脚本回滚 SQL 表或列的创建、更新、删除或存储过程。
- en: So prior to any production release, a database developer's roll-forward and
    roll-back scripts should be tested. As multiple database developers are part of
    the same release, these database release scripts should be applied in the same
    sequenced order as they would be applied to production as one developers change
    could break another developers changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在任何生产发布之前，数据库开发人员的前进和回滚脚本应该经过测试。由于多个数据库开发人员参与同一版本发布，因此这些数据库发布脚本应按照它们在生产环境中应用的顺序进行应用，因为一个开发人员的变更可能会破坏另一个开发人员的变更。
- en: 'Before setting up a database continuous integration, a few prerequisites are
    required:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置数据库持续集成之前，需要满足一些前提条件：
- en: A database schema matching production with a relative dataset and all the same
    characteristics such as indexing so we are testing against a similar live version
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与生产匹配的数据库模式以及相关数据集，并确保所有特性一致，例如索引，以便我们能够测试与实际生产版本相似的环境。
- en: The continuous integration process should also utilize the same deployment runner
    script that is used to sequence the database release scripts and provide roll-back
    in case of failure
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成过程还应该利用与数据库发布脚本序列化相同的部署运行器脚本，并在失败时提供回滚功能。
- en: Testing roll-back scripts is as integral to testing roll-forward scripts so
    the database continuous integration process will need valid tests to encompass
    roll-back.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试回滚脚本与测试前进脚本同样重要，因此数据库持续集成过程需要有效的测试来涵盖回滚。
- en: 'A common database deployment workflow applied by a database developer on their
    local workstation would look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库开发人员在本地工作站上应用的常见数据库部署工作流程如下所示：
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将前进数据库脚本应用到 CI 测试数据库。
- en: Apply roll-back database script using deployment runner script to CI test database.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将回滚数据库脚本应用到 CI 测试数据库。
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将前进数据库脚本应用到 CI 测试数据库。
- en: Apply roll-back database script using deployment runner script to CI test database.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将回滚数据库脚本应用到 CI 测试数据库。
- en: If the preceding set of steps is successful then the roll-forward and roll-back
    database scripts are sound in terms of syntax and won't fail when applied to the
    production database.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的步骤成功，那么前进和回滚的数据库脚本在语法上是正确的，且在应用到生产数据库时不会失败。
- en: The preceding steps also check the validity of the sequencing using the deployment
    runner and check that the integrated database deployment scripts work together
    and do not conflict on roll-back either.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤还使用部署运行器检查顺序的有效性，并检查集成的数据库部署脚本是否协同工作且在回滚时不会冲突。
- en: Using continuous integration, we have already ruled out multiple possible scenarios
    that could cause a failure in production. However, the preceding continuous integration
    process alone is not enough, as with a code compilation, just because SQL is not
    returning an error doesn't mean the database roll-forward and roll-back scripts
    are technically valid, so database changes still need to be supplemented with
    functional tests too.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续集成，我们已经排除了可能导致生产环境失败的多种情况。然而，仅仅依赖前述的持续集成过程是不够的，因为与代码编译一样，SQL 不返回错误并不意味着数据库的前滚和回滚脚本在技术上是有效的，因此数据库更改仍然需要通过功能测试进行补充。
- en: Continuous integration is about putting quality checks earlier in the delivery
    lifecycle and creating feedback loops. Continuous integration is not about proving
    that a release is 100% valid, it should instead be looked at as a way of proving
    that a checking process has been followed, which proves that a release is not
    broken.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的关键是将质量检查提前到交付生命周期，并创建反馈循环。持续集成并不是为了证明一个发布是 100% 有效的，而应该看作是证明已经遵循了检查过程，从而证明发布没有问题。
- en: 'A simple continuous integration database process would provide the following
    feedback loop for database developers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的持续集成数据库过程将为数据库开发人员提供以下反馈循环：
- en: Developer commits roll-forward and roll-back change to **SCM System** and it
    is integrated with the code base.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员将前滚和回滚更改提交到**SCM 系统**，并与代码库进行集成。
- en: The code base is pulled down to a **CI Build Server**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码库被拉取到**CI 构建服务器**。
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将前滚数据库脚本应用于 CI 测试数据库。
- en: Apply roll-back database script using deployment runner script to CI test database.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将回滚数据库脚本应用于 CI 测试数据库。
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将前滚数据库脚本应用于 CI 测试数据库。
- en: Apply roll-back database script using deployment runner script to CI test database.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用部署运行器脚本将回滚数据库脚本应用于 CI 测试数据库。
- en: Return **Pass** or **Fail** exit condition and feedback to users.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**通过**或**失败**退出条件并反馈给用户。
- en: Repeat steps 1-7 for the next database change.![Database continuous integration](img/B05559_07_03.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 1-7，进行下一个数据库更改。![数据库持续集成](img/B05559_07_03.jpg)
- en: Once the release is ready to go live the database CI will have the final changes
    applied, preparing it for the next release, the next iteration of database changes
    and the next batch of database scripts that will be applied by the next release.
    Alternately, the CI database schema can be refreshed from production.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布准备好上线，数据库 CI 将应用最终的更改，为下一次发布、下一次数据库更改迭代以及下一批数据库脚本做好准备，这些脚本将由下次发布应用。或者，CI
    数据库架构可以从生产环境中刷新。
- en: A good concept is to always create a baseline of the database so that if a database
    developer unwittingly commits a bad roll-forward and roll-back on a database then
    the CI database can be easily restored to the desired state and not prove a bottleneck
    for development.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是始终创建数据库的基准线，以便如果数据库开发人员不小心提交了错误的前滚和回滚操作，CI 数据库可以轻松恢复到所需的状态，而不会成为开发的瓶颈。
- en: Of course this is one way of dealing with validation of database changes and
    others are possible. Microsoft offers database projects for this very purpose,
    but the validation engine is not important, having validation of any changes early
    in the release lifecycle is the important takeaway.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一种处理数据库更改验证的方法，其他方法也是可能的。微软提供了数据库项目来实现这一目的，但验证引擎并不重要，关键是要在发布生命周期的早期进行任何更改的验证。
- en: It is important to make sure that nothing goes to production unless it goes
    through the CI process, there is no point setting up a great process and then
    skipping it as it makes the CI database schema invalid and could have massive
    consequences.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确保没有任何内容进入生产环境，除非经过 CI 过程，这是非常重要的。如果设置了一个很好的流程，但又跳过它，那么这将使 CI 数据库架构失效，可能带来巨大的后果。
- en: Tooling available for continuous integration
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用于持续集成的工具
- en: Many different flavors of configuration management tooling are available to
    help build continuous integration processes, so there is a rich variety of different
    options to choose from, which can seem daunting at first.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的配置管理工具可以帮助构建持续集成过程，因此有多种不同的选项可供选择，刚开始可能会显得让人不知所措。
- en: Tools should be picked to facilitate processes and will be selected by teams
    or users. As described in [Chapter 3](ch03.html "Chapter 3. Bringing DevOps to
    Network Operations"), *Bringing DevOps to Network Operations*, it is important
    to first map out requirements that need to be solved and the desired process before
    selecting any tooling.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 工具应根据流程需求进行选择，并由团队或用户进行挑选。如 [第 3 章](ch03.html "Chapter 3. Bringing DevOps to
    Network Operations")《将 DevOps 带入网络运维》中所述，*将 DevOps 带入网络运维*，在选择任何工具之前，首先需要规划好需要解决的需求和期望的流程。
- en: By the same token, it is important to avoid tools sprawl, which is all too common
    in large companies and have only one best fit tool for every operation rather
    than multiple tools doing the same thing as there is an operational overhead for
    the business.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，避免工具的泛滥，这是大公司中常见的问题，应为每个操作选择一个最合适的工具，而不是让多个工具做相同的事情，因为这样会给业务带来额外的运营负担。
- en: 'If configuration management tooling already exists in a company for continuous
    integration then it will more than likely be able to meet the needs. When considering
    the tooling for carrying out continuous integration processes the following tools
    are required:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司中已有用于持续集成的配置管理工具，那么它很可能能够满足需求。在考虑用于执行持续集成流程的工具时，需要以下工具：
- en: SCM system
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCM 系统
- en: Validation engine
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证引擎
- en: The SCM system is primarily used for storing code or configuration management
    configuration in a source control repository.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SCM 系统主要用于存储代码或配置管理的配置文件在源代码控制仓库中
- en: The validation engine is used to schedule the compilation of code or validate
    configuration. So continuous integration build servers are used for the scheduling
    and numerous compilation or test tools can be used to provide the validation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 验证引擎用于调度代码编译或验证配置。因此，持续集成构建服务器被用于调度，而许多编译或测试工具可用于提供验证功能。
- en: Source control management systems
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码管理系统
- en: 'SCM systems provide the center of a continuous integration process, but no
    matter the SCM system that is chosen; at a base level it should have the following
    essential features:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: SCM 系统提供了持续集成过程的核心，但无论选择哪个 SCM 系统，从基础层面来看，它应该具备以下基本功能：
- en: Be accessible to all users that need to push changes
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有需要提交更改的用户都应该可访问
- en: Store the latest version of files
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储文件的最新版本
- en: Have a centralized URL that can be browsed by users to see available repositories
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个可以被用户浏览的集中式 URL，以查看可用的仓库
- en: Have a role-based access permission model
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备基于角色的访问权限模型
- en: Support roll-back of versions and version trees on files
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持版本回滚和文件版本树
- en: Show which user committed a change along with the date and time of the change
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示提交更改的用户以及更改的日期和时间
- en: Support tagging of repositories, this can be used to check out a tag to show
    all the files that contributed to a release
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持仓库的标签管理，可以使用该标签来查看所有贡献于发布的文件
- en: Support multiple repository branches for parallel development
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个仓库分支以便进行并行开发
- en: Have the ability to merge files and deal with merge conflicts
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备合并文件和处理合并冲突的能力
- en: Have a command line
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备命令行
- en: Plug into Continuous Integration Build servers
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件支持持续集成构建服务器
- en: 'Most SCM systems will also support additional features such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SCM 系统还将支持以下附加功能：
- en: A programmable API or SDK
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供可编程的 API 或 SDK
- en: Easily integrated with developer IDEs
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够与开发人员的 IDEs 容易集成
- en: Integrate with Active Directory or **Lightweight Directory Access Protocol**
    (**LDAP**) for role-based access
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Active Directory 或 **轻量级目录访问协议** (**LDAP**) 集成，以实现基于角色的访问控制
- en: Support integration with change management tools, where a SCM commit can be
    associated with a change ticket
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持与变更管理工具的集成，其中 SCM 提交可以与变更工单关联
- en: Support integration with peer review tools
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持与同行评审工具的集成
- en: SCM systems can either be centralized or distributed, in recent years, distributed
    source control management systems have increased in popularity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SCM 系统可以是集中式或分布式的，近年来，分布式源代码管理系统的使用越来越广泛。
- en: Centralized SCM systems
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式 SCM 系统
- en: When SCM systems were originally created to facilitate development teams, a
    centralized architecture was used to build these systems. A centralized SCM system
    would be used to store code and developers would access the repository they were
    required to make code changes against and make edits against a live centralized
    system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当最初创建 SCM 系统时，旨在促进开发团队工作，采用了集中式架构来构建这些系统。集中式 SCM 系统用于存储代码，开发人员会访问他们需要对其进行更改的代码库，并对集中式系统中的实时代码进行编辑。
- en: 'For developers to remain productive, the centralized SCM system would always
    need to be available and online:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保开发人员的高效工作，集中式 SCM 系统始终需要保持在线并可用：
- en: Developers would access the repository where they wish to make code changes
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员会访问他们希望修改代码的代码库
- en: They'd then check out the file they wished to edit
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后他们会签出他们希望编辑的文件
- en: Make changes
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改
- en: Then check the file back into the code central branch
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将文件重新提交到代码中央分支
- en: The SCM system would have a locking mechanism to avoid collisions where only
    one file can be edited by one user at a time. If two developers accessed the file
    at the same time, the online SCM system would say it was locked by another developer
    and they would have to wait until the other developer made their change prior
    to being allowed to check out the code and make the subsequent change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SCM 系统会有一个锁定机制，以避免冲突，确保同一时间内只有一个用户能够编辑文件。如果两个开发人员同时访问该文件，在线 SCM 系统会显示该文件已被另一位开发人员锁定，他们必须等待该开发人员完成修改后，才能继续签出代码并进行后续更改。
- en: Developers when making changes would make a direct connection to repositories
    hosted in the centralized SCM system to make code updates. When a developer made
    a change, this in turn would write the changes in state to a centralized database,
    updating the state of the overall repository.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在进行更改时，会直接连接到集中式 SCM 系统中托管的代码库，以更新代码。当开发人员进行更改时，相应的更改状态会被写入集中式数据库，更新整体代码库的状态。
- en: The state change would then be synchronized to other developer's views automatically.
    One of the criticisms of centralized SCM systems was the fact that developers
    sometimes wanted to work offline, so some centralized source control management
    systems introduced the concept of snapshot views, which was an alternative to
    the permanently live and updated repository view and also introduced offline update
    features.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更改随后会自动同步到其他开发人员的视图中。集中式 SCM 系统的一个批评意见是，开发人员有时希望脱机工作，因此一些集中式源代码管理系统引入了快照视图的概念，作为永久在线更新代码库视图的替代方案，并引入了脱机更新功能。
- en: A snapshot view in a centralized SCM system was a snapped copy of the live repository
    at a given point in time. Best practice would dictate that before committing any
    development changes to the centralized server, the snapshot view should be updated;
    any merge conflicts would be dealt with locally before checking in any changes
    that were made in the snapshot view.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式 SCM 系统中，快照视图是某个时间点上，活跃代码库的快照副本。最佳实践要求，在将任何开发更改提交到集中式服务器之前，应该更新快照视图；任何合并冲突应在本地解决，之后再提交在快照视图中所做的更改。
- en: Developers would integrate with the centralized SCM system using the command-line
    interface or GUI that was integrated with a developers IDE for ease of use so
    they didn't need to jump between the command line and the IDE.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员会通过命令行接口或与开发人员集成的 IDE 图形界面与集中式 SCM 系统进行集成，以便于使用，这样他们就不需要在命令行和 IDE 之间切换。
- en: 'Examples of good centralized source control management systems are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一些优秀的集中式源代码管理系统示例如下：
- en: IBM Rational ClearCase
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM Rational ClearCase
- en: Telelogic CM Synergy
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Telelogic CM Synergy
- en: IBM Rational Team Concert
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM Rational Team Concert
- en: Microsoft Team Foundation Server
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 Team Foundation Server
- en: Subversion
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Perforce
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perforce
- en: Distributed SCM systems
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式 SCM 系统
- en: Distributed SCM systems do not have a central master and instead replicate changes
    to multiple places. Users will create replicas of a repository and then can pull
    or push using their own local copy sitting on their local development machine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式 SCM 系统没有中央主控节点，而是将更改复制到多个位置。用户会创建代码库的副本，然后可以通过自己的本地副本进行拉取或推送操作，这些副本存储在开发人员的本地开发机器上。
- en: Each repository in a distributed system will have an owner or maintainer and
    users will submit changes in the form of pull requests. Developers will create
    a pull request, which is like a merge request, but instead the repository maintainer
    can then approve if they accept the pull request or not. Once accepted, the commit
    will be pulled into the branch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的每个代码库都有一个所有者或维护者，用户将通过拉取请求的形式提交更改。开发人员会创建一个拉取请求，这类似于合并请求，但仓库的维护者可以决定是否接受该请求。一旦接受，提交的更改将被合并到分支中。
- en: One of the main benefits of a distributed SCM system is the ability to work
    on the repository offline. Changes can be committed to the local repository and
    then once it's back online, pushed to the master branch when developers are ready.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式SCM系统的主要优势之一是能够在离线时对代码库进行操作。更改可以提交到本地代码库，然后当开发人员准备好时，将其推送到主分支。
- en: Distributed SCM systems are more merge-friendly and efficient, so they work
    better with agile development, which often means multiple small repositories for
    each microservice rather than large centralized code bases for monolith applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式SCM系统更容易进行合并且效率更高，因此它们更适合敏捷开发，这通常意味着为每个微服务提供多个小型代码库，而不是为单体应用提供大型集中式代码库。
- en: 'Examples of distributed SCM systems are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式SCM系统的示例如下：
- en: Git
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Mercurial
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: Veracity
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Veracity
- en: Branching strategies
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支策略
- en: Branching strategies are used to meet the needs of modern software development,
    with multiple branches serving different use cases and supporting multiple versions
    of the code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略用于满足现代软件开发的需求，不同的分支服务于不同的使用场景并支持代码的多个版本。
- en: SCM systems traditionally relied on a **Mainline** branch, often referred to
    as the **Trunk** or **Master** branch. A mainline branching strategy meant that
    the mainline/trunk branch is always the clean and working version of the code,
    and the files on this branch are representative of the code in production.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SCM系统传统上依赖于**主干**分支，通常被称为**主线**或**主分支**。主干分支策略意味着主干/主线分支始终是干净且可工作的代码版本，该分支上的文件代表生产环境中的代码。
- en: Development branches were then created for active development on the latest
    releases, while release branches were used for maintenance releases if bugs were
    identified on the production system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了支持最新版本的活跃开发，创建了开发分支；而发布分支用于在生产系统中发现错误时进行维护发布。
- en: There are many different branching strategies that can be implemented; in the
    following example, the mainline branching strategy is illustrated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以实现许多不同的分支策略；以下示例展示了主干分支策略。
- en: The mainline/trunk/master branch is kept clean and all releases are done by
    merging changes to it, and this branch is tagged every time a release is done.
    This allows a diff to be done between tags to see what has changed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 主干/主线/主分支保持清洁，所有发布都通过将更改合并到该分支来进行，每次发布时都会给该分支打标签。这允许在标签之间进行差异对比，以查看发生了哪些变化。
- en: The development branch is used for active development and creates version 1.0,
    then merges to the **Release Branch 1.0**, which in turn immediately merges back
    to **Mainline/Trunk/Master**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支用于活跃的开发，创建版本1.0，然后合并到**发布分支 1.0**，此分支随后立即合并回**主干/主线/主分支**。
- en: 'The development branch then starts active development on version 2.0, while
    **Release Branch 1.0** is used for 1.x maintenance releases if a bug fix is required:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支随后开始版本2.0的活跃开发，而**发布分支 1.0**则用于1.x的维护发布，特别是当需要修复Bug时：
- en: '![Branching strategies](img/B05559_07_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Branching strategies](img/B05559_07_04.jpg)'
- en: The mainline branching strategy meant a lot of merging and coordination and
    release managers were required to coordinate merges and releases of versions on
    release days.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 主干分支策略意味着需要大量的合并和协调，发布经理需要在发布日协调合并和版本发布。
- en: Centralized configuration management systems were set up to favor a mainline
    approach to software development and this was good when supporting waterfall development.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 中央化的配置管理系统被建立以支持主干式的软件开发方法，这在支持瀑布开发时是有效的。
- en: Waterfall software development has rigid phases of the project, incorporating
    analysis, design, implementation, and testing phases, so the mainline branching
    strategy was sufficient when teams were producing only one release every few months
    as opposed to daily releases, so the laborious merge process was not such a bottleneck.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布式软件开发具有严格的项目阶段，包括分析、设计、实现和测试阶段，因此在团队每几个月只发布一次版本，而不是每天发布时，主线分支策略就足够用了，繁琐的合并过程并不是瓶颈。
- en: However, the transition to agile software development meant that implementing
    the mainline strategy became more difficult as teams release more frequently now
    that they have moved towards continuous deployment and delivery models.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向敏捷软件开发的过渡意味着实现主线策略变得更加困难，因为现在团队发布频率更高，已经转向了持续部署和交付模型。
- en: An alternate branching strategy better suited to agile development is using
    feature branches. In agile software development work is split into sprints that
    last two weeks. So the master or mainline branch is still used but very short-lived
    feature branches are created by developers during a sprint. Distributed SCM systems
    put the developer in charge of the merging as opposed to using a centralized release
    management team for these operations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更适合敏捷开发的替代分支策略是使用功能分支。在敏捷软件开发中，工作被拆分成持续两周的冲刺。因此，主分支或主线分支仍然被使用，但在冲刺期间开发人员会创建非常短暂的功能分支。分布式SCM系统将合并的控制权交给开发人员，而不是使用集中式的发布管理团队来处理这些操作。
- en: In the following example, we can see an example of feature branching, where
    three different feature branches, **Feature A**, **Feature B**, and **Feature
    C** are created during a two week sprint. When developers have finished development
    their features merged back into the **Trunk/Master** branch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到功能分支的一个例子，在为期两周的冲刺中创建了三个不同的功能分支，**功能 A**、**功能 B** 和 **功能 C**。当开发人员完成了功能开发后，这些功能会合并回**主干/主分支**。
- en: 'Every time a commit is done from a feature branch then the change is merged
    directly to **Trunk/Master** and a continuous integration process will be started
    which will validate the changes, every successful check-in then becomes a potential
    release candidate. After a release is packaged by the continuous integration process
    it is ready for deployment, as shown in the following diagram:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每当从一个功能分支进行提交时，变更会直接合并到**主干/主分支**，并且会启动一个持续集成过程来验证这些变更，每一次成功的提交都会成为潜在的发布候选版本。经过持续集成过程打包后的发布版本可以准备部署，如下图所示：
- en: '![Branching strategies](img/B05559_07_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![分支策略](img/B05559_07_05.jpg)'
- en: Some purists will argue against utilizing feature branches at all, preferring
    to always work against **Trunk/Master**. However, this decision it down to the
    individual teams to govern which approach works best for them and it is subjective.
    Some will also argue that it adds an additional level of control until adequate
    testing is created on the Trunk/Master branch so that changes can be suitably
    peer-reviewed prior to merging.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些纯粹主义者会反对使用功能分支，倾向于始终在**主干/主分支**上工作。然而，这个决策交给各个团队来决定哪种方法最适合他们，这是一个主观问题。也有人会认为，功能分支可以在主干/主分支上的适当测试创建之前，增加额外的控制层级，以便在合并之前进行适当的同行评审。
- en: When a commit is done against a branch it should trigger a CI build and associated
    validation of whatever change has been committed. This creates feedback loops
    at every stage of the process. Any change that goes into any branch should be
    governed by a CI build to gate-keep good changes and highlight breaking changes
    as soon as they happen so they can be fixed immediately.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当对一个分支进行提交时，应该触发持续集成构建并验证所提交的变更。这会在整个过程中形成反馈回路。任何进入任何分支的变更都应该由持续集成构建来管理，以筛选出良好的变更，并在发生破坏性变更时立即予以突出显示，以便及时修复。
- en: Continuous integration build servers
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成构建服务器
- en: Various continuous integration build servers are available to help schedule
    validation steps or tests. One of the first continuous integration build servers
    was Cruise Control from Thoughtworks, which has since evolved into Thoughtworks
    Go.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 各种持续集成构建服务器可用于帮助安排验证步骤或测试。最早的持续集成构建服务器之一是Thoughtworks的Cruise Control，后来发展成为Thoughtworks
    Go。
- en: '**Cruise Control** allowed users to configure an XML file that set up different
    continuous integration build jobs. Each build job ran a set of command-line options;
    normally, a compilation process against a code repository and it returned a green
    build if it was successful and a red build if the build was broken. Cruise Control
    would highlight the errors in the form of build logs providing feedback to users
    via the Cruise Control dashboard or by e-mail.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The market leading build server at the moment is Cloudbees Jenkins, which is
    an open source project and a fork of the original Hudson project. Jenkins really
    took away the need to configure XML files and moved all setup operations into
    the GUI or API. It comes with a plethora of plugins that can pretty much carry
    out any continuous integration operation possible. It also has recently delved
    into Continuous Delivery as of Jenkins 2.x release.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The next evolution of CI systems has moved towards cloud-based solutions with
    Travis being a popular choice for open source projects. This allows users to check
    in a Travis YAML file, which creates the build configuration from source control
    and can be versioned along with the code. This is something Jenkins 2.x is doing
    now using the Jenkinsfile and that the Jenkins job builder project had been doing
    for the OpenStack project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different options when looking for continuous integration build
    servers, consider the following; no matter the continuous integration build system
    that is chosen, at a base level it should have the following essential features:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard for feedback
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notion of green and red builds
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling capability for generic command lines
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass or fail builds based on exit conditions, `0` being a pass
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug-ins to well-known compilation tools
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to poll SCM systems
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to integrate with unit testing framework solutions such as Junit, Nunit,
    and more
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based access control
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to display change lists of the latest commits to a repository that has
    been built
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most continuous integration build servers will also support additional features
    such as:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Have a programmable API or SDK
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide e-mail or messaging integration
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with Active Directory or LDAP for role-based access
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support integration with change management tools, where a SCM commit can be
    associated with a change ticket
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support integration with peer review tools
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network continuous integration
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So why should network engineers be interested in continuous integration? A
    network team should be interested in continuous integration if they want to improve
    the following points, which were focused on in [Chapter 3](ch03.html "Chapter 3. Bringing
    DevOps to Network Operations"), *Bringing DevOps to Network Operations*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Velocity of change
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mean time to resolve
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved uptime
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased number of deployments
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross skilling between teams
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the bus factor of one
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to easily trace what has changed on the network and see which engineer
    made a change is something that continuous integration brings to the table. This
    information will be available by looking at the latest commit on a continuous
    integration build system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Roll-back will be as simple as deploying the last tagged release configuration
    as opposed to trawling through device logs to see what changes were applied to
    a network device if an error occurs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Every network engineer can look at the job configuration on the continuous integration
    build system and see how it operates so every network engineer knows how the process
    works so it helps with cross skilling.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Having continual feedback loops will allow network teams to continuously improve
    processes, if a network process is sub-optimal then the network team can easily
    highlight the pain points in the process and fix them as the change process is
    evident to all engineers and done in a consistent manner.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When network teams use continuous integration processes it moves network teams
    out of firefighting mode and into tactical continuous improvement and optimization
    mode. Continuous integration means that the quality of network changes will improve
    as every network change has associated validation steps that are no longer manual
    and error prone.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Instead, these checks and validations are built in and carried out every time
    a network operator commits a network change to the SCM System. These changes can
    be built up over time to make network changes less error prone and give network
    engineers the same capabilities as developers and infrastructure teams.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing network continuous integration also takes the fear out of making
    production changes, as they are already validated and verified as part of the
    continuous integration process, so production changes can be viewed as just a
    business-as-usual activity, rather than something that needs to be planned weeks
    in advance or worried about. The view is: if an activity is problematic then do
    it more often, continually iterate it, improve it, and make people less afraid
    of doing it.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Having covered topics such as different SCM branching strategies, continuous
    integration build servers, and shown how continuous integration can be used for
    code and database changes, it should now be clear what continuous integration
    is and that it is not just about compilation of code. Instead, continuous integration
    is about validating parallel changes, making sure they all work together and providing
    feedback loops to users.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps movement is about interacting with others and removing bottlenecks,
    delivering products to market faster, and increasing accuracy so continuous integration
    is equally applicable to networking. The automation of processes and the collaboration
    between teams using similar concepts is very important so continuous integration
    really is the glue that holds infrastructure and networking as code together.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: To a network engineer, concepts such as continuous integration may seem alien
    at first, but instead of talking about deep dive compilation processes, it should
    be focusing on processes. If any network engineer was asked if they could have
    a quick and easy-to-use process that validated all their network changes before
    production, providing quick feedback loops, then the answer would be yes. Continuous
    integration can therefore be a useful tool that would mean less broken production
    changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In this book, in [Chapter 4](ch04.html "Chapter 4. Configuring Network Devices
    Using Ansible"), *Configuring Network Devices Using Ansible*, [Chapter 5](ch05.html
    "Chapter 5. Orchestrating Load Balancers Using Ansible"), *Orchestrating Load
    Balancers Using Ansible*, and [Chapter 6](ch06.html "Chapter 6. Orchestrating
    SDN Controllers Using Ansible"), *Orchestrating SDN Controllers Using Ansible*,
    we looked at ways that network changes could be treated as code, using configuration
    management tooling such as Ansible to configure network devices, load balancers,
    and SDN controllers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'So when considering the following diagram, the question regarding continuous
    integration of network changes is not asking if continuous integration is possible
    for network changes. It should instead be questioning which validation engines
    can be used for network changes after a SCM commit has taken place to give a quick
    feedback loop of **Pass** or **Fail** to network operators:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Network continuous integration](img/B05559_07_06.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Network validation engines
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenge when creating continuous integration builds for network changes
    is what to use for the validation engine. Network changes when using Ansible rely
    heavily on YAML configuration files, so the first validation that can be done
    is checking the YAML `var` files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The `var` files are used to describe the desired state of the network, so checking
    that these YAML files are valid in terms of syntax is one valid check. So to do
    this, a tool such as `yamllint` can be used to check if the syntax of the files
    that are committed into source control management are valid.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Once the YAML `var` files are checked into source control, the continuous integration
    build should create a tag to state a new release has happened. All SCM systems
    should have a tagging or base-lining feature.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Tagging versions means that the current network release version can be diffed
    against the previous version to see what file changes have occurred on the YAML
    `var` files. If an issue is detected at any stage, all networks changes are made
    transparent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: So what other validation is possible? When focusing on configuration of network
    devices, we are pushing configuration changes to a networking operating system
    such as Juniper Junos or Arista Eos. So being able to run the newly committed
    changes and make sure the syntax is programmatically correct against those operating
    systems as part of the continuous integration process is highly desirable. Most
    network device operating systems as discussed in [Chapter 4](ch04.html "Chapter 4. Configuring
    Network Devices Using Ansible"), *Configuring Network Devices Using Ansible*,
    are Linux-based, so having a network operating system to issue commands to as
    part of the CI process doesn't seem too absurd.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The same can be said when checking the configuration used to orchestrate load
    balancers or SDN controllers, having a test environment attached to the continuous
    integration process is also highly desirable in theory. By utilizing a software
    version of the load balancer or emulated version of the SDN controller would be
    highly beneficial, so network engineers can pre-flight their network changes to
    make sure the API calls and syntax is correct.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: However, there are challenges with simulating an SDN controller or creating
    or simulating a production environment depending on the vendor, they may have
    a huge overhead in terms of setting up a continuous integration environment due
    to cost. Network devices, load balancers, and SDN vendors are evolving to support
    automation and DevOps friendly processes such as continuous integration. Therefore,
    networking vendors are starting to appreciate the validity of giving small test
    environments; this is where virtualized or containerized versions of load balancers
    or SDN controllers would be useful as an API endpoint to validate the desired
    state that has been set up in YAML files.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Alternately, the vendors could provide a vagrant box to test if the desired
    configuration specified in YAML `var` files that is checked into SCM Systems is
    valid before it is propagated to the first test environment. Any enhancements
    that can be done to processes to make it fail as fast as possible and shift issues
    as far left as possible in the development lifecycle should be implemented where
    possible.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: So with all of these validators, let's look at how these processes can be applied
    to network devices, or alternately orchestration. The number of validators used
    may depend on the network vendors that are being used, so we will look at the
    start point for a continuous integration build for network devices regardless
    of vendor and then look at more advanced options that could be used if the vendor
    provides a software load balancer or SDN emulation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Simple continuous integration builds for network devices
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As network changes are always required daily by large organizations that are
    implementing microservice applications. To meet those demands networking should
    be as self-service as possible. To keep up with demand, network teams will probably
    need to use a feature branch SCM strategy or allow self-service YAML files to
    be committed directly to the master branch, as shown in the following diagram:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大型组织在实施微服务应用程序时通常需要每天进行网络更改，因此为了满足这些需求，网络应尽可能自助服务。为了跟上需求，网络团队可能需要使用特性分支 SCM
    策略，或者允许直接将自助服务 YAML 文件提交到主分支，如下图所示：
- en: '![Simple continuous integration builds for network devices](img/B05559_07_07.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![简单的网络设备持续集成构建](img/B05559_07_07.jpg)'
- en: Each commit should be peer reviewed before it is merged. Ideally, the self-service
    process should allow development teams to package network changes alongside their
    code changes and follow a self-service approach.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每次提交应在合并之前进行同行评审。理想情况下，自助服务流程应允许开发团队将网络更改与他们的代码更改一起打包，并遵循自助服务方法。
- en: The first continuous integration build that should be set up for network devices
    or orchestration should focus on version controlling the Ansible YAML files and
    running a simple YAML validation on the desired state.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个应该为网络设备或编排设置的持续集成构建应专注于版本控制 Ansible YAML 文件，并对期望状态运行简单的 YAML 验证。
- en: Each continuous integration build that runs will also tag the repository. Tagging
    the SCM repository means that release versions can be compared or easily rolled
    back. It will also act as an audit log to show which user made changes and what
    exactly has changed in the environment. No changes should be made to a production
    system that has not gone through the continuous integration process.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行的持续集成构建还将标记仓库。标记 SCM 仓库意味着可以比较发布版本，或轻松回滚。它还将作为审计日志，显示哪个用户进行了更改，以及在环境中具体更改了什么。未经持续集成过程的更改不应应用于生产系统。
- en: 'So a simple network continuous integration build will follow these simple validation
    steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个简单的网络持续集成构建将遵循以下简单的验证步骤：
- en: YAML files are checked for syntax.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 YAML 文件进行语法检查。
- en: The repository is tagged in the SCM System if successful.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，仓库将在 SCM 系统中被标记。
- en: 'Therefore, a simple network continuous integration build would follow these
    steps. The network operator would commit the YAML files to the SCM system to change
    the desired state of the network; the continuous integration build server would
    tag the build if the YAML Lint operation finds that all the YAML files in the
    repository have valid syntax and return a positive result:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个简单的网络持续集成构建将遵循以下步骤。网络操作员将把 YAML 文件提交到 SCM 系统，以更改网络的期望状态；如果 YAML Lint 操作发现仓库中的所有
    YAML 文件具有有效的语法并返回正面结果，则持续集成构建服务器将标记该构建：
- en: '![Simple continuous integration builds for network devices](img/B05559_07_08.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![简单的网络设备持续集成构建](img/B05559_07_08.jpg)'
- en: Configuring a simple Jenkins network CI build
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置一个简单的 Jenkins 网络 CI 构建
- en: This simple continuous integration build for network devices can be set up in
    the Jenkins CI build server. Rake and the `yamllint` gem should be configured
    on the Jenkins slave that the build will be executed on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的网络设备持续集成构建可以在 Jenkins CI 构建服务器上设置。`Rake` 和 `yamllint` gem 应该在将要执行构建的 Jenkins
    从属机上进行配置。
- en: Once this has been completed, a new Jenkins CI build can be created in a matter
    of minutes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些步骤，新的 Jenkins CI 构建可以在几分钟内创建。
- en: 'First, select a new Jenkins freestyle job:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择一个新的 Jenkins 自由风格作业：
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![配置一个简单的 Jenkins 网络 CI 构建](img/B05559_07_09.jpg)'
- en: 'Then configure the SCM system to use, in this instance Git, specifying `git@gitlab:devops/sdn.git`
    as the repository and the `*/master` branch of the project along with the SSH
    key required to provide access to the repository:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后配置 SCM 系统，在本例中使用 Git，指定 `git@gitlab:devops/sdn.git` 作为仓库，并指定项目的 `*/master`
    分支以及提供访问仓库所需的 SSH 密钥：
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_10.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![配置一个简单的 Jenkins 网络 CI 构建](img/B05559_07_10.jpg)'
- en: 'Now for the validation step, a shell command build step is selected, which
    will run `rake yamllint` on the repository after configuring a **Rakefile** in
    the `git@gitlab:devops/sdn.git` repository so the YAML files can be parsed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行验证步骤，选择一个 shell 命令构建步骤，该步骤将在配置了 **Rakefile** 的 `git@gitlab:devops/sdn.git`
    仓库中运行 `rake yamllint`，以便可以解析 YAML 文件：
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_11.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Finally, configure the build job to tag the Jenkins build version against the
    `devops/sdn.git` gitlab repository and **Save** the build:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_12.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: This has configured a very simple Jenkins CI build process that will poll the
    Git repository for new changes, run `yamllint` against the repository, and then
    tag the Git repository if the build is successful.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The build health will be shown in Jenkins; the green ball means the build is
    in a healthy state so the YAML files are currently in a good state, and the duration
    of the check shows it took 6.2 seconds to execute the build, as shown in the following
    screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_13.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Adding validations to network continuous integration builds
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After highlighting the need for more robust validation to pre-flight configuration
    of network devices shifting failure as far left in the development lifecycle as
    possible to reduce the cost to fix. Having the ability to push mission-critical
    configuration changes to a networking operating system such as Cisco Nxos, Juniper
    Junos, or Arista Eos would be a good continuous integration validation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: So, like databases verifying that SQL syntax is correct, being able to run the
    newly committed changes and make sure the networking commands or orchestration
    commands applied to network devices syntax is programmatically correct should
    be part of the continuous integration build.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration can then help the quality of network changes as an incorrect
    change would never be pushed to a network device, load balancer, or SDN controller.
    Of course, the functionality of the configuration pushed may not be what is required,
    but there should at least never be a situation where the configuration has a syntax
    error at deployment time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: As network devices, load balancer, and SDN controller changes are mission-critical,
    this brings an added layer of validation checks to any network changes and checks
    in a quick and automated way, providing quick feedback if a network change is
    not what is required.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration for network devices
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before setting up a network device, continuous integration of a few prerequisites
    is required:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: A network operating system will be required with production configuration pushed
    to it and all live settings, which can be hosted on a virtual appliance
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The continuous integration build tools such as Jenkins will need to have an
    Ansible Control Host set up on the agent so it can execute Ansible playbooks
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All playbooks should be written with a block rescue so subsequent cleanup is
    built-in if the execution of the playbook fails
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical network device release process will have the two following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Apply the network change self-service playbook.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the playbook is idempotent, changes will only be shown if a change has occurred.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ansible playbook should provide resilience for roll-forward and roll-back
    in terms of state change. The previous steps also check the validity of the sequencing
    using the Ansible playbook and also check that the calls being made to the network
    device are valid.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple continuous integration network build process would provide the following
    feedback loop for network operators:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The network operator commits Ansible playbook or YAML `var` file's change to
    **SCM System**, and it is integrated with the code base.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code base is pulled down to a **CI Build Server**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML files are checked using `yamllint`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ansible playbook is applied to push network changes to the device.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return **Pass** or **Fail** exit conditions and feedback to users.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-5 for the next network device change:![Continuous integration
    for network devices](img/B05559_07_14.jpg)
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous integration builds for network orchestration
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before setting up a network orchestration for load balancers or SDN controllers,
    a few prerequisites are required:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: A software load balancer or an emulated SDN controller will be required with
    production configuration pushed to it and all live settings
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The continuous integration build tools such as Jenkins will need to have an
    Ansible controller set up on the agent so it can execute Ansible playbooks as
    well as the SDK that will allow the network orchestration modules to be executed
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All playbooks should be written with a block rescue so subsequent cleanup is
    built in if the execution of the playbook fails
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical network device release process will have the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Apply network changes to the self-service playbook.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the playbook is idempotent, changes will be only shown if a change has occurred.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible playbook, like with the network device changes should provide resilience
    for roll-forward and roll-back in terms of state change. Some test servers may
    be needed on a virtualization platform to simulate the load balancing so health
    checks can be tested too.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple continuous integration network orchestration continuous integration
    process would provide the following feedback loop for network operators:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The network operator commits Ansible playbook or YAML `var` file change to **SCM
    System** and it is integrated with the code base.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code base is pulled down to a **CI Build Server**.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML files are checked using `yamllint`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Ansible playbook is applied to orchestrate the API and create the necessary
    load balancer or SDN changes.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return **Pass** or **Fail** exit condition and feedback to users.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-5 for next network orchestration change:![Continuous integration
    builds for network orchestration](img/B05559_07_15.jpg)
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at what continuous integration is and how continuous
    integration processes can be applied to code and databases. The chapter then looked
    at ways that continuous integration can be applied to assist with network operations
    to provide feedback loops.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We also explored different SCM methodologies, the difference between centralized
    and distributed SCM systems and how branching strategies are used with waterfall
    and agile processes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We then looked into the vast array of tools available for creating continuous
    integration processes focusing on some examples using Jenkins to set up a simple
    network continuous integration build.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned what continuous integration is, how it can be applied
    to network operations, SCM tooling, and the difference between centralized and
    distributed systems along with common SCM branching strategies.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Other key takeaways from this chapter include continuous integration build servers
    and their use, ways to integrate network changes into continuous integration,
    and potential continuous integration validation engines for network changes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at various test tools and how they can be
    applied to continuous integration processes for added validation. This will allow
    unit tests to be created for network operations to make sure the desired state
    is actually implemented on devices before we will look at deploying the network
    changes in Continuous Delivery pipelines.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
