- en: Chapter 7. Using Continuous Integration Builds for Network Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on continuous integration, what the process entails,
    and why it is applicable to network operations. We will look at why continuous
    integration processes are vitally important when automating network operations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss the benefits of configuration management tooling and
    we will look at practical configuration management processes that can be used
    to set up continuous integration processes and tooling that is available to support
    continuous integration processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration tooling available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration is a process used to improve the quality of development
    changes. A continuous integration process, when applied to developers, takes new
    code changes and integrates it with the rest of the code base. This is done early
    in the development lifecycle, creating an instant feedback loop and associated
    pass or failure against the change.
  prefs: []
  type: TYPE_NORMAL
- en: Within the remits of DevOps, continuous integration is a key component as it
    uses centralized tooling to make changes visible to other users and promotes collaboration
    and integration of changes earlier in the software development lifecycle. Continuous
    integration is often coupled with Continuous Delivery processes, where continuous
    integration is used as the first part of the software delivery lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to continuous integration being implemented, developers would sometimes
    only find out that code changes did not work when a release needed to be packaged.
    At this point, all developer changes were combined by a release management or
    operations team. By the time the release was ready to be packaged, a developer
    would have moved on to new tasks and not have been currently working on that piece
    of work anymore, meaning fixing the issue incurred more time delaying the release
    schedule.
  prefs: []
  type: TYPE_NORMAL
- en: A good continuous integration process should be triggered every time a developer
    commits a change, meaning that they have a prompt feedback cycle to tell them
    if their change is good, rather than finding out weeks or months later that their
    commit had an issue that will slow down the release process.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration works on the premise of fixing as far left as possible,
    meaning at development time, with the furthest right being production. What this
    phrase really means is that if an issue is found earlier in the development cycle
    then it will cost less to fix and have less of an impact to the business as it
    will ideally never reach production.
  prefs: []
  type: TYPE_NORMAL
- en: 'A continuous integration process follows the following steps, **Commit Change**
    to **Source Control Management** (**SCM**), the repository change is validated,
    and a pass or failure is issued back to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous integration overview](img/B05559_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of the continuous integration process should be what is shipped to
    test environments and production servers. It is important to make sure that the
    same binary artifacts that have been through continuous integration and relative
    testing are the same ones that will eventually be deployed onto the production
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Processes such as continuous integration are used to create feedback loops that
    show issues as soon as they occur, which saves cost. This means the change is
    fresh in the implementers mind and they will be able to fix it or revert the change
    quickly, with developers currently iterating the code collaboratively and fixing
    issues as soon as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Although all IT staff may not follow identical deployment strategies, feedback
    loops and validation should not be unique to just developers. Sure, a compilation
    process may not be required when making network changes, but other validations
    can be done against a network device or a change on an SDN controller or load
    balancer to validate the changes are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Developer continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A continuous integration process in its purest form takes a developer code change,
    integrates it with other developers' latest changes and makes sure it compiles
    correctly. The continuous integration process can then optionally run a set of
    unit or integration tests on the code base, package the compiled binaries, and
    then upload the build package to an artifact repository, tagging the code repository
    and package with a unique version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a simple continuous integration process can be summarized as the following
    feedback loop:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer commits code change to the **SCM System** and integrates it with
    the code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code base is pulled down to a **CI Build Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code is compiled to check that the new commit is valid and non-breaking
    and the repository is tagged with the build version number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return **Pass** or **Fail** exit conditions and **Feedback result** to users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-5 for the next code change.![Developer continuous integration](img/B05559_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 1 (developer commit) and step 2 (creating a copy of the repository on
    the **CI Build Server**) are processes taken care of by **SCM Systems**.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the popular SCM systems over the past 10 years have been Subversion,
    IBM Rational ClearCase, Microsoft Team Foundation Server, Perforce, and Telelogic
    CM Synergy. While distributed source control management systems have moved from
    centralized to distributed source control management systems such as Git and Mercurial
    in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 3 (code compilation), 4 (code compilation feedback to users), and 5 (repetition
    of the process) in the process are carried out by a continuous integration building
    servers, which act as a scheduling agent for the continuous build process.
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as Cruise Control, Hudson, or more recently Jenkins, Travis, and
    Thoughtworks Go are used to schedule continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4 (code compilation feedback to users) can be carried out using compilation
    tools such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven [https://maven.apache.org/](https://maven.apache.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ant [http://ant.apache.org/](http://ant.apache.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MsBuild [https://msdn.microsoft.com/en-us/library/ms171452(v=vs.90).aspx](https://msdn.microsoft.com/en-us/library/ms171452(v=vs.90).aspx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rake [http://rake.rubyforge.org/](http://rake.rubyforge.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make [http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these tools, and many more, can be used as the main validation step in the
    process depending on the type of code compilation that is required.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous integration process is carried out, polling for every new developer
    commit, and carrying out the code compilation and repeating the same process over
    and over to provide a continuous feedback loop. If a developer breaks the CI build
    they need to immediately fix it so that it doesn't block other development changes
    from being compiled and validated. So developers use continuous integration to
    collaborate and make sure their changes successfully integrate.
  prefs: []
  type: TYPE_NORMAL
- en: Additional steps such as unit or integration tests can be subsequently bolted
    on to the process after the compilation is successful for increased validation
    of the change. Just because code compiles, it doesn't mean it is always functional.
    When all compilation and tests are packaged a sixth step may be introduced to
    package the software and deploy it to an artifact repository.
  prefs: []
  type: TYPE_NORMAL
- en: All good continuous integration processes should work on the premise of compile,
    test, and package. So a code release should be packaged once and the same package
    should be distributed to all servers at deployment time.
  prefs: []
  type: TYPE_NORMAL
- en: Database continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After continuous integration was set up to help improve the quality of code
    releases, developers that controlled database changes generally thought about
    doing similar processes for database changes. As database changes are always a
    big part of any enterprise release process having broken database releases can
    prevent software being deployed and released to customers.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, database schema changes or database programmatic stored procedures
    would equally benefit from being integrated earlier on in the continuous integration
    process and tested in a similar way using quick validation and feedback loops.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, developers have it easy when considering continuous integration as
    the compilation process is a binary pass or fail metric that is easy to understand.
    Scripting languages are of course the exception to this rule, but these can be
    supplemented using unit tests to provide the code validation on various code operations
    and both codes are improved by good test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: When doing database schema changes, a number of test criteria need to be met
    prior to pushing the code to production. Good database developers will provide
    roll forward and roll-back scripts when making SQL changes, which will be applied
    to production databases and they normally test these on their development machines
    prior to checking them into a source control management system.
  prefs: []
  type: TYPE_NORMAL
- en: Database developers implement database changes using a roll-forward and roll-back
    release script and store them in SCM systems. The roll-back is only performed
    in the case of an emergency when it is being applied to production if the roll-forward
    for any reason fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'So a typical database release process will have the two following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply SQL table or column creation, update, deletion, or stored procedure using
    release script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this fails, roll-back SQL table or column creation, update, deletion or stored
    procedure using the roll-back release script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So prior to any production release, a database developer's roll-forward and
    roll-back scripts should be tested. As multiple database developers are part of
    the same release, these database release scripts should be applied in the same
    sequenced order as they would be applied to production as one developers change
    could break another developers changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before setting up a database continuous integration, a few prerequisites are
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: A database schema matching production with a relative dataset and all the same
    characteristics such as indexing so we are testing against a similar live version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The continuous integration process should also utilize the same deployment runner
    script that is used to sequence the database release scripts and provide roll-back
    in case of failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing roll-back scripts is as integral to testing roll-forward scripts so
    the database continuous integration process will need valid tests to encompass
    roll-back.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common database deployment workflow applied by a database developer on their
    local workstation would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-back database script using deployment runner script to CI test database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-back database script using deployment runner script to CI test database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the preceding set of steps is successful then the roll-forward and roll-back
    database scripts are sound in terms of syntax and won't fail when applied to the
    production database.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding steps also check the validity of the sequencing using the deployment
    runner and check that the integrated database deployment scripts work together
    and do not conflict on roll-back either.
  prefs: []
  type: TYPE_NORMAL
- en: Using continuous integration, we have already ruled out multiple possible scenarios
    that could cause a failure in production. However, the preceding continuous integration
    process alone is not enough, as with a code compilation, just because SQL is not
    returning an error doesn't mean the database roll-forward and roll-back scripts
    are technically valid, so database changes still need to be supplemented with
    functional tests too.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration is about putting quality checks earlier in the delivery
    lifecycle and creating feedback loops. Continuous integration is not about proving
    that a release is 100% valid, it should instead be looked at as a way of proving
    that a checking process has been followed, which proves that a release is not
    broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple continuous integration database process would provide the following
    feedback loop for database developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Developer commits roll-forward and roll-back change to **SCM System** and it
    is integrated with the code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code base is pulled down to a **CI Build Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-back database script using deployment runner script to CI test database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-forward database script using deployment runner script to CI test
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply roll-back database script using deployment runner script to CI test database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return **Pass** or **Fail** exit condition and feedback to users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-7 for the next database change.![Database continuous integration](img/B05559_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the release is ready to go live the database CI will have the final changes
    applied, preparing it for the next release, the next iteration of database changes
    and the next batch of database scripts that will be applied by the next release.
    Alternately, the CI database schema can be refreshed from production.
  prefs: []
  type: TYPE_NORMAL
- en: A good concept is to always create a baseline of the database so that if a database
    developer unwittingly commits a bad roll-forward and roll-back on a database then
    the CI database can be easily restored to the desired state and not prove a bottleneck
    for development.
  prefs: []
  type: TYPE_NORMAL
- en: Of course this is one way of dealing with validation of database changes and
    others are possible. Microsoft offers database projects for this very purpose,
    but the validation engine is not important, having validation of any changes early
    in the release lifecycle is the important takeaway.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make sure that nothing goes to production unless it goes
    through the CI process, there is no point setting up a great process and then
    skipping it as it makes the CI database schema invalid and could have massive
    consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling available for continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many different flavors of configuration management tooling are available to
    help build continuous integration processes, so there is a rich variety of different
    options to choose from, which can seem daunting at first.
  prefs: []
  type: TYPE_NORMAL
- en: Tools should be picked to facilitate processes and will be selected by teams
    or users. As described in [Chapter 3](ch03.html "Chapter 3. Bringing DevOps to
    Network Operations"), *Bringing DevOps to Network Operations*, it is important
    to first map out requirements that need to be solved and the desired process before
    selecting any tooling.
  prefs: []
  type: TYPE_NORMAL
- en: By the same token, it is important to avoid tools sprawl, which is all too common
    in large companies and have only one best fit tool for every operation rather
    than multiple tools doing the same thing as there is an operational overhead for
    the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'If configuration management tooling already exists in a company for continuous
    integration then it will more than likely be able to meet the needs. When considering
    the tooling for carrying out continuous integration processes the following tools
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: SCM system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SCM system is primarily used for storing code or configuration management
    configuration in a source control repository.
  prefs: []
  type: TYPE_NORMAL
- en: The validation engine is used to schedule the compilation of code or validate
    configuration. So continuous integration build servers are used for the scheduling
    and numerous compilation or test tools can be used to provide the validation.
  prefs: []
  type: TYPE_NORMAL
- en: Source control management systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SCM systems provide the center of a continuous integration process, but no
    matter the SCM system that is chosen; at a base level it should have the following
    essential features:'
  prefs: []
  type: TYPE_NORMAL
- en: Be accessible to all users that need to push changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the latest version of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a centralized URL that can be browsed by users to see available repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a role-based access permission model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support roll-back of versions and version trees on files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show which user committed a change along with the date and time of the change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support tagging of repositories, this can be used to check out a tag to show
    all the files that contributed to a release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support multiple repository branches for parallel development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the ability to merge files and deal with merge conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug into Continuous Integration Build servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most SCM systems will also support additional features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: A programmable API or SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily integrated with developer IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with Active Directory or **Lightweight Directory Access Protocol**
    (**LDAP**) for role-based access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support integration with change management tools, where a SCM commit can be
    associated with a change ticket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support integration with peer review tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SCM systems can either be centralized or distributed, in recent years, distributed
    source control management systems have increased in popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized SCM systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When SCM systems were originally created to facilitate development teams, a
    centralized architecture was used to build these systems. A centralized SCM system
    would be used to store code and developers would access the repository they were
    required to make code changes against and make edits against a live centralized
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For developers to remain productive, the centralized SCM system would always
    need to be available and online:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers would access the repository where they wish to make code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They'd then check out the file they wished to edit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then check the file back into the code central branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SCM system would have a locking mechanism to avoid collisions where only
    one file can be edited by one user at a time. If two developers accessed the file
    at the same time, the online SCM system would say it was locked by another developer
    and they would have to wait until the other developer made their change prior
    to being allowed to check out the code and make the subsequent change.
  prefs: []
  type: TYPE_NORMAL
- en: Developers when making changes would make a direct connection to repositories
    hosted in the centralized SCM system to make code updates. When a developer made
    a change, this in turn would write the changes in state to a centralized database,
    updating the state of the overall repository.
  prefs: []
  type: TYPE_NORMAL
- en: The state change would then be synchronized to other developer's views automatically.
    One of the criticisms of centralized SCM systems was the fact that developers
    sometimes wanted to work offline, so some centralized source control management
    systems introduced the concept of snapshot views, which was an alternative to
    the permanently live and updated repository view and also introduced offline update
    features.
  prefs: []
  type: TYPE_NORMAL
- en: A snapshot view in a centralized SCM system was a snapped copy of the live repository
    at a given point in time. Best practice would dictate that before committing any
    development changes to the centralized server, the snapshot view should be updated;
    any merge conflicts would be dealt with locally before checking in any changes
    that were made in the snapshot view.
  prefs: []
  type: TYPE_NORMAL
- en: Developers would integrate with the centralized SCM system using the command-line
    interface or GUI that was integrated with a developers IDE for ease of use so
    they didn't need to jump between the command line and the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of good centralized source control management systems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: IBM Rational ClearCase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telelogic CM Synergy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IBM Rational Team Concert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Team Foundation Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perforce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed SCM systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Distributed SCM systems do not have a central master and instead replicate changes
    to multiple places. Users will create replicas of a repository and then can pull
    or push using their own local copy sitting on their local development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Each repository in a distributed system will have an owner or maintainer and
    users will submit changes in the form of pull requests. Developers will create
    a pull request, which is like a merge request, but instead the repository maintainer
    can then approve if they accept the pull request or not. Once accepted, the commit
    will be pulled into the branch.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main benefits of a distributed SCM system is the ability to work
    on the repository offline. Changes can be committed to the local repository and
    then once it's back online, pushed to the master branch when developers are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed SCM systems are more merge-friendly and efficient, so they work
    better with agile development, which often means multiple small repositories for
    each microservice rather than large centralized code bases for monolith applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of distributed SCM systems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Veracity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Branching strategies are used to meet the needs of modern software development,
    with multiple branches serving different use cases and supporting multiple versions
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: SCM systems traditionally relied on a **Mainline** branch, often referred to
    as the **Trunk** or **Master** branch. A mainline branching strategy meant that
    the mainline/trunk branch is always the clean and working version of the code,
    and the files on this branch are representative of the code in production.
  prefs: []
  type: TYPE_NORMAL
- en: Development branches were then created for active development on the latest
    releases, while release branches were used for maintenance releases if bugs were
    identified on the production system.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different branching strategies that can be implemented; in the
    following example, the mainline branching strategy is illustrated.
  prefs: []
  type: TYPE_NORMAL
- en: The mainline/trunk/master branch is kept clean and all releases are done by
    merging changes to it, and this branch is tagged every time a release is done.
    This allows a diff to be done between tags to see what has changed.
  prefs: []
  type: TYPE_NORMAL
- en: The development branch is used for active development and creates version 1.0,
    then merges to the **Release Branch 1.0**, which in turn immediately merges back
    to **Mainline/Trunk/Master**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The development branch then starts active development on version 2.0, while
    **Release Branch 1.0** is used for 1.x maintenance releases if a bug fix is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Branching strategies](img/B05559_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mainline branching strategy meant a lot of merging and coordination and
    release managers were required to coordinate merges and releases of versions on
    release days.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized configuration management systems were set up to favor a mainline
    approach to software development and this was good when supporting waterfall development.
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall software development has rigid phases of the project, incorporating
    analysis, design, implementation, and testing phases, so the mainline branching
    strategy was sufficient when teams were producing only one release every few months
    as opposed to daily releases, so the laborious merge process was not such a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: However, the transition to agile software development meant that implementing
    the mainline strategy became more difficult as teams release more frequently now
    that they have moved towards continuous deployment and delivery models.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate branching strategy better suited to agile development is using
    feature branches. In agile software development work is split into sprints that
    last two weeks. So the master or mainline branch is still used but very short-lived
    feature branches are created by developers during a sprint. Distributed SCM systems
    put the developer in charge of the merging as opposed to using a centralized release
    management team for these operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we can see an example of feature branching, where
    three different feature branches, **Feature A**, **Feature B**, and **Feature
    C** are created during a two week sprint. When developers have finished development
    their features merged back into the **Trunk/Master** branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time a commit is done from a feature branch then the change is merged
    directly to **Trunk/Master** and a continuous integration process will be started
    which will validate the changes, every successful check-in then becomes a potential
    release candidate. After a release is packaged by the continuous integration process
    it is ready for deployment, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Branching strategies](img/B05559_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some purists will argue against utilizing feature branches at all, preferring
    to always work against **Trunk/Master**. However, this decision it down to the
    individual teams to govern which approach works best for them and it is subjective.
    Some will also argue that it adds an additional level of control until adequate
    testing is created on the Trunk/Master branch so that changes can be suitably
    peer-reviewed prior to merging.
  prefs: []
  type: TYPE_NORMAL
- en: When a commit is done against a branch it should trigger a CI build and associated
    validation of whatever change has been committed. This creates feedback loops
    at every stage of the process. Any change that goes into any branch should be
    governed by a CI build to gate-keep good changes and highlight breaking changes
    as soon as they happen so they can be fixed immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration build servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Various continuous integration build servers are available to help schedule
    validation steps or tests. One of the first continuous integration build servers
    was Cruise Control from Thoughtworks, which has since evolved into Thoughtworks
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cruise Control** allowed users to configure an XML file that set up different
    continuous integration build jobs. Each build job ran a set of command-line options;
    normally, a compilation process against a code repository and it returned a green
    build if it was successful and a red build if the build was broken. Cruise Control
    would highlight the errors in the form of build logs providing feedback to users
    via the Cruise Control dashboard or by e-mail.'
  prefs: []
  type: TYPE_NORMAL
- en: The market leading build server at the moment is Cloudbees Jenkins, which is
    an open source project and a fork of the original Hudson project. Jenkins really
    took away the need to configure XML files and moved all setup operations into
    the GUI or API. It comes with a plethora of plugins that can pretty much carry
    out any continuous integration operation possible. It also has recently delved
    into Continuous Delivery as of Jenkins 2.x release.
  prefs: []
  type: TYPE_NORMAL
- en: The next evolution of CI systems has moved towards cloud-based solutions with
    Travis being a popular choice for open source projects. This allows users to check
    in a Travis YAML file, which creates the build configuration from source control
    and can be versioned along with the code. This is something Jenkins 2.x is doing
    now using the Jenkinsfile and that the Jenkins job builder project had been doing
    for the OpenStack project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different options when looking for continuous integration build
    servers, consider the following; no matter the continuous integration build system
    that is chosen, at a base level it should have the following essential features:'
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard for feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notion of green and red builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling capability for generic command lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass or fail builds based on exit conditions, `0` being a pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug-ins to well-known compilation tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to poll SCM systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to integrate with unit testing framework solutions such as Junit, Nunit,
    and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to display change lists of the latest commits to a repository that has
    been built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most continuous integration build servers will also support additional features
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a programmable API or SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide e-mail or messaging integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with Active Directory or LDAP for role-based access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support integration with change management tools, where a SCM commit can be
    associated with a change ticket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support integration with peer review tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So why should network engineers be interested in continuous integration? A
    network team should be interested in continuous integration if they want to improve
    the following points, which were focused on in [Chapter 3](ch03.html "Chapter 3. Bringing
    DevOps to Network Operations"), *Bringing DevOps to Network Operations*:'
  prefs: []
  type: TYPE_NORMAL
- en: Velocity of change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mean time to resolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved uptime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased number of deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross skilling between teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the bus factor of one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to easily trace what has changed on the network and see which engineer
    made a change is something that continuous integration brings to the table. This
    information will be available by looking at the latest commit on a continuous
    integration build system.
  prefs: []
  type: TYPE_NORMAL
- en: Roll-back will be as simple as deploying the last tagged release configuration
    as opposed to trawling through device logs to see what changes were applied to
    a network device if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Every network engineer can look at the job configuration on the continuous integration
    build system and see how it operates so every network engineer knows how the process
    works so it helps with cross skilling.
  prefs: []
  type: TYPE_NORMAL
- en: Having continual feedback loops will allow network teams to continuously improve
    processes, if a network process is sub-optimal then the network team can easily
    highlight the pain points in the process and fix them as the change process is
    evident to all engineers and done in a consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: When network teams use continuous integration processes it moves network teams
    out of firefighting mode and into tactical continuous improvement and optimization
    mode. Continuous integration means that the quality of network changes will improve
    as every network change has associated validation steps that are no longer manual
    and error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, these checks and validations are built in and carried out every time
    a network operator commits a network change to the SCM System. These changes can
    be built up over time to make network changes less error prone and give network
    engineers the same capabilities as developers and infrastructure teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing network continuous integration also takes the fear out of making
    production changes, as they are already validated and verified as part of the
    continuous integration process, so production changes can be viewed as just a
    business-as-usual activity, rather than something that needs to be planned weeks
    in advance or worried about. The view is: if an activity is problematic then do
    it more often, continually iterate it, improve it, and make people less afraid
    of doing it.'
  prefs: []
  type: TYPE_NORMAL
- en: Having covered topics such as different SCM branching strategies, continuous
    integration build servers, and shown how continuous integration can be used for
    code and database changes, it should now be clear what continuous integration
    is and that it is not just about compilation of code. Instead, continuous integration
    is about validating parallel changes, making sure they all work together and providing
    feedback loops to users.
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps movement is about interacting with others and removing bottlenecks,
    delivering products to market faster, and increasing accuracy so continuous integration
    is equally applicable to networking. The automation of processes and the collaboration
    between teams using similar concepts is very important so continuous integration
    really is the glue that holds infrastructure and networking as code together.
  prefs: []
  type: TYPE_NORMAL
- en: To a network engineer, concepts such as continuous integration may seem alien
    at first, but instead of talking about deep dive compilation processes, it should
    be focusing on processes. If any network engineer was asked if they could have
    a quick and easy-to-use process that validated all their network changes before
    production, providing quick feedback loops, then the answer would be yes. Continuous
    integration can therefore be a useful tool that would mean less broken production
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, in [Chapter 4](ch04.html "Chapter 4. Configuring Network Devices
    Using Ansible"), *Configuring Network Devices Using Ansible*, [Chapter 5](ch05.html
    "Chapter 5. Orchestrating Load Balancers Using Ansible"), *Orchestrating Load
    Balancers Using Ansible*, and [Chapter 6](ch06.html "Chapter 6. Orchestrating
    SDN Controllers Using Ansible"), *Orchestrating SDN Controllers Using Ansible*,
    we looked at ways that network changes could be treated as code, using configuration
    management tooling such as Ansible to configure network devices, load balancers,
    and SDN controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when considering the following diagram, the question regarding continuous
    integration of network changes is not asking if continuous integration is possible
    for network changes. It should instead be questioning which validation engines
    can be used for network changes after a SCM commit has taken place to give a quick
    feedback loop of **Pass** or **Fail** to network operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network continuous integration](img/B05559_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Network validation engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenge when creating continuous integration builds for network changes
    is what to use for the validation engine. Network changes when using Ansible rely
    heavily on YAML configuration files, so the first validation that can be done
    is checking the YAML `var` files.
  prefs: []
  type: TYPE_NORMAL
- en: The `var` files are used to describe the desired state of the network, so checking
    that these YAML files are valid in terms of syntax is one valid check. So to do
    this, a tool such as `yamllint` can be used to check if the syntax of the files
    that are committed into source control management are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Once the YAML `var` files are checked into source control, the continuous integration
    build should create a tag to state a new release has happened. All SCM systems
    should have a tagging or base-lining feature.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging versions means that the current network release version can be diffed
    against the previous version to see what file changes have occurred on the YAML
    `var` files. If an issue is detected at any stage, all networks changes are made
    transparent.
  prefs: []
  type: TYPE_NORMAL
- en: So what other validation is possible? When focusing on configuration of network
    devices, we are pushing configuration changes to a networking operating system
    such as Juniper Junos or Arista Eos. So being able to run the newly committed
    changes and make sure the syntax is programmatically correct against those operating
    systems as part of the continuous integration process is highly desirable. Most
    network device operating systems as discussed in [Chapter 4](ch04.html "Chapter 4. Configuring
    Network Devices Using Ansible"), *Configuring Network Devices Using Ansible*,
    are Linux-based, so having a network operating system to issue commands to as
    part of the CI process doesn't seem too absurd.
  prefs: []
  type: TYPE_NORMAL
- en: The same can be said when checking the configuration used to orchestrate load
    balancers or SDN controllers, having a test environment attached to the continuous
    integration process is also highly desirable in theory. By utilizing a software
    version of the load balancer or emulated version of the SDN controller would be
    highly beneficial, so network engineers can pre-flight their network changes to
    make sure the API calls and syntax is correct.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are challenges with simulating an SDN controller or creating
    or simulating a production environment depending on the vendor, they may have
    a huge overhead in terms of setting up a continuous integration environment due
    to cost. Network devices, load balancers, and SDN vendors are evolving to support
    automation and DevOps friendly processes such as continuous integration. Therefore,
    networking vendors are starting to appreciate the validity of giving small test
    environments; this is where virtualized or containerized versions of load balancers
    or SDN controllers would be useful as an API endpoint to validate the desired
    state that has been set up in YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately, the vendors could provide a vagrant box to test if the desired
    configuration specified in YAML `var` files that is checked into SCM Systems is
    valid before it is propagated to the first test environment. Any enhancements
    that can be done to processes to make it fail as fast as possible and shift issues
    as far left as possible in the development lifecycle should be implemented where
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: So with all of these validators, let's look at how these processes can be applied
    to network devices, or alternately orchestration. The number of validators used
    may depend on the network vendors that are being used, so we will look at the
    start point for a continuous integration build for network devices regardless
    of vendor and then look at more advanced options that could be used if the vendor
    provides a software load balancer or SDN emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Simple continuous integration builds for network devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As network changes are always required daily by large organizations that are
    implementing microservice applications. To meet those demands networking should
    be as self-service as possible. To keep up with demand, network teams will probably
    need to use a feature branch SCM strategy or allow self-service YAML files to
    be committed directly to the master branch, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple continuous integration builds for network devices](img/B05559_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each commit should be peer reviewed before it is merged. Ideally, the self-service
    process should allow development teams to package network changes alongside their
    code changes and follow a self-service approach.
  prefs: []
  type: TYPE_NORMAL
- en: The first continuous integration build that should be set up for network devices
    or orchestration should focus on version controlling the Ansible YAML files and
    running a simple YAML validation on the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Each continuous integration build that runs will also tag the repository. Tagging
    the SCM repository means that release versions can be compared or easily rolled
    back. It will also act as an audit log to show which user made changes and what
    exactly has changed in the environment. No changes should be made to a production
    system that has not gone through the continuous integration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'So a simple network continuous integration build will follow these simple validation
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML files are checked for syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The repository is tagged in the SCM System if successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, a simple network continuous integration build would follow these
    steps. The network operator would commit the YAML files to the SCM system to change
    the desired state of the network; the continuous integration build server would
    tag the build if the YAML Lint operation finds that all the YAML files in the
    repository have valid syntax and return a positive result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple continuous integration builds for network devices](img/B05559_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a simple Jenkins network CI build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simple continuous integration build for network devices can be set up in
    the Jenkins CI build server. Rake and the `yamllint` gem should be configured
    on the Jenkins slave that the build will be executed on.
  prefs: []
  type: TYPE_NORMAL
- en: Once this has been completed, a new Jenkins CI build can be created in a matter
    of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, select a new Jenkins freestyle job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then configure the SCM system to use, in this instance Git, specifying `git@gitlab:devops/sdn.git`
    as the repository and the `*/master` branch of the project along with the SSH
    key required to provide access to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now for the validation step, a shell command build step is selected, which
    will run `rake yamllint` on the repository after configuring a **Rakefile** in
    the `git@gitlab:devops/sdn.git` repository so the YAML files can be parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, configure the build job to tag the Jenkins build version against the
    `devops/sdn.git` gitlab repository and **Save** the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This has configured a very simple Jenkins CI build process that will poll the
    Git repository for new changes, run `yamllint` against the repository, and then
    tag the Git repository if the build is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build health will be shown in Jenkins; the green ball means the build is
    in a healthy state so the YAML files are currently in a good state, and the duration
    of the check shows it took 6.2 seconds to execute the build, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a simple Jenkins network CI build](img/B05559_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding validations to network continuous integration builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After highlighting the need for more robust validation to pre-flight configuration
    of network devices shifting failure as far left in the development lifecycle as
    possible to reduce the cost to fix. Having the ability to push mission-critical
    configuration changes to a networking operating system such as Cisco Nxos, Juniper
    Junos, or Arista Eos would be a good continuous integration validation.
  prefs: []
  type: TYPE_NORMAL
- en: So, like databases verifying that SQL syntax is correct, being able to run the
    newly committed changes and make sure the networking commands or orchestration
    commands applied to network devices syntax is programmatically correct should
    be part of the continuous integration build.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration can then help the quality of network changes as an incorrect
    change would never be pushed to a network device, load balancer, or SDN controller.
    Of course, the functionality of the configuration pushed may not be what is required,
    but there should at least never be a situation where the configuration has a syntax
    error at deployment time.
  prefs: []
  type: TYPE_NORMAL
- en: As network devices, load balancer, and SDN controller changes are mission-critical,
    this brings an added layer of validation checks to any network changes and checks
    in a quick and automated way, providing quick feedback if a network change is
    not what is required.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration for network devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before setting up a network device, continuous integration of a few prerequisites
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: A network operating system will be required with production configuration pushed
    to it and all live settings, which can be hosted on a virtual appliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The continuous integration build tools such as Jenkins will need to have an
    Ansible Control Host set up on the agent so it can execute Ansible playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All playbooks should be written with a block rescue so subsequent cleanup is
    built-in if the execution of the playbook fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical network device release process will have the two following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the network change self-service playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the playbook is idempotent, changes will only be shown if a change has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ansible playbook should provide resilience for roll-forward and roll-back
    in terms of state change. The previous steps also check the validity of the sequencing
    using the Ansible playbook and also check that the calls being made to the network
    device are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple continuous integration network build process would provide the following
    feedback loop for network operators:'
  prefs: []
  type: TYPE_NORMAL
- en: The network operator commits Ansible playbook or YAML `var` file's change to
    **SCM System**, and it is integrated with the code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code base is pulled down to a **CI Build Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML files are checked using `yamllint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ansible playbook is applied to push network changes to the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return **Pass** or **Fail** exit conditions and feedback to users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-5 for the next network device change:![Continuous integration
    for network devices](img/B05559_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous integration builds for network orchestration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before setting up a network orchestration for load balancers or SDN controllers,
    a few prerequisites are required:'
  prefs: []
  type: TYPE_NORMAL
- en: A software load balancer or an emulated SDN controller will be required with
    production configuration pushed to it and all live settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The continuous integration build tools such as Jenkins will need to have an
    Ansible controller set up on the agent so it can execute Ansible playbooks as
    well as the SDK that will allow the network orchestration modules to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All playbooks should be written with a block rescue so subsequent cleanup is
    built in if the execution of the playbook fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical network device release process will have the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply network changes to the self-service playbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the playbook is idempotent, changes will be only shown if a change has occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible playbook, like with the network device changes should provide resilience
    for roll-forward and roll-back in terms of state change. Some test servers may
    be needed on a virtualization platform to simulate the load balancing so health
    checks can be tested too.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple continuous integration network orchestration continuous integration
    process would provide the following feedback loop for network operators:'
  prefs: []
  type: TYPE_NORMAL
- en: The network operator commits Ansible playbook or YAML `var` file change to **SCM
    System** and it is integrated with the code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code base is pulled down to a **CI Build Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML files are checked using `yamllint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Ansible playbook is applied to orchestrate the API and create the necessary
    load balancer or SDN changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return **Pass** or **Fail** exit condition and feedback to users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-5 for next network orchestration change:![Continuous integration
    builds for network orchestration](img/B05559_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at what continuous integration is and how continuous
    integration processes can be applied to code and databases. The chapter then looked
    at ways that continuous integration can be applied to assist with network operations
    to provide feedback loops.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored different SCM methodologies, the difference between centralized
    and distributed SCM systems and how branching strategies are used with waterfall
    and agile processes.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked into the vast array of tools available for creating continuous
    integration processes focusing on some examples using Jenkins to set up a simple
    network continuous integration build.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned what continuous integration is, how it can be applied
    to network operations, SCM tooling, and the difference between centralized and
    distributed systems along with common SCM branching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Other key takeaways from this chapter include continuous integration build servers
    and their use, ways to integrate network changes into continuous integration,
    and potential continuous integration validation engines for network changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at various test tools and how they can be
    applied to continuous integration processes for added validation. This will allow
    unit tests to be created for network operations to make sure the desired state
    is actually implemented on devices before we will look at deploying the network
    changes in Continuous Delivery pipelines.
  prefs: []
  type: TYPE_NORMAL
