<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor458"/>10</h1>
<h1 id="_idParaDest-149"><a id="_idTextAnchor459"/>Building Out a Cloud Network</h1>
<p>Now that we have launched servers in Microsoft Azure, we will start looking at launching services within <a id="_idTextAnchor460"/><a id="_idTextAnchor461"/><strong class="bold">Amazon Web </strong><strong class="bold">Services</strong> (<strong class="bold">AWS</strong>).</p>
<p>Before we launch virtual machine instances, we must create a network to host them. This is called a <a id="_idTextAnchor462"/><strong class="bold">virtual private cloud</strong> (<strong class="bold">VPC</strong>) and there are a few different elements we will need to bring together in a playbook to create one, which we will then be able to use for our instances.</p>
<p><a id="_idTextAnchor463"/>In this chapter, we will do the following:</p>
<ul>
<li>Receive an introduction to AWS</li>
<li>Cover what it is we are trying to achieve and why</li>
<li>Create a VPC, subnets, and routes (networking and routing)</li>
<li>Create security groups (firewall)</li>
</ul>
<p>We will look at more advanced Ansible techniques as we launch and manage more dynamic resources with complex dependencies.</p>
<p>The chapter covers the following topics:</p>
<ul>
<li>An introduction to AWS</li>
<li>Amazon VPC overview</li>
<li>Creating an access key and secret</li>
<li>Getting Ansible ready for targeting AWS</li>
<li>The AWS playbook</li>
<li>Running the playbook</li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor464"/>Technical requirements</h1>
<p>This chapter will use <a id="_idTextAnchor465"/>AWS; you will need administrator access to create the roles needed to allow Ansible to interact with your account. As with other chapters, you can find the complete playbooks in the <code>Chapter10</code> folder in the accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter10">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor466"/>An introduction to AWS</h1>
<p>AWS has been<a id="_idIndexMarker547"/> around since 2002; it started by offering a few services that were not linked in any way. It progressed in this form until early 2006 when it was relaunched. The relaunched<a id="_idIndexMarker548"/> AWS brought together three services:</p>
<ul>
<li><strong class="bold">Amazon Elastic Compute Cloud</strong> (<strong class="bold">Amazon EC2</strong>): This is <a id="_idIndexMarker549"/>the AWS compute service</li>
<li><strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">Amazon S3</strong>): Amazon’s<a id="_idIndexMarker550"/> scalable object storage service</li>
<li><strong class="bold">Amazon Simple Queue Service</strong> (<strong class="bold">Amazon SQS</strong>): This service provides a message<a id="_idIndexMarker551"/> queue, primarily for web applications</li>
</ul>
<p>Since 2006, it has grown from three unique services to over 160, covering over 15 primary areas such as the following:</p>
<ul>
<li>Compute</li>
<li>Storage</li>
<li>Database</li>
<li>Networking and content delivery</li>
<li>Machine learning analytics security, identity, and compliance</li>
<li>Internet of things</li>
</ul>
<p>At its earnings call in October 2023, it was revealed that AWS had USD 23.06 billion in revenue in the third quarter of 2023, good for a service that initially offered to share idle compute time.</p>
<p>At the time of writing, AWS s<a id="_idTextAnchor467"/>pans 32 geographic regions, which host a total of 102 availability zones (<a href="https://aws.amazon.com/about-aws/global-infrastructure/">https://aws.amazon.com/about-aws/global-infrastructure/</a>).</p>
<p>So, what makes AWS so successful? Not only its coverage but its approach to putting out its services. Andy Jassy, AWS CEO, has been quoted as saying:</p>
<p class="author-quote">“<em class="italic">Our mission is to enable any developer or any company to be able to build all their technology applications on top of our infrastructure technology platform</em>.”</p>
<p>As an individual, you have access to the same APIs, services, regions, tools, and pricing models as large multi-national companies and Amazon themselves, as they consume their services. This gives you the freedom to start small and scale massively. For example, Amazon EC2 instances start from around USD 4.50 per month for a t2.nano (1 vCPU and 0.5G) all the way up to over USD 19,000 per month for an x1e.32xlarge (128 vCPU, 3,904 GB RAM, and two 1920 GB SSD storage); as you can see, there are instance types for every workload imaginable.</p>
<p>Both instances and<a id="_idIndexMarker552"/> most services are billed under pay-as-you-go, from per-second billing for EC2 instances to pay per GB per month for the storage you are using.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor468"/>Amazon VPC overview</h1>
<p>In this chapter, we <a id="_idIndexMarker553"/>are going to be concentrating on launching an <strong class="bold">Amazon Virtual Private Cloud</strong> (<strong class="bold">Amazon VPC</strong>); this is the networking layer that will host the computing and other Amazon services that we will be launching in <a href="B21620_11.xhtml#_idTextAnchor501"><em class="italic">Chapter 11</em></a>, <em class="italic">Highly Available </em><em class="italic">Cloud Deployments</em>.</p>
<p>We are going to be launching our VPC into the <strong class="bold">EU-West #1 (Ireland)</strong> region; we will be spanning all three availability zones for <a id="_idIndexMarker554"/>our <strong class="bold">EC2</strong> instances and also <a id="_idIndexMarker555"/>the <strong class="bold">Application Elastic Load Balancer</strong>. We will, again, be using <a id="_idIndexMarker556"/>the three availability zones for our <strong class="bold">Amazon Relational Database Service</strong> (<strong class="bold">RDS</strong>) instance and also two zones <a id="_idIndexMarker557"/>for the <strong class="bold">Amazon Elastic File System</strong> (<strong class="bold">Amazon </strong><strong class="bold">EFS</strong>) volumes.</p>
<p>This all means our Ansible playbook needs to create/configure the following:</p>
<ul>
<li>One Amazon VPC</li>
<li>Three subnets for EC2 instances</li>
<li>Three subnets for Amazon RDS instances</li>
<li>Three subnets for Amazon E<a id="_idTextAnchor469"/>FS volumes</li>
<li>Three subnets for the Application Load Balancer</li>
<li>One internet gateway</li>
</ul>
<p>We will also need to configure the following:</p>
<ul>
<li>One route to allow access through the internet gateway</li>
<li>One security group that allows everyone to access port <code>80</code> (HTTP) and <code>443</code> (HTTPS) on the Application Load Balancer</li>
<li>One security group that allows trusted source access to port <code>22</code> (SSH) on the EC2 instances</li>
<li>One security group that allows access to port <code>80</code> (HTTP) from the Application Load Balancer to the EC2 instances</li>
<li>One security group that allows access to port <code>3306</code> (MySQL) on the Amazon RDS instances from the EC2 instances</li>
<li>One security group that allows access to port <code>2049</code> (NFS) on the Amazon EFS volumes from the EC2 instances</li>
</ul>
<p>This will give us our primary network, allowing restrictive access to everything but the Application Load Balancer, which we want to be publicly available.</p>
<p>Before creating an <a id="_idIndexMarker558"/>Ansible playbook that deploys the network, we need to get an AWS API access key and secret.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor470"/>Creating an access key and secret</h1>
<p>It is more than<a id="_idIndexMarker559"/> possible to create an access key and secret key for your AWS user to give Ansible full access to your AWS account.</p>
<p>Because of this, we are going to look at creating a user for Ansible, which only has permission to access the parts of AWS we know that Ansible will need to interact with for the tasks we are covering in this chapter. We will be giving Ansible full access to the following services:</p>
<ul>
<li>Amazon VPC</li>
<li>Amazon EC2</li>
<li>Amazon RDS</li>
<li>Amazon EFS</li>
</ul>
<p>To do this, follow these steps:</p>
<ol>
<li>Log in to the AWS console, which can be found at <a href="https://console.aws.amazon.com/">https://console.aws.amazon.com/</a>.</li>
<li>Once logged in, click on <code>IAM</code> into the search box and then click on the <strong class="bold">IAM “Manage access to AWS </strong><strong class="bold">resources”</strong> result.</li>
<li>On the <strong class="bold">IAM</strong> page, click <strong class="bold">User Groups</strong> in the left-hand side menu; we will create a group with the permissions assigned to it, and then we will create a user and add it to our group.</li>
<li>Once on the <code>Ansible</code>.</li>
<li>Now, in the <strong class="bold">Attach permissions policies – Optional</strong> sec<a id="_idTextAnchor471"/>tion, select <strong class="bold">AmazonEC2FullAccess</strong>, <strong class="bold">AmazonVPCFullAccess</strong>, <strong class="bold">AmazonRDSFullAccess</strong>, and <strong class="bold">AmazonElasticFileSystemFullAccess</strong>; once all four have been selected, click on the <strong class="bold">Create Group</strong> button at the bottom of the page.</li>
<li>Now that we have our Ansible group, click <strong class="bold">Users</strong> in the left-hand side menu.</li>
<li>Once on the <code>LearnAnsible</code> in here</li><li>Leave the <strong class="bold">Provide user access to the AWS Management Console – optional</strong> option unchecked, as we will create a programmatic user</li></ul></li>
<li>Click on the <code>Ansible</code> group we created earlier ticked, and then click <strong class="bold">Next</strong>, which will take you to the <strong class="bold">Review and </strong><strong class="bold">Create</strong> page.</li>
<li>Once you <a id="_idIndexMarker560"/>have reviewed the details, you need to click the <code>LearnAnsible</code> user.</li>
<li>The final step is to get an access key for our user. To get this, click on the <code>LearnAnsible</code> user and select the <strong class="bold">Security credentials</strong> tab; from there, scroll down to <strong class="bold">Access Keys</strong> and click the <strong class="bold">Create access </strong><strong class="bold">key</strong> button.</li>
<li>In the list of <code>For use with Learn Ansible</code> for the description tag value and then click <strong class="bold">Create </strong><strong class="bold">access key</strong>.</li>
<li>The <strong class="bold">Retrieve access keys</strong> page is the only time you get access to the Secret access key, so I recommend downloading the CSV file. Once downloaded, click on <strong class="bold">Done</strong>.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">The CSV file you have just downloaded contains credentials allowing whoever has them to launch resources in your AWS account; please do not share them and keep them safe, as they could be misused, resulting in a huge and unexpected AWS bill should they fall into the wrong hands.</p>
<p>Now that we have an access key ID and secret access key for a user with the permissions, we <a id="_idIndexMarker561"/>need to launch our VPC using Ansible; we can start getting Ansible ready and reviewing the playbook.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor473"/>Getting Ansible ready for targeting AWS</h1>
<p>We first<a id="_idIndexMarker562"/> need to discuss how to pass our access key ID and <a id="_idIndexMarker563"/>secret access key to Ansible safely and securely. As I will share the final playbooks in a public repository on GitHub, I want to keep my AWS keys private from the world as that could get expensive! Typically, if it were a private repository, I would use Ansible Vault or some other secret management to encrypt the keys and include them with other potentially sensitive data, such as deployment keys.</p>
<p>In this case, I don’t want to include any encrypted information in the repository, as it would mean that people would need to unencrypt it, edit the values, and then re-encrypt it. Luckily, the AWS modules allow you to set two environment variables on your Ansible controller; those variables will then be read as part of the playbook execution.</p>
<p>To set the variables, run the following commands to make sure that you replace the content with your access key and secret after <code>=</code> (the information listed as follows is just placeholder values):</p>
<pre class="console">
$ export AWS_ACCESS_KEY=AKIAI5KECPOTNTTVM3EDA
$ export AWS_SECRET_KEY=Y4B7FFiSWl0Am3VIFc07lgnc/TAtK5+RpxzIGTr</pre> <p>Once set, you can view the contents by running the following:</p>
<pre class="console">
$ echo $AWS_ACCESS_KEY</pre> <p>Now that we can securely pass our credentials to Ansible, we can install the Python modules needed by the AWS Ansible modules to interact with the AWS API.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You must set the environment variables for each terminal session, as they will be lost each time you close your terminal.</p>
<p>To install the Python modules, run the following command:</p>
<pre class="console">
$ pip3 install botocore boto3</pre> <p>Now that <a id="_idIndexMarker564"/>we<a id="_idIndexMarker565"/> have the basics configured, we can review our playbook.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor474"/>The AWS playbook</h1>
<p>As mentioned at the <a id="_idIndexMarker566"/>start of the chapter, we are going to be using some more advanced techniques when it comes to deploying resources in AWS where possible; I have tried to allow the resources to be deployed as dynamically as possible, a lot of which comes down to how we define our variables, which is where we are going to start our playbook review.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor475"/>The playbook variables</h2>
<p>Most of the <a id="_idIndexMarker567"/>variables we define can be found in <code>group_vars/common.yml</code>, and as you can see from the following, they start by looking a lot like the variables we described in <a href="B21620_09.xhtml#_idTextAnchor411"><em class="italic">Chapter 9</em></a>, <em class="italic">Moving to </em><em class="italic">the Cloud</em>:</p>
<pre class="source-code">
debug_output: false
app:
  name: "learnansible"
  region: "eu-west-1"
  env: "prod"</pre> <p>As you can see, we have the same <code>debug_output</code> feature flag and selection of variables used to describe our app and the AWS region in which it will be launched.</p>
<p>Next up, we have the resource names:</p>
<pre class="source-code">
vpc_name: "{{ app.name }}-{{ app.env }}-{{ playbook_dict.vpc }}"
internet_gateway_name: "{{ app.name }}-{{ app.env }}-{{ playbook_dict.internet_gateway }}"
internet_gateway_route_name: "{{ internet_gateway_name }}-{{ playbook_dict.route }}"</pre> <p>Nothing too out<a id="_idIndexMarker568"/> of the ordinary so far, but here we will find our first difference in approach:</p>
<pre class="source-code">
vpc:
  cidr_block: "10.0.0.0/23"
  dns_hostnames: true
  dns_support: true
  subnet_size: "27"
  subnets:
    - name: "ec2"
      role: "{{ subnet_role_compute }}"
    - name: "rds"
      role: "{{ subnet_role_database }}"
    - name: "efs"
      role: "{{ subnet_role_storage }}"
    - name: "dmz"
      role: "{{ subnet_role_public }}"</pre> <p>At first glance, that doesn’t look too dissimilar to what we did for Microsoft Azure.</p>
<p>However, you might have noticed that there are no IP address CIDR ranges listed for the subnets, just some details about the subnets, including a dictionary of roles:</p>
<pre class="source-code">
subnet_role_compute: "compute"
subnet_role_database: "database"
subnet_role_storage: "storage"
subnet_role_public: "public"</pre> <p>We will look at why the subnet’s CIDR ranges are missing when we get to the tasks that create the subnet.</p>
<p>Next, we have the variables for creating the security groups; in total, we will be configuring four security groups, so in the interest of space, I will only be showing one of the small groups here:</p>
<pre class="source-code">
security_groups:
  - name: "{{ app.name }}-rds-{{ playbook_dict.security_group }}"
    description: "opens port 3306 to the ec2 instances"
    id_var_name: "rds_group_id"
    rules:
      - proto: "tcp"
        from_port: "3306"
        to_port: "3306"
        group_id: "{{ ec2_group_id | default('') }}"
    <a id="_idTextAnchor476"/>    rule_desc: "<a id="_idTextAnchor477"/>allow {{ ec2_group_id | default('') }} access to port 3306"</pre> <p>See the GitHub repo for the full configuration for the four security groups; there is only one thing at this point to highlight, and that is this: where we reference <code>{{ e<a id="_idTextAnchor478"/>c2_group_id | default('') }}</code>, we are setting a default value of nothing (which is the <code>''</code> part). We will discuss why we are doing this when we cover the security role.</p>
<p>The final set of<a id="_idIndexMarker569"/> variables is the dictionary (<code>playbook_dict</code>) and a variable, which sets the value of <code>region</code> using <code>app.region</code>; again, see the GitHub if you want to see all the contents.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor479"/>The VPC role</h2>
<p>Before we get<a id="_idIndexMarker570"/> to the exciting tasks, we need to create the VPC. The task in <code>roles/vpc/tasks/main.yml</code> looks like the following:</p>
<pre class="source-code">
- name: "Create VPC"
  amazon.aws.ec2_vpc_net:
    name: "{{ vpc_name }}"
    region: "{{ region }}"
    cidr_block: "{{ vpc.cidr_block }}"
    dns_hostnames: "{{ vpc.dns_hostnames }}"
    dns_support: "{{ vpc.dns_support }}"
    state: "{{ state }}"
    tags:
      Name: "{{ vpc_name }}"
      projectName: "{{ app.name }}"
      environment: "{{ app.env }}"
      deployedBy: "{{ playbook_dict.deployedBy }}"
      description: "{{ playbook_dict.ansible_warning }}"
  register: vpc_output</pre> <p>The task is pretty much as you would expect, apart from the tags being set a little more in line than those<a id="_idIndexMarker571"/> we defined in <a href="B21620_09.xhtml#_idTextAnchor411"><em class="italic">Chapter 9</em></a>, <em class="italic">Moving to the Cloud</em>. There is also a debug statement that prints the results of creating the VPC if you set <code>debug_output</code> to <code>true</code>:</p>
<pre class="source-code">
- name<a id="_idTextAnchor480"/>: "Debug - VPC result"
  ansible.builtin.debug:
    var: "vpc_output"
  when: debug_output</pre> <p>From now on, it is safe to assume that all registered output will be followed by an <code>ansible.builtin.debug</code> task. Now that we have our VPC launched, we can start putting things inside it, beginning with the subnets, where things get more interesting.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor481"/>The subnets role</h2>
<p>As mentioned in<a id="_idIndexMarker572"/> the AWS overview, there are 32 geographic regions and, at<a id="_idTextAnchor482"/> the time of writing, 102 Availability Zones. AWS differs from Microsoft Azure in t<a id="_idTextAnchor483"/>hat you need a subnet per Availability Zone rather than a single subnet spanning all the availability zones.</p>
<p>The <code>eu-west-1</code> region, which is the region we w<a id="_idTextAnchor484"/>ill target, is made up of three availability zones, and we have subnets for four different roles, meaning that we need 12 subnets in total, but our playbook could easily be targeting a region that only has two availability zones, or in some cases, even more.</p>
<p>So, our first task is to get information on the availability zones in our target region:</p>
<pre class="source-code">
- name: "Get some information on the available zones"
  amazon.aws.aws_az_info:
    region: "{{ region }}"
  register: zones_output</pre> <p>Now that we know some information on the region, we can use that information and create our subnets:</p>
<pre class="source-code">
- name: "Create all subnets"
  ansible.builtin.include_tasks: create_subnet.yml
  loop: "{{ vpc.subnets }}"
  loop_control:
    loop_var: subnet_item
    index_var: subnet_index
  vars:
    subnet_name: "{{ subnet_item.name }}"
    subnet_role: "{{ subnet_item.role }}"
    az_zones_from_main: "{{ zones_output }}"
  register: subnet_output</pre> <p>This task is quite different from the ones we have been using so far in the book, so let’s take a deeper dive into what is happening.</p>
<p>Here, we are using a loop to automate the creation of multiple subnets. Each iteration of the loop processes one subnet from the <code>vpc.subnets</code> list, which, as we have already seen, contains the configuration details for each subnet.</p>
<p>As the loop runs, it assigns the current subnet’s details to the <code>subnet_item</code> variable and its index in the list to <code>subnet_index</code>. These variables are then utilized to customize the creation process for each subnet.</p>
<p>The task includes and exec<a id="_idTextAnchor485"/>utes the steps defined in <code>create_subnet.yml</code> (which we will cover next) for each subnet, using the specific details of that subnet (such as its name and role).</p>
<p>You may have noticed that we still haven’t passed in any CIDR ranges for the subnets; this is all handled within the <code>create_subnet.yml</code> task, which we loop over for each of our four <a id="_idIndexMarker573"/>subnet types; this is also where a second loop happens:</p>
<pre class="source-code">
- name: "Create subnet in the availability zone"
  amazon.aws.ec2_vpc_subnet:
    region: "{{ region }}"
    state: "{{ state }}"
    vpc_id: "{{ vpc_output.vpc.id }}"
    cidr: "{{ vpc_output.vpc.cidr_block | ansible.utils.ipsubnet(vpc.subnet_size, az_loop_index + (subnet_index * az_zones_from_main.availability_zones|length)) }}"
    az: "{{ az_item.zone_name }}"
    tags:
      Name: "{{ subnet_name }}-{{ playbook_dict.subnet }}-{{ az_item.zone_id }}"
      projectName: "{{ app.name }}"
      environment: "{{ app.env }}"
      deployedBy: "{{ playbook_dict.deployedBy }}"
      description: "{{ playbook_dict.ansible_warning }}"
      role: "{{ subnet_role }}"
  loop: "{{ az_zones_from_main.availability_zones }}"
  loop_control:
    loop_var: az_item
    index_var: az_loop_index</pre> <p>Please stick with me, as this is where it gets a little confusing; for each of the four loops we are enacting from our main loop, we are taking the information on the availability zones and then looping over them, creating a subnet per availability zone for the role we are currently looping over.</p>
<p>So, what about the CIDR range for the subnet?</p>
<p>You may have <a id="_idIndexMarker574"/>noticed something where you would expect to see the CIDR rang<a id="_idTextAnchor486"/>e; we have this expression:</p>
<pre class="source-code">
<a id="_idTextAnchor487"/>vpc_output.vpc.cidr_block | ansible.utils.ipsubnet(vpc.subnet_size, az_loop_index + (subnet_index * az_zones_from_main.availability_zones|length))</pre> <p>We have the following components in the expression:</p>
<ul>
<li><code>vpc_output.vpc.cidr_block</code>: This is the CIDR block of the VPC, within which the subnets will be created. For our example, it’s <code>10.0.0.0/22</code>.</li>
<li><code>vpc.subnet_size</code>: This specifies the size of each subnet. We are using <code>/27</code>, representing a subnet with 32 IP addresses.</li>
<li><code>az_zones_from_main.availability_zones|length</code>: This is the total number of availability zones available. The region we are targeting has <code>3</code> availability zones.</li>
<li><code>az_loop_index</code>: This is the current index in the loop over the availability zones.</li>
<li><code>subnet_index</code>: This is the index of the current subnet being processed.</li>
</ul>
<p>This means that for our expression, we will get the following results. The first subnet, which is labeled <code>az1</code>) will have the following:</p>
<ul>
<li><code>az_loop_index = 0</code></li>
<li><code>subnet_index = 0</code></li>
</ul>
<p>So, the formula would be <code>0+(0*3)=0</code>, meaning that we would get the following:</p>
<pre class="source-code">
cidr = "{{ vpc_output.vpc.cidr_block  | ansible.utils.ipsubnet(27, 0) }}"</pre> <p>With <code>vpc_output.vpc.cidr_block</code> being <code>10.0.0.0/22</code>, we could get the first <code>/27</code>, which would be <code>10.0.0.0/27</code>.</p>
<p>For the second availability zone (<code>az2</code>), the loop would be the following:</p>
<ul>
<li><code>az_loop_index = 1</code></li>
<li><code>subnet_index = 0</code></li>
</ul>
<p><code>1+(0*3)=1</code> means we would get <code>10.0.0.32/27</code> since the next subnet block starts immediately after the <a id="_idIndexMarker575"/>previous one at the next 32 IP address interval.</p>
<p>The third Availability Zone (<code>az3</code>) would be <code>2+(0*3)=2</code>, and the CIDR block would be <code>10.0.0.64/27</code>.</p>
<p>The next subnet role, which is the RDS role, would give the following for <code>az1</code>:</p>
<ul>
<li><code>az_loop_index = 0</code></li>
<li><code>subnet_index = 1</code></li>
</ul>
<p>The formula would be <code>0+(1*3)=3</code>, giving us a CIDR block <code>10.0.0.96/27</code>.</p>
<p>This pattern would follow the sequence, where the next subnet for RDS <code>az2</code> would be at <code>10.0.0.128/27</code>, and for <code>az3</code>, it would be at <code>10.0.0.160/27</code>, and so on.</p>
<p>This expression ensures that each subnet created within the VPC is assigned a unique and non-overlapping CIDR block, segmented adequately according to the defined subnet size, and distributed across different availability zones.</p>
<p>Taking this approach not only simplifies the management of subnet creation but also ensures efficiency when it comes to writing the role, as it means that we don’t have to hardcode tasks to consider changes between regions or the number of subnets we are defining in our variables.</p>
<p>The remaining tasks in the role build a list of the subnet IDs for each of the roles we have defined. An example of one of these tasks is as follows:</p>
<pre class="source-code">
- name: "Gather information about the compute subnets"
  amazon.aws.ec2_vpc_subnet_info:
    region: "{{ region }}"
    fi<a id="_idTextAnchor488"/>lters:
      "tag:role": "{{ subnet_role_compute }}"
      "tag:environment": "{{ app.env }}"
      "tag:projectName": <a id="_idTextAnchor489"/>"{{ app.name }}"
  register: subnets_compute_output</pre> <p>This gets information on the three subnets assigned the <code>subnet_role_compute</code> role. A few more of these data-gathering tasks can be found in the repo; these cover the <code>subnet_role_database</code>, <code>subnet_role_storage</code>, and <code>subnet_role_public</code> roles.</p>
<p>Finally, the final task in the role prints the subnet IDs that we have gathered using the previous set of tasks; this looks slightly different to the debug statements we have been using in the<a id="_idIndexMarker576"/> playbook so far, as we are using the <code>msg</code> function rather than the <code>var</code> one when calling the <code>ansible.builtin.debug</code> module.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor490"/>The gateway role</h2>
<p>The gateway role <a id="_idIndexMarker577"/>is relatively simple compared to the previous one. In comparison, it deploys an internet gateway. Then, it creates a route to send all traffic destined for the internet (represented by using <code>0.0.0.0/0</code>, the CIDR notation for all network traffic) to our newly launched internet gateway.</p>
<p>The task that creates the internet gateway looks like the following:</p>
<pre class="source-code">
- name: "Create an Internet Gateway"
  amazon.aws.ec2_vpc_igw:
    region: "{{ region }}"
    state: "{{ state }}"
    vpc_id: "{{ vpc_output.vpc.id }}"
    tags:
      "Name": "{{ internet_gateway_name }}"
      "projectName": "{{ app.name }}"
      "environment": "{{ app.env }}"
      "deployedBy": "{{ playbook_dict.deployedBy }}"
      "description": "{{ playbook_dict.ansible_warning }}"
      "role": "igw"
  register: internet_gateway_output</pre> <p>As per the rest of the tasks, a debug task follows this, and then the task that creates the route table, which is then associated with our newly created internet gateway and also the computing<a id="_idIndexMarker578"/> and public subnets that we defined and gathered the information for in the subnet’s role:</p>
<pre class="source-code">
- name: "Create a route table so the internet gateway can be used by the public subnets"
  amazon.aws.ec2_vpc_route_table:
    region: "{{ region }}"
    state: "{{ state }}"
    vpc_id: "{{ vpc_output.vpc.id }}"
    subnets: "{{ subnet_compute_ids + subnet_public_ids }}"
    routes:
      - dest: "0.0.0.0/0"
        gateway_id: "{{ internet_gateway_output.gateway_id }}"
    resource_tags:
      "Name": "{{ internet_gateway_route_name }}"
      "projectName": "{{ app.name }}"
      "environment": "{{ app.env }}"
      "deployedBy": "{{ playbook_dict.deployedBy }}"
      "description": "{{ playbook_dict.ansible_warning }}"
      "role": "route"
  register: internet_gateway_route_output</pre> <p>We then do a debug task that completes this role, and we then move on to the final role of the<a id="_idIndexMarker579"/> playbook: the security group’s role.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor491"/>The security group’s role</h2>
<p>While this role, in<a id="_idIndexMarker580"/> my opinion, is not as complicated as the subnet’s role, we have built a little more logic into the task than some of the more straightforward tasks in the book that we have run so far.</p>
<p>If you recall, earlier in the chapter, when we covered the variables being used by the playbook, we gave the following example of the security groups being deployed:</p>
<pre class="source-code">
  - proto: "tcp"
    from_port: "3306"
    to_port: "3306"
    group_id: "{{ e<a id="_idTextAnchor492"/>c2_group_id | default<a id="_idTextAnchor493"/>('') }}"
    rule_desc: "allow {{ ec2_group_id | default('') }} access to port 3306"</pre> <p>The preceding rule, as per <code>rule_desc</code>, opens up port <code>3306</code> for any devices that have the EC2 security group attached to them, which, as we will see in <a href="B21620_11.xhtml#_idTextAnchor501"><em class="italic">Chapter 11</em></a>, <em class="italic">Highly Available Cloud Deployments</em>, will be the EC2 instances that will be running our workload.</p>
<p>You may think to yourself, <em class="italic">“Now that makes sense.”</em> However, this is a little bit of a flaw in the logic we must work around. <code>ec2_group_id</code> is referencing a group ID, which, at the time we first run our playbook, doesn’t exist. So, how can we create the groups and populate them with rules that reference groups that don’t yet exist?</p>
<p>As we have already seen, looping over the resources defined in our variables is more efficient. It reduces the hard-coded logic at the role level, making the role more re-useable between projects and playbooks.</p>
<p>Before we look at the logic of creating the groups, we need to gather one bit of information: the public IP address of the resource running Ansible. To do this, we call the following task:</p>
<pre class="source-code">
- name: "Find out your current public IP address using https://ipify.org/"
  community.general.ipify_facts:
  register: public_ip_output</pre> <p>Then we set a <a id="_idIndexMarker581"/>fact called <code>your_public_ip</code>, which we can reference in our rules where needed:</p>
<pre class="source-code">
- name: "Set your public ip as a fact"
  ansible.builtin.set_fact:
    your_public_ip: "{{ public_ip_output.ansible_facts.ipify_public_ip }}/32"</pre> <p>Now that we have that snippet of information, we can return to the question of how we can reference the IDs of resources that have yet to be launched.</p>
<p>To create the security groups, we will be using the <code>amazon.aws.ec2_security_group</code> mo<a id="_idTextAnchor494"/>dule. The module has a flag called <code>purge_rules</code>, set to <code>true</code> by default; in this default state, when our playbook finds and needs to update an existing security group, it will drop all the rules in the group and then add just the ones defined in the playbook to maintain a consistent state.</p>
<p>While it is a valid use case, in our example, disabling this functionality by setting <code>purge_rules</code> to <code>false</code> will allow us to create some unpopulated security groups:</p>
<pre class="source-code">
- name: "Create the base security groups"
  amazon.aws.ec2_security_group:
    region: "{{ region }}"
    state: "{{ state }}"
    vpc_id: "{{ vpc_output.vpc.id }}"
    name: "{{ item.name }}"
    description: "{{ item.description }}"
    purge_rules: false
    tags:
      "Name": "{{ item.name }}"
      "projectName": "{{ app.name }}"
      "environment": "{{ app.env }}"
      "deployedBy": "{{ playbook_dict.deployedBy }}"
      "role": "securitygroup"
  loop: "{{ security_groups }}"
  register: base_security_groups_output</pre> <p>This will loop through and create the base, unpopulated security groups if they don’t exist, and if they do already exist, no changes will be made to them.</p>
<p>So, now that we have our groups created, or if they already exist, we have the information we <a id="_idIndexMarker582"/>need to dynamically define some facts based on the output of the previous tasks:</p>
<pre class="source-code">
- name: "Set the fact for the security group ids"
  ansible.builtin.set_fact:
    "{{ item.id_var_name }}": "{{ base_security_groups_output.results | selectattr('item.name', 'equalto', item.name) | map(attribute='group_id') | first }}"
  loop: "{{ security_groups }}"
  when: base_security_groups_output.results | selectattr('item.name', 'equalto', item.name) | map(attribute='group_id') | list | length &gt; 0</pre> <p>This task uses the <code>ansible.builtin.set_fact</code> module, allowing the creation or update of new variables during runtime. This task aims to extract the unique ID of each security group created in the first task and assign it to a specific variable name.</p>
<p>There are two expressions we use to do this. The first is the following:</p>
<pre class="source-code">
<code>"{{ item.id_var_name }}": "{{ base_security_groups_output.results | selectattr('item.name', 'equalto', item.name) | map(attribute='group_id') | first }}"</code></pre> <p>This is used to create the dynamic set of variables based on the loop created by the second expression. A breakdown of this first expression follows:</p>
<ul>
<li><code>base_security_groups_output.results</code>: This refers to the list of results from the previous task that created the security groups. Each result in this list contains data about one of the security groups.</li>
<li><code>selectattr('item.name', 'equalto', item.name)</code>: The <code>selectattr</code> filter is used to search through the list of results. It looks for results where the name attribute of the item (each security group) is equal to the current <code>item.name</code> in the loop. In other words, it filters the results to find the specific security group we’re currently interested in.</li>
<li><code>map(attribute='group_id')</code>: The <code>map</code> filter is then used to transform the filtered list of results. It extracts only the <code>group_id</code> attribute from each result, which is the ID of the security group.</li>
<li><code>first</code>: Since the previous step can still return a list (albeit with a single element), the <code>first</code> filter takes only the first element from this list, which should be the unique ID of the security group.</li>
</ul>
<p>The result of this <a id="_idIndexMarker583"/>expression is the ID of the security group that matches the current item in the loop, and it’s assigned to a variable named according to <code>item.id_var_name</code>.</p>
<p>The second expression, which is in the <code>when</code> condition, runs as part of the loop:</p>
<pre class="source-code">
when: base_security_groups_output.results | selectattr('item.name', 'equalto', item.name) | map(attribute='group_id') | list | length &gt; 0</pre> <p>This expression determines whether the task should be executed for a particular item in the loop. It follows a similar logic to the first expression:</p>
<ul>
<li>It starts with the same filtering process to find the security group that matches the current <code>item.name</code>.</li>
<li>After extracting the <code>group_id</code>, it ensures the output is treated as a list using the <code>list</code> filter.</li>
<li><code>length &gt; 0</code>: This part checks whether the length of the list (the number of items in it) is greater than <code>0</code>. This means at least one security group with the specified name must exist. If the list is empty, no matching security group is found, and the task will be skipped for the current item.</li>
</ul>
<p>In theory, we should have now populated the variables that contain the security group IDs, meaning that we can now add the rules:</p>
<pre class="source-code">
- name: "Provision security group rules"
  amazon.aws.ec2_security_group:
    region: "{{ region }}"
    state: "{{ state }}"
    vpc_id: "{{ vpc_output.vpc.id }}"
    name: "{{ item.name }}"
    description: "{{ item.description }}"
    purge_rules: false
    rules: "{{ item.rules }}"
  loop: "{{ security_groups }}"
  register: security_groups_with_rules_output</pre> <p>This will loop over<a id="_idIndexMarker584"/> the already created groups and populate the rules for each one, using the group IDs from the variables we dynamically defined in the previous task.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor495"/>Running the playbook</h1>
<p>As mentioned<a id="_idIndexMarker585"/> earlier, we worked our way through the playbook code; before you run the playbook, you must set the <code>AWS_ACCESS_KEY</code> and <code>AWS_SECRET_KEY</code> environment variables on your terminal session by running the following, making sure to update any values to those that you made a note of when you created the Ans<a id="_idTextAnchor496"/>ible user in the AWS console:</p>
<pre class="console">
$ export AWS_ACC<a id="_idTextAnchor497"/>ESS_KEY=AKIAI5KECPOTNTTVM3EDA
$ export AWS_SECRET_KEY=Y4B7FFiSWl0Am3VIFc07lgnc/TAtK5+RpxzIGTr</pre> <p>With the environment variables set, you can run the playbook running the now very familiar following code:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml</pre> <p>Once completed, you should see something like the following terminal output:</p>
<div><div><img alt="Figure 10.1 – Running the playbook in a terminal" src="img/B21620_10_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Running the playbook in a terminal</p>
<p>Going to the VPC<a id="_idIndexMarker586"/> and viewing the resource map in <a href="http://console.aws.amazon.com/">http://console.aws.amazon.com/</a> should display somethi<a id="_idTextAnchor498"/>ng like the following resource map:</p>
<div><div><img alt="Figure 10.2 – Viewing the resource map" src="img/B21620_10_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Viewing the resource map</p>
<p>By going<a id="_idIndexMarker587"/> to <strong class="bold">Security Groups</strong>, you should also see the groups that we created listed:</p>
<div><div><img alt="Figure 10.3 – Reviewing the security groups" src="img/B21620_10_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Reviewing the security groups</p>
<p>I have included a second playbook in the repo, which destroys all of the resources created by running the <code>site.yml</code> playbook called <code>destroy.yml</code>. You can run it using the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts destroy.yml</pre> <p>I am not going to cover the contents of the playbook here, but if you review the code, you will notice that, in <a id="_idIndexMarker588"/>essence, it runs the same tasks in the role we have covered in this chapter in reverse order, setting the state to <code>absent</code> rather than <code>present</code>.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor499"/>Summary</h1>
<p>In this chapter, we have taken our next step in using Ansible to launch resources in a public cloud. We have laid the groundwork for automating quite a complex environment by creating a VPC, setting up the subnets we need for our application, provisioning an internet gateway, and setting our instances to route their outgoing traffic through it.</p>
<p>We have configured four security groups, with three containing dynamic content, to secure the services launching into our VPC.</p>
<p>In the next chapter, we will build on the foundations laid in this chapter and launch a more complex set of services alongside the VPC.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor500"/>Further reading</h1>
<ul>
<li><strong class="bold">Details of the AWS Q3 2023 earnings </strong><strong class="bold">call</strong>: <a href="https://www.cnbc.com/2023/10/26/aws-q3-earnings-report-2023.html">https://www.cnbc.com/2023/10/26/aws-q3-earnings-report-2023.html</a></li>
</ul>
</div>
</body></html>