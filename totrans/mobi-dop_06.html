<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Configuring TeamCity for CI/CD with Xamarin</h1>
                </header>
            
            <article>
                
<p>In the old days, application development used to happen in separate, not-so-integrated teams. Developers were not used to merging their work with other developers' code for quite a long time, and that used to create merge issues. Things that were working on the developer's local copy used to stop working when merged with others' code. This kind of <em>not-so-integrated development</em> environment increased the development time and delayed the discovery of issues. One solution for this is to have continuous integration built into the development cycle, where developers merge their code multiple times a day and get issues fixed at earlier stages.</p>
<p>In this chapter, we will learn more about continuous integration, continuous delivery, and the different tools that we can use for a better development integration and delivery process.</p>
<p>In this chapter, we'll be covering the following topics:</p>
<ul>
<li>Introduction to continuous integration</li>
<li>Various tools for continuous integration</li>
<li>Using TeamCity with Xamarin</li>
<li>Preparing a build server for TeamCity and installing TeamCity</li>
<li>Creating a build script</li>
<li>Creating a TeamCity project</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to continuous integration</h1>
                </header>
            
            <article>
                
<p><strong>Continuous Integration</strong> (<strong>CI</strong>) is a development and integration practice in which developers check code into a shared repository frequently, preferably several times a day. Each code merge can then be verified by an automated build and automated tests if applicable.</p>
<p>There are many benefits to following continuous integration; one of the advantages is that it helps detect defects quickly and at an early stage. The check-ins are usually very small and contain small developments, thus helping to identify the exact issues quickly.</p>
<p><strong>Continuous Delivery</strong> (<strong>CD</strong>), on the other hand, is a process performed after integration, and as the name suggests, it makes sure that the code base checked in is deployable at any point of time. Each environment from test to production can, and mostly does, have different configurations. Continuous delivery makes sure that all configurations are always ready for deployment to any environment, and that the code passes all the tests necessary for release.</p>
<p>In short, continuous integration improves the development and testing experience with frequent code merges, helps quickly identify bugs, and involves running automated tests if included in the process. Continuous delivery makes sure the codebase is in a ready state for the code to be deployed in any environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CI/CD for a web application</h1>
                </header>
            
            <article>
                
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e45d2f34-6d0e-48ac-9b51-11dc044cef30.png" style=""/></div>
<p>For a web application, once the build is ready from the CI server, it is not a big task to test the application on different browsers since there are only a limited number of them. But in a mobile application, there is one more step involved to improve the experience, since there are thousands of devices with different versions of operating systems available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CI/CD for a mobile application</h1>
                </header>
            
            <article>
                
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/87519c1b-ca69-4533-af52-bc6727732fac.png" style=""/></div>
<p>As shown in the preceding diagram, mobile applications need to be tested on hundreds of devices with different operating systems, and purchasing all these mobile devices, which keep on coming out on a regular basis, can be very expensive. To make sure the quality of the application stays high, including Test Cloud-based solutions becomes an integral part of the process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing tools for continuous integration</h1>
                </header>
            
            <article>
                
<p>There are many CI tools available on the market to implement continuous integration, just like there are many languages available on the market with which to develop applications, but choosing the right CI tool is very important for ensuring long-term benefits.</p>
<p>Choosing a CI tool for your project can depend on many variables:</p>
<ul>
<li><strong>Programming language support</strong>: This is one of the most important factors while choosing a CI tool. Some CI tools have better support for certain language-specific builds and packages, while others might not provide language-specific packaging options.</li>
<li><strong>Operating system</strong>: Operating system support is important, as some teams might find an open source operating system such as Linux to be a better choice for all their servers, including the CI server, and it might be more comfortable for them to configure a familiar operating system, while other teams working on .NET applications might find Windows to be more comfortable and feature-rich for their configurations. It all boils down to the preference different teams have and the kind of application they are working on.</li>
<li><strong>Integration with a code repository</strong>: Different teams prefer different code repositories for various reasons. Some might find Git to be more feature-rich and supported on various IDEs with plugins, while others who are more familiar with Microsoft environments find Team Services to be easier to use and better integrated. Different CI tools have different levels of support for these repositories.</li>
<li><strong>Support for application platform deployment</strong>: Some CI servers are better suited for web application deployment, while others provide more features and better support for mobile application deployment to app stores. Depending on your type of application, the choice can vary.</li>
<li><strong>Cost</strong>: Cost is always an important factor while choosing any type of tool. Medium to big companies can afford to have expensive, feature-rich CI tools, while smaller companies and teams might want to stick to low-budget and sometimes open source and freely available CI tools, and customize them according to their needs.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Various tools for continuous integration</h1>
                </header>
            
            <article>
                
<p>Let's have a look at some of the widely used CI tools available in the market.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TeamCity</h1>
                </header>
            
            <article>
                
<p>TeamCity is a well-known CI server, built by JetBrains. JetBrains is quite well known for developing various tools for different phases in the software development life cycle, such as WebStorm and ReSharper. TeamCity has both a licensed version and a free version with a limited number of configurations and build agents. The free version is suitable for small teams that plan to grow over time.</p>
<p>Despite being a Java-based solution, TeamCity offers the best .NET support among the tools on this list. There are also different enterprise packages that scale by the number of agents needed.</p>
<p>You will be learning more about TeamCity later in this chapter.</p>
<p>Its key features are as follows:</p>
<ul>
<li>Extensive support for .NET-based applications and Visual Studio</li>
<li>Remote run, which can be used to test changes for failures without doing an actual commit</li>
<li>Supports both automated and manual types of build trigger, and you can configure automated build triggers for every commit</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jenkins</h1>
                </header>
            
            <article>
                
<p>Jenkins is one of the most popular open source projects for continuous integration. With thousands of plugins to choose from, Jenkins can help teams automate tasks that would otherwise put a time-consuming strain on your software team. Common uses include building projects, running tests, bug detection, code analysis, and project deployment.</p>
<p>Its key features are as follows:</p>
<ul>
<li>Jenkins has an easy installation process by just running a command, <kbd>java -jar jenkins.war</kbd>, and deploying - nothing else</li>
<li>Jenkins comes with a user-friendly web interface and you can configure Jenkins entirely from that</li>
<li>Jenkins has a huge plugin library and integrates with most build tools</li>
<li>Customizing Jenkins to your project's needs is very straightforward by creating plugins and extending its capabilities</li>
<li>Distributed builds are supported by Jenkins over different servers, and even with different operating systems</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio Team Services</h1>
                </header>
            
            <article>
                
<p>Visual Studio Team Services, provided by Microsoft, helps teams plan better, code together, and ship faster. You can code in any IDE or language, for any target platform. Various tools and plugins can be downloaded to customize it to your project requirements.</p>
<p>The key features are as follows:</p>
<ul>
<li>Supports a wide variety of tools including Visual Studio, Eclipse, or any other tool available</li>
<li>Comes with unlimited free, private repos (including Git repos)</li>
<li>Planning boards and tools are available for Agile and even Kanban projects</li>
<li>Automatically compiles and tests apps in the Cloud to avoid build failures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bamboo</h1>
                </header>
            
            <article>
                
<p>Bamboo is a CI server used by software teams worldwide to automate the process of release management for applications and general software. It allows teams to establish a streamlined pipeline for build delivery. Mobile developers can deploy their apps back to the Apple store or Google Play automatically. Being an Atlassian tool, it has native support for Jira and BitBucket, and you can even import your Jenkins configurations into Bamboo easily.</p>
<p>Its key features are as follows:</p>
<ul>
<li>Unlike Jenkins, Bamboo has built-in Git branching workflows</li>
<li>Because it is built by Atlassian, it has built-in integration for Jira and BitBucket</li>
<li>Bamboo also supports automated merging to avoid conflicts and differences between the working branch and master branch</li>
<li>Test automation in Bamboo produces a continuous flow from build, to test, even to releasing the application to the customer when ready</li>
<li>Built-in support for Jira makes bug tracking in a specific release, and even builds, automated and easily trackable</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using TeamCity with Xamarin for CI/CD</h1>
                </header>
            
            <article>
                
<p>As mentioned in the previous section, TeamCity provides great support for .NET-based applications.</p>
<p>While it can automatically detect build steps from configuration files and project files, it can also detect automatic build triggers from GitHub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requirements for using TeamCity</h1>
                </header>
            
            <article>
                
<p>To use TeamCity, knowledge about, and the access to, some hardware and technologies are required to make the setup process smoother:</p>
<ul>
<li><strong>A dedicated build server for TeamCity installation and setup</strong>: Ideally the build server should be a standalone server and should not be responsible for other responsibilities such as being a DB server or hosting server.</li>
<li><strong>Knowledge of MSBuild</strong>: Having knowledge of MSBuild can make this setup much better and helps in resolving any compilation-related issues if required.</li>
<li><strong>Knowledge of Xamarin Test Cloud for continuous testing</strong>: Xamarin Test Cloud will be used in this chapter for continuous testing after a build and application package is ready. You will be familiar with this because it has been described in detail in the last chapter.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Steps involved in TeamCity setup</h1>
                </header>
            
            <article>
                
<p>The following steps are involved in setting up TeamCity:</p>
<ul>
<li><strong>Preparing the build server</strong>: In order to build our mobile app on the build server, there is some software that needs to be installed on the build server, which will be used while building the application</li>
<li><strong>Creating the build script</strong>: A build script is basically a script containing a set of commands to perform various actions in the build process, such as compiling the application, building the APK, and then submitting it to the cloud for testing, as well as much more</li>
<li><strong>Installing TeamCity</strong>: Once we have the required tools installed on the CI server, TeamCity needs to be installed and configured for the project and its users to run build scripts</li>
<li><strong>Creating a TeamCity project</strong>: Once we have all the software required to build our project and the script to perform the building, a TeamCity project should be created</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the build server</h1>
                </header>
            
            <article>
                
<p>In order to compile and build a mobile app on the server, some software need to be installed as it is required for the build process. For an Android application to be built on the build server, it is important to have tools such as the Visual Studio SDK and Visual Studio build tools installed on the server. Also, acquiring Android Keystore is required to sign the application package to be released later. To avoid any configuration issues, it is recommended to install this software under the same user account as TeamCity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firewall configuration</h1>
                </header>
            
            <article>
                
<p>For continuous testing, we are using Xamarin Test Cloud, which was described in the previous chapter in detail. For tests to be submitted to Xamarin Test Cloud automatically as part of CI, the CI server must be configured to allow network traffic to and from <a href="http://testcloud.xamarin.com"><span class="URLPACKT">testcloud.xamarin.com</span></a> on ports <kbd>80</kbd> and <kbd>443</kbd>.</p>
<p>Once these configurations are done and the firewall is configured to allow communication between the server and Xamarin Test Cloud, we will be able to use command-line tools in the build steps to submit our UITests to Xamarin Test Cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio with Xamarin</h1>
                </header>
            
            <article>
                
<p>To install Visual Studio with Xamarin, you can follow the same steps described in <a href="1f45b30c-388e-4fd2-b2e6-cfe6d906cd7b.xhtml" target="_blank">Chapter 3</a>, <em>Cross-Platform Mobile App Development with Xamarin</em>.</p>
<p>Following the steps should install both Visual Studio and Xamarin with the required tools and SDKs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Android Keystore</h1>
                </header>
            
            <article>
                
<p>Android Keystore is used for signing the application while distributing it. This is required before packaging the application, so that our final package is signed with it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your own Keystore</h1>
                </header>
            
            <article>
                
<p>The first step is to create your own personal Keystore that will contain the information used to digitally sign your Android package files. You can do this with the following command:</p>
<pre><strong>"C:Program Files (x86)Javajre1.8.0_45binkeytool.exe" -genkey -v -keystore youFileName.keystore" -alias your_alias_for_keystore -keyalg RSA -keysize 2048 -validity 30000</strong></pre>
<p>The <kbd>30000</kbd> at the end of the command denotes the length of validity of certificates; Google requires this to be higher than <kbd>2033</kbd>.</p>
<p>Before you run this command, make note of a few parameters first. When you run the command, it will ask you to enter the following parameters. These parameters will be used again later in the project file:</p>
<pre><strong>Password -  &lt;yourpassword&gt;</strong>
<strong>Name - &lt;yourname&gt;</strong>
<strong>OU - &lt;organisationunit&gt; eg: JamSoft</strong>
<strong>Orgname - &lt;organisationame&gt; </strong>
<strong>Local - &lt;locality&gt; </strong>
<strong>State - &lt;state&gt; </strong>
<strong>Country - &lt;2lettercountrycode&gt;</strong>  </pre>
<p>Running the command should generate a <kbd>.keystore</kbd> file with the filename provided in the command. Now that our build server is ready, let's prepare the build script that we'll be using in the build process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a build script</h1>
                </header>
            
            <article>
                
<p>The build script should contain the following steps:</p>
<ul>
<li><strong>Compile the application</strong>: Configuring the application project file to use the proper Keystore and compiling the application using Visual Studio SDK tools</li>
<li><strong>Submit the application to Xamarin Test Cloud</strong>: Once the server's firewall is configured to allow communication with Test Cloud servers, as mentioned in previous steps, this step in the build script will run the command to upload the signed application package to the Test Cloud servers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling the application</h1>
                </header>
            
            <article>
                
<p>Now that we have our Android Keystore ready and prepped for use, we can look at the Visual Studio project. In order to automate this in the build system, we need to configure the project to use our Keystore credentials:</p>
<ol>
<li>In Visual Studio, edit the Android application <kbd>.csproj</kbd> file and add another <kbd>PropertyGroup</kbd> element as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">&lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
&lt;AndroidKeyStore&gt;True&lt;/AndroidKeyStore&gt;        &lt;AndroidSigningKeyStore&gt;myandroid.keystore&lt;/AndroidSigningKeyStore&gt;
&lt;AndroidSigningStorePass&gt;yourpassword&lt;/AndroidSigningStorePass&gt;        &lt;AndroidSigningKeyAlias&gt;myaliasdroidpub&lt;/AndroidSigningKeyAlias&gt;
&lt;AndroidSigningKeyPass&gt;yourpassword&lt;/AndroidSigningKeyPass&gt;
&lt;/PropertyGroup&gt;  </pre>
<ol start="2">
<li>Now our <kbd>.csproj</kbd> file knows how to use our Keystore unattended. We can tie in to the Xamarin build process from within our automated builds and produce the base Android package. You can test that this is working using the following command:</li>
</ol>
<pre style="padding-left: 60px">msbuild.exe PhoneCallApp.csproj /p:Configuration=Release /t:Rebuild  </pre>
<p style="padding-left: 60px">This command uses MSBuild to build the application with the given configuration; in our case, it should be release.</p>
<ol start="3">
<li>We have our application package now and we can apply the signing processes. To sign the package created in the previous step, we need to execute the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>"C:\Program Files (x86)\Java\jdk1.7.0_71\binjarsigner.exe" -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore youFileName.keystore -storepass yourpassword -keypass yourpassword -signedjar \bin\Release\packagename-signed.apk \bin\Release\packagename.apk your_alias_for_keystore</strong></pre>
<p style="padding-left: 60px">This package is now digitally signed using your certificate from the Keystore we made earlier.</p>
<ol start="4">
<li>Now that we have a signed package, we can zip-align this package and then publish this as an artifact of our TeamCity build process. This command makes use of the Android SDK's <kbd>zipalign.exe</kbd> program. You'll have to find where this is on your machine, as there are many potential locations. The command you need will look something like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>"C:\Users\&lt;name&gt;\AppData\Local\Android\android-sdk\build-tools &lt;version&gt;\zipalign.exe" -f -v 4 packagename-signed.apk packagename-zipaligned.apk</strong></pre>
<ol start="5">
<li>Now it is time to upload our tests and Android package to Xamarin Test Cloud to be UI tested. We created Xamarin.UITest in the previous chapter, and it is assumed that you are aware of the process of creating and uploading the test to Xamarin Test Cloud.</li>
<li>So, include the following command to your build process to upload the test to Test Cloud:</li>
</ol>
<pre style="padding-left: 60px"><strong>test-cloud.exe &lt;path-to-apk-or-ipa-file&gt; &lt;test-cloud-team-api-key&gt; --devices &lt;device-selection-id&gt; --assembly-dir &lt;path-to-tests-containing-test-assemblies&gt; --nunit-xml report.xml --user &lt;email&gt;</strong>    </pre>
<p style="padding-left: 60px">When the test is run, the test results will be returned in the form of an NUnit-style XML file called <kbd>report.xml</kbd>. TeamCity will display the information in the build log.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and configuring TeamCity</h1>
                </header>
            
            <article>
                
<p>To install and configure TeamCity on a Windows machine, follow these steps:</p>
<ol>
<li>Go to <a href="https://www.jetbrains.com/teamcity/download/#section=windows"><span class="URLPACKT">https://www.jetbrains.com/teamcity/download/#section=windows</span></a> and click on the <span class="packt_screen">DOWNLOAD</span> button to download the TeamCity installation package from the TeamCity website:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/2c68084c-2a78-49c5-97d0-0ffd7501d095.png" style=""/></div>
<ol start="2">
<li>Once downloaded, open the installation package and click <span class="packt_screen">Next</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/6d6fcb61-aa1f-4154-9765-2a41dd7b333d.png"/></div>
<ol start="3">
<li>On the next screen, agree to the license and go to the next step:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/e0ed84f1-71ab-4d32-bc9f-0b6f9dbf34c5.png"/></div>
<ol start="4">
<li>Select the path to install TeamCity in and click <span class="packt_screen">Next</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/cb1dd9fa-fbf6-4cad-8e11-18bbd627b601.png"/></div>
<ol start="5">
<li>Select the packages to be installed; for example, if you are installing <span class="packt_screen">Build Agent</span> and <span class="packt_screen">Server</span> on different servers, then select accordingly. For learning purposes, you can select to install both on the same machine:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/4359740e-5f93-4cc4-8262-ca30989473d0.png"/></div>
<ol start="6">
<li>Once the installation is done, select the port you would like the TeamCity server to run on. Make sure this port is not used by other services on the machine, and choose a unique port number and not the default one if possible:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/986777ea-61eb-4688-8321-75baa185b910.png"/></div>
<ol start="7">
<li>In the next screen, you'll be able to see the configurations and ports configured for the server, and you can also change them here if you want to:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/a167c9a0-e506-46c2-9bac-acef1a0a9c3c.png"/></div>
<ol start="8">
<li>Click on <span class="packt_screen">OK</span> to save the configuration.</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/f7e2cda8-3259-41ea-800c-4aba928b66cc.png"/></div>
<ol start="9">
<li>Select the account to run TeamCity:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/93551935-ccf4-4c70-9590-be99307aded1.png"/></div>
<ol start="10">
<li>Start the build server and build agent:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/21d37a27-52fe-45a2-ab42-5c8479703b47.png"/></div>
<ol start="11">
<li>Check <span class="packt_screen">Open TeamCity Web UI after Setup is completed</span> and click <span class="packt_screen">Finish</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/beea17ad-6987-47e2-83db-a4c3d0bf5309.png"/></div>
<ol start="12">
<li>This will open the TeamCity web UI where we can create a TeamCity project.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a TeamCity project</h1>
                </header>
            
            <article>
                
<p>Once the installation is done, the TeamCity web user interface will open in the browser and we can create a new TeamCity project there. To do so, follow these steps:</p>
<ol>
<li>Once you have logged in to TeamCity UI, click on <span class="packt_screen">Create project</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/ab11df06-2f6a-485a-80a5-85d93fc35d0c.png" style=""/></div>
<ol start="2">
<li>To connect to our project from GitHub, click on <span class="packt_screen">From GitHub</span> on the next screen:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/462123a3-e226-4a82-b404-a57ae4091008.png" style=""/></div>
<ol start="3">
<li>This will open a popup with instructions to add a TeamCity application to your GitHub account:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/173f07a4-7b9a-4998-a0c3-dab6b1790bf4.png" style=""/></div>
<ol start="4">
<li>Click on the <strong>register TeamCity</strong> link and it should take you to the GitHub page where you can register a new OAuth app.</li>
<li>Give the details of the application, homepage URL, and callback URL, as shown in the following screenshot, and register the OAuth app:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/3b713a00-4814-45a5-821d-2a32e42b25d3.png" style=""/></div>
<ol start="6">
<li>Once you register, on the next screen you'll get a <span class="packt_screen">Client ID</span> and <span class="packt_screen">Client Secret</span>; copy those details since they will be required for the TeamCity project:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/aa251526-c01f-47d3-b086-1d4918b082b9.png"/></div>
<ol start="7">
<li>Go back to TeamCity, put the <span class="packt_screen">Client ID</span> and <span class="packt_screen">Client Secret</span> in the required fields, and click <span class="packt_screen">Save</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/9d01f773-267e-4acc-b5e7-1469bcf92f9a.png" style=""/></div>
<ol start="8">
<li>Next, you need to do a one-time sign in to allow TeamCity to use GitHub repositories. Click on <span class="packt_screen">Sign in to GitHub</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/dfd160ea-e948-4f35-a672-f95d18d6c297.png" style=""/></div>
<ol start="9">
<li>Authorize the TeamCity app to use GitHub by clicking on <span class="packt_screen">Authorize</span> app:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/cd55027e-d010-4e1d-9d60-f82fa941eeac.png" style=""/></div>
<ol start="10">
<li>Once authorized, select the <span class="packt_screen">PhoneCallApp</span> repository from the list of repositories shown on TeamCity:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/2da36619-883c-45ee-8ee0-c8e68eb61bf0.png" style=""/></div>
<ol start="11">
<li>On the next screen, TeamCity will offer to create a new project from the URL selected. Give it a name and click <span class="packt_screen">Proceed</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/ee1cac04-4355-493a-847d-aaf841cbd543.png"/></div>
<ol start="12">
<li>This should create two things. The first is a trigger in TeamCity for each code check-in you do; each will trigger a build. The second is a build step from the repository automatically:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/1e4786fd-f781-4679-9c5b-9508c3754e19.png"/></div>
<ol start="13">
<li>We need to configure the build steps manually and use the build scripts described in the <em>Creating a build script</em> section. Use those scripts, described sequentially in previous steps, to create the build steps in TeamCity.</li>
<li>Finally, your build steps should look like the following screenshot, consisting of all the steps mentioned in the <em>Creating a build script</em> section:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/e3792c2d-7fab-47a7-aa59-76c15baf07fe.png"/></div>
<ol start="15">
<li>Now, your TeamCity continuous build is ready, and a trigger is already configured to perform this build on each code check-in, or whenever it finds any code changes in the repository. This finally provides you with an Android package that is ready to be distributed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about continuous integration and continuous delivery. We learned about various tools for continuous integration. We used TeamCity to implement CI/CD in the Xamarin project developed in earlier chapters, and learned how to create a project in TeamCity to automate the build process and finally get a distributable Android package.</p>
<p>In the next chapter, you'll learn more about continuous distribution and delivery using Visual Studio Team Services.</p>


            </article>

            
        </section>
    </body></html>