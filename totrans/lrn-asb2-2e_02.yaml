- en: Chapter 2. Automating Simple Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned in the previous chapter, Ansible can be used for both,
    creating and managing a whole infrastructure, as well as be integrated into an
    infrastructure that is already working.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: What a playbook is and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a web server using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A close look at the Jinja2 template engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But first we will talk about **YAML Ain't Markup Language** (**YAML**), a human-readable
    data serialization language that is widely used in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'YAML, like many other data serialization languages (such as JSON), has very
    few, basic concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A declaration is very similar to a variable in any other language, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a list, we will have to use ''`-`'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'YAML uses indentation to logically divide parents from children. So if we want
    to create associative arrays (also known as objects), we would just need to add
    an indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we can mix those together, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Those are the basics of YAML. YAML can do much more, but for now this will be
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Hello Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous chapter, it is possible to use Ansible to automate
    simple tasks that you probably already perform daily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by checking if a remote machine is reachable; in other words,
    let''s start by pinging a machine. The simplest way to do this, is to run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `HOST` is an IP address, the **Fully Qualified Domain Name** (**FQDN**),
    or an alias of a machine where you have SSH access (you can use a **Kernel-based
    Virtual Machine** (**KVM**), as we have seen in the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the "`HOST,`" the comma is mandatory, because otherwise it would not be
    seen as a list, but as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have performed it against a virtual machine on our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive something like this as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what we did and why. Let''s start from the Ansible help. To
    query it, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easier to be read, we have removed all the output related to options
    that we have not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what we did was:'
  prefs: []
  type: TYPE_NORMAL
- en: We invoked Ansible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We instructed Ansible to run on all hosts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specified our inventory (also known as the list of the hosts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specified the module we wanted to run (`ping`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we can ping the server, let's `echo hello ansible!`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive something like this as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we used an additional option. Let''s check the help to see
    what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you may have guessed from the context and the name, the `args` options allow
    you to pass additional arguments to the module. Some modules (like `ping`) do
    not support any arguments, while others (such as `shell`) will require arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Working with playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks are one of the core features of Ansible and tell Ansible what to execute.
    They are like a to-do list for Ansible that contains a list of tasks; each task
    internally links to a piece of code called a **module**. Playbooks are simple,
    human-readable YAML files, whereas modules are a piece of code that can be written
    in any language with the condition that its output be in the JSON format. You
    can have multiple tasks listed in a playbook and these tasks would be executed
    serially by Ansible. You can think of playbooks as an equivalent of manifests
    in Puppet, states in Salt, or cookbooks in Chef; they allow you to enter a list
    of tasks or commands you want to execute on your remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Studying the anatomy of a playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbooks can have a list of remote hosts, user variables, tasks, handlers,
    and so on. You can also override most of the configuration settings through a
    playbook. Let's start looking at the anatomy of a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the playbook we are going to consider now, is to ensure that
    the `httpd` package is installed and the service is **enabled** and **started**.
    This is the content of the `setup_apache.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup_apache.yaml` file is an example of a playbook. The file is comprised
    of three main parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts`: This lists the host or host group against which we want to run the
    task. The hosts field is mandatory and every playbook should have it. It tells
    Ansible on which hosts to run the listed tasks. When provided with a host group,
    Ansible will take the host group from the playbook and try look for it in an inventory
    file . If there is no match, Ansible will skip all the tasks for that host group.
    The `--list-hosts` option along with the playbook (`ansible-playbook <playbook>
    --list-hosts`) will tell you exactly which hosts the playbook will run against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_user`: This is one of the configuration parameters of Ansible (consider,
    for example, `tom -remote_user`) that tells Ansible to use a particular user (in
    this case, `tom`) while logging into the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tasks`: Finally, we come to tasks. All playbooks should contain tasks. Tasks
    are a list of actions you want to perform. A tasks field contains the name of
    the task (that is, the help text for the user about the task), a module that should
    be executed, and arguments that are required for the module. Let''s look at the
    single task that is listed in the playbook, as shown in the preceding snippet
    of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All examples in the book would be executed on CentOS, but the same set of examples
    with a few changes would work on other distributions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding case, there are two tasks. The `name` parameter represents
    what the task is doing and is `present` mainly to improve readability, as we''ll
    see during the playbook run. The `name` parameter is optional. The `modules`,
    `yum` and `service`, have their own set of parameters. Almost all modules have
    the `name` parameter (there are exceptions such as the `debug` module), which
    indicates what component the actions are performed on. Let''s look at the other
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `yum` module's case, the `state` parameter has the latest value and it
    indicates that the `httpd` latest package should be installed. The command to
    execute more or less translates to `yum install httpd`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `service` module's scenario, the `state` parameter with the started value
    indicates that the `httpd` service should be started, and it roughly translates
    to `/etc/init.d/httpd` start. In this module we also have the "`enabled`" parameter
    that defines whether the service should start at boot or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `become: True` parameter represents the fact that the tasks should be executed
    with `sudo` access. If the `sudo` user''s file does not allow the user to run
    the particular command, then the playbook will fail when it is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have questions about why there is no package module that figures out
    the architecture internally and runs the `yum`, `apt`, or any other package options
    depending on the architecture of the system. Ansible populates the package manager
    value into a variable named `ansible_pkg_manager`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we need to remember that the number of packages that have a common
    name across different operating systems is a small subset of the number of packages
    that are actually present. For example, the `httpd package` is called `httpd`
    in Red Hat systems and `apache2` in Debian-based systems. We also need to remember
    that every package manager has its own set of options that make it powerful; as
    a result, it makes more sense to use explicit package manager names so that the
    full set of options are available to the end user writing the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Running a playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it''s time (yes, finally!) to run the playbook. To instruct Ansible to
    execute a playbook instead of a module, we will have to use a different command
    (`ansible-playbooks`) that has a syntax very similar to the "`ansible`" command
    we already saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, aside from the host-pattern (that is specified in the playbook)
    that has disappeared, and the module option that has been replaced by the playbook
    name, nothing changed. So to execute this command on my machine, the exact command
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! The example worked. Let''s now check whether the `httpd` package is installed
    and up-and-running on the machine. To check if HTTPd is installed, the easiest
    way is to ask `rpm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked properly, you should have an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the status of the service, we can ask `systemd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected result is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The end state, according to the playbook, has been achieved. Let''s briefly
    look at exactly what happens during the playbook run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This line advises us that a playbook is going to start here and that it will
    be executed on "`all`" hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TASK` lines show the name of the task (`setup` in this case), and their
    effect on each host. Sometimes people get confused by the `setup` task. In fact,
    if you look at the playbook, there is no `setup` task. This is because Ansible,
    before executing the tasks that we have asked it to, will try to connect to the
    machine and gather information about it that could be useful later. As you can
    see, the task resulted with a green `ok` state, so it succeeded and nothing was
    changed on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These two task''s states are yellow and spell "`changed`". This means that
    those tasks were executed and have succeeded but have actually changed something
    on the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Those last few lines are a recapitulation of how the playbook went. Let''s
    rerun the task now and see the output after both the tasks have actually run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you would have expected, the two tasks in question give an output of `ok`,
    which would mean that the desired state was already met prior to running the task.
    It's important to remember that many tasks such as the **Gathering facts** task
    obtain information regarding a particular component of the system and do not necessarily
    change anything on the system; hence, these tasks didn't display the changed output
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PLAY RECAP` section in the first and second run are shown as follows.
    You will see the following output during the first run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output during the second run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the difference is that the first task's output shows `changed=2`,
    which means that the system state changed twice due to two tasks. It's very useful
    to look at this output, since, if a system has achieved its desired state and
    then you run the playbook on it, the expected output should be `changed=0`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're thinking of the word **Idempotency** at this stage, you're absolutely
    right and deserve a pat on the back! Idempotency is one of the key tenets of configuration
    management. Wikipedia defines Idempotency as an operation that, if applied twice
    to any value, gives the same result as if it were applied once. The earliest examples
    of this that you would have encountered in your childhood would be multiplicative
    operations on the number `1`, where `1*1=1` every single time.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the configuration management tools have taken this principle and applied
    it to the infrastructure as well. In a large infrastructure, it is highly recommended
    to monitor or track the number of changed tasks in your infrastructure and alert
    the concerned tasks if you find oddities; this applies to any configuration management
    tool in general. In an ideal state, the only time you should see changes is when
    you're introducing a new change in the form of any **Create**, **Remove**, **Update**,
    or **Delete** (**CRUD**) operation on various system components. If you're wondering
    how you can do it with Ansible, keep reading the book and you'll eventually find
    the answer!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed. You could have also written the preceding tasks as follows
    but when the tasks are run, from an end user''s perspective, they are quite readable
    (we will call this file `setup_apache_no_com.yaml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the playbook again to spot any difference in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the difference is in the readability. Wherever possible, it's
    recommended to keep the tasks as simple as possible (the **KISS** principle of
    **Keep It Simple Stupid**) to allow for maintainability of your scripts in the
    long run.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how you can write a basic playbook and run it against a
    host, let's look at other options that would help you while running playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible verbosity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first options anyone picks up is the debug option. To understand
    what is happening when you run the playbook, you can run it with the **verbose**
    (`-v`) option. Every extra `v` will provide the end user with more debug output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using the playbook debug for a single task using the
    following debug options:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-v` option provides the default output, as shown in the preceding examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-vv` option adds a little more information, as shown in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-vvv` option adds a lot more information, as shown in the following code.
    This shows the `ssh` command Ansible uses to create a temporary file on the remote
    host and run the script remotely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Variables in playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is important to `set` and `get` variables in a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Very often, you'll need to automate multiple similar operations. In those cases,
    you'll want to create a single playbook that can be called with different variables
    to ensure code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another case where variables are very important is when you have more than
    one datacenter and some values will be datacenter-specific. A common example are
    the DNS servers. Let''s analyze the following simple code that will introduce
    us to the Ansible way to set and get variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we analyze the code we have just executed, it should be pretty clear what's
    going on. We set a variable (that in Ansible are called `facts`) and then we print
    it with the `debug` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables should always be between quotes when you use this expanded version
    of YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible allows you to set your variables in many different ways, that is, either
    by passing a variable file, declaring it in a playbook, passing it to the `ansible-playbook`
    command using `-e / --extra-vars`, or by declaring it in an inventory file (we
    will be discussing more in-depth about this in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to start using some metadata that Ansible obtained during the
    setup phase. Let''s start by looking at the data that is gathered by Ansible.
    To do this, we will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In our specific case, this means executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can obviously do the same with a playbook, but this way is faster. Also,
    for the "setup" case, you will need to see the output only during the development
    to be sure to use the right variable name for your goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, from this huge list of options, you can gain a huge quantity
    of information, and you can use them as any other variable. Let''s print the OS
    name and the version. To do so, we can create a new playbook called `setup_variables.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it printed the OS name and version, as expected. In addition
    to the methods seen previously, it''s also possible to pass a variable using a
    command-line argument. In fact, if we look in the Ansible help, we will notice
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The same lines are present in the `ansible-playbook` command as well. Let''s
    make a small playbook called `cli_variables.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In case we forgot to add the additional parameter to specify the variable,
    we would have executed it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We would have received the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned the basics of playbooks, let's create a web server
    from scratch using them. To do so, let's start from the beginning, creating an
    Ansible user and then moving forward from there.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Ansible user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create a machine (or rent one from any hosting company) it arrives
    only with the `root` user. Let''s start creating a playbook that ensures that
    an Ansible user is created, it''s accessible with an SSH key, and is able to perform
    actions on behalf of other users (`sudo`) with no password asked. I often call
    this playbook, `firstrun.yaml` since I execute it as soon as a new machine is
    created, but after that, I don''t use it since it uses the root user that I disable
    for security reasons. Our script will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Before running it, let's look at it a little bit. We have used three different
    modules (`user`, `authorized_key`, and `lineinfile`) that we have never seen.
    The `user` module, as the name suggests, allows us to make sure a user is present
    (or absent).
  prefs: []
  type: TYPE_NORMAL
- en: The `authorized_key` module allows us to ensure that a certain SSH key can be
    used to login as a specific user on that machine. This module will not substitute
    all the SSH keys that are already enabled for that user, but will simply add (or
    remove) the specified key. If you want to alter this behavior, you can use the
    *exclusive* option, that allows you to delete all the SSH keys that are not specified
    in this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lineinfile` module allows us to alter the content of a file. It works
    in a very similar way to **sed** (a stream editor), where you specify the regular
    expression that will be used to match the line, and then specify the new line
    that will be used to substitute the matched line. If no line is matched, the line
    is added at the end of the file. Now let''s run it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a basic server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have created the user for Ansible with the necessary privileges, we
    can go on to make some other small changes to the OS. To make it more clear, we
    will see how each action is performed and then we'll look at the whole playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling EPEL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EPEL is the most important repository for Enterprise Linux and it contains
    a lot of additional packages. It''s also a safe repository since no package in
    EPEL will conflict with packages in the base repository. To enable EPEL in RHEL/CentOS
    7, it is enough to just install the `epel-release` package. To do so in Ansible,
    we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the `yum` module, as we did in one of the first
    examples of the chapter, specifying the name of the package and that we want it
    to be present.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python bindings for SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Ansible is written in Python and mainly uses the Python bindings to operate
    on the operating system, we will need to install the Python bindings for SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This could be written in a shorter way, using a cycle, but we'll see how to
    do so in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading all installed packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To upgrade all installed packages, we will need to use the `yum` module again,
    but with a different parameter, in fact we would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have specified "`*`" as the package name (this stands for
    a wildcard to match all installed packages) and the `state` is `latest`. This
    will upgrade all installed packages to the latest version available.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, when we talked about the "`present`" state, we said that it
    was going to install the last available version. So what's the difference between
    "`present`" and "`latest`"? Present will install the latest version if the package
    is not installed, while if the package is already installed (no matter the version)
    it will go forward without making any change. Latest will install the latest version
    if the package is not installed, while if the package is already installed will
    check whether a newer version is available and if it is, Ansible will update the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that NTP is installed, configured, and running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure NTP is present, we use the `yum` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know that NTP is installed, we should ensure that the server is
    using the `timezone` that we want. To do so, we will create a symbolic link in
    `/etc/localtime` that will point to the wanted `zoneinfo` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have used the `file` module to tell Ansible, specifying
    that it needs to be a link (`state: link`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the NTP configuration, we need to start the `ntpd` service and
    ensure that it will run at every, consequent boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Ensuring that FirewallD is present and enabled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can imagine, the first step is to ensure that FirewallD is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want to be sure that, when we enable FirewallD we will not lose our
    SSH connection, we ensure that SSH traffic can always pass through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To do so, we have used the `firewalld` module. This module will take parameters
    that are very similar to the ones the `firewall-cmd` console would use. You will
    have to specify the service that is to be authorized to pass the firewall, whether
    you want this rule to apply immediately, and whether you want the rule to be permanent
    so that after a reboot the rule will still be present.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can specify the service name (such as '`ssh`') using the `service` parameter,
    or you can specify the port (such as '`22/tcp`') using the `port` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed FirewallD and we are sure that our SSH connection
    will survive, we can enable it as we do any other service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Adding a customized MOTD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the MOTD, we will need a template that will be the same for all servers
    and a task to use the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'I find it very useful to add a MOTD to every server. It''s even more useful
    if you use Ansible, because you can use it to warn your users that changes to
    the system could be overwritten by Ansible. My usual template is called `''motd''`,
    and has this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a `jinja2` template and it allows us to use every variable set in the
    playbooks. This also allows us to use complex syntax for conditionals and cycles
    that we will see later in this chapter. To populate a file from a template in
    Ansible, we will need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The template module allows us to specify a local file (`src`) that will be interpreted
    by `jinja2` and the output of this operation will be saved on the remote machine
    in a specific path (`dest`), be owned by a specific user (`owner`) and group (`group`),
    and have a specific access mode (`mode`).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the hostname
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep things simple, one way I find useful is to set the hostname of a machine
    to something meaningful. To do so, we can use a very simple Ansible module called
    `hostname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing and running the playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Putting everything together, we now have the following playbook (called `common_tasks.yaml`
    for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this `playbook` is pretty complex, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This asks Ansible to print all the tasks in a shorter form so that we can quickly
    see what tasks a `playbook` performs. The output should be something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the `playbook` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have made some generic changes to the operating system, let's move
    on to actually creating a web server. We are splitting those two phases so we
    can share the first phase between every machine and apply the second only to web
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this second phase, we will create a new playbook called `webserver.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first two tasks are the same as the ones in the example
    at the beginning of this chapter, and the last two tasks are used to instruct
    FirewallD to let HTTP and HTTPS traffic pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this script with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a web server, let's publish a small single-page static website.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our website will be a simple, single page website, we can easily create
    it and publish it using a single Ansible task. To make this page a little bit
    more interesting, we will create it from a template that will be populated by
    Ansible with a little data about the machine. The script to publish it will be
    called `deploy_website.yaml` and will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with a simple template that we will call `index.html.j2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test our website deployment by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If you now go to your test machine IP/FQDN in your browser, you'll find the
    "Hello World!" page.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jinja2** is a widely-used and fully-featured template engine for Python.
    Let''s look at some syntax that will help us with Ansible. This paragraph does
    not want to be a replacement for the official documentation, but its goal is to
    teach you some components that you''ll find very useful when using them with Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, we can print variable content simply with the '`{{ VARIABLE_NAME
    }}`' syntax. If we want to print just an element of an array we can use '`{{ ARRAY_NAME['KEY']
    }}`', and if we want to print a property of an object, we can use '`{{ OBJECT_NAME.PROPERTY_NAME
    }}`'.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can improve our previous static page in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From time to time, we may want to change the style of a string a little bit,
    without writing specific code for it, for example, we may want to capitalize some
    text. To do so, we can use one of Jinja2''s filters, such as: ''`{{ VARIABLE_NAME
    | capitalize }}`''. There are many filters available for Jinja2 and you can find
    the full list at: [http://jinja.pocoo.org/docs/dev/templates/#builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#builtin-filters).'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing you may often find useful in a template engine is the possibility
    of printing different strings depending on the content (or existence) of a string.
    So we can improve our static web page in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added the capability to print the main IPv4 address
    for the `eth0` connection, if the connection is `active`. With conditionals we
    can also use the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a full list, please refer to: [http://jinja.pocoo.org/docs/dev/templates/#builtin-tests](http://jinja.pocoo.org/docs/dev/templates/#builtin-tests).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So to obtain the same result we could also have written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of different tests that will really help you to create easy-to-read,
    effective templates.
  prefs: []
  type: TYPE_NORMAL
- en: Cycles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `jinja2` template system also offers the capability to create cycles. Let''s
    add a feature to our page that will print the main IPv4 network address for each
    device instead of only `eth0`. We will then have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax for cycles is familiar if you already know Python.
  prefs: []
  type: TYPE_NORMAL
- en: These few pages on Jinja2 templating were not a substitute for the official
    documentation. In fact Jinja2 templates are much more powerful than what we have
    seen here. The goal here is only to give you the basic Jinja2 templates that are
    most often used in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started looking at YAML and saw what a playbook is, how
    it works, and how to use it to create a web server (and a deployment for your
    static website). We have also seen multiple Ansible modules such as the user,
    yum, service, FirewalID, lineinfile, and template modules. At the end of the chapter,
    we focused on templates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about inventories so that we can easily manage
    multiple machines.
  prefs: []
  type: TYPE_NORMAL
