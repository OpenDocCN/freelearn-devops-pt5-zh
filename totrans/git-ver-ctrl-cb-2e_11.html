<html><head></head><body>
        

                            
                    <h1 class="header-title">Tips and Tricks</h1>
                
            
            
                
<p>his chapter, we will cover the following recipes:</p>
<ul>
<li>Using git stash</li>
<li>Saving and applying stashes</li>
<li>Debugging with git bisect</li>
<li>Using the blame command</li>
<li>Coloring the UI in the prompt</li>
<li>Autocompletion</li>
<li>Bash prompt with status information</li>
<li>More aliases</li>
<li>Interactive add</li>
<li>Interactive add with Git gui</li>
<li>Ignoring files</li>
<li>Showing and cleaning ignored files</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, you will find some tips and tricks that can be useful in everyday Git work; from stashing away your changes when you get interrupted while doing an important task, to efficient bug hunting with <kbd>bisect</kbd> and <kbd>blame</kbd>, to finding color and status information in your prompt. We'll also look at aliases, how you can create clean commits by selecting which lines should be included in the commit and, finally, how you can ignore files.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using git stash</h1>
                
            
            
                
<p>In this example, we'll explore the <kbd>git stash</kbd> command and learn how we can use it to quickly <kbd>stash</kbd> away uncommitted changes and retrieve them again. This can be useful when you are interrupted while doing an urgent task and you are not yet ready to commit the work you currently have in your working directory. With the <kbd>git stash</kbd> command, you can save the state of your current working directory with/without a staging area and restore the working tree to a clean state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this example, we'll use the <kbd>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</kbd> repository. We'll use the <kbd>master</kbd> branch, but before we are ready to try the <kbd>stash</kbd> command, we need to create some changes in the working directory and the staging area, as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks<br/></strong><strong>$ git checkout master</strong></pre>
<p>Make some changes to <kbd>foo</kbd> and add them to the staging area, as follows:</p>
<pre><strong>$ echo "Just another unfinished line" &gt;&gt; foo</strong>
<strong>$ git add foo</strong></pre>
<p>Make some changes to <kbd>bar</kbd> and create a new file:</p>
<pre><strong>$ echo "Another line" &gt;&gt; bar</strong>
<strong>$ echo "Some content" &gt; new_file</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
  <strong>Changes to be committed:</strong>
    <strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>  modified:   foo</strong>
    
  <strong>Changes not staged for commit:</strong>
    <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
    <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong>  modified:   bar</strong>
    
  <strong>Untracked files:</strong>
    <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong> new_file</strong>
  </pre>
<p>We can see that we have one file added to the staging area, <kbd>foo</kbd>, one modified file, <kbd>bar</kbd>, and an untracked file in the work area as well, <kbd>new_file</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>With the preceding state of our repository, we can stash away the changes so that we can work on something else. The basic command will put away changes from the staging area and changes made to tracked files. It leaves untracked files in the working directory:</p>
<pre><strong>$ git stash</strong>
<strong>Saved working directory and index state WIP on master: d611f06 Update foo and bar</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
  <strong>Untracked files:</strong>
  <strong>  (use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
  <strong>    new_file</strong>
    
<strong>nothing added to commit but untracked files present (use "git add" to track)</strong>  </pre>
<p>We can now work on something else and create and commit those changes. We'll change the first line of the <kbd>foo</kbd> file and create a commit with this change:</p>
<pre><strong># MacOS (BSD sed):<br/>$ sed -i '' 's/First line/This is the very first line of the foo file/' foo<br/># Linux (GNU sed):</strong><br/><strong>$ sed 's/First line/This is the very first line of the foo file/' foo<br/></strong><strong>$ git add foo</strong> <strong>$ git commit -m "Update foo"</strong> <strong>[master fa4b595] Update foo</strong> <strong>1 file changed, 1 insertion(+), 1 deletion(-)</strong></pre>
<p>We can see the current work we have stashed away with the <kbd>git stash list</kbd> command:</p>
<pre><strong>$ git stash list</strong>
<strong>stash@{0}: WIP on master: b6dabd7 Update foo and bar</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To get the changes we stashed away back, we can pop them from the <kbd>stash</kbd> stack, as follows:</p>
<pre><strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
  <strong>(use "git push" to publish your local commits)</strong>
    
  <strong>Untracked files:</strong>
    <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong> new_file</strong>
  <strong>nothing added to commit but untracked files present (use "git add" to track)</strong>
<strong>$ git stash pop</strong>
<strong>Auto-merging foo</strong>
<strong>On branch master</strong>
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
  <strong>(use "git push" to publish your local commits)</strong>
    
  <strong>Changes not staged for commit:</strong>
   <strong> (use "git add &lt;file&gt;..." to update what will be committed)</strong>
   <strong> (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
   <strong>   modified:   bar</strong>
   <strong>   modified:   foo</strong>
    
  <strong>Untracked files:</strong>
  <strong>  (use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
  <strong>  new_file</strong>
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong>
<strong>Dropped refs/stash@{0} (733703568b7dcf2a0d5e4db5957d351417bcd793)</strong></pre>
<p>Now, the stashed changes are available again in the working repository and the <kbd>stash</kbd> entry has been deleted. Note that the changes are applied only to the working directory, although one of the files was staged when we created the <kbd>stash</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have created two commits: one for the index and one for the work area. In <kbd>gitk</kbd>, we can see the commits that <kbd>stash</kbd> creates to put the changes away (<kbd>gitk stash</kbd>), as shown in the following screenshot:</p>
<p class="mce-root"/>
<div><img class="alignnone size-full wp-image-459 image-border" src="img/7406e649-8999-4398-bac9-ed3f94ad2f21.png" style="width:36.83em;height:22.33em;"/></div>
<p>We can also see the state of the branches after we created the commit (<kbd>gitk --reflog</kbd>), as shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-460 image-border" src="img/9daab906-9007-41b7-9006-3bb61e821a8d.png" style="width:35.33em;height:21.50em;"/></div>
<p>Git actually creates two commits under the <kbd>refs/stash</kbd> namespace. One commit contains the contents of the staging area. This commit is called <kbd>index on master</kbd>. The other commit is the work in progress in the working directory, <kbd>WIP on master</kbd>. When Git puts away changes by creating commits, it can use its normal resolution methods to apply the stashed changes back to the working directory. This means that if a conflict arises when applying the stash, you need it to be solved in the usual way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In the preceding example, we saw only the very basic usage of the <kbd>stash</kbd> command, putting away changes to untracked files and changes added to the staging area. It is also possible to include untracked files in the <kbd>stash</kbd> command. This can be done with the <kbd>--include-untracked</kbd> option. We can add <kbd>foo</kbd> to the staging area; firstly, to have the same state as when we created the <kbd>stash</kbd> earlier and then to create a <kbd>stash</kbd> that includes untracked files:</p>
<pre><strong>$ git add foo</strong>
<strong>$ git stash --include-untracked</strong>
<strong>Saved working directory and index state WIP on master: 691808e Update foo</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
  <strong>(use "git push" to publish your local commits)</strong>
    
<strong>nothing to commit, working directory clean</strong></pre>
<p>Now, we can see that <kbd>new_file</kbd> has disappeared from the working directory. It's included in the stash, and we can check this with Gitk. It will show up as another commit of untracked files:</p>
<pre><strong>$ gitk master stash </strong></pre>
<p>Gitk shows the stash with its untracked files:</p>
<div><img class="alignnone size-full wp-image-461 image-border" src="img/67d05fc8-ab3b-45f1-a62c-3e33ff4c3bf0.png" style="width:40.83em;height:24.75em;"/></div>
<p>We can also make sure that the changes we added to the staging area are added back to the staging area after we apply the <kbd>stash</kbd>, so we end up with the exact same state as before we stashed our changes away:</p>
<pre><strong>$ git stash pop --index</strong>
<strong>On branch master</strong>
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
  <strong>(use "git push" to publish your local commits)</strong>
    
  <strong>Changes to be committed:</strong>
    <strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>modified:   foo</strong>
    
  <strong>Changes not staged for commit:</strong>
    <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
    <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong>  modified:   bar</strong>
    
  <strong>Untracked files:</strong>
    <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong> new_file</strong>
    
<strong>Dropped refs/stash@{0} (ff331af57406948619b0671dab8b4f39da1e8fa2)</strong></pre>
<p>It's also possible to put away only the changes in the working directory, while keeping the changes in the staging area. We can do this either for only the tracked files or by stashing away untracked files ( <kbd>--include-untracked</kbd>), as follows:</p>
<pre><strong>$ git stash --keep-index --include-untracked</strong>
<strong>Saved working directory and index state WIP on master: 00dd8f8 Update foo</strong>
<strong>HEAD is now at 00dd8f8 Update foo</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
<strong>  (use "git push" to publish your local commits)</strong>
    
  <strong>Changes to be committed:</strong>
  <strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
  <strong>    modified:   foo</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving and applying stashes</h1>
                
            
            
                
<p>When stashing away work, we can easily have more than one state stashed away at a time. However, the default names for stashed away changes aren't always helpful. In this example, we'll see how we can save stashes and name them so that it is easy to identify them again when listing the content of the stash. We'll also learn how to apply a stash without deleting it from the stash list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the same repository as in the previous example, continuing from the state we left it in:</p>
<pre><strong>$ cd Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
<strong>  (use "git push" to publish your local commits)</strong>
    
  <strong>Changes to be committed:</strong>
  <strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
  <strong>    modified:   foo</strong>
    
<strong>$ git stash list</strong>
<strong>stash@{0}: WIP on master: 4447f69 Update foo</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To save the current state to a stash with a description we can remember at a later point in time, use the following command:</p>
<pre><strong>$ git stash save 'Updates to foo'</strong>
<strong>Saved working directory and index state On master: Updates to foo</strong></pre>
<p>Our <kbd>stash</kbd> list now looks like the following:</p>
<pre><strong>$ git stash list</strong>
<strong>stash@{0}: On master: Updates to foo</strong>
<strong>stash@{1}: WIP on master: 2302181 Update foo</strong></pre>
<p>We can change <kbd>bar</kbd> and create a new <kbd>stash</kbd>:</p>
<pre><strong>$ echo "Another change" &gt;&gt; bar</strong>
<strong>$ git stash save 'Made another change to bar'</strong>
<strong>Saved working directory and index state On master: Made another change to bar</strong>
<strong>$ git stash list</strong>
<strong>stash@{0}: On master: Made another change to bar</strong>
<strong>stash@{1}: On master: Updates to foo</strong>
<strong>stash@{2}: WIP on master: 2302181 Update foo</strong></pre>
<p>We can apply the stashes back to the working tree (and staging area with the <kbd>--index option</kbd>) without deleting them from the <kbd>stash</kbd> list:</p>
<pre><strong>$ git stash apply 'stash@{1}'</strong>
  <strong>On branch master</strong>
  <strong>Your branch is ahead of 'origin/master' by 1 commit.</strong>
    <strong>(use "git push" to publish your local commits)</strong>
    
  <strong>Changes not staged for commit:</strong>
    <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
    <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong>  modified:   foo</strong>
    
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong>
<strong>$ git stash apply --quiet 'stash@{0}'</strong>
<strong>$ git stash list</strong>
<strong>stash@{0}: On master: Made another change to bar</strong>
<strong>stash@{1}: On master: Updates to foo</strong>
<strong>stash@{2}: WIP on master: 2302181 Update foo</strong></pre>
<p>The stashes are still in the <kbd>stash</kbd> list, and they can be applied in any order and referred to with the <kbd>stash@{stash-no}</kbd> syntax. The <kbd>--quiet</kbd> option suppresses the status output after the stashes have been applied.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>For stashes applied with <kbd>git stash apply</kbd>, the <kbd>stash</kbd> needs to be deleted with <kbd>git stash drop</kbd>:</p>
<pre><strong>$ git stash drop 'stash@{1}'</strong>
<strong>Dropped stash@{1} (e634b347d04c13fc0a0d155a3c5893a1d3841fcd)</strong>
<strong>$ git stash list</strong>
<strong>stash@{0}: On master: Made another change to bar</strong>
<strong>stash@{1}: WIP on master: 1676cdb Update foo</strong></pre>
<p>Keeping the stashes in the <kbd>stash</kbd> list by using <kbd>stash apply</kbd> and explicitly deleting them with <kbd>git stash drop</kbd> has some advantages over just using <kbd>stash pop</kbd>. When using the <kbd>pop</kbd> option, the stashes in the list are automatically deleted if they can be successfully applied. But if it fails and triggers the conflict resolution mode, the stash applied is not dropped from the list and continues to exist on the <kbd>stash</kbd> stack. This might later lead to accidentally using the wrong <kbd>stash</kbd> because it was thought to have been removed. By consistently using <kbd>git stash apply</kbd> and <kbd>git stash drop</kbd>, you can avoid this scenario.</p>
<p>The <kbd>git stash</kbd> command can also be used to apply debug information to an application. Let's pretend you have been bug hunting and have added a lot of debug statements to your code in order to track down a bug. Instead of deleting all those debug statements, you can save them as a Git <kbd>stash</kbd>:<br/>
<kbd>$ git stash save "Debug info stash"</kbd><br/>
Then, if you need debug statements later, you can just apply the stash and you'll be ready to debug.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging with git bisect</h1>
                
            
            
                
<p>The <kbd>git bisect</kbd> command is an excellent tool to find which commit caused a bug in the repository. The tool is particularly useful if you are looking at a long list of commits that may contain the bug. The <kbd>bisect</kbd> command performs a binary search through the commit history to find the commit that introduced the bug as fast as possible. The binary search method, or bisection method, as it is also called, is a search method where an algorithm finds the position of a key in a sorted array. In each step of the algorithm, the key is compared to the middle value of the array and if they match, the position is returned. Otherwise, the algorithm repeats its search in the subarray to the right or left of the middle value, depending on whether the middle value was greater or less than the key. In the Git context, the list of commits in the history makes up for the array of values to be tested, and the key can be a test if the code can be compiled successfully at the given commit. The binary search algorithm has a performance of <em>O(log n)</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the same repository as seen in the last example, but from a clean state:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong>
<strong>$ git checkout bug_hunting</strong></pre>
<p>The <kbd>bug_hunting</kbd> branch contains 23 commits, since it branched off from the <kbd>master</kbd> branch. We know that the tip of the <kbd>bug_hunting</kbd> branch contains the bug and that it was introduced in a commit, since it branched off from <kbd>master</kbd>. The bug was introduced in the following commit:</p>
<pre><strong>commit 83c22a39955ec10ac1a2a5e7e69fe7ca354129af</strong>
<strong>Author: HAL 9000 &lt;John.Doe@example.com&gt;</strong>
<strong>Date:   Tue May 13 09:53:45 2014 +0200</strong>
    
<strong>Bugs...</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The bug is clearly visible in the <kbd>map.txt</kbd> file, in the middle of Australia. The following snippet of the file shows the bug:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c0523183-60dc-4d83-b8af-a6f02eb395b3.png"/></p>
<p>Now, all we need is some way to reproduce/detect the bug so that we can test the different commits. This could, for example, simply be to compile the code, run tests, and so on.</p>
<p>For this example, we'll create a test script to check for bugs in the code (a simple <kbd>grep</kbd> for <kbd>oo</kbd> should do it in this example; see for yourself if you can find the bug in the <kbd>map.txt</kbd> file):</p>
<pre><strong>$ echo "! grep -q oo map.txt" &gt; ../test.sh</strong>
<strong>$ chmod +x ../test.sh</strong></pre>
<p>It's better to create this test script outside the repository to prevent interactions between checkouts, compilation, and so on in the repository.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To begin bisecting, we simply type the following:</p>
<pre><strong>$ git bisect start</strong></pre>
<p>To mark the current commit (<kbd>HEAD -&gt; bug_hunting</kbd>) as bad, we type the following:</p>
<pre><strong>$ git bisect bad</strong></pre>
<p>We also want to mark the last known good commit (<kbd>master</kbd>) as good:</p>
<pre><strong>$ git bisect good master</strong>
<strong>Bisecting: 11 revisions left to test after this (roughly 4 steps)</strong>
<strong>[9d2cd13d4574429dd0dcfeeb90c47a2d43a9b6ef] Build map part 11</strong></pre>
<p>This time, something happened. Git did a checkout of <kbd>9d2cd13</kbd>, which it wants us to test and mark as either good or bad. It also tells us there are 11 revisions to test after this, and it can be done in approximately four steps. This is how the bisecting algorithm works: every time a commit is marked as good or bad, Git will <kbd>checkout</kbd> the one between the commit that has just been marked and the current commit of opposite value. In this way, Git quickly narrows down the number of commits to check. It also knows that there are approximately four steps, and this makes sense since, with 11 revisions left, the maximum number of tries is <em>log<sub>2</sub>(11) = 3.46</em> before the faulty commit is found.</p>
<p>We can test with the <kbd>test.sh</kbd> script we created previously, and based on the return value, mark the commit as good or bad:</p>
<pre><strong>$ ../test.sh; test $? -eq 0 &amp;&amp; git bisect good || git bisect bad</strong>
<strong># git bisect good</strong>
<strong>Bisecting: 5 revisions left to test after this (roughly 3 steps)</strong>
<strong>[c45cb51752a4fe41f52d40e0b2873350b95a9d7c] Build map part 16</strong> </pre>
<p>The test marks the commit as good and Git checks out the next commit to be marked, until we hit the commit that introduces the bug:</p>
<pre><strong>$ ../test.sh; test $? -eq 0 &amp;&amp; git bisect good || git bisect bad </strong>
<strong># git bisect bad</strong>
<strong>Bisecting: 2 revisions left to test after this (roughly 2 steps)</strong>
<strong>[83c22a39955ec10ac1a2a5e7e69fe7ca354129af] Bugs...</strong>
<strong>$ ../test.sh; test $? -eq 0 &amp;&amp; git bisect good || git bisect bad </strong>
<strong># git bisect bad</strong>
<strong>Bisecting: 0 revisions left to test after this (roughly 1 step)</strong>
<strong>[670ab8c42a6cb1c730c7c4aa0cc26e5cc31c9254] Build map part 13</strong>
<strong>$ ../test.sh; test $? -eq 0 &amp;&amp; git bisect good || git bisect bad</strong>
<strong># git bisect good</strong>
<strong>83c22a39955ec10ac1a2a5e7e69fe7ca354129afis the first bad commit</strong>
<strong>commit 83c22a39955ec10ac1a2a5e7e69fe7ca354129af</strong>
<strong>Author: HAL 9000 &lt;aske.olsson@switch-gears.dk&gt;</strong>
<strong>Date:   Tue May 13 09:53:45 2014 +0200</strong>
    
<strong>    Bugs...</strong>
    
<strong>:100644 100644 8a13f6bd858aefb70ea0a7d8f601701339c28bb0 1afeaaa370a2e4656551a6d44053ee0ce5c3a237 M map.txt</strong></pre>
<p>After four steps, Git has identified the <kbd>83c22a3</kbd> commit as the first bad commit. We can end the <kbd>bisect</kbd> session and take a closer look at the commit:</p>
<pre><strong>$ git bisect reset</strong>
<strong>Previous HEAD position was 670ab8c... Build map part 13</strong>
<strong>Switched to branch 'bug_hunting'</strong>
<strong>Your branch is up-to-date with 'origin/bug_hunting'.</strong>
<strong>$ git show 83c22a39955ec10ac1a2a5e7e69fe7ca354129af</strong>
<strong>commit 83c22a39955ec10ac1a2a5e7e69fe7ca354129af</strong>
<strong>Author: HAL 9000 &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Tue May 13 09:53:45 2014 +0200</strong>
    
<strong>  Bugs...</strong>
    
<strong>diff --git a/map.txt b/map.txt</strong>
<strong>index 8a13f6b..1afeaaa 100644</strong>
<strong>--- a/map.txt</strong>
<strong>+++ b/map.txt</strong>
<strong>@@ -34,6 +34,6 @@ Australia:</strong>
    <strong>                .-./     |.     :  :,</strong>
    <strong>               /           '-._/     _</strong>
    <strong>              /                '       </strong>
    <strong>-           .'                         *: Brisbane</strong>
    <strong>-        .-'                             ;</strong>
    <strong>-        |                               |</strong>
    <strong>+           .'        __/             *: Brisbane</strong>
    <strong>+        .-'          (oo)               ;</strong>
    <strong>+        |           //||\              |</strong>
  </pre>
<p>Clearly, a bug was introduced with this commit.</p>
<p>The following annotated screenshot shows the steps taken by the <kbd>bisect</kbd> session:</p>
<p class="mce-root"/>
<div><img src="img/5e06b301-474f-479b-a48f-628a01617960.png" style="width:36.42em;height:28.58em;"/></div>
<p>Note that the bisection algorithm actually hits the faulty commit in the third step, but it needs to look further to make sure that the commit isn't just a child commit of the faulty commit, and is in fact the commit that introduced the bug.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Instead of running all the bisecting steps manually, it's possible to do it automatically by passing Git a script, makefile, or test to run on each commit. The script needs to exit with a <strong>zero-status</strong> to mark a commit as good and a <strong>non-zero</strong> status to mark it as bad. We can use the <kbd>test.sh</kbd> script we created at the beginning of this chapter for this. First, we set up the good and bad commits:</p>
<pre><strong>$ git bisect start HEAD master</strong>
<strong>Bisecting: 11 revisions left to test after this (roughly 4 steps)</strong>
<strong>[9d2cd13d4574429dd0dcfeeb90c47a2d43a9b6ef] Build map part 11</strong></pre>
<p>Then, we tell Git to run the <kbd>test.sh</kbd> script and automatically mark the commits:</p>
<pre><strong>$ git bisect run ../test.sh</strong> <strong>running ../test.sh</strong> <strong>Bisecting: 5 revisions left to test after this (roughly 3 steps)</strong> <strong>[c45cb51752a4fe41f52d40e0b2873350b95a9d7c] Build map part 16</strong> <strong>running ../test.sh</strong> <strong>Bisecting: 2 revisions left to test after this (roughly 2 steps)</strong> <strong>[83c22a39955ec10ac1a2a5e7e69fe7ca354129af] Bugs...</strong> <strong>running ../test.sh</strong> <strong>Bisecting: 0 revisions left to test after this (roughly 1 step)</strong> <strong>[670ab8c42a6cb1c730c7c4aa0cc26e5cc31c9254] Build map part 13</strong> <strong>running ../test.sh</strong> <strong>83c22a39955ec10ac1a2a5e7e69fe7ca354129afis the first bad commit</strong> <strong>commit 83c22a39955ec10ac1a2a5e7e69fe7ca354129af</strong> <strong>Author: HAL 9000 &lt;john.doe@example.com&gt;</strong> <strong>Date: Tue May 13 09:53:45 2014 +0200</strong> <strong> Bugs...</strong> <strong>:100644 100644 8a13f6bd858aefb70ea0a7d8f601701339c28bb0 1afeaaa370a2e4656551a6d44053ee0ce5c3a237 M map.txt</strong> <strong>bisect run success</strong></pre>
<p>Git found the same commit and we can now exit the bisecting session:</p>
<pre><strong>$ git bisect reset</strong>
<strong>Previous HEAD position was 670ab8c... Build map part 13</strong>
<strong>Switched to branch 'bug_hunting'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the blame command</h1>
                
            
            
                
<p>The <kbd>bisect</kbd> command is good when you don't know where in your code there is a bug, but you can test for it and thereby find the commit that introduced it. If you already know where in the code the bug is but want to find the commit that introduced it, you can use <kbd>git blame</kbd>. The <kbd>blame</kbd> command will annotate every line in the file with the commit that most recently touched that line, making it easy to find the commit ID and then the full context of the commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the same repository and branch as in the bisect example:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks<br/></strong><strong>$ git checkout bug_hunting</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We know that the bug is in <kbd>map.txt</kbd> on lines 37-39. To annotate each line in the file with the commit ID and author, we'll run <kbd>git blame</kbd> on the file. We can further limit the search to specific lines with the <kbd>-L &lt;from&gt;,&lt;to&gt;</kbd> option, as shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-462 image-border" src="img/6a9c27d8-3809-483d-86c7-3458e6067a63.png" style="width:58.33em;height:23.92em;"/></div>
<p>From the output, it can clearly be seen that the commit with the ID <kbd>83c22a39</kbd> by <kbd>HAL 9000</kbd> introduced the bug.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The <kbd>blame</kbd> command can be used even if the file has been refactored and the code has been moved around. With the <kbd>-M</kbd> option, the <kbd>blame</kbd> command can detect lines that have been moved within the file, and with the <kbd>-C</kbd> option, Git can detect lines that were moved or copied from other files in the same commit. If the <kbd>-C</kbd> option is used three times <kbd>-CCC</kbd>, the <kbd>blame</kbd> command will find lines that were copied from other files in any commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coloring the UI in the prompt</h1>
                
            
            
                
<p>By default, Git has no colors when displaying information in the terminal. However, displaying colors is a feature of Git that is only a configuration away.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the <kbd>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</kbd> repository:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we'll edit and add <kbd>foo</kbd>:</p>
<pre><strong>$ echo "And another line" &gt;&gt; foo</strong>
<strong>$ git add foo</strong></pre>
<p>Change <kbd>foo</kbd> some more, but don't add it to the staging area:</p>
<pre><strong>$ echo "Last line ...so far" &gt;&gt; foo</strong></pre>
<p>Create a new file called <kbd>test</kbd>:</p>
<pre><strong>$ touch test</strong></pre>
<p>The <kbd>git status</kbd> command will show us the status:</p>
<pre><strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
  <strong>Changes to be committed:</strong>
    <strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>  modified:   foo</strong>
    
  <strong>Changes not staged for commit:</strong>
    <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
    <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong>  modified:   foo</strong>
    
  <strong>Untracked files:</strong>
    <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong>  test</strong></pre>
<p>We can set the <kbd>color.ui</kbd> configuration to <kbd>auto</kbd> or <kbd>true</kbd> to get color in the UI when required:</p>
<pre><strong>$ git config --global color.ui true</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
<strong>Changes to be committed:</strong>
  <strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>modified:   foo</strong>
<br/><strong>Changes not staged for commit:</strong>
  <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
   <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong> modified:   foo</strong>
    
<strong>Untracked files:</strong>
  <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
  <strong>test</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The <kbd>color.ui</kbd> configuration works with a long range of Git commands, <kbd>diff</kbd>, <kbd>log</kbd>, and <kbd>branch</kbd> included. The following is an example of <kbd>git log</kbd> when setting <kbd>color.ui</kbd> to <kbd>true</kbd>:</p>
<pre><strong>$ git log --oneline --decorate --graph</strong>
<strong>* c111003 (HEAD -&gt; master, origin/master, origin/HEAD) Update foo and bar</strong>
<strong>* 270e97b Add bar</strong>
<strong>* 43fd490 Initial commit, adds foo</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Autocompletion</h1>
                
            
            
                
<p>Git comes with built-in support for the autocompletion of Git commands for the <kbd>bash</kbd> and <kbd>zsh</kbd> shells. If you use either of these shells, you can enable the autocompletion feature and let the <kbd>&lt;tab&gt;</kbd> option help you complete commands.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Generally, the autocompletion feature is distributed with the Git installation, but it is not enabled by default on all platforms or distributions. To enable it, we need to find the <kbd>git-completion.bash</kbd> file distributed/installed with the Git installation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Linux</h1>
                
            
            
                
<p>For Linux users, the location may vary depending on the distribution. Generally, the file can be found at <kbd>/etc/bash_completion.d/git-completion.bash</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mac</h1>
                
            
            
                
<p>For Mac users, it can generally be found at <kbd>/Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash</kbd>.</p>
<p>If you installed Git from Homebrew, it can be found at <kbd>/usr/local/Cellar/git/2.15.0/etc/bash_completion.d/git-completion.bash</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Windows</h1>
                
            
            
                
<p>With the <strong>Msysgit</strong> installation on Windows, the completion functions are already enabled in the Git Bash shell it bundles.</p>
<p>If you can't find the file on your system, you can obtain the latest version from <a href="https://github.com/git/git/blob/master/contrib/completion/git-completion.bash">https://github.com/git/git/blob/master/contrib/completion/git-completion.bash</a> and install it in your home directory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To enable the completion feature, you need to run the <kbd>source</kbd> command on the completion file, which you can do by adding the following lines to your <kbd>.bashrc</kbd> or <kbd>.zshrc</kbd> file, depending on your shell and the location of the Git completion file:</p>
<pre><strong>if [ -f /etc/bash_completion.d/git-completion.bash ]; then</strong>
<strong>    source /etc/bash_completion.d/git-completion.bash</strong>
<strong>fi</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Now you are ready to try this. Switch to an existing Git repository, for example, <kbd>cookbook-tips-tricks</kbd>, and type the following commands:</p>
<pre><strong>$ git che&lt;tab&gt;&lt;tab&gt;</strong>
<strong>checkout      cherry        cherry-pick</strong></pre>
<p class="mce-root"/>
<p>You can add another <kbd>c&lt;tab&gt;</kbd> and the command will autocomplete to <kbd>checkout</kbd>. But the autocompletion feature doesn't only complete commands; it can also help you complete branch names, and so on. This means that you can continue with the checkout and write <kbd>mas&lt;tab&gt;</kbd>. You should be able to see the output completed to the <kbd>master</kbd> branch, unless you are in a repository where there are several branches starting with <kbd>mas</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The completion feature also works with options. This is quite useful if you can't remember the exact option but you may remember some of it, for example, when using <kbd>git branch</kbd>:</p>
<pre><strong>git branch --&lt;tab&gt;&lt;tab&gt;</strong>
<strong>--abbrev=            --merged             --set-upstream-to=</strong>
<strong>--color              --no-abbrev          --track</strong>
<strong>--contains           --no-color           --unset-upstream</strong>
<strong>--edit-description   --no-merged          --verbose</strong>
<strong>--list               --no-track</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Bash prompt with status information</h1>
                
            
            
                
<p>Another cool feature Git provides is having the prompt display status information if the current working directory is a Git repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For the status information prompt to work, we also need to source another file, <kbd>git-prompt.sh</kbd>, which is usually distributed with the Git installation and located in the same directory as the completion file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In your <kbd>.bashrc</kbd> or <kbd>.zshrc</kbd> file, add the following code snippet, again depending on your shell and the location of the <kbd>git-prompt.sh</kbd> file:</p>
<pre><strong>if [ -f /etc/bash_completion.d/git-prompt.sh ]; then</strong>
<strong>    source /etc/bash_completion.d/git-prompt.sh</strong>
<strong>fi</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To make use of the Command Prompt, we must change the <kbd>PS1</kbd> variable; usually this is set to something like the following:</p>
<pre><strong>PS1='u@h:w$ '</strong></pre>
<p>The preceding command shows the current user, an <kbd>@</kbd> sign, the hostname, the current working directory relative to the user's home directory, and finally, the <kbd>$</kbd> character:</p>
<pre><strong>john.doe@yggdrasil:~/cookbook-tips-tricks$</strong></pre>
<p>We can change this to add a branch name after the working directory by adding <kbd>$(__git_ps1 " (%s)")</kbd> to the <kbd>PS1</kbd> variable:</p>
<pre><strong>PS1='u@h:w$(__git_ps1 " (%s)") $ ' </strong></pre>
<p>Our prompt will now look like this:</p>
<pre><strong>john.doe@yggdrasil:~/cookbook-tips-tricks (master) $</strong></pre>
<p>It is also possible to show the state of the working tree, the index, and so on. We can enable these features by exporting some environment variables in the <kbd>.bashrc</kbd> file that <kbd>git-prompt.sh</kbd> picks up.</p>
<p>The following environment variables can be set:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Variable</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Effect</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GIT_PS1_SHOWDIRTYSTATE</kbd></p>
</td>
<td>
<p>Nonempty</p>
</td>
<td>
<p>Shows <kbd>*</kbd> for unstaged changes and <kbd>+</kbd> for staged changes.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GIT_PS1_SHOWSTASHSTATE</kbd></p>
</td>
<td>
<p>Nonempty</p>
</td>
<td>
<p>Shows the <kbd>$</kbd> character if something is stashed.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GIT_PS1_SHOWUNTRACKEDFILES</kbd></p>
</td>
<td>
<p>Nonempty</p>
</td>
<td>
<p>Shows the <kbd>%</kbd> character if there are untracked files in the repository.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GIT_PS1_SHOWUPSTREAM</kbd></p>
</td>
<td>
<p>auto</p>
<p>verbose</p>
<p>name</p>
<p>legacy</p>
<p>Git</p>
<p>svn</p>
</td>
<td>
<p>Auto shows whether you are behind (<kbd>&lt;</kbd>) or ahead (<kbd>&gt;</kbd>) of the upstream branch. A <kbd>&lt;&gt;</kbd> value is displayed if the branch is diverged and <kbd>=</kbd> if it is up to date. Verbose shows the number of commits behind/ahead. Name shows the upstream name. Legacy is verbose for old versions of Git. Git compares <kbd>HEAD</kbd> to <kbd>@{upstream}</kbd>. SVN compares <kbd>HEAD</kbd> to <kbd>svn upstream</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GIT_PS1_DESCRIBE_STYLE</kbd></p>
</td>
<td>
<p>contains</p>
<p>branch</p>
<p>describe</p>
<p>default</p>
</td>
<td>
<p>Displays extra information when on a detached <kbd>HEAD</kbd>. Contains is relative to a newer annotated tag (<kbd>v1.6.3.2~35</kbd>). Branch is relative to a newer tag or branch (<kbd>master~4</kbd>). Describe is relative to an older annotated tag (<kbd>v1.6.3.1-13-gdd42c2f</kbd>). Default is the tag that matches exactly.</p>
</td>
</tr>
</tbody>
</table>
<div><p> </p>
<p>Let's try to set some of the variables in the <kbd>~/.bashrc</kbd> file:</p>
<pre><strong>export GIT_PS1_SHOWUPSTREAM=auto</strong>
<strong>export GIT_PS1_SHOWDIRTYSTATE=enabled</strong>
<strong>PS1='u@h:w$(__git_ps1 " (%s)") $ ' </strong></pre>
<p>Let's see the <kbd>~/.bashrc</kbd> file in action:</p>
<pre><strong>john.doe@yggdrasil:~ $ cd tips_and_tricks/</strong>
<strong>john.doe@yggdrasil:~/tips_and_tricks (master=) $ touch test</strong>
<strong>john.doe@yggdrasil:~/tips_and_tricks (master=) $ git add test</strong>
<strong>john.doe@yggdrasil:~/tips_and_tricks (master +=) $ echo "Testing" &gt; test</strong>
<strong>john.doe@yggdrasil:~/tips_and_tricks (master *+=) $ git commit -m "test"</strong>
<strong>[master 5c66d65] test</strong>
  <strong>1 file changed, 0 insertions(+), 0 deletions(-)</strong>
<strong>  create mode 100644 test</strong>
<strong>  john.doe@yggdrasil:~/tips_and_tricks (master *&gt;) $</strong></pre>
<p>When using the <kbd>__git_ps1</kbd> option, Git will also display information when merging, rebasing, bisecting, and so on. This is very useful and a lot of <kbd>git status</kbd> commands suddenly become unnecessary, as you have the information right there in the prompt.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>What is a terminal without some colors these days? The <kbd>git-prompt.sh</kbd> script also supports this. All we need to do is set the <kbd>GIT_PS1_SHOWCOLORHINTS</kbd> variable to a nonempty value and, instead of using <kbd>PS1</kbd>, we need to use <kbd>PROMPT_COMMAND</kbd>. Let's change <kbd>~/.bashrc</kbd>:</p>
<pre><strong>export GIT_PS1_SHOWUPSTREAM=auto</strong>
<strong>export GIT_PS1_SHOWDIRTYSTATE=enabled</strong>
<strong>export GIT_PS1_SHOWCOLORHINTS=enabled</strong>
<strong>PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\$ "'</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>If we redo the same scenario as the previous one, we get the following:</p>
<div><img class="alignnone size-full wp-image-464 image-border" src="img/cae11322-952c-4fc9-a382-1d4686e8155a.png" style="width:163.83em;height:32.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>If you are using <kbd>zsh</kbd> or just want to try something new with many features, such as completion, Git support, and so on, you should take a look at the <kbd>oh-my-zsh</kbd> framework, available for <kbd>zsh</kbd> at: <a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">More aliases</h1>
                
            
            
                
<p>In <a href="dfad614d-7bef-4396-824c-7bdfcbd22802.xhtml">Chapter 2</a>, <em>Configuration</em>, we saw how we can create aliases and looked at a few examples of them. In this section, we will look at some more examples of useful aliases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will have to clone the <kbd>cookbook-tips-tricks</kbd> repository and check out the <kbd>aliases</kbd> branch:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong>
<strong>$ git checkout aliases</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Here, we'll see some examples of aliases, with a short description of each of them and an example of how to use them. The aliases are just made for the local repository; use <kbd>--global</kbd> to make them available for all the repositories.</p>
<ol>
<li>Let's begin with an alias to show the current branch only:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.b "rev-parse --abbrev-ref HEAD"</strong>
<strong>$ git b</strong>
<strong>aliases</strong></pre>
<ol start="2">
<li>To show a compact graph history view with colors, the following alias will save you many keystrokes:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.graph "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"</strong>
<strong>$ git graph origin/conflict aliases</strong></pre>
<p style="padding-left: 60px">The following screenshot shows you a typical output, where commits are colored red, committers are colored blue, and so on:</p>
<div><img src="img/18966b27-700f-41ae-8672-01228039f358.png"/></div>
<ol start="3">
<li>When resolving a conflicted merge, it can be useful to get a list of the conflicted/unmerged files:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.unmerged '!git ls-files --unmerged | cut -f2 | sort -u'</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li class="packt_nosymbol">We can see the previous alias in action by merging the <kbd>origin/conflict</kbd> branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge origin/conflict</strong>
<strong>Auto-merging spaceship.txt</strong>
<strong>CONFLICT (content): Merge conflict in spaceship.txt</strong>
<strong>Automatic merge failed; fix conflicts and then commit the result.</strong>
  </pre>
<ol start="5">
<li class="packt_nosymbol">First, check the output of <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch aliases</strong>
<strong>Your branch is up-to-date with 'origin/aliases'.</strong>
    
<strong>You have unmerged paths.</strong>
  <strong>(fix conflicts and run "git commit")</strong>
    
  <strong>Unmerged paths:</strong>
    <strong>(use "git add &lt;file&gt;..." to mark resolution)</strong>
    
    <strong>  both modified:      spaceship.txt</strong>
    
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<ol start="6">
<li class="packt_nosymbol">We see the unmerged path mentioned in the output. Let's use the <kbd>unmerged</kbd> alias to get a simple list of unmerged files:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git unmerged</strong>
<strong>spaceship.txt</strong></pre>
<ol start="7">
<li class="packt_nosymbol">You can abort the merge as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge --abort</strong></pre>
<ol start="8">
<li>During a work day, you will type <kbd>git status</kbd> many times. Adding a shorthand status can be helpful:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.st "status"</strong>
<strong>$ git st</strong>
<strong>On branch aliases</strong>
<strong>Your branch is up-to-date with 'origin/aliases'.</strong>
    
<strong>nothing to commit, working directory clean</strong></pre>
<ol start="9">
<li>An even shorter status with branch and file information can be defined as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.s 'status -sb'</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="10">
<li class="packt_nosymbol">To try it out, first modify <kbd>foo</kbd> and create an untracked <kbd>test</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ touch test</strong>
<strong>$ echo testing &gt;&gt; foo</strong></pre>
<ol start="11">
<li class="packt_nosymbol">Next, try your new <kbd>s</kbd> alias:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git s</strong>
<strong>## aliases...origin/aliases</strong>
<strong>M foo</strong>
<strong>?? test</strong> </pre>
<ol start="12">
<li>Often, you'll just want to show the latest commit with some stats:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.l1 "log -1 --shortstat"</strong>
<strong>$ git l1</strong>
<strong>  commit a43eaa9b461e811eeb0f18cce67e4465888da333</strong>
  <strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
  <strong>Date:   Wed May 14 22:46:32 2014 +0200</strong>
    
    <strong>Better spaceship design</strong>
    
 <strong>1 file changed, 9 insertions(+), 9 deletions(-)</strong></pre>
<ol start="13">
<li>But sometimes, you need a bit more context. The following alias is the same  as the previous but for the five latest commits (the output is not shown):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.l5 "log -5 --decorate --shortstat"</strong></pre>
<ol start="14">
<li>A commit listing with statistics on the changed files in color can be displayed using the following alias:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.ll 'log --pretty=format:"%C(yellow)%h%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset %Cred%d%Creset" --numstat'</strong>
<strong>$ git ll -5</strong></pre>
<p style="padding-left: 60px">As the next screenshot shows, committers are colored blue, their age in green, and so on:</p>
<div><img class="alignnone size-full wp-image-465 image-border" src="img/feb33e0e-c000-4819-8d9e-f0bf8d3ea163.png" style="width:137.00em;height:42.00em;"/></div>
<ol start="15">
<li>If you work in many repositories, remember that the <kbd>upstream/tracking</kbd> branch can be difficult. The following alias is shorthand for showing this:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.upstream "rev-parse --symbolic-full-name --abbrev-ref=strict HEAD@{u}"</strong>
<strong>$ git upstream</strong>
<strong>origin/aliases</strong> </pre>
<ol start="16">
<li>You can show the details of ID/SHA-1 (commit, tag, tree, blob) with the <kbd>details</kbd> alias. Not that you save many keystrokes, but <kbd>details</kbd> is easier to remember:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.details "cat-file -p"</strong>
<strong>$ git details HEAD</strong>
<strong>tree bdfdaacbb29934b239db814e599342159c4390dd</strong>
<strong>parent 8fc1819f157f2c3c25eb973c2a2a412ef3d5517a</strong>
<strong>author John Doe &lt;john.doe@example.com&gt; 1400100392 +0200</strong>
<strong>committer John Doe &lt;john.doe@example.com&gt; 1400100392 +0200</strong>
    
<strong>Better spaceship design</strong></pre>
<ol start="17">
<li>A repository will grow, and the directory tree will become large. You can show the number of <kbd>cd-ups</kbd> and, <kbd>../</kbd>, needed to go to the repository root using the following alias, which can be useful in shell scripts:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.root "rev-parse --show-cdup"</strong>
<strong>$ cd sub/directory/example</strong>
<strong>$ pwd</strong>
<strong>/path/to/cookbook-tips-tricks/sub/directory/example</strong>
<strong>$ git root</strong>
<strong>../../../</strong>
<strong>$ cd $(git root)</strong>
<strong>$ pwd</strong>
<strong>/path/to/cookbook-tips-tricks</strong></pre>
<ol start="18">
<li>The path of the repository on the filesystem can easily be viewed with the following alias:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.path "rev-parse --show-toplevel"</strong>
<strong>$ git path</strong>
<strong>/path/to/cookbook-tips-tricks</strong></pre>
<ol start="19">
<li>If we need to abandon whatever changes we have in the index, working tree, and also possibly the commits, and reset the working tree to a known state (commit ID) but we don't want to touch the untracked files, all we need is a <kbd>ref</kbd> to a state of the repository to be restored, for example, <kbd>HEAD</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.abandon "reset --hard"</strong>
<strong>$ echo "new stuff" &gt;&gt; foo</strong>
<strong>$ git add foo</strong>
<strong>$ echo "other stuff" &gt;&gt; bar</strong>
<strong>$ git s</strong>
<strong>## aliases...origin/aliases</strong>
<strong>M bar</strong>
<strong>M  foo</strong>
<strong>?? test</strong>
<strong>$ git abandon HEAD</strong>
<strong>$ git s</strong>
<strong>## aliases...origin/aliases</strong>
<strong>?? test</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Interactive add</h1>
                
            
            
                
<p>The exposed staging area Git offers sometimes leads to confusion, especially when adding a file, changing it a bit, and then adding the file again to be able to commit the changes made after the first add. While it can seem a bit cumbersome to add the file after every little change, it is also a big advantage that you can stage and unstage changes. With the <kbd>git add</kbd> command, it's even possible to only add some changes to a file in the staging area. This comes in handy, especially if you make a lot of changes to a file and, for example, want to split the changes into bug fixes, refactoring, and features. This example will show how you can easily do this.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the <kbd>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</kbd> repository. Clone it and check out the interactive branch:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong>
<strong>$ git checkout interactive</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we need some changes to be added; we do this by resetting the latest commit:</p>
<pre><strong>$ git reset 'HEAD^'</strong>
<strong>Unstaged changes after reset:</strong>
<strong>M    liberty.txt</strong></pre>
<p>Now we have a modified file. To start the interactive add, we can either run the <kbd>git add -i</kbd> or <kbd>git add -p</kbd> filename. The <kbd>-i</kbd> option brings up an interface where all the different files in the modified state can be added interactively one at a time. The <kbd>add -p/--patch</kbd> option is simpler and just gives you the option to add parts of the file specified:</p>
<pre><strong>$ git add -p liberty.txt</strong>
<strong>diff --git a/liberty.txt b/liberty.txt</strong>
<strong>index 8350a2c..9638930 100644</strong>
<strong>--- a/liberty.txt</strong>
<strong>+++ b/liberty.txt</strong>
<strong>@@ -8,6 +8,13 @@</strong>
    <strong>  WW) ,WWW)</strong>
    <strong>  7W),WWWW'</strong>
    <strong>  'WWWWWW'</strong>
<strong>+          9---W)</strong>
<strong>+      ,,--WPL=YXW===</strong>
<strong>+     (P),CY:,I/X'F9P</strong>
<strong>+     WUT===---/===9)</strong>
<strong>+     -HP+----Y(C=9W)</strong>
<strong>+      '9Y3'-'-OWPT-</strong>
<strong>+       'WWLUIECW</strong>
    <strong>  (:7L7C7'</strong>
    <strong>   ,P--=YWFL</strong>
    <strong>   Y-=:9)UW:L</strong>
<strong>Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]?</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Git asks you whether you want to stage the previous change (the hunk), but also shows quite a lot of options, which can be expanded a little bit if you type <kbd>?</kbd>:</p>
<pre><strong>Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]? </strong>
<strong>y - stage this hunk</strong>
<strong>n - do not stage this hunk</strong>
<strong>q - quit; do not stage this hunk nor any of the remaining ones</strong>
<strong>a - stage this hunk and all later hunks in the file</strong>
<strong>d - do not stage this hunk nor any of the later hunks in the file</strong>
<strong>g - select a hunk to go to</strong>
<strong>/ - search for a hunk matching the given regex</strong>
<strong>j - leave this hunk undecided, see next undecided hunk</strong>
<strong>J - leave this hunk undecided, see next hunk</strong>
<strong>k - leave this hunk undecided, see previous undecided hunk</strong>
<strong>K - leave this hunk undecided, see previous hunk</strong>
<strong>s - split the current hunk into smaller hunks</strong>
<strong>e - manually edit the current hunk</strong>
<strong>? - print help</strong></pre>
<p>There are a lot of options, but with the help text, they are quite self-explanatory. Let's add the current hunk, <kbd>y</kbd>, and look at the next one:</p>
<pre><strong>Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]? y</strong>
<strong>@@ -17,16 +24,17 @@</strong>
    <strong>   7WYW))PW W</strong>
    <strong>   7WH)),WC)</strong>
    <strong>   7L--/XY)</strong>
<strong>+DEBUG: Don't include this line...</strong>
    <strong>      9+-,KY7)</strong>
    <strong>      W9-Y3+7)</strong>
    <strong>      W'=9WI7)</strong>
    <strong>      ,W  '-YY)</strong>
<strong>-         W    ::W</strong>
<strong>-        ,T     :X)</strong>
<strong>-        ()     '9W  'L.                    ,-</strong>
<strong>-        (C     =:9   '9L                  ,T</strong>
<strong>-        ()    ,,-7)    7WL              ,F'</strong>
<strong>-        ()    , T9)     '9WL          ,YF</strong>
<strong>+         W    ::W                ,</strong>
<strong>+        ,T     :X)              ()</strong>
<strong>+        ()     '9W  'L.         ()         ,-</strong>
<strong>+        (C     =:9   '9L        ()        ,T</strong>
<strong>+        ()    ,,-7)    7WL      WW      ,F'</strong>
<strong>+        ()    , T9)     '9WL    --    ,YF</strong>
    <strong>     ()    '-/(W       -==+PE9P7===O)          -,</strong>
    <strong>     'W, ,  T+/WX=L-. ,WP+()+3L3,),=WL  --==-T-</strong>
    <strong>      7)    -,YW '-=9WPL+PT-- ':--L/=9WP=-'</strong>
<strong>Stage this hunk [y,n,q,a,d,/,K,j,J,g,s,e,?]?</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Whoa! It looks like there is a debug line there that we should not add. Let's split the hunk, <kbd>s</kbd>:</p>
<pre><strong>Stage this hunk [y,n,q,a,d,/,K,j,J,g,s,e,?]? s</strong>
<strong>Split into 2 hunks.</strong>
<strong>@@ -17,7 +24,8 @@</strong>
    <strong>    7WYW))PW W</strong>
    <strong>    7WH)),WC)</strong>
    <strong>    7L--/XY)</strong>
<strong>+DEBUG: Don't include this line...</strong>
    <strong>     9+-,KY7)</strong>
    <strong>     W9-Y3+7)</strong>
    <strong>     W'=9WI7)</strong>
    <strong>     ,W  '-YY)</strong>
<strong>Stage this hunk [y,n,q,a,d,/,K,j,J,g,e,?]?</strong>  </pre>
<p>We don't want the output to be staged, use <kbd>n</kbd>, but we'll stage the next hunk and all the hunks later, in the <kbd>a</kbd> file:</p>
<pre><strong>Stage this hunk [y,n,q,a,d,/,K,j,J,g,e,?]? n</strong>
<strong>@@ -20,13 +28,13 @@</strong>
    <strong>     9+-,KY7)</strong>
    <strong>     W9-Y3+7)</strong>
    <strong>     W'=9WI7)</strong>
    <strong>     ,W  '-YY)</strong>
<strong>-         W    ::W</strong>
<strong>-        ,T     :X)</strong>
<strong>-        ()     '9W  'L.                    ,-</strong>
<strong>-        (C     =:9   '9L                  ,T</strong>
<strong>-        ()    ,,-7)    7WL              ,F'</strong>
<strong>-        ()    , T9)     '9WL          ,YF</strong>
<strong>+         W    ::W                ,</strong>
<strong>+        ,T     :X)              ()</strong>
<strong>+        ()     '9W  'L.         ()         ,-</strong>
<strong>+        (C     =:9   '9L        ()        ,T</strong>
<strong>+        ()    ,,-7)    7WL      WW      ,F'</strong>
<strong>+        ()    , T9)     '9WL    --    ,YF</strong>
    <strong>     ()    '-/(W       -==+PE9P7===O)          -,</strong>
    <strong>     'W, ,  T+/WX=L-. ,WP+()+3L3,),=WL  --==-T-</strong>
    <strong>     7)    -,YW '-=9WPL+PT-- ':--L/=9WP=-'</strong>
<strong>Stage this hunk [y,n,q,a,d,/,K,j,J,g,e,?]? a</strong></pre>
<p>Let's see the current status and the difference between the working directory and staging area:</p>
<pre><strong>$ git status</strong>
<strong>On branch interactive</strong>
<strong>Your branch is behind 'origin/interactive' by 1 commit, and can be fast-forwarded.</strong>
  <strong>(use "git pull" to update your local branch)</strong>
    
<strong>Changes to be committed:</strong>
  <strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong> modified:   liberty.txt</strong>
    
<strong>Changes not staged for commit:</strong>
  <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
  <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong> modified:   liberty.txt</strong>
<strong>$ git diff</strong>
<strong>diff --git a/liberty.txt b/liberty.txt</strong>
<strong>index 035083e..9638930 100644</strong>
<strong>--- a/liberty.txt</strong>
<strong>+++ b/liberty.txt</strong>
<strong>@@ -24,6 +24,7 @@</strong>
    <strong>   7WYW))PW W</strong>
    <strong>   7WH)),WC)</strong>
    <strong>   7L--/XY)</strong>
<strong>+DEBUG: Don't include this line...</strong>
    <strong>      9+-,KY7)</strong>
    <strong>      W9-Y3+7)</strong>
    <strong>      W'=9WI7)</strong></pre>
<p>Perfect! We got all the changes staged except the debug line, so the result can be committed:</p>
<pre><strong>$ git commit -m 'Statue of liberty completed'</strong>
<strong>[interactive 1ccb885] Statue of liberty completed</strong>
<strong>1 file changed, 36 insertions(+), 29 deletions(-)</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>As mentioned earlier, it's also possible to use <kbd>git add -i</kbd> to interactively add files. If we do this after resetting our branch, we will get the following menu:</p>
<pre><strong>$ git add -i</strong>
    <strong> staged     unstaged path</strong>
<strong>1:    unchanged      +37/-29 liberty.txt</strong>
    
<strong>*** Commands ***</strong>
<strong>1: status    2: update    3: revert    4: add untracked</strong>
<strong>5: patch     6: diff      7: quit      8: help</strong>
<strong>What now&gt;</strong></pre>
<p class="mce-root"/>
<p>The eight options pretty much do what they say. We can choose the patch option to get into the patch menu, as we saw previously, but first we have to choose which files to add patches for:</p>
<pre><strong>What now&gt; p</strong>
    <strong>      staged     unstaged path</strong>
<strong>1:    unchanged      +37/-29 liberty.txt</strong>
<strong>Patch update&gt;&gt; 1</strong>
    <strong>     staged     unstaged path</strong>
<strong>* 1:    unchanged      +37/-29 liberty.txt</strong>
<strong>Patch update&gt;&gt;</strong>
<strong>diff --git a/liberty.txt b/liberty.txt</strong>
<strong>index 8350a2c..9638930 100644</strong>
<strong>--- a/liberty.txt</strong>
<strong>+++ b/liberty.txt</strong>
<strong>...</strong></pre>
<p>Once we have chosen the files, we want to add patches so they get a <kbd>*</kbd> character in the menu. To begin patching, just click on <kbd>&lt;return&gt;</kbd>. When you're done, you'll return to the menu and can quit, review, revert, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interactive add with Git gui</h1>
                
            
            
                
<p>The interactive features of <kbd>git add</kbd> are really powerful for creating clean commits that only contain a single logical change, even though it was coded as a mix of feature adding and bug fixing. The downside of the interactive <kbd>git add</kbd> feature is that it is hard to get an overview of all the changes that exist in the file when only being showed one hunk at a time. To get a better overview of the changes and still be able to only add selected hunks (and even single lines), we can use <kbd>git gui</kbd>. Git GUI is normally distributed with the Git installation (MsysGit on Windows) and can be launched from the command line: <kbd>git gui</kbd>. If your distribution doesn't have Git GUI available, you can probably install it from the package manager called <kbd>git-gui</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the same repository as in the last example and reset it to the same state so that we can perform the same adds with Git GUI:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong>
<strong>$ git checkout interactive</strong>
<strong>$ git reset HEAD^</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Load Git GUI in the <kbd>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</kbd> repository. Here, you can see the unstaged changes (files) at the top-left and the staged changes (files) underneath. The main window will display the unstaged changes in the current marked file. You can right-click on a hunk and see a context menu with options for staging and so on. The first hunk shown by Git GUI is much larger than what we saw before with <kbd>git add -p</kbd>. Choose Show Less Context to split the hunk, as shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-466 image-border" src="img/55c0e5df-e123-4224-aaa7-63201d610cb7.png" style="width:37.58em;height:33.75em;"/></div>
<p>Now, we get a smaller hunk like before, as shown in the following screenshot:</p>
<div><img src="img/9e6d22e8-3fd6-4ea9-af5f-a53ecb20cee0.png" style="width:58.33em;height:25.33em;"/></div>
<p>For the first hunk, we just choose to add Stage Hunk For Commit, and the next hunk moves to the top of the screen, as shown in the next screenshot:</p>
<div><img src="img/96088c69-0258-4cc8-9e54-478d70566145.png" style="width:60.50em;height:36.83em;"/></div>
<p>Here, we can select the lines we want to add, instead of performing another split, and stage those lines: Stage Lines For Commit. We can add the rest of the hunks except the one with the debug line. Now, we are ready to create a commit and we can do so from the Git GUI. We can just write the commit message in the field at the bottom of the screen and hit Commit, as shown in the next screenshot:</p>
<div><img src="img/d0d83a40-b60e-41ab-b619-bdda1bde49f2.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Ignoring files</h1>
                
            
            
                
<p>For every repository, there are usually certain types of files you don't want tracked in the repository. The files can be configuration files, build output, or just backup files created by the editor when editing the file. To avoid these files showing up in the untracked files section of the <kbd>git status</kbd> output, it's possible to add them to a file called <kbd>.gitignore</kbd>. Entries in this file that match files in the working directory will not be considered by <kbd>git status</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Clone the <kbd>Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</kbd> repository and check out the <kbd>ignore</kbd> branch:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks</strong>
<strong>$ git checkout ignore</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll create some files and directories:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Testing" &gt; test.txt</strong>
<strong>$ echo "Testing" &gt; test.txt.bak</strong>
<strong>$ mkdir bin</strong>
<strong>$ touch bin/foobar</strong>
<strong>$ touch bin/frotz</strong></pre>
<ol start="2">
<li>Let's see the output of <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch ignore</strong>
<strong>Your branch is up-to-date with 'origin/ignore'.</strong>
    
 <strong>Untracked files:</strong>
   <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong> test.txt</strong>
    
<strong>nothing added to commit but untracked files present (use "git add" to track)</strong></pre>
<ol start="3">
<li>Only the <kbd>test.txt</kbd> file showed up in the output. This is because the rest of the files are ignored by Git. We can check the content of <kbd>.gitignore</kbd> to see how this happened:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cat .gitignore</strong>
<strong>*.config</strong>
<strong>*.bak</strong>
    
<strong># Java files</strong>
<strong>*.class</strong>
    
<strong>bin/</strong></pre>
<p style="padding-left: 60px">This means that <kbd>*.bak</kbd>, <kbd>*.class</kbd>, <kbd>*.config</kbd>, and everything in the <kbd>bin</kbd> directory are being ignored by Git.</p>
<ol start="4">
<li>If we try to add files in a path ignored by Git, for example <kbd>bin</kbd>, it will complain:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add bin/frotz</strong>
<strong>The following paths are ignored by one of your .gitignore files:</strong>
<strong>bin/frotz</strong>
<strong>Use -f if you really want to add them.</strong></pre>
<p style="padding-left: 60px">But, it also gives us the option to use <kbd>-f</kbd> if we really want to add it, which is <kbd>-f</kbd>:</p>
<pre style="padding-left: 60px"><strong>$ git add -f bin/frotz</strong>
<strong>$ git status</strong>
<strong>On branch ignore</strong>
  <strong>Your branch is up-to-date with 'origin/ignore'.</strong>
    
    <strong>Changes to be committed:</strong>
    <strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>    new file:   bin/frotz</strong>
    
<strong>Untracked files:</strong>
  <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
<strong>test.txt</strong></pre>
<ol start="5">
<li>If we ignore the <kbd>foo</kbd> file, which is already tracked, and modify it, it still shows up in the status, since tracked files are not ignored:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "foo" &gt;&gt; .gitignore</strong>
<strong>$ echo "more testing" &gt;&gt; foo</strong>
<strong>$ git status</strong>
<strong>On branch ignore</strong>
<strong>Your branch is up-to-date with 'origin/ignore'.</strong>
    
  <strong>Changes to be committed:</strong>
    <strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>  new file:   bin/frotz</strong>
    
  <strong>Changes not staged for commit:</strong>
    <strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
    <strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong>  modified:   .gitignore</strong>
    <strong>  modified:   foo</strong>
    
  <strong>Untracked files:</strong>
    <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
<strong>  test.txt</strong></pre>
<ol start="6">
<li>Let's add and commit <kbd>foo</kbd>, <kbd>.gitignore</kbd>, and the contents of the current staging area:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add foo .gitignore</strong>
<strong>$ git commit -m 'Add bin/frotz with force, foo &amp; .gitignore'</strong>
<strong>[ignore fc60b44] Add bin/frotz with force, foo &amp; .gitignore</strong>
<strong>3 files changed, 2 insertions(+)</strong>
<strong>create mode 100644 bin/frotz</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's also possible to ignore files of a repository without the <kbd>.gitignore</kbd> files. You can put your ignored files in a global ignore file, for example <kbd>~/.gitignore_global</kbd>, and globally configure Git to also consider entries in this file to be ignored:</p>
<pre><strong>$ git config --global core.excludesfile ~/.gitignore_global</strong></pre>
<p>You can also do it per repository in the <kbd>.git/info/exclude</kbd> file. If you use either of these options, you won't be able to easily share the ignored file; they can't be added to the repository as they are stored outside it. Sharing <kbd>.gitignore</kbd> files is much easier; you just add and commit them to Git. But, let's see how the other options work:</p>
<pre><strong>$ echo "*.test" &gt; .git/info/exclude</strong>
<strong>$ touch test.test</strong>
<strong>$ git status</strong>
<strong>On branch ignore</strong>
  <strong>Your branch is ahead of 'origin/ignore' by 1 commit.</strong>
    <strong>(use "git push" to publish your local commits)</strong>
    
  <strong>Untracked files:</strong>
    <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong>  test.txt</strong>
    
<strong>nothing added to commit but untracked files present (use "git add" to track)</strong>
<strong>$ ls</strong>
<strong>bar        bin       foo</strong>
<strong>test.test  test.txt  test.txt.bak</strong></pre>
<p>We can see that the <kbd>.test</kbd> file didn't show up in the <kbd>status</kbd> output and that the ignored files exist in the working directory.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>A wide range of files are commonly ignored, for example, to avoid accidentally adding text editor backup files, <kbd>*.swp</kbd>, <kbd>*~.</kbd>, and <kbd>*.bak</kbd> are commonly ignored. If you are working on a Java project, you might add <kbd>*.class</kbd>, <kbd>*.jar</kbd>, and <kbd>*.war</kbd> to your <kbd>.gitignore</kbd> and <kbd>*.o</kbd>, <kbd>*.elf</kbd>, and <kbd>*.lib</kbd> if you are working on a C project. GitHub has a repository dedicated to collect Git ignore files for different programming languages and editors/IDEs. You can find it at: <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Showing and cleaning ignored files</h1>
                
            
            
                
<p>Ignoring files is useful for filtering noise from the output of <kbd>git status</kbd>. But sometimes, it's necessary to check which files are ignored. This example will show you how to do that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll continue in the repository from the last example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To show the files we have ignored, we can use the <kbd>clean</kbd> command. Normally, the <kbd>clean</kbd> command will remove the untracked files from the working directory, but it is possible to run this in dry-run mode, <kbd>-n</kbd>, which just shows what would happen:</p>
<pre><strong>$ git clean -Xnd</strong>
<strong>Would remove bin/foobar</strong>
<strong>Would remove test.test</strong>
<strong>Would remove test.txt.bak</strong></pre>
<p>The options used in the preceding command specify the following:</p>
<ul>
<li><kbd>-n</kbd>, <kbd>--dry-run</kbd>: Only lists what will be removed</li>
<li><kbd>-X</kbd>: Removes only the files ignored by Git</li>
<li><kbd>-d</kbd>: Removes the untracked directories in addition to the untracked files</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The ignored files can also be listed with the <kbd>ls-files</kbd> command:</p>
<pre><strong>$ git ls-files -o -i --exclude-standard</strong>
<strong>bin/foobar</strong>
<strong>test.test</strong>
<strong>test.txt.bak</strong></pre>
<p>Where the <kbd>-o</kbd> option, <kbd>--others</kbd>, shows the untracked files, the <kbd>-i</kbd> option, <kbd>--ignored</kbd>, shows only the ignored files, and <kbd>--exclude-standard</kbd> uses the standard exclusion files <kbd>.git/info/exclude</kbd> and <kbd>.gitignore</kbd> in each directory, and the user's global exclusion file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If we need to remove the ignored files, we can of course use <kbd>git clean</kbd> to do this; instead of the dry-run option, we pass the force option, <kbd>-f</kbd>:</p>
<pre><strong>$ git clean -Xfd</strong>
<strong>Removing bin/foobar</strong>
<strong>Removing test.test</strong>
<strong>Removing test.txt.bak</strong></pre>
<p>To remove all the untracked files and not just the ignored files, use <kbd>git clean -xfd</kbd>. The lowercase <kbd>x</kbd> means we don't use the ignore rules, we just remove everything that is not tracked by Git.</p>


            

            
        
    </body></html>