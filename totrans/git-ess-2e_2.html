<html><head></head><body>
        

                            
                    <h1 class="header-title">Git Fundamentals - Working Locally</h1>
                
            
            
                
<p>In this chapter, we will dive deep into some of the fundamentals of Git; it is essential to understand well how Git thinks about files, its way of tracking the history of commits, and all the basic commands that we need to master, in order to become proficient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Digging into Git internals</h1>
                
            
            
                
<p>In this second edition of <em>Git Essentials</em>, I slightly changed my approach in explaining how Git works; instead of explaining with words and figures, this time I want to show you how Git works internally with only the help of the shell, allowing you to follow all the steps on your computer and hoping that these will be clear enough for you to understand.</p>
<p>Once you know the fundamentals of the Git working system, I think the rest of the commands and patterns will be clearer, allowing you to accomplish proficiently your daily work, getting out of trouble when needed.</p>
<p>So, it's time to start digging inside the true nature of Git; in this chapter, we will get in touch with the essence of this powerful tool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git objects</h1>
                
            
            
                
<p>In <a href="831d785f-1ea2-4ea1-b175-21a22d9fb26a.xhtml">Chapter 1</a>, <em>Getting Started with Git</em>, we created an empty folder (in <kbd>C:\Repos\MyFirstRepo</kbd>) and then we initialized a new Git repository, using the <kbd>git init</kbd> command.</p>
<p>Let's create a new repository to refresh our memory and then start learning a little bit more about Git.</p>
<p>In this example, we use Git to track our shopping list before going to the grocery; so, create a new grocery folder, and then initialize a new Git repository:</p>
<pre><strong>[1] ~</strong>
<strong>$ mkdir grocery</strong>

<strong>[2] ~</strong>
<strong>$ cd grocery/</strong>

<strong>[3] ~/grocery</strong>
<strong>$ git init</strong>
<strong>Initialized empty Git repository in C:/Users/san/Google Drive/Packt/PortableGit/home/grocery/.git/</strong></pre>
<p>As we have already seen before, the result of the <kbd>git init</kbd> command is the creation of a <kbd>.git</kbd> folder, where Git stores all the files it needs to manage our repository:</p>
<pre><strong>[4] ~/grocery (master)</strong>
<strong>$ ll</strong>
<strong>total 8</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 17 11:11 ./</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 17 11:11 ../</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 17 11:11 .git/</strong> </pre>
<p>So, we can move this <kbd>grocery</kbd> folder wherever we want, and no data will be lost. Another important thing to highlight is that we don't need any server: we can create a repository locally and work with it whenever we want, even with no LAN or internet connection. We only need them if we want to share our repository with someone else, directly or using a central server.<br/>
In fact, during this example, we won't use any remote server, as it is not necessary.</p>
<p>Go on and create a new <kbd>README.md</kbd> file to remember the purpose of this repository:</p>
<pre><strong>[5] ~/grocery (master)</strong>
<strong>$ echo "My shopping list repository" &gt; README.md</strong></pre>
<p>Then add a banana to the shopping list:</p>
<pre><strong>[6] ~/grocery (master)</strong>
<strong>$ echo "banana" &gt; shoppingList.txt</strong></pre>
<p>At this point, as you already know, before doing a commit, we have to add files to the <em>staging area</em>; add both the files using the shortcut <kbd>git add .</kbd>:</p>
<pre><strong>[7] ~/grocery (master)</strong>
<strong>$ git add .</strong></pre>
<p>With this trick (the dot after the <kbd>git add</kbd> command), you can add all the new or modified files in one shot.</p>
<p>At this point, if you didn't set up a global username and email like we did in <a href="831d785f-1ea2-4ea1-b175-21a22d9fb26a.xhtml">Chapter 1</a>, <em>Getting Started with Git</em>, this is a thing that could happen:</p>
<pre class="mce-root"><strong>[8] ~/grocery (master)</strong><br/><strong>$ git commit -m "Add a banana to the shopping list"</strong><br/><strong>[master (root-commit) c7a0883] Add a banana to the shopping list</strong><br/><strong>Committer: Santacroce Ferdinando &lt;san@intre.it&gt;<br/></strong><br/><strong>Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate.<br/></strong><br/><strong>You can suppress this message by setting them explicitly:</strong><br/><strong>git config --global user.name "Your Name"</strong><br/><strong>git config --global user.email you@example.com</strong><br/><strong>After doing this, you may fix the identity used for this commit with:</strong><br/><strong>git commit --amend --reset-author</strong><br/><br/><strong> 2 files changed, 2 insertions(+)</strong><br/><strong> create mode 100644 README.md</strong><br/><strong> create mode 100644 shoppingList.txt</strong></pre>
<p>First of all, take a look at the second line, where Git says something like <strong><kbd>root commit</kbd></strong>; this means this is <strong>the first commit</strong> of your repository, and this is like a root in a tree (or a root on a disk partition; maybe you nerds will understand this better). Later we will come back to this concept.</p>
<p>Then, Git shows a message that says: "<em>You didn't set a global username and email; I used ones I found configured in your system, but if you don't like it, you can go back and remake your commit with another pair of data</em>".</p>
<p>I prefer not to set up a global username and password in Git, as I usually work on different repositories using different usernames and emails; if I don't pay attention, I end up doing a job commit with my hobby profile or vice versa, and this is annoying. So, I prefer setting up usernames and emails per repository; in Git, you can set up your config variables at three levels: <em>repository</em> (with the <kbd>--local</kbd> option, the default one), <em>user</em> (with the <kbd>--global</kbd> option), and <em>system-wide</em> (with the <kbd>--system</kbd> option). Later we will learn something more about configuration, but this is what you need for now to go on with.</p>
<p>So, let's change these settings and <em>amend</em> our commit (amending a commit is a way to redo the last commit and fix up some little mistakes, such as adding a forgotten file, changing the message or the author, as we are going to do; later we will learn in detail what this means):</p>
<pre><strong>[9] ~/grocery (master)</strong>
<strong>$ git config user.name "Ferdinando Santacroce"</strong>

<strong>[10] ~/grocery (master)</strong>
<strong>$ git config user.email ferdinando.santacroce@gmail.com</strong></pre>
<p>As I didn't specify the config level, these parameters will be set at <em>repository level</em> (the same as <kbd>--local</kbd>); from now on, all the commits I will do in this repository will be signed by <kbd>"Ferdinando Santacroce"</kbd>, with the <kbd>ferdinando.santacroce@gmail.com</kbd> email (now you know how to get in touch with me, just in case).</p>
<p>Now it's time to type this command, <kbd>git commit --amend --reset-author</kbd>. When amending a commit this way, Git opens the default editor to let you change even the commit message, if you like; as we have seen in <a href="831d785f-1ea2-4ea1-b175-21a22d9fb26a.xhtml">Chapter 1</a>, <em>Getting Started with Git</em>, in Windows the default editor is <em>Vim</em>. For the purpose of this exercise, please leave the message as it is, press <em>Esc</em>, and then input the <kbd>:wq</kbd> (or <kbd>:x</kbd>) command and press <em>Enter</em> to save and exit:</p>
<pre><strong>[11] ~/grocery (master)</strong>
<strong>$ git commit --amend --reset-author #here Vim opens</strong>
<strong>[master a57d783] Add a banana to the shopping list</strong>
<strong> 2 files changed, 2 insertions(+)</strong>
<strong> create mode 100644 README.md</strong>
<strong> create mode 100644 shoppingList.txt</strong></pre>
<p>Okay, now I have a commit with the right author and email.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Commits</h1>
                
            
            
                
<p>Now it's time to start investigating commits.</p>
<p>To verify the commit we have just created, we can use the <kbd>git log</kbd> command:</p>
<pre><strong>[12] ~/grocery (master)</strong>
<strong>$ git log</strong>
<strong>commit a57d783905e6a35032d9b0583f052fb42d5a1308</strong>
<strong>Author: Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt;</strong>
<strong>Date:   Thu Aug 17 13:51:33 2017 +0200</strong>

<strong>Add a banana to the shopping list</strong></pre>
<p>As you can see, <kbd>git log</kbd> shows the commit we did in this repository; <kbd>git log</kbd> shows all the commits, in reverse chronological order; we have only a commit for now, but next we will see this behavior in action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The hash</h1>
                
            
            
                
<p>It is now time to analyze the information provided. The first line contains the commit's <strong>SHA-1</strong> (<a href="https://en.wikipedia.org/wiki/SHA-1">https://en.wikipedia.org/wiki/SHA-1</a>), an alphanumeric sequence of 40 characters representing a hexadecimal number. This <em>code</em>, or <strong>hash</strong>, as it is usually called, uniquely identifies the commit within the repository, and it's thanks to it that from now on we can refer to it doing some actions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The author and the commit creation date</h1>
                
            
            
                
<p>We already talked about authors just a couple of paragraphs before; the <strong>author</strong> is who performed the commit, and the <strong>date</strong> is the full date when the commit was generated. Since that instance, this commit is part of the repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The commit message</h1>
                
            
            
                
<p>Just under the author and date, after a blank line, we can see the message we attached to the commit we made; even the message is part of the commit itself.</p>
<p>But there's something more under the hood; let's try to use the <kbd>git log</kbd> command with the <kbd>--format=fuller</kbd> option:</p>
<pre><strong>[13] ~/grocery (master)</strong>
<strong>$ git log --format=fuller</strong>
<strong>commit a57d783905e6a35032d9b0583f052fb42d5a1308</strong>
<strong>Author: Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt;</strong>
<strong>AuthorDate: Thu Aug 17 13:51:33 2017 +0200</strong>
<strong>Commit: Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt;</strong>
<strong>CommitDate: Thu Aug 17 13:51:33 2017 +0200</strong>

<strong>Add a banana to the shopping list</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The committer and the committing date</h1>
                
            
            
                
<p>Other than the author, a commit preserves even the <strong>committer</strong>, and the <strong>committing date</strong>; what's the difference compared to author and author date? First of all, don't worry too much about this: 99% of commits in your repository will have the same values for the author and committer, and the same dates.</p>
<p>In some situations, such as the <em>cherry-pick</em>, you carry an existing commit on top of another branch, making a brand-new commit that applies the same changes of the previous. In this case, the author and author date will remain the same, while the committer and the committing date will be related to the person who performed this operation and the date they did it. Later we will get in touch with this useful Git command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Going deeper</h1>
                
            
            
                
<p>We analyzed a commit, and the information supplied by a simple <kbd>git log</kbd>; but we are not yet satisfied, so go deeper and see what's inside.</p>
<p>Using the <kbd>git log</kbd> command again, we can enable x-ray vision using the <kbd>--format=raw</kbd> option:</p>
<pre><strong>[14] ~/grocery (master)</strong>
<strong>$ git log --format=raw</strong>
<strong>commit a57d783905e6a35032d9b0583f052fb42d5a1308</strong>
<strong>tree a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong>

<strong>Add a banana to the shopping list</strong></pre>
<p>This time the output format is different; we can see the author and committer, as we saw before, but in a more compact form; then there is the commit message, but something new appears: it's a <em>tree</em>. Please be patient, we will talk about trees in a couple of paragraphs.</p>
<p>What I want to show now is another command, this time a little bit more obscure; it's <kbd>git cat-file -p</kbd>.</p>
<p>Let's try this command. To make it work, we need to specify the <strong>object</strong> we want to investigate; we can use the hash of the object, our first commit in this case. You don't need to specify the entire hash, but the first five-six characters are enough for small repositories. Git is smart enough to understand what's the object even with less than the 40 characters; the minimum is four characters, and the number increases as the total amount of Git objects in the repository increases. Just to give you an idea, the Linux kernel is currently 15 million lines of code, with millions of tracked files and folders; in that Git repository[1], you need to specify 12 characters to get the right object.</p>
<p>When in need, I usually try typing only the first five characters; if they are not sufficient to make Git aware of the object I need, it will warn me to input a character or two more.</p>
<p>Back on topic; type the command, specifying the first characters of the commit's hash (<kbd>a57d7</kbd> in my case):</p>
<pre><strong>[15] ~/grocery (master)</strong>
<strong>$ git cat-file -p a57d7</strong>
<strong>tree a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong>

<strong>Add a banana to the shopping list</strong></pre>
<p>Okay, as you can see, the output is the same of <kbd>git log --format=raw</kbd>.</p>
<p>This is not unusual in Git: there are different commands and options that end up doing the same thing; this is a common <em>feature</em> of Git, and it's due to its organic growth across the years. Git changed (and changes) continuously, so the developers have to guarantee some backward compatibility when introducing new commands; this is one of the side effects.</p>
<p>I introduced this command only to have the chance of introducing another peculiarity of Git, the separation between <em>porcelain commands</em> and <em>plumbing commands</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Porcelain commands and plumbing commands</h1>
                
            
            
                
<p>Git, as we know, has a myriad of commands, some of which are practically never used by the average user; as by example, the previous <kbd>git cat-file</kbd>. These commands are called <strong>plumbing commands</strong>, while those we have already learned about, such as <kbd>git add</kbd>, <kbd>git commit</kbd>, and so on, are among the so-called <strong>porcelain commands</strong>.</p>
<p>The metaphor originates directly from the fervent imagination of Linus Torvalds, the dad of Git, and has to do with plumbers. They, as is well known, also take care of the maintenance of the toilets; here Linus refers to the toilet bowl. The bowl is a porcelain artifact, which makes us sit comfortably; using then a series of pipes and devices, it allows us a correct discharge of what you know down into the sewerage system.</p>
<p>Linus has used this refined metaphor to divide the Git commands into two families, the highest-level ones, comfortable for a user interested in the most common operations (<em>porcelain</em>) and those used internally by the same (but usable at the discretion of the more experienced users) to perform lower-level operations (<em>plumbing</em>).</p>
<p>We can, therefore, consider porcelain commands as <em>interface</em> commands to the user, while the plumbing works at a <em>low level</em>. This also means that porcelain commands stay more <em>stable</em> over time (usage patterns and options vary with more caution and delayed time), as they are used directly, but are also implemented in numerous graphic tools, editors, and so on, while plumbing generally evolves with less restrictions.</p>
<p>There is no precise subdivision between these two categories of commands, as the border is often quite lively; we will still use them, in order to better understand the internal functioning of Git.</p>
<p>Let's go back to the topic now; we were talking about Git objects.</p>
<p>Git uses four different types of <strong>objects</strong>, and <em>commit</em> is one of these. Then there are <em>tree</em>, <em>blob</em>, and <em>annotated tag</em>. Let's leave the annotated tags aside for a moment (whoever already uses a versioning system knows what tags are) and focus on blobs and trees.</p>
<p>Here, for convenience, there is the output of the <kbd>git cat-file -p</kbd> command typed before:</p>
<pre><strong>[15] ~/grocery (master)</strong>
<strong>$ git cat-file -p a57d7</strong>
<strong>tree a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong></pre>
<p>As we can understand now, this plumbing command lets you peek into the Git objects; with the <kbd>-p</kbd> option (which means <em>pretty-print</em> here), we ask Git to show an easier way to read what the contents of the object are.</p>
<p>At this point, it's time to learn what a tree is in Git; in fact, in the command output, we can see this line: <kbd>tree a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40</kbd>.</p>
<p>What does it mean? Let's see it together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trees</h1>
                
            
            
                
<p>The <strong>tree</strong> is a <strong>container</strong> for blobs and other trees. The easiest way to understand how it works is to think about folders in your operating system, which also collect files and other subfolders inside them.</p>
<p>Let's try to see what this additional Git object holds, using again the <kbd>git cat-file -p</kbd> command:</p>
<pre><strong>[16] ~/grocery (master)</strong>
<strong>$ git cat-file -p a31c3</strong>
<strong>100644 blob 907b75b54b7c70713a79cc6b7b172fb131d3027d README.md</strong>
<strong>100644 blob 637a09b86af61897fb72f26bfb874f2ae726db82 shoppingList.txt</strong></pre>
<p>This tree, which we said is something that Git uses to identify a folder, also contains some additional objects, called <strong>blobs.</strong></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blobs</h1>
                
            
            
                
<p>As you can see, at the right of the previous command output, we have <kbd>README.md</kbd> and <kbd>shoppinglist.txt</kbd>, which makes us guess that Git blobs represent the <strong>files</strong>. As before, we can verify its contents; let's see what's inside <kbd>637a0</kbd>:</p>
<pre><strong>[17] ~/grocery (master)</strong>
<strong>$ git cat-file -p 637a0</strong>
<strong>banana</strong></pre>
<p>Wow! Its content is exactly the content of our <kbd>shoppingFile.txt</kbd> file.</p>
<p>To confirm, we can use the <kbd>cat</kbd> command, which on <kbd>*nix</kbd> systems allows you to see the contents of a file:</p>
<pre><strong>[18] ~/grocery (master)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong></pre>
<p>As you can see, the result is the same.</p>
<p>Blobs are binary files, nothing more and nothing less. These byte sequences, which cannot be interpreted with the naked eye, retain inside information belonging to any file, whether binary or textual, images, source code, archives, and so on. Everything is compressed and transformed into a blob before archiving it into a Git repository.</p>
<p>As already mentioned previously, each file is marked with a <em>hash</em>; this hash uniquely identifies the file within our repository, and it is thanks to this ID that Git can then retrieve it when needed, and detect any changes when the same file is altered (files with different content will have different hashes).</p>
<p>We said SHA-1 hashes are unique; but what does it mean?</p>
<p>Let's try to understand it better with an example.</p>
<p>Open a shell and try to play a bit with another plumbing command, <kbd>git hash-object</kbd>:</p>
<pre><strong>[19] ~/grocery (master)</strong>
<strong>$ echo "banana" | git hash-object --stdin</strong>
<strong>637a09b86af61897fb72f26bfb874f2ae726db82</strong></pre>
<p>The <kbd>git hash-object</kbd> command is the plumbing command to calculate the hash of any object; in this example, we used the <kbd>--stdin</kbd> option to pass as a command argument the result of the preceding command, <kbd>echo "banana";</kbd> in a few words, we calculated the hash of the string <kbd>"banana"</kbd>, and it came out <kbd>637a09b86af61897fb72f26bfb874f2ae726db82</kbd>.</p>
<p>And on your computer, did you try it? What is the result?</p>
<p>A bit of suspense... That's incredible, it's the same!</p>
<p>You can try to rerun the command as many times as you want, the resulting hash will always be the same (if not, it can be due to different line endings in your operating system or shell).</p>
<p>This makes us understand something very important: <strong>an object</strong>, whatever it is, <strong>will always have the same hash in any repository</strong>, in any computer, on the face of the Earth.</p>
<p>The experienced and the smart ones probably had "<em>smelt a rat</em>" for some time now, but I hope that in the rest of the readers I have pulled up the same amazement that caught me when I did this for the first time. This behavior has some interesting implications, as we will see soon.</p>
<p>Last, but not least, I want to highlight how <strong>Git calculates the hash on the content of the file, not in the file itself</strong>; in fact, the <kbd>637a09b86af61897fb72f26bfb874f2ae726db82</kbd> hash calculated using <kbd>git hash-object</kbd> is the same as the blob we inspect previously using <kbd>git cat-file -p</kbd>. This teaches us an important lesson: if you have two different files with the same content, even if they have different names and paths, in Git you will end up having only one blob.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Even deeper - the Git storage object model</h1>
                
            
            
                
<p>Okay, now we know there are different Git objects, and we can inspect inside them using some plumbing commands. But how and where does Git store them?</p>
<p>Do you remember the <kbd>.git</kbd> folder? Let's put our nose inside it:</p>
<pre><strong>[20] ~/grocery (master)</strong>
<strong>$ ll .git/</strong>
<strong>total 13</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:22 ./</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 ../</strong>
<strong>-rw-r--r-- 1 san 1049089 294 Aug 17 13:52 COMMIT_EDITMSG</strong>
<strong>-rw-r--r-- 1 san 1049089 208 Aug 17 13:51 config</strong>
<strong>-rw-r--r-- 1 san 1049089  73 Aug 17 11:11 description</strong>
<strong>-rw-r--r-- 1 san 1049089  23 Aug 17 11:11 HEAD</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 hooks/</strong>
<strong>-rw-r--r-- 1 san 1049089 217 Aug 18 17:22 index</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 info/</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 logs/</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 objects/</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 refs/</strong></pre>
<p>Within it, there is an <kbd>objects</kbd> subfolder; let's take a look:</p>
<pre><strong>[21] ~/grocery (master) </strong>
<strong>$ ll .git/objects/</strong>
<strong>total 4</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 ./</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:22 ../</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 63/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 90/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 a3/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 a5/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 c7/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 17 11:11 info/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:12 pack/</strong></pre>
<p>Other than <kbd>info</kbd> and <kbd>pack</kbd> folders, which are not interesting for us right now, as you can see there are some other folders with a strange two-character name; let's go inside the <kbd>63</kbd> folder:</p>
<pre><strong>[22] ~/grocery (master)</strong> <br/><strong>$ ll .git/objects/63/<br/>total 1<br/>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 ./<br/>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 ../<br/>-r--r--r-- 1 san 1049089 20 Aug 17 13:34 7a09b86af61897fb72f26bfb874f2ae726db82</strong></pre>
<p>Hmmm...</p>
<p>Look at the file within it, and think: <kbd>63</kbd> + <kbd>7a09b86af61897fb72f26bfb874f2ae726db82</kbd> is actually the hash of our <kbd>shoppingList.txt</kbd> blob!</p>
<p>Git is amazingly smart and simple: to be quicker while searching through the filesystem, Git creates a set of folders where the name is two characters long, and those two characters represent the first two characters of a hash code; inside those folders, Git writes all the objects using as a name the other 38 characters of the hash, regardless of the kind of Git object.</p>
<p>So, the <kbd>a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40</kbd> tree is stored in the <kbd>a3</kbd> folder, and the <kbd>a57d783905e6a35032d9b0583f052fb42d5a1308</kbd> commit in the <kbd>a5</kbd> one.</p>
<p>Isn't that the most clever and simple thing you have ever seen?</p>
<p>Now, if you try to inspect those files with a common <kbd>cat</kbd> command, you will be deluded: those files are plain text files, but Git compresses them using the <kbd>zlib</kbd> library to reserve space on your disk. This is why we use the <kbd>git cat-file -p</kbd> command, which decompresses them on the fly for us.</p>
<p>This highlights once again the simplicity of Git: no metadata, no internal databases, or useless complexity, but simple files and folders are enough to make it possible to manage any repository.</p>
<p>At this point, we know how Git stores objects, and where they are archived; we also know that there is no database, no central repository or stuff like that, so how is Git able to reconstruct the history of our repository? How can it define which commit precedes or follows another one?</p>
<p>To become aware of this, we need a new commit. So, let's now proceed modifying the <kbd>shoppingList.txt</kbd> file:</p>
<pre><strong>[23] ~/grocery (master)</strong>
<strong>$ echo "apple" &gt;&gt; shoppingList.txt</strong>

<strong>[24] ~/grocery (master)</strong>
<strong>$ git add shoppingList.txt</strong>

<strong>[25] ~/grocery (master)</strong>
<strong>$ git commit -m "Add an apple"</strong>
<strong>[master e4a5e7b] Add an apple</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Use the <kbd>git log</kbd> command to check the new commit; the <kbd>--oneline</kbd> option allows us to see the log in a more compact way:</p>
<pre><strong>[26] ~/grocery (master)</strong>
<strong>$ git log --oneline</strong>
<strong>e4a5e7b Add an apple</strong>
<strong>a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, we have a new commit, with its hash. Time to see what's inside it:</p>
<pre><strong>[27] ~/grocery (master)</strong>
<strong>$ git cat-file -p e4a5e7b</strong>
<strong>tree 4c931e9fd8ca4581ddd5de9efd45daf0e5c300a0</strong>
<strong>parent a57d783905e6a35032d9b0583f052fb42d5a1308</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1503586854 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1503586854 +0200</strong>

<strong>Add an apple</strong></pre>
<p>There's something new!</p>
<p>I'm talking about the <kbd>parent a57d783905e6a35032d9b0583f052fb42d5a1308</kbd> row; did you see? A <strong>parent</strong> of a commit is simply the commit that precedes it. In fact, the <kbd>a57d783</kbd> hash is actually the hash of the first commit we made. So, every commit has a parent, and following these relations between commits, we can always navigate from a random one down to the first one, the already mentioned <strong>root commit</strong>.</p>
<p>If you remember, the first commit did not have a parent, and this is the main (and only) difference between all commits and the first one. Git, while navigating and reconstructing our repository, simply knows it is done when it finds a commit without a parent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git doesn't use deltas</h1>
                
            
            
                
<p>Now it's time to investigate another well-known difference between Git and other versioning systems. Take Subversion as an example: when you do a new commit, Subversion creates a new numbered revision that only contains deltas between the previous one; this is a smart way to archive changes to files, especially among big text files, because if only a line of text changes, the size of the new commit will be much smaller.</p>
<p>Instead, in Git even if you change only a char in a big text file, it always stores a new version of the file: <strong>Git doesn't do deltas</strong> (at least not in this case), and <strong>every commit is actually a snapshot of the entire repository</strong>.</p>
<p>At this point, people usually exclaim: <q>"Gosh, Git waste a large amount of disk space in vain!"</q>. Well, this is simply untrue.</p>
<p>In a common source code repository, with a certain amount of commit, Git usually won't need more space than other versioning systems. As an example, when Mozilla went from Subversion to Git, the exact same repository went from 12GB to 420MB disk space required; look at this comparison page to learn more: <a href="https://git.wiki.kernel.org/index.php/GitSvnComparsion">https://git.wiki.kernel.org/index.php/GitSvnComparsion</a></p>
<p>Furthermore, Git has a clever way to deal with files; let's take a look again at the last commit:</p>
<pre><strong>[28] ~/grocery (master)</strong>
<strong>$ git cat-file -p e4a5e7b</strong>
<strong>tree 4c931e9fd8ca4581ddd5de9efd45daf0e5c300a0</strong>
<strong>parent a57d783905e6a35032d9b0583f052fb42d5a1308</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1503586854 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1503586854 +0200</strong>

<strong>Add an apple</strong></pre>
<p>Okay, now to the tree:</p>
<pre><strong>[29] ~/grocery (master)</strong>
<strong>$ git cat-file -p 4c931e9</strong>
<strong>100644 blob 907b75b54b7c70713a79cc6b7b172fb131d3027d README.md</strong>
<strong>100644 blob e4ceb844d94edba245ba12246d3eb6d9d3aba504 shoppingList.txt</strong></pre>
<p>Annotate the two hashes on a notepad; now we have to look at the tree of the first commit; cat-file the commit:</p>
<pre><strong>[30] ~/grocery (master)</strong>
<strong>$ git cat-file -p a57d783</strong>
<strong>tree a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1502970693 +0200<br/>Add a banana to the shopping list<br/></strong></pre>
<p>Then cat-file the tree:</p>
<pre><strong>[31] ~/grocery (master)</strong>
<strong>$ git cat-file -p a31c31c</strong>
<strong>100644 blob 907b75b54b7c70713a79cc6b7b172fb131d3027d README.md</strong>
<strong>100644 blob 637a09b86af61897fb72f26bfb874f2ae726db82 shoppingList.txt</strong></pre>
<p>Guess what! The hash of the <kbd>README.md</kbd> file is the same in the two trees of the first and second commit; this allows us to understand another simple but clever strategy that Git adopts to manage files; when a file is untouched, while committing Git creates a tree where the blob for the file points to the already existing one, <em>recycling</em> it and avoiding waste of disk space.</p>
<p>The same applies to the trees: if my working directory has some folders and files within them that will remain untouched, when we do a new commit Git recycles the same trees.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Wrapping up</h1>
                
            
            
                
<p>It's time to summarize all the concepts illustrated since now.</p>
<p>An image, as they say, is worth a thousand words, so here you can find a picture representing the actual state of our repository, thanks to the <strong>git-draw</strong> tool (<a href="https://github.com/sensorflo/git-draw">https://github.com/sensorflo/git-draw</a>):</p>
<div><img src="img/2108beaa-0538-4922-b88f-f3efa0370e76.png"/></div>
<p>In this graphic representation, you will find a detailed diagram that represents the current structure of the newly created repository; you can see trees (yellow), blobs (white), commits (green), and all relationships between them, represented by oriented arrows.</p>
<p>Note how the direction of the arrow joining the commit comes from the second commit and goes to the first, or from descendant to its ancestor; it may seem a detail, but it is important that graphic representations such as these are properly indicated in order to correctly highlight the relationship that binds the commits between them (it is always the child who depends on the parent).</p>
<p>I just want to highlight some other things; such as:</p>
<ul>
<li>The two different trees refer to the same <kbd>README.md</kbd> blob</li>
<li>There are two different blobs for the <kbd>shoppingList.txt</kbd> files, one containing only the <kbd>banana</kbd> text line and one containing <kbd>banana</kbd> and <kbd>apple</kbd></li>
<li>The second commit refers to the first</li>
<li>The first commit has no parent</li>
<li>There are three commits!</li>
</ul>
<p>What the heck?!</p>
<p>Okay, don't panic. Look at the commit at the right of the picture, and read author and email: that was the first commit we did using the <em>wrong</em> user and email; after that, we amended the commit, changing the author, remember?</p>
<p>Well, but why is it already there? And why do we see it in this picture, but we don't see it in <kbd>git log</kbd>?</p>
<p>It's about <strong>reachability</strong> of the commit, a topic that we will talk about in the following sections.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git references</h1>
                
            
            
                
<p>In the previous section, we have seen that a Git repository can be imagined as a tree that, starting from a root (the root-commit), grows upward through one or more branches.</p>
<p>These branches are generally distinguished by a name. In this Git is no exception; if you remember, the experiments conducted so far led us to commit to the <kbd>master</kbd> branch of our test repository. <em>Master</em> is precisely the name of the <em>default branch</em> of a Git repository, somewhat like <kbd>trunk</kbd> is for Subversion.</p>
<p>But Subversion analogies end here: we will now see how Git handles branches, and for Subversion users it will be a little surprising.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">It's all about labels</h1>
                
            
            
                
<p>In Git, <strong>a branch is nothing more than a label</strong>, a <em>mobile label</em> placed on a commit.</p>
<p>In fact, every leaf on a Git branch has to be labeled with a meaningful name to allow us to reach it and then move around, go back, merge, rebase, or discard some commits when needed.</p>
<p>Let's start exploring this topic by checking the current status of our <kbd>grocery</kbd> repository; we do it using the well-known <kbd>git log</kbd> command, this time adding some new options:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate</strong>
<strong>* e4a5e7b (HEAD -&gt; master) Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Let's look at those options in detail:</p>
<ul>
<li><kbd>--graph</kbd>: In this case it just adds an asterisk to the left, before the commit hash, but when you have more branches, this option will draw them for us giving a simple but effective graphical representation of the repository</li>
<li><kbd>--decorate</kbd>: This option prints out the labels attached to any commits that are shown; in this case, it prints <kbd>(HEAD -&gt;</kbd><kbd>master)</kbd> on the <kbd>e4a5e7b</kbd> commit</li>
<li><kbd>--oneline</kbd>: This is easy to understand: it reports every commit using one line, shortening things when necessary</li>
</ul>
<p>We'll now do a new commit and see what happens:</p>
<pre><strong>[2] ~/grocery (master)</strong>
<strong>$ echo "orange" &gt;&gt; shoppingList.txt</strong>

<strong>[3] ~/grocery (master)</strong>
<strong>$ git commit -am "Add an orange"</strong>
<strong>[master 0e8b5cf] Add an orange</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Have you noticed? After adding an orange to the <kbd>shopingList.txt</kbd>, I made a commit without first making <kbd>git add</kbd>; the <em>trick</em> is in the <kbd>-a</kbd> (<kbd>--add</kbd>) option added to the <kbd>git commit</kbd> command, which means <em>add to this commit all the modified files that I have already committed at least one time before</em>. In our case, this option allowed us to go faster and skip the <kbd>git add</kbd> command.</p>
<p>Anyway, use it carefully, especially while learning and using Git at the beginning: you easily end up doing commit with more files than you want.</p>
<p>Okay, go on now and take a look at the current repository situation:</p>
<pre><strong>[4] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate</strong>
<strong>* 0e8b5cf (HEAD -&gt; master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Interesting! Both <kbd>HEAD</kbd> and <kbd>master</kbd> have now moved on the last commit, the third one; what does it mean?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Branches are movable labels</h1>
                
            
            
                
<p>We have seen in the previous sections how the commits are linked to each other by a parent-and-son relationship: each commit contains a reference to the previous commit.</p>
<p>This means that, for example, to <em>navigate</em> within a repository I cannot start from the first commit and try to go to the next, because a commit has no reference to who comes next, but to who comes first. By staying in our <em>arboreal</em> metaphor, this means that our tree is only navigable from <em>leaves</em>, from the extreme <em>top</em> of a branch, and then down to root-commit.</p>
<p>So, branches are nothing but labels that are on the tip commit, the last one. This commit, our leaf, must always be identified by a label so that its ancestors commits can be reached while browsing within a repository. Otherwise, we should remember for every branch of our repository the hash code of the tip commit, and you can imagine how easy it would be for humans.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How references work</h1>
                
            
            
                
<p>So, every time we make a commit to a branch, the <strong>reference</strong> that identifies that branch will move accordingly to always stay associated with the tip commit.</p>
<p>But how will Git handle this feature? Let's go back to putting the nose again in the <kbd>.git</kbd> folder:</p>
<pre><strong>[5] ~/grocery (master)</strong>
<strong>$ ll .git/</strong>
<strong>total 21</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 25 11:20 ./</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 25 11:19 ../</strong>
<strong>-rw-r--r-- 1 san 1049089  14 Aug 25 11:20 COMMIT_EDITMSG</strong>
<strong>-rw-r--r-- 1 san 1049089 208 Aug 17 13:51 config</strong>
<strong>-rw-r--r-- 1 san 1049089  73 Aug 17 11:11 description</strong>
<strong>-rw-r--r-- 1 san 1049089  23 Aug 17 11:11 HEAD</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 hooks/</strong>
<strong>-rw-r--r-- 1 san 1049089 217 Aug 25 11:20 index</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 info/</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 logs/</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 25 11:20 objects/</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 18 17:15 refs/</strong></pre>
<p>There's a <kbd>refs</kbd> folder: let's take a look inside:</p>
<pre><strong>[6] ~/grocery (master)</strong>
<strong>$ ll .git/refs/</strong>
<strong>total 4</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 18 17:15 ./</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 25 11:20 ../</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 25 11:20 heads/</strong>
<strong>drwxr-xr-x 1 san 1049089 0 Aug 17 11:11 tags/</strong></pre>
<p>Now go to <kbd>heads</kbd>:</p>
<pre><strong>[7] ~/grocery (master)</strong>
<strong>$ ll .git/refs/heads/</strong>
<strong>total 1</strong>
<strong>drwxr-xr-x 1 san 1049089  0 Aug 25 11:20 ./</strong>
<strong>drwxr-xr-x 1 san 1049089  0 Aug 18 17:15 ../</strong>
<strong>-rw-r--r-- 1 san 1049089 41 Aug 25 11:20 master</strong></pre>
<p>There's a <kbd>master</kbd> file inside! Let's see what's the content:</p>
<pre><strong>[8] ~/grocery (master)</strong>
<strong>$ cat .git/refs/heads/master</strong>
<strong>0e8b5cf</strong><strong>1c1b44110dd36dea5ce0ae29ce22ad4b8</strong></pre>
<p>As you could imagine, Git manages all this articulated reference system... with a trivial text file! It contains the hash of the last commit made on the branch; in fact, if you look at the previous <kbd>git log</kbd> output, you can see the hash of the last commit is <kbd>0e8b5cf</kbd>.</p>
<p>Nowadays it has been time since the first time, but I continue to be amazed by how essential and effective the internal structure of Git is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new branch</h1>
                
            
            
                
<p>Now that we have warmed up, the fun begins. Let's see what happens when you ask Git to create a new branch. Since we are going to serve a delicious fruit salad, it's time to set a branch apart for a <em>berries-flavored</em> variant recipe:</p>
<pre><strong>[9] ~/grocery (master)</strong>
<strong>$ git branch berries</strong></pre>
<p>That's all! To create a new branch, all you need to do is call the <kbd>git branch</kbd> followed by the name of the branch you'd like to use. And this is super-fast; always working locally, Git does this kind of work in a blink of an eye.</p>
<p>To be true, there are some (complicated) rules to be respected and things to know about the possible name of a branch (all you need to know is here: <a href="https://git-scm.com/docs/git-check-ref-format">https://git-scm.com/docs/git-check-ref-format</a>), but for now it is not relevant.</p>
<p>So, <kbd>git log</kbd> again:</p>
<pre><strong>[10] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate</strong>
<strong>* 0e8b5cf (HEAD -&gt; master, berries) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Wonderful! Now Git tells us there's a new branch, <kbd>berries</kbd>, and it refers to the same commit as a <kbd>master</kbd> branch.</p>
<p>Anyway, at the moment we continue to be located in the <kbd>master</kbd> branch; in fact, as you can see in the shell output prompt, it continues to appear <kbd>(master)</kbd> between the round parenthesis:</p>
<pre><strong>[10] ~/grocery (master)</strong></pre>
<p>How can I switch branch? By using the <kbd>git checkout</kbd> command:</p>
<pre><strong>[11] ~/grocery (master)</strong>
<strong>$ git checkout berries</strong>
<strong>Switched to branch 'berries'</strong></pre>
<p>Do a <kbd>git log</kbd> to see:</p>
<pre><strong>[12] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate</strong>
<strong>* 0e8b5cf (HEAD -&gt; berries, master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Mmm, interesting! Now there's a <kbd>(berries)</kbd> sign into the shell prompt, and more, something happened to that <kbd>HEAD</kbd> thing: now the arrows points to <kbd>berries</kbd>, not more to <kbd>master</kbd>. What does it mean?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HEAD, or you are here</h1>
                
            
            
                
<p>During previous exercises we continued to see that <kbd>HEAD</kbd> thing while using <kbd>git log</kbd>, and now it's time to investigate a little bit.</p>
<p>First of all, what is <kbd>HEAD</kbd>? As branches are, <kbd>HEAD</kbd> is a <strong>reference</strong>. It represents a pointer to the place on where we are right now, nothing more, nothing less. In practice instead, it is just another plain text file:</p>
<pre><strong>[13] ~/grocery (berries)</strong>
<strong>$ cat .git/HEAD</strong>
<strong>ref: refs/heads/berries</strong></pre>
<p>The difference between the <kbd>HEAD</kbd> file and branches text file is that the <kbd>HEAD</kbd> file usually refers to a branch, and not directly to a commit as branches do. The <kbd>ref:</kbd> part is the convention Git uses internally to declare a pointer to another branch, while <kbd>refs/heads/berries</kbd> is of course the relative path to the <kbd>berries</kbd> branch text file.</p>
<p>So, having checked out the <kbd>berries</kbd> branch, in fact we moved that pointer from the <kbd>master</kbd> branch to the <kbd>berries</kbd> one; from now on, every commit we do will be part of the <kbd>berries</kbd> branch. Let's give it a try.</p>
<p>Add a blackberry to the shopping list:</p>
<pre><strong>[14] ~/grocery (berries)</strong>
<strong>$ echo "blackberry" &gt;&gt; shoppingList.txt</strong></pre>
<p>Then perform a commit:</p>
<pre><strong>[15] ~/grocery (berries)</strong>
<strong>$ git commit -am "Add a blackberry"</strong>
<strong>[berries ef6c382] Add a blackberry</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Take a look on what happened with the usual <kbd>git log</kbd> command:</p>
<pre><strong>[16] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate</strong>
<strong>* ef6c382 (HEAD -&gt; berries) Add a blackberry</strong>
<strong>* 0e8b5cf (master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Nice! Something happened here:</p>
<ul>
<li>The <kbd>berries</kbd> branch moved to the last commit we performed, confirming what we said before: a branch is just a label that follows you while doing new commits, getting stuck to the last one</li>
<li>The <kbd>HEAD</kbd> pointer moved too, following the branch it is actually pointing to, the <kbd>berries</kbd> one</li>
<li>The <kbd>master</kbd> branch remains where it was, stuck to the penultimate commit, the last one we did before switching to the <kbd>berries</kbd> branch</li>
</ul>
<p>Okay, so now our <kbd>shoppingList.txt</kbd> file appears to contain these text lines:</p>
<pre><strong>[17] ~/grocery (berries)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong>
<strong>blackberry</strong></pre>
<p>What happens if we move back to the <kbd>master</kbd> branch? Let's see.</p>
<p>Check out the master branch:</p>
<pre><strong>[18] ~/grocery (berries)</strong>
<strong>$ git checkout master</strong>
<strong>Switched to branch 'master'</strong></pre>
<p>Look at the <kbd>shoppingFile.txt</kbd> content:</p>
<pre><strong>[19] ~/grocery (master)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong></pre>
<p>We actually moved back to where we were before adding the blackberry; as it is being added in the <kbd>berries</kbd> branch, here in the <kbd>master</kbd> branch it does not exist: sounds good, doesn't it?</p>
<p>Even the <kbd>HEAD</kbd> file has been updated accordingly:</p>
<pre><strong>[20] ~/grocery (master)</strong>
<strong>$ cat .git/HEAD</strong>
<strong>ref: refs/heads/master</strong></pre>
<p>But at this point someone could raise their hand and say: <q>"That's weird! In Subversion, we usually have different folders for each different branch; here Git seems to always overwrite the content of the same folder, isn't it?"</q>.</p>
<p>Of course, it is. This is how Git works. When you switch a branch, Git goes to the commit the branch is pointing to, and following the parent relationship and analyzing trees and blobs, rebuilds the content on the <strong>working directory</strong> accordingly, getting hold of that files and folders (that is the same Subversion can do with the <em>switch branch</em> feature, actually).</p>
<p>This is a big difference between Git and Subversion (and other similar versioning systems); people used to Subversion often argue that in this manner you cannot easily compare branches file by file, or open in your favorite IDE two different <em>versions</em> of your in-development software. Yes, this is true, in Git you cannot do the same, but there are some tricks to work around this issue (if it is an issue for you).</p>
<p>Another important thing to say is that in Git you cannot check out only a folder of the repository, as you can do in Subversion; when you check out a branch, you get all its content.</p>
<p>Go back to the repository now; let's do the usual <kbd>git log</kbd>:</p>
<pre><strong>[21] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate</strong>
<strong>* 0e8b5cf (HEAD -&gt; master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Uh-oh: where is the <kbd>berries</kbd> branch? Don't worry: <kbd>git log</kbd> usually displays only the branch you are on, and the commit that belongs to it. To see all branches, you only need to add the <kbd>--all</kbd> option:</p>
<pre><strong>[22] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* ef6c382 (berries) Add a blackberry</strong>
<strong>* 0e8b5cf (HEAD -&gt; master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, let's see: we are on the <kbd>master</kbd> branch, as the shell prompts and as <kbd>HEAD</kbd> remembers us, with that arrow that points to <kbd>master</kbd>; then there is a <kbd>berries</kbd> branch, with a commit more than <kbd>master</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reachability and undoing commits</h1>
                
            
            
                
<p>Now let's imagine this scenario: we have a new commit on the <kbd>berries</kbd> branch, but we realized it is a wrong one, so we want the <kbd>berries</kbd> branch to go back where <kbd>master</kbd> is. We actually want to discard the last commit on the <kbd>berries</kbd> branch.</p>
<p>First, check out the <kbd>berries</kbd> branch:</p>
<pre><strong>[23] ~/grocery (master)</strong>
<strong>$ git checkout -</strong>
<strong>Switched to branch 'berries'</strong></pre>
<p>New trick: using the dash (<kbd>-</kbd>), you actually are saying to Git: "<em>Move me to the branch I was before switching</em>"; and Git obeys, moving us to the <kbd>berries</kbd> branch.</p>
<p>Now a new command, <kbd>git reset</kbd> (please don't care about the <kbd>--hard</kbd> option for now):</p>
<pre><strong>[24] ~/grocery (berries)</strong>
<strong>$ git reset --hard master</strong>
<strong>HEAD is now at 0e8b5cf Add an orange</strong></pre>
<p>In Git, this is simple as this. The <kbd>git reset</kbd> actually <strong>moves a branch from the current position to a new one</strong>; here we said Git to move the current <kbd>berries</kbd> branch to where <kbd>master</kbd> is, and the result is that now we have all the two branches pointing to the same commit:</p>
<pre><strong>[25] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 0e8b5cf (HEAD -&gt; berries, master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>You can double-check this looking at <kbd>refs</kbd> files; this is the <kbd>berries</kbd> one:</p>
<pre><strong>[26] ~/grocery (berries)</strong>
<strong>$ cat .git/refs/heads/berries</strong>
<strong>0e8b5cf1c1b44110dd36dea5ce0ae29ce22ad4b8</strong></pre>
<p>And this is the <kbd>master</kbd> one:</p>
<pre><strong>[27] ~/grocery (berries)</strong>
<strong>$ cat .git/refs/heads/master</strong>
<strong>0e8b5cf1c1b44110dd36dea5ce0ae29ce22ad4b8</strong></pre>
<p>Same hash, same commit.</p>
<p>A <em>side effect</em> of this operation is losing the last commit we did in <kbd>berries</kbd>, as we already said: but why? And how?</p>
<p>This is due to the <strong>reachability</strong> of commits. A commit is not more reachable when no branches points to it directly, nor it figures as a parent of another commit in a branch. Our <em>blackberry commit</em> was the last commit on the <kbd>berries</kbd> branch, so moving the <kbd>berries</kbd> branch away from it, made it unreachable, and it <em>disappears</em> from our repository.</p>
<p>But are you sure it is gone? Want to make a bet?</p>
<p>Let's try another trick: we can use <kbd>git reset</kbd> to move the actual branch directly to a commit. And to make things more interesting, let's try to point the <em>blackberry commit</em> (if you scroll your shell window backwards, you can see its hash, which for me is <kbd>ef6c382</kbd>) so, <kbd>git reset</kbd> to the <kbd>ef6c382</kbd> commit:</p>
<pre><strong>[28] ~/grocery (berries)</strong>
<strong>$ git reset --hard ef6c382</strong>
<strong>HEAD is now at ef6c382 Add a blackberry</strong></pre>
<p>And then do the usual <kbd>git log</kbd>:</p>
<pre><strong>[29] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* ef6c382 (HEAD -&gt; berries) Add a blackberry</strong>
<strong>* 0e8b5cf (master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>That's magic! We actually recovered the lost commit!</p>
<p>Okay, jokes aside, there's no magic in Git; it simply won't delete unreachable commits, at least not immediately. It makes some housekeeping automatically at a given time, as it has some powerful <strong>garbage collection</strong> features (look at the <kbd>git gc</kbd> command help page if you are curious; I want you to remember that any Git command, followed by the <kbd>--help</kbd> option, will open for you the internal man page for it).</p>
<p>So, we have seen what reachability of commits means, and then learnt how to undo a commit using the <kbd>git reset</kbd> command, that is a thing to know to take advantage of Git features while working on a repository.</p>
<p>But let's continue experimenting with branches.</p>
<p>Assume you want to add a watermelon to the shopping list, but later you realize you added it to the wrong <kbd>berries</kbd> branch; so, add <kbd>"watermelon"</kbd> to the <kbd>shoppingList.txt</kbd> file:</p>
<pre><strong>[30] ~/grocery (berries)</strong>
<strong>$ echo "watermelon" &gt;&gt; shoppingList.txt</strong></pre>
<p>Then do the commit:</p>
<pre><strong>[31] ~/grocery (berries)</strong>
<strong>$ git commit -am "Add a watermelon"</strong>
<strong>[berries a8c6219] Add a watermelon</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>And do a <kbd>git log</kbd> to check the result:</p>
<pre><strong>[32] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* a8c6219 (HEAD -&gt; berries) Add a watermelon</strong>
<strong>* ef6c382 Add a blackberry</strong>
<strong>* 0e8b5cf (master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Now our aim here is: have a new <kbd>melons</kbd> branch, which the <em>watermelon commit</em> have to belong to, then set the house in order and move the <kbd>berries</kbd> branch back to the <em>blackberry commit</em>. To keep the <em>watermelon commit</em>, first create a <kbd>melon</kbd> branch that points to it with the well-known <kbd>git branch</kbd> command:</p>
<pre><strong>[33] ~/grocery (berries)</strong>
<strong>$ git branch melons</strong></pre>
<p>Let's check:</p>
<pre><strong>[34] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* a8c6219 (HEAD -&gt; berries, melons) Add a watermelon</strong>
<strong>* ef6c382 Add a blackberry</strong>
<strong>* 0e8b5cf (master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, so now we have both <kbd>berries</kbd> and <kbd>melons</kbd> branches pointing to the watermelon commit.</p>
<p>Now we can move the <kbd>berries</kbd> branch back to the previous commit; let's get advantage of the opportunity to learn something new.</p>
<p>In Git, you often have the need to point to a preceding commit, like in this case, the one before; for this scope, we can use <kbd>HEAD</kbd> reference, followed by one of two different special characters, the <em>tilde</em><kbd>~</kbd> and the <em>caret</em><kbd>^</kbd>. A <strong>caret</strong> basically means <em>a back step</em>, while two carets means two steps back, and so on. As you probably don't want to type dozens of carets, when you need to step back a lot, you can use <strong>tilde</strong>: similarly, <kbd>~1</kbd> means <em>a back step</em>, while <kbd>~25</kbd> means 25 steps back, and so on.</p>
<p>There's more to know about this mechanism, but it is enough for now; for all the details check <a href="http://www.paulboxley.com/blog/2011/06/git-caret-and-tilde">http://www.paulboxley.com/blog/2011/06/git-caret-and-tilde</a>.</p>
<p>So, let's step back our <kbd>berries</kbd> branch using caret; do a <kbd>git reset --hard HEAD^</kbd>:</p>
<pre><strong>[35] ~/grocery (berries)</strong>
<strong>$ git reset --hard HEAD^</strong>
<strong>HEAD is now at ef6c382 Add a blackberry</strong></pre>
<p>Let's see the result:</p>
<pre><strong>[36] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* a8c6219 (melons) Add a watermelon</strong>
<strong>* ef6c382 (HEAD -&gt; berries) Add a blackberry</strong>
<strong>* 0e8b5cf (master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Well done! We successfully recovered the mistake, and learnt how to use the <kbd>HEAD</kbd> reference and <kbd>git reset</kbd> command to move branches from here to there.</p>
<p>Just to remark concepts, let's take a look at the <kbd>shoppingList.txt</kbd> file here in the <kbd>berries</kbd> branch:</p>
<pre><strong>[37] ~/grocery (berries)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong>
<strong>blackberry</strong></pre>
<p>Okay, here we have blackberry, other than the other previously added fruits.</p>
<p>Switch to <kbd>master</kbd> and check again; check out the <kbd>master</kbd> branch:</p>
<pre><strong>[38] ~/grocery (berries)</strong>
<strong>$ git checkout master</strong>
<strong>Switched to branch 'master'</strong></pre>
<p>Then <kbd>cat</kbd> the file:</p>
<pre><strong>[39] ~/grocery (master)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong></pre>
<p>Okay, no blackberry here, but only fruits added before the <kbd>berries</kbd> branch creation.</p>
<p>And now a last check on the <kbd>melons</kbd> branch; check out the branch:</p>
<pre><strong>[40] ~/grocery (master)</strong>
<strong>$ git checkout melons</strong>
<strong>Switched to branch 'melons'</strong></pre>
<p>And <kbd>cat</kbd> the <kbd>shoppingList.txt</kbd> file:</p>
<pre><strong>[41] ~/grocery (melons)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong>
<strong>blackberry</strong>
<strong>watermelon</strong></pre>
<p>Fantastic! Here there is the watermelon, other than fruits previously added while in the <kbd>berries</kbd> and <kbd>master</kbd> branches.</p>
<p>Quick tip: while writing the branch name, use <em>Tab</em> to autocomplete: Git will write the complete branch name for you.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Detached HEAD</h1>
                
            
            
                
<p>Now it's time to explore another important concept about Git and its references, the <kbd>detached HEAD</kbd> state.</p>
<p>For the sake of the explanation, go back to the <kbd>master</kbd> branch and see what happens when we check out the previous commit, moving <kbd>HEAD</kbd> backward; perform a <kbd>git checkout HEAD^</kbd>:</p>
<pre><strong>[42] ~/grocery (master)</strong>
<strong>$ git checkout HEAD^</strong>
<strong>Note: checking out 'HEAD^'.<br/><br/><br/></strong><strong>You are in 'detached HEAD' state. You can look around, make experimental</strong>
<strong>changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout.</strong>

<strong>If you want to create a new branch to retain commits you create, you may</strong>
<strong>do so (now or later) by using -b with the checkout command again. Example:</strong>

<strong>  git checkout -b &lt;new-branch-name&gt;</strong>

<strong>HEAD is now at e4a5e7b... Add an apple</strong></pre>
<p>Wow, a lot of new things to see here. But don't be scared, it's not that complicated: let's take some baby steps into the long message Git showed us.</p>
<p>First, think about it: Git is very kind and often tells us loads of useful information in its output messages. Don't under evaluate this behavior: especially at the beginning, reading Git messages allows you to learn a lot, so read them carefully.</p>
<p>Here, Git says we are in a <kbd>detached HEAD</kbd> state. Being in this state basically means that <kbd>HEAD</kbd> does not reference a branch, but directly a commit, the <kbd>e4a5e7b</kbd> one in this case; do a <kbd>git log</kbd> and see:</p>
<pre><strong>[43] ~/grocery ((e4a5e7b...))</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* a8c6219 (melons) Add a watermelon</strong>
<strong>* ef6c382 (berries) Add a blackberry</strong>
<strong>* 0e8b5cf (master) Add an orange</strong>
<strong>* e4a5e7b (HEAD) Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>First of all, in the shell prompt you can see that between rounds, that now are doubled, there is not a branch name, but the first seven characters of the commit, <kbd>((e4a5e7b...))</kbd>.</p>
<p>Then, <kbd>HEAD</kbd> is now stuck to that commit, while branches, especially the <kbd>master</kbd> one, remains at their own place. As a result, the <kbd>HEAD</kbd> file now contains the hash of that commit, not a ref to a branch as before:</p>
<pre><strong>[44] ~/grocery ((e4a5e7b...))</strong>
<strong>$ cat .git/HEAD</strong>
<strong>e4a5e7b3c64bee8b60e23760626e2278aa322f05</strong></pre>
<p>Going on, Git says that in this state we can look around, make experiments, doing new commits if we like, and then discard them simply by checking out an existing branch, or save them if you like creating a new branch. Can you say why this is true?</p>
<p>Due to reachability of commits, of course. If we do some commits, then move <kbd>HEAD</kbd> to an existing branch, those commits become unreachable. They stay in a reachable state until <kbd>HEAD</kbd> is on top of the last of them, but when you move <kbd>HEAD</kbd> with a <kbd>git checkout</kbd>, they are gone. At the same time, if you create a new branch before moving <kbd>HEAD</kbd>, there will be a label, a pointer Git can use to reach those commits, so they are safe.</p>
<p>Want to try?</p>
<p>Okay, let's have some fun; modify the <kbd>shoppingList.txt</kbd> file, adding a <kbd>bug</kbd>:</p>
<pre><strong>[45] ~/grocery ((e4a5e7b...))</strong>
<strong>$ echo "bug" &gt; shoppingList.txt</strong></pre>
<p>Then <kbd>commit</kbd> this voluntary mistake:</p>
<pre><strong>[46] ~/grocery ((e4a5e7b...))</strong>
<strong>$ git commit -am "Bug eats all the fruits!"</strong>
<strong>[detached HEAD 07b1858] Bug eats all the fruits!</strong>
<strong> 1 file changed, 1 insertion(+), 2 deletions(-)</strong></pre>
<p>Let's <kbd>cat</kbd> the file:</p>
<pre><strong>[47] ~/grocery ((07b1858...))</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>bug</strong></pre>
<p>Ouch, we actually erased all your shopping list files!</p>
<p>What happened in the repository then?</p>
<pre><strong>[48] ~/grocery ((07b1858...))<br/>$ git log --oneline --graph --decorate --all<br/><br/></strong><strong>  * 07b1858 (HEAD) Bug eats all the fruits!</strong>
<strong>  | * a8c6219 (melons) Add a watermelon</strong>
<strong>  | * ef6c382 (berries) Add a blackberry</strong>
<strong>  | * 0e8b5cf (master) Add an orange</strong>
<strong>  |/<br/><br/></strong><strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong>
  </pre>
<p>Nice! We have a new commit, the bug one, and we can see as <kbd>HEAD</kbd> followed us, so now it points to it. Then, the console drew two different <kbd>paths</kbd>, because starting from <kbd>apple commit</kbd>, we traced two routes: one that goes to the <kbd>master</kbd> branch (then to <kbd>berries</kbd> and <kbd>melons</kbd>), and one that goes to the <kbd>bug commit</kbd> we just made.</p>
<p>Okay, so if we now check out <kbd>master</kbd> again, what happens? Give it a try:</p>
<pre><strong>[49] ~/grocery ((07b1858...))</strong>
<strong>$ git checkout master</strong>
<br/><strong>Warning: you are leaving 1 commit behind, not connected to</strong>
<strong>any of your branches:</strong>

<strong>  07b1858 Bug eats all the fruits!</strong>

<strong>If you want to keep it by creating a new branch, this may be a good time to do so with:</strong>
<strong> git branch &lt;new-branch-name&gt; 07b1858</strong>

<strong>Switched to branch 'master'</strong></pre>
<p>Okay, we have already seen this message: Git is aware that we are leaving a commit behind; but in this case, it's not a problem for us, indeed it's actually what we really want.</p>
<p>Let's check the situation:</p>
<pre><strong>[50] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* a8c6219 (melons) Add a watermelon</strong>
<strong>* ef6c382 (berries) Add a blackberry</strong>
<strong>* 0e8b5cf (HEAD -&gt; master) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Yay! The bug commit is gone, so nothing is compromised. In the previous message, Git was kind enough to remind us how to recover that commit, just in case; the trick is to directly create a branch that points to that commit, and Git pinned us even the complete command. Let's try it, creating a <kbd>bug</kbd> branch:</p>
<pre><strong>[51] ~/grocery (master)</strong>
<strong>$ git branch bug 07b1858</strong></pre>
<p>Let's see what happened:</p>
<pre><strong>[52] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 07b1858 (bug) Bug eats all the fruits!</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>| * 0e8b5cf (HEAD -&gt; master) Add an orange</strong>
<strong>|/</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Wow, that's amazingly simple! The commit is here again, and now we have even a branch to check out if we like.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The reflogs</h1>
                
            
            
                
<p>Okay, but what if we ignore the Git message the first time, then time goes and at the end, we can't remember the hash of the commit we want to retrieve?</p>
<p>Git never forgets you. It has another powerful tool in its wrench box, and that is called the <strong>reference log</strong>, or reflog for short. Basically, the reflog (or better the reflogs, as there is one for every reference) records what happens in the repository while you commit, reset, check out, and so on. To be more precise, every reflog records all the times that tips of the branches and other references (such as <kbd>HEAD</kbd>) where updated.</p>
<p>We can take a look at it with a convenient Git command, <kbd>git reflog show</kbd>:</p>
<pre><strong>[53] ~/grocery (master)</strong>
<strong>$ git reflog show</strong>
<strong>0e8b5cf HEAD@{0}: checkout: moving from 07b18581801f9c2c08c25cad3b43aeee7420ffdd to master</strong>
<strong>07b1858 HEAD@{1}: commit: Bug eats all the fruits!</strong>
<strong>e4a5e7b HEAD@{2}: checkout: moving from master to HEAD^</strong>
<strong>0e8b5cf HEAD@{3}: reset: moving to 0e8b5cf</strong>
<strong>e4a5e7b HEAD@{4}: reset: moving to HEAD^</strong>
<strong>0e8b5cf HEAD@{5}: checkout: moving from melons to master</strong>
<strong>a8c6219 HEAD@{6}: checkout: moving from master to melons</strong>
<strong>0e8b5cf HEAD@{7}: checkout: moving from berries to master</strong>
<strong>ef6c382 HEAD@{8}: reset: moving to HEAD^</strong>
<strong>a8c6219 HEAD@{9}: commit: Add a watermelon</strong>
<strong>ef6c382 HEAD@{10}: reset: moving to ef6c382</strong>
<strong>ef6c382 HEAD@{11}: reset: moving to ef6c382</strong>
<strong>0e8b5cf HEAD@{12}: reset: moving to master</strong>
<strong>ef6c382 HEAD@{13}: checkout: moving from master to berries</strong>
<strong>0e8b5cf HEAD@{14}: checkout: moving from berries to master</strong>
<strong>ef6c382 HEAD@{15}: commit: Add a blackberry</strong>
<strong>0e8b5cf HEAD@{16}: checkout: moving from master to berries</strong>
<strong>0e8b5cf HEAD@{17}: commit: Add an orange</strong>
<strong>e4a5e7b HEAD@{18}: commit: Add an apple</strong>
<strong>a57d783 HEAD@{19}: commit (amend): Add a banana to the shopping list</strong>
<strong>c7a0883 HEAD@{20}: commit (initial): Add a banana to the shopping list</strong></pre>
<p>Actually, here there are all the movements the <kbd>HEAD</kbd> reference made in my repository since the beginning, in reverse order, as you may have already noticed.<br/>
In fact, the last one (<kbd>HEAD@{0}</kbd>) says:</p>
<pre><strong>checkout: moving from 07b18581801f9c2c08c25cad3b43aeee7420ffdd to master</strong></pre>
<p>Actually, this is the very last thing we did, apart from the creation on the <kbd>bug</kbd> branch. As we never moved into it, the <kbd>HEAD</kbd> reflog doesn't log anything about <kbd>bug</kbd> branch creation.</p>
<p>The reflog is a quite complex topic to be discussed in depth, so here we only learn how to open and read it, and how to interpret information from it.</p>
<p>The only things I want you to know are that this log will be cleared at some point; the default retention is 90 days. Then, there is a reflog for every reference; what we are seeing now is the <kbd>HEAD</kbd> reflog (<kbd>HEAD@</kbd> is a hint about this), but if you type <kbd>git reflog show berries</kbd> you will see the movements <kbd>berries</kbd> branch did in the past:</p>
<pre><strong>[54] ~/grocery (master)<br/>$ git reflog berries<br/><br/></strong><strong>ef6c382 berries@{0}: reset: moving to HEAD^</strong>
<strong>a8c6219 berries@{1}: commit: Add a watermelon</strong>
<strong>ef6c382 berries@{2}: reset: moving to ef6c382</strong>
<strong>0e8b5cf berries@{3}: reset: moving to master</strong>
<strong>ef6c382 berries@{4}: commit: Add a blackberry</strong>
<strong>0e8b5cf berries@{5}: branch: Created from master</strong></pre>
<p>To go back to our problem, if we want to check out a currently unreachable commit, we can go to the <kbd>HEAD</kbd> reflog and look for a line where we did the commit (in this example, I would look for a <kbd>commit:</kbd> logline, searching the one where the commit message says something that helps me to remind, something like <kbd>bug</kbd> in this case).</p>
<p>Well done, that's enough for now; later we will use reflog again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tags are fixed labels</h1>
                
            
            
                
<p><strong>Tags</strong> are labels you can pin to a commit, but unlike branches, they will stay there.</p>
<p>Creating a tag is simple: you only need the <kbd>git tag</kbd> command, followed by a tag name; we can create one in the tip commit of <kbd>bug</kbd> branch to give it a try; check out the <kbd>bug</kbd> branch:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ git checkout bug</strong>
<strong>Switched to branch 'bug'</strong></pre>
<p>Then use the <kbd>git tag</kbd> command followed by the funny <kbd>bugTag</kbd> name:</p>
<pre><strong>[2] ~/grocery (bug)</strong>
<strong>$ git tag bugTag</strong></pre>
<p>Let's see what <kbd>git log</kbd> says:</p>
<pre><strong>[3] ~/grocery (bug)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 07b1858 (HEAD -&gt; bug, tag: bugTag) Bug eats all the fruits!</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>| * 0e8b5cf (master) Add an orange<br/>|/<br/><br/></strong><strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>As you can see in the log, now on the tip of the <kbd>bug</kbd> branch there is even a tag named <kbd>bugTag</kbd>.</p>
<p>If you do a commit in this branch, you will see the <kbd>bugTag</kbd> will remain at its place; add a new line to the same old shopping list file:</p>
<pre><strong>[4] ~/grocery (bug)</strong>
<strong>$ echo "another bug" &gt;&gt; shoppingList.txt</strong></pre>
<p>Perform a <kbd>commit</kbd>:</p>
<pre><strong>[5] ~/grocery (bug)</strong>
<strong>$ git commit -am "Another bug!"</strong>
<strong>[bug 5d605c6] Another bug!</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Then look at the current situation:</p>
<pre><strong>[6] ~/grocery (bug)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 5d605c6 (HEAD -&gt; bug) Another bug!</strong>
<strong>* 07b1858 (tag: bugTag) Bug eats all the fruits!</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>| * 0e8b5cf (master) Add an orange</strong>
<strong>|/</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>That's exactly what we predict.</p>
<p>Tags are useful to give a particular meaning to some particular commits; for instance, as a developer, you maybe want to tag every release of your software: in that case, this is all you need to know to do that job.</p>
<p>Even tags are references, and they are stored, as branches, as simple text files in the tags subfolder within the <kbd>.git</kbd> folder; take a look under the <kbd>.git/refs/tags</kbd> folder, you will see a <kbd>bugTag</kbd> file; look at the content:</p>
<pre><strong>[7] ~/grocery (bug)</strong>
<strong>$ cat .git/refs/tags/bugTag</strong>
<strong>07b18581801f9c2c08c25cad3b43aeee7420ffdd</strong></pre>
<p>As you maybe have already predicted, it contains the hash of the commit it refers to.</p>
<p>To delete a tag, you have to simply append the <kbd>-d</kbd> option: <kbd>git tag -d &lt;tag name&gt;</kbd>.</p>
<p>As you can't move a tag, if you need to move it you have to delete the previous tag and then create a new one with the same name that points to the commit you want; you can create a tag that points a commit wherever you want, appending the hash of the commit as an argument, for example, <kbd>git tag myTag 07b1858</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Annotated tags</h1>
                
            
            
                
<p>Git has two kinds of tags; this is because in some situations you may want to add a message to the tag, or because you like to have the author stick to it.</p>
<p>We already have seen the first type, the simpler one; tags containing this extra information load belong to the second type, the <strong>annotated tag</strong>.</p>
<p>An annotated tag is both a <em>reference</em> and a <em>git object</em> such as commits, trees, and blobs.</p>
<p>To create one, simply append <kbd>-a</kbd> to the command; let's create another one to give this a try:</p>
<pre><strong>[8] ~/grocery (bug)</strong>
<strong>$ git tag -a annotatedTag 07b1858</strong></pre>
<p>At this point Git opens the default editor, to allow you to write the tag message, as in the following screenshot:</p>
<div><img height="133" width="452" class="aligncenter size-full wp-image-213 image-border" src="img/efb244ea-c2fa-48f6-acda-7d0dd2fba54f.png"/></div>
<p>Save and exit, and then see the log:</p>
<pre><strong>[9] ~/grocery (bug)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 5d605c6 (HEAD -&gt; bug) Another bug!</strong>
<strong>* 07b1858 (tag: bugTag, tag: annotatedTag) Bug eats all the fruits!</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>| * 0e8b5cf (master) Add an orange<br/>|/<br/><br/></strong><strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, there are two tags now on the same commit.</p>
<p>A new ref has been created:</p>
<pre><strong>[10] ~/grocery (bug)</strong>
<strong>$ cat .git/refs/tags/annotatedTag</strong>
<strong>17c289ddf23798de6eee8fe6c2e908cf0c3a6747</strong></pre>
<p>But even a new object: try to <kbd>cat-file</kbd> the hash you see in the reference:</p>
<pre><strong>[11] ~/grocery (bug)</strong>
<strong>$ git cat-file -p 17c289</strong>
<strong>object 07b18581801f9c2c08c25cad3b43aeee7420ffdd</strong>
<strong>type commit</strong>
<strong>tag annotatedTag</strong>
<strong>tagger Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 150376226 4 +0200</strong>

<strong>This is an annotated tag</strong></pre>
<p>This is how an annotated tag looks like.</p>
<p>Obviously, the <kbd>git tag</kbd> command has many other options, but I only highlighted the ones I think are worth knowing at the moment.</p>
<p>If you want to look at all the options of a command, remember you can always do a <kbd>git &lt;command&gt; --help</kbd> to see the complete guide.</p>
<p>Time to spend some words on the staging area, as we have only scratched the surface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Staging area, working tree, and HEAD commit</h1>
                
            
            
                
<p>Until now, we have barely named the <strong>staging area</strong> (also known as an <strong>index</strong>), while preparing files to make a new commit with the <kbd>git add</kbd> command.</p>
<p>Well, the staging area purpose is actually this. When you change the content of a file, when you add a new one or delete an existing one, you have to tell Git what of these modifications will be part of the next commit: the staging area is the container for this kind of data.</p>
<p>Let's focus on this right now; move to the <kbd>master</kbd> branch, if not already there, then type the <kbd>git status</kbd> command; it allows us to see the actual status of the staging area:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>nothing to commit, working tree clean</strong></pre>
<p>Git says there's nothing to commit, our working tree is clean. But what's a <strong>working tree</strong>? Is it the same as the working directory we talked about? Well, yes and no, and it's confusing, I know.</p>
<p>Git had (and still have) some troubles with names; in fact, as we said a couple of lines before, even for the staging area we have two names (the other one is index). Git uses both in its messages and commands output, and the same often does people, blogs, and books like this one while talking about Git. Having two names for the same thing is not always a good idea, especially when they represent exactly the same thing, but being aware of this is enough (time will give us a less confusing Git, I'm sure).</p>
<p>For the working tree and working directory, the story is this. At some point, someone argued: <em>If I'm in the root of the repository I'm in a working directory, but if I walk through a subfolder, I'm in another working directory</em>. This is technically true by a filesystem perspective, but while in Git, doing some operations such as checkout or reset does not affect the current working directory, but the entire... working tree. So, to avoid confusion, Git stopped talking about working directory in its messages and "renamed" it as working tree. This is the commit on Git repository that made this change: <a href="https://github.com/git/git/commit/2a0e6cdedab306eccbd297c051035c13d0266343">https://github.com/git/git/commit/2a0e6cdedab306eccbd297c051035c13d0266343</a>, if you want to go in deep. Hope I've clarified a little bit.</p>
<p>Back on topic now.</p>
<p>Add a <kbd>peach</kbd> to the <kbd>shoppingList.txt</kbd> file:</p>
<pre><strong>[2] ~/grocery (master)</strong>
<strong>$ echo "peach" &gt;&gt; shoppingList.txt</strong></pre>
<p>Then make use of this new learnt command again, <kbd>git status</kbd>:</p>
<pre><strong>[3] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Changes not staged for commit:</strong>
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>

<strong>modified:   shoppingList.txt</strong>

<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<p>Okay, now it's time to learn about <strong>staged</strong> changes; with the word <kbd>staged</kbd>, Git means modifications we already added to the staging area, so they will be part of the next commit. In the current situation, we modified the <kbd>shoppingList.txt</kbd> file, but we have not added it yet to the staging area (using the good old <kbd>git add</kbd> command).</p>
<p>So, Git informs us: it tells that there is a modified file (in red color), and then offers two possibilities: <em>stage</em> it (add it to the staging area), or <em>discard</em> the modification, using the <kbd>git checkout -- &lt;file&gt; command</kbd>.</p>
<p>Let's try to add it; we will see the second option later.</p>
<p>So, try a <kbd>git add</kbd> command, with nothing more:</p>
<pre><strong>[4] ~/grocery (master)</strong>
<strong>$ git add</strong>
<strong>Nothing specified, nothing added.</strong>
<strong>Maybe you wanted to say 'git add .'?</strong></pre>
<p>Okay, new thing learnt: <kbd>git add</kbd> wants you to specify something to add. A common thing is to use the dot <kbd>.</kbd> as a wildcard, and this by default means, <em>add all the files in this folder and subfolders to the staging area</em>. This is the same as <kbd>git add -A</kbd> (or <kbd>--all</kbd>), and by "all" I mean:</p>
<ul>
<li><strong>Files in this folder and sub-folders I added in the past at least one time</strong>: This set of files is also known as the <strong>tracked files</strong></li>
<li><strong>New files</strong>: These are called <strong>untracked files</strong></li>
<li>Files marked for deletion</li>
</ul>
<p>Be aware that this behavior changed over time: before Git 2.x, <kbd>git add .</kbd> and <kbd>git add -A</kbd> had different effects. Here is a table for quickly understanding the differences.</p>
<p>Git version 1.x:</p>
<table style="width: 964px;height: 378px" class="MsoTableGrid">
<tbody>
<tr>
<td/>
<td>
<p><strong>New files</strong></p>
</td>
<td>
<p><strong>Modified files</strong></p>
</td>
<td>
<p><strong>Deleted files</strong></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>git add -A</kbd></p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>Stage all (new, modified, deleted) files</p>
</td>
</tr>
<tr>
<td>
<p><kbd>git add .</kbd></p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>no</p>
</td>
<td>
<p>Stage new and modified files only</p>
</td>
</tr>
<tr>
<td>
<p><kbd>git add -u</kbd></p>
</td>
<td>
<p>no</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>Stage modified and deleted files only</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Git version 2.x:</p>
<table style="width: 1045px;height: 398px" class="MsoTableGrid">
<tbody>
<tr>
<td/>
<td>
<p><strong>New files</strong></p>
</td>
<td>
<p><strong>Modified files</strong></p>
</td>
<td>
<p><strong>Deleted files</strong></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>git add -A</kbd></p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>Stage all (new, modified, deleted) files</p>
</td>
</tr>
<tr>
<td>
<p><kbd>git add .</kbd></p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p><strong>yes</strong></p>
</td>
<td>
<p>Stage all (new, modified, deleted) files</p>
</td>
</tr>
<tr>
<td>
<p><kbd>git add --ignore-removal .</kbd></p>
</td>
<td>
<p><strong>yes</strong></p>
</td>
<td>
<p><strong>yes</strong></p>
</td>
<td>
<p><strong>no</strong></p>
</td>
<td>
<p>Stage new and modified files only</p>
</td>
</tr>
<tr>
<td>
<p><kbd>git add -u</kbd></p>
</td>
<td>
<p>no</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>yes</p>
</td>
<td>
<p>Stage modified and deleted files only</p>
</td>
</tr>
</tbody>
</table>
<p>As you can see, in Git 2.x there's a new way to stage new and modified files only, the <kbd>git add --ignore-removal .</kbd> way, and then <kbd>git add .</kbd> became the same as <kbd>git add -A</kbd>. If you are wondering, the <kbd>-u</kbd> option is the equivalent of <kbd>--update</kbd>.</p>
<p>Another basic usage is to specify the file we want to add; let's give it a try:</p>
<pre><strong>[5] ~/grocery (master)</strong>
<strong>$ git add shoppingList.txt</strong></pre>
<p>As you can see, when <kbd>git add</kbd> goes right, Git says nothing, no messages: let's consider it a tacit approval.</p>
<p>Other ways to add files is specifying a directory to add all the changed files within it, using wildcards such as the star <kbd>*</kbd> with or without something else (for example, <kbd>*.txt</kbd> for adding all <kbd>txt</kbd> files, <kbd>foo*</kbd> for adding all files starting with <kbd>foo</kbd> and so on).<br/>
Please refer to <a href="https://git-scm.com/docs/git-add#git-add-ltpathspecgt82308203">https://git-scm.com/docs/git-add#git-add-ltpathspecgt82308203</a> for all the information.</p>
<p>Okay, time to look back at our repository; go with a <kbd>git status</kbd> now:</p>
<pre><strong>[6] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Changes to be committed:</strong>
<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>

<strong>modified:   shoppingList.txt</strong></pre>
<p>Nice! Our file has been added to the staging area, and now it is one of the changes that will be part of the next commit, the only one actually.</p>
<p>Now take a look at what Git says then: if you want to <kbd>unstage</kbd> the change, you can use the <kbd>git reset HEAD</kbd> command: what does it mean? <strong>Unstage</strong> is a word to say <em>remove a change from the staging area</em>, for example, because we realized we want to add that change not in the next commit, but later.</p>
<p>For now, leave things how they are, and do a <kbd>commit</kbd>:</p>
<pre><strong>[7] ~/grocery (master)</strong>
<strong>$ git commit -m "Add a peach"</strong>
<strong>[master 603b9d1] Add a peach</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Check the status:</p>
<pre><strong>[8] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>nothing to commit, working tree clean</strong></pre>
<p>Okay, now we have a new <kbd>commit</kbd> and our working tree is clean again; yes, because the effect of <kbd>git commit</kbd> is to create a new commit with the content of the staging area, and then empty it.</p>
<p>Now we can make some experiments and see how to deal with the staging area and working tree, undoing changes when in need.</p>
<p>So, follow me and make things more interesting; add an onion to the shopping list and then add it to the staging area, and then add a garlic and see what happens:</p>
<pre><strong>[9] ~/grocery (master)</strong>
<strong>$ echo "onion" &gt;&gt; shoppingList.txt</strong>

<strong>[10] ~/grocery (master)</strong>
<strong>$ git add shoppingList.txt</strong>

<strong>[11] ~/grocery (master)</strong>
<strong>$ echo "garlic" &gt;&gt; shoppingList.txt</strong>

<strong>[12] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Changes to be committed:</strong>
<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>

<strong>modified:   shoppingList.txt</strong>

<strong>Changes not staged for commit:</strong>
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>

<strong>modified:   shoppingList.txt</strong></pre>
<p>Okay, good! We are in a very interesting state now. Our <kbd>shoppingList.txt</kbd> file has been modified two times, and only the first modification has been added to the staging area. This means that at this point if we would commit the file, only the <kbd>onion</kbd> modification would be part of the commit, but not the <kbd>garlic</kbd> one. This is a thing to underline, as in other versioning systems it is not so simple to do this kind of work.</p>
<p>To highlight the modification we did, and take a brief look, we can use the <kbd>git diff</kbd> command; for example, if you want to see the difference between the working tree version and the staging area one, try to input only the <kbd>git diff</kbd> command without any option or argument:</p>
<pre><strong>[13] ~/grocery (master)</strong>
<strong>$ git diff</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index f961a4c..20238b5 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -3,3 +3,4 @@ apple</strong>
<strong> orange</strong>
<strong> peach</strong>
<strong> onion</strong>
<strong>+garlic</strong></pre>
<p>As you can see, Git highlights the fact that in the working tree we have a <kbd>garlic</kbd> more than the staging area version.</p>
<p>The last part of the output of the <kbd>git diff</kbd> command is not difficult to understand: green lines starting with a plus <kbd>+</kbd> symbol are new lines added (there would be red lines starting with a minus <kbd>-</kbd> for deleted lines). A modified line will be usually highlighted by Git with a minus red deleted line and a plus green added line; to be <kbd>true</kbd>, Git can be instructed to use different <kbd>diff</kbd> algorithms, but this is out of the scope of this book.</p>
<p>Other than this, the first part of the <kbd>git diff</kbd> output is a little bit too difficult to explain in a few words; please refer to <a href="https://git-scm.com/docs/git-diff">https://git-scm.com/docs/git-diff</a> for all the details.</p>
<p>But what if you want to see the differences between the last committed version of the <kbd>shoppingList.txt</kbd> file and the one added into the staging area?</p>
<p>We have to use the <kbd>git diff --cached HEAD</kbd> command:</p>
<pre><strong>[14] ~/grocery (master)</strong>
<strong>$ git diff --cached HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index 175eeef..f961a4c 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -2,3 +2,4 @@ banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong> peach</strong>
<strong>+onion</strong></pre>
<p>We have to dissect this command to better understand what's the purpose; appending the <kbd>HEAD</kbd> argument, we are asking to use the last commit we did as a subject of the compare. To be <kbd>true</kbd>, in this case, the <kbd>HEAD</kbd> reference is optional, as it is the default: <kbd>git diff --cached</kbd> would return the same result.<br/>
Instead, the <kbd>--cached</kbd> option says, <em>compare the argument (HEAD in this case) with the version in the staging area</em>.</p>
<p>Yes, dear friends: the staging area, also known as an <kbd>index</kbd>, sometimes is called <kbd>cache</kbd>, hence the <kbd>--cached</kbd> option.</p>
<p>The last experiment that we can do is compare the <kbd>HEAD</kbd> version with the working tree one; let's do it with a <kbd>git diff HEAD</kbd>:</p>
<pre><strong>[15] ~/grocery (master)</strong>
<strong>$ git diff HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index 175eeef..20238b5 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -2,3 +2,5 @@ banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong> peach</strong>
<strong>+onion</strong>
<strong>+garlic</strong></pre>
<p>Okay, it works as expected.</p>
<p>Now it's time to take a break from the console and spend a couple of words to talk about these three <kbd>locations</kbd> we compared.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The three areas of Git</h1>
                
            
            
                
<p>In Git, we work at three different levels:</p>
<ul>
<li>The <strong>working tree</strong> (or working directory)</li>
<li>The <strong>staging area</strong> (or index, or cache)</li>
<li>The <strong>HEAD </strong><strong>commit</strong> (or the last commit or tip commit on the current branch)</li>
</ul>
<p>When we modify a file, we are doing it at working tree level; when we do a <kbd>git add</kbd>, we are actually copying the changes from the working tree to the staging area. At the end, when we do a <kbd>git commit</kbd>, we finally move the changes from the staging area to a brand new commit, referenced by <kbd>HEAD</kbd>, which will become part of our repository history: this is what I mean with the HEAD commit.</p>
<p>The following figure draws those three areas:</p>
<div><img height="182" width="265" src="img/41b68d6e-bdb8-4894-9a6f-81baafcd030e.png"/></div>
<p>We can move changes between these areas forward, from the working tree to the <kbd>HEAD</kbd> commit, but we can even go backward, undoing changes if we like.</p>
<p>We already know how to go forward using <kbd>git add</kbd> then <kbd>git commit</kbd>; let's take a look at the commands to go backward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing changes from the staging area</h1>
                
            
            
                
<p>It happens that you add changes to the staging area, then you realize they fit better in a future commit, not in the commit you are composing right now.</p>
<p>To remove those changes to one or more files from the staging area, you can use the <kbd>git reset HEAD &lt;file&gt;</kbd> command; get back the shell and follow me.</p>
<p>Check the repository current status:</p>
<pre><strong>[16] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Changes to be committed:</strong>
<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>

<strong>modified:   shoppingList.txt</strong>

<strong>Changes not staged for commit:</strong>
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>

<strong>modified:   shoppingList.txt</strong></pre>
<p>This is the actual situation, remember? We have an <kbd>onion</kbd> in the staging area and a <kbd>garlic</kbd> more in the working tree.</p>
<p>Now go with a <kbd>git reset HEAD</kbd>:</p>
<pre><strong>[17] ~/grocery (master)</strong>
<strong>$ git reset HEAD shoppingList.txt</strong>
<strong>Unstaged changes after reset:</strong>
<strong>M   shoppingList.txt</strong></pre>
<p>Okay, Git confirms we unstaged changes. The <kbd>M</kbd> on the left side means <kbd>Modified</kbd>; here Git is telling us we have unstaged a modification to a file. If you create a new file and you add it to the staging area, Git knows this is a new file; if you try to unstage it, Git would put an <kbd>A</kbd> for <kbd>Added</kbd> in the left, to remember that you just unstaged the addition of a new file. Same if you unstage the deletion of an existing file: on the left would appear a <kbd>D</kbd> for <kbd>Deleted</kbd>.</p>
<p>Well, time to verify what happened:</p>
<pre><strong>[18] ~/grocery (master)</strong><strong>$ git status</strong><br/><strong>On branch master 
Changes not staged for commit:</strong><br/><br/><strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong><strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong><strong>modified:   shoppingList.txt</strong><strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<p>Okay, by using <kbd>git status</kbd> we see that now the staging area is empty, there's nothing staged. We only have some unstaged modification, but what modification? Did the <kbd>git reset HEAD</kbd> actually delete the onion?</p>
<p>Let's verify this using the <kbd>git diff</kbd> command:</p>
<pre><strong>[19] ~/grocery (master)</strong>
<strong>$ git diff</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index 175eeef..20238b5 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -2,3 +2,5 @@ banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong> peach</strong>
<strong>+onion</strong>
<strong>+garlic</strong></pre>
<p>No, fortunately! The <kbd>git reset HEAD</kbd> command won't destroy your modification; it only moves away them from the staging area, so they will not be part of the next commit.</p>
<p>The following figure shows a quick summary of <kbd>git diff</kbd> different behaviors:</p>
<div><img height="244" width="260" src="img/0e8a66c7-9317-47fb-8777-0206751c5d8c.png"/></div>
<p>Now imagine that we completely messed up: the modification we did to the <kbd>shoppingList.txt</kbd> file is wrong (in fact they are, no tasty fruit salad with onion and garlic), so we need to undo them.</p>
<p>The command for that is <kbd>git checkout -- &lt;file&gt;</kbd>, as Git gently reminds in <kbd>the git status</kbd> output message. Give it a try:</p>
<pre><strong>[20] ~/grocery (master)</strong>
<strong>$ git checkout -- shoppingList.txt</strong></pre>
<p>Check the status:</p>
<pre><strong>[21] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>nothing to commit, working tree clean</strong></pre>
<p>Check the content of the file:</p>
<pre><strong>[22] ~/grocery (master)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong>
<strong>peach</strong></pre>
<p>That's it! We actually removed onion and garlic from the shopping list file. But be aware: we lost them! As those modifications were only in the working tree, there's no way to reclaim them, so be careful: <kbd>git checkout --</kbd> is a <kbd>destructive</kbd> command, use it carefully.</p>
<p>Other than this, we need to remember that <kbd>git checkout</kbd> overwrites even the staging area; as per the preceding figure, working tree and <kbd>HEAD</kbd> commit are in direct relationship: changes always go through the staging area. Later we will grasp this concept better while delving into <kbd>git reset</kbd> options.</p>
<p>At this point you maybe have noticed here we used <kbd>git reset</kbd> and <kbd>git checkout</kbd> commands in a different way than we did in the preceding sections, and this is true.</p>
<p>At the beginning, this can be a little confusing for the newcomers, because mentally you cannot associate a single command to a single operation as it can be used to do more than one. For example, you cannot say, <em>git checkout is for branch switching</em> (or for commit inspection, going to a detaching <kbd>HEAD</kbd> state), as it can be used even to discard changes in a working tree, as we just did.</p>
<p>The trick you can use to differentiate the two variations for these commands is to take into account that double-dash <kbd>--</kbd> notation. So, you can remember <em>git checkout is for switching branches</em> and <em>git checkout -- is for discarding local changes</em>.</p>
<p>This is <kbd>true</kbd> even for the <kbd>git reset</kbd> command; in fact, do a <kbd>git reset -- &lt;file&gt;</kbd> is actually the same as doing a <kbd>git reset HEAD &lt;file&gt;</kbd>.</p>
<p>To be true, the double-dash <kbd>--</kbd> notation is not mandatory; if you do a <kbd>git checkout &lt;file&gt;</kbd> or <kbd>git reset &lt;file&gt;</kbd> without <kbd>--</kbd>, in 99% of cases Git does what you expect. The double-dash is needed when, due to a coincidence, there is a file and a branch with the same name: in that case, Git has to know if you want to deal with branches, for example switching to another one with <kbd>git checkout</kbd>, or if you want to manage files. In this situation, the double-dash is the way to tell Git <em>I want to handle files, not branches</em>.</p>
<p>The following figure summarizes the commands to move changes between those three areas:</p>
<div><img height="205" width="488" src="img/7aa9ce86-1772-40a9-97c2-f5ea48dd5f4e.png"/></div>
<p>Now it's time to complete our cultural baggage about file status lifecycle within a repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">File status lifecycle</h1>
                
            
            
                
<p>In a Git repository, files pass through some different states. When you first create a file in the working tree, Git notices it and tells you there's a new untracked file; let's try to create a new <kbd>file.txt</kbd> in our <kbd>grocery</kbd> repository and see the output of <kbd>git status</kbd>:</p>
<pre><strong>[23] ~/grocery (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Untracked files:</strong>
<strong>  (use "git add &lt;file&gt;..." to include in what will be committed)</strong>

<strong>file.txt</strong>

<strong>nothing added to commit but untracked files present (use "git add" to track)</strong></pre>
<p>As you can see, Git explicitly says that there's an <strong>untracked</strong> file; an untracked file is basically a new file Git has never seen before.</p>
<p>When you add it, it becomes a <strong>tracked</strong> file.</p>
<p>If you commit the file, then it goes in an <strong>unmodified</strong> state; this means Git knows it, and the current version of the file in the working tree is the same as the one in the <kbd>HEAD</kbd> commit.</p>
<p>If you make some changes, the file goes to a <strong>modified</strong> state.</p>
<p>Adding a modified file to the staging area makes it a <strong>staged</strong> file.</p>
<p>The following figure summarizes these states:</p>
<div><img height="301" width="491" src="img/765544f9-0219-4db1-ad35-15a0ffdcc754.png"/></div>
<p>Knowing this terminology is important to better understand Git messages, and it helps me and you to go smoothly while talking about files in a Git repository.</p>
<p>Now it's time to go a little bit deep with <kbd>git reset</kbd> and <kbd>git checkout</kbd> commands.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">All you need to know about checkout and reset</h1>
                
            
            
                
<p>First of all, we need to do some housekeeping. Go back to the <kbd>grocery</kbd> repository and clean up the working tree; double-check that you are in the <kbd>master</kbd> branch, and then do a <kbd>git reset --hard master</kbd>:</p>
<pre><strong>[24] ~/grocery (master)</strong>
<strong>$ git reset --hard master</strong>
<strong>HEAD is now at 603b9d1 Add a peach</strong></pre>
<p>This allows us to discard all the latest changes and go back to the latest commit on <kbd>master</kbd>, cleaning up even the staging area.</p>
<p>Then, delete the <kbd>bug</kbd> branch we created some time ago; the command to delete a branch is again the <kbd>git branch</kbd> command, this time followed by a <kbd>-d</kbd> option and then the branch name:</p>
<pre><strong>[25] ~/grocery (master)</strong>
<strong>$ git branch -d bug</strong>
<strong>error: The branch 'bug' is not fully merged.</strong>
<strong>If you are sure you want to delete it, run 'git branch -D bug'.</strong></pre>
<p>Okay, Git has an objection. It says the branch is not fully merged, in other words, <em>if you delete it, the commit within it will be lost</em>. No problem, we don't need that commit; so, use the capital <kbd>-D</kbd> option to force the deletion:</p>
<pre><strong>[26] ~/grocery (master)</strong>
<strong>$ git branch -D bug</strong>
<strong>Deleted branch bug (was 07b1858).</strong></pre>
<p>Okay, now we are done, and the repository is in good shape, as the <kbd>git log</kbd> command shows:</p>
<pre><strong>[27] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 603b9d1 (HEAD -&gt; master) Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Git checkout overwrites all the tree areas</h1>
                
            
            
                
<p>Now switch to the <kbd>melons</kbd> branch using the <kbd>git checkout</kbd> command:</p>
<pre><strong>[28] ~/grocery (master)</strong>
<strong>$ git checkout melons</strong>
<strong>Switched to branch 'melons'</strong></pre>
<p>Check the log:</p>
<pre><strong>[29] ~/grocery (melons)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 603b9d1 (master) Add a peach</strong>
<strong>| * a8c6219 (HEAD -&gt; melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, what happened?</p>
<p>Git took the tip commit in the <kbd>melons</kbd> branch, analyzed it, and then rebuilt the snapshot the commit represents into our working tree. It basically copied all those files and folders into the staging area and then into the working tree.</p>
<p>Remember that <kbd>git checkout</kbd> can destroy changes in your working tree; in fact, if you have some local modification Git will block you.</p>
<p>We can try it; add a <kbd>potato</kbd> to the shopping list file:</p>
<pre><strong>[30] ~/grocery (melons)</strong>
<strong>$ echo "potato" &gt;&gt; shoppingList.txt</strong></pre>
<p>Then checkout <kbd>master</kbd>:</p>
<pre><strong>[31] ~/grocery (melons)</strong>
<strong>$ git checkout master</strong>
<strong>error: Your local changes to the following files would be overwritten by checkout:</strong>
<strong>shoppingList.txt</strong>
<strong>Please commit your changes or stash them before you switch branches.</strong>
<strong>Aborting</strong></pre>
<p>As you can see, you cannot switch branch if you are not in a clean state.</p>
<p>Now please remove the potato from the shopping list file, by an editor or by Git (I leave this to you as an exercise).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git reset can be hard, soft, or mixed</h1>
                
            
            
                
<p>Finally, you will see what <kbd>git reset --hard</kbd> means, and what are the other reset options that we have.</p>
<p>To avoid messing up our repo again, go into a detached <kbd>HEAD</kbd> state, so at the end it will be easier to throw all the things away. To do this, checkout directly the penultimate commit on the <kbd>master</kbd> branch:</p>
<pre><strong>[32] ~/grocery (master)</strong>
<strong>$ git checkout HEAD~1</strong>
<strong>Note: checking out 'HEAD~1'.</strong>

<strong>You are in 'detached HEAD' state. You can look around, make experimental</strong>
<strong>changes and commit them, and you can discard any commits you make in this</strong>
<strong>state without impacting any branches by performing another checkout.</strong>

<strong>If you want to create a new branch to retain commits you create, you may</strong>
<strong>do so (now or later) by using -b with the checkout command again. Example:</strong>

<strong>  git checkout -b &lt;new-branch-name&gt;</strong>

<strong>HEAD is now at 0e8b5cf... Add an orange</strong></pre>
<p>Okay, this is the content of the <kbd>shoppingList.txt</kbd> file in this commit:</p>
<pre><strong>[33] ~/grocery ((0e8b5cf...))</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong></pre>
<p>Now just replicate the <kbd>onion</kbd> and <kbd>garlic</kbd> situation we used before: append an <kbd>onion</kbd> to the file and add it to the staging area, and then add a <kbd>garlic</kbd>:</p>
<pre><strong>[34] ~/grocery ((0e8b5cf...))</strong>
<strong>$ echo "onion" &gt;&gt; shoppingList.txt</strong>

<strong>[35] ~/grocery ((0e8b5cf...))</strong>
<strong>$ git add shoppingList.txt</strong>

<strong>[36] ~/grocery ((0e8b5cf...))</strong>
<strong>$ echo "garlic" &gt;&gt; shoppingList.txt</strong>

<strong>[37] ~/grocery ((0e8b5cf...))</strong>
<strong>$ git status</strong>
<strong>HEAD detached at 0e8b5cf</strong>
<strong>Changes to be committed:</strong>
<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>

<strong>modified:   shoppingList.txt</strong>

<strong>Changes not staged for commit:</strong>
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>

<strong>modified:   shoppingList.txt</strong></pre>
<p>Now use the <kbd>git diff</kbd> command to be sure we are in the situation we desire; check the differences with the staging area:</p>
<pre><strong>[38] ~/grocery ((0e8b5cf...))</strong>
<strong>$ git diff --cached HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index edc9072..063aa2f 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -1,3 +1,4 @@</strong>
<strong> banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong>+onion</strong></pre>
<p>Check the differences between the working tree and <kbd>HEAD</kbd> commit:</p>
<pre><strong>[39] ~/grocery ((0e8b5cf...))</strong>
<strong>$ git diff HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index edc9072..93dcf0e 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -1,3 +1,5 @@</strong>
<strong> banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong>+onion</strong>
<strong>+garlic</strong></pre>
<p>Okay, we have a <kbd>HEAD</kbd> commit with only fruits, and then a staging area with an onion more and working tree with a garlic more.</p>
<p>Now try to do a <strong>soft reset</strong> to the <kbd>master</kbd> branch, with the <kbd>git reset --soft master</kbd> command:</p>
<pre><strong>[40] ~/grocery ((0e8b5cf...))</strong>
<strong>$ git reset --soft master</strong></pre>
<p>Diff to the staging area:</p>
<pre><strong>[41] ~/grocery ((603b9d1...))</strong>
<strong>$ git diff --cached HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index 175eeef..063aa2f 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -1,4 +1,4 @@</strong>
<strong> banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong>-peach</strong>
<strong>+onion</strong></pre>
<p>What did Git do? It basically moved the <kbd>HEAD</kbd> reference to the last commit in the <kbd>master</kbd> branch, the <kbd>603b9d1</kbd>. Small break: note as when in detached <kbd>HEAD</kbd> state, even if you reset to a commit with a branch label, Git continues to reference directly the commit, not the branch.</p>
<p>Okay, having done this, now the differences between the <kbd>HEAD</kbd> commit and staging area are those we see in the output: the peach that was part of the <kbd>shoppingList.txt</kbd> file in the <kbd>HEAD</kbd> commit is not part of the currently staged <kbd>shoppingList.txt</kbd> file, so Git marks a <kbd>peach</kbd> text line in red with a preceding minus, to tell you <em>actually this line has been deleted</em>, while the <kbd>onion</kbd> one has been added.</p>
<p>The same is if you compare the <kbd>HEAD</kbd> commit with a working tree:</p>
<pre><strong>[42] ~/grocery ((603b9d1...))</strong>
<strong>$ git diff HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index 175eeef..93dcf0e 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -1,4 +1,5 @@</strong>
<strong> banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong>-peach</strong>
<strong>+onion</strong>
<strong>+garlic</strong></pre>
<p>In this case, Git even notes that two new lines have been added, <kbd>onion</kbd> and <kbd>garlic</kbd>.</p>
<p>This soft-reset technique can help you quickly compare changes between two commits, as it only overwrites the <kbd>HEAD</kbd> commit area.</p>
<p>Another option is the <strong>mixed reset</strong>; you can do it using the <kbd>--mixed</kbd> option (or simply using no options, as this is the default):</p>
<pre><strong>[43] ~/grocery ((603b9d1...))</strong>
<strong>$ git reset --mixed master</strong>
<strong>Unstaged changes after reset:</strong>
<strong>M   shoppingList.txt</strong></pre>
<p>Okay, there's something different here: Git tells us about unstaged changes. In fact, the <kbd>--mixed</kbd> option makes Git overwrite even the staging area, not only the <kbd>HEAD</kbd> commit. If you check differences between the <kbd>HEAD</kbd> commit and staging area with <kbd>git diff</kbd>, you will see that there are no differences:</p>
<pre><strong>[44] ~/grocery ((603b9d1...))</strong>
<strong>$ git diff --cached HEAD</strong></pre>
<p>Instead, differences arise between the <kbd>HEAD</kbd> commit and working tree:</p>
<pre><strong>[45] ~/grocery ((603b9d1...))</strong>
<strong>$ git diff HEAD</strong>
<strong>diff --git a/shoppingList.txt b/shoppingList.txt</strong>
<strong>index 175eeef..93dcf0e 100644</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@ -1,4 +1,5 @@</strong>
<strong> banana</strong>
<strong> apple</strong>
<strong> orange</strong>
<strong>-peach</strong>
<strong>+onion</strong>
<strong>+garlic</strong></pre>
<p>This mixed-reset technique can be useful, for example, to clean up all the staged changes in one shot, with a simple <kbd>git reset HEAD</kbd>.</p>
<p>At this point, you can presume what is the purpose of the <kbd>--hard</kbd> option: it overwrites all the three areas:</p>
<pre><strong>[46] ~/grocery ((603b9d1...))</strong>
<strong>$ git reset --hard master</strong>
<strong>HEAD is now at 603b9d1 Add a peach</strong>

<strong>[47] ~/grocery ((603b9d1...))</strong>
<strong>$ git diff --cached HEAD</strong>

<strong>[48] ~/grocery ((603b9d1...))</strong>
<strong>$ git diff HEAD</strong></pre>
<p>In fact, now there are no differences at any level.</p>
<p>This hard-reset technique is used to completely discard all the changes we did, with a <kbd>git reset --hard HEAD</kbd> command, as we did in our previous experiments.</p>
<p>We are done. Now we know a little more about both the <kbd>git checkout</kbd> and <kbd>git reset</kbd> command; but before leaving, go back in a non-detached <kbd>HEAD</kbd> state, checking out the <kbd>master</kbd> branch:</p>
<pre><strong>[49] ~/grocery ((603b9d1...))</strong>
<strong>$ git checkout master</strong>
<strong>Switched to branch 'master'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rebasing</h1>
                
            
            
                
<p>Now I want to tell you something about the <kbd>git rebase</kbd> command; a <strong>rebase</strong> is a common term while using a versioning system, and even in Git this is a hot topic.</p>
<p>Basically, with <kbd>git rebase</kbd> you <strong>rewrite history</strong>; with this statement, I mean you can use rebase command to achieve the following:</p>
<ul>
<li>Combine two or more commits into a new one</li>
<li>Discard a previous commit you did</li>
<li>Change the starting point of a branch, split it, and much more</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Reassembling commits</h1>
                
            
            
                
<p>One of the widest uses of the <kbd>git rebase</kbd> command is for reordering or combining commits. For this first approach, imagine you have to combine two different commits.</p>
<p>Suppose we erroneously added half a grape in the <kbd>shoppingList.txt</kbd> file, then the other half, but at the end we want to have only one commit for the entire grape; follow me with these steps.</p>
<p>Add a <kbd>gr</kbd> to the shopping list file:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ echo -n "gr" &gt;&gt; shoppingList.txt</strong></pre>
<p>The <kbd>-n</kbd> option is for not adding a new line.</p>
<p>Cat the file to be sure:</p>
<pre><strong>[2] ~/grocery (master)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong>
<strong>peach</strong>
<strong>gr</strong></pre>
<p>Now perform the first commit:</p>
<pre><strong>[3] ~/grocery (master)</strong>
<strong>$ git commit -am "Add half a grape"</strong>
<strong>[master edac12c] Add half a grape</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Okay, we have a commit with half a grape. Go on and add the other half, <kbd>ape</kbd>:</p>
<pre><strong>[4] ~/grocery (master)</strong>
<strong>$ echo -n "ape" &gt;&gt; shoppingList.txt</strong></pre>
<p>Check the file:</p>
<pre><strong>[5] ~/grocery (master)</strong>
<strong>$ cat shoppingList.txt</strong>
<strong>banana</strong>
<strong>apple</strong>
<strong>orange</strong>
<strong>peach</strong>
<strong>grape</strong></pre>
<p>Perform the second commit:</p>
<pre><strong>[6] ~/grocery (master)</strong>
<strong>$ git commit -am "Add the other half of the grape"</strong>
<strong>[master 4142ad9] Add the other half of the grape</strong>
<strong> 1 file changed, 1 insertion(+), 1 deletion(-)</strong></pre>
<p>Check the log:</p>
<pre><strong>[7] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 4142ad9 (HEAD -&gt; master) Add the other half of the grape</strong>
<strong>* edac12c Add half a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Well, this is inconvenient: I'd like to have only a commit with the entire <kbd>grape</kbd>.</p>
<p>We can repair the mistake with an <strong>interactive rebase</strong>. To do this, we have to rebase the last two commits, creating a new one that is, in fact, the sum of the two.</p>
<p>So, type <kbd>git rebase -i HEAD~2</kbd> and see what happen; <kbd>-i</kbd> means <em>interactive</em>, while the <kbd>HEAD~2</kbd> argument means <em>I want to rebase the last two commits</em>.</p>
<p>This is a screenshot of the console:</p>
<div><img height="363" width="503" src="img/6c3b58b3-d761-44d9-a2c6-06def3d85f88.png"/></div>
<p>As you can see in the preceding screenshot, Git opens the default editor, Vim. Then it tells us how to edit this temporary file (you can see the location at the bottom of the screenshot) using some commented lines (those starting with <kbd>#</kbd>).</p>
<p>Let's read this message carefully.</p>
<p>Here we can reorder the commit lines; doing only this, we basically change the order of commits in our repository. Maybe this can seem a not-so-useful feature, but it can be so if you plan to create new branches after this rebase and you want to clear the ground before.</p>
<p>Then you can delete lines: if you delete a line, basically you drop the corresponding commit.</p>
<p>Finally, for every line (every commit), you can use one of the following commands, as per the comments showed in the Vi editor:</p>
<ul>
<li><strong># p, pick = use commit</strong>: If you pick a commit, the commit will continue to be part of your repo. Think at it as, <em>Okay, I want to preserve this commit as is</em>.</li>
<li><strong># r, reword = use commit, but edit the commit message</strong>: Reword allows you to change the commit message, useful if you realized you wrote something wrong in it. It's kind of, <em>Okay, I want to preserve this commit, but I want to change the message</em>.</li>
<li><strong># e, edit = use commit, but stop for amending</strong>: When you amend a commit you basically want to reassemble it. For example, you forgot to include a file in it, or you added one too many. If you mark a commit to be edited, Git will stop the subsequent rebase operations to let you do what you need. So, the commit will be preserved, but it will be altered.</li>
<li><strong># s, squash = use commit, but meld into previous commit</strong>: Squash is a term we will see again; it basically means put together two commits or more. In this case, if you squash a commit, it will be removed, but the changes within it will be part of the preceding commit. This is maybe the command we need?</li>
<li><strong># f, fixup = like "squash", but discard this commit's log message</strong>: Fixup is like squash, but let's provide you with a new commit message. This is definitely what I need; as I want the new <kbd>grape</kbd> commit to have a new message.</li>
<li><strong># x, exec = run command (the rest of the line) using shell</strong>: Exec is, well, advanced stuff. You basically tell Git to run a particular command when it will manipulate this commit during the following rebase actions. This can be useful to do something you forgot between two commits, rerun some tests, or whatever.</li>
<li><strong># d, drop = remove commit</strong>: Drop simply removes the commit, the same as deleting the entire line.</li>
</ul>
<p>Okay, now we can proceed. We have to modify this file using those commands, and then save it and exit: Git will then continue the rebase process executing every command in order, from top to bottom.</p>
<p>To resolve our issue, I will <em>reword</em> the first commit and then <em>fixup</em> the second; the following is a screenshot of my console:</p>
<div><img height="299" width="414" src="img/17444bdb-82fd-422e-b472-548ee5187224.png"/></div>
<p>Note that you can use the long format of the command or the short one (for example, <kbd>f -&gt;</kbd> short, fixup <kbd>-&gt;</kbd> long).</p>
<p>Okay, now Git does the work and then opens a new temporary file to allow us to write the new message for the commit we decided to reword, that is, the first one. The following is the screenshot:</p>
<div><img height="229" width="412" src="img/a0dd0337-87a3-4c40-a7dd-7186152eead4.png"/></div>
<p>Note as Git tell us word for word what it is going to do.</p>
<p>Now edit the message, and then save and exit, like in the following screenshot:</p>
<div><img height="240" width="432" src="img/aabe28e4-58ff-4834-b2c7-9aef6c1ae508.png"/></div>
<p>Press <kbd>ENTER</kbd> and we're done.</p>
<p>This is the final message from Git:</p>
<pre><strong>[8] ~/grocery (master)</strong>
<strong>$ git rebase -i HEAD~2</strong>
<strong>unix2dos: converting file C:/Users/san/Google Drive/Packt/PortableGit/home/grocery/[detached HEAD 53c73dd] Add a grape</strong>
<strong> Date: Sat Aug 26 14:00:58 2017 +0200</strong>
<strong> 1 file changed, 1 insertion(+)</strong>
<strong>Successfully rebased and updated refs/heads/master.</strong></pre>
<p>Take a look at the log:</p>
<pre><strong>[9] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 6409527 (HEAD -&gt; master) Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Wonderful! We just accomplished our mission.</p>
<p>Now let's make a little experiment on rebasing branches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rebasing branches</h1>
                
            
            
                
<p>With the <kbd>git rebase</kbd> command you can also modify the story of branches; one of the things you do more often inside a repository is to change - or better to say - move the point where a branch started, bringing it to another point of the tree. This operation makes it possible to keep low the level of ramifications that would instead be generated using the command <kbd>git merge</kbd>, which we will see later.</p>
<p>In order to better understand this, let me give you an example.</p>
<p>Let's imagine that to the commit where the orange was added, a branch <kbd>nuts</kbd> was created in the past, to which a walnut was added.</p>
<p>At this point, let's imagine that we want to move this branch above, to the point where it is now <kbd>master</kbd> as if this branch had been created starting from there and not from the orange commit.</p>
<p>Let's see how this can be achieved using the <kbd>git rebase</kbd> command.</p>
<p>Let's start by creating a new branch that points to commit <kbd>0e8b5cf</kbd>, the orange one:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ git branch nuts 0e8b5cf</strong></pre>
<p>This time I used the <kbd>git branch</kbd> command followed by two arguments, the name of the branch and the commit where to stick the label. As a result, a new <kbd>nuts</kbd> branch has been created:</p>
<pre><strong>[2] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 6409527 (HEAD -&gt; master) Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf (nuts) Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Move <kbd>HEAD</kbd> to the new branch with the <kbd>git checkout</kbd> command:</p>
<pre><strong>[3] ~/grocery (master)</strong>
<strong>$ git checkout nuts</strong>
<strong>Switched to branch 'nuts'</strong></pre>
<p>Okay, now it's time to add a <kbd>walnut</kbd>; add it to the <kbd>shoppingList.txt</kbd> file:</p>
<pre><strong>[4] ~/grocery (nuts)</strong>
<strong>$ echo "walnut" &gt;&gt; shoppingList.txt</strong></pre>
<p>Then do the commit:</p>
<pre><strong>[5] ~/grocery (nuts)</strong>
<strong>$ git commit -am "Add a walnut"</strong>
<strong>[master 3d3ae9c] Add a walnut</strong>
<strong> 1 file changed, 1 insertion(+), 1 deletion(-)</strong></pre>
<p>Check the log:</p>
<pre><strong>[6] ~/grocery (nuts)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 9a52383 (HEAD -&gt; nuts) Add a walnut</strong>
<strong>| * 6409527 (master) Add a grape</strong>
<strong>| * 603b9d1 Add a peach</strong>
<strong>|/</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>As you can see, the graph is now a little bit more complicated; starting from the <kbd>orange</kbd> commit, there are three branches: the <kbd>berries</kbd>, the <kbd>master</kbd>, and the <kbd>nuts</kbd> ones.</p>
<p>Now we want to move the <kbd>nuts</kbd> branch starting point, form an orange commit to a <kbd>grape</kbd> commit, as if the <kbd>nuts</kbd> branch is just one commit next to the <kbd>master</kbd>.</p>
<p>Let's do it, rebasing the <kbd>nuts</kbd> branch on top of <kbd>master</kbd>; double-check that you actually are in the <kbd>nuts</kbd> branch, as a rebase command basically rebases the current branch (<kbd>nuts</kbd>) to the target one, <kbd>master</kbd>; so:</p>
<pre><strong>[7] ~/grocery (nuts)</strong>
<strong>$ git rebase master</strong>
<strong>First, rewinding head to replay your work on top of it...</strong>
<strong>Applying: Add a walnut</strong>
<strong>Using index info to reconstruct a base tree...</strong>
<strong>M   shoppingList.txt</strong>
<strong>Falling back to patching base and 3-way merge...</strong>
<strong>Auto-merging shoppingList.txt</strong>
<strong>CONFLICT (content): Merge conflict in shoppingList.txt</strong>
<strong>Patch failed at 0001 Add a walnut</strong>
<strong>The copy of the patch that failed is found in: .git/rebase-apply/patch</strong>

<strong>When you have resolved this problem, run "git rebase --continue".</strong>
<strong>If you prefer to skip this patch, run "git rebase --skip" instead.</strong>
<strong>To check out the original branch and stop rebasing, run "git rebase --abort".</strong>

<strong>error: Failed to merge in the changes.</strong></pre>
<p>Okay, don't be scared: the rebase failed, but that's not a problem. In fact, it failed because Git cannot merge differences between <kbd>shoppingList.txt</kbd> file versions automatically.</p>
<p>Read the message: Now you have three choices:</p>
<ol>
<li>Fix the merge conflicts and then continue, with <kbd>git rebase -continue.</kbd></li>
<li>Skip this step, and discard the modification using <kbd>git rebase -skip.</kbd></li>
<li>Abort the rebase, using <kbd>git rebase -abort.</kbd></li>
</ol>
<p>We will choose the first option, but I want to tell you something about the second and third ones.</p>
<p>While rebasing, Git internally creates patches and applies them to the commits we are moving; in fact, while rebasing a branch you actually move all its commits on top of another commit of choice, in this case the last commit on the <kbd>master</kbd> branch.</p>
<p>In this case, the <kbd>nuts</kbd> branch has only one commit, so Git compared the destination commit (the grape commit on <kbd>master</kbd>) with a walnut commit on the <kbd>nuts</kbd> branch. At the end, only one comparing and patching step will be necessary (this is the meaning of the <kbd>REBASE 1/1</kbd> message on the console: you are rebasing commit 1 of 1 total commits to rebase).</p>
<p>That being said, you can now understand what <kbd>git rebase --skip</kbd> means: if you find the current patching step not useful nor necessary, you can skip it and move on to the next one.</p>
<p>Finally, with <kbd>git rebase --abort</kbd> you simply stop the current rebase operation, backing to the previous pre-rebase situation.</p>
<p>Now, back to our repository; if you open the file with Vim, you can see the generated conflict:</p>
<pre><strong>[8] ~/grocery (nuts|REBASE 1/1)</strong>
<strong>$ vi shoppingList.txt</strong></pre>
<div><img height="207" width="474" src="img/cf8277b3-82eb-4c16-9171-ad489b64c34a.png"/></div>
<p>Walnut has been added at line 4, but in the <kbd>master</kbd> branch, that line is occupied by the peach, and then there's a <kbd>grape</kbd>.</p>
<p>I will fix it adding the <kbd>walnut</kbd> at the end of the file:</p>
<div><img src="img/95de9c5a-c0be-45a1-8320-365519b5ac09.png"/></div>
<p>Now, the next step is to <kbd>git add</kbd> the <kbd>shoppingList.txt</kbd> file to the staging area, and then go on with the <kbd>git rebase --continue</kbd> command, as the previous message suggested:</p>
<pre><strong>[9] ~/grocery (nuts|REBASE 1/1)</strong>
<strong>$ git add shoppingList.txt</strong>

<strong>[10] ~/grocery (nuts|REBASE 1/1)</strong>
<strong>$ git rebase --continue</strong>
<strong>Applying: Add a walnut</strong>

<strong>[11] ~/grocery (nuts)</strong>
<strong>$</strong></pre>
<p>As you can see, after the <kbd>git rebase --continue</kbd> command, the rebase ends successfully (no errors and no more <kbd>REBASE</kbd> message in shell prompt at step <kbd>[11]</kbd>).</p>
<p>Now take a look at the repo using <kbd>git log</kbd> as usual:</p>
<pre><strong>[12] ~/grocery (nuts)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 383d95d (HEAD -&gt; nuts) Add a walnut</strong>
<strong>* 6409527 (master) Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Well done! The <kbd>nuts</kbd> branch is now just a commit beyond the <kbd>master</kbd> one.</p>
<p>Okay, now to keep the simplest and most compact repository, we cancel the <kbd>walnut</kbd> commit and put everything back in place as it was before this little experiment, even removing the <kbd>nuts</kbd> branch:</p>
<pre><strong>[13] ~/grocery (nuts)</strong>
<strong>$ git reset --hard HEAD^</strong>
<strong>HEAD is now at 6409527 Add a grape</strong>

<strong>[14] ~/grocery (nuts)</strong>
<strong>$ git checkout master</strong>
<strong>Switched to branch 'master'</strong>

<strong>[15] ~/grocery (master)</strong>
<strong>$ git branch -d nuts</strong>
<strong>Deleted branch nuts (was 6409527).</strong></pre>
<p>Well done.</p>
<p>Rebasing is a wide and fairly complex topic; we would need another entire chapter (or book) to tell everything about it, but this is basically what we need to know about rewriting history.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Merging branches</h1>
                
            
            
                
<p>Yes, I know, probably there's a thought on your mind since we start playing with branches: <em>why he doesn't talk about merging?</em>.</p>
<p>Now the moment has arrived.</p>
<p>In Git, merging two (or more!) branches is the act of making their personal history meet each other. When they meet, two things can happen:</p>
<ul>
<li>Files in their tip commit are different, so some conflict will rise</li>
<li>Files do not conflict</li>
<li>Commits of the target branch are directly behind commits of the branch we are merging, so a fast-forward will happen</li>
</ul>
<p>In the first two cases, Git will guide us assembling a new commit, a so-called <strong>merge commit</strong>; in the fast-forward case instead, no new commit is needed: Git will simply move the target branch label to the tip commit of the branch we are merging.</p>
<p>Let's give it a try.</p>
<p>We can try to merge the <kbd>melons</kbd> branch into the <kbd>master</kbd> one; to do so, you have to check out the target branch, <kbd>master</kbd> in this case, and then fire a <kbd>git merge &lt;branch name&gt;</kbd> command; as I'm already on the <kbd>master</kbd> branch, I go straight with the <kbd>merge</kbd> command:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ git merge melons</strong>
<strong>Auto-merging shoppingList.txt</strong>
<strong>CONFLICT (content): Merge conflict in shoppingList.txt</strong>
<strong>Automatic merge failed; fix conflicts and then commit the result.</strong></pre>
<p>Uh-oh, conflicts here. Git always tries to auto-merge a file (it uses complex algorithms to reduce your manual work on files), but if you're in doubt, pretend you fix the issues by hand.</p>
<p>See the conflict with <kbd>git diff</kbd>:</p>
<pre><strong>[2] ~/grocery (master|MERGING)</strong>
<strong>$ git diff</strong>
<strong>diff --cc shoppingList.txt</strong>
<strong>index 862debc,7786024..0000000</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@@ -1,5 -1,5 +1,10 @@@</strong>
<strong>  banana</strong>
<strong>  apple</strong>
<strong>  orange</strong>
<strong>++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</strong>
<strong> +peach</strong>
<strong>- grape</strong>

<strong>++grape</strong>
<strong>++=======</strong>
<strong>+ blackberry</strong>
<strong>+ watermelon</strong>
<strong>++&gt;&gt;&gt;&gt;&gt;&gt;&gt; melons</strong></pre>
<p>Okay, it's clear that the fourth and fifth line of our <kbd>shoppingList.txt</kbd> diverged in the two branches: in <kbd>master</kbd>, they are occupied respectively by <kbd>peach</kbd> and <kbd>grape</kbd>, in the <kbd>melons</kbd> branch the place is taken by <kbd>blackberry</kbd> and <kbd>watermelon</kbd>.</p>
<p>Note the shell prompt: it has that <kbd>MERGING</kbd> word after the branch name to remind us that we are in the middle of a merge. Instead, don't mind the <kbd>- grape ++grape</kbd> part: it is a due line ending mismatch between my Windows computer and the GNU/Linux Git subsystem.</p>
<p>To resolve the merge, you have to edit the file accordingly, and then add and commit it; let's go.</p>
<p>I will edit the file enqueuing <kbd>blackberry</kbd> and <kbd>watermelon</kbd> after <kbd>peach</kbd> and <kbd>grape</kbd>, as per the following screenshot:</p>
<div><img src="img/86e857bb-9653-4a83-a1a2-cd60e09c73f1.png"/></div>
<p>After saving the file, add it to the staging area and then commit:</p>
<pre><strong>[3] ~/grocery (master|MERGING)</strong>
<strong>$ git add shoppingList.txt</strong>

<strong>[4] ~/grocery (master|MERGING)</strong>
<strong>$ git commit -m "Merged melons branch into master"</strong>
<strong>[master e18a921] Merged melons branch into master</strong></pre>
<p>The commit is done, and the merge is finished. Perfect!</p>
<p>Now take a look at the log:</p>
<pre><strong>[5] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>*   e18a921 (HEAD -&gt; master) Merged melons branch into master</strong>
<strong>|\</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>* | 6409527 Add a grape</strong>
<strong>* | 603b9d1 Add a peach</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Wow, that's cool!</p>
<p>Look at the green path, the one on the right: this is now the new history of the <kbd>master</kbd> branch. It starts from the beginning, the banana commit, goes to <kbd>apple</kbd>, <kbd>orange</kbd>, and then to <kbd>peach</kbd>, <kbd>grape</kbd>, <kbd>blackberry</kbd>, and the <kbd>watermelon</kbd> commit.</p>
<p>The tip commit on the <kbd>master</kbd> branch is the merge commit, the result of the merge. Can you tell how Git is able to draw this graph?</p>
<p>Suggestion: look at the merge commit with <kbd>git cat-file -p</kbd>:</p>
<pre><strong>[6] ~/grocery (master)</strong>
<strong>$ git cat-file -p HEAD</strong>
<strong>tree 2916dd995ee356351c9b49a5071051575c070e5f</strong>
<strong>parent 6409527a1f06d0bbe680d461666ef8b137ac7135</strong>
<strong>parent a8c62190fb1c54d1034db78a87562733a6e3629c</strong>
<strong>author Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1503754221 +0200</strong>
<strong>committer Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 1503754221 +0200</strong>

<strong>Merged melons branch into master</strong></pre>
<p>A-ha! This commit has <strong>two parents</strong>! In fact, this is the result of the merge of two previous commits, and this is how Git handles merges. Storing the two parents inside the commit, Git can keep track of the merge, and use the information to draw the graph and let you remember, even after years, when and how you merged two branches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fast forwarding</h1>
                
            
            
                
<p>A merge not always generates a new commit; to test this case, try to merge the <kbd>melons</kbd> branch into a <kbd>berries</kbd> one:</p>
<pre><strong>[7] ~/grocery (master)</strong>
<strong>$ git checkout berries</strong>
<strong>Switched to branch 'berries'</strong>

<strong>[8] ~/grocery (berries)</strong>
<strong>$ git merge melons</strong>
<strong>Updating ef6c382..a8c6219</strong>
<strong>Fast-forward</strong>
<strong> shoppingList.txt | 1 +</strong>
<strong> 1 file changed, 1 insertion(+)</strong>

<strong>[9] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>*   e18a921 (master) Merged melons branch into master</strong>
<strong>|\</strong>
<strong>| * a8c6219 (HEAD -&gt; berries, melons) Add a watermelon</strong>
<strong>| * ef6c382 Add a blackberry</strong>
<strong>* | 6409527 Add a grape</strong>
<strong>* | 603b9d1 Add a peach</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>As <kbd>melons</kbd> contained only a commit more than the <kbd>berries</kbd> branch, and as it changes between the two are not in conflict, doing a merge here is just a matter of a second: Git only needs to move the <kbd>berries</kbd> label to the same tip commit of the <kbd>melons</kbd> branch.</p>
<p>This is called <strong>fast-forwarding</strong>.</p>
<p>This time there's no merge commit, as it is not necessary; someone will argue that in this manner you lose the information that tells you when two branches have been merged. If you want to force Git always create a new merge commit, you can use the <kbd>--no-ff</kbd> (no fast-forward) option.</p>
<p>Wanna try? Okay, good chance to make another exercise.</p>
<p>Move back the <kbd>berries</kbd> branch where it was using <kbd>git reset</kbd>:</p>
<pre><strong>[10] ~/grocery (berries)</strong>
<strong>$ git reset --hard HEAD^</strong>
<strong>HEAD is now at ef6c382 Add a blackberry</strong>

<strong>[11] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>*   e18a921 (master) Merged melons branch into master</strong>
<strong>|\</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (HEAD -&gt; berries) Add a blackberry</strong>
<strong>* | 6409527 Add a grape</strong>
<strong>* | 603b9d1 Add a peach</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>We have just undone a merge, did you realize it?</p>
<p>Okay, now do the merge again with the <kbd>--no-ff</kbd> option:</p>
<pre><strong>[12] ~/grocery (berries)</strong>
<strong>$ git merge --no-ff melons</strong></pre>
<p>Git will now open your default editor to allow you to specify a commit message, as shown in the following screenshot:</p>
<div><img src="img/dc6314d3-748b-4263-a060-aeae22a7dfb4.png"/></div>
<p>As you can see, when Git can automatically merge the changes, it does; it then asks you for a commit message, suggesting a default one.</p>
<p>Accept the default message, save and exit:</p>
<pre><strong>[13] ~/grocery (berries)</strong>
<strong>Merge made by the 'recursive' strategy.--all</strong>
<strong> shoppingList.txt | 1 +</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Merge done.</p>
<p>Git tells us what merging strategy is adopted for the automatic merge, and then what changed in terms of files and changes to them (insertions or deletions).</p>
<p>Now a <kbd>git log</kbd>:</p>
<pre><strong>[14] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>*   cb912b2 (HEAD -&gt; berries) Merge branch 'melons' into berries</strong>
<strong>|\</strong>
<strong>| | *   e18a921 (master) Merged melons branch into master</strong>
<strong>| | |\</strong>
<strong>| | |/</strong>
<strong>| |/|</strong>
<strong>| * | a8c6219 (melons) Add a watermelon</strong>
<strong>|/ /</strong>
<strong>* | ef6c382 Add a blackberry</strong>
<strong>| * 6409527 Add a grape</strong>
<strong>| * 603b9d1 Add a peach</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, now the graph highlights the merge between the two branches. As you can see, the graph is a little bit more complicated now, and this is why doing a fast-forward merge is normally preferable: it ends with a more compact and simple repository structure.</p>
<p>We are done with these experiments; anyway, I want to undo this merge, because I want to keep the repository as simple as possible to allow you to better understand the exercise we do together; go with a <kbd>git reset --hard HEAD^</kbd>:</p>
<pre><strong>[15] ~/grocery (berries)</strong>
<strong>$ git reset --hard HEAD^</strong>
<strong>HEAD is now at ef6c382 Add a blackberry</strong>


<strong>[16] ~/grocery (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>*   e18a921 (master) Merged melons branch into master</strong>
<strong>|\</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (HEAD -&gt; berries) Add a blackberry</strong>
<strong>* | 6409527 Add a grape</strong>
<strong>* | 603b9d1 Add a peach</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, now undo even the past merge we did on the <kbd>master</kbd> branch:</p>
<pre><strong>[17] ~/grocery (master)</strong>
<strong>$ git reset --hard HEAD^</strong>
<strong>HEAD is now at 6409527 Add a grape</strong>

<strong>[18] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 6409527 (HEAD -&gt; master) Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>I'm sure you get the point now: undoing a merge in Git is easy. I wanted to show you this more and more because sometimes merging branches is scaring; after doing it, sometimes you realize you messed up your project, and you go out of mind. Instead, don't worry about it: recovering from this situation is simple.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cherry picking</h1>
                
            
            
                
<p>Sometimes you don't want to merge two branches, but simply your desire is to apply the same changes in a commit on top to another branch. This situation is very common when working on bugs: you fix a bug in a branch, and then you want to apply the same fix on top of another branch.</p>
<p>Git has a convenient way to do it; this is the <kbd>git cherry-pick</kbd> command.</p>
<p>Let's play with it a little bit.</p>
<p>Assume you want to pick the <kbd>blackberry</kbd> from the <kbd>berries</kbd> branch, and then apply it into the <kbd>master</kbd> branch; this is the way:</p>
<pre><strong>[1] ~/grocery (master)</strong>
<strong>$ git cherry-pick ef6c382</strong>
<strong>error: could not apply ef6c382... Add a blackberry</strong>
<strong>hint: after resolving the conflicts, mark the corrected paths</strong>
<strong>hint: with 'git add &lt;paths&gt;' or 'git rm &lt;paths&gt;'</strong>
<strong>hint: and commit the result with 'git commit'</strong></pre>
<p>For the argument, you usually specify the hash of the commit you want to pick; in this case, as that commit is referenced even by the <kbd>berries</kbd> branch label, doing a <kbd>git cherry-pick berries</kbd> would have been the same.</p>
<p>Okay, the cherry pick raised a conflict, of course:</p>
<pre><strong>[2] ~/grocery (master|CHERRY-PICKING)</strong>
<strong>$ git diff</strong>
<strong>diff --cc shoppingList.txt</strong>
<strong>index 862debc,b05b25f..0000000</strong>
<strong>--- a/shoppingList.txt</strong>
<strong>+++ b/shoppingList.txt</strong>
<strong>@@@ -1,5 -1,4 +1,9 @@@</strong>
<strong>  banana</strong>
<strong>  apple</strong>
<strong>  orange</strong>
<strong>++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</strong>
<strong> +peach</strong>
<strong>- grape</strong>
<strong>++grape</strong>
<strong>++=======</strong>
<strong>+ blackberry</strong>
<strong>++&gt;&gt;&gt;&gt;&gt;&gt;&gt; ef6c382... Add a blackberry</strong></pre>
<p>The fourth line of both the <kbd>shoppingList.txt</kbd> file versions has been modified with different fruits. Resolve the conflict and then add a commit:</p>
<pre><strong>[3] ~/grocery (master|CHERRY-PICKING)</strong>
<strong>$ vi shoppingList.txt</strong></pre>
<p>The following is a screenshot of my Vim console, and the files are arranged as I like:</p>
<div><img src="img/47c3e1ba-8bf7-48b9-a0f3-fa5842f76cc3.png"/></div>
<pre><strong>[4] ~/grocery (master|CHERRY-PICKING)</strong>
<strong>$ git add shoppingList.txt</strong>

<strong>[5] ~/grocery (master|CHERRY-PICKING)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>You are currently cherry-picking commit ef6c382.</strong>
<strong>  (all conflicts fixed: run "git cherry-pick --continue")</strong>
<strong>  (use "git cherry-pick --abort" to cancel the cherry-pick operation)</strong>

<strong>Changes to be committed:</strong>

<strong>modified:   shoppingList.txt</strong></pre>
<p>Note the <kbd>git status</kbd> output: you always have some suggestions; in this case, to abort a <kbd>cherry-pick</kbd> and undo all you did, you can do a <kbd>git cherry-pick --abort</kbd> (you can do the same even while rebasing or merging).</p>
<p>Now go on and commit:</p>
<pre><strong>[6] ~/grocery (master)</strong>
<strong>$ git commit -m "Add a cherry-picked blackberry"</strong>
<strong>On branch master</strong>
<strong>nothing to commit, working tree clean</strong>

<strong>[7] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 99dd471 (HEAD -&gt; master) Add a cherry-picked blackberry</strong>
<strong>* 6409527 Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (melons) Add a watermelon</strong>
<strong>| * ef6c382 (berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Okay, as you can see a new commit appeared, but there are no new paths in the graph. Unlike the merging feature, with cherry-picking you only pick changes made inside the specified commit, and no relationship will be stored between the cherry-picked commit and the new one created.</p>
<p>If you want to track what was the commit you cherry-picked, you can append the <kbd>-x</kbd> option to the <kbd>git cherry-pick</kbd> command; then, while committing, don't append the message in the <kbd>git commit</kbd> command using the <kbd>-m</kbd> option, but type <kbd>git commit</kbd> and then press <kbd>ENTER</kbd> to allow Git to open the editor: it will suggest you a message that contains the hash of the cherry-picked commit, as you can see in the following screenshot:</p>
<div><img height="411" width="488" src="img/ebae889b-b086-45c0-9a24-bd918685c9bd.png"/></div>
<p>This is the only way to track a cherry pick, if you want.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This has been a very long chapter, I know.</p>
<p>But now I think you know all you need to work proficiently with Git, at least in your own local repository. You know about working tree, staging area, and <kbd>HEAD</kbd> commit; you know about references as branches and <kbd>HEAD</kbd>; you know how to merge rebase, and cherry pick; and finally, you know how Git works under the hood, and this will help you from here on out.</p>
<p>In the next chapter, we will learn how to deal with <strong>remotes</strong>, and pushing and pulling changes from a server such as GitHub.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>