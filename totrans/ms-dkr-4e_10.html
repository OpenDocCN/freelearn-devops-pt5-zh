<html><head></head><body><div><div><p id="_idParaDest-185" class="chapter-number"><a id="_idTextAnchor277"/><em class="italic">Chapter 10</em></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor278"/>Running Docker in Public Clouds</h1>
			<p>So far, we have been using Digital Ocean to launch containers on a cloud-based infrastructure. In this chapter, we will look at the container solutions offered by <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), Microsoft Azure, and Google Cloud. </p>
			<p>Before we talk about these container services, we will also go into a little bit of the history behind each one of the cloud providers and cover the installation of any of the command-line tools required to launch the container services.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>AWS</li>
				<li>Microsoft Azure</li>
				<li>Google Cloud Run</li>
			</ul>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor279"/>Technical requirements</h1>
			<p>In this chapter, we will be using AWS, Microsoft Azure, and Google Cloud, so if you are following along, you will need active accounts with one or all of them. </p>
			<p>Don't forget that if you are following along, there may be charges for the services you launch in public cloud providers – please ensure that you terminate resources when you have finished with them to avoid any unexpected costs.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor280"/>Amazon Web Services</h1>
			<p>The first of the<a id="_idIndexMarker711"/> public cloud providers we are going to be looking at in this chapter is AWS. It was first launched in July 2002 as an internal service used within Amazon to provide a few disparate services to support the Amazon retail site. A year or so later, an internal presentation at Amazon laid the groundwork for what AWS was to become: a standardized and completely automated compute infrastructure to support Amazon's vision of a web-based retail platform.</p>
			<p>At the end of the presentation, it was mentioned that Amazon could possibly sell access to some of the services AWS had to offer to help fund the infrastructure investment required to get<a id="_idIndexMarker712"/> the platform off the ground. In late 2004, the first of these public services was launched – <strong class="bold">Amazon Simple Queue Service</strong> (<strong class="bold">Amazon SQS</strong>), a distributed message queuing service. Around this time, Amazon started work on services that it <a id="_idIndexMarker713"/>could consume for the retail site and services it could sell to the public.</p>
			<p>In 2006, AWS <a id="_idIndexMarker714"/>was relaunched, and Amazon SQS<a id="_idIndexMarker715"/> was joined by <strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">Amazon S3</strong>) and <strong class="bold">Amazon Elastic Compute Cloud</strong> (<strong class="bold">Amazon EC2</strong>), and from there, AWS's popularity grew. At the time of writing, AWS has an annual revenue of over $25 billion and the number of services offered as part of the platform has grown from the original 3 to over 210.</p>
			<p>These <a id="_idIndexMarker716"/>services include <strong class="bold">Amazon Elastic Container Registry</strong> (<strong class="bold">Amazon ECR</strong>), which we looked at in <a href="B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 3</em></a>, <em class="italic">Storing and Distributing Images</em>, <strong class="bold">Amazon Elastic Container Service</strong> (<strong class="bold">Amazon ECS</strong>), and <strong class="bold">AWS Fargate</strong>. While<a id="_idIndexMarker717"/> these last two services are actually designed to <a id="_idIndexMarker718"/>work together, let's take a quick look at what options were available for using Amazon ECS before Amazon introduced AWS Fargate.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor281"/>Amazon ECS – EC2-backed</h2>
			<p>Amazon ECS is<a id="_idIndexMarker719"/> described by Amazon as follows:</p>
			<p class="author-quote">"A highly scalable, fast, container management service that makes it easy to run, stop, and manage Docker containers on a cluster."</p>
			<p>In essence, it allows you to manage the placement and availability of Docker containers on a cluster of compute resources before you launch your first ECS cluster. Let's quickly have a look at some of the terminology involved and get an idea of how it is going to hang together. When we launch our Amazon ECS-hosted application, we will need to define the following:</p>
			<ul>
				<li>Containers</li>
				<li>Tasks</li>
				<li>Services</li>
				<li>Clusters</li>
			</ul>
			<p>The following diagram will give you an idea of how the preceding elements are going to be utilized within our cluster; you can clearly see the containers, tasks, and the service, which in this diagram, is the box that spans the three instances:</p>
			<div><div><img src="img/Figure_10.01_B15659.jpg" alt="Figure 10.1 – Amazon ECS container instances&#13;&#10;" width="1286" height="381"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Amazon ECS container instances</p>
			<p>The important<a id="_idIndexMarker720"/> difference between the preceding diagram and if we were going to be using AWS Fargate is the fact that we are running<a id="_idIndexMarker721"/> container instances. To launch a cluster of EC2 instances, do the following:</p>
			<ol>
				<li>Open up the AWS console at <a href="https://console.aws.amazon.com/">https://console.aws.amazon.com/</a>.</li>
				<li>Sign in. </li>
				<li>Select <strong class="bold">ECS</strong> in the <strong class="bold">Services</strong> menu in the top-left corner of the page. </li>
				<li>Once you have the Amazon ECS page open, select your preferred region in the region switcher in the top-right corner – as I am based in the UK, I have chosen <strong class="bold">London</strong>.</li>
				<li>Click on <strong class="bold">Clusters</strong>, which is the first entry in the left-hand menu:<div><img src="img/Figure_10.02_B15659.jpg" alt="Figure 10.2 – Creating Amazon ECS Clusters&#13;&#10;" width="1384" height="652"/></div><p class="figure-caption">Figure 10.2 – Creating Amazon ECS Clusters</p></li>
				<li>Click the <strong class="bold">Create Cluster</strong> button and you will be presented with three options:<p><strong class="bold">Networking only</strong></p><p><strong class="bold">EC2 Linux + Networking</strong></p><p><strong class="bold">EC2 Windows + Networking</strong></p></li>
				<li>As we are<a id="_idIndexMarker722"/> going to be launching an AWS Fargate cluster next and our test application is Linux-based, select <strong class="bold">EC2 Linux + Networking</strong> and then on the <strong class="bold">Next Step</strong> button at the bottom of the options, and you should find yourself on the <strong class="bold">Configure cluster</strong> page.</li>
				<li>We need to name our cluster. A cluster name is a unique name; I have called mine <code>RussTestECSCluster</code>.</li>
				<li>Leave the <code>1</code> to <code>3</code>; when using spot instances, it is important that you have more than 1 instance to maintain a basic level of availability.</p><p><strong class="bold">EC2 Ami Id</strong>: This option can't be changed.</p><p><strong class="bold">EBS storage (GiB)</strong>: I left this at the default, <strong class="bold">22GB</strong>.</p><p><strong class="bold">Key pair</strong>: I left this as <strong class="bold">None - Unable to SSH</strong>.</p></li>
				<li>For <strong class="bold">Networking</strong>, <strong class="bold">Container instance IAM role</strong>, <strong class="bold">Spot Fleet IAM role</strong>, and <strong class="bold">Tags</strong>, I left everything at their defaults before finally reaching the very last option, <strong class="bold">CloudWatch Container Insights</strong>, I ticked the box for <strong class="bold">Enable Container Insights</strong>. Once everything's filled in, click on the <strong class="bold">Create</strong> button. Once clicked, your cluster will be launched, and you can track the progress as resources are configured and launched:<div><img src="img/Figure_10.03_B15659.jpg" alt="Figure 10.3 – Launcing the ECS cluster&#13;&#10;" width="1003" height="1158"/></div><p class="figure-caption">Figure 10.3 – Launcing the ECS cluster</p></li>
				<li>Once <a id="_idIndexMarker724"/>it's launched, you can click on the <strong class="bold">View cluster</strong> button, which will take you the following screen:<div><img src="img/Figure_10.04_B15659.jpg" alt="Figure. 10.4 – Looking at the ECS cluster&#13;&#10;" width="1530" height="999"/></div><p class="figure-caption">Figure 10.4 – Looking at the ECS cluster</p></li>
				<li>Now that we have a <a id="_idIndexMarker725"/>cluster, we need to create a task definition. To do this, click on <strong class="bold">Task Definitions</strong> in the left-hand menu and then click on the <strong class="bold">Create new Task Definition</strong> button. The first option we are presented with asks which launch type we want to use. We have just created an EC2-based cluster, so select <strong class="bold">EC2</strong>:<div><img src="img/Figure_10.05_B15659.jpg" alt="Figure 10.5 – Select which type of task we need&#13;&#10;" width="1650" height="625"/></div><p class="figure-caption">Figure 10.5 – Select which type of task we need</p></li>
				<li>Once <a id="_idIndexMarker726"/>selected, click on the <code>cluster-task</code>.</p><p><code>1gb</code>.</p><p><code>1 vcpu</code>.</p></li>
				<li>This brings us down to the container definitions. As a task definition is a collection of containers, you can enter multiple containers here. In this example, we are going to add a single container. To start, click on <code>cluster-container</code>.</p><p><code>russmckendrick/cluster:latest</code>.</p><p><code>128</code>.</p><p><code>80</code> for the <code>tcp</code>. </p></li>
				<li>Leave the <a id="_idIndexMarker727"/>remainder of the form at the default settings and then click on <strong class="bold">Add</strong>.</li>
				<li>The final part of the task definition we need to define is <code>cluster-task</code>, leave <strong class="bold">Volume type</strong> as <strong class="bold">Bind month</strong> and <strong class="bold">Source path</strong> empty, and then click on the <strong class="bold">Add</strong> button. Now, click on <strong class="bold">Create</strong> and then return to the cluster via the left-hand <strong class="bold">Clusters</strong> menu.</li>
				<li>Now that we have our cluster, and our task definition, we can create a service. To do this within the <code>cluster-service</code>.</p><p><strong class="bold">Service Type</strong>: Leave this as <strong class="bold">REPLICA</strong>.</p><p><strong class="bold">Number of tasks</strong>: Enter 2.</p><p><strong class="bold">Minimum healthy percent</strong>: Leave at <strong class="bold">100</strong>.</p><p><strong class="bold">Maximum percent</strong>: Leave at <strong class="bold">200</strong>.</p></li>
				<li>Leave the <strong class="bold">Deployments</strong> and <strong class="bold">Task Placement</strong> options at the defaults and click <a id="_idIndexMarker728"/>on the <strong class="bold">Next step</strong> button at the bottom of the page, which will take you to the <strong class="bold">Configure network</strong> page:<p><strong class="bold">Load balancer type</strong>: Select <strong class="bold">None</strong>.</p><p><strong class="bold"> Enable service discovery integration</strong>: Untick this option.</p></li>
				<li>Click on <strong class="bold">Next step</strong> and leave <strong class="bold">Service Auto Scaling</strong> on the default <strong class="bold">Do not adjust the service's desired count</strong> option, and then click on <strong class="bold">Next Step</strong>. After reviewing the options, click on the <strong class="bold">Create Service</strong> button.</li>
				<li>Before we open our running container, we need to open the firewall rules. To do this, select <code>30000-60000</code>.</p><p><code>0.0.0.0/0</code>.</p><p><code>Container ports</code>.</p></li>
				<li>Then, click on the <strong class="bold">Save Rules</strong> button. This should leave you with something like the following:<div><img src="img/Figure_10.06_B15659.jpg" alt="Figure 10.6 – Updating the security group rules&#13;&#10;" width="1650" height="731"/></div><p class="figure-caption">Figure 10.6 – Updating the security group rules</p></li>
				<li>Once you<a id="_idIndexMarker729"/> have set the rule, return to your ECS cluster, click on the <strong class="bold">Tasks</strong> tab, then select one of the two running tasks. Once the task overview place loads, scroll down to the container and extend the container listed in the table, and then click on the external link. This will take you straight to the running container:</li>
			</ol>
			<div><div><img src="img/Figure_10.07_B15659.jpg" alt="Figure 10.7 – Our working application&#13;&#10;" width="1575" height="866"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Our working application</p>
			<p>Now that you<a id="_idIndexMarker730"/> have seen the running container, let's remove the cluster. To do this, go to the cluster overview page and click on the <strong class="bold">Delete Cluster</strong> button in the top-right corner – from there, follow the on-screen instructions.</p>
			<p>Now that was the old way of launching containers sort-of nativity in AWS; I say sort of because we are still starting EC2 instances to power our cluster, and even though we used spot instances, we had a lot of unused resources that we would have been paying for – what if we could just launch containers and not have worry about managing a bunch of EC2 resources?</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor282"/>Amazon ECS – AWS Fargate backed</h2>
			<p>In November 2017, Amazon<a id="_idIndexMarker731"/> announced that they had been working on AWS Fargate – this is a service that is Amazon ECS-compatible and removes the need to launch and manage EC2 instances. Instead, your containers are launched on Amazon's backplane, and you get per-second billing, meaning you only pay for the vCPU and memory that your containerised application requests during its life cycle.</p>
			<p>We are going to cheat slightly and work through the Amazon ECS first-run process. You can access this by going to the following URL: https://console.aws.amazon.com/ecs/home?#/firstRun.</p>
			<p>This will take us through the four steps we need to take to launch a container within a Fargate cluster. The first step in launching our AWS Fargate-hosted container is to configure the container and task definitions:</p>
			<ol>
				<li value="1">For our example, there are three predefined options and a custom option. Click on the <code>cluster-container</code>.</p><p><code>russmckendrick/cluster:latest</code>.</p><p><code>80</code> and leave <code>tcp</code> selected.</p></li>
				<li>Then, click on the <code>cluster-task</code>.</p><p><code>awsvpc</code>; you can't change this option.</p><p><code>ecsTaskExecutionRole</code>.</p><p><code>FARGATE</code> and you should not be able to edit it.</p><p><strong class="bold">Task memory and Task CPU</strong>: Leave both at their default options.</p></li>
				<li>Once everything's updated, click on the <strong class="bold">Save</strong> button. Now, you can click on the <strong class="bold">Next</strong> button at the bottom of the page. This will take us to the second step, which is where the service is defined.</li>
				<li>As we discussed in the previous section, the service runs tasks, which in turn have a container associated with them. The default services are fine, so click on the <strong class="bold">Next</strong> button to proceed to the third step of the launch process. The first step is where the cluster is created. Again, the default values are fine, so click on the <strong class="bold">Next</strong> button <a id="_idIndexMarker733"/>to be taken to the review page.</li>
				<li>This is your last chance to double-check the task, service, and cluster definitions before any services are launched. If you are happy with everything, click on the <strong class="bold">Create</strong> button. From here, you will be taken to a page where you can view the status of the various AWS services that make our AWS Fargate cluster:<div><img src="img/Figure_10.08_B15659.jpg" alt="Figure 10.8 – Launching our Fargate cluster&#13;&#10;" width="1624" height="966"/></div><p class="figure-caption">Figure 10.8 – Launching our Fargate cluster</p></li>
				<li>Once everything has changed from <strong class="bold">pending</strong> to <strong class="bold">complete</strong>, you will be able to click on the <strong class="bold">View service</strong> button to be taken to the <strong class="bold">Service</strong> overview page:<div><img src="img/Figure_10.09_B15659.jpg" alt="Figure 10.9 – Looking at our Fargate cluster&#13;&#10;" width="1585" height="1304"/></div><p class="figure-caption">Figure 10.9 – Looking at our Fargate cluster</p></li>
				<li>Now, we need<a id="_idIndexMarker734"/> to know the public IP address of our container. To find this, click on the <strong class="bold">Task</strong> tab, and then select the unique ID of the running task. In the <strong class="bold">Network</strong> section of the page, you should be able to find both the private and public IP addresses of the tasks. Entering the public IP in your browser should<a id="_idIndexMarker735"/> bring up the now-familiar cluster application:</li>
			</ol>
			<div><div><img src="img/Figure_10.10_B15659.jpg" alt="Figure 10.10 – Our working application&#13;&#10;" width="1635" height="1015"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – Our working application</p>
			<p>You will notice that the container name that's displayed is the hostname of the container, and includes the internal IP address. You can also view the logs from the container by click on the <strong class="bold">Logs</strong> tab:</p>
			<div><div><img src="img/Figure_10.11_B15659.jpg" alt="Figure 10.11 – Viewing the container logs&#13;&#10;" width="1650" height="810"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – Viewing the container logs</p>
			<p>So, how much is<a id="_idIndexMarker736"/> this costing? To be able to run the container for an entire month would cost around $14, which works out at about $0.019 per hour.</p>
			<p>This costing means that if you are going to be running a number of tasks 24/7, then Fargate may not be the most cost-effective way of running your containers. Instead, you may want to take the Amazon ECS EC2 option, where you can pack more containers onto your resource, or the Amazon EKS service, which we will look at later in this chapter. However, for quickly bringing up a container and then terminating it, Fargate is excellent—there is a low barrier to launching the containers and the number of supporting resources is small.</p>
			<p>Once you have finished with your Fargate container, you should delete the cluster. This will remove all of the services associated with the cluster. Once the cluster has been removed, go into the <strong class="bold">Task Definitions</strong> page and deregister them if needed.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor283"/>Summing up AWS</h2>
			<p>In this section of <a id="_idIndexMarker737"/>the chapter, we have only touched on how Amazon ECS works; what we haven't covered is some of the close integration that an Amazon ECS-managed container has with other AWS services, such as <strong class="bold">Elastic Load Balancing</strong>, <strong class="bold">Amazon Cloud Map</strong>, and <strong class="bold">AWS App Mesh</strong>. Also, using the <a id="_idIndexMarker738"/>Amazon<a id="_idIndexMarker739"/> ECS command-line tool, you <a id="_idIndexMarker740"/>can launch your Docker Compose files into an Amazon ECS-managed cluster.</p>
			<p>Now that we <a id="_idIndexMarker741"/>have our AWS basics in place, let's move on to one of its major competitors, Microsoft Azure.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor284"/>Microsoft Azure</h1>
			<p><strong class="bold">Microsoft Azure</strong>, or Windows <a id="_idIndexMarker742"/>Azure as it started life as, is Microsoft's <a id="_idIndexMarker743"/>entry <a id="_idIndexMarker744"/>into the public cloud. It offers a mixture of the <strong class="bold">software as a service</strong> (<strong class="bold">SaaS</strong>), <strong class="bold">platform as a service</strong> (<strong class="bold">PaaS</strong>), and <strong class="bold">infrastructure as a service</strong> (<strong class="bold">IaaS</strong>) services. It began<a id="_idIndexMarker745"/> life as an internal Microsoft project with the codename of <em class="italic">Project Red Dog</em> around 2005. Project Red Dog was a continuation of the <em class="italic">Red Dog OS</em>, which was a fork of the Windows operating system, which was focused on delivering data center services using core Windows components.</p>
			<p>The service that was publicly announced at the Microsoft Developer conference in 2008 was made up of five core services:</p>
			<ul>
				<li>Windows Azure: Allows users to spin up and manage compute instances, storage, and various networking services.</li>
				<li><strong class="bold">Microsoft SQL Data Services</strong>: A cloud <a id="_idIndexMarker746"/>version of the Microsoft SQL database.</li>
				<li><strong class="bold">Microsoft .NET services</strong>: Services that would allow you to deploy your .NET instance to the <a id="_idIndexMarker747"/>cloud without having to worry about instances.</li>
				<li><strong class="bold">Microsoft SharePoint and</strong> <strong class="bold">Microsoft Dynamics services</strong>: These would be SaaS <a id="_idIndexMarker748"/>offerings <a id="_idIndexMarker749"/>of Microsoft's intranet and CRM software.</li>
			</ul>
			<p>It launched in early 2010 to mixed reviews as some people thought it was limited compared to AWS, which by this time had been available for 4 years and was much more mature. However, Microsoft persevered, and over the last 10 years has added numerous services that have moved it way beyond its Windows roots. This promoted the name change from Windows Azure to Microsoft Azure in 2014.</p>
			<p>Since then, Microsoft's cloud has quickly caught up feature-wise with AWS, and depending on which news source you read, is chosen by enterprises to run their cloud workloads <a id="_idIndexMarker750"/>thanks to its tight integration with other Microsoft services, such as <strong class="bold">Microsoft Office</strong> and <strong class="bold">Microsoft 365</strong>.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor285"/>Azure web app for containers</h2>
			<p>Microsoft Azure App<a id="_idIndexMarker751"/> Service is a fully managed platform that allows you to deploy your application and let Azure worry about managing the platform they are running on. There are several options available when launching an app service. You can run applications written in <strong class="bold">.NET</strong>, <strong class="bold">.NET Core</strong>, <strong class="bold">Ruby</strong>, <strong class="bold">Node.js</strong>, <strong class="bold">PHP</strong>, and <strong class="bold">Python</strong>, or you can launch an image directly from a container image registry.</p>
			<p>In this quick walkthrough, we are going to be launching the cluster image from the Docker Hub: </p>
			<ol>
				<li value="1">Log in to the Azure portal at <a href="https://portal.azure.com/">https://portal.azure.com/</a>.</li>
				<li>Select <strong class="bold">App Services</strong> from the left-hand menu, which can be accessed via the burger icon on the top left-hand corner of the screen:<div><img src="img/Figure_10.12_B15659.jpg" alt="Figure 10.12 – Preparing to launch an app service&#13;&#10;" width="1644" height="944"/></div><p class="figure-caption">Figure 10.12 – Preparing to launch an app service</p></li>
				<li>On the page that<a id="_idIndexMarker752"/> loads, click on the <code>Docker Container</code>.</p><p><strong class="bold">Operating System</strong>: Leave as <strong class="bold">Linux</strong>.</p><p><strong class="bold">Region</strong>: Select your preferred region.</p><p><strong class="bold">App Service plan</strong>: By default, a more expensive production-ready plan is selected, so clicking <strong class="bold">Change size</strong> in the <strong class="bold">Sku and size</strong> section will give you options on changing the pricing tier. For our needs, the <strong class="bold">Dev/Test</strong> plan will be fine. </p></li>
				<li>Once you have selected and filled out the preceding options, click on the <code>Single container</code>.</p><p><code>Docker Hub</code> from the dropdown list. This will open up the Docker Hub options below the form.</p><p><code>public</code>.</p><p><code>russmckendrick/cluster:latest</code>.</p><p><strong class="bold">Startup command</strong>: Leave blank.</p></li>
				<li>Once that's all completed, click through the <strong class="bold">Monitoring</strong> and <strong class="bold">Tag</strong> tabs, and then click on the <strong class="bold">Create</strong> button after reviewing the information. After a minute or two, you should be presented with a screen that looks like the following:<div><img src="img/Figure_10.13_B15659.jpg" alt="Figure 10.13 – Deploying the app service&#13;&#10;" width="1649" height="944"/></div><p class="figure-caption">Figure 10.13 – Deploying the app service</p></li>
				<li>Clicking on the <strong class="bold">Go to resource</strong> button <a id="_idIndexMarker754"/>will take you to the newly launched application:</li>
			</ol>
			<div><div><img src="img/Figure_10.14_B15659.jpg" alt="Figure 10.14 – Viewing our running app service&#13;&#10;" width="1650" height="505"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14 – Viewing our running app service</p>
			<p>Now that our application has launched, you should be able to access the service via the URL provided by Azure – for example, mine was <a href="https://masteringdocker4thedition.azurewebsites.net">https://masteringdocker4thedition.azurewebsites.net</a>. Opening this, your browser will display the <a id="_idIndexMarker755"/>cluster application:</p>
			<div><div><img src="img/Figure_10.15_B15659.jpg" alt="Figure 10.15 – Displaying the cluster application&#13;&#10;" width="1624" height="913"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – Displaying the cluster application</p>
			<p>As you can see, this time, we have the container ID, rather than a full hostname as we got when launching the container on AWS Fargate. The container at this spec will cost us around $10 per month.</p>
			<p>There are some other really useful advantages to launching your container as an application, rather <a id="_idIndexMarker756"/>than just a plain old container – for example, you may have noticed that our container URL has an <strong class="bold">SSL certificate</strong> enabled. While it is currently one that covers <a href="http://azurewebsites.net">azurewebsites.net</a>, you can add your own custom domain and provide your own SSL certificate.</p>
			<p>Another handy feature is that you can configure your single container to automatically update itself via a trigger from a webhook. For example, when your new container image has successfully been built, you can find this option on the <strong class="bold">Container settings</strong> page for the<a id="_idIndexMarker757"/> application:</p>
			<div><div><img src="img/Figure_10.16_B15659.jpg" alt="Figure 10.16 – Launching multiple containers&#13;&#10;" width="1542" height="1331"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.16 – Launching multiple containers</p>
			<p>Also, as touched on when we first configured the application, you can use a Docker Compose file to launch multiple containers in your Microsoft Azure web app.</p>
			<p>Once you have finished with the web app, delete it and the resource group, assuming it doesn't contain<a id="_idIndexMarker758"/> any other resources you need.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor286"/>Azure container instances</h2>
			<p>Now that we have<a id="_idIndexMarker759"/> learned how to launch Docker containers in Azure using Azure web apps, let's now look at the Azure Container Instance service. Think of this as being similar in concept to the AWS Fargate service in that it allows you to launch containers directly on, in this case, Microsoft's shared backplane.</p>
			<p>Let's configure a container instance: </p>
			<ol>
				<li value="1">Enter <code>Container instances</code> into the search bar at the top of the screen and then click on the link for the <strong class="bold">Container Instances</strong> service. </li>
				<li>Once the page loads, click on the <code>Public</code>.</p><p><code>russmckendrick/cluster:latest</code>.</p><p><code>Linux</code>.</p><p><code>1GB</code>.</p></li>
				<li>Once you have filled in the information, click on the <code>Yes</code>.</p><p><code>80</code> and <strong class="bold">TCP</strong> configured.</p><p><strong class="bold">DNS name label</strong>: Enter a DNS name for your container.</p></li>
				<li>Skip past the <strong class="bold">Advance</strong> and <strong class="bold">Tags</strong> sections and go straight to <strong class="bold">Review + create</strong>. Once the<a id="_idIndexMarker760"/> validation has passed, click on the <strong class="bold">Create</strong> button:<div><img src="img/Figure_10.17_B15659.jpg" alt="Figure 10.17 – Launching our Azure container instance&#13;&#10;" width="1650" height="901"/></div><p class="figure-caption">Figure 10.17 – Launching our Azure container instance</p></li>
				<li>As before, click on the <strong class="bold">Go to resource</strong> button and you will be taken to the newly created Azure container instance, as you can see in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_10.18_B15659.jpg" alt="Figure 10.18 – An overview of our Azure container instance&#13;&#10;" width="1429" height="1006"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.18 – An overview of our Azure container instance</p>
			<p>There are fewer options <a id="_idIndexMarker761"/>than we had in the web application, and that is because Azure container instances are designed to do just one thing: run containers. </p>
			<p>If you were to click on <code>/bin/sh</code> option:</p>
			<div><div><img src="img/Figure_10.19_B15659.jpg" alt="Figure 10.19 – Opening a session to our Azure container instance&#13;&#10;" width="1641" height="689"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.19 – Opening a session to our Azure container instance</p>
			<p>Entering the URL given in<a id="_idIndexMarker762"/> the overview page into a browser, which in my case was <a href="http://masteringdocker4thedition-aci.uksouth.azurecontainer.io/">http://masteringdocker4thedition-aci.uksouth.azurecontainer.io/</a>, will show you your container app:</p>
			<div><div><img src="img/Figure_10.20_B15659.jpg" alt="Figure 10.20 – Our running application&#13;&#10;" width="1622" height="789"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.20 – Our running application</p>
			<p>As you can see, this <a id="_idIndexMarker763"/>time we have the container ID, which in my case was wk-caas-ca0c275b8f3e4ce2848c5802ee406a13-4e02f5281687aa1e58d98f. You might notice that there is no HTTPS this time, just plain old HTTP on port 80. </p>
			<p>Once you have finished with your Azure container instance, click on <strong class="bold">Delete</strong>, and also remove the resource group if required.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor287"/>Summing up Microsoft Azure</h2>
			<p>While on the face<a id="_idIndexMarker764"/> of it the two services we have looked at in this section appear to quite similar, they are in fact really very different. Microsoft web apps are a managed service offered by Microsoft that is powered by containers. Typically, the container that is launched is for the code that the end user launches. However, when running containers, they end up running Docker in Docker. Azure container instances are just that, your running container – no wrappers or helpers, only vanilla containers.</p>
			<p>We know have a foundation in Microsoft Azure. With Amazon and Microsoft established in the game, it's<a id="_idIndexMarker765"/> no surprise that Google launched its own competitor product. Let's take a look at it in the next section.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor288"/>Google Cloud</h1>
			<p>Of the three majo<a id="_idIndexMarker766"/>r public clouds, <strong class="bold">Google Cloud</strong> is the newest. It started life as Google App Engine in 2008. App Engine was Google's PaaS offering, which supported Java, PHP, Node.js, Python, C#, .Net, Ruby, and Go applications. Unlike AWS and Microsoft Azure, Google remained a PaaS service for over 4 years until it introduced Google Compute Engine.</p>
			<p>We are going to be learning a lot more about Google's journey into the cloud in the next chapter when we start to talk about Kubernetes, so I am not going to go into much more detail here. So, let's jump right in.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor289"/>Google Cloud Run</h2>
			<p>Google Cloud Run<a id="_idIndexMarker767"/> works slightly differently than the other container services we have looked at in this chapter. The first thing we need is to have an image hosted in Google Container Registry to use the service: </p>
			<ol>
				<li value="1">Let's grab a copy of our cluster image from Docker Hub:<pre><strong class="bold">$ docker image pull russmckendrick/cluster</strong></pre></li>
				<li>Now, we need to use the Google Cloud command-line tool to log in to our Google Cloud account. To do this, run the following:<pre><strong class="bold">$ gcloud init</strong></pre></li>
				<li>Once logged in, we can configure Docker to use Google Container Registry by running the following:<pre><strong class="bold">$ gcloud auth configure-docker</strong></pre></li>
				<li>Now that Docker is configured to interact with Google Container Registry, we can run the following commands to create a tag and push our image:<pre><code>masterdocker4</code>; you will need to replace that with your own Google Cloud project name. You <a id="_idIndexMarker768"/>can verify that the image has been pushed by logging in to the Google Cloud console and navigating to Google Container Registry by entering <code>Cloud Registry</code> into the search bar at the top of the page. You should see something like the following:</p><div><img src="img/Figure_10.21_B15659.jpg" alt="Figure 10.21 – Viewing our cluster image in Google Container Registry&#13;&#10;" width="1465" height="631"/></div><p class="figure-caption">Figure 10.21 – Viewing our cluster image in Google Container Registry</p></li>
				<li>Now, in the search bar at the top of the page, enter <code>Cloud Run</code> and follow the link. </li>
				<li>Once the Cloud Run page loads, click on the <strong class="bold">Create Service</strong> button at the top. </li>
				<li>The first thing you need to do is choose which image to use. Click on <strong class="bold">Select</strong> and highlight the <a id="_idIndexMarker769"/>cluster image and then the version of the image you want to use:<div><img src="img/Figure_10.22_B15659.jpg" alt="Figure 10.22 – Selecting the Google Container Registry image&#13;&#10;" width="1650" height="694"/></div><p class="figure-caption">Figure 10.22 – Selecting the Google Container Registry image</p></li>
				<li>Once selected, click on <strong class="bold">CONTINUE</strong>. </li>
				<li>For the deployment platform, we are going to be using <strong class="bold">Cloud Run (fully managed)</strong>. Choose the closest region to you from the drop-down box. </li>
				<li>Next up, we need to name the server – I called mine <code>masteringdocker4cluster</code> – and then tick the <strong class="bold">Allow unauthenticated invocations</strong> radio box. </li>
				<li>As our container listens on port <code>80</code>, we need to update the revision settings as the default is port <code>8080</code>. Clicking on <code>8080</code> to <code>80</code>. </li>
				<li>Once everything is filled in, scroll to the bottom of the page and click on the <strong class="bold">Create</strong> button. After <a id="_idIndexMarker770"/>a short while, you should see something like the following screen:</li>
			</ol>
			<div><div><img src="img/Figure_10.23_B15659.jpg" alt="Figure 10.23 – Viewing our Cloud Run application&#13;&#10;" width="1635" height="839"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.23 – Viewing our Cloud Run application</p>
			<p>As you can see, we have information on our running container, including a URL, which in this case was <a href="https://cluster-5iidnzldtq-ez.a.run.app">https://cluster-5iidnzldtq-ez.a.run.app</a> – opening the URL in a browser shows the following:</p>
			<div><div><img src="img/Figure_10.24_B15659.jpg" alt="Figure 10.24 – Our running application&#13;&#10;" width="1341" height="772"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.24 – Our running application</p>
			<p>This is what we would have expected to have seen; however, there is a difference between how Google Cloud Run and the other services we covered in the AWS and Azure section of this<a id="_idIndexMarker771"/> chapter work. With the other service, our container was running all of the time, but with Google Cloud Run, it only runs when it is needed. Google Cloud Run is built on top of <strong class="bold">Knative</strong>, which is an open source serverless platform designed to<a id="_idIndexMarker772"/> run on top of a Kubernetes, and we have been running our containers on Google's own Kubernetes cluster.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor290"/>Summing up Google Cloud</h2>
			<p>As you may have <a id="_idIndexMarker773"/>guessed, Google is more geared to running Kubernetes-based services, as we have already seen with Google Cloud Run. So, we will revisit Google<a id="_idIndexMarker774"/> Cloud in a later chapter once we have covered Kubernetes in a little more depth.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor291"/>Summary</h1>
			<p>In this chapter, we have looked at how we can deploy our Docker containers into services offered by the three leading public cloud providers using their container-only services. The services we looked at all approach both the deployment and management of containers in very different ways, from the fully managed Docker-based web app in Azure app services to AWS' own clustering service Amazon ECS.</p>
			<p>The differences between all of these services are quite important as it means that if you want to use them, then you are tied to just the one cloud provider. While in most cases, that shouldn't be too much of a problem, it could in the long term end up limiting you. </p>
			<p>In the next chapter (and in subsequent chapters), we will explore one of the most exciting services to arrive on the scene since Docker: Kubernetes.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor292"/>Questions</h1>
			<ol>
				<li value="1">What type of application do we need to launch in Azure?</li>
				<li>What Amazon service don't you have to manage if you're using Amazon Fargate directly?</li>
				<li>True or false: Azure Container Instances comes with HTTPS support out of the box.</li>
				<li>Name the open source service that Google Cloud Run is built on top of.</li>
				<li>Which of the services that we looked at support Docker Compose?</li>
			</ol>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor293"/>Further reading</h1>
			<p>For details on each of the services we have used in this chapter, refer to the following:</p>
			<ul>
				<li>AWS: <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
				<li>Amazon ECS: <a href="https://aws.amazon.com/ecs/">https://aws.amazon.com/ecs/</a></li>
				<li>AWS Fargate: <a href="https://aws.amazon.com/fargate/">https://aws.amazon.com/fargate/</a></li>
				<li>Microsoft Azure: <a href="https://azure.microsoft.com/">https://azure.microsoft.com/</a></li>
				<li>Azure App Service: <a href="https://azure.microsoft.com/en-gb/services/app-service/">https://azure.microsoft.com/en-gb/services/app-service/</a></li>
				<li>Azure Container Instances: <a href="https://azure.microsoft.com/en-gb/services/container-instances/">https://azure.microsoft.com/en-gb/services/container-instances/</a></li>
				<li>Google Cloud: <a href="https://cloud.google.com">https://cloud.google.com</a></li>
				<li>Google Cloud Run: <a href="https://cloud.google.com/run">https://cloud.google.com/run</a></li>
				<li>Knative: <a href="http://knative.dev">http://knative.dev</a></li>
			</ul>
		</div>
	</div>



  </body></html>