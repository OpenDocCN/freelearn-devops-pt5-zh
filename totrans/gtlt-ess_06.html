<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Getting Started with Access Control</h1></div></div></div><p>By now, you know how to add new users to the Gitolite system, as well as how to create new repositories or bring existing repositories into Gitolite control. It's time to tie those together now and look at <em>access control</em>, which is, for most sites, the main reason to install Gitolite.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Basic access control examples</h1></div></div></div><p>The aspect of<a id="id113" class="indexterm"/> access control that first comes to mind, for any Git administrator, is the ability to prevent people from accessing repositories. We'll start with some simple examples before describing the syntax. Here's a very simple set of rules for a repository called <code class="literal">foo</code>:</p><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>  R    =  alice</strong>
<strong>  RW   =  bob</strong>
<strong>  RW+  =  carol</strong>
</pre></div><p>These rules establish what operations Alice, Bob, Carol, and any other Gitolite users are allowed to execute against this repository. As you might guess from the simple R permission given to Alice (or, to put it another way, the lack of a <code class="literal">W</code> in her permission string), she is only allowed to read the repository, which means she can use the <code class="literal">git clone</code>, <code class="literal">git fetch</code>, and <code class="literal">git ls-remote</code> commands, but cannot use <code class="literal">git push</code> in any form.</p><p>Bob and Carol are both allowed to push changes to the repository. As before, you probably guessed this from the <code class="literal">W</code> character in each of their permission lines. What may not be immediately obvious is the significance of the <code class="literal">+</code> character in Carol's permission string. This extra character allows Carol to <em>force</em> a push, that is, push a new object to a ref even if the new object is not a descendant of the old object. This is called a non-fast forward push in Git parlance, and, even in normal Git use (that is, even without an access control system in place), requires explicit action on the user's part in order to succeed. If you're not familiar with this, please consult man <code class="literal">git-push</code> and other Git resources.</p><p>The <code class="literal">+</code> character <a id="id114" class="indexterm"/>was chosen because it is a reminder of the <code class="literal">+</code> you have to use in the <code class="literal">git push</code> command to selectively force-push some refs. (Please refer to the description of the <code class="literal">refspec</code> field in the man page for the <code class="literal">git push</code> command for more details). Although we will not encounter this use case in this chapter, for the sake of completeness, we should also mention that the <code class="literal">+</code> character also allows a user to <em>delete</em> a ref, even though the corresponding syntax in the <code class="literal">git push</code> command does not use a <code class="literal">+</code> sign.</p><p>For a lot of installations, this basic example serves all their needs—namely, to distinguish people who are only allowed to read but not to write, and among those that are allowed to write, prevent some from dangerously force-pushing (or worse, deleting) an important branch or tag.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec29"/>Basic branch level access control</h2></div></div></div><p>The next <a id="id115" class="indexterm"/>example will show another very common need: that of restricting some people (perhaps junior developers or interns) to being able to push only branches in a specific namespace. This is a fairly common situation, where the most important branches (such as master, or maybe next, or whatever your branch naming and workflow uses), can only be changed by trusted developers, who presumably have reviewed the code and found it to be acceptable. Code written by junior developers and/or interns is not deemed to be automatically acceptable, and it is often useful to <em>sandbox</em> them in some way.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>Interestingly, this particular use case appears to be more about developer trust and maturity than about security per se. However, in terms of controlling or preventing such behavior, there is no difference between someone accidentally overwriting the master branch, and someone doing it with malicious intent.</p></div></div><p>Here's an example of an access control rule set that achieves such a restriction:</p><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>  R          =  alice</strong>
<strong>  RW+        =  bob</strong>
<strong>  RW+  dev/  =  carol</strong>
</pre></div><p>This allows Carol to read the repository as well as to push to it, but it prevents her from pushing anything except branches whose names start with <code class="literal">dev/</code>. In contrast, Bob whose access rule does not specify anything after the permission field, can push any branch.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Lexical syntax of the conf file</h1></div></div></div><p>Now that we've seen a<a id="id116" class="indexterm"/> couple of useful, and immediately usable, examples, it is time to look at the <strong>lexical</strong> syntax of the <code class="literal">conf/gitolite.conf</code> file (often called, in Gitolite, <em>the conf file</em>).</p><p>The conf file is a plain text file,<a id="id117" class="indexterm"/> whose overall syntax is governed by a few simple rules.</p><p>Gitolite usernames (in our example, <code class="literal">alice</code>, <code class="literal">bob</code>, and so on) must start with an alphanumeric character, and contain alphanumerics, periods, hyphens, underscores, or the <code class="literal">@</code> sign. If an <code class="literal">@</code> sign is present, it must be followed by a domain name (that is, something that has at least one period in it). This allows e-mail addresses to be used as usernames, which is arguably very useful when you have several John Smith in your organization!</p><p>Repository names must start with an alphanumeric character, and contain alphanumerics, periods, hyphens, underscores, or slashes. However, they must not start with a slash or end with a slash.</p><p>Comments are allowed; the syntax is the same as the shell, perl, and so on. Anything following a <code class="literal">#</code> sign is taken to be a comment and discarded.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>Continuation lines (in the C-style) are not allowed by default. However, by editing the <code class="literal">$HOME/.gitolite.rc</code> file, which we will see in more detail in <a class="link" href="ch07.html" title="Chapter 7. Advanced Access Control and Configuration">Chapter 7</a>, <em>Advanced Access Control and Configuration</em>, you can enable this feature.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>The syntax of access control rules</h1></div></div></div><p>The access control list<a id="id118" class="indexterm"/> has a<a id="id119" class="indexterm"/> simple structure. Briefly, it is structured like this:</p><div><pre class="programlisting">
<strong>repo &lt;one or more repos or repo-groups&gt;</strong>
<strong>    &lt;permission&gt;    &lt;zero or more refexes&gt;  =  &lt;one or more users or user-groups&gt;</strong>
</pre></div><p>A conf file has one or more <code class="literal">repo</code> lines. Each repo line contains the word <code class="literal">repo</code>, followed by one or more repository names or repository-group names (we'll discuss groups later in this chapter). These repository or group names must all be on the same line.</p><p>Each <code class="literal">repo</code> line is followed by one or more <em>access rules</em> that apply to this set of repositories or groups. An access rule consists of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A permission field (for example, R, RW, and so on)</li><li class="listitem" style="list-style-type: disc">Zero or more <em>refexes</em> (refexes are detailed in the next section, but one example refex you have already seen is <code class="literal">dev/</code>)</li><li class="listitem" style="list-style-type: disc">An <code class="literal">=</code> sign to serve as a separator</li><li class="listitem" style="list-style-type: disc">And finally a list of users or user-group names</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Branch level access control and refexes</h1></div></div></div><p>This section will talk <a id="id120" class="indexterm"/>about a very important part of Gitolite—specifying who can make changes to which branch or tag. As a matter of historical interest, the lack of this feature, in what was at that time the most popular tool for Git server administration, was the sole motivation for Gitolite being created.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>This section assumes some familiarity with <em>regular expressions</em>.</p></div></div><p>To understand<a id="id121" class="indexterm"/> branch level access control and how to specify them in Gitolite, we should first have a quick refresher of related concepts in Git itself, to make things easier to understand.</p><p>Git uses the word <code class="literal">ref</code> to refer to both branches and tags. Branch names are usually of the form <code class="literal">refs/heads/something</code>, while tag names are of the form <code class="literal">refs/tags/something</code>. When a user pushes to a Gitolite managed repository, Gitolite helps you determine whether the <em>refs</em> being updated are allowed to be updated by this user or not.</p><p>Thus, to allow Bob to push the branch called master, you might write:</p><div><pre class="programlisting">
<strong>RW+  refs/heads/master  =  bob</strong>
</pre></div><p>When a user pushes to the repository, Git supplies Gitolite with the name of the ref being pushed. Gitolite then matches the ref with each of the refexes in the access rule lines. If there is a match, and the user is also listed on the right side of the <code class="literal">=</code> sign, then the push is allowed.</p><p>However, due to the fact that branches are far more frequently access controlled than tags, Gitolite assumes anything that does not start with <code class="literal">refs/</code> to be prefixed with <code class="literal">refs/heads/</code>. Thus, you can just say:</p><div><pre class="programlisting">
<strong>RW+  master    =  bob</strong>
</pre></div><p>and that would be taken as <code class="literal">refs/heads/master</code>.</p><p>To be strictly accurate, the preceding data allows Bob to push any branch with a  name that starts with <code class="literal">master</code>. To restrict the rule to just <code class="literal">master</code>, you should actually write the refex as <code class="literal">master$</code>. In practice, however, this is rarely required.</p><p>Controlling tags is just as easy. Let us say you want to allow a user to push any tag with a name starts with the letter v, followed by a digit, optionally followed by anything else. Here's the rule for it:</p><div><pre class="programlisting">
<strong>RW+  refs/tags/v[0-9]  =  bob</strong>
</pre></div><p>The regular expression pattern <code class="literal">[0-9]</code> represents the notion of any character between <code class="literal">0</code> and <code class="literal">9</code> inclusive.</p><p>Gitolite anchors<a id="id122" class="indexterm"/> this regex at the beginning only, not at the end. In regex terms, this means a <code class="literal">^</code> character is implicitly added at the start, but a <code class="literal">$</code> character is not added at the end. This allows Bob to push tags like <code class="literal">v1</code>, <code class="literal">v2.2</code>, <code class="literal">v3.4.5</code>, and so on, but not <code class="literal">new-v1</code> and <code class="literal">next-v2</code>.</p><p>Thus we come to the definition of a <em>refex</em>: a refex is a regex (that is, a regular expression) that is used to match the ref being pushed.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec30"/>Using deny rules</h2></div></div></div><p>So far, the <a id="id123" class="indexterm"/>rules we have seen allow you to specify which branches or tags a user is allowed to push. However, we often need to be able to specify, for example, that a user is allowed to push <em>all branches except master</em>.</p><p>To do that, we need to use what Gitolite calls <em>deny</em> rules. Here's how you might implement the above restriction for a user:</p><div><pre class="programlisting">
<strong>-         master    =  bob</strong>
<strong>RW+                 =  bob</strong>
</pre></div><p>Gitolite checks rules in sequence when attempting to determine whether a branch is allowed to be pushed or not. When Bob pushes a branch called <code class="literal">next</code> (that is, <code class="literal">refs/heads/next</code>) to this repository, the first rule does not match at all, since <code class="literal">refs/heads/master</code> is not a pattern that matches the string <code class="literal">refs/heads/next</code>. Gitolite then checks the next rule. Since this rule does not specify a refex, all refs will match, and since the permission field is <code class="literal">RW+</code>, the push is allowed.</p><p>However, when Bob pushes <code class="literal">refs/heads/master</code>, the ref matches the refex in the first rule, and since the rule is a deny rule, the push is denied.</p><p>Observant readers will notice that the sequence of the rules is very important here. Reversing the order of the two rules we looked at would remove the restriction we want to implement. The first rule encountered will be:</p><div><pre class="programlisting">
<strong>RW+      =  bob</strong>
</pre></div><p>This does not specify a refex and thus matches all refs. As a result, the operation is allowed to proceed. In other words, the deny rule is never even checked!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec31"/>The permission field</h2></div></div></div><p>We have now <a id="id124" class="indexterm"/>seen examples of the four most common permissions used in access rules, so it is a good idea to summarize them.</p><p>The <code class="literal">R</code> permission allows the user to read (clone, fetch) the repository, but not push. <code class="literal">RW</code> allows the user to push, but only if it is a fast-forward push or a new branch is being created. Non-fast forward pushes and deletions are not allowed. And <code class="literal">RW+</code> allows non-fast forward pushes and deletions too.</p><p>As long as your rule set contains only these three types of rules, it does not matter which order they appear in. However, as you saw in the previous section, the sequence of rules becomes important when you use the fourth kind of rule—a deny rule, denoted by a single minus sign.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>While these are the most commonly used permissions, they are not all there are. There are a few more permissions which will appear in the section <em>Types of Write Operations</em> in <a class="link" href="ch07.html" title="Chapter 7. Advanced Access Control and Configuration">Chapter 7</a>, <em>Advanced Access Control and Configuration</em>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Defining user and repo groups</h1></div></div></div><p>Gitolite allows <a id="id125" class="indexterm"/>you to define groups of users or repositories for convenience. The syntax is very simple, and<a id="id126" class="indexterm"/> does not distinguish between a user group and a repository group. For example, take a look at the deny rule example in the previous section:</p><div><pre class="programlisting">
<strong>-         master    =  bob</strong>
<strong>RW+                 =  bob</strong>
</pre></div><p>Let's say that, instead of just Bob, you had several more users who must be prevented from pushing the <code class="literal">master</code> branch, perhaps because they are all junior developers. One way is to add each of their usernames on both the rule lines, after Bob's username, like this:</p><div><pre class="programlisting">
<strong>-          master    =  bob carol dave</strong>
<strong>RW+                  =  bob carol dave</strong>
</pre></div><p>But this gets cumbersome, and will only get worse if there are more rules to be applied to the same group of people.</p><p>With groups, however, you can do this:</p><div><pre class="programlisting">
<strong>@junior-devs    =  bob carol dave</strong>

<strong>-          master    =  @junior-devs</strong>
<strong>RW+                  =  @junior-devs</strong>
</pre></div><p>As you can see, this is far more convenient, and also less error-prone. Even more importantly, the<a id="id127" class="indexterm"/> group <a id="id128" class="indexterm"/>name can often serve as important documentation for the ruleset—a future administrator may not know who Bob, Carol, and Dave are, and may puzzle over why they were restricted, but the group name, if chosen well, makes things very clear.</p><p>You can use group names for repositories also, for example:</p><div><pre class="programlisting">
<strong>@foss-repos  =  git linux apache gcc</strong>

<strong>repo @foss-repos</strong>
<strong>  R  =  @all</strong>
</pre></div><p>While in this case it may not look as critical, because the group name is being used to replace only one occurrence of the repository names, it is still a lot cleaner. Also, as with the user group names, the repository group name serves as additional documentation of the nature of those repositories.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec32"/>Working with large groups</h2></div></div></div><p>Sometimes you <a id="id129" class="indexterm"/>need a group which contains several members—far more than can fit on one line comfortably to edit. To make this easier (and because Gitolite does not, by default, allow continuation lines), Gitolite treats every definition of a group as cumulative. This means that if the group was already defined earlier, the new members are added to it rather than replacing the existing member list. This allows you to say:</p><div><pre class="programlisting">
<strong>@foss-repos  =  git</strong>
<strong>@foss-repos  =  linux</strong>
<strong>@foss-repos  =  apache</strong>
</pre></div><p>This would have the same effect as the single line definition we saw earlier in this section.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec33"/>The special @all group</h2></div></div></div><p>Gitolite also <a id="id130" class="indexterm"/>has <a id="id131" class="indexterm"/>a special, built-in group called @all, which refers to all repositories, or all users, depending on where it is used. A common use for this is to allow certain privileged users access to all repositories, perhaps as follows:</p><div><pre class="programlisting">
<strong>repo @all</strong>
<strong>    R            =  @QA-leads</strong>
<strong>    RW+          =  @dev-leads</strong>
</pre></div><p>For another example, let us consider a situation where only Adam and Dave are allowed to push the <code class="literal">master</code> branch. Here's how you might do that:</p><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>    RW+  master         =  adam dave</strong>
<strong>    -         master    =  @all</strong>
</pre></div><p>We have <a id="id132" class="indexterm"/>a <em>deny</em> rule <a id="id133" class="indexterm"/>here, so again, notice that the order of rules is important. If we had placed the <em>deny</em> rule first, then—because Adam and Dave are implicitly members of @all—they would also be denied rights to push the master branch.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>The include statement</h1></div></div></div><p>You can<a id="id134" class="indexterm"/> also split up your access rules and group definitions into multiple files, and <em>include</em> them into the main conf file (<code class="literal">conf/gitolite.conf</code> in your gitolite-admin repository). For example, you can keep all group information (that is, which users are members of which groups) in a separate file and include that. The syntax is very simple; here's an example:</p><div><pre class="programlisting">
<strong>include "groups.conf"</strong>
</pre></div><p>This will look for a file called <code class="literal">groups.conf</code> in the <code class="literal">conf</code> directory and include its contents at that point.</p><p>Advanced users may note that this command also accepts wildcards. For example, you might have several individual conf files in a subdirectory of <code class="literal">conf</code> called <code class="literal">foss</code>. If you don't want to name each of them separately, you can say:</p><div><pre class="programlisting">
<strong>include "foss/*.conf"</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Rule accumulation and delegation</h1></div></div></div><p>Gitolite allows you to split up access rules for repositories into multiple chunks which are not necessarily contiguous. It will then combine all these chunks (in the order they were read) and apply the combined set of rules to the repository in question.</p><p>There's a very good use for this behavior. Combining groups, that include statement, and rule accumulation<a id="id135" class="indexterm"/>, makes Gitolite administration easier than it already is. Here's an example, with some comments, to give you some idea of what can be done.</p><div><pre class="programlisting">
<strong>include "groups.conf"</strong>
<strong># contains definitions of all groups used in the rest of the conf file.  All</strong>
<strong># membership changes happen here</strong>

<strong>include "foss.conf"</strong>
<strong># contains rules for open source repositories.  For example, "R = @all" is</strong>
<strong># pretty much expected for such repositories.  There may be other rules</strong>
<strong># specific to different FOSS repositories that may also be specified here</strong>

<strong>include "boss.conf"</strong>
<strong># contains rules that define what kind of access management has to the</strong>
<strong># development repositories.  For example, some of the managers may have</strong>
<strong># read access to all repositories, so something like</strong>
<strong>#    repo @all</strong>
<strong>#      R  =  scott douglas</strong>
<strong># is probably quite useful.</strong>

<strong># repo-specific rules</strong>
<strong># At this point you could have repository specific rules that do not fit neatly</strong>
<strong># into any of the previous include files.  For example:</strong>
<strong>repo git</strong>
<strong>  RW+  =  linus junio</strong>
</pre></div><p>As you can see, a repository can appear in any or all of the include files that the main conf file pulls in. If we required all the rules for each repository to be in one place, it would be impossible to organize your rules in this sort of manner.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Summary</h1></div></div></div><p>We've now seen most of Gitolite's basic access control features, including various types of access rules, the syntax of the conf file, and some convenient features that make managing this easier. In the next chapter, we will discuss some advanced access control features, such as personal branches and <strong>VREFs</strong>.</p></div></body></html>