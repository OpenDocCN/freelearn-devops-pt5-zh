- en: Chapter 9. Customizing Gitolite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It must be clear by this time that Gitolite is a pretty powerful tool for managing
    Git repositories on a server. The most powerful tools, however, allow the administrator
    to add features that are unique to their site, and thus cannot be expected to
    be added to the product itself. For example, consider Git itself, its *hooks*
    mechanism (see `man githooks` for details) contains several predefined hooks,
    which the user can install on their repositories to customize Git's behavior at
    various points in the lifecycle of a commit, a rebase, a push, and so on. In fact,
    Gitolite's ability to perform branch level access control (as opposed to merely
    repository level access control) is *entirely* done by using Git's `update` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Core and non-core Gitolite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gitolite goes a little further than merely allowing you to customize it for
    your location-specific needs. Gitolite actually *ships* with customizations already
    in place for several optional features. Some of these customizations are enabled
    by default, while others are disabled, though requiring only a quick edit of `$HOME/.gitolite.rc`
    to enable them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, Gitolite makes a distinction between **core** and **non-core**
    Gitolite code. If you happened to look into the Gitolite source tree (under `src`
    if you cloned the Gitolite source code), you will notice several directories at
    the top level, and a couple of files. Of these, gitolite considers the following
    directories to contain non-core code: `commands`, `syntactic-sugar`, `triggers`,
    `lib/Gitolite/Triggers`, and `VREF`. Everything else is considered *core*.'
  prefs: []
  type: TYPE_NORMAL
- en: Making this distinction also helps in deciding whether a new feature is to be
    added or not. If the feature requires change to core Gitolite, a lot more careful
    consideration and thought will go into it, and even then it will only happen if
    the change is really needed by several users. In practice, however, Gitolite's
    customization feature is so powerful that it has become increasingly rare that
    any change to core Gitolite is required.
  prefs: []
  type: TYPE_NORMAL
- en: Types of non-core code and examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gitolite allows four types of customizations you can develop for your site.
    This might sound somewhat intimidating, but in practice most people use only two
    of them. We'll describe each of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gitolite allows remote users to run some specific commands on the server, in
    the form `ssh git@host command-name`. Commands need to be enabled before they
    can be used remotely; see the section on making changes to the `rc` file in [Chapter
    8](ch08.html "Chapter 8. Allowing Users to Create Repos"), *Allowing Users to
    Create Repos*. One way to look at this is to view it as giving users a very restricted
    shell to use, which allows only specific commands to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We've already encountered some Gitolite commands, the `perms` and `D` commands
    in [Chapter 8](ch08.html "Chapter 8. Allowing Users to Create Repos"), *Allowing
    Users to Create Repos*, for instance, and `info` and `help` in earlier chapters.
    Gitolite ships with more than twenty commands, although only five are enabled
    for remote use by default. A few more are listed in `$HOME/.gitolite.rc`, but
    left disabled by being commented out. It only takes a removal of the comment marker
    in the line to enable them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the commands that Gitolite comes with, however, are not meant for remote
    use at all and thus, they are not listed (even in commented out form) in `$HOME/.gitolite.rc`.
    These commands are meant as helpers to server-side scripts or other non-core programs.
    One of the most convenient of these is the `access` command, which has the following
    help message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is of great use in rolling your own code, where you would
    like to check a user's access rights to a repository or several repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Running `gitolite help` on the server will list all available commands; just
    as running `ssh git@host help` will list all commands available *remotely*. In
    addition, Gitolite comes with several commands that are implemented internally
    in Gitolite. They are, in effect, part of the "core". Run `gitolite -h` to get
    a list of them with brief descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: All Gitolite commands respond with a usage message when invoked with a single
    argument of `-h`. If you write your own commands, it would be a good idea to adhere
    to this convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of some of the existing commands in Gitolite with a brief description
    of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`access`: This prints or tests access rights on a repository for a user. This
    is useful when you write your own commands. See the description of the `fork`
    command below for one example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: This lets a user delete a repository that they created (see [Chapter 8](ch08.html
    "Chapter 8. Allowing Users to Create Repos"), *Allowing Users to Create Repos*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`desc`: This shows or sets a description for a user-created repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fork`: This forks a repo on the server. This takes a repository and creates
    a new one with the same content. It checks to make sure the reader has read access
    to the source repository, and is allowed to create the destination repository
    (see [Chapter 8](ch08.html "Chapter 8. Allowing Users to Create Repos"), *Allowing
    Users to Create Repos*). This command uses the `-l` option to `git clone`, so
    it runs really fast. (Without this command, the alternative would be for the user
    to clone the source repository, and then use that to create and push to the destination
    repository. For large repositories, this could take a while).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git-config`: This prints (or tests existence of) ''config'' values in the
    repo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help`: This prints a list of all the available commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: This prints your username, the git/gitolite version numbers, and any
    repositories you have access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`perms`: This lists or sets permissions for a user-created repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a subsequent section, we will see how to create your own commands.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic sugar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntactic sugar scripts are a form of customization that most people will rarely,
    if ever, have to write, or even encounter. They are useful for situations where
    the administrator would like some additional, purely syntax-related feature added
    to Gitolite's access control language. In such situations, a syntactic sugar helper
    script can be written that changes what the administrator writes into something
    Gitolite can parse.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite ships with a few syntactic sugar helper scripts. For example, one is
    to allow C-style continuation lines in Gitolite's `conf` file, since normally
    Gitolite does not allow that. Another is to provide a simple macro facility.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arguably, the most powerful of Gitolite's customization features is the trigger
    feature. Gitolite triggers are the equivalent of Git's hooks. Just as Git provides
    hooks that run at various points (for example, `pre-commit`, `pre-receive`, and
    `post-receive`, to name a few), similarly Gitolite's triggers also run at specific
    points in the lifecycle of a Gitolite managed push or fetch.
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference between Git hooks and Gitolite trigger programs though.
    Git defines several hooks and requires that your hook code be named exactly one
    of those (for example, `post-receive` or `update`). Gitolite on the other hand
    allows you to define a list of trigger programs, which it will invoke in sequence
    when the trigger point is reached. It is only the name of the trigger point that
    is fixed. This also means, of course, that your programs can be called whatever
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: The important trigger points, from a customization point of view, are `INPUT`
    , `POST_CREATE`, and `POST_COMPILE`, although there are several other trigger
    points supported.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of an `INPUT` trigger is to manipulate the input arguments or the
    environment in some way. Since a child program cannot affect the parent's environment,
    `INPUT` triggers need to be written in Perl and installed as modules in `lib/Gitolite/Triggers`
    (as opposed to being plain programs in any language, that are installed in the
    `triggers` directory). Examples of features using the `INPUT` trigger are giving
    some users full shell access and allowing repositories to have aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter will contain references to many non-core features that are out
    of scope for this book. Please refer to Gitolite's online documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: The `POST_CREATE` trigger point is useful to run any housekeeping or reporting
    tasks that need to be performed after a new repository is created. For example,
    Gitolite uses this trigger point to run code that updates the access lists for
    gitweb and git-daemon whenever a user creates a *wild* repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `POST_COMPILE` trigger point helps you perform additional tasks when the
    gitolite-admin repository is pushed. This trigger point is associated with the
    maximum number of programs shipped with Gitolite. Most of them have to do with
    with ssh keys, or updating access lists for gitweb and git-daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual refs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final type of non-core customization available is Gitolite's ability to
    make access decisions based on what Gitolite calls virtual refs. The scripts that
    do this are called `VREFs`; they are complex and important enough to have the
    next chapter be devoted entirely to them.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own non-core code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's reasonably easy to write your own code to add features that are specific
    to your site. For example, suppose we want an e-mail to be sent to the administrator
    every time a developer creates a *wild repositor*y. We will assume that the standard
    Unix utilities exist and are available. In particular, we will assume the Unix
    mail command is available. This command takes the message from standard input,
    and the subject and recipient data from command-line arguments, and sends the
    e-mail, thus suits our purposes very well.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is an action that needs to run when a repository is created, it needs
    to be added to the `POST_CREATE` trigger list. According to the Gitolite documentation,
    when a wild repository is created, each program in the `POST_CREATE` trigger list
    is called with the second argument being the name of the repository that was just
    created, while the third argument is the name of the user who created it. (If
    this is empty, this is not a wild repository creation but a normal repository
    creation; that is, by the administrator adding the repository to the Gitolite
    `conf` file and pushing the change.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, this code could be as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we've written this code, we need to put it somewhere that Gitolite will
    find it and use it at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: We decide to create a new directory called `$HOME/local` to hold all our local
    customizations. In this directory, we add a subdirectory called `triggers`, and
    into this we place this script, naming it `new-repo-alert`. (Don't forget to `chmod
    +x` the script!)
  prefs: []
  type: TYPE_NORMAL
- en: Now, we edit Gitolite's `rc` file`($HOME/.gitolite.rc`). In this file, we find
    a line that defines the `LOCAL_CODE` variable commented out but conveniently pointing
    to precisely where we chose to place our customizations, so we simply uncomment
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the following lines of code immediately after the `LOCAL_CODE`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Did you note the trailing comma after the closing bracket? And that's really
    all you need to do. From now on, any time a user creates a new "wild" repository;
    the `new-repo-alert` script will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: As a second example, we will create a small command. The example we use will
    allow a user to check the size of a repository using the `git count-objects` command.
    Our command will default to running it with the `-v` option because that is the
    most generic and useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, create a directory called `$HOME/local/commands`, and put a script
    called `count-objects` in that directory. Make sure the script is executable (`chmod
    +x`). The code for the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part of this code is not the actual `count-objects` command.
    The most generic, and thus most usable for your needs, is the `gitolite access`
    command, whose usage message we have already seen in an earlier section. Here,
    we are using it to ensure that the user running the command has at least got write
    access to the repository in question before allowing the command to run.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add this command to the list of commands in `rc` file's `ENABLE` list,
    preferably in the `COMMANDS` section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `count-objects` is a harmless command, so it may not need to be protected.
    However, if you then stretch the use case a little and allow the user to start
    a `git gc` operation, or even a `git fsck`, you need to be more careful. Some
    of those commands don't deal well with being run too many times or simultaneously
    by multiple people. Ensure your command does some rate limiting or serializing.
  prefs: []
  type: TYPE_NORMAL
- en: Other commands require arguments to be supplied. If your script takes arguments
    from the user, be sure to sanitize them before running the command. You can undermine
    all of Gitolite's access control with one carelessly written command!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these two examples, the most important aspect of adding
    a new feature to your site is to decide when and how the feature should be invoked—should
    it be a user command, or a trigger that runs at specific points, or perhaps a
    `VREF` that can influence the outcome of the overall command, and so on. In some
    cases, it could even be a combination, for instance, a command and a VREF working
    together. As an extreme example, Gitolite's mirroring feature, which is written
    entirely as non-core code, is implemented as one command, and one Perl module
    is added to each of the `INPUT, PRE_GIT`, and `POST_GIT` trigger lists.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen an introduction to how Gitolite can be customized
    or new features can be added that are specific to your site. This is a fairly
    complex topic, but if you get your hands dirty and start writing programs, you
    will soon get very comfortable with the idea, as well as get a very good feel
    for how powerful the feature actually is.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on `VREF`, a powerful feature for even more fine-grained
    access control, as well as access control based on factors other than what Gitolite
    normally uses.
  prefs: []
  type: TYPE_NORMAL
