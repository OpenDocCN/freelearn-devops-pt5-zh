<html><head></head><body>
		<div><h1 id="_idParaDest-280"><em class="italic"><a id="_idTextAnchor299"/>Chapter 13</em>: Docker Security Fundamentals and Best Practices</h1>
			<p>As we wish to ensure that our containers are hardened for both development and production environments, there are many techniques and best practices we can implement to achieve this task. In many cases, it is simply a case of modifying existing commands or behaviors you've learned throughout this book to add an extra layer of security to your practices.</p>
			<p>Within this chapter, we will be building upon the foundational knowledge we have of Docker and container security. This will involve hands-on exercises in building and modifying containers. Covering subjects as varied as image security through the usage of Docker commands and signed images, upon completing the following exercises, you should feel comfortable in applying these skills in a real-world development and DevOps environment.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li><strong class="bold">Docker image security</strong>: Here, we will learn about image security, including using minimal base images, signed and verified images, and avoiding data leakage.</li>
				<li><code>COPY</code> instead of <code>ADD</code> when building out Docker images.</li>
				<li><strong class="bold">Security around the build process</strong>: Here, we will learn about the best practices for build processes, including multi-stage builds.</li>
			</ul>
			<p>Let's get started by looking at Docker image security and some best practices we can implement.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor300"/>Technical requirements</h1>
			<p>For this chapter, you will need to have access to a Linux machine running Docker. We recommend that you use the setup you have been using so far in this book.</p>
			<p>In addition to this, you will need an account on Docker Hub in order to access images located there. If you have not already set one up, you can do so at <a href="https://hub.docker.com">https://hub.docker.com</a>.</p>
			<p>If you have an existing container or service running SSH, this can be used later in this chapter. If not, do not worry. We provide a link to an example Dockerfile from the official Docker documentation you can use instead if you wish.</p>
			<p>Check out the following video to see the Code in Action:</p>
			<p><a href="https://bit.ly/30WkOPE">https://bit.ly/30WkOPE</a></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor301"/>Docker image security</h1>
			<p>As you have worked through the material in this book, you will have become increasingly familiar with images. These are a fundamental building block in the Docker ecosystem. An image is the <a id="_idIndexMarker1003"/>combination of the filesystem and parameters that, when run by Docker, becomes your container.</p>
			<p>Having made sure Docker itself is patched and secured, that our application code is robust, and that when we run the containers they will have limited privileges, we also want to ensure that the image itself is secure.</p>
			<p>One of the benefits of Docker is that services such as Docker Hub allow us to share and reuse container images. However, we need to be careful that what we are downloading is secure and has not been uploaded by a malicious party:</p>
			<div><div><img src="img/B11641_13_001.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Docker Hub displaying example repositories </p>
			<p>You should always be cautious, however, even with legitimate/official websites.</p>
			<p>There have <a id="_idTextAnchor302"/><a id="_idIndexMarker1004"/>been several cases in the past where malicious images have been uploaded to Docker Hub, with the hope that these will be downloaded by unsuspecting parties. Examples of <a id="_idIndexMarker1005"/>malicious code have included images purporting to be related to <strong class="bold">tomcat</strong>, <strong class="bold">mysql</strong>, and <strong class="bold">cron</strong>. A compromised <a id="_idIndexMarker1006"/>container containing a kernel exploit, for example, could <a id="_idIndexMarker1007"/>lead to an attack on the underlying host. </p>
			<p>Kromtech Security Center in one particular time frame in 2018 found 17 malicious Docker images on Docker Hub. You can read about this situation in their report, <em class="italic">Cryptojacking invades cloud. How modern containerization trend is exploited by attackers</em>, at <a href="https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers">https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers</a>.</p>
			<p>Your first step, therefore, in any project when using third-party tools and code should be to verify that the source of these artifacts is trustworthy. It is also important to stay on top of security alerts to make sure you do not inadvertently download images with damaging flaws.</p>
			<p>In the case <a id="_idIndexMarker1008"/>of Docker images, once you are confident of the validity of origin, you can then add additional verification processes to check the artifact itself is safe. In fact, you may be familiar with this concept with other technologies you use, such as verifying a file integrity hash when downloading an OS.</p>
			<p>One mechanism to help ensure that the source of what we are downloading is legitimate is to use the signed Docker Certified images served from Docker Hub. As we saw with the Kromtech report, we can never be too careful, even with legitimate hosts like Docker Hub. These certified images have been reviewed by the host and certified as authentic. Many popular <a id="_idIndexMarker1009"/>application environments are available on Docker Hub, including the following:</p>
			<ul>
				<li>Splunk Enterprise Edition: <a href="https://hub.docker.com/_/splunk-enterprise">https://hub.docker.com/_/splunk-enterprise</a></li>
				<li>Datadog: <a href="https://hub.docker.com/_/datadog-agent">https://hub.docker.com/_/datadog-agent</a> </li>
				<li>Dynatrace: <a href="https://hub.docker.com/_/dynatrace">https://hub.docker.com/_/dynatrace</a></li>
				<li>Oracle Java 8 SE (Server JRE): <a href="https://hub.docker.com/_/oracle-serverjre-8">https://hub.docker.com/_/oracle-serverjre-8</a></li>
			</ul>
			<p>You can find more at the Docker Hub website here: </p>
			<p><a href="https://hub.docker.com/search?q=&amp;type=image&amp;certification_status=certified">https://hub.docker.com/search?q=&amp;type=image&amp;certification_status=certified</a></p>
			<p>Let's now take a hands-on approach to checking the legitimacy of an image, including interacting with Docker Hub. Load up your command-line tool and then move on to the next section.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor303"/>Image verification</h2>
			<p>The first concept <a id="_idIndexMarker1010"/>we need to understand <a id="_idIndexMarker1011"/>is that of content trust. This is the security model in Docker applied to images.</p>
			<p><strong class="bold">Docker's Content Trust</strong> (<strong class="bold">DCT</strong>) model <a id="_idIndexMarker1012"/>at its heart is a mechanism to use digital signatures to prove the integrity of images hosted on platforms such as Docker Hub. With DCT enabled, users can then ensure they do not pull untrusted images (that is, unsigned images) unless they make explicit exceptions.</p>
			<p>By default, Docker has DCT disabled, which will allow you to pull images without verifying the safety of them. This opens <a id="_idIndexMarker1013"/>you up to the risk of downloading an artifact that is infected with malware or another security vulnerability.</p>
			<p>Thankfully, we can use the <code>DOCKER_CONTENT_TRUST</code> flag to ensure that when we pull an image, it is verified. This works by checking whether the image has been signed by <a id="_idIndexMarker1014"/>its creator or whether we are using an explicit hash associated with an image. To enable it system-wide, include it in your <code>.bashrc</code> file as follows:</p>
			<pre>$ vim /&lt;path&gt;/&lt;to&gt;/.bashrc
export DOCKER_CONTENT_TRUST=1 
:x
$ source /&lt;path&gt;/&lt;to&gt;/.bashrc</pre>
			<p>If, for any reason, you wish to interact with an untagged image, you can temporarily disable the setting by using the <code>--disable-content-trust</code> flag in your command.</p>
			<p>The <code>DOCKER_CONTENT_TRUST</code> flag can be limited to a single shell in addition to system-wide coverage. To quickly enable it in a new shell when you spawn, type the following:</p>
			<pre>$ export DOCKER_CONTENT_TRUST=1 </pre>
			<p>Just remember that when you close the shell, you will need to enable the flag again, or set the system-wide property as explained earlier in the <code>.bashrc</code> file.</p>
			<p>In practice, with this setting enabled system-wide (or in an individual shell), it means that command-line operations that interact with a tagged image will need to have one of two things. These can be either content hashes appended to the image or the image itself will need to be one that has already been signed in advance through the use of signing keys. </p>
			<p class="callout-heading">Signing keys</p>
			<p class="callout">Signing keys are a set of components that are used to sign an image. They consist of an offline key, which forms the basis for DCT to trust an image tag, along with a tagging key for signing tags themselves and finally, a set of server-managed keys for enforcing security guarantees.</p>
			<p>So, from a practical perspective, what exactly does this result in when running commands? Let's see a quick example using the image called <code>shipitclicker</code>.</p>
			<p>If we wish <a id="_idIndexMarker1015"/>to pull the <code>shipitclicker</code> image while the <code>DOCKER_CONTENT_TRUST</code> flag is enabled, we can append a hash to the image using the <code>@</code> symbol. Consider the following, for example:</p>
			<pre>$ docker pull dockerfordevelopers/shipitclicker@sha256:b20caa037ac2c36a9845f719ebb12952bbb3e749d4b05fcdcd8d 38201a7de795</pre>
			<p>As long as the content hash <code>sha256:b20caa037ac2c36a9845f719ebb12952bbb3e749d4b05fcdcd8d382 01a7de795</code> exists, the <a id="_idIndexMarker1016"/>command will succeed. Otherwise, imagine that we wanted to pull the latest version of this image or version number, such as the following, for example:</p>
			<pre>$ docker shipitclicker:v0.1</pre>
			<p>In this scenario, we then would need to ensure that the image had been signed, or the command will fail. The <code>pull</code> command is not the only operation that interacts with trusted content. Others include the following:</p>
			<ul>
				<li><code>$docker push</code></li>
				<li><code>$docker build</code></li>
				<li><code>$docker create</code></li>
				<li><code>$docker run</code></li>
			</ul>
			<p>We can test this out now. We've created the <code>shipitclicker</code> image in advance for you to pull from Docker Hub, located in the Packt Docker book repository at <a href="https://hub.docker.com/r/dockerfordevelopers/shipitclicker">https://hub.docker.com/r/dockerfordevelopers/shipitclicker</a>.</p>
			<p>You can attempt to pull this image using the following command:</p>
			<pre>$ docker pull dockerfordevelopers/shipitclicker:v0.1</pre>
			<p>You should now see a <em class="italic">request denied</em> error similar to the following:</p>
			<pre>Error: remote trust data does not exist for docker.io/ dockerfordevelopers/shipitclicker: notary.docker.io does not have trust data for docker.io/ dockerfordevelopers/shipitclicker</pre>
			<p>Ensuring that this flag is enabled in an automated build process is also a must, as it prevents unverified images from making their way into your environments by accident.</p>
			<p>This very <a id="_idIndexMarker1017"/>simple approach of using DCT can go a long way <a id="_idIndexMarker1018"/>to ensuring you avoid using untrusted content from Docker Hub. Now let's look at the base images a little closer.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor304"/>Using minimal base images</h2>
			<p>So we know <a id="_idIndexMarker1019"/>that we are pulling in signed images or specific hashes, but is there anything we need to consider around the type of image we are using in our containers? The answer to this is <em class="italic">yes</em>.</p>
			<p>You should <a id="_idIndexMarker1020"/>ask yourself when using an image whether the whole OS, complete with all its pre-installed packages, is required? In some cases, this can introduce vulnerabilities, as you may be including unpatched libraries and other code in your container. The best approach, therefore, is to start with something basic and then build up from there. This will help to reduce your overall attack surface.</p>
			<p>Let's grab a minimal image from Docker Hub now so we can work with it throughout the rest of this chapter. The image we are going to use is <code>shipitclicker:v0.1</code>, which we just tested with <code>DOCKER_CONTENT_TRUST</code> and is based on Alpine.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are interested in checking it out and haven't already done so, the Alpine image is only 5 MB in size and is part of the Official Images program on Docker Hub. These are a set of repositories that provide all the essential basics, while also ensuring all security patches are applied regularly. In addition to this, the official Docker images are also signed, so can therefore guarantee some of the security precautions that were just discussed around image verification in this chapter.</p>
			<p>The first thing you will need to do is disable <code>DOCKER_CONTENT_TRUST</code> in your current shell, or grab the hash of the image so that you can now pull it. If you wish to disable <code>DOCKER_CONTENT_TRUST</code>, you can do this via the following command in your current shell:</p>
			<pre>$ export DOCKER_CONTENT_TRUST=0</pre>
			<p>Just remember, if you shut the shell down and create a new one, you will need to run this command again. We recommend you leave the flag set to <code>1</code> and instead pull the hash version.</p>
			<p>You can find the hash under the <strong class="bold">Tags</strong> tab for the repository, as the following link demonstrates: </p>
			<p><a href="https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags">https://hub.docker.com/r/dockerfordevelopers/shipitclicker/tags</a></p>
			<p>From here, select the digest value displayed under the version you are interested in. This will then display the <code>sha256</code> hash, such as the following, for example: </p>
			<pre>DIGEST:sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c 64992ef69804dbf01</pre>
			<p>The following screenshot shows where you can find the hash for use in your <code>docker pull</code> commands:</p>
			<div><div><img src="img/B11641_13_002.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Information on a Docker image</p>
			<p>The portion <a id="_idIndexMarker1021"/>of the string containing <code>sha256</code> onward can then be used in the pull request:</p>
			<pre>$ docker pull  dockerfordevelopers/shipitclicker@ sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef 69804dbf01</pre>
			<p>You should <a id="_idIndexMarker1022"/>now see something similar to the following in your terminal:</p>
			<pre>sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef 69804dbf01: Pulling from dockerfordevelopers/shipitclicker
Digest: sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c 4992ef69804dbf01</pre>
			<p>Running the <code>docker images</code> command should now show it present on your system. </p>
			<p>When it comes to building your own images, another consideration is using the <code>.dockerignore</code> file to help keep the overall container size down.</p>
			<p>With the <code>.dockerignore</code> file included in the build context directory, any files listed in the file will not be added to the image. This, as you will see shortly, has another handy benefit. From an image size perspective, and in light of our general drive cleanliness as a best practice, we can use it to avoid binaries such as Python <code>.pyc</code> files and similar being accidentally added to the image. The following example <code>.dockerignore</code> file demonstrates how we can do this:</p>
			<pre> # ignore .pyc and .git files/directories
.git
**/*.pyc</pre>
			<p>This <a id="_idIndexMarker1023"/>approach is very simple, and if you are used to using <code>.gitignore</code> files, it will already be familiar.</p>
			<p>Now we have <a id="_idIndexMarker1024"/>our minimal base image, we should take a look at some methods to restrict privileges when we create containers, so as to prevent accidental security breaches. </p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor305"/>Restricting privileges</h2>
			<p>In the previous chapter, we looked at assigning a user and a group to restrict privilege escalation <a id="_idIndexMarker1025"/>when starting the image. We can build on this by also using a useful parameter called <code>no-new-privileges</code>.</p>
			<p>The flag <a id="_idIndexMarker1026"/>leverages a feature of the underlying Linux kernel known as <code>no_new_privs</code>. The basic idea of this feature was to ensure that any processes, including child processes, cannot gain additional privileges when spawned. With this option enabled, applications will not be able to use features such as <code>setuid</code>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>setuid</code> feature allows users to run and execute certain programs with escalated privileges. This poses a security threat, as an attacker can exploit it to execute code and programs they would not normally have access to.</p>
			<p>Processes spawned via this feature also cannot unset the <code>no_new_privs</code> flag on themselves, thus preventing an attacker from disabling this feature and escalating privileges via <code>setgid</code> or <code>setuid</code>. </p>
			<p>To enable the <code>no-new-privileges</code> feature when running a container, you will need to include the <code>--security-opt</code> flag and add it as a parameter.</p>
			<p>Let's try this out with the image we just downloaded:</p>
			<pre>$ docker run -d -it --security-opt=no-new-privileges dockerfordevelopers/shipitclicker@sha256:39eda93d15866957 feaee28f8fc5adb545276a64147445c64992ef69804dbf01</pre>
			<p>The image should now be running in this mode. Remember that we can get the container name by running the following command: </p>
			<pre>$ docker ps -a</pre>
			<p>Disabling the ability for a container to gain further privileges can also help us to prevent container breakout. The term <strong class="bold">breakout</strong> is used to refer to a case when a compromised container can access sensitive data on the underlying host. In a scenario where a container is exploited <a id="_idIndexMarker1027"/>and the exploit allows the attacker to elevate privileges (if, for example, the previously discussed flag wasn't included), they may then <a id="_idIndexMarker1028"/>attempt to pivot and compromise other containers through Docker, or exploit the host itself for some other gain.</p>
			<p>As we will learn later in this chapter, there are ways to harden our system further, by restricting the privileges (known as capabilities) of a container when we run it. </p>
			<p>We'll now look at some more flags we can add, along with some other techniques to ensure that the data we are using remains safe.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor306"/>Avoiding data leakages from your image</h2>
			<p>In Linux, we can implement users and groups to ensure that only those who need access to read and write <a id="_idIndexMarker1029"/>files can do so. This fine-tuned system of access permissions is important to help prevent data leakage. Another useful method <a id="_idIndexMarker1030"/>we can use to protect the filesystem used by the image is to set the filesystems and any volumes to a read-only state.</p>
			<p>Let's start by looking at a volume we may want to mount. We're going to run a new container based off the <code>shipitclicker</code> image and mount a local filesystem to it. In order to achieve this, in addition to the <code>--mount</code> flag, we will include a <code>readonly</code> statement within the <code>run</code> command. </p>
			<p>Start by creating an empty folder on your local OS, which we can use to mount the filesystem:</p>
			<pre>$mkdir testfiles</pre>
			<p>Next, try running the following command. It will mount the local folder and run the container and attempt to write a file to the <code>/mnt/testfiles</code> directory called <code>test.file</code>:</p>
			<pre>$ docker run --mount source=testfiles,destination=/mnt/testfiles,readonly dockerfordevelopers/shipitclicker@ sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef 69804dbf01 sh -c 'touch /mnt/testfiles/test.file'</pre>
			<p>You should now see an error informing you that the filesystem is read-only:</p>
			<pre>touch: /mnt/testfiles/test.file: Read-only filesystem</pre>
			<p>Using this mechanism, we can read files mounted to the container, but avoid a situation where the container can write files back to it, thus accidentally writing keys or other data into a directory on the host where they should not be located.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An important point to remember is that the root account can override any file permissions and thus can read any files in the container. If somebody gets root access, they can exfiltrate your data!</p>
			<p>What about <a id="_idIndexMarker1031"/>protecting the filesystem in the container itself, for example, the <code>/tmp</code> directory? Thankfully, Docker provides us with an easy method to do this, via the <code>--read-only</code> flag. We can try this out and see how <a id="_idIndexMarker1032"/>it works in practice. First, stop the container we just created. Remember, you can get the container's name when you run the <code>docker ps -a</code> command.</p>
			<p>Once you have the container name, stop the container. We've used <code>nervous_sinoussi</code> here to represent the name; replace this with your container's own unique name:</p>
			<pre>$ docker stop nervous_sinoussi</pre>
			<p>Now, we are going to recreate the container using the <code>--read-only</code> flag. Included in the <code>run</code> command will be an example of trying to write a file called <code>test</code> to the <code>/tmp</code> directory. With the <code>--read-only</code> flag enabled, we should get an error informing us this is not permitted.</p>
			<p>Let's remove the container we created previously in order to keep our environment clean:</p>
			<pre>$docker container rm nervous_sinoussi</pre>
			<p>So, try running the following command, including your container name:</p>
			<pre>$ docker run --read-only dockerfordevelopers/shipitclicker@ sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992e f69804dbf01 sh -c 'echo "Testing" &gt; /tmp/test'</pre>
			<p>You should now see an error such as the following:</p>
			<pre>sh: can't create /tmp/test: Read-only filesystem</pre>
			<p>Checking the list of Docker processes running, you will see the command executed and exited. Let's clear this container out and try rerunning the command without the flag and echo out the contents of the file we create:</p>
			<pre>$ docker run dockerfordevelopers/shipitclicker@sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804 dbf01 sh -c 'echo "Testing" &gt; /tmp/test | echo "File content is: $(cat /tmp/test)"'</pre>
			<p>Confirmation that the filesystem was written to will now be displayed via the <code>echo</code> command, which prints the contents of <code>/tmp/test</code>:</p>
			<pre>File content is: Testing</pre>
			<p>Therefore, to avoid this second scenario where the filesystem can be written to, always include the <code>--read-only</code> flag.</p>
			<p>Additionally, remember not to include sensitive information such as private keys and API tokens inside <a id="_idIndexMarker1033"/>the Dockerfile. There are a number of services you can use to avoid this situation including HashiCorpVault, Docker Swarm, and services <a id="_idIndexMarker1034"/>built into cloud providers like AWS, such as SSM. <a href="B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316"><em class="italic">Chapter 14</em></a>, <em class="italic">Advanced Docker Security – Secrets, Secret Commands, Tagging, and Labels</em>, will cover these in more detail. </p>
			<p>With some of these best practices in mind, now let's look at the commands we would use to build our own images and what security concerns we need to take into consideration. </p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor307"/>Security around Docker commands</h1>
			<p>We will shortly be <a id="_idIndexMarker1035"/>exploring the build process and how we can harden this from a security perspective. In order to do this, however, we will first dig into some of the commands we will use in a little more detail so we know which ones are safe to use, and which pose a potential threat. Let's start by looking at the <code>COPY</code> and <code>ADD</code> commands.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor308"/>COPY versus ADD – what's the story?</h2>
			<p>When you come to build an image, you will want to copy files from the host over to it. Typically, there <a id="_idIndexMarker1036"/>are two methods <a id="_idIndexMarker1037"/>for doing this. If you've done any research online, you may <a id="_idIndexMarker1038"/>have seen comments along the lines of "don't use the <code>ADD</code> command." So why is this?</p>
			<p>The <code>ADD</code> command allows <a id="_idIndexMarker1039"/>us to recursively copy files over to the image, much like a <code>cp -r</code> command might do in Linux if we also piped it through <code>zip</code> when necessary. In short, it expands archive files and creates any directories that don't exist on the target.</p>
			<p>The input to the command is provided as a URL that can reference either a local or remote (archive) file. As you can imagine, when pulling from a remote location, there are a number of risks to consider</p>
			<ul>
				<li>Has the file been modified on the remote host and compromised?</li>
				<li>Do you know the origin of the file on the remote host?</li>
				<li>What <a id="_idIndexMarker1040"/>considerations are there regarding <strong class="bold">Man-In-The-Middle</strong> (<strong class="bold">MITM</strong>) attacks?</li>
			</ul>
			<p>An example of how this command might be used in a Dockerfile can be seen here:</p>
			<pre>ADD https://github.com/PacktPublishing/Docker-for-Developers/archive/master.zip /tmp/ch13/</pre>
			<p>In this case, the <a id="_idIndexMarker1041"/>zipped version of <a id="_idIndexMarker1042"/>the repository hosted on this book's GitHub account would be downloaded and expanded into the <code>tmp</code> directory.</p>
			<p>Previously, we discussed <a id="_idIndexMarker1043"/>using the <code>.dockerignore</code> file to help keep image sizes small. In addition to this benefit, they can help to prevent files accidentally being added if you include the <code>ADD</code> command. For example, you can ensure that configuration <code>.ENV</code> files or similar are not copied over. </p>
			<p>The <code>COPY</code> command works <a id="_idIndexMarker1044"/>slightly differently to <code>ADD</code>. Like <code>ADD</code>, it copies files recursively. However, you must provide an explicit source and destination folder. This means you have to declare the locations the files are coming from and going to. A ZIP file copied from A to B will still remain a ZIP file, and not be expanded while avoiding any unintended consequences.</p>
			<p>We can see an example of the syntax for this command as follows:</p>
			<pre>COPY master.zip /tmp/ch13</pre>
			<p>It is safer to break down the process of adding files into multiple steps, such as downloading the files, scanning them, and then copying them over. When accessing remote content, you should always use an SSL/TLS connection as well. This can prevent MITM attacks being a problem by implementing a cryptographically secure and authenticated communication route.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An MITM attack is one where a malicious party secretly eavesdrops, relays, or alters communications between two parties.</p>
			<p>We've just looked at how the <code>COPY</code> command can avoid some of the issues of <code>ADD</code>, but what about recursive copying? Are there risks here? </p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor309"/>Recursive COPY – use with caution</h2>
			<p>Recursive copying, as you may be aware, copies the contents of one location to another, and includes <a id="_idIndexMarker1045"/>all the nested subfolders and files. </p>
			<p>It's possible <a id="_idIndexMarker1046"/>to accidentally copy files into the image you did not mean to when using the recursive copy command in Docker. </p>
			<p>Let's look at an example. In this following screenshot, we can see an example directory, and included in it is a folder called <code>oops</code> and a <code>my_secret</code> file. This file contains a hypothetical secret such as an API token that has been accidentally left in the folder:</p>
			<div><div><img src="img/B11641_13_003.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Example of a secret accidentally left in the source code</p>
			<p>Imagine that we were to run the following command:</p>
			<pre>COPY . . </pre>
			<p>Along with the parent directory in which all the folders reside, this secret file would also be copied over, as the command will recursively copy everything, including the <code>oops</code> directory and our nested file. </p>
			<p>In order to avoid these negative effects, it is always a good practice to update your <code>.dockerignore</code> file to ensure that sensitive file types are excluded. </p>
			<p>As we noted earlier, if you are familiar with <code>.gitignore</code>, adding file types to your <code>.dockerignore</code> file should be simple. Here are some quick rules to remember:</p>
			<pre># comment – the line is ignored
* # matches anything up to the * e.g. *.txt matches all text files 
**# matches any number of folders e.g. **/*.txt matches all text files in build context
! #can be used to exclude a specific file e.g. !id_rsa.pub 
tmp? # Any files or folder that start with tmp and include a subsequent character are 
           #ignored  
*/tmp* # Will exclude any directories or files starting with tmp directly below root
*/*/tmp* # Similar to the above however works for two directories below root </pre>
			<p>Using these <a id="_idIndexMarker1047"/>mechanisms, you can ensure a <a id="_idIndexMarker1048"/>variety of files are excluded from the container, such as <code>*.pem</code> and <code>*.ENV</code> files. </p>
			<p>Therefore, if you do plan to use recursive copying in your Dockerfile, ensure the <code>.dockerignore</code> file is up to date and that you have audited your application to ensure that everything being copied over is as intended. </p>
			<p>Let's now turn our attention to the build process and how we can improve security at this stage. Here, we will see how commands such as <code>COPY</code> come into play as part of a larger process.</p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor310"/>Security around the build process </h1>
			<p>We've seen how we can pull images and run them in a secure fashion. But what about building our <a id="_idIndexMarker1049"/>own container images? As you are now familiar with, some commands pose additional risks when added to the Dockerfile. In this section of the chapter, we will look at how we can secure the build process using the techniques we have learned so far. This will include using a minimal base image (<code>shipitclicker</code>) as a starting point and then using the security tweaks we have tested against this image when running it as a container. </p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor311"/>Using multi-stage builds</h2>
			<p>As we <a id="_idIndexMarker1050"/>previously covered, we need to be careful about <a id="_idIndexMarker1051"/>secrets and ensure they are not accidentally leaked. One way to avoid this is to not include them in the Dockerfile. However, what about at the build stage? It's likely you will need to use private keys in conjunction with the build process from time to time, for example, to pull code from a remote service that is protected with public key encryption. </p>
			<p>One method to use keys securely is through the use of multi-stage builds. This process uses a disposable intermediate layer, which ensures that data isn't accidentally leaked into the final build process. Let's look at a simple example. If you wish to run this code, you will need to have an SSH server running and add your public key to it.</p>
			<p>If you don't have one running already, to build a container that runs SSH, you can reuse the Dockerfile located at <a href="https://docs.docker.com/engine/examples/running_ssh_service/">https://docs.docker.com/engine/examples/running_ssh_service/</a>.</p>
			<p>Next, let's take a look at an example of the multi-stage build process and how we can use it in conjunction with accessing an SSH service.</p>
			<p>Copy the following code to a new Dockerfile you can work with. On your container running the SSH server, add a file called <code>file.txt</code> and then update the Dockerfile code to include your user, IP/hostname, and the path to the file you just created.</p>
			<p>Let's do a quick walkthrough of what is going on here before we build it:</p>
			<pre>FROM  dockerfordevelopers/shipitclicker@sha256:39eda93 d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01 as intermediate
WORKDIR /test
ARG ssh_prv_key
RUN echo "$ssh_prv_key" &gt; /tmp/id_rsa_test
RUN chmod 600 /tmp/*
RUN apk add openssh
RUN scp -i /tmp/id_rsa_test user@server:/path/to/file.txt .
FROM dockerfordevelopers/shipitclicker@sha256:39eda93 d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01
WORKDIR /test
COPY --from=intermediate /test .</pre>
			<p>This code does a number of things. First, it takes our <code>shipitclicker</code> image as an intermediate build step.</p>
			<p>Following this, it sets the <code>WORKDIR</code> to test and creates an <code>ARG</code> value called <code>ssh_prv_key</code>. This <code>ARG</code> value will allow us to pass in the path to the RSA private key that will be needed to connect to the remote SSH server.</p>
			<p>Based upon our input, we echo it out as a file and then set permissions on the file to <code>600</code>. Then, we install <code>openssh</code> so we can use the <code>scp</code> command-line feature. The interesting bit comes next.</p>
			<p>The <code>RUN scp</code> command takes the private key we injected and uses it to connect to the remote server to <a id="_idIndexMarker1052"/>retrieve a file called <code>file.txt</code>, which is then <a id="_idIndexMarker1053"/>copied back to the present directory. This step completes the first stage of the build.</p>
			<p>In the second stage, we once again use the <code>shipitclicker</code> image and use the same <code>WORKDIR</code>, that is, <code>test</code>. The final line, however, is where the magic happens. It copies from the intermediate step we completed in step 1, the file that was retrieved from the remote server, and replicates it to the final build stage.</p>
			<p>As you can see from the result, the final container does not contain the private key we used to retrieve the file from the remote SSH server, and thus will not accidentally end up in the final container.</p>
			<p>To build out this Dockerfile once you have a remote location to copy the file from, you can use the following command:</p>
			<pre>$docker build --build-arg ssh_prv_key="$(cat ~/.ssh/id_rsa_test)" .</pre>
			<p>As you can probably guess from looking at this, the <code>ssh_prv_key</code> build argument is simply the value of our private key concatenated out into the variable.</p>
			<p>Once we have <a id="_idIndexMarker1054"/>built our container, when we run it, we want to ensure that it does not consume more resources than required. This can <a id="_idIndexMarker1055"/>help to mitigate damage in the case of an unfortunate security breach. </p>
			<p>As a final note, multi-stage builds can also aid in keeping the images small, which is a desirable quality, as already discussed. Let's now take a look at how we limit capabilities and resource usage in Docker further. </p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor312"/>Limiting resources and capabilities when deploying your builds</h1>
			<p>You can limit a variety of resources available to your container, including CPU usage and memory. This can <a id="_idIndexMarker1056"/>help prevent denial-of-service attacks. In this scenario, the container is exploited to use up the underlying resources of <a id="_idIndexMarker1057"/>the host, thus causing overall performance degradation, or worse, the underlying host to crash.</p>
			<p>Additionally, access control mechanisms are an important piece of the puzzle to ensure that as well as limiting the resources used by a container, we also limit privileges and access.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor313"/>Limiting resources</h2>
			<p>In order to avoid the types of DOS attacks mentioned earlier, we can use a combination of flags to restrict how much of the underlying host resources a container can consume.</p>
			<p>The first area <a id="_idIndexMarker1058"/>we will look at is memory. Docker gives us the ability to restrict how much memory a container can use through a combination of hard and soft limits.</p>
			<p>We can set a hard limit on a container using the <code>-m</code>/<code>--memory</code> flag. This will set aside the amount you specify and will not allow the container to exceed this. In the case that a container does become compromised, the hard limit feature will prevent a runaway malicious process from consuming more and more of the underlying host's RAM.</p>
			<p>When setting the memory limit, ensure that you adjust it in line with what your application is intended to do. Too little memory may prevent an issue if the container were compromised, but may, in turn, not be enough to run your application.</p>
			<p>The <code>–memory</code> flag can also be combined with the <code>–memory-reservation</code> flag. This second feature allows you to specify a soft limit smaller than the <code>–memory</code> one. When Docker discovers that the underlying host has an issue, such as low memory, it will activate this feature. Once activated, Docker will attempt to restrict the amount of memory available to the container.</p>
			<p>As with memory, we also need to be aware that an exploited container can also consume more CPU resources than expected, which can, in turn, have negative side effects for the host.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using Docker 1.12 or lower, you will need to use the<code> –cpu-period</code> and <code>–cpu-quota</code> flags instead of the <code>–cpus</code> flag.</p>
			<p>Using the <code>–cpus</code> flag, you can define how many CPUs a container has access to. If you have multiple CPUs (for example, four) and set the value to <code>–cpus="2"</code>, the container is restricted to only being able to use up to two CPUs and no more. </p>
			<p>We've seen <a id="_idIndexMarker1059"/>how we can use some flags to restrict the resources a container has available to it at runtime. Let's look at some additional flags we can use to further restrict potential security risks when we run our container.</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor314"/>Dropping capabilities</h2>
			<p>Some techniques <a id="_idIndexMarker1060"/>you can use to help avoid other risks include dropping capabilities when running containers. Capabilities are a feature of Linux that divide privileges associated with the root/super user account into individual components. </p>
			<p>The list of capabilities that a container usually has are <code>chown</code>, <code>dac_override</code>, <code>fowner</code>, <code>fsetid</code>, <code>kill</code>, <code>setgid</code>, <code>setuid</code>, <code>setpcap</code>, <code>net_bind_service</code>, <code>net_raw</code>, <code>sys_chroot</code>, <code>mknod</code>, <code>audit_write</code>, and <code>setfcap</code>. To understand what each capability allows, please refer to the Linux man-pages <a id="_idIndexMarker1061"/>documentation at <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a>.</p>
			<p>To remove capabilities such as <code>chown</code>, you can use the <code>–cap-drop</code> flag when running a container. Refer to the following for an example:</p>
			<pre>$ docker run -d -it --cap-drop=chown  --security-opt=no-new-privileges dockerfordevelopers/shipitclicker@sha256:39eda 93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01</pre>
			<p>Removing powerful capabilities that your production containers do not need can help harden you against attacks that seek to break out of the container.</p>
			<p>That ends this chapter on techniques to improve your fundamental security posture. Before we move on to some more advanced techniques, let's quickly re-cap what we have learned so far.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor315"/>Summary</h1>
			<p>In this chapter, we have reviewed some basic steps you can take to ensure that when you pull images and build and run containers, your attack surface will be reduced.</p>
			<p>We learned about how to ensure that we only pull safe images from Docker Hub. Additionally, we saw how we can use read-only permissions to prevent write access to filesystems.</p>
			<p>Multi-stage builds were discussed to show how we can break down our container build process into steps to ensure that SSH keys and similar are not accidentally included in the final product. The <code>.dockerignore</code> file was briefly reviewed from a security perspective, and finally, we discussed how to restrict system resources and implement access control through removing capabilities.</p>
			<p>In the next chapter, we will look at how we can automate some of the security processes by using scanning tools and implement monitoring.</p>
		</div>
	</body></html>