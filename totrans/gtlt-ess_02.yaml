- en: Chapter 2. Installing Gitolite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter showed you how to set up what we might call a **sandbox**
    installation of Gitolite, suitable for experimenting with the software and getting
    comfortable with it. We did that using a script that hid most of the details of
    the install process so that you could *get to the good stuff*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will actually perform a proper install of Gitolite. We will
    start with the prerequisites on the server and move on to the actual install steps.
    By the end of this chapter, you should have a working installation of Gitolite
    that is ready to support users and serve up repositories to them securely, enforcing
    access restrictions as you specify them.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite users and the hosting user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gitolite provides access to several Gitolite users, using only one actual user
    ID on the server. Before we start installing and setting up Gitolite, it's useful
    to have some knowledge of what is actually going on behind the scenes and how
    this is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite uses one Unix user called the **hosting** **user** to provide repository
    access to many Gitolite users. The hosting user can be any valid user on the system,
    though by convention it is either git or gitolite. This is the only user ID that
    is used by Gitolite on the server, and it is within the home directory of this
    user that Gitolite places its files, its own configuration, as well as the repositories
    it manages.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite can support thousands of Gitolite users on one server. These users
    are not *real* users as far as the server operating system is concerned, and they
    do not get access to the shell command line on the server. A Gitolite user does,
    however, get access to some of the repositories on the server so that they can
    run Git commands against them.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing users from each other
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gitolite uses ssh to authenticate its users. However, while ssh normally allows
    authentication using either a password or an ssh key pair, Gitolite requires that
    a key pair be used for authentication; passwords are not accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Each Gitolite user has an ssh key pair on their desktop or laptop. A key pair
    consists of two files, typically called `id_rsa` (the private key), and `id_rsa.pub`
    (the public key).
  prefs: []
  type: TYPE_NORMAL
- en: 'The public key file contains a single, very long line of text; here''s a shortened
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The key is actually too long to print here, so we removed about 350 characters
    from the middle, replacing them with ellipsis, but this should still give you
    a good idea of what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Distinguishing users from each other](img/2371OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure illustrates the sequence of events that happens when a
    user connects to a Gitolite server to access a Git repository, and how this sequence
    is enabled. First, each user sends their public key to the Gitolite administrator.
    When the Gitolite administrator adds these users to Gitolite, Gitolite adds the
    keys to a file called `.ssh/authorized_keys` in the home directory of the hosting
    user. It then prefixes to the beginning of each line a string that looks somewhat
    like the following line (for the user Adam) and similarly for other users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This first step is what enables the access control. It is a one-time action,
    and needs to be repeated only when the administrator adds or removes users. Notice
    the `command` option, containing a program name (`gitolite-shell` using its full
    path), and its argument (the username, `adam` in this example)—this will be relevant
    a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: The second step shows what happens when, say, Bob tries to connect to the server.
    Bob runs the ssh command, whether directly or via his local git client, in the
    form of a clone, fetch, or push command. The ssh daemon on the server handles
    the connection attempt. Bob's ssh client will offer a public key, and the ssh
    daemon will go looking for it in the authorized keys file, finding it eventually.
    In our example, it finds a match on the second line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the ssh daemon notices the command option on the matched line in the authorized
    keys file. This tells the ssh daemon that, instead of running the program that
    the client asked for, it should instead run the command mentioned in that option,
    including any arguments supplied. This means the `gitolite-shell` program is executed
    with the Gitolite username (in our example, Bob) as the first argument. This is
    how the `gitolite-shell` program knows who is connecting.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those who are wondering what happened to the original command that the git
    client actually wanted, the ssh daemon stores it in an environment variable called
    `SSH_ORIGINAL_COMMAND` and passes it to the `gitolite-shell` program, which knows
    what to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gitolite can be installed on any Unix server. This includes Linux, any of the
    BSDs, and the legacy Unix servers such as AIX and HP-UX. With that said, here
    are the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A Unix system with a POSIX-compatible sh (shell)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Version 1.7.1 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perl 5.8.8 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSH 5.0 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dedicated Unix user as the hosting user described previously, whose home directory
    must be on a filesystem that supports symlinks, and allows executables (that is,
    it is not mounted with the `noexec` mount flag)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, you should use a brand new user ID that has no existing files or directories,
    except for whatever a newly created user gets (such as the bashrc or similar files).
    This will ensure that any leftover files don't interfere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting the Gitolite source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to obtain the Gitolite source code. The simplest way to do
    this, if your server can connect to the Internet, is to run `git clone` `git://github.com/sitaramc/gitolite`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not have direct access to the Internet, simply use some other machine
    in between. For example, you could run the previous command on a server that can
    connect to the Internet. From that intermediate server, you can zip the entire
    Gitolite repository, bring it over to the Gitolite server, and unzip it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to put the source code where you want it to go. Gitolite is
    designed in a way that it doesn't require root (except to create the hosting user),
    so you can (and usually should) put it somewhere within the home directory of
    the Gitolite hosting user. For our discussion, we will pick `$HOME/bin`, because
    this is usually included in the user's PATH setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as the hosting user, and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For people who are familiar with commands such as `make prefix=/usr/local install`,
    this is conceptually not very different.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Gitolite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the code is in the right place, we need to set it up. Setting it up
    involves adding an ssh public key for the main administrator of the Gitolite installation.
    In this book, we will assume the administrator's name is Adam, thus his Gitolite
    username will be `adam`, but as you follow along, please substitute your own name
    wherever you see references to Adam or `adam`.
  prefs: []
  type: TYPE_NORMAL
- en: Ssh is a powerful and complex tool. To make things simpler in this chapter,
    we will describe a set of steps that would surely work, along with suitable assumptions
    and constraints. These constraints are not absolutely necessary, but they do serve
    to simplify our procedure, as well as remove potential troublespots. If you're
    very familiar with SSH, you will probably be able to get around them quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ssh key pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The administrator needs to first create an ssh key pair for themselves at their
    main workstation. In many cases, there may already be an ssh key pair, possibly
    generated for some other purpose. You should look in `$HOME/.ssh` for a pair of
    files called `id_rsa` and `id_rsa.pub`. If you don't find any such files, you
    can generate a key pair by running the `ssh-keygen` command.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you will choose a strong passphrase to protect your private key when
    generating your ssh key pair. To use it without having to constantly type the
    passphrase, you will then use the `ssh-agent` command or any of its derivatives,
    such as the keychain package. However, these nuances are out of the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you had previously created a non-default key type (that is, something
    other than RSA for ssh protocol 2, which is the default), then it is assumed that
    you know what you are doing. Gitolite should work fine with DSA and ECDSA key
    pairs, but will probably not work with RSA protocol 1 keys.
  prefs: []
  type: TYPE_NORMAL
- en: Running the setup command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have your key pair at your workstation, you will need to get the
    public key (and *only* the public key!) over to the Gitolite hosting user's home
    directory on the server. One way to do this is to use the `scp` command, as in
    `scp .ssh/id_rsa.pub git@host:adam.pub`. You can use any other method available
    to you, for example rsync, or sftp, or even a USB stick. It doesn't matter how
    you do it as long as the file gets there and is renamed as `adam.pub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of warning for ssh experts: do not be tempted to automatically add this
    key to the Gitolite hosting user''s authorized keys file using a command such
    as `ssh-copy-id`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have copied the file, you are ready to run the actual setup command,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should produce an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can ignore the warning about the authorized keys file being created—this
    is quite normal for the first time you do this. And with that, your Gitolite installation
    and setup are all done.
  prefs: []
  type: TYPE_NORMAL
- en: Checking over your new Gitolite server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Very few Gitolite administration tasks require logging on to the server and
    using the command line. Most of the day-to-day maintenance tasks (especially adding
    users and repositories) are done by making changes to a special repository called
    `gitolite-admin`, and pushing those changes to the server; that is, the administrator
    must perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the `gitolite-admin` repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some files or make changes to existing files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push them to the server (an administrator is someone who is allowed to push
    to the `gitolite-admin` repo). When the push completes, Gitolite on the server
    side invokes specific scripts to effect the changes requested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to clone the gitolite-admin repository from your workstation
    by running `git clone` `git@server:gitolite-admin`. Git will use ssh to connect
    to the "git" user on the "server". By default, it will look at your `$HOME/.ssh`
    directory, find your ssh key pair, and offer the public key to the server to authenticate
    you. After that, things proceed pretty much as described in the earlier section
    on distinguishing users from each other, and Gitolite gives you access to the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the usual message from a successful `git clone` operation,
    and you can enter `cd gitolite-admin` to see what came in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see where the public keys are stored. Note that Gitolite's notion of
    what your Gitolite username is, comes solely from the name of the public key file
    in the `keydir` directory. This is why when you copied the `id_rsa.pub` file from
    your workstation you copied it as `adam.pub`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ssh experts may note that the comment field inside the public key file is ignored;
    it would be against the conventional meaning of the word "comment" to use it for
    anything that causes a behavioral change in a system, despite the number of people
    on the Internet who appear to think it has a higher purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we will cover adding users in detail in a later chapter, you may want
    to add a beta user right away. Let''s say you want to add Bob; here''s how you
    can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Get his public key, rename it to `bob.pub`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy it to the `keydir` directory you saw above (that is, in your local clone
    of the `gitolite-admin` repository).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the file, commit, and push.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking inside the `conf/gitolite.conf` file shows us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a new repository, edit this file and add a repo line similar to the
    ones that were added previously, followed by an access rule line, sticking to
    the syntax shown previously for now. Save the file, add it, commit the change,
    and push the commit. You should immediately see the usual response from the remote
    git for a successful push, but also something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the new repository is ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we installed Gitolite, learned about the special `gitolite-admin`
    repository and its contents, and added a new user and a new repository. In the
    next chapter, we will talk about what a Gitolite-managed Git repository server
    will look like to your users and what they can do with it.
  prefs: []
  type: TYPE_NORMAL
