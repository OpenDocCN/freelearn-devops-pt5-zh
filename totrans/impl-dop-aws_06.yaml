- en: Chapter 6. Continuous Deployment - A Fully Automated Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the final stage of the CI workflow - the **Continuous Deployment**.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to take the AMI we produced during the Continuous Delivery
    step and deploy that to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this process, we are going to use **blue/green deployment** approach. Our
    production environment is going to consist of ELB and two Auto scaling Groups
    (blue and green):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous Deployment - A Fully Automated Workflow](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we assume that the blue group holds our current production nodes, then upon
    deployment, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach ELB to the green group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale the green group up using the new AMI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale the blue group down, effectively shifting traffic to the instances of
    the new AMI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are building on top of our existing CI pipelines, there are only a few
    changes we need to make to the code from the previous chapter. We need to add
    a few extra Terraform resources; let us take a look at those.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform code (resources.tf)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/Terraform/resources.tf) .'
  prefs: []
  type: TYPE_NORMAL
- en: We add a second public and a matching private subnet so that we can distribute
    the production instances across multiple availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aws_subnet` resource creates a subnet named `public-2`. It takes attributes
    such as a VPC ID, CIDR BLOCK and AZs, the values of which we pull from variables.
    To compute the CIDR and AZ values we use Terraform''s interpolation functions
    (ref: [https://www.terraform.io/docs/configuration/interpolation.html](https://www.terraform.io/docs/configuration/interpolation.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we associate the newly created subnet with a routing table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then repeat for the `Private` subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this VPC, we are going to end up with subnets 1 and 3 public, and 2 and 4
    private.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change is the addition of a prod ELB and a security group for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the protocol value of `"-1"`, meaning "all":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us also update the `demo-app` security group Ingress rules to allow traffic
    from the ELB. To help visualize, here is our earlier diagram with more labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terraform code (resources.tf)](img/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we introduce our blue/green **Auto Scaling Groups** (**ASG**) and a temporary
    launch configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The launch configuration here is really only a placeholder, so that we can define
    the Auto Scaling Groups (which is why we reuse the Jenkins variables). We are
    going to create a new, real launch configuration to serve the `demo-app` later
    on as part of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: outputs.tf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/Terraform/outputs.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A minor addition to the outputs, to give us the Production ELB endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is time for exercise. Using the earlier-mentioned templates and the rest
    of the familiar code from [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_06_CodeFiles](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_06_CodeFiles) plus
    your previous experience you should be able to bring up a VPC plus a Jenkins instance
    with two pipelines, exactly as we did in the chapter on Continuous Delivery. Do
    not forget to update any deployment-specific details such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH public key in `salt:states:users:files`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authorized key in the `serverspec` test specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The S3 URI in `salt:states:yum-s3:files:s3.repo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The S3 bucket name in `demo-app/Jenkinsfile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variables in `packer:demo-app_vars.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variables in `demo-app-cdelivery/Jenkinsfile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I would recommend you to disable the SCM Polling in the **demo-app** job so
    that we don't trigger a run before all our downstream jobs have been configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that all went well, we are back where we left off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jenkins pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier we have our Integration and Delivery pipelines chained together, taking
    code and producing and AMI artifact. Our next task is to design a third pipeline
    to take that AMI and deploy it into our production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can create the new job in Jenkins, we need to make the code for it
    available via Git:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_06_CodeFiles/CodeCommit/demo-app-cdeployment](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_06_CodeFiles/CodeCommit/demo-app-cdeployment).'
  prefs: []
  type: TYPE_NORMAL
- en: We will examine the files in detail shortly, for now just create and populate
    a `demo-app-cdeployment` CodeCommit repository. Similar to our other repositories,
    the new one would have an URL such as [https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app-cdeployment](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app-cdeployment).
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in hand, we proceed to create the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins pipelines](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will need to take an `AMI ID` parameter (to be passed on from the Delivery
    job):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins pipelines](img/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then of course, it needs the `Jenkinsfile` location ([https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app-cdeployment](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app-cdeployment)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins pipelines](img/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With that final job ready, our Jenkins dashboard looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins pipelines](img/image_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Continuous Deployment pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back to the code, as promised:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/CodeCommit/demo-app-cdeployment/Jenkinsfile](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/CodeCommit/demo-app-cdeployment/Jenkinsfile).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Jenkinsfile is rather simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We simply check out the associated repository and execute a shell script. Naturally,
    we could have coded the whole task in Groovy, but I personally am more used to
    Bash, hence the resulting `cdeployment.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly described the deployment task in the beginning of this chapter. Generally
    speaking, we are going to be serving the application code from two separate clusters
    of instances and swap traffic from one to the other. We will use the extensive
    and user friendly AWS CLI to carry out most operations plus Bash to process any
    input/output data.
  prefs: []
  type: TYPE_NORMAL
- en: Let us dive into the script for more details.
  prefs: []
  type: TYPE_NORMAL
- en: cdeployment.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/CodeCommit/demo-app-cdeployment/cdeployment.sh](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_06_CodeFiles/CodeCommit/demo-app-cdeployment/cdeployment.sh).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top, we define the names of our Auto Scaling Groups, the Production
    ELB, and the ID of the AMI, which we will be working with (passed on from the
    upstream pipeline):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Namely, the `techo` (timestamped echo) for a more informative output and `ERR`
    for when we encounter problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to abort a deployment and restore our infrastructure to its original
    state, we will use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we would abort if we detect an increase in the error count of certain
    metrics. We would put the newly deployed instances in **Standby** mode then detach
    the ELB from the given Auto Scaling Group.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we launch new instances, we should pause to allow those to fully
    initialize then verify what they have done so far and the following `wait_for_instances()`function
    will help us with this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for the expected number of instances to launch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for them to become available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let the ELB declare them `InService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, since we know the region we will be working with, we set it in advance
    to avoid having to append it to each AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going any further, we make sure that there is a valid `AMI ID` to work
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be working with two Auto Scaling Groups and one ELB, we check the properties
    of each group and extract the ELB name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we ensure that only one of the groups has the Production ELB associated
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have established which of the two groups is currently serving
    traffic (`Active`) and the one to take over from it (`newActive`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, the `newActive` will be empty, before we deploy any instances within
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If that is so, we can proceed to get some stats from the `Active` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Desired`/`Min`/`Max` are the standard Auto Scaling values that we will end
    up transferring onto the `newActive` group. The `scaleStep`, in this case, 30%
    of the instances presumably in service, is the initial number of instances we
    would like to introduce (allowing them to receive live traffic) during the deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be rather strange if our `Active` group is empty, otherwise should
    it have a low count, we round up the `scaleStep` to at least 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Those were the prerequisites; now let us start the deployment by slowly scaling
    up the `newActive` group.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would need a launch configuration. To create one, we can either pass all
    needed parameters ourselves or let EC2 copy most of those by providing an example
    instance from our `Active` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the newly created launch configuration to the group as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add ELB as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Start scaling up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a moment or two, for the instances to boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our initial batch of instances should now have been deployed, attached to the
    Production ELB, and started serving traffic. Before we launch even more copies
    of the new AMI, we ought to check that we have not caused any issues so far. One
    way to do this is to pause the deployment for a few minutes and examine metrics,
    such as number of non-200 responses, exceptions, or requests per second. For simplicity,
    in this example, we assume that this has been done; in real life, you would query
    your monitoring system(s) or perhaps pull samples of CloudWatch ELB/EC2 statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not detect any anomalies, we scale the `newActive` group further to
    match the size of the `Active` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would expect, another check is in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we could simulate a problem and trigger a rollback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rollback` function should take care of the rest. If we keep `doRollback`
    as `false`, our deployment continues as planned and we shift traffic completely
    from the `Active` to the `newActive` group by scaling the former down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And detach ELB from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us see our script in action. First, we should simulate an `Active`
    group by manually scaling up, say the blue one, and attach the Production ELB
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![cdeployment.sh](img/image_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a few moments, you should have three instances and ELB in blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![cdeployment.sh](img/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let us re-enable SCM polling for the `demo-app` job and trigger a run by
    pushing a code change to its CodeCommit repo. You should see the pipeline running,
    invoking the two downstream ones along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to simulate a metrics problem and cause a rollback, then the
    deployed instances should end up in the **Standby** mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![cdeployment.sh](img/image_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the `rollback` was triggered after the initial deployment of one
    instance (`scaleStep=1`). Theoretically, the next step would be to investigate
    the instance looking for a possible cause for the error metrics.
  prefs: []
  type: TYPE_NORMAL
- en: If the instance is deemed healthy, then we would need to complete the deployment
    manually by bringing the instance into service, scaling the group up further,
    then scaling the other group down (essentially completing the remaining steps
    in the `cdeployment` script).
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the instance can be put into service, then the group scaled down
    to zero, bringing the infrastructure back to its original state with the blue
    group remaining as `Active`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you have chosen not to cause any rollbacks, the deployment ought to
    proceed as planned and in the end the green group would have taken over the blue
    one, indicating a successful deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![cdeployment.sh](img/image_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, if you load the ELB URI in your browser, you should get a response
    from our `demo-app` as served from the newly deployed AMI.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finalized our Jenkins CI solution by adding the Deployment
    component to it. We made extensive use of the AWS CLI to orchestrate a blue/green
    deployment process. The resulting pipeline or a collection of such allows us to
    continuously integrate our application's code changes and build an AMI containing
    those, which is then deployed to a given environment after certain tests have
    been passed and criteria met.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter takes us in a new direction, introducing the topic of monitoring,
    metrics, and log collection. We will take a look at tools that can help us stay
    aware of the state of our infrastructure at any given time, visualize performance,
    and react to issues.
  prefs: []
  type: TYPE_NORMAL
