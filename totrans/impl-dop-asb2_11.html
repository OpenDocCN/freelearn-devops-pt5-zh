<html><head></head><body>
        

                            
                    <h1 class="header-title">Extending Ansible</h1>
                
            
            
                
<p class="mce-root">Ansible has matured over the years to support a wide variety of technologies, tools, operating systems, and processes. Its flexible architecture and modular implementation make it ideal for DevOps oriented groups with varying or diverse requirements. The extensible architecture that comprises Ansible was designed to support the creation of modules and expand the Ansible solution to fit the user's needs. As a result, Ansible itself and many of its now core modules derive from once available plugins.</p>
<p class="mce-root">Throughout the years, Ansible's creators added numerous API hooks and architectures in an effort to support expanding Ansible itself via a wide variety of means. The end result of this effort was a highly extensible system, which was leveraged by developers to create a significant amounts of additional core functionality. A plugin system!</p>
<p>Over the years, the Ansible plugin and module system have expanded out and taken a more central role in Ansible's core architecture. The once clumsily conglomerated extension system has been refined into a well-architected and implemented plugin solution. The once haphazardly implemented extension points have been refined to become a robust and highly capable module API. As a result of these improvements, the plugin and module systems have evolved significantly since its infantile stages.</p>
<p>In this chapter, we are going to take a tour of the Ansible module and plugin architecture. We are going to explore the inner workings of the Ansible architecture and APIs. We are going to dive into Python development and leverage it to create some custom modules and plugin extensions that will enhance our Ansible implementations to support custom needs. Specifically, we will cover the following topics:</p>
<ul>
<li>Understanding Ansible Plugins and its Architecture</li>
<li>Setting Up the Ansible Module Development Environment</li>
<li>Developing a HelloWorld Ansible Module and Extending it</li>
<li>Setting Up a Plugin Development Environment</li>
<li>Understanding the Different Types of Plugins</li>
</ul>
<p>As we embark on this quest to learn about the Ansible plugin system, take careful note of the syntax and formatting to ensure the code is kept clean and unambiguous. By following this general rule of thumb, you will learn how to create and deliver high-quality Ansible extensions. Let's get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Ansible Plugins and its Architecture</h1>
                
            
            
                
<p>Ansible's implementation is highly modular. A modular architecture provides a high level of encapsulation (keeping concerns segregated and preventing them from cross-contaminating). The plugin solution within Ansible's subsystems is architected in order to keep additions organized and encapsulated. This architecture is divided into distinct subsystems. The most critical subsystems for Ansible plugins and modules and modules are defined as follows:</p>
<ul>
<li>The Ansible Core modules</li>
<li>Ansible configs</li>
<li>Custom modules</li>
<li>The Ansible Python API</li>
</ul>
<p>To better describe the vague list just provided, the following diagram provides an illustrated view of the Ansible architecture:</p>
<div><img class="image-border" src="img/c6ae4b76-d6a1-4f05-b680-91de26f31b8f.jpg"/></div>
<p>The preceding diagram highlights three of the most critical subsystems for Ansible plugin and module development. The <strong>Core Modules</strong>, the <strong>Custom Modules</strong>, and the <strong>Ansible Python API</strong>. This stack provides a comprehensive set of components for extending Ansible.</p>
<p>In Ansible, there are two distinct ways to extend the Ansible Core solution. These are described as follows:</p>
<ul>
<li><strong>Ansible plugins</strong>: Plugins in Ansible extend the core functionality of the master system and provide additional functionality to the control server.</li>
<li><strong>Ansible modules:</strong> Modules in Ansible extend the capabilities of playbooks running on target systems. These would be the systems that Ansible runs its playbooks on.</li>
</ul>
<p>These two distinctions are quite important as it defines the scope of the development. Let's take a look at a simple Ansible playbook so we can better understand the role Ansible modules play within the Ansible architecture:</p>
<pre class="mce-root">
# This simple playbook installs / updates Apache<br/>---<br/>- hosts: all<br/> tasks:<br/>   - name: Ensure Apache is installed and at the latest version<br/>     yum: name=httpd state=latest
</pre>
<p class="mce-root">Based on the preceding playbook, can you determine how modules are used? No? Let's examine this playbook more closely:</p>
<pre>
# This simple playbook installs / updates Apache<br/>---<br/>- hosts: all<br/> tasks:<br/>   - name: Ensure Apache is installed and at the latest version<br/><strong>     &lt;yum&gt;: &lt;param&gt;=&lt;value&gt; &lt;param&gt;=&lt;value&gt;</strong>
</pre>
<p>If you guessed that the module name is <kbd>&lt;yum&gt;</kbd>, you would be correct. Tasks represented in the playbook form are simply module calls. If this is the case, then we would logically ask ourselves "When should I create my own modules?"</p>


            

            
        
    

        

                            
                    <h1 class="header-title">When should we create a module?</h1>
                
            
            
                
<p>The most obvious question at this point is when and why you would want to develop your own Ansible modules. The answer is most of the time you actually won't want to. But there are cases where you may need to. Some examples of this are as follows:</p>
<ul>
<li>When communication with a specific API feels clumsy or arduous</li>
<li>To do something custom that Ansible does not have native support for</li>
<li>To communicate with an internal process or software that does not have an already developed Ansible module</li>
</ul>
<p>Generally, if you want to write an Ansible module and the software solution was created by a third-party (open source, commercial, and so on), it makes sense to check the Ansible modules for out-of-the-box support before jumping in and writing code.</p>
<p>In the next section, we will take a look at how to set up the Ansible development environment, where the Ansible module code should be stored and how it should be organized. Let's proceed, shall we?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting Up the Ansible Module Development Environment</h1>
                
            
            
                
<p>In this section, we will discuss how to set up a local Linux environment for Ansible module development. In our specific implementation, we will look at how to do this in Ubuntu. However, the same set of configuration options should work under other Linux flavors as well. As new Ansible module developers, we will want to begin by understanding how to configure our system to best support Ansible development, how to setup the modules path, and how to configure the environment for testing.</p>
<p>The first step to getting a development environment up and running is to understand the Ansible library path on the system. This path is where Ansible will search for additional libraries. The default value for the library path is defined within the primary Ansible configuration file (<kbd>/etc/ansible/ansible.cfg</kbd>). The line item is shown as follows:</p>
<pre>
<strong>library = /usr/share/ansible</strong>
</pre>
<p>While the default path is defined within the Ansible configuration file, it can be manipulated at runtime by specifying the <kbd>--module-path</kbd> on the command line when launching Ansible.</p>
<p>In addition to the <kbd>--module-path</kbd> switch, we can also override the default modules path via a system-level environment variable. An example of how to do this is provided next:</p>
<pre>
<strong>#&gt; export ANSIBLE_LIBRARY=/srv/modules/custom_modules:/srv/modules/vendor_modules</strong>
</pre>
<p>When developing and using Ansible modules, the most preferred location to store the modules is next to the playbook itself within a <kbd>./library</kbd> directory. This would involve creating a directory structure that looks like the following:</p>
<pre>
<strong>#&gt; foo.yml</strong><br/><strong> #&gt; library/</strong><br/><strong> #&gt; library/mymodule.py</strong>
</pre>
<p>Within the preceding structure, we could leverage the tasks available within the playbook. Pretty nice, right? These are the basics of setting up the development environment using Ansible. From here, we should probably also set up some basic debugging and lint solutions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible module testing tool setup</h1>
                
            
            
                
<p>Ansible developers have implemented and released a pretty helpful tool to debug syntax and format issues within Ansible plugins and modules. This linter is quite useful indeed. To install the linter, execute the following command:</p>
<pre>
<strong>$ pip install git+https://github.com/sivel/ansible-testing.git#egg=ansible_testing</strong>
</pre>
<p>Upon executing the preceding command, we should see the following output:</p>
<div><img class="image-border" src="img/1beefb9b-99fe-404a-9bac-22fac8eb609d.png"/></div>
<p>Now that we have the lint tool installed, let's check it out to make sure it's installed. Try the following command:</p>
<pre>
<strong>#&gt; ansible-validate-modules</strong>
</pre>
<p>By executing the preceding command, we should see the following output on the console:</p>
<div><img class="image-border" src="img/c28eeb38-a9e2-4e7f-b55f-dee736c2cb72.png"/></div>
<p>Nice, right? From here, we will want to set up the Ansible module test solution. Let's proceed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing Hello World Ansible Module</h1>
                
            
            
                
<p>Now that we have a basic development environment setup, we are going to explore how to create Ansible modules by taking a look at the obligatory Hello World Ansible module implementation. By creating a Hello World module, we can get our feet wet in Ansible module development and learn the basic structures required for a successful implementation. Let's get started!</p>
<p>To begin our <em>Hello World</em> module, let's create a directory structure that reflects the following screenshot:</p>
<div><img class="image-border" src="img/dc638bef-6a01-41c3-bd3b-4a25f775209a.png"/></div>
<p>Once this structure has been created, let's begin filling in our Ansible Hello World module code. To accomplish this, alter the <kbd>helloworld.py</kbd> file to contain the following Python code:</p>
<pre class="mce-root">
#!/usr/bin/python<br/># The following Python code converts a simple "Hello Ansible" message into a json object <br/># for use with an Ansible module call<br/><br/>import json<br/><br/>message = "Hello Ansible"<br/>print(json.dumps({<br/> "Message" : message<br/>}))
</pre>
<p>Once the preceding code has been implemented, we will want an efficient way to test its functionality. Let's get that testing environment set up next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing a developmental Ansible module</h1>
                
            
            
                
<p>Once the primary Ansible module development environment has been set up, we will want to set up the Ansible module testing environment. This solution will provide us with the ability to validate our Python code without using Ansible directly. As such, it will make the development and validation of potential modules more efficient. To set this up, execute the following commands within the development modules directory:</p>
<pre>
<strong>#&gt; git clone git://github.com/ansible/ansible.git</strong><br/><strong>#&gt; source ansible/hacking/env-setup</strong>
</pre>
<p>Upon executing these commands, you should see something similar to the following output:</p>
<div><img class="image-border" src="img/47c213e3-20da-4046-bbb2-3e686f8ba237.png"/></div>
<p>Once this has been completed, we should have access to a new command, which will enable our ability to test our partially developed Ansible modules. Let's check that out:</p>
<pre>
<strong>#&gt; ansible/hacking/test-module -m ./library/helloworld.py</strong>
</pre>
<p>The following screenshot shows the output for the preceding command:</p>
<div><img class="image-border" src="img/651930f1-7efe-424b-b06c-b7bee6fa759b.png"/></div>
<p>If something were to go wrong (a typo or non-compilable script), we would see something like the following:</p>
<div><img class="image-border" src="img/54ba8e03-b526-470f-9834-612c7f710b1d.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading input parameters</h1>
                
            
            
                
<p>One of the fundamental values that Ansible provides is its connection to the YAML playbooks. Developing modules is useful only if we can create playbooks that pass data parameters to the modules. In this section, you will learn how to expand our Hello World Ansible module to accept and process input parameters from playbooks. We will also look at how to structure our module so that it conforms to the Ansible boilerplate template system designed for module development.</p>
<p>In order for our Hello World program to be able to read input parameters from an Ansible playbook, we will need to modify it a bit. Let's update the <kbd>./library/HelloWorld.py</kbd> file to the following:</p>
<pre>
#!/usr/bin/python#!/usr/bin/python<br/>import json<br/>def main(): <br/><br/>    module = AnsibleModule(argument_spec=dict( param1 = dict(required=True, type='str') ) )<br/>    message = module.params['param1']<br/><br/>    print(json.dumps({<br/>        "Message" : message<br/>    }))<br/><br/>    module.exit_json(changed=True, keyword=value)<br/>    module.exit_json(changed=False, msg='error message ', keyword=value)<br/><br/>from ansible.module_utils.basic import *<br/>if __name__ = '__main__': <br/>    main() 
</pre>
<p>Next, create a simple playbook <kbd>myplaybook.yml</kbd> in the parent folder of the library folder with the contents defined as follows:</p>
<pre>
- name: Hello World<br/>  hosts: localhost<br/>  connection: local<br/>  tasks:<br/>    - name: Tell the Ansible Community Hello<br/>      helloworld: param1=hello
</pre>
<p>Once saved, let's execute it and see the output. The following is the command to run and the expected output:</p>
<pre>
<strong>#&gt; ansible-playbook myplaybook.yml -i localhost -v</strong>
</pre>
<p>The output would look like what is shown in the following screenshot:</p>
<div><img class="image-border" src="img/269ee631-15ea-4e7f-a2e1-e182f8d097bb.png"/></div>
<p>Nice, right? Next, let's take a look at what each of these Hello World lines does. The following is a far more documented copy of the <kbd>helloworld.py</kbd> script:</p>
<pre>
#!/usr/bin/python<br/><br/><br/>#Main Entry point for the module<br/>def main():<br/><br/>    # Instantiate the message variable (this will contain our YAML param value)<br/>    message = ''<br/><br/>    # Instantiate the Ansible Module which will retrieve the value of our param1 variable<br/>    module = AnsibleModule(argument_spec=dict(param1 = dict(required=True, type='str')))<br/><br/>    # Set the value of Message to the value of module.params['param1']<br/>    message = module.params['param1']<br/><br/>    # Display the content of the message in JSON format<br/>    print(json.dumps({"Message": message{))<br/><br/>    # Exit the program SUCCESS/FAIL<br/>    module.exit_json(changed=True, keyword=value)<br/>    module.exit_json(changed=False, msg='error message', keyword=value)<br/><br/># Import ansible functionality from Ansible.module<br/>from ansible.module_utils.basic import *<br/><br/># This line imports the functionality of JSON. It allows us to print the JSON formatted message<br/>import json<br/><br/># Call Main Function IF _main_ is defined<br/>if __name__ = '__main__':<br/>    main()<br/><br/><br/>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding custom facts to a module</h1>
                
            
            
                
<p>Ansible facts (as we mentioned in earlier chapters) provide informational data points about the systems that have run a playbook or task. At some point, we might need to set some Ansible facts and return them to the Ansible control server. In this section, we will discuss how to set Ansible facts within our Hello World module and some of the limitations of Ansible facts.</p>
<p>According to the Ansible documentation (<a href="https://docs.ansible.com/ansible/dev_guide/developing_modules_general.html">https://docs.ansible.com/ansible/dev_guide/developing_modules_general.html</a>):</p>
<p>The setup - Gathers facts about remote hosts module that ships with Ansible provides many variables about a system that can be used in playbooks and templates. However, it's possible to also add your own facts without modifying the system module. To do this, just have the module return a ansible_facts key, like so, along with other return data.</p>
<p>In this section, we will go over how to gather module-specific custom facts and return them to the Ansible control server. To begin, we will want to define a set of formatted facts. Let's take a look at an example of the code that does this:</p>
<pre>
ansible_facts_dict = {<br/> "changed" : true,<br/> "rc" : 5,<br/> "ansible_facts" : {<br/> "foo" : "bar",<br/> }<br/>}<br/><br/>module.exit_json(changed=False, result="success",ansible_facts)
</pre>
<p>Based on the previous code, we can see that Ansible facts can be set in the JSON dictionary form and then passed through the <kbd>module.exit_json</kbd> file. These facts can then be accessed later within the playbook but only after the task that sets the facts has been executed. Nice, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the Ansible Plugin Development Environment</h1>
                
            
            
                
<p>Ansible plugins, as we mentioned earlier, represent actions that are executed on the master (control server) instead of the target host. These plugins allow us to add additional functionality to the Ansible solution easily. Once the plugin has been written, the action is then available to be called via a traditional YAML playbook <em>action</em>. Before we start coding our action plugin, let's take a look at how to set up the development environment.</p>
<p>Similar to the modules' development environment, action plugins must reside either in <kbd>./&lt;type of plugin&gt;_plugins</kbd> next to the playbook being executed <em>or</em> within one of the specified folders. For example, you might have a directory structure like the following:</p>
<pre>
<strong>#&gt; foo.yml</strong><br/><strong>#&gt; action_plugins/</strong><br/><strong>#&gt; action_plugin/mymodule.py</strong>
</pre>
<p>Or, you may have this:</p>
<pre>
<strong>#&gt; foo.yml</strong><br/><strong>#&gt; callback_plugins/</strong><br/><strong>#&gt; callback_plugin/mymodule.py</strong>
</pre>
<p>Or, you might consider altering the <kbd>&lt;type of plugin&gt;_plugins</kbd> path in the config folder, as follows:</p>
<pre>
#action_plugins = /usr/share/ansible/plugins/action<br/>#callback_plugins = /usr/share/ansible/plugins/callback<br/>#connection_plugins = /usr/share/ansible/plugins/connection<br/>#lookup_plugins = /usr/share/ansible/plugins/lookup<br/>#vars_plugins = /usr/share/ansible/plugins/vars<br/>#filter_plugins = /usr/share/ansible/plugins/filter<br/>#test_plugins = /usr/share/ansible/plugins/test
</pre>
<p>It is important to uncomment in the configuration the type of plugin you wish to leverage within the config. Once the development environment has been created for the type of plugin we wish to create, it's time to start coding the plugin itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Different Types of Plugins</h1>
                
            
            
                
<p>Ansible provides the option to create numerous types of plugins. Each plugin type interacts with the Ansible system in a different way. In this section, we will be looking at the different types of plugins available within the Ansible plugin architecture and discover how to code them. The different types of plugins available are as follows:</p>
<ul>
<li>Action plugins</li>
<li>Callback plugins</li>
<li>Connection plugins</li>
<li>Lookup plugins</li>
<li>Vars plugins</li>
<li>Filter plugins</li>
<li>Test plugins</li>
</ul>
<p>In the coming sections, we will take a look at how to code each plugin type and what they are capable of. Let's get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Action plugins</h1>
                
            
            
                
<p>In this section, we will take a look at action plugins and you will learn what action plugins do and some basic code examples on how to create new actions that are available within the Ansible subsystems. In Ansible, <kbd>action_plugins</kbd> are a special type of module that provide additional functionality to an existing module. As we mentioned earlier, <kbd>action_plugins</kbd> run on the master instead of on the target.</p>
<p>For example, an action plugin represented via an Ansible playbook would look like the following:</p>
<pre>
- name: Special Action to be run on the master<br/>  action: myaction foo=bar
</pre>
<p>The code for such an action plugin might look something like the following:</p>
<pre class="mce-root">
#!/usr/bin/python<br/><br/># Import the Ansible Runner return data lib <br/>from ansible.runner.return_data import ReturnData<br/><br/># Define our ActionModule class (MUST BE NAMED ActionModule)<br/>class ActionModule(object):<br/><br/>    # Define our Calss constructor method (Must be present)<br/>    def __init__(self, runner):<br/>        self.runner = runner<br/><br/>    # Define our run method (must be present)<br/>    def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):<br/>        return ReturnData(conn=conn, comm_ok=True, result=dict(failed=False, changed=False, msg="Hello Ansible"))
</pre>
<p>So, as we can see, the plugin code simply adds functionality to the playbook by using a set of well-defined structured methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Callback plugins</h1>
                
            
            
                
<p>Callback plugins in Ansible provide additional functionality to Ansible when responding to various events within the system. Callback plugins also control most of the execution output that is displayed when running a command-line program. In this section, we will take a look at callback plugins and learn how to implement additional callbacks within the Ansible subsystems.</p>
<p>The Python code for callback plugins must be stored in the <kbd>callback</kbd> folder, as we talked about earlier. The code that needs to be overridden by the class is shown as follows:</p>
<pre class="mce-root">
#!/usr/bin/python<br/><br/># Import CallbackPlugin base class<br/>from ansible.plugins.callback import CallbackBase<br/>from ansible import constants as C<br/><br/># Define the CallBackModule class<br/>class CallbackModule(CallbackBase):<br/>    pass
</pre>
<p class="mce-root">The way Callback plugins work is similar to other plugins. They provide us with the ability to override various functionality developed within the initial Ansible implementation. Additional details on the specifics of overrides available can be found at <a href="http://docs.ansible.com/ansible/dev_guide/developing_plugins.html">http://docs.ansible.com/ansible/dev_guide/developing_plugins.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connection plugins</h1>
                
            
            
                
<p>Similar to callback and action plugins, connection plugins can also be added to enhance the capability of the Ansible subsystems. Out of the box, Ansible uses a <kbd>paramiko</kbd> SSH and a native SSH Protocol connection solution. In addition, there are some other minor libraries leveraged as well (<kbd>chroot</kbd>, <kbd>jail</kbd>, and so on.) These libraries can be leveraged via playbook's. It may become wanted to leverage an alternative connection type such as SNMP, or message for Ansible to use. It's really a simple procedure (for those with Python and programming knowledge) using the connection plugin option. To accomplish this, simply copy one of the formats of one of the existing connection types into a <kbd>plugins_connection</kbd> folder and modify it to suit your needs.</p>
<p>Documentation for this plugin type is not comprehensive, and it is not available publicly yet by the Ansible creators. As such, it's recommended that you take a look at the Ansible source code for the existing connection plugins, for example. These examples can be found at <a href="https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/connection">https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/connection</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lookup plugins</h1>
                
            
            
                
<p>In this section, we will take a closer look at lookup plugins and learn what they are, where some examples can be found, and how to leverage them. To begin, let's better understand what a lookup plugin actually is. A lookup plugin is designed to retrieve information and datasets from external data sources. For example, the concept of Ansible iterations is developed using lookup plugins. More specifically, <kbd>with_fileglob</kbd> and <kbd>with_items</kbd> were implemented using the lookup plugin constructs.</p>
<p>Let's take a look at how to implement a look-up plugin based on the official Ansible source code documentation:</p>
<pre>
# This Code Example Comes from the Official Ansible Documentation Set (http://www.ansible.com/)<br/><br/>from ansible.errors import AnsibleError, AnsibleParserError<br/>from ansible.plugins.lookup import LookupBase<br/><br/>try:<br/>    from __main__ import display<br/>except ImportError:<br/>    from ansible.utils.display import Display<br/>    display = Display()<br/><br/># This is the standard class for the LookupModule implementation it is required to be this name <br/>class LookupModule(LookupBase):<br/><br/>    # As with all our other plugins, the run method MUST be there <br/>    def run(self, terms, variables=None, **kwargs):<br/><br/>        ret = []<br/>        # Perform iteration<br/>        for term in terms:<br/><br/>            display.debug("File lookup term: %s" % term)<br/><br/>            # Find the file in the expected search path<br/>            lookupfile = self.find_file_in_search_path(variables, 'files', term)<br/>            display.vvvv(u"File lookup using %s as file" % lookupfile)<br/>            try:<br/>                if lookupfile:<br/>                    contents, show_data = self._loader._get_file_contents(lookupfile)<br/>                    ret.append(contents.rstrip())<br/>                else:<br/>                    raise AnsibleParserError()<br/><br/>            except AnsibleParserError:<br/>                raise AnsibleError("could not locate file in lookup: %s" % term)<br/>return ret
</pre>
<p class="mce-root">This is an example of how this lookup is called:</p>
<pre class="mce-root">
---<br/>- hosts: all<br/> vars:<br/> contents: "{{ lookup('file', '/etc/foo.txt') }}"<br/> tasks:<br/><br/>  - debug: msg="the value of foo.txt is {{ contents }} as seen today {{ lookup('pipe', 'date +"%Y-%m-%d"') }}"
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Distributing Ansible plugins</h1>
                
            
            
                
<p>We discussed this in some detail within each section of this chapter, but it deserves reiterating. The most effective way to enable and distribute an Ansible plugin is to create a subdirectory alongside the playbook, which will leverage the plugin, that is, to create one of the following directories along side your playbook:</p>
<ul>
<li class="mce-root"><kbd>./action_plugins</kbd></li>
<li class="mce-root"><kbd>./lookup_plugins</kbd></li>
<li class="mce-root"><kbd>./callback_plugins</kbd></li>
<li class="mce-root"><kbd>./connection_plugins</kbd></li>
<li class="mce-root"><kbd>./filter_plugins</kbd></li>
<li class="mce-root"><kbd>./strategy_plugins</kbd></li>
<li class="mce-root"><kbd>./cache_plugins</kbd></li>
<li class="mce-root"><kbd>./test_plugins</kbd></li>
<li class="mce-root"><kbd>./shell_plugins</kbd></li>
</ul>
<p class="mce-root">In addition to this methodology for the distribution of a plugin, we could also use RPM or PIP to package the plugin and distribute it to the proper Ansible installation directory. The traditional installation location is set in the <kbd>/etc/ansible/ansible.cfg</kbd> file and can be altered as required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we talked about extending Ansible. You learned that there are two types of extensions for Ansible. The first is an Ansible module, and the second one is an Ansible plugin. Ansible modules provide developers with the ability to add functionality to Ansible running on target hosts, whereas plugins extend the capabilities of the control server.</p>
<p>You learned how to set up a local development environment for both Ansible modules and Ansible plugins. Once we had the development environment taken care of, we looked at how to write modules using a Hello World example and how to extend Ansible with a new plugin that overrides functionality within the core Ansible plugin solution.</p>
<p>After that, we explored the plugin architecture and learned the various extension points that can be leveraged. This included action plugins, controller plugins, var plugins, and more.</p>
<p>In the next and final chapter, we will take a look at Ansible Galaxy. Ansible Galaxy is a user-managed distribution point for Ansible playbooks. It is a critical implementation for Ansible developers and makes the job of creating playbooks to perform common tasks a breeze. Let's get moving.</p>
<p> </p>
<p> </p>


            

            
        
    </body></html>