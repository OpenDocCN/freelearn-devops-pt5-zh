<html><head></head><body>
        

                            
                    <h1 class="header-title">Mastering Containers</h1>
                
            
            
                
<p>In the previous chapter, you learned how to optimally prepare your working environment for the productive and frictionless use of Docker. In this chapter, we are going to get our hands dirty and learn everything that is important to know when working with containers. Here are the topics we're going to cover in this chapter:</p>
<ul>
<li>Running the first container</li>
<li>Starting, stopping, and removing containers</li>
<li>Inspecting containers</li>
<li>Exec into a running container</li>
<li>Attaching to a running container</li>
<li>Retrieving container logs</li>
<li>Anatomy of containers</li>
</ul>
<p>After finishing this chapter, you will be able to do the following things:</p>
<ul>
<li>Run, stop, and delete a container based on an existing image, such as Nginx, BusyBox, or Alpine.</li>
<li>List all containers on the system.</li>
<li>Inspect the metadata of a running or stopped container.</li>
<li>Retrieve the logs produced by an application running inside a container.</li>
<li>Run a process such as <kbd>/bin/sh</kbd> in an already-running container.</li>
<li>Attach a Terminal to an already-running container.</li>
<li>Explain in your own words to an interested lay person the underpinnings of a container.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>For this chapter, you should have installed Docker for Desktop on your macOS or Windows PC. If you are on an older version of Windows or are using Windows 10 Home Edition, then you should have Docker Toolbox installed and ready to use. On macOS, use the Terminal application, and on Windows, a PowerShell or Bash console, to try out the commands you will be learning.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the first container</h1>
                
            
            
                
<p>Before we start, we want to make sure that Docker is installed correctly on your system and ready to accept your commands. Open a new Terminal window and type in the following command:</p>
<pre><strong>$ docker version</strong></pre>
<p>If you are using Docker Toolbox then use the Docker Quickstart Terminal that has been installed with the Toolbox, instead of the Terminal on macOS or Powershell on Windows.</p>
<p>If everything works correctly, you should see the version of Docker client and server installed on your laptop output in the Terminal. At the time of writing, it looks like this (shortened for readability):</p>
<pre>Client: Docker Engine - Community<br/> Version: 19.03.0-beta3<br/> API version: 1.40<br/> Go version: go1.12.4<br/> Git commit: c55e026<br/> Built: Thu Apr 25 19:05:38 2019<br/> OS/Arch: darwin/amd64<br/> Experimental: false<br/><br/>Server: Docker Engine - Community<br/> Engine:<br/> Version: 19.03.0-beta3<br/> API version: 1.40 (minimum version 1.12)<br/> Go version: go1.12.4<br/> Git commit: c55e026<br/> Built: Thu Apr 25 19:13:00 2019<br/> OS/Arch: linux/amd64<br/> ...</pre>
<p>You can see that I have <kbd>beta3</kbd> of version <kbd>19.03.0</kbd> installed on my macOS.</p>
<p>If this doesn't work for you, then something with your installation is not right. Please make sure that you have followed the instructions in the previous chapter on how to install Docker for Desktop or Docker Toolbox on your system.</p>
<p>So, you're ready to see some action. Please type the following command into your Terminal window and hit <em>Return</em>:</p>
<pre><strong>$ docker container run alpine echo "Hello World" </strong></pre>
<p>When you run the preceding command the first time, you should see an output in your Terminal window similar to this:</p>
<pre>Unable to find image 'alpine:latest' locally<br/>latest: Pulling from library/alpine<br/>e7c96db7181b: Pull complete<br/>Digest: sha256:769fddc7cc2f0a1c35abb2f91432e8beecf83916c421420e6a6da9f8975464b6<br/>Status: Downloaded newer image for alpine:latest<br/><strong>Hello World</strong></pre>
<p>Now that was easy! Let's try to run the very same command again:</p>
<pre><strong>$ docker container run alpine echo "Hello World" </strong></pre>
<p>The second, third, or <em>n</em><sup>th</sup> time you run the preceding command, you should see only this output in your Terminal:</p>
<pre> <strong>Hello World</strong>  </pre>
<p>Try to reason about why the first time you run a command you see a different output than all of the subsequent times. But don't worry if you can't figure it out; we will explain the reasons in detail in the following sections of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Starting, stopping, and removing containers</h1>
                
            
            
                
<p>You have successfully run a container in the previous section. Now, we want to investigate in detail what exactly happened and why. Let's look again at the command we used:</p>
<pre><strong>$ docker container run alpine echo "Hello World"</strong> </pre>
<p>This command contains multiple parts. First and foremost, we have the word <kbd>docker</kbd>. This is the name of the Docker <strong>Command-Line Interface</strong> (<strong>CLI</strong>) tool, which we are using to interact with the Docker engine that is responsible to run containers. Next, we have the word <kbd>container</kbd>, which indicates the context we are working with. As we want to run a container, our context is the word <kbd>container</kbd>. Next is the actual command we want to execute in the given context, which is <kbd>run</kbd>.</p>
<p>Let me recap—so far, we have <kbd>docker container run</kbd>, which means, <em>Hey Docker, we want to run a container.</em></p>
<p>Now we also need to tell Docker which container to run. In this case, this is the so-called <kbd>alpine</kbd> container.</p>
<div><kbd>alpine</kbd> is a minimal Docker image based on Alpine Linux with a complete package index and is only 5 MB in size.</div>
<p>Finally, we need to define what kind of process or task shall be executed inside the container when it is running. In our case, this is the last part of the command, <kbd>echo "Hello World"</kbd>.</p>
<p>Maybe the following screenshot can help you to get a better idea of the whole thing:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-931 image-border" src="img/aa2c9ba0-11fb-4b2a-ae10-2c3419981032.png" style="width:29.58em;height:7.67em;"/></p>
<p>Anatomy of the docker container run expression</p>
<p>Now that we have understood the various parts of a command to run a container, let's try to run another container with a different process running inside it. Type the following command into your Terminal:</p>
<pre><strong>$ docker container run centos ping -c 5 127.0.0.1</strong></pre>
<p>You should see output in your Terminal window similar to the following:</p>
<pre>Unable to find image 'centos:latest' locally<br/>latest: Pulling from library/centos<br/>8ba884070f61: Pull complete<br/>Digest: sha256:b5e66c4651870a1ad435cd75922fe2cb943c9e973a9673822d1414824a1d0475<br/>Status: Downloaded newer image for centos:latest<br/>PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.<br/>64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.104 ms<br/>64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.059 ms<br/>64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.081 ms<br/>64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.050 ms<br/>64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.055 ms<br/>--- 127.0.0.1 ping statistics ---<br/>5 packets transmitted, 5 received, 0% packet loss, time 4127ms<br/>rtt min/avg/max/mdev = 0.050/0.069/0.104/0.022 ms</pre>
<p>What changed is that this time, the container image we're using is <kbd>centos</kbd> and the process we're executing inside the <kbd>centos</kbd> container is <kbd>ping -c 5 127.0.0.1</kbd>, which pings the loopback address five times until it stops.</p>
<div><kbd>centos</kbd> is the official Docker image for CentOS Linux, which is a community-supported distribution derived from sources freely provided to the public by <strong>Red Hat</strong><strong> </strong>for <strong>Red Hat Enterprise Linux</strong> (<strong>RHEL</strong>).</div>
<p>Let's analyze the output in detail.</p>
<p>The first line is as follows:</p>
<pre style="padding-left: 30px">Unable to find image 'centos:latest' locally</pre>
<p>This tells us that Docker didn't find an image named <kbd>centos:latest</kbd> in the local cache of the system. So, Docker knows that it has to pull the image from some registry where container images are stored. By default, your Docker environment is configured so that images are pulled from Docker Hub at <kbd>docker.io</kbd>. This is expressed by the second line, as follows:</p>
<pre>latest: Pulling from library/centos </pre>
<p>The next three lines of output are as follows:</p>
<pre class="mce-root">8ba884070f61: Pull complete<br/>Digest: sha256:b5e66c4651870a1ad435cd75922fe2cb943c9e973a9673822d1414824a1d0475<br/>Status: Downloaded newer image for centos:latest</pre>
<p>This tells us that Docker has successfully pulled the <kbd>centos:latest</kbd> image from Docker Hub.</p>
<p>All of the subsequent lines of the output are generated by the process we ran inside the container, which is the Ping tool in this case. If you have been attentive so far, then you might have noticed the <kbd>latest</kbd> keyword occurring a few times. Each image has a version (also called <kbd>tag</kbd>), and if we don't specify a version explicitly, then Docker automatically assumes it is <kbd>latest</kbd>.</p>
<p>If we run the preceding container again on our system, the first five lines of the output will be missing since, this time, Docker will find the container image cached locally and hence won't have to download it first. Try it out and verify what I just told you.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running a random trivia question container</h1>
                
            
            
                
<p>For the subsequent sections of this chapter, we need a container that runs continuously in the background and produces some interesting output. That's why we have chosen an algorithm that produces random trivia questions. The API that produces that free random trivia can be found at <a href="http://jservice.io/" target="_blank">http://jservice.io/</a>.</p>
<p>Now the goal is to have a process running inside a container that produces a new random trivia question every five seconds and outputs the question to <kbd>STDOUT</kbd>. The following script will do exactly that:</p>
<pre>while : <br/>do <br/> wget -qO- http://jservice.io/api/random | jq .[0].question <br/> sleep 5 <br/>done</pre>
<p class="mce-root">Try it in a Terminal window. Stop the script by pressing <em>Ctrl </em>+ <em>C</em>. The output should look similar to this:</p>
<pre>"In 2004 Pitt alumna Wangari Maathai became the first woman from this continent to win the Nobel Peace Prize"<br/>"There are 86,400 of these in every day"<br/>"For $5 million in 2013 an L.A. movie house became TCL Chinese Theatre, but we bet many will still call it this, after its founder"<br/>^C</pre>
<p>Each response is a different trivia question.</p>
<div><p>You may need to install <kbd>jq</kbd> first on your macOS or Windows computer. <kbd>jq</kbd> is a handy tool often used to nicely filter and format JSON output, which increases the readability of it on the screen.</p>
</div>
<p>Now, let's run this logic in an <kbd>alpine</kbd> container. Since this is not just a simple command, we want to wrap the preceding script in a script file and execute that one. To make things simpler, I have created a Docker image called <kbd>fundamentalsofdocker/trivia</kbd> that contains all of the necessary logic, so that we can just use it here. Later on, once we have introduced Docker images, we will analyze this container image further. For the moment, let's just use it as is. Execute the following command to run the container as a background service. In Linux, a background service is also called a daemon:</p>
<pre><strong>$ docker container run -d --name trivia fundamentalsofdocker/trivia:ed2</strong></pre>
<p>In the preceding expression, we have used two new command-line parameters, <kbd>-d</kbd> and <kbd>--name</kbd>. Now, <kbd>-d</kbd> tells Docker to run the process running in the container as a Linux daemon. The <kbd>--name</kbd> parameter, in turn, can be used to give the container an explicit name. In the preceding sample, the name we chose is <kbd>trivia</kbd>.</p>
<p>If we don't specify an explicit container name when we run a container, then Docker will automatically assign the container a random but unique name. This name will be composed of the name of a famous scientist and an adjective. Such names could be <kbd>boring_borg</kbd> or <kbd>angry_goldberg</kbd>. They're quite humorous, our Docker engineers, <em>aren't they?</em></p>
<p>We are also using the tag <kbd>ed2</kbd> for the container. This tag just tells us that this image has been created for the second edition of this book.</p>
<p>One important takeaway is that the container name has to be unique on the system. Let's make sure that the trivia container is up and running:</p>
<pre><strong>$ docker container ls -l</strong></pre>
<p>This should give us something like this (shortened for readability):</p>
<pre>CONTAINER ID  IMAGE                            ... CREATED         STATUS ...<br/>0ff3d7cf7634  fundamentalsofdocker/trivia:ed2  ... 11 seconds ago  Up 9 seconds ...</pre>
<p>The important part of the preceding output is the <kbd>STATUS</kbd> column, which in this case is <kbd>Up 9 seconds</kbd>. That is, the container has been up and running for 9 seconds now.</p>
<p>Don't worry if the last Docker command is not yet familiar to you, we will come back to it in the next section.</p>
<p>To complete this section, let's stop and remove the <kbd>trivia</kbd> container with the following command:</p>
<pre><strong>$ docker rm -f trivia</strong></pre>
<p>Now it is time to learn how to list containers running or dangling on our system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing containers</h1>
                
            
            
                
<p>As we continue to run containers over time, we get a lot of them in our system. To find out what is currently running on our host, we can use the <kbd>container ls</kbd> command, as follows:</p>
<pre><strong>$ docker container ls</strong></pre>
<p>This will list all currently running containers. Such a list might look similar to this:</p>
<div><img src="img/068c2859-04d5-43a4-9e16-e1326761f468.png"/></div>
<p>List of all containers running on the system</p>
<p>By default, Docker outputs seven columns with the following meanings:</p>
<table style="border-collapse: collapse;width: 100.688%" border="1">
<tbody>
<tr style="height: 37.6563px">
<td style="width: 19.9576%;height: 37.6563px">
<p class="CDPAlignCenter CDPAlign"><br/>
<strong>Column</strong><br/></p>
</td>
<td style="width: 77.0424%;height: 37.6563px">
<p class="CDPAlignCenter CDPAlign"><br/>
<strong>Description</strong><br/></p>
</td>
</tr>
<tr style="height: 98px">
<td style="width: 19.9576%;height: 98px">
<p><kbd>Container ID</kbd></p>
</td>
<td style="width: 77.0424%;height: 98px">
<p>This is the unique ID of the container. It is an SHA-256.</p>
</td>
</tr>
<tr style="height: 65px">
<td style="width: 19.9576%;height: 65px">
<p><kbd>Image</kbd></p>
</td>
<td style="width: 77.0424%;height: 65px">
<p>This is the name of the container image from which this container is instantiated.</p>
</td>
</tr>
<tr style="height: 65px">
<td style="width: 19.9576%;height: 65px">
<p><kbd>Command</kbd></p>
</td>
<td style="width: 77.0424%;height: 65px">
<p>This is the command that is used to run the main process in the container.</p>
</td>
</tr>
<tr style="height: 65px">
<td style="width: 19.9576%;height: 65px">
<p><kbd>Created</kbd></p>
</td>
<td style="width: 77.0424%;height: 65px">
<p>This is the date and time when the container was created.</p>
</td>
</tr>
<tr style="height: 96px">
<td style="width: 19.9576%;height: 96px">
<p><kbd>Status</kbd></p>
</td>
<td style="width: 77.0424%;height: 96px">
<p>This is the status of the container (created, restarting, running, removing, paused, exited, or dead).</p>
</td>
</tr>
<tr style="height: 65px">
<td style="width: 19.9576%;height: 65px">
<p><kbd>Ports</kbd></p>
</td>
<td style="width: 77.0424%;height: 65px">
<p>This is the list of container ports that have been mapped to the host.</p>
</td>
</tr>
<tr style="height: 65px">
<td style="width: 19.9576%;height: 65px">
<p><kbd>Names</kbd></p>
</td>
<td style="width: 77.0424%;height: 65px">
<p>This is the name assigned to this container (multiple names are possible).</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If we want to list not only the currently running containers but all containers that are defined on our system, then we can use the command-line parameter <kbd>-a</kbd> or <kbd>--all</kbd>, as follows:</p>
<pre><strong>$ docker container ls -a</strong></pre>
<p>This will list containers in any state, such as <kbd>created</kbd>, <kbd>running</kbd>, or <kbd>exited</kbd>.</p>
<p>Sometimes, we want to just list the IDs of all containers. For this, we have the <kbd>-q</kbd> parameter:</p>
<pre><strong>$ docker container ls -q</strong></pre>
<p>You might wonder where this is useful. I will show you a command where it is very helpful right here:</p>
<pre><strong>$ docker container rm -f $(docker container ls -a -q)</strong></pre>
<p>Lean back and take a deep breath. Then, try to find out what the preceding command does. Don't read any further until you find the answer or give up.</p>
<p>The preceding command deletes all containers that are currently defined on the system, including the stopped ones. The <kbd>rm</kbd> command stands for remove, and it will be explained soon.</p>
<p>In the previous section, we used the <kbd>-l</kbd> parameter in the list command. Try to use Docker help to find out what the <kbd>-l</kbd> parameter stands for. You can invoke help for the list command as follows:</p>
<pre><strong>$ docker container ls -h<br/></strong></pre>
<p>Next, let's learn how to stop and restart containers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stopping and starting containers</h1>
                
            
            
                
<p>Sometimes, we want to (temporarily) stop a running container. Let's try this out with the trivia container we used previously:</p>
<ol>
<li>Run the container again with this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker container run -d --name trivia fundamentalsofdocker/trivia:ed2</strong></pre>
<ol start="2">
<li>Now, if we want to stop this container, then we can do so by issuing this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker container stop trivia</strong></pre>
<p>When you try to stop the trivia container, you will probably note that it takes a while until this command is executed. To be precise, it takes about 10 seconds. <em>Why is this the case?</em></p>
<p class="mce-root"/>
<p>Docker sends a Linux <kbd>SIGTERM</kbd> signal to the main process running inside the container. If the process doesn't react to this signal and terminate itself, Docker waits for 10 seconds and then sends <kbd>SIGKILL</kbd>, which will kill the process forcefully and terminate the container.</p>
<p>In the preceding command, we have used the name of the container to specify which container we want to stop. But we could have also used the container ID instead.</p>
<p><em>How do we get the ID of a container?</em> There are several ways of doing so. The manual approach is to list all running containers and find the one that we're looking for in the list. From there, we copy its ID. A more automated way is to use some shell scripting and environment variables. If, for example, we want to get the ID of the trivia container, we can use this expression:</p>
<pre><strong>$ export CONTAINER_ID=$(docker container ls -a | grep trivia | awk '{print $1}')</strong></pre>
<p>We are using the <kbd>-a</kbd> parameter with the Docker <kbd>container ls</kbd> command to list all containers, even the stopped ones. This is necessary in this case since we stopped the trivia container a moment ago.</p>
<p>Now, instead of using the container name, we can use the <kbd>$CONTAINER_ID</kbd> variable in our expression:</p>
<pre><strong>$ docker container stop $CONTAINER_ID </strong></pre>
<p>Once we have stopped the container, its status changes to <kbd>Exited</kbd>.</p>
<p>If a container is stopped, it can be started again using the <kbd>docker container start</kbd> command. Let's do this with our trivia container. It is good to have it running again, as we'll need it in the subsequent sections of this chapter:</p>
<pre><strong>$ docker container start trivia<br/></strong></pre>
<p>It is now time to discuss what to do with stopped containers that we don't need anymore.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing containers</h1>
                
            
            
                
<p>When we run the <kbd>docker container ls -a</kbd> command, we can see quite a few containers that are in the <kbd>Exited</kbd> status. If we don't need these containers anymore, then it is a good thing to remove them from memory; otherwise, they unnecessarily occupy precious resources. The command to remove a container is as follows:</p>
<pre><strong>$ docker container rm &lt;container ID&gt;</strong></pre>
<p>Another command to remove a container is the following:</p>
<pre><strong>$ docker container rm &lt;container name&gt;</strong></pre>
<p>Try to remove one of your exited containers using its ID.</p>
<p>Sometimes, removing a container will not work as it is still running. If we want to force a removal, no matter what the condition of the container currently is, we can use the command-line parameter <kbd>-f</kbd> or <kbd>--force</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inspecting containers</h1>
                
            
            
                
<p>Containers are runtime instances of an image and have a lot of associated data that characterizes their behavior. To get more information about a specific container, we can use the <kbd>inspect</kbd> command. As usual, we have to provide either the container ID or name to identify the container of which we want to obtain the data. So, let's inspect our sample container:</p>
<pre><strong>$ docker container inspect trivia </strong></pre>
<p>The response is a big JSON object full of details. It looks similar to this:</p>
<pre>[<br/>    {<br/>        "Id": "48630a3bf188...",<br/>        ...<br/>        "State": {<br/>            "Status": "running",<br/>            "Running": true,<br/>            ...<br/>        },<br/>        "Image": "sha256:bbc92c8f014d605...",<br/>        ...<br/>        "Mounts": [],<br/>        "Config": {<br/>            "Hostname": "48630a3bf188",<br/>            "Domainname": "",<br/>            ...<br/>        },<br/>        "NetworkSettings": {<br/>            "Bridge": "",<br/>            "SandboxID": "82aed83429263ceb6e6e...",<br/>            ...<br/>        }<br/>    }<br/>]</pre>
<p>The output has been shortened for readability.</p>
<p>Please take a moment to analyze what you got. You should see information such as the following:</p>
<ul>
<li>The ID of the container</li>
<li>The creation date and time of the container</li>
<li>The image from which the container is built</li>
</ul>
<p>Many sections of the output, such as <kbd>Mounts</kbd> or <kbd>NetworkSettings</kbd>, don't make much sense right now, but we will certainly discuss those in the upcoming chapters of this book. The data you're seeing here is also named the metadata of a container. We will be using the <kbd>inspect</kbd> command quite often in the remainder of this book as a source of information.</p>
<p>Sometimes, we need just a tiny bit of the overall information, and to achieve this, we can either use the grep tool or a filter. The former method does not always result in the expected answer, so let's look into the latter approach:</p>
<pre><strong>$ docker container inspect -f "{{json .State}}" trivia | jq .</strong></pre>
<p>The <kbd>-f</kbd> or <kbd>--filter</kbd> parameter is used to define the filter. The filter expression itself uses the Go template syntax. In this example, we only want to see the state part of the whole output in the JSON format.</p>
<p>To nicely format the output, we pipe the result into the <kbd>jq</kbd> tool:</p>
<pre>{<br/>  "Status": "running",<br/>  "Running": true,<br/>  "Paused": false,<br/>  "Restarting": false,<br/>  "OOMKilled": false,<br/>  "Dead": false,<br/>  "Pid": 18252,<br/>  "ExitCode": 0,<br/>  "Error": "",<br/>  "StartedAt": "2019-06-16T13:30:15.776272Z",<br/>  "FinishedAt": "2019-06-16T13:29:38.6412298Z"<br/>}</pre>
<p>After we have learned how to retrieve loads of important and useful meta information about a container, we now want to investigate how we can execute it in a running container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exec into a running container</h1>
                
            
            
                
<p>Sometimes, we want to run another process inside an already-running container. A typical reason could be to try to debug a misbehaving container. <em>How can we do this?</em> First, we need to know either the ID or the name of the container, and then we can define which process we want to run and how we want it to run. Once again, we use our currently running trivia container and we run a shell interactively inside it with the following command:</p>
<pre><strong>$ docker container exec -i -t trivia /bin/sh</strong></pre>
<p>The <kbd>-i</kbd> flag signifies that we want to run the additional process interactively, and <kbd>-t</kbd> tells Docker that we want it to provide us with a TTY (a Terminal emulator) for the command. Finally, the process we run is <kbd>/bin/sh</kbd>.</p>
<p>If we execute the preceding command in our Terminal, then we will be presented with a new prompt, <kbd>/app #</kbd>. We're now in a shell inside the trivia container. We can easily prove that by, for example, executing the <kbd>ps</kbd> command, which will list all running processes in the context:</p>
<pre><strong>/app # ps</strong></pre>
<p>The result should look somewhat similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-850 image-border" src="img/4f28c7e4-bd1d-42f6-9b52-ed75c1a3f98e.png" style="width:30.50em;height:7.92em;"/></p>
<p>List of processes running inside the trivia container</p>
<p>We can clearly see that the process with <kbd>PID 1</kbd> is the command that we have defined to run inside the trivia container. The process with <kbd>PID 1</kbd> is also named the main process.</p>
<p>Leave the container by pressing <em>Ctrl </em>+ <em>D</em>. We cannot only execute additional processes interactive in a container. Please consider the following command:</p>
<pre><strong>$ docker container exec trivia ps</strong></pre>
<p>The output evidently looks very similar to the preceding output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-851 image-border" src="img/484111d6-69b2-44fc-9529-4d42a780eecc.png" style="width:28.75em;height:7.42em;"/></p>
<p>List of processes running inside the trivia container</p>
<p>We can even run processes as a daemon using the <kbd>-d</kbd> flag and define environment variables using the <kbd>-e</kbd> flag variables, as follows:</p>
<pre><strong>$ docker container exec -it \</strong><br/><strong>    -e MY_VAR="Hello World" \</strong><br/><strong>    trivia /bin/sh</strong><br/><strong>/app # echo $MY_VAR</strong><br/><strong>Hello World</strong><br/><strong>/app # &lt;CTRL-d&gt;</strong></pre>
<p>Great, we have learned how to execute into a running container and run additional processes. But there is another important way to mingle with a running container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching to a running container</h1>
                
            
            
                
<p>We can use the <kbd>attach</kbd> command to attach our Terminal's standard input, output, and error (or any combination of the three) to a running container using the ID or name of the container. Let's do this for our trivia container:</p>
<pre><strong>$ docker container attach trivia</strong></pre>
<p>In this case, we will see every five seconds or so a new quote appearing in the output.</p>
<p>To quit the container without stopping or killing it, we can press the key combination <em>Ctrl </em>+ <em>P</em>+ <em>Ctrl </em>+ <em>Q</em>. This detaches us from the container while leaving it running in the background. On the other hand, if we want to detach and stop the container at the same time, we can just press <em>Ctrl</em> + <em>C.</em></p>
<p>Let's run another container, this time an Nginx web server:</p>
<pre><strong>$ docker run -d --name nginx -p 8080:80 nginx:alpine</strong></pre>
<p>Here, we run the Alpine version of Nginx as a daemon in a container named <kbd>nginx</kbd>. The <kbd>-p 8080:80</kbd> command-line parameter opens port <kbd>8080</kbd> on the host for access to the Nginx web server running inside the container. Don't worry about the syntax here as we will explain this feature in more detail in <a href="f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml" target="_blank">Chapter 10</a>, <em>S</em><em>ingle-Host Networking</em>:</p>
<ol>
<li>Let's see whether we can access Nginx using the <kbd>curl</kbd> tool and running this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -4 localhost:8080</strong></pre>
<p style="padding-left: 60px">If all works correctly, you should be greeted by the welcome page of Nginx (shortened for readability):</p>
<pre style="padding-left: 60px">&lt;html&gt; 
&lt;head&gt; 
&lt;title&gt;Welcome to nginx!&lt;/title&gt; 
&lt;style&gt; 
    body { 
        width: 35em; 
        margin: 0 auto; 
        font-family: Tahoma, Verdana, Arial, sans-serif; 
    } 
&lt;/style&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt; 
...
&lt;/html&gt; </pre>
<ol start="2">
<li>Now, let's attach our Terminal to the <kbd>nginx</kbd> container to observe what's happening:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker container attach nginx</strong></pre>
<ol start="3">
<li>Once you are attached to the container, you first will not see anything. But now open another Terminal, and in this new Terminal window, repeat the <kbd>curl</kbd> command a few times, for example, using the following script:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ for n in {1..10}; do curl -4 localhost:8080; done  </strong></pre>
<p style="padding-left: 60px">You should see the logging output of Nginx, which looks similar to this:</p>
<pre style="padding-left: 60px">172.17.0.1 - - [16/Jun/2019:14:14:02 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.54.0" "-"<br/>172.17.0.1 - - [16/Jun/2019:14:14:02 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.54.0" "-"<br/>172.17.0.1 - - [16/Jun/2019:14:14:02 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.54.0" "-"<br/>...</pre>
<ol start="4">
<li>Quit the container by pressing <em>Ctrl </em>+ <em>C</em>. This will detach your Terminal and, at the same time, stop the <kbd>nginx</kbd> container.</li>
<li>To clean up, remove the <kbd>nginx</kbd> container with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker container rm nginx<br/></strong></pre>
<p>In the next section, we're going to learn how to work with container logs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving container logs</h1>
                
            
            
                
<p>It is a best practice for any good application to generate some logging information that developers and operators alike can use to find out what the application is doing at a given time, and whether there are any problems to help to pinpoint the root cause of the issue.</p>
<p>When running inside a container, the application should preferably output the log items to <kbd>STDOUT</kbd> and <kbd>STDERR</kbd> and not into a file. If the logging output is directed to <kbd>STDOUT</kbd> and <kbd>STDERR</kbd>, then Docker can collect this information and keep it ready for consumption by a user or any other external system:</p>
<ol>
<li>To access the logs of a given container, we can use the <kbd>docker container logs</kbd> command. If, for example, we want to retrieve the logs of our <kbd>trivia</kbd> container, we can use the following expression:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker container logs trivia</strong></pre>
<p style="padding-left: 60px">This will retrieve the whole log produced by the application from the very beginning of its existence.</p>
<p>Stop, wait a second—this is not quite true, what I just said. By default, Docker uses the so-called <kbd>json-file</kbd> logging driver. This driver stores the logging information in a file. And if there is a file rolling policy defined, then <kbd>docker container logs</kbd> only retrieves what is in the current active log file and not what is in previous rolled files that might still be available on the host.</p>
<ol start="2">
<li>If we want to only get a few of the latest entries, we can use the <kbd>-t</kbd> or <kbd>--tail</kbd> parameter, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker container logs --tail 5 trivia</strong></pre>
<p style="padding-left: 60px">This will retrieve only the last five items the process running inside the container produced.</p>
<p style="padding-left: 60px">Sometimes, we want to follow the log that is produced by a container. This is possible when using the <kbd>-f</kbd> or <kbd>--follow</kbd> parameter. The following expression will output the last five log items and then follow the log as it is produced by the containerized process:</p>
<pre style="padding-left: 60px"><strong>$ docker container logs --tail 5 --follow trivia </strong></pre>
<p>Often using the default mechanism for container logging is not enough. We need a different way of logging. This is discussed in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Logging drivers</h1>
                
            
            
                
<p>Docker includes multiple logging mechanisms to help us to get information from running containers. These mechanisms are named<strong> logging drivers</strong>. Which logging driver is used can be configured at the Docker daemon level. The default logging driver is <kbd>json-file</kbd>. Some of the drivers that are currently supported natively are as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 18.595%">
<p class="CDPAlignCenter CDPAlign"><strong>Driver</strong><br/></p>
</td>
<td style="width: 80.5785%">
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong><br/></p>
</td>
</tr>
<tr>
<td style="width: 18.595%">
<p><kbd>none</kbd></p>
</td>
<td style="width: 80.5785%">
<p>No log output for the specific container is produced.</p>
</td>
</tr>
<tr>
<td style="width: 18.595%">
<p><kbd>json-file</kbd></p>
</td>
<td style="width: 80.5785%">
<p>This is the default driver. The logging information is stored in files, formatted as JSON.</p>
</td>
</tr>
<tr>
<td style="width: 18.595%">
<p><kbd>journald</kbd></p>
</td>
<td style="width: 80.5785%">
<p>If the journals daemon is running on the host machine, we can use this driver. It forwards logging to the <kbd>journald</kbd> daemon.</p>
</td>
</tr>
<tr>
<td style="width: 18.595%">
<p><kbd>syslog</kbd></p>
</td>
<td style="width: 80.5785%">
<p>If the <kbd>syslog</kbd> daemon is running on the host machine, we can configure this driver, which will forward the log messages to the <kbd>syslog</kbd> daemon.</p>
</td>
</tr>
<tr>
<td style="width: 18.595%">
<p><kbd>gelf</kbd></p>
</td>
<td style="width: 80.5785%">
<p>When using this driver, log messages are written to a <strong>Graylog Extended Log Format</strong> (<strong>GELF</strong>) endpoint. Popular examples of such endpoints are Graylog and Logstash.</p>
</td>
</tr>
<tr>
<td style="width: 18.595%">
<p><kbd>fluentd</kbd></p>
</td>
<td style="width: 80.5785%">
<p>Assuming that the <kbd>fluentd</kbd> daemon is installed on the host system, this driver writes log messages to it.</p>
</td>
</tr>
</tbody>
</table>
<p>If you change the logging driver, please be aware that the <kbd>docker container logs</kbd> command is only available for the <kbd>json-file</kbd> and <kbd>journald</kbd> drivers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a container-specific logging driver</h1>
                
            
            
                
<p>We have seen that the logging driver can be set globally in the Docker daemon configuration file. But we can also define the logging driver on a container by container basis. In the following example, we are running a <kbd>busybox</kbd> container and use the <kbd>--log-driver</kbd> parameter to configure the <kbd>none</kbd> logging driver:</p>
<pre><strong>$ docker container run --name test -it \</strong><br/><strong>    --log-driver none \</strong><br/><strong>    busybox sh -c 'for N in 1 2 3; do echo "Hello $N"; done'</strong></pre>
<p>We should see the following:</p>
<pre>Hello 1
Hello 2<br/>Hello 3 </pre>
<p>Now, let's try to get the logs of the preceding container:</p>
<pre><strong>$ docker container logs test</strong></pre>
<p>The output is as follows:</p>
<pre>Error response from daemon: configured logging driver does not support reading</pre>
<p>This is to be expected since the <kbd>none</kbd> driver does not produce any logging output. Let's clean up and remove the <kbd>test</kbd> container:</p>
<pre><strong>$ docker container rm test</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced topic – changing the default logging driver</h1>
                
            
            
                
<p>Let's change the default logging driver of a Linux host:</p>
<ol>
<li>The easiest way to do this is on a real Linux host. For this purpose, we're going to use Vagrant with an Ubuntu image:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ vagrant init bento/ubuntu-17.04
$ vagrant up
$ vagrant ssh</strong></pre>
<div><strong>Vagrant</strong> is an open source tool developed by Hashicorp that is often used for building and maintaining portable virtual software development environments.</div>
<ol start="2">
<li>Once inside the Ubuntu VM, we want to edit the Docker daemon configuration file. Navigate to the <kbd>/etc/docker</kbd> folder and run <kbd>vi</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ vi daemon.json  </strong></pre>
<ol start="3">
<li>Enter the following content:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  "Log-driver": "json-log",<br/>  "log-opts": {<br/>    "max-size": "10m",<br/>    "max-file": 3<br/>  }<br/>}</pre>
<ol start="4">
<li>Save and exit <kbd>vi</kbd> by first pressing <em>Esc</em><em> </em>and then typing <kbd>:w:q</kbd> and finally hitting the <em>Enter</em> key.</li>
</ol>
<p style="padding-left: 60px">The preceding definition tells the Docker daemon to use the <kbd>json-log</kbd> driver with a maximum log file size of 10 MB before it is rolled, and the maximum number of log files that can be present on the system is <kbd>3</kbd> before the oldest file gets purged.</p>
<p style="padding-left: 60px">Now we have to send a <kbd>SIGHUP</kbd> signal to the Docker daemon so that it picks up the changes in the configuration file:</p>
<pre style="padding-left: 60px"><strong>$ sudo kill -SIGHUP $(pidof dockerd)</strong></pre>
<p>Note that the preceding command only reloads the config file and does not restart the daemon.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Anatomy of containers</h1>
                
            
            
                
<p>Many people wrongly compare containers to VMs. However, this is a questionable comparison. Containers are not just lightweight VMs. OK then, <em>what is the correct description of a container?</em></p>
<p>Containers are specially encapsulated and secured processes running on the host system. Containers leverage a lot of features and primitives available in the Linux OS. The most important ones are <em>namespaces </em>and <em>cgroups</em>. All processes running in containers only share the same Linux kernel of the underlying host operating system. This is fundamentally different compared with VMs, as each VM contains its own full-blown operating system.</p>
<p>The startup times of a typical container can be measured in milliseconds, while a VM normally needs several seconds to minutes to start up. VMs are meant to be long-living. It is a primary goal of each operations engineer to maximize the uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They come and go relatively quickly.</p>
<p>Let's first get a high-level overview of the architecture that enables us to run containers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecture</h1>
                
            
            
                
<p>Here, we have an architectural diagram on how this all fits together:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-853 image-border" src="img/350f0f91-f671-4ed5-9eae-0f0d6c5dae6e.png" style="width:38.50em;height:19.42em;"/></p>
<p>High-level architecture of Docker</p>
<p>In the lower part of the preceding diagram, we have the Linux operating system with its <strong>cgroups</strong>, <strong>Namespaces</strong>, and <strong>Layer</strong> <strong>Capabilities</strong> as well as <strong>Other OS Functionality</strong> that we do not need to explicitly mention here. Then, there is an intermediary layer composed of <strong>containerd</strong> and <strong>runc</strong>. On top of all that now sits the <strong>Docker engine</strong>. The <strong>Docker engine</strong> offers a RESTful interface to the outside world that can be accessed by any tool, such as the Docker CLI, Docker for macOS, and Docker for Windows or Kubernetes to name just a few.</p>
<p>Let's now describe the main building blocks in a bit more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Namespaces</h1>
                
            
            
                
<p>Linux namespaces had been around for years before they were leveraged by Docker for their containers. A namespace is an abstraction of global resources such as filesystems, network access, and process trees (also named PID namespaces) or the system group IDs and user IDs. A Linux system is initialized with a single instance of each namespace type. After initialization, additional namespaces can be created or joined.</p>
<p>The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version 3.8, user namespaces were introduced and with it, namespaces were ready to be used by containers.</p>
<p>If we wrap a running process, say, in a filesystem namespace, then this process has the illusion that it owns its own complete filesystem. This, of course, is not true; it is only a virtual filesystem. From the perspective of the host, the contained process gets a shielded subsection of the overall filesystem. It is like a filesystem in a filesystem:</p>
<div><img class="alignnone size-full wp-image-855 image-border" src="img/9ce9575c-b97c-4da2-8cf9-13bf1b9bd15b.png" style="width:33.17em;height:26.00em;"/></div>
<p>Filesystem namespaces on Linux</p>
<p>The same applies to all of the other global resources for which namespaces exist. The user ID namespace is another example. Having a user namespace, we can now define a <kbd>jdoe </kbd>user many times on the system as long as it is living in its own namespace.</p>
<p>The PID namespace is what keeps processes in one container from seeing or interacting with processes in another container. A process might have the apparent PID <strong>1</strong> inside a container, but if we examine it from the host system, it would have an ordinary PID, say <strong>334</strong>:</p>
<div><img src="img/a4d80d0a-451d-40dd-9c62-90b7c451dce9.png" style="width:33.33em;height:19.67em;"/></div>
<p>Process tree on a Docker host</p>
<p>In a given namespace, we can run one to many processes. That is important when we talk about containers, and we have experienced that already when we executed another process in an already-running container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Control groups (cgroups)</h1>
                
            
            
                
<p>Linux cgroups are used to limit, manage, and isolate resource usage of collections of processes running on a system. Resources are CPU time, system memory, network bandwidth, or combinations of these resources, and so on.</p>
<p>Engineers at Google originally implemented this feature in 2006. The cgroups functionality was merged into the Linux kernel mainline in kernel version 2.6.24, which was released in January 2008.</p>
<p>Using cgroups, administrators can limit the resources that containers can consume. With this, we can avoid, for example, the classical <em>noisy neighbor</em> problem, where a rogue process running in a container consumes all CPU time or reserves massive amounts of RAM and, as such, starves all of the other processes running on the host, whether they're containerized or not.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Union filesystem (Unionfs)</h1>
                
            
            
                
<p>Unionfs forms the backbone of what is known as container images. We will discuss container images in detail in the next chapter. At this time, we want to just understand a bit better what Unionfs is, and how it works. Unionfs is mainly used on Linux and allows files and directories of distinct filesystems to be overlaid to form a single coherent filesystem. In this context, the individual filesystems are called branches. Contents of directories that have the same path within the merged branches will be seen together in a single merged directory, within the new virtual filesystem. When merging branches, the priority between the branches is specified. In that way, when two branches contain the same file, the one with the higher priority is seen in the final filesystem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Container plumbing</h1>
                
            
            
                
<p>The basement on top of which the Docker engine is built; is the <strong>container plumbing</strong> and is formed by two components, <strong>runc</strong> and <strong>containerd</strong>.</p>
<p>Originally, Docker was built in a monolithic way and contained all of the functionality necessary to run containers. Over time, this became too rigid and Docker started to break out parts of the functionality into their own components. Two important components are runc and containerd.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">runC</h1>
                
            
            
                
<p>runC is a lightweight, portable container runtime. It provides full support for Linux namespaces as well as native support for all security features available on Linux, such as SELinux, AppArmor, seccomp, and cgroups.</p>
<p>runC is a tool for spawning and running containers according to the <strong>Open Container Initiative</strong> (<strong>OCI</strong>) specification. It is a formally specified configuration format, governed by the <strong>Open Container Project</strong> (<strong>OCP</strong>) under the auspices of the Linux Foundation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Containerd</h1>
                
            
            
                
<p>runC is a low-level implementation of a container runtime; containerd builds on top of it and adds higher-level features, such as image transfer and storage, container execution, and supervision as well as network and storage attachments. With this, it manages the complete life cycle of containers. Containerd is the reference implementation of the OCI specifications and is by far the most popular and widely used container runtime.</p>
<p>Containerd was donated to and accepted by the CNCF in 2017. There exist alternative implementations of the OCI specification. Some of them are rkt by CoreOS, CRI-O by RedHat, and LXD by Linux Containers. However, containerd at this time is by far the most popular container runtime and is the default runtime of Kubernetes 1.8 or later and the Docker platform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned how to work with containers that are based on existing images. We showed how to run, stop, start, and remove a container. Then, we inspected the metadata of a container, extracted the logs of it, and learned how to run an arbitrary process in an already-running container. Last but not least, we dug a bit deeper and investigated how containers work and what features of the underlying Linux operating system they leverage.</p>
<p>In the next chapter, you're going to learn what container images are and how we can build and share our own custom images. We'll also be discussing the best practices commonly used when building custom images, such as minimizing their size and leveraging the image cache. Stay tuned!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<p class="mce-root">To assess your learning progress, please answer the following questions:</p>
<ol>
<li>What are the states of a container?</li>
<li>Which command helps us to find out what is currently running on our Docker host?</li>
<li>Which command is used to list the IDs of all containers?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>The following articles give you some more information related to the topics we discussed in this chapter:</p>
<ul>
<li>Docker containers at <a href="http://dockr.ly/2iLBV2I" target="_blank">http://dockr.ly/2iLBV2I</a></li>
<li>Getting started with containers at <a href="http://dockr.ly/2gmxKWB" target="_blank">http://dockr.ly/2gmxKWB</a></li>
<li>Isolating containers with a user namespace at <a href="http://dockr.ly/2gmyKdf" target="_blank">http://dockr.ly/2gmyKdf</a></li>
<li>Limiting a container's resources at <a href="http://dockr.ly/2wqN5Nn" target="_blank">http://dockr.ly/2wqN5Nn</a></li>
</ul>


            

            
        
    </body></html>