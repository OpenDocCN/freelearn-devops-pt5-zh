<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-153"><a id="_idTextAnchor150"/>7</h1>
<h1 id="_idParaDest-154"><a id="_idTextAnchor151"/>Testing Applications Running in Containers</h1>
<p>In the previous chapters, we have learned how we can containerize our applications written in any language, such as Node.js, Python, Java, C#, and .NET. We all know that just writing code and then shipping it to production is not enough. We also need to guarantee that the code is error-free and that it does what it is supposed to do. This is commonly subsumed <a id="_idIndexMarker571"/>under the term <strong class="bold">quality assurance</strong>, or <strong class="bold">QA</strong> for short.</p>
<p>It has been proven in practice over and over again that fixing a bug in an application that has been discovered in production as opposed to during development is very costly. We want to avoid this. The most cost-effective way to do so is to have the developer who writes the code also write automated tests that make sure the new or changed code is of high quality and performs exactly as specified in the acceptance criteria of the business requirement or feature specification.</p>
<p>Here is a list of the topics we are going to discuss in this chapter:</p>
<ul>
<li>The benefits of testing applications running in containers</li>
<li>Different types of testing</li>
<li>Commonly used tools and technologies</li>
<li>Best practices for setting up a testing environment</li>
<li>Tips for debugging and troubleshooting issues</li>
<li>Challenges and considerations when testing applications running in containers</li>
<li>Case studies</li>
</ul>
<p>After reading this chapter, you will be able to do the following:</p>
<ul>
<li>Explain the benefits of testing applications running in containers to an interested layperson</li>
<li>Set up a productive environment that allows you to write and execute tests for applications or services running in containers</li>
<li>Develop unit and integration tests for code running in a container</li>
<li>Run your unit and integration tests in a container with the application code under test</li>
<li>Run a dedicated container with functional tests that act on your application as a black box</li>
<li>Manage application dependencies and create test data</li>
</ul>
<h1 id="_idParaDest-155"><a id="_idTextAnchor152"/>Technical requirements</h1>
<p>In this chapter, you need Docker Desktop, a terminal, and VS Code installed on your Mac, Windows, or Linux machine. As we will work with code, you should prepare a chapter folder in the code repository you cloned from GitHub:</p>
<ol>
<li>Navigate to the folder to which you cloned the GitHub repository accompanying this book. Normally, you do this as follows:<pre class="console">
$ cd ~/The-Ultimate-Docker-Container-Book</pre></li> <li>Create a chapter folder in this directory and navigate to it:<pre class="console">
$ mkdir ch07 &amp;&amp; cd ch07</pre></li> </ol>
<p>As always, you can find complete sample solutions for all the exercises we will do in this chapter in the <code>sample-solutions/ch07</code> subfolder.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor153"/>Benefits of testing applications in containers</h1>
<p>In this section, we are <a id="_idIndexMarker572"/>discussing the benefits of testing applications in containers, including the ability to replicate production environments, ease of configuration and setup, and faster test execution.</p>
<p>But before we start, letâ€™s pause for a second and ask ourselves, why do we care to test at all?</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor154"/>Why do we test?</h2>
<p>Every person working in any role in software development is aware that one needs to implement and <a id="_idIndexMarker573"/>ship new or changed application features at a fast cadence. There is constant pressure to implement new code and ship it as quickly as possible to production. But business analysts that write the feature specifications and software engineers that write the actual code implementing the specifications are just human beings. Human beings working under a lot of pressure tend to make mistakes. These mistakes can be subtle, or they can be quite substantial. Those mistakes will manifest themselves in the application running in production. Our customers will discover them, and this will have consequences.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor155"/>Manual versus automated testing</h2>
<p>Most companies that write commercial applications will have a team of manual software testers. These people will take the newest version of the application that product engineering has prepared for them and execute a suite of manual regression tests <a id="_idIndexMarker574"/>against this application. If a manual tester discovers a bug, they will report it in a tool such as <a id="_idIndexMarker575"/>Jira as a bug ticket, where they will ideally <a id="_idIndexMarker576"/>write down all the necessary details that matter for the developer who will have to fix the bug. This includes the exact version of the application tested, the steps that the tester took before the bug was detected, and some evidence of the bug, such as screenshots, error messages, stack traces, and log entries. These tickets written by manual testers will become part of the backlog of product engineering.</p>
<p>Product engineering will then, together with the testers, triage all the new bug tickets on a regular basis, say daily, and decide how quickly a particular bug needs to be addressed. Usually, the classification of P1, P2, P3, and P4 is used, where P1 is a defect of the highest severity that needs to be fixed immediately, and P4 is a bug that is of low priority and can be dealt with whenever the team has time.</p>
<p>If the application is a typical enterprise application consisting of many services all running in the cloud, then the testers need a special environment where they can perform their <a id="_idIndexMarker577"/>regression testing. This environment is often called <strong class="bold">user acceptance testing</strong>, or <strong class="bold">UAT</strong> for short. A full test suite for such an enterprise application usually consists of several hundred test cases. To perform a single test case takes a manual tester a considerable amount of time. It is not unheard of that a team of dedicated manual testers needs a couple of weeks to perform a full test run. During <a id="_idIndexMarker578"/>this time, the UAT environment is blocked. No new version can be deployed to this environment, because otherwise the testers would have to restart their regression testing. Each <a id="_idIndexMarker579"/>change in the application can introduce <a id="_idIndexMarker580"/>new bugs, and we can only be certain to catch them all if we execute the whole suite of regression tests on each new version.</p>
<p>Only after the manual testers have run through all regression tests, and only if no more severe bugs have been discovered, can the current version of the application be shipped to production.</p>
<p>I bet you can imagine that having UAT blocked for several weeks at a time can introduce some significant problems in the software development process. Your many product engineering teams will have accumulated a lot of new code in the form of new features and bug fixes that are blocked from being shipped to production since the manual testers are still testing the previous version. But accumulating a lot of code changes does, at the same time, increase risk. To ship a piece of software that has undergone many changes is riskier than if we continuously ship new versions with minimal changes to production.</p>
<p>The only real solution to this problem is to shorten the regression test cycle. We need to shorten it from weeks to minutes or a small number of hours. This way, we can test and ship small batches of changes in a continuous fashion. But no human being is able to test so fast. The solution is to exclusively use automated testing. And yes, I mean it: we should rely exclusively on automated regression and acceptance testing.</p>
<p>What did we learn? Manual testing is not scalable, it is super boring, since the testers have to repeat the same tests over and over again, and it is error prone, since everything humans do is not automated and thus not exactly repeatable every time.</p>
<p>Does this mean we have to fire all manual testers? Not necessarily. Manual testers should not perform acceptance and regression tests but rather exploratory tests. Manual testers are human beings, and they should leverage that fact and their creativity to discover yet undiscovered potential defects in the application. As the term <em class="italic">exploratory testing</em> implies, these tests are not following a particular script, but are rather random and only guided by the professional experience of the tester and their understanding <a id="_idIndexMarker581"/>of the business domain for which the application has been written. If the tester discovers <a id="_idIndexMarker582"/>a bug, they write a ticket for it, which <a id="_idIndexMarker583"/>then will be triaged and flown into the backlog of the development teams.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor156"/>Why do we test in containers?</h2>
<p>There are <a id="_idIndexMarker584"/>several reasons why it is often useful to run tests in containers:</p>
<ul>
<li><strong class="bold">Isolation</strong>: Running tests in containers can provide a level of isolation between the test environment and the host system, which can be useful for ensuring that the test results are consistent and repeatable.</li>
<li><strong class="bold">Environment consistency</strong>: Containers allow you to package the entire test environment (including dependencies, libraries, and configuration) in a self-contained unit, which can help to ensure that the test environment is consistent across different development environments.</li>
<li><strong class="bold">Ease of use</strong>: Containers can make it easier to set up and run tests, as you donâ€™t have to manually install and configure all of the required dependencies and libraries on the host system.</li>
<li><strong class="bold">Portability</strong>: Containers can be easily moved between different environments, which can be useful for running tests in different environments or on different platforms.</li>
<li><strong class="bold">Scalability</strong>: Containers can make it easier to scale up your test infrastructure by allowing you to run tests in parallel or on multiple machines.</li>
</ul>
<p>Overall, running tests in containers can help to improve the reliability, consistency, and scalability of the testing process and can make it easier to set up and maintain a testing environment that is isolated from the host system.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor157"/>Different types of testing</h1>
<p>This section <a id="_idIndexMarker585"/>gives an overview of different types of testing that can be performed on applications running in containers, including unit tests, integration tests, and acceptance tests.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor158"/>Unit tests</h2>
<p>A unit testâ€™s primary <a id="_idIndexMarker586"/>objective is to validate the functionality of a <em class="italic">unit</em>, or tiny, isolated portion of code. In order to check that the code is accurate and operates as expected, developers frequently build unit tests as they create or modify the code. These tests are then routinely executed as part of the development process.</p>
<p>With no reliance on <a id="_idIndexMarker587"/>other resources or components, unit tests are made to test distinct pieces of code in isolation. This enables developers to find and quickly solve bugs in their code and makes them quick and simple to run.</p>
<p>Typically, tools and testing frameworks that facilitate the creation, running, and reporting of unit tests are used to generate unit tests. These tools frequently offer capabilities such as automatic test discovery, test execution, and test results reporting, and they enable developers to create unit tests using a particular syntax or structure.</p>
<p>A thorough testing approach should include unit tests, since they enable developers to verify that their code is valid and works as intended at the most granular level. Normally, they are <a id="_idIndexMarker588"/>executed as a part of a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) process, which is a workflow in which code changes are automatically executed each time they are committed to a version control system.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor159"/>Integration tests</h2>
<p>Software testing called <em class="italic">integration testing</em> examines how well various systems or components <a id="_idIndexMarker589"/>function together as a whole. It usually follows <a id="_idIndexMarker590"/>unit testing and entails examining how various parts of an application or system interact with one another.</p>
<p>Integration tests are created to examine how well various units or components interact together. They are frequently used to confirm that an applicationâ€™s or systemâ€™s various components can function as intended. Testing the integration of several software components or the integration of a software program with external resources such as databases or APIs are examples of this.</p>
<p>As many components or systems need to be set up and configured in order to execute the tests, integration tests are typically more complicated and time-consuming than unit tests. In order to <a id="_idIndexMarker591"/>enable the execution and reporting of the tests, they could <a id="_idIndexMarker592"/>also call for the employment of specialist testing tools and frameworks.</p>
<p>Integration tests, like unit tests, are a crucial component of a thorough testing approach, because they enable developers to confirm that several systems or components can function together as intended.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor160"/>Acceptance tests</h2>
<p>Software testing of this kind, known as <em class="italic">acceptance testing</em>, ensures that a system or application is <a id="_idIndexMarker593"/>suitable for its intended use and that it satisfies all <a id="_idIndexMarker594"/>of the requirements. It usually comes after all other types of testing (such as unit testing and integration testing) and is the last step in the testing procedure.</p>
<p>Acceptance tests are typically developed and carried out by a different team or group of testers who are tasked with assessing the system or application from the viewpoint of the end user. These tests are intended to make sure that the system or program is simple to use, fits the demands of the intended users, and is user-friendly.</p>
<p>Functional testing (to ensure that the application or system performs the required functions correctly), usability testing (to make sure that the application or system is easy to use), and performance testing are just a few examples of the different types of testing that may be included in acceptance tests (to verify that the application or system performs well under different load conditions).</p>
<p>Acceptance testing is a crucial step in the software development process, since it enables developers to confirm that the system or application is ready for deployment and satisfies the needs of the intended customers. Although it is highly recommended to employ automated acceptance testing technologies to assist the testing process, it is often carried out manually by testers.</p>
<p>In this chapter, we will look at a special type <a id="_idIndexMarker595"/>of acceptance test called <em class="italic">black box tests</em>. The main differentiator compared to unit and integration tests is that these black box tests look at the system under tests from a decidedly business-oriented perspective. Ideally, acceptance tests, and with it black box tests, reflect the acceptance criteria to be found in the feature specifications written by business analysts or product owners. Most often, acceptance tests are written in a way that they look at the component <a id="_idIndexMarker596"/>to be tested as a black box. The internals of <a id="_idIndexMarker597"/>this component do not and should not matter. The test code only ever accesses the component or system under test via its public interfaces. Typically, public interfaces are APIs or messages that the component consumes or produces.</p>
<div><div><img alt="Figure 7.1 â€“ Acceptance test interacting with the system under test" height="382" src="img/B19199_07_01.jpg" width="330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 â€“ Acceptance test interacting with the system under test</p>
<p>In the <a id="_idIndexMarker598"/>preceding figure, we can see how the test code is structured in the popular format of <strong class="bold">Arrange-Act-Assert</strong>, or <strong class="bold">AAA</strong>. First, we set up the boundary conditions (arrange). Next, we specify the action to exercise on the system under test (act). Finally, we verify <a id="_idIndexMarker599"/>that the outcome of the action is as expected (assert). The <strong class="bold">system under test</strong> (<strong class="bold">SUT</strong>) is the component that has a public interface in the form of either a REST API and/or messages that it consumes from a message bus. The SUT, in most cases, also has a database where it stores it state.</p>
<p>In the next section, we will present tools and technologies used for testing.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor161"/>Commonly used tools and technologies</h1>
<p>Letâ€™s now <a id="_idIndexMarker600"/>discuss the tools and technologies that are commonly used <a id="_idIndexMarker601"/>for testing applications running in containers, such as Docker, Kubernetes, and <strong class="bold">continuous integration and delivery</strong> (<strong class="bold">CI/CD</strong>) platforms.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor162"/>Implementing a sample component</h2>
<p>In this section, we want to implement a sample component that we are later going to use to <a id="_idIndexMarker602"/>demonstrate how we can write and execute tests for, and, specifically, how we can combine the advantage of automated tests and the use of Docker containers. We will implement the sample component using recent versions of Java and Spring Boot.</p>
<p>This sample <a id="_idIndexMarker603"/>component represents a simple REST API with some CRUD logic behind it. The tasks of creating and managing lists of animal species and associated races are simple enough to not warrant more complicated modeling. For simplicity, we are working with the in-memory database H2. This means that upon each restart of the component, the previous data is wiped out. If you want to change this, you can configure H2 to use a backing file for persistence instead:</p>
<ol>
<li>Use the <strong class="bold">spring initializr</strong> page at <a href="https://start.spring.io">https://start.spring.io</a> to bootstrap the Java project. After configuring everything, the page should look like this:</li>
</ol>
<div><div><img alt="Figure 7.2 â€“ Bootstrapping the library project" height="763" src="img/B19199_07_02.jpg" width="1089"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 â€“ Bootstrapping the library project</p>
<p>Note how we have added the four dependencies listed on the right-hand side of the preceding figure.</p>
<ol>
<li value="2">Download <a id="_idIndexMarker604"/>the bootstrap code <a id="_idIndexMarker605"/>and unzip the file into the chapter folder, <code>.../ch07</code>. You should now have a subfolder called <code>library</code> containing the code we can use as a starting point to implement our API.</li>
<li>Open th<a id="_idTextAnchor163"/>e project in VS Code.</li>
<li>Locate the <code>Lib<a id="_idTextAnchor164"/>raryApplication.java</code> file in the <code>src/main/java/com/example/library</code> folder. Itâ€™s the typical start class containing the <code>main</code> function for a Spring Boot-based Java application.</li>
<li>Inside this folder, create three subfolders called <code>controllers</code>, <code>models</code>, and <code>repositories</code>, respectively. They will contain the logic for our library.</li>
</ol>
<div><div><img alt="Figure 7.3 â€“ Project structure of the library API" height="443" src="img/B19199_07_03.jpg" width="352"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 â€“ Project structure of the library API</p>
<ol>
<li value="6">Letâ€™s first <a id="_idIndexMarker606"/>define the <a id="_idIndexMarker607"/>models weâ€™re using in our application. To the <code>models</code> folder, add the following simple data classes:<ol><li>To a file called <code>Race.java</code>, add the following content:</li></ol></li>
</ol>
<div><div><img alt="Figure 7.4 â€“ The Race data class" height="935" src="img/B19199_07_04.jpg" width="784"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 â€“ The Race data class</p>
<ol>
<li value="2">To a <a id="_idIndexMarker608"/>file called <code>Species.java</code>, add <a id="_idIndexMarker609"/>this content:</li>
</ol>
<div><div><img alt="Figure 7.5 â€“ The Species data class" height="901" src="img/B19199_07_05.jpg" width="784"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 â€“ The Species data class</p>
<p>Note how <a id="_idIndexMarker610"/>we use the <code>@Entity</code> annotation to mark these classes as (database) entities, and we decorate <a id="_idIndexMarker611"/>their respective <code>id</code> properties with the <code>@Id</code> annotation to tell Spring Boot that this property represents the unique ID of each entity.</p>
<ol>
<li value="7">Next, we are going to implement the repositories weâ€™re going to use to persist data to and retrieve data from our database. To the <code>repositories</code> folder, add the following:<ol><li>A file called <code>RaceRepository.java</code> with this content:</li></ol></li>
</ol>
<div><div><img alt="Figure 7.6 â€“ Code for the race repository" height="567" src="img/B19199_07_06.jpg" width="1098"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 â€“ Code for the race repository</p>
<p>Note how <a id="_idIndexMarker612"/>on line 10, we add <a id="_idIndexMarker613"/>a custom <code>findBySpeciesId</code> method, which will allow us to retrieve all races assigned to a given <code>speciesId</code>.</p>
<ol>
<li value="2">A file called <code>SpeciesRepository.java</code> with the following content:</li>
</ol>
<div><div><img alt="Figure 7.7 â€“ Code for the species repository" height="481" src="img/B19199_07_07.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 â€“ Code for the species repository</p>
<ol>
<li value="8">Then, we define the two REST controllers through which we can interact with the <a id="_idIndexMarker614"/>application. To <a id="_idIndexMarker615"/>the <code>controllers</code> folder, add the following:<ol><li>A file called <code>RacesController.java</code> with this content:</li></ol></li>
</ol>
<div><div><img alt="Figure 7.8 â€“ Code for the races controller" height="1100" src="img/B19199_07_08.jpg" width="859"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 â€“ Code for the races controller</p>
<p>You can find the full code here: <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/RacesController.java">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/RacesController.java</a>.</p>
<ol>
<li value="2">A file <a id="_idIndexMarker616"/>called <code>SpeciesController.java</code> with <a id="_idIndexMarker617"/>this code:</li>
</ol>
<div><div><img alt="Figure 7.9 â€“ Code for the species controller" height="1100" src="img/B19199_07_09.jpg" width="1001"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 â€“ Code for the species controller</p>
<p>You can find the full code here: <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/SpeciesController.java">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/SpeciesController.java</a>.</p>
<ol>
<li value="9">Finally, we need to do some application configuration. We can do so in the <code>application.properties</code> file, which you can find in the <code>src/main/resources</code> folder. Add this content to it, which configures the database <a id="_idIndexMarker618"/>we are going <a id="_idIndexMarker619"/>to use for this example:</li>
</ol>
<div><div><img alt="Figure 7.10 â€“ Application configuration" height="480" src="img/B19199_07_10.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 â€“ Application configuration</p>
<p>We are using the H2 in-memory database with a username of <code>sa</code> and no password. We are also making sure to enable the H2 console in our application to have an easy way to inspect the data from our browser (line 6).</p>
<ol>
<li value="10">Now open the <code>LibraryApplication</code> class and click the <strong class="bold">Run</strong> link above the main method to start the application. Observe the output generated in the terminal:</li>
</ol>
<div><div><img alt="Figure 7.11 â€“ Logging the output of the running library application" height="268" src="img/B19199_07_11.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 â€“ Logging the output of the running library application</p>
<p>Read through the log output and try to make sense of each line. The second-to-last line of the preceding output is telling us that the application can be accessed at port <code>8080</code>, which is the default for Spring Boot applications. Also note the line where it says <code>H2 console available at â€˜/h2-consoleâ€™. Database available at â€˜jdbc:h2:mem:inventoryâ€™</code>. This indicates that we can now open a browser at <code>localhost:8080/h2-console</code> to open the H2 console and, through it, access our in-memory database.</p>
<ol>
<li value="11">Use <a id="_idIndexMarker620"/>the Thunder <a id="_idIndexMarker621"/>client in VS Code, Postman, or the <code>curl</code> command in the terminal to add a species to the database. Here we are using <code>curl</code>:<pre class="console">
$ curl -X POST -d '{"id": 1, "name": "Elephant"}' \Â Â Â Â -H 'Content-Type: application/json' \Â Â Â Â localhost:8080/species</pre></li> </ol>
<p>The response should look like this:</p>
<pre class="console">
{"id":1,"name":"Elephant","description":null}</pre> <ol>
<li value="12">Use <code>curl</code> (or any other tool) again to list the species stored in the system:<pre class="console">
$ curl localhost:8080/species</pre></li> </ol>
<p>The output should look like this:</p>
<pre class="console">
[{"id":1,"name":"Elephant","description":null}]</pre> <p>It is a JSON array with exactly one element.</p>
<ol>
<li value="13">Try all the other <code>REST</code> calls that the two controllers we implemented support, such as <code>PUT</code> to update an existing species and <code>GET</code>, <code>POST</code>, and <code>PUT</code> for the <code>/</code><code>races</code> endpoint.</li>
<li>When done, make sure to stop the application.</li>
</ol>
<p>Next, we need to package the application into a container and run it:</p>
<ol>
<li>Add a Dockerfile to the root of the library project with this content:</li>
</ol>
<div><div><img alt="Figure 7.12 â€“ Dockerfile for the library component" height="580" src="img/B19199_07_12.jpg" width="904"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 â€“ Dockerfile for the library component</p>
<ol>
<li value="2">Create <a id="_idIndexMarker622"/>a Docker image <a id="_idIndexMarker623"/>using this Dockerfile with this command executed from within the <code>ch07</code> folder:<pre class="console">
$ docker image build -t library library</pre></li> <li>Run a container with this command:<pre class="console">
$ docker container run -d --rm \Â Â Â Â -p 8080:8080 library</pre></li> <li>Test that the component now running inside a container still works as expected by using the same commands as in the previous section.</li>
<li>When done, stop the container with the library component. We suggest that you use the Docker plugin of VS Code to do so or the dashboard of Docker Desktop.</li>
</ol>
<p>Now <a id="_idIndexMarker624"/>that we have a working example <a id="_idIndexMarker625"/>application, we can continue and discuss how we can test this REST API using unit, integration, and black box tests. Letâ€™s start with the unit and/or integration tests.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Implementing and running unit and integration tests</h2>
<p>Now that <a id="_idIndexMarker626"/>we have a working component, it <a id="_idIndexMarker627"/>is time to write <a id="_idIndexMarker628"/>some tests for it. In this section, we <a id="_idIndexMarker629"/>concentrate on unit and integration <a id="_idIndexMarker630"/>tests. Spring <a id="_idIndexMarker631"/>Boot makes <a id="_idIndexMarker632"/>it really <a id="_idIndexMarker633"/>simple to get started:</p>
<ol>
<li>To the <code>src/test/java/com/example/library</code> folder, add a <code>LibraryUnitTests.java</code> file with the following content:</li>
</ol>
<div><div><img alt="Figure 7.13 â€“ Sample unit test written for the library project" height="1100" src="img/B19199_07_13.jpg" width="998"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 â€“ Sample unit test written for the library project</p>
<p>Note <a id="_idIndexMarker634"/>how we have added <a id="_idIndexMarker635"/>a private <code>Calculator</code> class <a id="_idIndexMarker636"/>to our <code>Test</code> class. This <a id="_idIndexMarker637"/>is for demonstration purposes only and makes it easier to show how to write a unit test. Normally, one would test classes and their methods that are part of the code base.</p>
<p class="callout-heading">Tip</p>
<p class="callout">It is a good idea to always structure your tests in a similar way and make it easier for others (and yourself) to read and comprehend those tests. In this case, we have chosen the triple-A (AAA) syntax consisting of Arrange, Act, and Assert. Alternatively, you could use the Given-When-Then syntax.</p>
<ol>
<li value="2">If you <a id="_idIndexMarker638"/>have the <strong class="bold">Test Runner for Java</strong> extension installed on your VS Code editor, you should now see a <a id="_idIndexMarker639"/>green triangle <a id="_idIndexMarker640"/>next to the test method (line 19 in the preceding figure). Click it to run the test. As a result, you should <a id="_idIndexMarker641"/>see something like this:</li>
</ol>
<div><div><img alt="Figure 7.14 â€“ Results of a first test run" height="485" src="img/B19199_07_14.jpg" width="1029"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 â€“ Results of a first test run</p>
<p class="callout-heading">Note</p>
<p class="callout">Alternatively, you can run the tests from the command line with this command:</p>
<p class="callout"><code>$ ./</code><code>mvnw test</code></p>
<ol>
<li value="3">Now letâ€™s add a sample integration test. For this, add a file called <code>LibraryIntegrationTests.java</code> in the same folder as where you have put the unit tests. We will implement a test using the <code>MockMvc</code> helper class provided <a id="_idIndexMarker642"/>by Spring Boot to simulate <a id="_idIndexMarker643"/>that our application <a id="_idIndexMarker644"/>runs on a web <a id="_idIndexMarker645"/>server and weâ€™re accessing it through its REST endpoints. Add the following content to the test class:</li>
</ol>
<div><div><img alt="Figure 7.15 â€“ Sample Integration Test written for the library project" height="996" src="img/B19199_07_15.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 â€“ Sample Integration Test written for the library project</p>
<ol>
<li value="4">Run the preceding test the same way as you did with the unit test. Make sure the test passes.</li>
</ol>
<p>We have <a id="_idIndexMarker646"/>finished our preparation <a id="_idIndexMarker647"/>and are now ready <a id="_idIndexMarker648"/>to package the component into a <a id="_idIndexMarker649"/>container and run the unit and integration tests inside the same container. To do this, follow these steps:</p>
<ol>
<li>Letâ€™s add a Dockerfile with the following content to the root of our library project. The content is the same that we already used in the previous Java example:</li>
</ol>
<div><div><img alt="Figure 7.16 â€“ Dockerfile for the library project" height="580" src="img/B19199_07_16.jpg" width="904"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 â€“ Dockerfile for the library project</p>
<ol>
<li value="2">Then, letâ€™s build an image using this Dockerfile:<pre class="console">
$ docker image build -t library .</pre></li> <li>Run the tests in the container with the following command:<pre class="console">
$ docker container run --rm \Â Â Â Â -v $HOME/.m2:/root/.m2Â Â Â Â library ./mvnw test</pre></li> </ol>
<p>Note the volume mapping we are using. We are sharing our local Maven repository at <code>$HOME/.m2</code> with the container, so when building the application, Maven does not have to download all dependencies first as they are already in our local cache. This improves the overall experience massively.</p>
<p>Also <a id="_idIndexMarker650"/>note how we override the <code>CMD</code> command <a id="_idIndexMarker651"/>in our Dockerfile (line 8 in the preceding figure) with <code>./mvnw test</code> to run the tests instead <a id="_idIndexMarker652"/>of running <a id="_idIndexMarker653"/>the application.</p>
<ol>
<li value="4">Observe the output generated. The last few lines of the output should look like this, indicating that tests were run:</li>
</ol>
<div><div><img alt="Figure 7.17 â€“ Output of a test run inside the container" height="520" src="img/B19199_07_17.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 â€“ Output of a test run inside the container</p>
<p>In the same way that you have now run the unit and integration tests inside a container locally on your laptop, you can also run it during the CI phase of your CI/CD pipeline. A simple shell script is enough to automate what you just did manually.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Implementing and running black box tests</h2>
<p>Since black box tests have to deal with the SUT as a closed system, the tests should not run inside the <a id="_idIndexMarker654"/>same container as the component <a id="_idIndexMarker655"/>itself. It is instead recommended to run the test code in its own dedicated test container.</p>
<p>It is also <a id="_idIndexMarker656"/>recommended to not intermingle the code of black box <a id="_idIndexMarker657"/>tests and the component but to keep them strictly separate. We will demonstrate this by writing the tests in a different language than the component. This time, we will use C#. Any language will do such as Kotlin, Node.js, or Python.</p>
<p>In this example, we will use .NET and C# to implement the component tests:</p>
<ol>
<li>From within the <code>ch07</code> folder, execute the following command to create a test project:<pre class="console">
$ dotnet new xunit -o library-component-tests</pre></li> </ol>
<p>This will create a test project in the <code>library-component-tests</code> subfolder using the popular <code>xunit</code> test library.</p>
<ol>
<li value="2">Try to run the tests with the following command:<pre class="console">
$ dotnet test library-component-tests</pre></li> </ol>
<p>The (shortened) output should look like this:</p>
<pre class="console">
Passed!Â Â - Failed:Â Â 0, Passed:Â Â 1, Skipped:Â Â 0, Total:Â Â 1, â€¦</pre> <p>This indicates that all tests passed. Of course, by default, there exists only an empty sample test in the project at this time.</p>
<ol>
<li value="3">Open this project in VS Code with the following:<pre class="console">
$ code library-component-tests</pre></li> <li>Locate the <code>UnitTest1.cs</code> file and open it. At the top of the file, add this statement:<pre class="console">
using System.Text.Json;</pre></li> <li>Right after the <code>namespace</code> declaration, add this record definition:<pre class="console">
public record Species(int id, string name, string description);</pre></li> <li>Now <a id="_idIndexMarker658"/>add a new method called <code>can_add_species</code>, looking <a id="_idIndexMarker659"/>like this:</li>
</ol>
<div><div><img alt="Figure 7.18 â€“ Component test to add a species" height="591" src="img/B19199_07_18.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 â€“ Component test to add a species</p>
<p>Here we <a id="_idIndexMarker660"/>are using the <code>HttpClient</code> class to post a <a id="_idIndexMarker661"/>data object of type <code>Species</code> to the <code>/species</code> endpoint. We are then asserting that the HTTP response code for the operation is <code>OK (200)</code>. Note how we are using the AAA convention to structure our test.</p>
<ol>
<li value="7">Add another method called <code>can_get_a_species_by_id</code> with the following content:</li>
</ol>
<div><div><img alt="Figure 7.19 â€“ Component test to read a species by ID" height="716" src="img/B19199_07_19.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 â€“ Component test to read a species by ID</p>
<ol>
<li value="8">Before you <a id="_idIndexMarker662"/>proceed and run the tests, make sure the <code>library</code> component <a id="_idIndexMarker663"/>is running <a id="_idIndexMarker664"/>and listening at port <code>8080</code>. Otherwise, the tests will fail, since <a id="_idIndexMarker665"/>nobody is listening at the expected endpoints. Use this command:<pre class="console">
$ docker container run --rm \Â Â Â Â -v $HOME/.m2:/root/.m2Â Â Â Â library</pre></li> <li>Run the tests with this command:<pre class="console">
$ dotnet test</pre></li> </ol>
<p>Make sure the two tests pass.</p>
<ol>
<li value="10"><code>library</code> component.</li>
<li>When done, stop the <code>library</code> component.</li>
</ol>
<p>Next, we <a id="_idIndexMarker666"/>are going to show how we <a id="_idIndexMarker667"/>can run the tests in a container:</p>
<ol>
<li>Add a Dockerfile with the following content to the root of the .NET test project:</li>
</ol>
<div><div><img alt="Figure 7.20 â€“ Dockerfile for the component tests" height="580" src="img/B19199_07_20.jpg" width="832"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 â€“ Dockerfile for the component tests</p>
<ol>
<li value="2">Create an <a id="_idIndexMarker668"/>image <a id="_idIndexMarker669"/>with this Dockerfile. From within the <code>ch07</code> folder, use this command:<pre class="console">
$ docker image build -t library-component-tests \Â Â Â Â library-component-tests</pre></li> <li>Double-check that we already have a Docker image created for the library component. If not, use this command to do so from within the <code>ch07</code> folder:<pre class="console">
$ docker image build -t library library</pre></li> <li>Now that we have a Docker image for the library component and one for the component tests, we need to run a container of each:<ol><li>To run the library component, use this:</li></ol><pre class="console">
$ docker container run -d --rm \Â Â Â Â -p 8080:8080 library</pre><ol><li value="2">To run the component tests, use this command:</li></ol><pre class="console">$ docker container run library-component-tests</pre></li> </ol>
<p>Observe that the tests are executed and are all passing.</p>
<ol>
<li value="5">When done, remove the two containers. Use your Docker plugin in VS Code or the dashboard of Docker Desktop to do so.</li>
</ol>
<p>Well, that was <a id="_idIndexMarker670"/>quite a run. We have <a id="_idIndexMarker671"/>shown how to write unit and integration tests for a component written in Java and using Spring Boot 3. We ran the tests natively on our laptop and also inside a container. Then <a id="_idIndexMarker672"/>we showed how to create some black box tests <a id="_idIndexMarker673"/>in .NET 7, C# and ran them against our library component. We did this again natively on our laptop and then ran the component and the black box tests each in their own container.</p>
<p>Next, we are going to discuss how to best set up a testing environment.</p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/>Best practices for setting up a testing environment</h1>
<p>In this section, we want <a id="_idIndexMarker674"/>to list a few best practices for setting up a testing environment for applications running in containers, including considerations for network isolation, data management, and resource constraints:</p>
<ul>
<li><strong class="bold">Use a separate testing environment</strong>: It is generally a good idea to use a separate testing environment for running tests in containers rather than running tests on the same host as your production environment. This can help to prevent any potential issues or disruptions from affecting your production environment.</li>
<li><strong class="bold">Isolate the testing network</strong>: To ensure that your testing environment is isolated from your production environment, it is a good idea to use a separate network for testing. This can be achieved by using a separate virtual network or by using network namespaces or overlays in your container runtime.</li>
<li><strong class="bold">Manage test data carefully</strong>: When testing applications in containers, it is important to <a id="_idIndexMarker675"/>manage test data carefully to ensure that your tests are reliable and repeatable. This can involve using test data generation tools, snapshotting the test data, or using a separate test database.</li>
<li><strong class="bold">Use resource constraints</strong>: To ensure that your tests are reliable and consistent, it is a good idea to use resource constraints (e.g., CPU, memory) to limit the resources available to your containers. This can help to prevent resource contention and ensure that your tests are not impacted by external factors such as the load on the host system.</li>
<li><strong class="bold">Use a container orchestration tool</strong>: To manage a large number of containers and ensure that they are deployed and scaled consistently, it is a good idea to use a container orchestration tool such as Kubernetes or Docker Swarm. These tools can help to automate the process of deploying and scaling containers and can provide features such as automatic rollbacks and self-healing.</li>
<li><strong class="bold">Monitor the testing environment</strong>: To ensure that your testing environment is running smoothly and to identify any issues that may arise, it is a good idea to use monitoring tools to track the performance and resource usage of your containers. This can help you to identify and fix any issues that may affect the reliability of your tests.</li>
</ul>
<p>Now when testing, you may face some troubles and hard-to-explain test failures. In the next section, weâ€™re going to provide a few tips about what you can do in such a situation.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/>Tips for debugging and troubleshooting issues</h1>
<p>As we are running automated tests in our containerized environments, we may from time to time <a id="_idIndexMarker676"/>face seemingly weird behaviors and mysteriously failing tests. Here are some tips for debugging and troubleshooting issues that may arise when testing applications in containers:</p>
<ul>
<li><code>docker container logs</code> to view the logs for a specific container.</li>
<li><strong class="bold">Use a debugger</strong>: If the error message or log output is not sufficient to diagnose the problem, you can use a debugger to inspect the state of the application at runtime. Many IDEs, such as VS Code, which we use all the time, Visual Studio, and IntelliJ, have built-in support for debugging applications running in containers.</li>
<li><code>docker container exec</code> to run commands inside the container and inspect its environment.</li>
<li><strong class="bold">Use a container runtime debugger</strong>: Some container runtimes, such as Docker, provide tools for debugging issues with the container itself (e.g., resource usage and networking issues). These tools can be helpful for diagnosing issues that are specific to the container runtime.</li>
<li><strong class="bold">Use a containerized debugging environment</strong>: If you are having difficulty reproducing the issue in a local development environment, you can use a containerized debugging environment (e.g., a debugger container) to replicate the production environment more closely.</li>
<li><strong class="bold">Check for known issues</strong>: If you are using third-party libraries or dependencies in your application, it is worth checking whether there are any known issues <a id="_idIndexMarker677"/>or bugs that could be causing the problem. Many libraries and dependencies maintain lists of known issues and workarounds on their website or in their documentation.</li>
<li><strong class="bold">Get help</strong>: If you are unable to diagnose the issue on your own, donâ€™t hesitate to seek help from the community, for example, from Stack Overflow or the maintainers of the libraries and tools you are using. There are many resources available online.</li>
</ul>
<p>Now letâ€™s discuss a few challenges that may occur during testing and what we should consider when testing.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Challenges and considerations when testing applications running in containers</h1>
<p>Next to all <a id="_idIndexMarker678"/>the many advantages that testing <a id="_idIndexMarker679"/>applications running in containers brings to the table, we need to also have a brief discussion of the challenges and considerations involved in this type of testing, such as dealing with dependencies and managing test data:</p>
<ul>
<li><strong class="bold">Isolation</strong>: Testing applications in containers can provide a level of isolation between the test environment and the host system, which can be useful for ensuring that the test results are consistent and repeatable. However, this isolation can also make it more difficult to debug issues and identify the root cause of problems, as you may not have access to the host system and its resources.</li>
<li><strong class="bold">Environment consistency</strong>: Ensuring that the test environment is consistent across different development environments can be a challenge when using containers. Differences in the host system, container runtime, and network configuration can all impact the behavior of the application and the test results.</li>
<li><strong class="bold">Data management</strong>: Managing test data in a containerized environment can be challenging, as you may need to ensure that the test data is consistent and available to all containers, or that it is properly isolated and not shared between tests.</li>
<li><strong class="bold">Resource constraints</strong>: Testing applications in containers can be resource-intensive, as you may need to run multiple containers in parallel to test different scenarios. This can <a id="_idIndexMarker680"/>lead to resource <a id="_idIndexMarker681"/>contention and may require careful resource management to ensure that your tests are reliable and consistent.</li>
<li><strong class="bold">Integration testing</strong>: Testing the integration between multiple containers can be challenging, as you may need to coordinate the startup and shutdown of multiple containers and ensure that they can communicate with each other.</li>
<li><strong class="bold">Performance testing</strong>: Testing the performance of applications running in containers can be difficult, as the performance may be impacted by the host system, the container runtime, and the network configuration.</li>
</ul>
<p>Overall, testing applications running in containers requires careful planning and consideration to ensure that the test environment is consistent and reliable, and to ensure that the test results are meaningful and actionable.</p>
<p>Before we end this chapter, letâ€™s look at a few case studies where companies are using containerized tests.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Case studies</h1>
<p>In this last section of the chapter, we present a few case studies and examples of organizations <a id="_idIndexMarker682"/>that have successfully implemented testing strategies for applications running in containers:</p>
<ol>
<li>An automated testing technique was introduced by a well-known online shop to boost the effectiveness and efficiency of its software development process. The company was able to considerably reduce the time and effort needed to test its applications by automating the execution of functional, integration, and acceptance tests. As a result, it was able to provide customers with new features and upgrades more rapidly and reliably.</li>
<li>Automated testing was used by a financial services company to enhance the dependability and stability of their trading platform. The business was able to find and fix <a id="_idIndexMarker683"/>problems early in the development process by automating the execution of unit, integration, and acceptance tests, minimizing the risk of downtime and enhancing customer satisfaction.</li>
<li>Automated testing was used by a healthcare organization to guarantee the precision and <a id="_idIndexMarker684"/>dependability of its <strong class="bold">electronic medical record</strong> (<strong class="bold">EMR</strong>) system. The business was able to swiftly identify and address problems by automating the execution of functional and acceptability tests, increasing the EMR systemâ€™s dependability and trustworthiness, and lowering the risk of mistakes and patient harm.</li>
</ol>
<p>The advantages of automated testing, such as better quality, quicker development and deployment cycles, increased reliability, and higher customer happiness, are illustrated by these case studies.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Summary</h1>
<p>In this chapter, we learned about the benefits of testing applications running in containers, discussed the different types of testing, presented some of the tools and technologies commonly used for testing, as well as best practices for setting up a testing environment. We also presented a list of tips for debugging and troubleshooting issues, talked about challenges and considerations when testing applications running in containers, and concluded the chapter with a list of case studies.</p>
<p>In the next chapter, we will introduce miscellaneous tips, tricks, and concepts useful when containerizing complex distributed applications or when using Docker to automate sophisticated tasks.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Questions</h1>
<p>To assess your learning, please try to answer the following questions before you proceed to the next chapter:</p>
<ol>
<li>How do we run unit tests for an application inside a container?</li>
<li>Should the Docker images that we use in production contain test code? Justify your answer.</li>
<li>Where do we typically run unit and integration tests that run inside a container?</li>
<li>List a few advantages of running unit and integration tests in containers.</li>
<li>What are a few challenges you may face if running tests in containers?</li>
</ol>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Answers</h1>
<p>Here are sample answers to the questions of this chapter:</p>
<ol>
<li>We have learned how to run an application in a container. We have seen examples written in Node.js, Python, Java, and .NET C#. We have learned how the Dockerfile must look to create an image. Specifically, we have learned how to define the startup command to execute when a container is created from such an image. In the case of a Java application, this could be as follows:<pre class="console">
<code>CMD java -jar /app/my-app.jar</code></pre></li> </ol>
<p>For a Node.js application, it could be as follows:</p>
<pre class="console">
<code>CMD node index.js</code></pre> <p>To run the unit tests for the application, we just have to use a different startup command.</p>
<ol>
<li value="2">We strongly advise against shipping test code to a production environment. Tests bloat the Docker image, which has several negative side effects, such as the following:<ul><li>Providing a bigger surface for hacker attacks</li><li>Longer startup times for the container since it takes longer to load an image from storage into the memory of the container host</li><li>Longer download times and higher network usage due to the increased size of the image</li></ul></li>
<li>Unit and integration tests are typically run on the developerâ€™s local machine before they push code to a code repository such as GitHub. Once the code is pushed to GitHub or any other remote code repository, usually the CI/CD pipeline kicks in and the CI stage is executed. Part of this stage is the execution of all unit and integration tests against the application. Usually, this is performed on a so-called build agent. In many cases, this is a sandbox environment where Docker containers can be run. Thus, the CI stage uses the same technique to run the tests in the build agent as a developer would do locally. It is important to note that tests other than some special smoke tests are never run in a production environment, since this could have undesired side effects.</li>
<li>One of the most important advantages of running tests in containers is the isolation aspect. We can run the tests on any environment able to run containers and do not have to worry about installing frameworks or libraries on the hosting machine first.</li>
</ol>
<p>Another important advantage is that running tests in containers makes them repeatable out of the box. Each time a container containing the application code and the tests are started, the boundary conditions are the same. With this, we guarantee consistency in the test execution. Were we to run the tests natively on the host, we would have a harder time guaranteeing this consistency.</p>
<ol>
<li value="5">Some challenges we may face when running our tests inside containers are as follows:<ul><li>It may be harder to troubleshoot and debug failing tests</li><li>Integration testing can be more challenging when several containers are involved in the necessary setup</li><li>Resources such as CPU, RAM, and network bandwidth can be limited in a containerized environment (via cgroup settings) and thus negatively impact your test runs</li></ul></li>
</ol>
</div>
</div></body></html>