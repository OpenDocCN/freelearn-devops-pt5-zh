- en: Chapter 3. Working with Custom Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple custom field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom field searchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with custom fields on an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming custom field options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding validation of custom fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing change log value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating from one custom field type to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making custom fields sortable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying custom fields on subtask columns on parent issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User and date fields from 4.1.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom fields to notification mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding help text for a custom field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the 'none' option from a select field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the custom field project importable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the size of a text area custom field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an issue tracking application, the more details you can provide about an
    issue, the better. JIRA helps by giving us some standard issue fields that are
    most likely to be used while creating an issue. But what if we need to capture
    additional information such as the name of the reporter's dad or something else
    that is worth capturing, perhaps the SLA or the estimated costs? For this, we
    can make use of custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: With JIRA comes a group of pre-defined custom field types. It includes types
    like Number Field, User Picker, and so on, which are most likely to be used by
    JIRA users. But as you become a power user of JIRA, you might come across the
    need for a customized field type. That is where people start writing custom field
    plugins to create new field types or custom searchers.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this chapter to learn more about custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple custom field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to write a new custom field type. Once created,
    we can create a number of custom fields of this type on our JIRA instance that
    can then be used to capture information on the issues.
  prefs: []
  type: TYPE_NORMAL
- en: New Custom field types are created with the help of the `customfield-type` module.
    The following are the key attributes and elements supported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | This should be unique within the plugin. |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Must implement the `com.atlassian.jira.issue.customfields.CustomFieldType`
    interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `i18n-name-key` | The localization key for the human-readable name of the
    plugin module. |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | Human-readable name of the web resource. |'
  prefs: []
  type: TYPE_TB
- en: '**Elements:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Description` | Description of the custom field type. |'
  prefs: []
  type: TYPE_TB
- en: '| `resource type="velocity"` | Velocity templates for the custom field views.
    |'
  prefs: []
  type: TYPE_TB
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, create a skeleton plugin. Next, create an eclipse project using
    the skeleton plugin, and we are good to go!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, let us look at an example custom field type to ease understanding.
    Let us consider the creation of a `Read Only` custom field that stores the name
    of the user who edited the issue the last time. It is simple in functionality
    and enough to explain the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the major steps to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `atlassian-plugin.xml` file to include the `customfield-type` module.
    Make sure the appropriate class name and views are added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our example, the modified `atlassian-plugin.xml` will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the key is unique inside the plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the class. As mentioned in the introduction, the class must implement
    the `com.atlassian.jira.issue.customfields.CustomFieldType` interface. Now if
    you do this, make sure you implement all the methods in the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: An easier way is to override some of the existing custom field implementations,
    if there are any similar to the type you are developing. In such cases, you will
    need to only override certain methods or maybe just modify the velocity templates!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The details on existing implementations can be found at the Javadocs for the
    `CustomFieldType` interface. `NumberCFType`, `DateCFType`, `UserCFType`, and so
    on, are some useful examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, the class is `com.jtricks.ReadOnlyUserCF`. Now, our field type
    is nothing but a text field in essence and so it makes sense to override the already
    existing `TextCFType`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Following is how the class will look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the class extends the `TextCFType` class. We perform a 'constructor
    injection' to call the super class constructor. All you need to do is add the
    required component as an argument in the public constructor of the class and Spring
    will inject an instance of that component at runtime. Here, `JiraAuthenticationContext`
    is injected as we use it in our class. As you can see, `authContext` is an argument
    that is injected and is assigned to a class variable with the same name for using
    it later in the various methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement/Override the methods of interest. As mentioned earlier, implement
    all the required methods, if you are implementing the interface directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case, we extend the `TextCFType`, and so we need to only override the
    selected methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The only method that we override here is the `getVelocityParameters` method
    where we populate the velocity params with additional values. In this case, we
    add the current user''s name. We will later use this params in the velocity context
    to generate the views. The same method is used in creating the different views
    in different scenarios, that is, create, edit, and so on. The following is the
    codeippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note: Use the `authContext.getLoggedInUser` method if using JIRA 4.3+.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the templates defined in the `atlassian-plugin.xml` file. The templates
    could be written in a way you want the fields to appear in different scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you take a closer look, we have defined four velocity resources but using
    only two velocity template files, as the `view-readonly-user.vm` is shared across
    ''view'', ''column-view'', and ''xml'' resources. In this example, we only need
    to show the `readonly` field in all the three mentioned cases, and so the template
    will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code uses velocity syntax, the details of which can be found at [http://velocity.apache.org/engine/devel/developer-guide.html](http://velocity.apache.org/engine/devel/developer-guide.html).
    Here we display the existing custom field value of the issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The edit template should be a `readonly` `textfield` with `id` as the custom
    field''s ID, as JIRA uses this to store values back into the database when the
    issue is edited. The template looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we use the field `currentUser`, as we added into the velocity context in
    step 4\. The value of the text field is `$currentUser`. Also note that the ID
    is `$customfield.id` and the `readonly` attribute is present to make it read only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, more complex logic and beautifications can go into the class and velocity
    templates. As they say, the sky is the limit!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the plugin is installed, it is available under **Administration** | **Issue
    Fields** | **Custom Fields**.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new custom field of the type we just created and map it into the appropriate
    issue types and projects. Also add the fields to the appropriate screens. Once
    done, the field will be available on the issue at the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: More details on adding a custom field can be found at [http://confluence.atlassian.com/display/JIRA/Adding+a+Custom+Field](http://confluence.atlassian.com/display/JIRA/Adding+a+Custom+Field).
  prefs: []
  type: TYPE_NORMAL
- en: In our example, whenever an issue is edited, the name of the user who edited
    it is stored in the custom field.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that we added only one parameter in the velocity context,
    that is, `currentUser`, but we have used `$value` in the view template. Where
    does this variable `value` come from?
  prefs: []
  type: TYPE_NORMAL
- en: JIRA already populates the custom field velocity contexts with some existing
    variables in addition to the new ones we add. `value` is just one among them and
    the full list can be found at [http://confluence.atlassian.com/display/JIRADEV/Custom+field+Velocity+context+unwrapped](http://confluence.atlassian.com/display/JIRADEV/Custom+field+Velocity+context+unwrapped).
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that `authContext` is already available in the velocity context
    and so we could have implemented this example by getting the current user in the
    velocity template itself instead of injecting the `JiraAuthenticationContext`
    in the constructor of the class and getting the `currentUser` variable from it
    in the class. But we have done that just for the purpose of explaining the example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a skeleton plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process"), *Plugin Development Process*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying your plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom field searchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing the custom field type is one thing, but making it available to one of
    JIRA's most powerful functionalities, that is, Search, is another! When you create
    the custom field, you can associate the searcher to be used along with it.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you wouldn't need a custom searcher. Instead, you can use the
    built-in custom field searchers in JIRA itself. The list includes, but is not
    restricted to, Text Field Searcher, Date Searcher, Number Searcher, User Searcher,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The first step, of course, is to determine what the kind of Searcher your new
    field needs. For example, a Select field can easily be searched with Text Searcher
    or an Exact Text Searcher! A User Picker field can be searched with a User Searcher
    or a Text Searcher. You might even want to extend one of these Searchers to add
    some extra functionality, like some special conditions or hacks you want to introduce!
    Yeah, you know what I mean!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how JIRA has defined the Text Searcher for its system custom fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it makes use of the `customfield-searcher` module. The custom
    fields that should be searchable using this **Free Text Searcher** should be added
    under the `valid-customfield-type` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the key attributes and elements supported by the `customfield-searcher`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | This should be unique within the plugin |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Must implement the `com.atlassian.jira.issue.customfields.CustomFieldSearcher`
    interface |'
  prefs: []
  type: TYPE_TB
- en: '| `i18n-name-key` | The localization key for the human-readable name of the
    plugin module |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Human-readable name of the web resource |'
  prefs: []
  type: TYPE_TB
- en: '**Elements**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | Description of the custom field searcher module |'
  prefs: []
  type: TYPE_TB
- en: '| `resource type="velocity"` | Velocity templates for the custom field searcher
    views |'
  prefs: []
  type: TYPE_TB
- en: '| `valid-customfield-type` | Defines the custom field types this searcher can
    apply to. It has two attributes: `package` – the key of the atlassian plugin where
    the custom field resides and `key` – the module key for the custom field type.
    |'
  prefs: []
  type: TYPE_TB
- en: Let us see in detail how to define a searcher for the custom field we wrote
    in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have created the `Read Only User` custom field (`com.jtricks.ReadOnlyUserCF`
    ) using the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, we will do it as a step-by-step procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `customfield-searcher` module into the `atlassian-plugin.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, the field is a read-only text field that holds the username,
    and so it makes sense to use the existing `TextSearcher` instead of writing a
    new Searcher class. The module will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we use `com.atlassian.jira.issue.customfields.searchers.TextSearcher` that
    implements the `com.atlassian.jira.issue.customfields.CustomFieldSearcher` interface.
    If we need to write custom searchers, the appropriate class should appear here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also need to define the velocity templates for `edit` and `view` scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the custom field searcher class. In this case, we can skip this step,
    as we are going with the already implemented class `TextSearcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if we are implementing a custom searcher, it might be wise to extend an
    already existing searcher class and override only the methods of interest to avoid
    implementing everything from scratch. Having said that, it is entirely up to the
    developer to give a brand new implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The only mandatory thing to note is that the searcher class must implement the
    `com.atlassian.jira.issue.customfields.CustomFieldSearcher` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the velocity templates. For a custom field searcher, there are two views.
    `Edit` and `view`, both of which will appear on the issue navigator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `edit` template is used when the filters are created / edited. The `view`
    template is used when the filter is viewed or the search results are viewed by
    clicking on **View and Hide** ('Search' from JIRA 4.3) on the issue navigator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, we have used the in-built JIRA templates, but it is perfectly
    fine to give a custom implementation of these templates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure the `valid-customfield-type` tags are correctly entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is a basic, but very common, error you might make here. The `package`
    attribute here refers to the atlassian-plugin key where the custom field resides
    and not the Java package where the Searcher class resides! Just to make it clear,
    the atlassian plugin key is the key in the first line of your `atlassian-plugin.xml`,
    which is `com.jtricks` in our case:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This package (plugin key) along with the custom field key (`readonly-user` in
    this case) will point to the right custom field. This would also mean that you
    can have the same `readonly-user` in another plugin with a different plugin key!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the custom field type is associated with a searcher using the `customfield-searcher`
    module, you will see it appear in the searcher drop-down when a custom field of
    that type is created.
  prefs: []
  type: TYPE_NORMAL
- en: For any existing custom fields, the searcher can be defined or modified using
    the edit operation. Once the searcher is changed, a re-indexing must be done for
    the changes to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: We can define more than one custom field using the `valid-customfield-type`
    element for a single searcher.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the same custom field type can be defined under more than one searcher.
    This will be useful when two different custom fields of the same type can potentially
    use two different searchers. For example, text fields can use `TextSearcher` or
    `ExactTextSearcher`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the searcher is defined against the custom field, you can see it appearing
    in the issue navigator **when the correct context is selected**. The last part
    is extremely important because the field will be available to search only when
    the context chosen is correct. For example, if field X is available only on bugs,
    it won't appear on the issue navigator when the issue types selected has both
    bugs and new features. Refresh the search menu after the correct context is selected
    to see your field. This is applicable only for **simple** searching.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the introduction of v2 plugins, courtesy of OSGI bundles, referring to
    the built-in JIRA searcher classes directly in the `atlassian-plugin.xml` file
    will fail sometimes because it can't resolve all the dependencies (the notorious
    **Unsatisfied dependency** errors!). This is because some of the classes are not
    available for dependency injection in the version 2 plugins, as they were in version
    1 plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is an easy hack to do it. Just create a dummy custom Searcher class
    with the constructor that does the dependency injection for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If that doesn't work, add the field to the `system-customfield-types.xml` file
    under `WEB-INF/classes` along with the JIRA system custom fields, that is, one
    more `valid-customfield-type` entry into the relevant `customfield-searcher` element.
    If you do this, remember to apply this workaround when JIRA is upgraded!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with custom fields on an issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to work with custom fields on an issue. It covers
    reading a custom field value from an issue and then updating the custom field
    value on the issue, with and without notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identify the places where the custom fields needs to be manipulated, be it on
    a listener, workflow element, or somewhere else in our plugins.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see how to access the value of a custom field and modify the value as
    we go along.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the steps to read the custom field value from an `Issue` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of the `CustomFieldManager` class. This is the manager class
    that does most of the operations on custom fields. There are two ways to retrieve
    a manager class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the manager class in the constructor of your plugin class implementation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retrieve the `CustomFieldManager` directly from the `ComponentManager` class.
    It can be done as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the `customField` object using the `customfield` name or the ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OR
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the custom field object is available, its value for an issue can be retrieved
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OR
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The latter works fine in all scenarios, whereas the former seems to fail in
    cases like workflow validators and post functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cast the value object to the appropriate class. For example, String for a text
    field, `List<String>` for a multi select field, `Double` for a number field, and
    so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to update the custom field values back on to the issue, continue
    with the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a modified value object with the old value and the new value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Obtain the `FieldLayoutItem` associated with the custom field for this issue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the custom field value for the issue using the `fieldLayoutItem`, `modfiedValue`
    and a default change holder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The advantage of doing this, or the disadvantage depending on your perception,
    is that the custom field value change will not trigger a notification. If you
    want to trigger notifications, please follows these steps to update the issue
    instead of previous steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the custom field value for the issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the action parameters Map using `issueObject`, `remoteUser` details,
    and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `ISSUE_UPDATE` operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will throw an issue update event and all the handlers will be able to pick
    it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternate, and probably simpler, way to update the custom fields is to use
    the type of the field, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are the things taking place at the backend when the custom field
    value is changed using one of the aforementioned methods.
  prefs: []
  type: TYPE_NORMAL
- en: The Value is updated in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change record is created and change history is updated with the latest changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes are updated to hold the new values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *Issue Updated* event is fired if `ActionDispatcher` is used to update the
    field, which in turn fires notifications and listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with custom fields and SOAP* in [Chapter 9](ch09.html "Chapter 9. Remote
    Access to JIRA"), *Remote Access to JIRA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming custom field options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to create a custom field type, search for it, and read/update
    its value from/on an issue. But one important aspect of multi-valued custom fields
    and one that we haven't seen yet is custom field options.
  prefs: []
  type: TYPE_NORMAL
- en: On a multi-valued custom field, the administrator can configure the allowed
    set of values, also called `options`. Once the options are configured, users can
    only select values within that set of options and there is a validation done to
    ensure that this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we programmatically read those options or add a new option to the
    custom field so that it can be later set on an issue? Let us have a look at that
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a multi-valued custom field, say X, in your JIRA instance. Add a few
    options onto the field X.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deal with custom field options, Atlassian has written a manager class named
    `OptionsManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to get the options configured for a custom field:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an instance of the `OptionsManager` class. Similar to any other manager
    class, this can be done in two ways.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the manager class in the constructor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directly get an instance from the `ComponentManager` class as shown:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Retrieve the field configuration schemes for the custom field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There could be more than one field configuration scheme for a custom field,
    each with its own set of projects, issue types, and so on, defined in different
    contexts. We need to identify the field configuration scheme of interest to us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the field configuration from the scheme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the field configuration is available, we can use it to retrieve the options
    on the custom field for that field configuration. The options could be different
    for different contexts and that is the reason why we retrieve the `config` first
    and use it to get the options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`option.getValue()` will give the name of the option while iterating on the
    preceding list.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`option.getChildOptions()` will retrieve the child options in the case of a
    cascading select or any other multilevel select'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you need to add new options to the list, it is again `OptionsManager` who
    comes to the rescue. We do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first parameter is `fieldConfig` that we saw earlier. The second parameter
    is the `parent option ID`, used in case of a multi-level custom field like cascading
    select. It will be `null` for single-level custom fields. The third parameter
    is `sequence`, which determines the order in which the options will appear. The
    fourth parameter is the actual `value` to be added as an option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the new `option` to the list of options and update!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deleting and updating options are also possible like this, but we shouldn't
    forget to handle existing issues with those option values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OptionsManager` exposes a lot of other useful methods to handle custom field
    options, which can be found in the Javadocs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a simple custom field*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding validation of custom fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to write a custom field and set its options programmatically.
    We also discussed how the value set on a multi-valued custom field is validated
    against its set of pre-configured options. If the value doesn't belong to it,
    the validation fails and the issue can't be created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we have a scenario where we need to suppress this validation? What
    if we need to add values to an issue which doesn't come from its pre-configured
    options? Normally, you would add this to the options programmatically, as we've
    seen before but what if we don't want to do this due to some reason? This is when
    you can suppress the validation in your custom field.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create your custom field, as we have seen in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All you need to do here is to suppress the validation happening in the original
    parent custom field if you are extending an existing custom field type like `MultiSelectCFType`.
    The following is the method you should override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can add any additional validation in this method as well!
  prefs: []
  type: TYPE_NORMAL
- en: If you are writing a custom field type from scratch, you will be implementing
    the `CustomFieldType` interface. You will then need to implement the above method
    and can do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: And if you are interested and have access to the JIRA source code, go and have
    a look at how the validation is done in some existing custom field types!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a simple custom field*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the change log value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One scenario we might come across when writing certain custom field types is
    to manipulate the way we display the change log. For a normal Version Picker custom
    field, the change log is displayed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the change log value](img/1803-03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here **Test Version** is the field name. The first value you see, `Test2 [10010]`,
    is the old value and the second value, `Test1 [10000]`, is the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write your custom field type, as described in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have seen in the preceding screen, the change log value for both old
    value and new value are displayed in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Both the string value and ID value are stored in the `ChangeItem` table. But
    before storing the value in the database, this value is generated from the individual
    custom fields. That is where we need to intercept to manipulate the way change
    log is written.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods, one for `change log string` and another for `change
    log id`, which need to be modified. Following are the method definitions in the
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All you need to do is implement these methods or override them if you are extending
    an existing custom field type to put your custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want the string to appear in the change history, just return `null`
    in the `getChangelogString` method. Note that if `null` is returned in the `getChangelogValue`
    method, the change log isn't created!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider a simple example where the change history string is truncated
    when the length of a string is more than 100 characters. In this case, the `getChangelogValue`
    returns an empty string and `getChangelogString` returns the truncated string.
    The overridden methods are as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a value is changed for a custom field, it updates the value in the
    `CustomFieldValue` table. In addition, it also stores the changes on the issue
    by making a change log entry.
  prefs: []
  type: TYPE_NORMAL
- en: For every set of changes happening on an issue at a single update, a record
    is created under the `ChangeGroup` table. It stores the name of the user who made
    the change (author), the time when the change was made (created), and the issue
    ID (issue).
  prefs: []
  type: TYPE_NORMAL
- en: 'For every change group, there will be one or more change items stored in the
    `ChangeItem` table. It is in this table that the old and new values for fields
    are stored. For both old and new value, there are two columns in the table – one
    for the string representation and another for the ID. The following is the entity
    definition for the `ChangeItem` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The fields `oldvalue` and `newvalue` are populated using the method `getChangelogValue`.
    Similarly, the fields `oldstring` and `newstring` are populated using `getChangelogString`.
  prefs: []
  type: TYPE_NORMAL
- en: These fields are the ones used while displaying the change history.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from one custom field type to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you been using JIRA for more than a year or are you a power user of JIRA?
    That is, have you performed huge customizations, created numerous plugins, used
    lot of use cases, and so on? Then it is very likely that you have come across
    this scenario. You want to move the values from an old custom field to a new field.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA doesn't have a standard way of doing this. But you can achieve this to
    an extent by modifying the JIRA database. Even with SQL, there are some restrictions
    for doing this.
  prefs: []
  type: TYPE_NORMAL
- en: The first and foremost thing to check is that both the fields are compatible.
    You can't move the values from a text field to a number field without extra checks
    and validations. If there is a value `1234a` stored in one of the issues, it can't
    be stored as a number field as it is not a valid number. The same applies to all
    the field types.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see the migration of compatible types and discuss a few other scenarios
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us assume you have two text fields `Field A` and `Field B`. We need to
    migrate the values on every issue from `Field A` to `Field B`. Following are the
    steps that should be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Shut down the JIRA instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a backup of the database. We can revert to this backup if anything goes
    wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect to your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following SQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The query assumes that the custom field names are unique. If you have more than
    one custom field with the same name, use the IDs instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Commit the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-index JIRA by going to **Administration** | **System** | **Indexing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That should do it! Verify your changes both on the issue and in the filters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the SQL statements and database references are based on Oracle 10g. Please
    modify it to suit your database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that we did here was change the custom field ID in the `customfieldvalue`
    table. The other steps are standard steps for executing any SQL in JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if you have two custom fields with the same `name`, make sure you
    use the correct `id` instead of finding it using the `name` in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this will work fine if both the fields are of the same type. But what if
    you want to move the values from one type to another? This may not always be possible
    because some of the values in the `customfieldvalue` table may not be compatible
    with other custom field types.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider migrating a normal text field to a text area custom field. The
    value in the text area custom field is stored as a `CLOB` in the `textvalue` column
    in the database. But the value in a normal text field is stored as VARCHAR 2(255)
    in the `stringvalue` column. So, when you convert, we need to update the custom
    field ID, read the VARACHAR2(255) value from the `stringvalue` column and store
    it in the `textvalue` column as a `CLOB`. And set the no longer used `stringvalue`
    to `null` in order to free space in the database.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if you are trying the reverse order, that is, migrating from
    text area to text field, you should take into consideration the length of the
    text, and remove the extra text, as the text field can hold only up to 255 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the data type for the various custom fields by looking at the
    `getDatabaseType` method. For a `TextField`, the method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Other available field types are `TYPE_UNLIMITED_TEXT` (for example, text area),
    `TYPE_DATE` (Date custom field), and `TYPE_DECIMAL` (for example, number field).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we just need to change the type of a custom field instead of creating
    a new one and then migrating the values across. Let us quickly see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type of a custom field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the table that needs to be updated is the `CustomField` table.
    All we need to do is to update the `customfieldtypekey`. Just set the new custom
    field type key which will be {`YOUR_ATLASSIAN_PLUGIN_KEY}:{MODULE_KEY}`.
  prefs: []
  type: TYPE_NORMAL
- en: For a text field, the key is `com.atlassian.jira.plugin.system.customfieldtypes:textfield`.
  prefs: []
  type: TYPE_NORMAL
- en: For incompatible types, we need to consider all aforementioned cases and update
    the `CustomFieldValue` table accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Retrieving custom field details from database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making custom fields sortable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the creation of new custom fields, writing new searchers for them,
    and so on. Another important feature with the fields, be it custom fields or the
    standard JIRA fields, is to use them for sorting. But simply writing a new custom
    field type won't enable sorting on that field.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to enable sorting on custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the new custom field type that we need to enable searching for.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is easy to do. There are only two simple steps that you need to do to
    make sure the custom field is a sortable field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `SortableCustomField` interface. A new custom field type will
    look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are extending an existing custom field type like `TextCFType`, it already
    implements the interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `compare` method. Following is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DemoComparator` here is a custom comparator that we can write to implement
    the sorting logic.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just invoke `SortableCustomField.compare()` if a custom comparator is not needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the custom field implements the `SortableCustomField` interface, we can
    click on its header on the issue navigator, and see it getting sorted based on
    the logic we implemented.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BestNameComparator`, `FullNameComparator`, `LocaleComparator`, `GenericValueComparator`,
    and so on, are some reusable comparators that ships with JIRA. There is no definite
    list, but you will find quite a lot of them in the JIRA source, if you have access.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a simple custom field*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Making the custom field project importable*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying custom fields on subtask columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the easiest things that you can do! But it adds a lot of value
    at times. We are talking about adding extra columns for subtasks on the parent
    issue page.
  prefs: []
  type: TYPE_NORMAL
- en: We know how to add extra fields, don't we? Let us see how to do it and especially
    how to add custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In short, you need to modify the `jira.table.cols.subtasks` property in the
    `jira-application.properties`. Following are the steps to do it. We add a custom
    field in the example shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Stop JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `WEB-INF/classes` folder and modify the `jira.table.cols.subtasks`
    property in the `jira-application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the extra fields you want to add along with the existing fields like status,
    assignee, and so on. For a custom field to be added in the columns, add `customfield_xxxxxx`
    where `xxxxx` is the unique numeric ID of the custom field. You can find this
    unique ID from the database or from the URL when you hover over any of the operations
    on the custom field (for example, Edit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From JIRA 4.4, this property is available under **Administration** | **General
    Configuration** | **Advanced**. There is no need to modify the property file and
    restart JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA renders the subtask columns on the view issue page by looking at the preceding
    property. While adding the standard subtask fields are useful, adding custom fields
    can be extremely helpful sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have added `customfield_10140`, where `10140` is the numeric
    ID for the custom field. It stores the URL associated with the task, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looks useful, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: User and date fields from 4.1.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have upgraded from a pre 4.1 to a post 4.1 version, you must have noticed
    the new **View Issue** page. People have different opinions on the new UI usability,
    but one thing that gets everyone''s vote is how the date and user fields are arranged
    in the UI. You will see a section of its own for the user and date fields, as
    shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User and date fields from 4.1.x](img/1803-03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So how do our fields appear in that section?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write your new date fields or user fields, all you need to do to make
    it appear in the correct sections is to implement the right interface!
  prefs: []
  type: TYPE_NORMAL
- en: 'For a user field, the new custom field type class should implement the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For a date field, implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you are extending the existing date fields or user fields, they already implement
    the interface, and hence they will appear automatically in there!
  prefs: []
  type: TYPE_NORMAL
- en: What if you do not want your field in the special date/user sections? Simply
    ignore these interfaces. The fields will appear just like normal custom fields
    and will then appear in the order specified under field configurations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is quite simple. JIRA looks out for classes implementing the `UserField`/`DateField`
    interfaces and displays them in the respective sections. On the standard custom
    field section, it doesn't show these fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ever wondered where this check is done in the JIRA source code? The view is
    rendered in the `ViewIssue` class, but the actual check is done in the `util`
    class: `com.atlassian.jira.issue.fields.util.FieldPredicates`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a simple custom field*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom fields to notification mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main features of JIRA is its capability to send notifications – to
    selected people on selected events! It is often a requirement from JIRA users
    to customize these notifications, mainly to add more content in the form of custom
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: If you understand velocity templates, adding custom fields to notification mails
    is a cakewalk, as we would see in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should know the custom field ID that you need to add into the template.
    The `id` can be found in the URL that you see when you hover over the 'Edit' operation
    on the custom field in the administration page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us have a look at adding a custom field, X, into a notification mail when
    an issue is updated. The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the template that needs to be updated. For each event in JIRA, you
    can find the template associated with it in the `email-template-id-mappings.xml`
    residing under the `WEB-INF/classes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, the event is `Issue Updated`, and the matching template is `issueupdated.vm`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the template is identified, the files are present under `WEB-INF/classes/templates/email/text/`
    and `WEB-INF/classes/templates/email/html/`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify the template to include the custom field name and value wherever required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The name of the custom field can be retrieved as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The actual value can be retrieved as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In both the cases, `10010` is the numeric ID of the `customfield` that we discussed
    before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The e-mail notifications are rendered using velocity templates. JIRA already
    has a lot of objects in the velocity context including `customFieldManager` and
    `issue` objects that we have just used. The full list of objects available in
    the velocity context for e-mail templates can be found in the Atlassian documentation
    at [http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates](http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use the `customFieldManager` object to retrieve information
    about the custom field and then we use the `issue` object to retrieve its value
    from the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding help text for a custom field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our JIRA instance grows, demanding more and more information from the users
    through the custom fields, it becomes a norm to let the users know what we expect
    from them. Apart from a bunch of tutorials that we can prepare for them, it makes
    sense to give them some help right there on the screen, next to the field.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see the various options on how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have the custom field, for which the help needs to be displayed
    and configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various ways to provide help. Let us see the most widely accepted
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Link to a help page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just common sense. Just link to a documentation about the field, hosted
    somewhere. We can do this easily by adding few hyperlinks in the description of
    the custom field. We just need to reuse some of the JIRA styles to make sure the
    help appears consistent across the system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The hyperlinks again can be added in two ways. They are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the help document in a new window
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we just link to an external page, which opens in a new window.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`My Demo Field` here is the custom field name. As you can see, we use the image
    that ships along with JIRA for the consistency we discussed before. One thing
    we need to note here is the URL of the image – `/jira/images/icons/help_blue.gif`.
    In this case, we assume that `/jira` is the context path for this instance. If
    there is no context path, just use `/images/icons/help_blue.gif` or replace `/jira`
    using the context path of your instance!'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Also notice the CSS class `localHelp`, which is again used for consistency across
    help texts. Modify the help URL and title as per your needs.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the help document as a popup
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we open the help document as a popup instead of opening a new window. The
    focus is passed to the new window.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Again, the image and CSS files remain the same. Here we can specify the width,
    height, and so on, of the pop-up window as shown in the preceding code. Everything
    else remains the same!
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide inline help.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is suitable if the help isn't big enough to be put in documentation, but
    at the same time you don't want them to appear along with the description of the
    field! In this case, we go for a little JavaScript trick where we hide the help
    text under an HTML `DIV` and toggle the visibility as the user clicks on the help
    image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Put the following under the field description after modifying the relevant
    text. Here, `My Demo Field` is the actual field description and `Inline help for
    my demo field!` is the extra help we added:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Short and sweet, right?
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA, thankfully, allows HTML rendering on its description field. We have just
    used the HTML capabilities to provide some help for the field. It gives us lot
    of options and the aforementioned ones are just pointers on how to exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the 'none' option from a select field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a JIRA plugin developer, you must have come across this feature request
    before. Some people just don't like the 'none' option in the select fields for
    various reasons. One reason, obviously, is to force the users to select a valid
    value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Select Field` is a system custom field that uses velocity templates to render
    the view and edit screens. In order to remove the `none` option, we need to modify
    the edit template.'
  prefs: []
  type: TYPE_NORMAL
- en: For any system custom field, you can find the associated classes and their velocity
    templates from the file `system-customfieldtypes-plugin.xml` residing under the
    `WEB-INF/classes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we can find the following snippet related to `select-field`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As evident from the preceding snippet, the edit template for the select field
    is `templates/plugins/fields/edit/edit-select.vm`. That is the file we need to
    modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do now is to navigate to the file and remove the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The remaining code in the template *must not* be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Restart JIRA to make the change effective.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same approach can be used to remove the `none` option from other fields
    like 'radio buttons', 'multi select', 'cascading select', and so on. The actual
    code to remove will differ, but the approach is the same.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's more to it…
  prefs: []
  type: TYPE_NORMAL
- en: Reloading velocity changes without restart (auto reloading)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can configure JIRA to reload the changes to velocity templates without
    a restart. To do this, you need to make two changes to the `velocity.properties`
    file under `WEB-INF/classes`:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `class.resource.loader.cache` property to `false`. It is true, by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment the `velocimacro.library.autoreload=true` property. This can be done
    by removing the `#` at the beginning of the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart JIRA and then the changes to the velocity templates will be reloaded
    without another restart!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Changing the size of a text area custom field*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the custom field project importable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of JIRA 3.13, individual projects can be imported from an existing JIRA backup
    file. More information on this can be found at [http://confluence.atlassian.com/display/JIRA/Restoring+a+Project+from+Backup](http://confluence.atlassian.com/display/JIRA/Restoring+a+Project+from+Backup).
  prefs: []
  type: TYPE_NORMAL
- en: While importing projects, JIRA lets you copy all the issue data across, but
    only if it is asked to do so! Let us see how we can make the custom fields' project
    importable, or in simple words, inform JIRA that our fields are okay to be imported!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All we need to do to tag our custom field project as importable is to implement
    the following interface: `com.atlassian.jira.imports.project.customfield.ProjectImportableCustomField`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will have to then implement the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There are already existing implementations for the `ProjectCustomFieldImporter`
    class like the `SelectCustomFieldImporter` class, which we can reuse. It is in
    this class that we check whether the value getting imported is a valid value or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the case of a `select` field, we need to make sure that the
    value being imported is a valid option configured in the custom field on the target
    system. It is entirely up to the users to implement the various rules at this
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the Javadocs at: [http://docs.atlassian.com/jira/latest/com/atlassian/jira/imports/project/customfield/ProjectCustomFieldImporter.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/imports/project/customfield/ProjectCustomFieldImporter.html)
    for more details on doing custom `ProjectCustomFieldImporter` implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Making custom fields sortable*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the size of a text area custom field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed before, JIRA ships with some pre-defined custom field types.
    One such commonly used type is the Text Area field.
  prefs: []
  type: TYPE_NORMAL
- en: The Text Area field has a pre-defined width and height which is not customizable.
    It is often a requirement from the JIRA users to increase the size of the field
    either globally or for a particular custom field.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a look at how to achieve this in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like any other custom fields, the Text Area field is also rendered using
    velocity templates. From the `system-customfieldtypes-plugin.xml` file, we can
    find out that the location of the edit template is `templates/plugins/fields/edit/edit-textarea.vm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If we need to increase the size, we need to modify the template to increase
    the `rows` or `cols` property, as per the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to increase the width (number of columns) to 50 and height (number
    of rows) to 8, the `cols` and `rows` properties need to be updated to 50 and 8,
    respectively. The template will then look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If this needs to be done only for a selected `customfield`, just add a condition
    at the beginning of the template to handle the custom field separately. The template
    will then look like the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, that gives you an idea about increasing the size of the Text Area
    custom field.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, JIRA should be restarted to make this change effective, unless *velocity
    autoloading* is enabled, as we discussed in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Removing the ''none'' option from a select field*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
