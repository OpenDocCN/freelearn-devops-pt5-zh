<html><head></head><body><div><div><p id="_idParaDest-38" class="chapter-number"><a id="_idTextAnchor068"/><em class="italic">Chapter 2</em></p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor069"/>Building Container Images</h1>
			<p>In this chapter, you will start building container images. We will look at five different ways you can define and build images using native Docker tools.</p>
			<p>We will discuss the recommended ways that you can define and build your own images, as well as one way that is not considered to be a best practice but does have its uses. </p>
			<p>We will cover the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor070"/>I<a id="_idTextAnchor071"/>n<a id="_idTextAnchor072"/>troducing Dockerfiles</li>
				<li><a id="_idTextAnchor073"/>B<a id="_idTextAnchor074"/>u<a id="_idTextAnchor075"/>ilding Docker images</li>
			</ul>
			<p>Let’s get started!</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p>In this chapter, we will be using our Docker installation to build images. Some of the supporting commands, which will be few and far between, may only be applicable to macOS and Linux-based operating systems. </p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3h7oDX5">https://bit.ly/3h7oDX5</a></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While the screenshots in this chapter will be from my preferred operating system, which is macOS, the Docker commands we will be running will work on all three operating systems we have installed Docker on so far.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor077"/>Introducing Dockerfiles</h1>
			<p>In this section, we will <a id="_idIndexMarker086"/>cover Dockerfiles in depth, along with the best practices when it comes to their use. So, what is a Dockerfile?</p>
			<p>A <code>docker image build</code> command, which we will look at next, it is used to assemble<a id="_idIndexMarker087"/> a container image. </p>
			<p>A Dockerfile looks as follows:</p>
			<pre>FROM alpine:latest
LABEL maintainer=”Russ McKendrick &lt;russ@mckendrick.io&gt;”
LABEL description=”This example Dockerfile installs NGINX.”
RUN apk add --update nginx &amp;&amp; \
    rm -rf /var/cache/apk/* &amp;&amp; \
    mkdir -p /tmp/nginx/
COPY files/nginx.conf /etc/nginx/nginx.conf
COPY files/default.conf /etc/nginx/conf.d/default.conf
ADD files/html.tar.gz /usr/share/nginx/
EXPOSE 80/tcp
ENTRYPOINT [“nginx”]
CMD [“-g”, “daemon off;”]</pre>
			<p>As you can see, even with no explanation, it is quite easy to get an idea of what each step of the Dockerfile instructs the build command to do. Before we move on and work our way through the previous file, we should quickly touch upon Alpine Linux.</p>
			<p><code>grsecurity/PaX</code>, which is patched into its kernel. This port offers proactive protection against dozens of potential zero-day threats and other vulnerabilities.</p>
			<p>Alpine Linux, due to both its size and how powerful it is, has become the default image base for the official container<a id="_idIndexMarker089"/> images supplied by Docker. Because of this, we will be using it throughout this book. To give<a id="_idIndexMarker090"/> you an idea of just how small the official image for Alpine Linux is, let’s compare it to some of the other distributions available at the time of writing:</p>
			<div><div><img src="img/image_00_001.jpg" alt="Figure 2.1 – Comparing the size of popular base images&#13;&#10;" width="1403" height="406"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Comparing the size of popular base images</p>
			<p>As you can see from the preceding Terminal output, Alpine Linux weighs in at only 5.59 MB, as opposed to the biggest image, which is CentOS, at 237 MB. A bare-metal installation of Alpine Linux comes in at around 130 MB, which is still almost half the size of the CentOS container image.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor078"/>Reviewing Dockerfiles in depth</h2>
			<p>Let’s take a look at<a id="_idIndexMarker091"/> the instructions we used in the preceding Dockerfile example. We will look at them in the order they appeared in:</p>
			<ul>
				<li><code>FROM</code></li>
				<li><code>LABEL</code></li>
				<li><code>RUN</code></li>
				<li><code>COPY</code> and <code>ADD</code></li>
				<li><code>EXPOSE</code></li>
				<li><code>ENTRYPOINT</code> and <code>CMD</code></li>
				<li>Other Dockerfile instructions</li>
			</ul>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor079"/>FROM</h2>
			<p>The <code>FROM</code> instruction tells Docker which<a id="_idIndexMarker092"/> base you would like to use for your image. As we already mentioned, we are using Alpine Linux, so we simply have to state the name of the image and the release tag we wish to use. In our case, to use the latest official Alpine Linux image, we simply need to add <code>alpine:latest</code>.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor080"/>LABEL</h2>
			<p>The <code>LABEL</code> instruction can be used to <a id="_idIndexMarker093"/>add extra information to the image. This information can be anything from a version number to a description. It’s also recommended that you limit the number of labels you use. A good label structure will help others who will use our image later on.</p>
			<p>However, using too many labels <a id="_idIndexMarker094"/>can cause the image to become inefficient as well, so I would recommend using the label schema detailed at <a href="http://label-schema.org%20">http://label-schema.org</a>. You can view the containers’ labels with the following <code>docker inspect</code> command:</p>
			<pre>$ docker image inspect &lt;IMAGE_ID&gt;</pre>
			<p>Alternatively, you can use the following command to filter just the labels:</p>
			<pre>$ docker image inspect -f {{.Config.Labels}} &lt;IMAGE_ID&gt;</pre>
			<p>In the following screenshot, you can see the labels present for the CentOS image:</p>
			<div><div><img src="img/image_00_002.jpg" alt="Figure 2.2 – Checking image label&#13;&#10;" width="1650" height="261"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Checking image label</p>
			<p>In our example Dockerfile, we have added two labels:</p>
			<p><code>maintainer=”Russ McKendrick &lt;russ@mckendrick.io&gt;”</code>: Adds a label that helps the end user of the image identify who is maintaining it.</p>
			<p><code>description=”This example Dockerfile installs NGINX.”</code>: Adds a brief description of what the image is.</p>
			<p>Generally, it is better to define your labels<a id="_idIndexMarker095"/> when you create a container from your image, rather than at build time, so it is best to keep labels down to just metadata about the image and nothing else.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor081"/>RUN</h2>
			<p>The <code>RUN</code> instruction is where we interact with<a id="_idIndexMarker096"/> our image to install software and run scripts, commands, and other tasks. As you can see from the following <code>RUN</code> instruction, we are actually running three commands:</p>
			<pre>RUN apk add --update nginx &amp;&amp; \
    rm -rf /var/cache/apk/* &amp;&amp; \
    mkdir -p /tmp/nginx/</pre>
			<p>The first of our three commands is the equivalent of running the following command if we had a shell on an Alpine Linux host:</p>
			<pre>$ apk add --update nginx</pre>
			<p>This command installs NGINX using Alpine Linux’s package manager.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We are using the <code>&amp;&amp;</code> operator to <a id="_idIndexMarker097"/>move on to the next command if the previous command was successful. This makes it more obvious which commands we are running in the Dockerfile. We are also using <strong class="bold">\</strong>, which allows us to split the command over multiple lines, making it even easier to read.</p>
			<p>The following command in our chain removes any temporary files to keep the size of our image to a minimum:</p>
			<pre>$ rm -rf /var/cache/apk/*</pre>
			<p>The final command in our chain creates a folder with a path of <code>/tmp/nginx/</code> so that NGINX will start correctly when we run the container:</p>
			<pre>$ mkdir -p /tmp/nginx/</pre>
			<p>We could have also used the following in our Dockerfile to achieve the same results:</p>
			<pre>RUN apk add --update nginx
RUN rm -rf /var/cache/apk/*
RUN mkdir -p /tmp/nginx/</pre>
			<p>However, much like adding multiple<a id="_idIndexMarker098"/> labels, this is considered inefficient as it can add to the overall size of the image, which we should try to avoid. There are some valid use cases for this as some commands do not work well when they are stringed together using <code>&amp;&amp;</code>. However, for the most part, this approach to running commands should be avoided when your image is being built.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor082"/>COPY and ADD</h2>
			<p>At first glance, <code>COPY</code> and <code>ADD</code> look like they <a id="_idIndexMarker099"/>are doing the same task in that they are both <a id="_idIndexMarker100"/>used to transfer files to the image. However, there are some important differences, which we will discuss here. </p>
			<p>The <code>COPY</code> instruction is the more straightforward of the two:</p>
			<pre>COPY files/nginx.conf /etc/nginx/nginx.conf
COPY files/default.conf /etc/nginx/conf.d/default.conf</pre>
			<p>As you have probably guessed, we are copying two files from the <code>files</code> folder on the host we are building our image on. The first file is <code>nginx.conf</code>, which is a minimal NGINX configuration file:</p>
			<pre>user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  ‘$remote_addr - $remote_user [$time_
local] “$request” ‘
                      ‘$status $body_bytes_sent “$http_referer”
‘
                      ‘”$http_user_agent” “$http_x_forwarded_
for”’;
    access_log  /var/log/nginx/access.log  main;
    sendfile        off;
    keepalive_timeout  65;
    include /etc/nginx/conf.d/*.conf;
}</pre>
			<p>This will overwrite the <a id="_idIndexMarker101"/>NGINX configuration that was installed as part of the APK installation<a id="_idIndexMarker102"/> in the <code>RUN</code> instruction. </p>
			<p>The next file, <code>default.conf</code>, is the simplest virtual host that we can configure, and contains the following content:</p>
			<pre>server {
  location / {
      root /usr/share/nginx/html;
  }
}</pre>
			<p>Again, this will overwrite any existing files. So far, so good! So, why might we use the <code>ADD</code> instruction?</p>
			<p>In our example Dockerfile, the <code>ADD</code> instruction looks as follows:</p>
			<pre>ADD files/html.tar.gz /usr/share/nginx/</pre>
			<p>As you can see, we <a id="_idIndexMarker103"/>are adding a file called <code>html.tar.gz</code>, but we are not actually doing anything with the archive to uncompress it in our Dockerfile. This is because <code>ADD</code> automatically uploads, uncompresses, and adds the resulting folders and files to<a id="_idIndexMarker104"/> the path we request it to, which in our case is <code>/usr/share/nginx/</code>. This gives us our web root of <code>/usr/share/nginx/html/</code>, as we defined in the virtual host block in the <code>default.conf</code> file that we copied to the image.</p>
			<p>The <code>ADD</code> instruction can also be used to add content from remote sources. For example, consider the following:</p>
			<pre>ADD https://raw.githubusercontent.com/PacktPublishing/Mastering-Docker-Fourth-Edition/master/chapter02/dockerfile-example/files/html.tar.gz /usr/share/nginx/</pre>
			<p>The preceding command line would download <code>html.tar.gz</code> from <code>https://raw.githubusercontent.com/PacktPublishing/Mastering-Docker-Fourth-Edition/master/chapter02/dockerfile-example/files/</code> and place the file in the <code>/usr/share/nginx/</code> folder on the image. </p>
			<p>Archive files from a remote source are treated as files and are not uncompressed, which you will have to take into account when using them. This means that the file will have to be added before the <code>RUN</code> instruction so that we can manually unarchive the folder and also remove the <code>html.tar.gz</code> file.</p>
			<p><code>EXPOSE</code>: The <code>EXPOSE</code> instruction lets Docker know that when the image is executed, the port and protocol <a id="_idIndexMarker105"/>defined will be exposed at runtime. This instruction does not map the port to the host machine; instead, it opens the port to allow access to the service on the container network.</p>
			<p>For example, in our Dockerfile, we are telling Docker to open port <code>80</code> every time the image runs:</p>
			<pre>EXPOSE 80/tcp</pre>
			<p>The benefit of using <code>ENTRYPOINT</code> over <code>CMD</code> is that you<a id="_idIndexMarker106"/> can use them in conjunction with each other. <code>ENTRYPOINT</code> can be used by itself but remember that you <a id="_idIndexMarker107"/>would only want to use <code>ENTRYPOINT</code> by itself if you wanted your container to be executable.</p>
			<p>For reference, if you think of some of the <code>CLI</code> commands you might use, you must specify more than just the <code>CLI</code> command. You might have to add extra parameters that you want the command to interpret. This would be the use case for using <code>ENTRYPOINT</code> only.</p>
			<p>For example, if you want to have a default command that you want to execute inside a container, you could do something similar to the following example. Be sure to use a command that keeps the container alive. </p>
			<p>Here, we are using the following:</p>
			<pre>ENTRYPOINT [“nginx”]
CMD [“-g”, “daemon off;”]</pre>
			<p>What this means is that whenever we launch a container from our image, the NGINX binary is executed, which, as we have defined, is our entry point. Then, whatever we have as <code>CMD</code> is executed, giving us the equivalent of running the following command:</p>
			<pre>$ nginx -g daemon off;</pre>
			<p>Another example of how <code>ENTRYPOINT</code> can be used is as follows:</p>
			<pre>$ docker container run --name nginx-version dockerfile-example
-v</pre>
			<p>This would be the equivalent of running the following command on our host:</p>
			<pre>$ nginx -v</pre>
			<p>Notice that we didn’t have to tell Docker to use NGINX. Since we have the NGINX binary as our entry point, any command <a id="_idIndexMarker108"/>we pass overrides the <code>CMD</code> instruction that has been defined in the Dockerfile.</p>
			<p>This would display the<a id="_idIndexMarker109"/> version of NGINX we have installed and our container would stop, as the NGINX binary would only be executed to display the version information. We will look at this once we have built and launched a container using our image. Before we move on, we should look at some of the instructions that are not included in our Dockerfile.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor083"/>Other Dockerfile instructions</h2>
			<p>There are some instructions that we have not included in our example Dockerfile. Let’s take a look at them here:</p>
			<ul>
				<li><code>USER</code>: The <code>USER</code> instruction lets you specify the<a id="_idIndexMarker110"/> username to be used when a command is run. The <code>USER</code> instruction can be used on the <code>RUN</code> instruction, the <code>CMD</code> instruction, or the <code>ENTRYPOINT</code> instruction in the Dockerfile. Also, the user defined in the <code>USER</code> instruction must exist, or your image will fail to build. Using the <code>USER</code> instruction can also introduce permission issues, not only on the container itself, but also if you mount volumes.</li>
				<li><code>WORKDIR</code>: The <code>WORKDIR</code> instruction<a id="_idIndexMarker111"/> sets the working directory for the same set of instructions that the <code>USER</code> instruction can use (<code>RUN</code>, <code>CMD</code>, and <code>ENTRYPOINT</code>). It will allow you to use the <code>CMD</code> and <code>ADD</code> instructions as well.</li>
				<li><code>ONBUILD</code>: The <code>ONBUILD</code> instruction lets<a id="_idIndexMarker112"/> you stash a set of commands to be used when the image is used in the future, as a base image for another container image. For example, if you want to give an image to developers and they all have a different code base that they want to test, you can use the <code>ONBUILD</code> instruction to lay the groundwork ahead of the fact of needing the actual code. Then, the developers will simply add their code to the directory you ask them to, and <a id="_idIndexMarker113"/>when they run a new Docker build command, it will add their code to the running image.The <code>ONBUILD</code> instruction can be used in conjunction with the <code>ADD</code> and <code>RUN</code> instructions, such as in the following example:</li>
			</ul>
			<pre>ONBUILD RUN apk update &amp;&amp; apk upgrade &amp;&amp; rm -rf /var/cache/
apk/*</pre>
			<p>This would run an update and package upgrade every time our image is used as a base for another container image.</p>
			<ul>
				<li><code>ENV</code>: The <code>ENV</code> instruction<a id="_idIndexMarker114"/> sets ENVs within the image both when it is built and when it is executed. These variables can be overridden when you launch your image.</li>
			</ul>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor084"/>Dockerfiles – best practices</h2>
			<p>Now that we have<a id="_idIndexMarker115"/> covered Dockerfile instructions, let’s take a look at a few tips that are considered best practices for writing our own Dockerfiles. Following these will ensure that your images are lean, consistent, and easy for others to follow:</p>
			<ul>
				<li>You should try to get into the habit of using a <code>.dockerignore</code> file. We will cover the <code>.dockerignore</code> file in the <em class="italic">Building Docker images</em> section of this chapter; it will seem very familiar if you are used to using a <code>.gitignore</code> file. It will essentially ignore the items you specified in the file during the build process.</li>
				<li>Remember to only have one Dockerfile per folder to help you organize your containers.</li>
				<li>Use a version control system, such as Git, for your Dockerfile; just like any other text-based document, version control will help you move not only forward, but also backward, as necessary.</li>
				<li>Minimize the number of packages you need to install per image. One of the biggest goals you want to achieve while building your images is to keep them as small and secure as possible. Not installing unnecessary packages will greatly help in achieving this goal.</li>
				<li>Make sure there is only one<a id="_idIndexMarker116"/> application process per container. Every time you need a new application process, it is good practice to use a new container to run that application in.</li>
				<li>Keep things simple; over-complicating your Dockerfile will add bloat and potentially cause you issues down the line.</li>
				<li>Learn by example! Docker themselves have quite a detailed style guide for publishing the official images they host on Docker Hub. You can find a link to this in the <em class="italic">Further reading</em> section at the end of this chapter.</li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor085"/>Building Docker images</h1>
			<p>In this section, we will cover the <code>docker image build</code> command. This is where the rubber meets the road, as<a id="_idIndexMarker117"/> they say. It’s time for us to build the base upon which we will start building our future images. We will be looking at different ways to accomplish this goal. Consider this as a template that you may have created earlier with virtual machines. This will help save you time as this will complete the hard work for you; you will just have to create the application that needs to be added to the new images.</p>
			<p>There are a lot of switches that you can use while using the <code>docker build</code> command. So, let’s use the one that is always handy. Here, we will use the <code>--help</code> switch on the <code>docker image build</code> command to view what we can do:</p>
			<pre>$ docker image build --help</pre>
			<p>There are a lot of different flags listed that you can pass when building your image. Now, it may seem like a lot to digest, but out of all these options, we only need to use <code>--tag</code>, or its shorthand, <code>-t</code>, to name our image.</p>
			<p>You can use the other options to<a id="_idIndexMarker118"/> limit how much CPU and memory the build process will use. In some cases, you may not want the <code>build</code> command to take as much CPU or memory as it can have. The process may run a little slower, but if you are running it on your local machine or a production server and it’s a long build process, you may want to set a limit. There are also options that affect the network configuration of the container that was launched to build our image.</p>
			<p>Typically, you don’t use the <code>--file</code> or <code>-f</code> switch since you run the <code>docker build</code> command from the same folder that the Dockerfile is in. Keeping the Dockerfile in separate folders helps sort the files and keeps the naming convention of the files the same.</p>
			<p>It’s also worth mentioning that, while you are able to pass additional ENVs as arguments at build time, they are used at build time and your container image does not inherit them. This is useful for passing information such as proxy settings, which may only be applicable to your initial build/test environment.</p>
			<p>The <code>.dockerignore</code> file, as we discussed earlier, is used to exclude those files or folders we don’t want to be included in the Docker build since, by default, all the files in the same folder as the Dockerfile will be uploaded. We also discussed placing the Dockerfile in a separate folder, and the same applies to <code>.dockerignore</code>. It should go in the folder where the Dockerfile was placed.</p>
			<p>Keeping all the items you want to use in an image in the same folder will help you keep the number of items, if any, in the <code>.dockerignore</code> file to a minimum.</p>
			<p>Since we have spent the last few sections of this chapter looking at Dockerfiles, let’s start building images using the example file we have covered here.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor086"/>Using a Dockerfile</h2>
			<p>The first method that<a id="_idIndexMarker119"/> we are going to look at for building our base <a id="_idIndexMarker120"/>container images is creating a Dockerfile. In fact, we will be using the Dockerfile from the previous section and then executing a <code>docker image build</code> command against it to get ourselves an NGINX image. </p>
			<p>So, let’s start off by looking at the Dockerfile once more:</p>
			<pre>FROM alpine:latest
LABEL maintainer=”Russ McKendrick &lt;russ@mckendrick.io&gt;”
LABEL description=”This example Dockerfile installs NGINX.”
RUN apk add --update nginx &amp;&amp; \
    rm -rf /var/cache/apk/* &amp;&amp; \
    mkdir -p /tmp/nginx/
COPY files/nginx.conf /etc/nginx/nginx.conf
COPY files/default.conf /etc/nginx/conf.d/default.conf ADD files/html.tar.gz /usr/share/nginx/
EXPOSE 80/tcp
ENTRYPOINT [“n<a id="_idTextAnchor087"/>g<a id="_idTextAnchor088"/>inx”]
CMD [“-g”, “daemon off;”]</pre>
			<p>Don’t forget that you will <a id="_idIndexMarker121"/>also need the <code>default.conf</code>, <code>html.tar.gz</code>, and <code>nginx.conf</code> files in the <code>files</code> folder. You can find these in the accompanying GitHub repository.</p>
			<p>So, there are two ways we can go <a id="_idIndexMarker122"/>about building our image. The first way would be by specifying the <code>--file</code> switch when we use the <code>docker image build</code> command. We will also utilize the <code>--tag</code> switch to give the new image a unique name:</p>
			<pre>$ docker image build --file &lt;path_to_Dockerfile&gt; --tag
&lt;REPOSITORY&gt;:&lt;TAG&gt; .</pre>
			<p>Now, <code>&lt;REPOSITORY&gt;</code> is typically the username you sign up for on Docker Hub. We will look at this in more detail in <a href="B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 3</em></a>,<em class="italic"> Storing and Distributing Images</em>, but for now, we will be using <code>local</code>. <code>&lt;TAG&gt;</code> is a unique value that allows you to identify a container. Typically, this will be a version number or an other descriptor.</p>
			<p>As we have a file called Dockerfile, we can also skip using the <code>--file</code> switch. This is the second<a id="_idIndexMarker123"/> way of building an image. The<a id="_idIndexMarker124"/> following is the code for this:  </p>
			<pre>$ docker image build --tag local:dockerfile-example .</pre>
			<p>The most important thing to remember is the dot (or period) at the very end. This is to tell the <code>docker image build</code> command to build in the current folder. When you build your image, you should see something similar to the following Terminal output:</p>
			<div><div><img src="img/image_00_003.jpg" alt="Figure 2.3 – Building an image from our Dockerfile&#13;&#10;" width="1632" height="1699"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Building an image from our Dockerfile</p>
			<p>Once it’s built, you should be able to run the following command to check whether the image is available, as well as the size of your image:</p>
			<pre>$ docker image ls</pre>
			<p>As you can<a id="_idIndexMarker125"/> see from the following Terminal output, my image<a id="_idIndexMarker126"/> size is 7.15 MB:</p>
			<div><div><img src="img/image_00_004.jpg" alt="Figure 2.4 – Checking the size of the container image&#13;&#10;" width="1650" height="297"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Checking the size of the container image</p>
			<p>You can launch a container with your newly built image by running this command:</p>
			<pre>$ docker container run -d --name dockerfile-example -p 8080:80
local:dockerfile-example</pre>
			<p>This will launch a container called <code>dockerfile-example</code>. You can check whether it is running by using the following command:</p>
			<pre>$ docker container ls</pre>
			<p>Opening your browser and going to <code>http://localhost:8080/</code> should show you an extremely simple web page that looks as follows:</p>
			<div><div><img src="img/image_00_005.jpg" alt="Figure 2.5 – Checking the container in the browser&#13;&#10;" width="1431" height="178"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Checking the container in the browser</p>
			<p>Next up, we will quickly run a few of the commands we covered in the <em class="italic">Introducing Dockerfiles</em> section of this chapter, starting with the following command:</p>
			<pre>$ docker container run --name nginx-version local:dockerfile-
example -v</pre>
			<p>As you can see from the following Terminal output, we are currently running NGINX version 1.16.1:</p>
			<div><div><img src="img/image_00_006.jpg" alt="Figure 2.6 – Checking the version of NGINX&#13;&#10;" width="1650" height="189"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Checking the version of NGINX</p>
			<p>The next command we will look at<a id="_idIndexMarker127"/> running displays the labels that we embedded<a id="_idIndexMarker128"/> at build time. </p>
			<p>To view this information, run the following command:</p>
			<pre>$ docker image inspect -f {{.Config.Labels}} local:dockerfile-
example</pre>
			<p>As you can see from the following output, this displays the information we entered:</p>
			<div><div><img src="img/image_00_007.jpg" alt="Figure 2.7 – Checking the labels of our newly built image&#13;&#10;" width="1650" height="225"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Checking the labels of our newly built image</p>
			<p>Before we move on, you can stop and remove the containers we launched with the following commands:</p>
			<pre>$ docker container stop dockerfile-example
$ docker container rm dockerfile-example nginx-version</pre>
			<p>We will go into more detail about Docker container commands in <a href="B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Containers</em>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor089"/>Using an existing container </h2>
			<p>The easiest way to build a<a id="_idIndexMarker129"/> base image is to start off by using one of the official images from Docker Hub. Docker also keeps the Dockerfile for these official builds in their GitHub repositories. So, there are at least two choices you have for using existing images that others have already created. By using the Dockerfile, you can see exactly what is included in the build and add what you need. You can then version control that Dockerfile if you want to change or share it later.</p>
			<p>There is another way to achieve this; however, it is not recommended or considered to be good practice, and I would strongly discourage you from using it.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">I would only use this method during a prototyping phase to check that the commands you are running work as expected in an interactive shell before putting them in a Dockerfile. You should always use a Dockerfile.</p>
			<p>First, we should download the image we want to use as our base; as we did previously, we will be using Alpine Linux:</p>
			<pre>$ docker image pull alpine:latest</pre>
			<p>Next, we need to run a container in the foreground so that we can interact with it:</p>
			<pre>$ docker container run -it --name alpine-test alpine /bin/sh</pre>
			<p>Once the container runs, you can add the packages as necessary using the <code>apk</code> command, or whatever the package management commands are for your Linux flavor.</p>
			<p>For example, the following commands would install NGINX:</p>
			<pre>$ apk update
$ apk upgrade
$ apk add --update nginx
$ rm -rf /var/cache/apk/*
$ mkdir -p /tmp/nginx/
$ exit</pre>
			<p>After you have installed the packages you require, you need to save the container. The <code>exit</code> command at the end of the preceding set of commands will stop the running container since the shell process<a id="_idIndexMarker130"/> we are detaching ourselves from just happens to be the process keeping the container running in the foreground. </p>
			<p>You can see this in the following Terminal output:</p>
			<div><div><img src="img/image_00_008.jpg" alt="Figure 2.8 – Checking the Terminal output&#13;&#10;" width="1650" height="913"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Checking the Terminal output</p>
			<p class="callout-heading">Tip </p>
			<p class="callout">It is at this point that you should really stop; I do not recommend that you use the preceding commands to create and distribute images, apart from the one use case we will discuss in a moment.</p>
			<p>So, to save our stopped container as an image, you need to do something similar to the following:</p>
			<pre>$ docker container commit &lt;container_name&gt; &lt;REPOSITORY&gt;:&lt;TAG&gt;</pre>
			<p>For example, I ran the following command to save a copy of the container we launched and customized:</p>
			<pre>$ docker container commit alpine-test local:broken-container</pre>
			<p>Noticed how I called my image <code>broken-container</code>? Since one of the use cases for taking this approach is that if, for some reason, you have a problem with a container, then it is extremely useful to save<a id="_idIndexMarker131"/> the failed container as an image, or even export it as a <code>TAR</code> file to share with others if you need some assistance in getting to the root of the problem.</p>
			<p>To save the image file, simply run the following command:</p>
			<pre>$ docker image save -o &lt;name_of_file.tar&gt; &lt;REPOSITORY&gt;:&lt;TAG&gt;</pre>
			<p>So, for our example, I ran the following command:</p>
			<pre>$ docker image save -o broken-container.tar local:broken-
container</pre>
			<p>This gave me a 7.9 MB file called <code>broken-container.tar</code>. Since we have this file, we can uncompress it and have a look around. It will have the following structure:</p>
			<div><div><img src="img/image_00_009.jpg" alt="Figure 2.9 – Collection of JSON files, folders, and TAR files&#13;&#10;" width="1483" height="758"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Collection of JSON files, folders, and TAR files </p>
			<p>The image is made up of a collection of JSON files, folders, and other TAR files. All the images follow this structure, so you <a id="_idIndexMarker132"/>may be thinking to yourself, <strong class="bold">why is this method so bad?</strong></p>
			<p>The biggest reason is trust (as we’ve already mentioned). Your end user will not be able to easily see what is in the image they are running. Would you randomly download a prepackaged image from an unknown source to run your workload, without checking how the image was built? Who knows how it was configured and what packages have been installed!</p>
			<p>With a Dockerfile, you can see exactly what was executed to create the image, but with the method described here, you have zero visibility of this.</p>
			<p>Another reason is that it is difficult for you to build in a good set of defaults. For example, if you were to build your image this way, then you would not really be able to take advantage of features such as <code>ENTRYPOINT</code> and <code>CMD</code>, or even the most basic instructions, such as <code>EXPOSE</code>. Instead, the user would have to define everything required while running their <code>docker container run</code> command.</p>
			<p>In the early days of Docker, distributing images that had been prepared in this way was common practice. In fact, I was<a id="_idIndexMarker133"/> guilty of it myself since, coming from an operations background, it made perfect sense to launch a <strong class="bold">machine</strong>, bootstrap it, and then create a gold master. Luckily, over the last few years, Docker has extended the build functionality to the point where this option is not even considered anymore.</p>
			<p>Using scratch as a base</p>
			<p>So far, we have been <a id="_idIndexMarker134"/>using prepared images from Docker Hub as our base images. However, it is best to avoid this altogether (sort of) and roll out your own images from scratch.</p>
			<p>Now, when you usually hear the phrase from scratch, it literally means that you start from nothing. That’s what we have here – you get absolutely nothing and have to build upon it. Now, this can be a benefit because it will keep the image size very small, but it can also be detrimental if you are fairly new to Docker as it can get complicated.</p>
			<p>Docker has done some of the hard work for us already and created an empty <code>TAR</code> file on Docker Hub named <code>scratch</code>; you can use it in the <code>FROM</code> section of your Dockerfile. You can base your entire Docker build on this, and then add parts as needed.</p>
			<p>Again, we’ll be using Alpine Linux as our base operating system for the image. The reasons for doing this include not only the fact that it is distributed as an ISO, Docker image, and various virtual machine images, but also that the entire operating system is available as a compressed <code>TAR</code> file. You can find the download in this book’s GitHub repository, or on the Alpine Linux download page.</p>
			<p>To download a copy, just select the appropriate download<a id="_idIndexMarker135"/> from the downloads page, which can be found at <a href="https://www.alpinelinux.org/downloads/">https://www.alpinelinux.org/downloads/</a>. The one I used was <code>x86_64</code> from the <strong class="bold">MINI ROOT FILESYSTEM</strong> section.</p>
			<p>Once it’s finished downloaded, you need to create a Dockerfile that uses <code>scratch</code> and then add the <code>tar.gz</code> file, making sure to use the correct file, as shown in the following example:</p>
			<pre>FROM scratch
ADD files/alpine-minirootfs-3.11.3-x86_64.tar.gz /
CMD [“/bin/sh”]</pre>
			<p>You might be thinking, why did I just download the <code>alpine-minirootfs-3.11.3-x86_64.tar.gz</code> file? Could I have not had used <code>http://dl-cdn.alpinelinux.org/alpine/v3.11/releases/x86_64/alpine-minirootfs-3.11.3-x86_64.tar.gz</code> instead? </p>
			<p>Remember, remote archives are treated as files and are just downloaded. Normally, that wouldn’t be a problem as we could just add a <code>RUN</code> command to uncompress the file, but since we are using <code>scratch</code>, an operating system hasn’t been installed, which means that there are no commands available for <code>RUN</code> to be able to execute anything.</p>
			<p>Now that we have our Dockerfile, we can build our image as we would have done on any other Docker image – by running the following command:</p>
			<pre>$ docker image build --tag local:fromscratch .</pre>
			<p>This should give you the following output:</p>
			<div><div><img src="img/image_00_010.jpg" alt="Figure 2.10 – Building from scratch&#13;&#10;" width="1650" height="551"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Building from scratch</p>
			<p>You can compare the image size to the other container images we have built by running the following command:</p>
			<pre>$ docker image ls</pre>
			<p>As you can see in the following <a id="_idIndexMarker136"/>screenshot, the image I built is exactly the same size as the Alpine Linux image we have been using from Docker Hub:</p>
			<div><div><img src="img/image_00_011.jpg" alt="Figure 2.11 – Reviewing the image sizes&#13;&#10;" width="1650" height="334"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Reviewing the image sizes</p>
			<p>Now that our own image has been built, we can test it by running this command:</p>
			<pre>$ docker container run -it --name alpine-test local:fromscratch
/bin/sh</pre>
			<p>If you get an error, then you may already have a container called <code>alpine-test</code> created or running. Remove it by running <code>docker container stop alpine-test</code>, followed by <code>docker container rm alpine-test</code>.</p>
			<p>This should launch us into a shell on the Alpine Linux image. You can check this by running the following command:</p>
			<pre>$ cat /etc/*release</pre>
			<p>This will display information on the release the container is running. To get an idea of what this entire process looks like, see the following Terminal output:</p>
			<div><div><img src="img/image_00_012.jpg" alt="Figure 2.12 – Running the image from scratch&#13;&#10;" width="1650" height="444"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – Running the image from scratch</p>
			<p>While everything appears straightforward, this is only thanks to the way Alpine Linux packages their operating system. It can start to get more complicated when you choose to use other distributions who package their operating systems in a different way.</p>
			<p>There are several tools that can be used to<a id="_idIndexMarker137"/> generate a bundle of an operating system. We are not going to go into any details regarding how to use any of these tools here because, if you must consider this approach, you probably have some pretty specific requirements. You can check the list of tools in the <em class="italic">Further reading</em> section at the end of this chapter for more details.</p>
			<p>So, what could those requirements be? For most people, it will be legacy applications; for example, what happens if you have an application that requires an operating system that is no longer supported or available from Docker Hub, but you need a more modern platform to support the application? Well, you should be able to spin your image and install the application there, thus allowing you to host your old legacy application on a modern, supportable operating system/architecture.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor090"/>Using ENVs</h2>
			<p>In this section, we will cover a<a id="_idIndexMarker138"/> very powerful set of variables known as <strong class="bold">ENVs</strong> (<strong class="bold">ENVs</strong>), as you will be seeing a lot of them. You can <a id="_idIndexMarker139"/>use ENVs for a lot of things in your Dockerfile. If you are familiar with coding, these will probably be familiar to you.</p>
			<p>For others like myself, at first, they seemed intimidating, but don’t get discouraged. They will become a great resource once you get the hang of them. They can be used to set information when running the container, which means that you don’t have to go and update lots of the commands in your Dockerfile or in the scripts that you run on the server.</p>
			<p>To use ENVs in your Dockerfile, you can use the <code>ENV</code> instruction. The structure of the <code>ENV</code> instruction is as follows:</p>
			<pre>ENV &lt;key&gt; &lt;value&gt;
ENV username admin</pre>
			<p>Alternatively, you can always place an equals sign between the key and the value:</p>
			<pre>ENV &lt;key&gt;=&lt;value&gt;
ENV username=admin</pre>
			<p>Now, the question is, why are there two ways that you can define them, and what are the differences? </p>
			<ul>
				<li>With the first example, you can only set one ENV per line; however, it is easy to read and follow. </li>
				<li>With the second ENV example, you can set multiple environmental variables on the same line, as shown here:</li>
			</ul>
			<pre>ENV username=admin database=wordpress tableprefix=wp</pre>
			<p>You can view which ENVs are set on an image using the <code>docker inspect</code> command: </p>
			<pre>$ docker image inspect &lt;IMAGE_ID&gt;</pre>
			<p>Now that we know how<a id="_idIndexMarker140"/> they need to be set in our Dockerfile, let’s take a look at them in action. So far, we have been using a Dockerfile to build a simple image<a id="_idIndexMarker141"/> with just NGINX installed. Now, let’s look at building something a little more dynamic. </p>
			<p>Using Alpine Linux, we will do the following:</p>
			<ol>
				<li>Set an ENV to define which version of PHP we would like to install.</li>
				<li>Install Apache2 and our chosen PHP version.</li>
				<li>Set up the image so that Apache2 starts without issues.</li>
				<li>Remove the default <code>index.html</code> file and add an <code>index.php</code> file that displays the results of the <code>phpinfo</code> command.</li>
				<li>Expose port 80 on the container.</li>
				<li>Set Apache so that it is the default process:<p class="callout-heading">Information </p><p class="callout">Please note that PHP5 is no longer supported. Because of that, we are having to use an older version of Alpine Linux, 3.8, as that is the last version that supports the PHP5 packages.</p></li>
			</ol>
			<pre>FROM alpine:3.8
LABEL maintainer=”Russ McKendrick &lt;russ@mckendrick.io&gt;”
LABEL description=”This example Dockerfile installs Apache &amp; PHP.”
ENV PHPVERSION 7
RUN apk add --update apache2 php${PHPVERSION}-apache2 php${PHPVERSION} &amp;&amp; \
        rm -rf /var/cache/apk/* &amp;&amp; \
        mkdir /run/apache2/ &amp;&amp; \
        rm -rf /var/www/localhost/htdocs/index.html &amp;&amp; \
        echo “&lt;?php phpinfo(); ?&gt;” &gt; /var/www/localhost/htdocs/index.php &amp;&amp; \
        chmod 755 /var/www/localhost/htdocs/index.php
EXPOSE 80/tcp
ENTRYPOINT [“httpd”]
CMD [“-D”, “FOREGROUND”]</pre>
			<p>As you can see, we have<a id="_idIndexMarker142"/> chosen to install PHP7; we can build the image by running the following command:</p>
			<pre>$ docker build --tag local/apache-php:7 .</pre>
			<p>Notice how we have changed the<a id="_idIndexMarker143"/> command slightly. This time, we are calling the <code>local/apache-php</code> image and tagging the version as <code>7</code>. The full output that we obtained by running the preceding command is as follows:</p>
			<pre>Sending build context to Docker daemon   2.56kB
Step 1/8 : FROM alpine:3.8
 ---&gt; c8bccc0af957
Step 2/8 : LABEL maintainer=”Russ McKendrick &lt;russ@mckendrick.
io&gt;”
 ---&gt; Running in 7746dd8cabd0
Removing intermediate container 7746dd8cabd0
 ---&gt; 9173a415ed21
Step 3/8 : LABEL description=”This example Dockerfile installs Apache &amp; PHP.”
 ---&gt; Running in 322e98b9c2e0
Removing intermediate container 3<a id="_idTextAnchor091"/>2<a id="_idTextAnchor092"/>2e98b9c2e0
 ---&gt; aefb9450e664
Step 4/8 : ENV PHPVERSION 7</pre>
			<p>As you can <a id="_idTextAnchor093"/>s<a id="_idTextAnchor094"/>ee from the preceding output, the <code>PHPVERSION</code> ENV has been set to the number <code>7</code>:</p>
			<pre> ---&gt; Running in 0b9e9a5d8956
Removing intermediate container 0b9e9a5d8956
 ---&gt; 219afdf8eeb8
Step 5/8 : RUN apk add --update apache2 php${PHPVERSION}-
apache2 php${PHPVERSION} &amp;&amp;         rm -rf /var/cache/apk/* &amp;&amp;
         mkdir /run/apache2/ &amp;&amp;         rm -rf /var/www/
localhost/htdocs/index.html &amp;&amp;         echo “&lt;?php phpinfo(); 
?&gt;” &gt; /var/www/localhost/htdocs/index.php &amp;&amp;         chmod 755 
/var/www/localhost/htdocs/index.php
 ---&gt; Running in 36823df46b29
fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/main/x86_64/
APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/community/
x86_64/APKINDEX.tar.gz
(1/14) Installing libuuid (2.32-r0)
(2/14) Installing apr (1.6.3-r1)
(3/14) Installing expat (2.2.8-r0)
(4/14) Installing apr-util (1.6.1-r3)
(5/14) Installing pcre (8.42-r0)
(6/14) Installing apache2 (2.4.41-r0)
Executing apache2-2.4.41-r0.pre-install</pre>
			<p>So far, we have only referred to the <a id="_idIndexMarker144"/>ENV. As<a id="_idIndexMarker145"/> shown by the following output, the necessary <code>php7</code> packages will start to be installed:</p>
			<pre>(7/14) Installing php7-common (7.2.26-r0)
(8/14) Installing ncurses-terminfo-base (6.1_p20180818-r1)
(9/14) Installing ncurses-terminfo (6.1_p20180818-r1)
(10/14) Installing ncurses-libs (6.1_p20180818-r1)
(11/14) Installing libedit (20170329.3.1-r3)
(12/14) Installing libxml2 (2.9.8-r2)
(13/14) Installing php7 (7.2.26-r0)
(14/14) Installing php7-apache2 (7.2.26-r0)
Executing busybox-1.28.4-r3.trigger
OK: 26 MiB in 27 packages
Removing intermediate container 36823df46b29</pre>
			<p>Now that all the packages have been installed, the build can do some housekeeping and then complete:</p>
			<pre> ---&gt; 842eebf1d363
Step 6/8 : EXPOSE 80/tcp
 ---&gt; Running in 40494d3b357f
Removing intermediate container 40494d3b357f
 ---&gt; 074e10ff8526
Step 7/8 : ENTRYPOINT [“httpd”]
 ---&gt; Running in a56700cae985
Removing intermediate container a56700cae985
 ---&gt; 25b63b51f243
Step 8/8 : CMD [“-D”, “FOREGROUND”]
 ---&gt; Running in d2c478e67c0c
Removing intermediate container d2c478e67c0c
 ---&gt; 966dcf5cafdf
Successfully built 966d<a id="_idTextAnchor095"/><a id="_idTextAnchor096"/>cf5cafdf
Successfully tagged local/apache-php:7</pre>
			<p>We can check<a id="_idIndexMarker146"/> whether everything ran as expected by<a id="_idIndexMarker147"/> running the following command to launch a container using the image:</p>
			<pre>$ docker container run -d -p 8080:80 --name apache-php7 local/
apache-php:7</pre>
			<p>Once it’s launched, open a browser and go to <code>http://localhost:8080/</code>. You should see a page showing that PHP7 is being used:</p>
			<div><div><img src="img/image_00_013.jpg" alt="Figure 2.13 – Checking the PHP version&#13;&#10;" width="1525" height="798"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – Checking the PHP version</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don’t be confused by the next part; there is no PHP6. You can find out more about this at the following RFC <a id="_idTextAnchor097"/>a<a id="_idTextAnchor098"/>nd the results of the vote for skipping PHP6 at https://wiki.php.net/rfc/php6.</p>
			<p>Now, in <a id="_idIndexMarker148"/>your Dockerfile, change <code>PHPVERSION</code> from <code>7</code> to <code>5</code> and then run the following command to build a new image:</p>
			<pre>$ docker image build --tag local/apache-php:5 .</pre>
			<p>As you can see from the<a id="_idIndexMarker149"/> following Terminal output, the majority of the output is the same, apart from the packages that are being installed:</p>
			<pre>Sending build context to Docker daemon   2.56kB
Step 1/8 : FROM alpine:3.8
 ---&gt; c8bccc0af957
Step 2/8 : LABEL maintainer=”Russ McKendrick &lt;russ@mckendrick.
io&gt;”
 ---&gt; Using cache
 ---&gt; 9173a415ed21
Step 3/8 : LABEL description=”This example Dockerfile installs
Apache &amp; PHP.”
 ---&gt; Using cache
 ---&gt; aefb9450e664
Step 4/8 : ENV PHPVERSION 5</pre>
			<p>Here, we can see that <code>5</code> has been set as the value of the <code>PHPVERSION</code> ENV. From here, the build will <a id="_idIndexMarker150"/>continue just like the previous build did:</p>
			<pre> ---&gt; Running in d6e8dc8b70ce
Removing intermediate container d6e8dc8b70ce
 ---&gt; 71896c898e35
Step 5/8 : RUN apk add --update apache2 php${PHPVERSION}-
apache2 php${PHPVERSION} &amp;&amp;         rm -rf /var/cache/apk/* &amp;&amp;
         mkdir /run/apache2/ &amp;&amp;         rm -rf /var/www/
localhost/htdocs/index.html &amp;&amp;         echo “&lt;?php phpinfo();
 ?&gt;” &gt; /var/www/localhost/htdocs/index.php &amp;&amp;         chmod 755
 /var/www/localhost/htdocs/index.php
 ---&gt; Running in fb946c0684e4
fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/main/x86_64/
APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/community/
x86_64/APKINDEX.tar.gz
(1/15) Installing libuuid (2.32-r0)
(2/15) Installing apr (1.6.3-r1)
(3/15) Installing expat (2.2.8-r0)
(4/15) Installing apr-util (1.6.1-r3)
(5/15) Installing pcre (8.42-r0)
(6/15) Installing apache2 (2.4.41-r0)
Executing apache2-2.4.41-r0.pre-install</pre>
			<p>Here is where the PHP5 packages <a id="_idIndexMarker151"/>are installed. This is the only difference between our two builds:</p>
			<pre>(7/15) Installing php5-common (5.6.40-r0)
(8/15) Installing ncurses-terminfo-base (6.1_p20180818-r1)
(9/15) Installing ncurses-terminfo (6.1_p20180818-r1)
(10/15) Installing ncurses-libs (6.1_p20180818-r1)
(11/15) Installing readline (7.0.003-r0)
(12/15) Installing libxml2 (2.9.8-r2)
(13/15) Installing php5-cli (5.6.40-r0)
(14/15) Installing php5 (5.6.40-r0)
(15/15) Installing php5-apache2 (5.6.40-r0)
Executing busybox-1.28.4-r3.trigger
OK: 48 MiB in 28 packages
Removing intermediate container fb946c0684e4</pre>
			<p>Again, now that the<a id="_idIndexMarker152"/> packages have been installed, the build will <a id="_idIndexMarker153"/>progress as it did previously until we have our complete image:</p>
			<pre> ---&gt; 54cbb6ef4724
Step 6/8 : EXPOSE 80/tcp
 ---&gt; Running in 59776669f08a
Removing intermediate container 59776669f08a
 ---&gt; e34c5c34658d
Step 7/8 : ENTRYPOINT [“httpd”]
 ---&gt; Running in 037ecfed197c
Removing intermediate container 037ecfed197c
 ---&gt; c50bdf3e4b02
Step 8/8 : CMD [“-D”, “FOREGROUND”]
 ---&gt; Running in 9eccc9131ef9
Removing intermediate container 9eccc9131ef9
 ---&gt; 7471b75e789e
Successfully built 7471b75e789e
Successfully tagged local/apache-php:5</pre>
			<p>We can launch a container, this time on port 9090, by running the following command:</p>
			<pre>$ docker container run -d -p 9090:80 --name apache-php5 local/apache-php:5</pre>
			<p>Opening your browser again, but this time going to <code>http://localhost:9090/</code>, should show that we are running PHP5:</p>
			<div><div><img src="img/image_00_014.jpg" alt="Figure 2.14 – Running PHP5&#13;&#10;" width="1534" height="798"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – Running PHP5</p>
			<p>Finally, you can compare the size of the images by running this command:</p>
			<pre>$ docker image ls</pre>
			<p>You should see the following<a id="_idIndexMarker154"/> Terminal output:</p>
			<div><div><img src="img/image_00_015.jpg" alt="Figure 2.15 – Comparing the image sizes&#13;&#10;" width="1284" height="318"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – Comparing the image sizes</p>
			<p>This shows that the <a id="_idIndexMarker155"/>PHP7 image is a lot smaller than the PHP5 one. Let’s discuss what actually happened when we built the two different container images.</p>
			<p>So, what happened? Well, when Docker launched the Alpine Linux image to create our image, the first thing it did was set the ENVs we defined, making them available to all the shells within the container.</p>
			<p>Luckily for us, the naming scheme for PHP in Alpine Linux simply substitutes the version number and maintains the same name for the packages we need to install, meaning that we run the following command:</p>
			<pre>RUN apk add --update apache2 php${PHPVERSION}-apache2 php${PHPVERSION}</pre>
			<p>But it is actually interpreted as follows:</p>
			<pre>RUN apk add --update apache2 php7-apache2 php7</pre>
			<p>For PHP5, it is interpreted as the following instead:</p>
			<pre>RUN apk add --update apache2 php5-apache2 php5</pre>
			<p>This means that we do not have to go through the whole Dockerfile, manually substituting version numbers. This approach is<a id="_idIndexMarker156"/> especially useful when installing packages from remote URLs, such as software release pages.</p>
			<p>What follows is a more advanced <a id="_idIndexMarker157"/>example: a Dockerfile that installs and configures Consul by <em class="italic">HashiCorp</em>. In this Dockerfile, we are using ENVs to define the version numbers and the SHA256 hash of the file we downloaded:</p>
			<pre>FROM alpine:latest
LABEL maintainer=”Russ McKendrick &lt;russ@mckendrick.io&gt;”
LABEL description=”An image with the latest version on Consul.”
ENV CONSUL_VERSION 1.7.1
ENV CONSUL_SHA256 09f3583c6cd7b1f748c0c012ce9b3d96de95
a6c0d2334327b74f7d72b1fa5054
RUN  apk add --update ca-certificates wget &amp;&amp; \
     wget -O consul.zip https://releases.hashicorp.com/consul/
${CONSUL_VERSION}/consul_${CONSUL_VERSION}_linux_amd64.zip &amp;&amp; \
     echo “$CONSUL_SHA256 *consul.zip” | sha256sum -c - &amp;&amp; \
     unzip consul.zip &amp;&amp; \
     mv consul /bin/ &amp;&amp; \
     rm -rf consul.zip &amp;&amp; \
     rm -rf /tmp/* /var/cache/apk/*
EXPOSE 8300 8301 8301/udp 8302 8302/udp 8400 8500 8600 8600/udp
VOLUME [ “/data” ]
ENTRYPOINT [ “/bin/consul” ]
CMD [ “agent”, “-data-dir”, “/data”, “-server”, “
-bootstrap-expect”, “1”, “-client=0.0.0.0”]</pre>
			<p>As you can see, Dockerfiles can get quite complex, and using ENVs can help with maintenance. Whenever a new version of Consul is released, I simply need to update the <code>ENV</code> line and commit it to GitHub, which will trigger<a id="_idIndexMarker158"/> a new image being built. Well – it would have done if we had configured it to do so. We will look at this in the next chapter.</p>
			<p>You might have also noticed we<a id="_idIndexMarker159"/> are using an instruction within the Dockerfile that we have not covered here. Don’t worry – we will look a<a id="_idTextAnchor099"/><a id="_idTextAnchor100"/>t the <code>VOLUME</code> instruction in <a href="B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Containers</em>.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor101"/>Using multi-stage builds </h2>
			<p>In this section, which is the final <a id="_idIndexMarker160"/>part of our journey into using Dockerfiles and building container images, we will look at using a relatively new method for building an image. In the<a id="_idIndexMarker161"/> previous sections, we looked at adding binaries directly to our images either via a package manager, such as Alpine Linux’s APK, or, in the previous example, by downloading a precompiled binary from the software vendor.</p>
			<p>What if we wanted to compile our own software as part of the build? Historically, we would have had to use a container image containing a full build environment, which can be very big. This means that we probably would have had to cobble together a s<a id="_idTextAnchor102"/>c<a id="_idTextAnchor103"/>ript that ran through something like the following process:</p>
			<ol>
				<li value="1">Download the build environment container image and start a <code>build</code> container.</li>
				<li>Copy the source code to the <code>build</code> container.</li>
				<li>Compile the source code on the <code>build</code> container.</li>
				<li>Copy the compiled binary outside of the <code>build</code> container.</li>
				<li>Remove the <code>build</code> container.</li>
				<li>Use a pre-written Dockerfile to build an image and copy the binary to it.</li>
			</ol>
			<p>That is a lot of logic – in an ideal world, it should be part of Docker. Luckily, the Docker community thought so, and the functionality to achieve this, called a multi-stage build, was introduced in Docker 17.05.</p>
			<p>The Dockerfile contains two different build stages:</p>
			<ul>
				<li>The first, named <code>builder</code>, uses the official Go<a id="_idIndexMarker162"/> container image from Docker Hub. Here, we are installing a prerequisite, downloading the source code directly from GitHub, and then compiling it into a static binary:</li>
			</ul>
			<pre>FROM golang:latest as builder
WORKDIR /go-http-hello-world/
RUN go get -d -v golang.org/x/net/html 
ADD https://raw.githubusercontent.com/geetarista/go-http-hello-world/master/hello_world/hello_world.go ./hello_world.go
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o 
app .
FROM scratch 
COPY --from=builder /go-http-hello-world/app .
CMD [“./app”] </pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Notice here we are using <code>ADD</code> with a URL since we want to download an uncompressed version of the source code rather than a zipped archive.</p>
			<p>As our static binary has a <a id="_idIndexMarker163"/>built-in web server, we do not really need anything else to be present from an operating system point of view. Because of this, we are <a id="_idIndexMarker164"/>able to use <code>scratch</code> as the base image, meaning that all our image will contain is the static binary that we have copied from the builder image, and won’t contain any of the <code>builder</code> environment at all.</p>
			<p>To build the image, we just need to run the following command:</p>
			<pre>$ docker image build --tag local:go-hello-world .</pre>
			<p>The output of the preceding command can be found in the following code block. The interesting bits happen between <em class="italic">steps 5</em> and <em class="italic">6</em>:</p>
			<pre>Sending build context to Docker daemon  2.048kB
Step 1/8 : FROM golang:latest as builder
latest: Pulling from library/golang
50e431f79093: Pull complete
dd8c6d374ea5: Pull complete
c85513200d84: Pull complete
55769680e827: Pull complete
15357f5e50c4: Pull complete
9edb2e455d9d: Pull complete
ed2acfe844ed: Pull complete
Digest: sha256:d27017d27f9c9a58b361aa36126a29587ffd3b1b274af0
d583fe4954365a4a59
Status: Downloaded newer image for golang:latest
 ---&gt; 25c4671a1478</pre>
			<p>Now that the build<a id="_idIndexMarker165"/> environment container image has been pulled, we can prepare the environment to build our code:</p>
			<pre>Step 2/8 : WORKDIR /go-http-hello-world/
 ---&gt; Running in 9c23e012e016
Removing intermediate container 9c23e012e016
 ---&gt; ea0d7e26799e
Step 3/8 : RUN go get -d -v golang.org/x/net/html
 ---&gt; Running in 17f173992763
get “golang.org/x/net/html”: found meta tag get.metaImport
{Prefix:”golang.org/x/net”, VCS:”git”,
 RepoRoot:”https://go.googlesource.com/net”} at
//golang.org/x/net/html?go-get=1
get “golang.org/x/net/html”: verifying non-authoritative meta
tag
golang.org/x/net (download)
Removing intermediate container 17f173992763</pre>
			<p>With the environment prepared, we can<a id="_idIndexMarker166"/> download the source code from GitHub and compile it: </p>
			<pre> ---&gt; 68f07e01b0cf
Step 4/8 : ADD https://raw.githubusercontent.com/geetarista/go-http-hello-world/master/hello_world/hello_world.go ./hello_world.go
Downloading     393B
 ---&gt; 4fb92adacdb0
Step 5/8 : RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
 ---&gt; Running in 61a82b417f60
Removing intermediate container 61a82b417f60
 ---&gt; 502d219e6869</pre>
			<p>We now have our compiled code as a single executable binary, which means that we can create a new build image using <code>scratch</code> and copy the binary from the previous build image across to the new build image:</p>
			<pre>Step 6/8 : FROM scratch
 ---&gt;
Step 7/8 : COPY --from=builder /go-http-hello-world/app .
 ---&gt; 2b4a6e6066e5
Step 8/8 : CMD [“./app”]
 ---&gt; Running in c82089ea8a6b
Removing intermediate container c82089ea8a6b
 ---&gt; 5e196ed7f699
Successfully built 5e196ed7f699
Successfully tagged local:go-hello-world</pre>
			<p>As you can see, our binary has been <a id="_idIndexMarker167"/>compiled and the container that contains<a id="_idIndexMarker168"/> the build environment has been removed, leaving us with an image storing our binary. If you were to run the following command, you would get an idea of why it is a good idea not to ship an application with its build environment intact:</p>
			<pre>$ docker image ls</pre>
			<p>The following output shows that the <code>golang</code> image is <code>809MB</code>; with our source code and prerequisites added, the size increases to <code>862MB</code>:</p>
			<div><div><img src="img/image_00_016.jpg" alt="Figure 2.16 – Checking the image sizes&#13;&#10;" width="1369" height="318"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – Checking the image sizes</p>
			<p>However, the final image is just <code>7.41MB</code>. I am sure you will agree that this is quite a dramatic amount of space that’s been saved. It also adheres to the best practices by only having content relevant to our application shipped within the image, as well as being really, really small.</p>
			<p>You can test the application by launching a container with the following command:</p>
			<pre>$ docker container run -d -p 8000:80 --name go-hello-world 
local:go-hello-world</pre>
			<p>The application is accessible over a browser and simply increments a counter each time the page is loaded. To test it on macOS and Linux, you can use the <code>curl</code> command, as follows:</p>
			<pre>$ curl http://localhost:8000/</pre>
			<p>This should give you something like the following:</p>
			<div><div><img src="img/image_00_017.jpg" alt="Figure 2.17 – Running the container and calling the page using curl&#13;&#10;" width="1482" height="365"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.17 – Running the container and calling the page using curl</p>
			<p>Windows users<a id="_idIndexMarker169"/> can simply visit <code>http://localhost:8000/</code> in a browser. To stop and remove the running container, use the following<a id="_idIndexMarker170"/> commands:</p>
			<pre>$ docker container stop go-hello-world
$ docker container rm go-hello-world</pre>
			<p>As you can see, using a multi-stage build is a relatively simple process and is in keeping with the instructions that should already be star<a id="_idTextAnchor104"/>t<a id="_idTextAnchor105"/>ing to feel familiar to you.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor106"/>Summary</h1>
			<p>In this chapter, we looked at Dockerfiles, which I am sure you will agree are a straightforward way of defining you own Docker images.</p>
			<p>Once we finished our in-depth look at Dockerfiles, we then looked at five ways in which we can build your images. We started by looking at <strong class="bold">using a Dockerfile</strong> as this is the most common way you will be building your images and we will be using it throughout the rest of this book.</p>
			<p>Then we discussed <strong class="bold">using an existing container</strong> as when Docker first came on the scene, this was the way most people originally built their images. It is no longer considered a best practice and should only ever be used if you need to create a snapshot of a running or crashed container for debug purposes.</p>
			<p>Next up we talked about <strong class="bold">using scratch as a base. </strong>This is probably the most streamlined way of creating an image as you are literally starting from zero.</p>
			<p>We moved onto discussing <strong class="bold">using environmental variables</strong>. Here, we looked at the ways we can start to introduce variables such as version numbers into our Dockerfile in a way that means we don’t have to update the file in several places.</p>
			<p>Finally, we covered <code>scratch</code> container, giving us the smallest usable images possible.</p>
			<p>In the next chapter, now that we know how to build images using Dockerfiles, we will be taking a look at Docker Hub and all of the advantages that using a registry service brings. </p>
			<p>We will also look at the Docker registry, which is open source, so that you can create and configure your own place to store images, as well as third-party hosted registry services, all of which can be used to distribute you own container images.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor107"/>Questions</h1>
			<ol>
				<li value="1">True or false: the <code>LABEL</code> instruction tags your image once it has been built.</li>
				<li>What’s the difference between the <code>ENTRYPOINT</code> and <code>CMD</code> instructions?</li>
				<li>True or false: when using the <code>ADD</code> instruction, you can’t download and automatically uncompress an externally hosted archive.</li>
				<li>What is a valid use for using an existing container as the base of your image?</li>
				<li>What does the <code>EXPOSE</code> instruction expose?</li>
			</ol>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor108"/>Further reading</h1>
			<ul>
				<li>You can find the guidelines for the official Docker container images at <a href="https://github.com/docker-library/official-images/">https://github.com/docker-library/official-images/</a>.</li>
				<li>Some of the tools to help you create containers from existing installations are as follows:<p>debootstrap: <a href="https://wiki.debian.org/Debootstrap">https://wiki.debian.org/Debootstrap</a></p><p>yumbootstrap: <a href="http://dozzie.jarowit.net/trac/wiki/yumbootstrap">http://dozzie.jarowit.net/trac/wiki/yumbootstrap</a> </p><p>rinse: <a href="https://packages.debian.org/sid/admin/rinse">https://packages.debian.org/sid/admin/rinse</a> </p><p>Docker contrib scripts: <a href="https://github.com/moby/moby/tree/master/contrib">https://github.com/moby/moby/tree/master/contrib</a></p></li>
				<li>The full GitHub repository for the Go HTTP Hello World application can be found at <a href="https://github.com/geetarista/go-http-hello-world">https://github.com/geetarista/go-http-hello-world</a>.</li>
			</ul>
		</div>
	</div>



  </body></html>