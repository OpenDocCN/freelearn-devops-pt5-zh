- en: Extracting Data from the Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the top contributor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding bottlenecks in the source tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grepping the commit messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding what has been achieved in the repository in the last period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you work in big or small organizations, safeguarding and maintaining
    data is always important and it keeps track of a fair amount of information for
    you; it is just a matter of extracting the data. Some of the data is included
    in the system by you or any other developer when the commit message is filled
    in with the proper information – for instance, details of the bug you are fixing
    from the bug tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: The data is not only valid for management but can also be used to add more time
    to refactor the C files, where almost all bugs are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the top contributor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git has a few built-in stats you can get instantaneously. The `git log` command
    has different options, such as `--numstat`, that will show the number of files
    added and lines deleted for each file since each commit. However, for finding
    the top committer in the repository, we can just use the `git shortlog` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all the examples throughout the book, we are using the `jgit` repository;
    you can either clone it or go to one of the clones you might already have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `jgit` repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `shortlog` Git command is very simple and does not have a lot of options
    or flags to use with it. It can show the log but in a boiled-down version, and
    then it can summarize it for us as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by showing the last five commits with `shortlog`. We can use `-5` to
    limit the amount of output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the output is very different from the `git log` output. You
    can try it for yourself with `git log -5`. The numbers in parentheses are the
    number of commits by that committer. Beneath the name and number are the commit
    titles of the commits. Note that no commit hashes are shown. To find the top committer
    with just those five commits is easy, but when you try running `git shortlog`
    without `-5`, it is hard to find that person. To sort and find the top committer,
    we can use the `-n` or `--numbered` option to sort the output; the top committer
    is on top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the output is nicely sorted. If we don''t care about the commit
    subjects, we can use `-s` or `--summary` to only show the commit count for each
    developer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have what we want, except that we don''t have the email addresses
    of the committers; this option is also available with `-e` or `--email`. This
    will also show the email addresses of the committers in the list. This time, we
    will try it on the entire repository. Currently, we have only listed it for the
    HEAD commit. To list it for the repository, we need to add `--all` at the end
    of the command so as to execute the command for all branches as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is the list now; we know who contributed with the most commits, but
    this picture can be a little skewed, as the top committer may just happen to be
    the creator of the project and may not actively contribute to the repository.
    So, to list the top committers for the last six months, we can add `--since="6
    months ago"` to the `git shortlog` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the picture has changed since the start of the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use *"n weeks ago"*, *"n days ago"*, *"n months ago"*, *" n hours ago"*,
    and so on for specifying time periods. You can also use specific dates, such as
    `"1 october 2013"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also list the top committer for a specific month using the `--until`
    option, where you can specify the date you wish to list the commit until. This
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get another list, and it seems like Matthias is the main
    contributor, at least compared to the initial result. These types of data can
    also be used to visualize the shift of responsibility in a repository by collecting
    the data for each month since the repository's initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with code, it is often useful to know who to go to when you need
    to perform a fix in the software, especially in an area where you are inexperienced.
    So, it would be nice to figure out who is the code owner of the file or the files
    you are changing. The obvious reason is to get some input on the code, but also
    to know who to go to for a code review. You can again use `git shortlog` to figure
    this out. You can use the command on the files as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we simply add the file to the end of the `git shortlog` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `pom.xml`, we also have a top committer. As all the options you have
    for `git log` are available for `shortlog`, we can also do this on a directory
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is fairly simple to get some indication of who to go to for
    the different files or directories in Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding bottlenecks in the source tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the development teams know where the bottleneck in the source tree is,
    but it can be challenging to convince the management that you need resources to
    rewrite some code. However, with Git, it is fairly simple to extract that type
    of data from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by checking out the stable-3.1 release as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to start by listing some stats for one commit, and then we can extend
    the examples to larger chunks of commits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option we will be using is `--dirstat` for `git log` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--dirstat` option shows which directories have changed in the commit and
    how much they have changed compared to each other. The default setting is to count
    the number of lines added to or removed from the commit. So, rearranging the code
    potentially does not count for any change, as the line count might be the same.
    You can compensate for this slightly by using `--dirstat=lines`. This option will
    look at each file line by line and see whether they have changed compared to the
    previous version as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This also gives a slightly different result. If you would like to limit the
    output to only show directories with a certain percentage or higher, we can limit
    the output as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding `10` to the `--dirstat=lines` command, we are asking Git to only
    show the directories that have 10 percent or higher changes; you can use any number
    you like here. By default, Git does not count the changes in the subdirectories,
    but only the files in the directory. So, in the following diagram, only changes
    in **File A1** are counted as changes; for the **Dir A1** directory and the **File
    B1** file, it is counted as a change in **Dir A2**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31fd16f6-6591-4ea4-b2bc-252f7dd058f3.png)'
  prefs: []
  type: TYPE_IMG
- en: To cumulate this, we can add `cumulative` to the `--dirstat=lines,10` command,
    and this will cumulate the changes and calculate a percentage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Be aware that the percentage can go beyond 100 due to the way it is calculated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the output is slightly different from what we have seen earlier.
    By using `git log --dirstat`, you can get some information about what goes on
    in the repository. Obviously, you can also do this for all the commits between
    two releases or two commit hashes. Let''s try this, but instead of using `git
    log`, we will be using `git diff`, as Git will show the accumulated `diff` between
    the two releases, and `git log` will show `dirstat` for each commit between the
    releases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So, between the `origin/stable-3.1` and `origin/stable-3.2` branches, we can
    see which directories have the highest percentage of changes. We can then dig
    a little deeper using `--stat` or `--numstat` for the directory, and again use
    `git diff`. We will also use `--relative="org.eclipse.jgit.test/tst/org/eclipse/"`,
    which will show the relative path of the files from `org.eclipse.jgit.test/tst/org/eclipse/`.
    This will look better on the console. Feel free to try this without using the
    following option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first number is the number of lines added, and the second number is the
    lines removed from the files between the two branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used `git log`, `git diff`, and `git shortlog` to find information about
    the repository, but there are so many options for those commands on how to find
    bottlenecks in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to find the files with the most commits, and these are not necessarily
    the files with the most line additions or deletions, we can use `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `git log` between the `origin/stable-3.1` and `origin/stable-3.2`
    branches and list all the files changed in each commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we just need to sort and accumulate the result with some Bash tools as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we are just executing the command without the use of the Bash tools.
    You can see from the extensive output that you only see file names and nothing
    else. This is due to the options used. The `--format=format:` option tells Git
    to not display any commit-message-related information, and `--name-only` tells
    Git to list the files for each commit. Now, all we have to do is count them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a list of the top ten files between the two releases, but before
    we proceed further, let''s just go through what we did. We got the list of files,
    and we used `sed ''/^$/d''` to remove empty lines from the output. After this,
    we used `sort` to sort the list of files. Then, we used `uniq -c`, which counts
    the occurrences of each item in the files and adds the number from the output.
    Finally, we sorted in reverse order using `sort -r` and displayed only the top
    ten results using `head 10`. To proceed from here, we should list all the commits
    between the branches that are changing the top file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By adding the file to the end of the `git log` command, we will see the commits
    between the two branches. Now, all we have to do is to grep commits that have
    the bug, so we can tell our manager the number of bugs we fixed in this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grepping the commit messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to list and sort files that we make frequent changes to and
    vice versa, but we are also interested in finding out the bugs that we are fixing,
    the features that we are implementing, and perhaps who is signing the code. All
    this information is usually available in the commit message. Some companies have
    a policy that you need to have a referral to a bug, a feature, or some other reference
    in the commit message. By having this information in the commit message, it is
    a lot easier to produce a nice release note as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will mostly be grepping the Git database in these examples, we really
    don't need to check something out or be at a specific commit for this example.
    So, if you are still lurking around in the `chapter6` folder, we can continue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how many commits in the repository are referring to a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to know the pattern for bugs referred to in the commit
    messages. I did this by looking in the commits, and the pattern for `jgit` is
    to use `Bug: 6 digits`; so, to find all of these commits, we use the `--grep`
    option for `git log`, and we can grep for `"[Bb][Uu][gG]: [0-9]+"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a lot of commits as output, but you should notice that all the
    commits have a referral to a bug ID. So what was the grep doing? The `^[Bb][Uu][gG]:`
    part matches any combination of lowercase and uppercase bugs. The `^` character
    means from the beginning of the line. The `:` character is matching `:`. Then,
    we have `[0-9]+`, which will match any number between zero and nine, and the `+`
    part means one or more occurrences. But enough with regular expressions for grep.
    We have a lot of output (which is valuable), but for now, we just want to count
    the commits. We can do this by piping it to `wc -l` (word count `-l` is to count
    the lines):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before piping it to `wc`, remember to use `--oneline` to limit the output to
    one line for each commit. As you can see, when I was writing this, `jgit` has
    reference to `366` bugs that have all been fixed and released into the repository.
    If you are used to using regular expressions in another scripting or programming
    language, you will see that using `--grep` does not support everything. You can
    enable a more extensive regular expression support using the `--extended-regexp`
    option for `git log`; however, the pattern still has to be used with `--grep` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used it in the preceding example, and you can see that we are getting
    the same commits. I have used a slightly different expression, and have now added
    `{6}` instead of `+`; the `{6}` searches for six occurrences of the associated
    pattern. In our case, it is six digits as it is next to the `[0-9]` pattern. We
    can verify by counting the lines or commits again with `wc -l` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the same number. To shrink the regular expression even more, we can
    use `--regexp-ignore-case`, which will ignore the case for the pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the exact same output, and we no longer have `[bB][uU][Gg]` but
    just `bug`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you know how to grep the commit messages for information, and you can grep
    for anything in the commit message and list all the commits where the regular
    expression matches.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While extracting information from Git, one of the natural things to do is to
    generate release notes. To generate a release note, you need all the valid information
    from the repository between this release and the previous release.
  prefs: []
  type: TYPE_NORMAL
- en: We can utilize some of the methods we have used earlier to generate the data
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by listing the commits between two tags, `v2.3.1.201302201838-r` and
    `v3.0.0.201305080800-m7`, and then we build on that information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `git log` with `v3.0.0.201305080800-m7.. v3.0.0.201305080800-m7`,
    we will get the commits between the tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have a lot of commits between these two tags, let''s count them using
    `wc -l`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There are `211` commits between the tags. Now, we will show the most modified
    files between the releases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This information is useful as we now have an overview of where the majority
    of the changes are. Then, we can find the commit that refers to bugs so we can
    list the bug IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, what we have here is a nice list of the bugs being fixed and their corresponding
    commit hashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are using some Bash tools to get this list of fixed bugs. I will briefly
    explain what they are doing in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `xargs -n1 git log -1` part will execute `git log -1` on each commit coming
    from the first `git log` command, `git log --format=format:%h --regexp-ignore-case
    --extended-regexp --grep="bug: [0-9]{6}" v2.3.1.201302201838-r..v3.0.0.201305080800-m7`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `grep --ignore-case -E "commit [0-9a-f]{40}|bug:"` part will ignore the
    case in the regular expression and `-E` will enable an extended regular expression.
    You might see that a lot of these options for the tool grep are the same options
    we have for git log. The regular expression is matching commit and 40 characters
    with the `[0-9a-f]` range or bug. The `|` character means or. Remember we are
    in the output from `git log -1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this information we have extracted is the basis for a good, solid release
    note, with information on what has changed from one release to another.
  prefs: []
  type: TYPE_NORMAL
- en: The next natural step would be to look into the bug tracking system and also
    list the titles for each error being fixed in the commits. However, that is not
    something we will go through here as it all depends on the system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Finding what has been achieved in the repository in the last period
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's useful to be able to extract what has been achieved in a specific
    range of time. Let's see how `git log` numerous arguments can help with this task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we want to know everything that has been done in the last 30 days
    in the `jgit` repository that we have been analyzing so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `--all` in order to see the commits in all the branches and not
    only the current one. We also use `--since` as illustrated previously during this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s only show the commits by `David Pursehouse`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We used `--author` to specify the desired commit author and `--oneline` to condense
    the output to a more manageable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re looking for your own commits you can pass your name to `--author`,
    but if you are writing a script or an alias and you want it to be portable, you
    can, at least on Linux and macOS, use a subshell to retrieve the information automatically:
    `--author=$(git config user.name)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like some merge commits are present. These are not really useful to
    describe the activity of the last month, so let''s get rid of those with `--no-merges`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We finally have the information we need. This simple example also shows the
    importance of good commit messages as they will make the history managed by Git
    so much more useful and valuable!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we didn't have to jump through hoops to get the result we needed;
    we simply used the power of the log command and its options. As a matter of fact, `git
    log` has almost 200 different arguments, and its help document, reachable with
    `git log --help`, is composed of more than 11,000 words! Now you know what to
    do during your next long flight without internet access!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What about across repositories? The previous approach can, of course, be scaled
    with some scripting in order to repeat the operation on a list of repositories,
    but a better and simpler option is available as a third-party application that
    leverages the same `git log` capabilities we have been exploring thus far: `git-standup`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can easily be installed with a `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Its source code is available on `https://github.com/kamranahmedse/git-standup`
    and it features several options that will make daily or weekly team meetings much
    easier to prepare.
  prefs: []
  type: TYPE_NORMAL
- en: '`git-standup` is also able to operate on a single repository, and when applied
    to the previous example, its output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
