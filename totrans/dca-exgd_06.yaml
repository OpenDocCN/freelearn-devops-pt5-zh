- en: Deploying Multi-Container Applications
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the Docker Compose tool, a key component
    of any Docker environment. Using Docker Compose, we can manage multi-container
    applications, and all the actions and functionalities we usually use to manage
    a container-based application will be made available in multi-container environments
    by Docker Compose. We are able to build all the required images for a project
    at once. There is no need to build, pull/push, and execute containers one by one.
    We can declare all the pieces, along with their interconnections, storage, environments,
    and so on, in a single file. We are also able to debug multi-container applications
    from a single endpoint, which is vital when you have many separate elements running
    on production environments.
  prefs: []
  type: TYPE_NORMAL
- en: But this is not just a tool. Docker Compose declares a new type of file, `docker-compose.yaml`.
    This file provides all the requirements for multi-container applications and can
    be used with other Docker tools. The introduction of this kind of file is very
    important because it was the basis for Swarm-orchestrated deployments and the
    newest CNAB-based applications. We will not cover **Cloud-Native Application Bundles**
    (**CNABs**) in this book, but if you are interested, take a look at [https://cnab.io.](https://cnab.io.)
    Docker has its own CNAB implementation, but it is in the experimental stage at
    the time of writing this book and is not part of the DCA exam.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will review Docker Compose. We will learn how to install
    this tool with different methods, along with its keys and how we should use them.
    We will discover some of the actions provided by the tool and their use cases.
    We will finish with some tips that will help us to use `docker-compose` with variables.
    This allows us to provision dynamic content for different environments using the
    same deployment files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the docker-compose.yaml file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using docker-compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing images with docker-compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating your desktop and CI/CD with docker-compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Dockerized multi-container applications.
    We'll provide some labs at the end of this chapter that will help you understand
    and learn the concepts covered. These labs can be run on your laptop or PC using
    the provided Vagrant standalone environment or any already deployed Docker host
    of your own. Check the additional information in this book's GitHub code repository
    at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '"[https://bit.ly/3hz0IB0](https://bit.ly/3hz0IB0)"'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before deep-diving into the Docker Compose tool, let''s learn about the differences
    between multi-container applications and multi-service applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-container applications are applications based on multiple containers.
    These containers will run together on the same host. Therefore, we can deploy
    multi-container applications on our laptop or on any other Docker daemon. All
    application components will run together on a host. As a result, possible network
    performance issues will be mitigated because all the pieces will run together.
    Take into account that this deployment will not provide high availability if the
    host goes down. We will be able to configure the automatic restart of all components,
    but that is not enough for production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-service applications are applications based on multiple services. These
    applications will run using Swarm orchestration and containers will run distributed
    on different hosts. We will learn about Docker Swarm orchestration in [Chapter
    8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml), *Orchestrating with Docker Swarm*.
    But you should understand that services are the smallest unit of scheduling on
    Docker Swarm environments. We will not schedule containers; we will schedule a
    service, based on the execution of a number of tasks. Those tasks are associated
    with containers; in fact, one container per task. Therefore, a service is represented
    by a number of tasks (known as replicas) that run containers. We schedule a service
    in Docker Swarm, setting the number of replicas required to be healthy. Docker
    Swarm will take care of the container's status. As we mentioned previously, services
    will run distributed on different hosts. Multi-service application components
    will usually run distributed cluster-wide. Components' interconnections will rely
    on internal and external networking, while Swarm provides out-of-the-box high
    availability based on resilience for all services' tasks. Keep these features
    in mind. We will learn about the great features behind Swarm and Kubernetes orchestrations
    in the *Container orchestration* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, we deploy multi-container applications on one node while multi-service
    applications run distributed in different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose` does not come with Docker packages when you install it. It
    is a different product. On Docker Desktop for macOS and Windows, Docker Compose
    is included and ready to use.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we have to learn about Docker Compose is that it is a Python-based
    application. Therefore, we can install it as we would any other Python module
    or download it as a binary file. We can also run `docker-compose` within a container.
    We can find easy instructions at [https://docs.docker.com/compose/install](https://docs.docker.com/compose/install).
    Notice that at the time of writing, the latest `docker-compose` release was 1.24.1\.
    We will use this version for all of the following installation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Installing docker-compose as a Python module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installation using `pip` (the Python module installer) is easy on Linux systems.
    We will review this method and we will also download the Docker Compose binary.
    First, we need to have `pip` installed on our system. It is a package that's available
    on almost all Linux systems and, consequently, whether it's already installed
    or not will depend on the Linux flavor used (the package name can be `py-pip`,
    `python3-pip`, or `pip-python`; it really depends on your operating system and
    the Python version used).
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover this package installation and will assume you have `pip` installed
    on your system. We will install the `docker-compose` module as the root user to
    allow all host users to use it.
  prefs: []
  type: TYPE_NORMAL
- en: There is a version of `pip` for Python 2.x and another for Python 3.x. Remember
    that Python 2.x is obsolete nowadays, so it might be time to move to Python 3.x.
    We will cover Python 3 installation only, for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `sudo` as root with `-H` to use our logged-in user''s home path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After execution, we will have `docker-compose` installed at `/usr/local/bin/docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing docker-compose using downloaded binaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we just need `curl` or `wget` to download the defined version binaries
    from this project''s GitHub page ([https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)).
    Make sure to choose the right binary and version for your architecture processor
    and system. We will review the installation for the CentOS 7 Linux system, which
    is used for all our labs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can also use a container to execute `docker-compose`, as we will learn in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Executing docker-compose using a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is quite interesting because, as we have learned, executing applications
    as containers just requires a Docker daemon running on our system. It is a great
    way to execute applications! In this case, `run.sh` is a script that will prepare
    all the required volumes and parameters (`curl -L` will follow redirections and
    the `-o` argument will allow us to choose the destination filename):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Docker Compose can also be installed on Windows nodes, as we will learn in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing docker-compose on Windows servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Windows servers, we will use an elevated PowerShell (that is, run it as administrator).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since GitHub now requires TLS1.2, it is required to run the following on our
    administrator PowerShell before executing the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in the administrator''s PowerShell, we need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn about Docker Compose files.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the docker-compose.yaml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose introduces the concept of multi-container applications using
    an all-in-one application components' definition file. This file is known as `docker-compose.yaml`.
    Usually, we will manage a `docker-compose.yaml` file. Notice that this is a YAML
    file; therefore, indentation is fundamental. The file will contain all of the
    application components and their properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a simple `docker-compose.yaml` file looks (we can use either the
    `.yaml` or `.yml` extension for YAML files):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `docker-compose.yaml` file will contain definitions for all Docker-based
    application components (services, networks, and volumes). In this file, we first
    declare the file definition version. This definition manages how Docker Compose
    should interpret some of the directives written. We will use version 3.x for our
    file definition because it is the most up to date and is recommended at the time
    of writing. There are a few differences between versions, although `docker-compose`
    provides backward compatibility, so you should check the Docker documentation
    for more information. It is important to know that keys and definition structures
    may vary between versions, and you should use specific versions with older Docker
    engines. We will use version 3.7 (the current version at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn a bit about the file contents.
  prefs: []
  type: TYPE_NORMAL
- en: We are using environment variables to provide credentials and access to some
    services. This is just for demo purposes – never use environment variables for
    your passwords, credentials, or connection strings. In Docker Swarm, we use secrets
    and configuration objects. In Docker Compose, we do not have this kind of object,
    so it's preferred to use external configuration tools or secure key-value stores
    to manage these values.
  prefs: []
  type: TYPE_NORMAL
- en: We have a section for `services` and another one for `networks`. We can also
    have a `volumes` section. The `volumes` and `networks` sections will define their
    properties for the application. In these sections, we will declare special features
    and the drivers used for them. In the example file, we have declared a special
    subnet to use on the `simplestlab` network with the default bridge driver. This
    is the network that will be created and used for all the components, as we can
    see in all of our service definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In Docker Swarm, we can also define `Configs` and `Secrets`, which are cluster
    objects. We will declare objects in one section of the file and then we will use
    these objects inside each service definition.
  prefs: []
  type: TYPE_NORMAL
- en: Each service represents one component. Let's take a closer look at the definitions
    of the `app` service, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Each service definition has some key configurations to explain how this application
    component will run. In the `app` service, we have a `build` definition, which
    indicates how this component will be created. The value of the `build` key indicates
    the context path for building an image for these components (the `simplestapp`
    directory). Therefore, we can build this component with this `docker-compose.yaml`
    file and the `simplestapp` directory content. We've learned that to build an image,
    we need a Dockerfile; consequently, a Dockerfile is mandatory inside the `simplestapp`
    directory. All the files required to compile the `myregistry/simplest-lab:simplestapp`
    image should be in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about multi-container applications with Docker Compose, services
    definitions are different from Swarm Services, which are managed by Swarm orchestration.
    In non-Swam environments, we refer to services as application components.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, which contains the `image` key, defines the name of the image.
    If the image does not exist in your host, it will be built with this name. If
    we do not have a `build` definition, the Docker daemon will try to download the
    defined image from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: The next key defines a list of variables and their values to be used as environment
    variables during container execution. We can override the image-defined `ENVIRONMENT`,
    `CMD`, `ENTRYPOINT`, and `VOLUME` values, among others, as we usually do within
    containers. We will take a look at the Docker Compose definitions later, but keep
    in mind that almost every option we use on the `docker container run` or `docker
    container create` actions is available as a key on `docker-compose.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the networks to be used in this component. We also defined an
    alias name to use in this network. This component will be known as `app`, which
    is its service name, and also by its defined alias, which is `simplestapp`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that Docker Compose allows us to define an order of
    execution, as we can see in the last few lines. We used the `depends_on` key to
    wait until all the components in the list were available (that is, all the containers
    were marked as healthy).
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have reviewed the `services` section of the preceding code file.
    In this example, we also have `volumes` and `networks` sections.
  prefs: []
  type: TYPE_NORMAL
- en: In the `volumes` section, we have the simplest definition. It is empty and just
    defines a volume with the default parameters (the local driver). In the `services`
    section, we define where and how these volumes should be attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the basics, we can take a look at some of the most used key
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Definitions** |'
  prefs: []
  type: TYPE_TB
- en: '| `build` | This key will define the options used to build the application
    images. These are some of the most used options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context`: This option defines the path to the build context, the directory
    that contains the Dockerfile, and all the other files required for the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dockerfile`: This defines an alternative Dockerfile name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args`: We can set Dockerfile arguments here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`labels`: This option allows us to set image labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `image` | This is the name of the image to be used. If the image does not
    exist, it will be pulled from the registry. If the image must be built, it will
    use this value for its name. |'
  prefs: []
  type: TYPE_TB
- en: '| `environment` | We are able to set environment variables within containers.
    This will overwrite any image-defined values. We can also use `env_file` to define
    a file with many values. |'
  prefs: []
  type: TYPE_TB
- en: '| `command` | This will set or overwrite the image''s `command` definition.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `entrypoint` | This will set or overwrite the image''s `entrypoint` definition.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ports` | These are the ports to be exposed by the services to be reachable
    at the host level. |'
  prefs: []
  type: TYPE_TB
- en: '| `expose` | This option defines which service ports will be available for
    other services. |'
  prefs: []
  type: TYPE_TB
- en: '| `privileged``cap_add/cap_drop``read_only` | These options will set the same
    features we learned about when we talked about container execution in [Chapter
    3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml), *Running Docker Containers*. |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | This will set or overwrite the image''s `user` definition. |'
  prefs: []
  type: TYPE_TB
- en: '| `labels` | This will set or overwrite image labels. |'
  prefs: []
  type: TYPE_TB
- en: '| `restart` | With `restart`, we can set how associated containers should be
    managed. If they die, should Docker restart them or leave them stopped? Remember
    the options defined for our containers – we will use the same values here. |'
  prefs: []
  type: TYPE_TB
- en: '| `container_name` | We are able to set the container name using this variable.
    If not defined, the container name will be generated using the service project
    name as a prefix, followed by the service name and the instance number, starting
    from `1`. Take care with this parameter; as you''ve already learned, there can
    only be one container with a defined name per host. |'
  prefs: []
  type: TYPE_TB
- en: '| `hostname``domainname` | These options will allow us to change the container
    hostname and its domain name. Under the `network` definition, we are able to add
    as many DNS aliases as required. |'
  prefs: []
  type: TYPE_TB
- en: '| `extra_hosts` | With this option, we can add external hosts to be discovered
    via internal DNS. This will help us reach external services as if they were running
    within containers. |'
  prefs: []
  type: TYPE_TB
- en: '| `depends_on` | This key allows us to set components'' dependencies. It is
    deprecated now in version `3` but is included here to explain to you that it did
    not provide real dependency. This option will just control the boot order. |'
  prefs: []
  type: TYPE_TB
- en: '| `networks` | We can set which network drivers to use, their options and subnet
    ranges, and how they will be accessible (internal and/or attachable). Let''s review
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have defined `mynet` as a bridge network with a defined
    subnet for all our containers. We can use this defined network on each service
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `volumes` | Volumes are defined in the `volumes` section. We will be able
    to set their drivers and special options. The following is an example of a simple
    local definition that we can use in the `services` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `tmpfs` | We can use an in-memory filesystem with `tmpfs`. This option is
    very useful for bypassing the overlay filesystem to improve I/O performance or
    for security reasons. The in-memory filesystem will disappear when the container
    dies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `healthcheck` | This will set or overwrite the image''s `healthcheck` definitions.
    |'
  prefs: []
  type: TYPE_TB
- en: These keys are the most commonly used ones. Consult the Docker Compose documentation
    for more information, which is available on the Docker website at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  prefs: []
  type: TYPE_NORMAL
- en: There are many keys that are only allowed on Docker Swarm environments. We didn't
    include them in the preceding information table because the Swarm options will
    be shown in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml), *Orchestration
    Using Docker Swarm*. Defining container resource limits in `docker-compose.yaml`
    files is only allowed either using Docker Swarm mode or using Docker Compose version
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created our `docker-compose.yaml` file, we will be able to use
    the Docker Compose command-line definitions written in this file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker Compose command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We installed the `docker-compose` binary in the previous section, which means
    we can now review the actions available to us. `docker-compose` will provide most
    of the actions available for Docker because we will execute them on multiple containers
    at once. Let''s review the available `docker-compose` actions in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| `build` | As expected, this action will build or rebuild all `docker-compose.yaml`
    file components, or just the selected ones. This action will look for any `build`
    keys in our `docker-compose.yaml` file and launch a build or rebuild. If we set
    a project name using `--project`, all images will be created as `<project_name>_<service_name>`
    if no image name is defined. If so, this is the name that will be used if we push
    them to a registry. |'
  prefs: []
  type: TYPE_TB
- en: '| `pull`/`push` | We will be able to push or pull all images at once because
    we manage all the application components with `docker-compose`. |'
  prefs: []
  type: TYPE_TB
- en: '| `images` | This action will list all application images. |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | Remember that we can create containers. In this case, we will
    create all containers required by the application, but they will not be launched
    until a `start` action is executed. |'
  prefs: []
  type: TYPE_TB
- en: '| `rm` | This action will remove all stopped containers. Remember to use the
    project name, or leave it empty to use the current directory as the application
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `up` (`-d` or `--detach`) | We will create and start all components with
    this simple action. All the components will run at once. We will use `--detach`
    to run the application in the background, as we learned with containers. |'
  prefs: []
  type: TYPE_TB
- en: '| `down` | To remove all application components, we will use the `down` action.
    This will end all application containers or just the specified ones. Take care
    as externally defined resources will not be deleted and must be removed manually.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `start/stop/restart` | These options will allow us to manage components,
    applying either to all components at once or only those specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | With this option, we can execute one component to run a specified
    command, such as to initialize a database or create a required file. |'
  prefs: []
  type: TYPE_TB
- en: '| `pause`/`unpause` | As we learned with containers, we can pause and unpause
    application components. |'
  prefs: []
  type: TYPE_TB
- en: '| `ps` | `docker-compose` will show all application containers (processes)
    and their ports. |'
  prefs: []
  type: TYPE_TB
- en: '| `top` | This option will show the processes running on each container deployed
    for the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `exec` | We will be able to run a process within any application container
    namespace. Remember what we learned in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*. |'
  prefs: []
  type: TYPE_TB
- en: '| `logs` | It is very useful to be able to retrieve all application container''
    logs using a single command. We can use the `logs` action to retrieve all application
    logs at once. Logs will appear together, along with their service names, to help
    us identify each component. |'
  prefs: []
  type: TYPE_TB
- en: '| `config` | We can verify a Docker Compose definition using the `config` action.
    We can also list the defined services using `services` as the argument. |'
  prefs: []
  type: TYPE_TB
- en: With this information, we can quickly see how the usual container workflow can
    be achieved in multi-container environments with Docker Compose, which gives us
    a new command-line interface to build, share, and run all our application components
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define external resources such as `volume` or `networks`. We will use
    the `external: true` option in these cases and you''ll have to create these resources
    manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Each application that's deployed using `docker-compose` will have its own project
    definition. Each project will run in isolation alongside others in the same host.
    By default, `docker-compose` will use the current directory name as the project's
    name. We can override this behavior using `--project-name` or `-p` to set a more
    descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*, we learned that object names are unique (we can
    have objects with many names, but each is unique, and we cannot have repeated
    names); therefore, `docker-compose` adds the project's name as a prefix to each
    created object. This way, we identify all application components and ensure that
    they have unique names. Of course, we can use the same `docker-compose` file to
    deploy the same application twice, but we should choose a different project name
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `docker-compose.yaml` file to launch the same application multiple
    times, but we cannot share unique resources such as ports, volumes, and IP addresses
    between volumes. Sharing a volume between components depends on application behavior,
    but IP addresses or ports will be unique to a given Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review the complete application deployment workflow with the previous
    `docker-compose.yaml` file (seen in the *Understanding the docker-compose file*
    section).
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to build the application images. You can download all the application
    code from this book's GitHub repository at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git.](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clone the repository to get all the source code directories and configuration
    files. Your output may vary from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a directory for the `simplest-lab` project with a `docker-compose.yaml`
    file and different directories for each application component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In each project directory, there is a Dockerfile we can use to build that specific
    component. So, let's build all the components at once.
  prefs: []
  type: TYPE_NORMAL
- en: We have the same options for removing the intermediate containers (used for
    building and disallowing image caching) as we had with the `docker image build`
    command. We will use `--force-rm` and `--no-cache`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the defined `docker-compose.yaml` file is valid, we can use
    `docker-compose config --quiet`. If there is an issue, it will be reported. We
    can also list the names of the services or volumes that have been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will use these service name definitions later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will execute `docker-compose build` to build all the component images defined
    in our `docker-compose.yaml` file. This command will take some time because we
    are not just building an image, but all the images required. The following output
    is truncated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After a few minutes (or seconds, depending on your internet connection and processor
    speed), all three images will be created. As we have not set a project name, `docker-compose`
    has created one for you. As we mentioned previously, by default, all the components
    will be created with the directory name prefixed. In this case, we have an image
    key on our `docker-compose.yaml` file, so that image naming syntax will be used
    instead of a local directory reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we have used a dummy registry name (`myregistry`). This means that
    we cannot push images to this dummy registry, but it is important to understand
    the logic behind image names. If we list current images on our Docker daemon,
    we should have all the images created for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our images, we can share them. We can now execute the `docker-compose
    push` command to push them to `myregistry` (in our example file). This will upload
    the images one by one with defined tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to run all the application components together using `docker-compose
    up`. To launch it in the background, we will use the `--detach` option. If we
    do not use this option, we will be attached to all our container''s standard and
    error outputs. We learned how to attach to container output in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*. Remember that this behavior is expected on `docker
    container run` without the `--detach` or `-d` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this line, we have just started our application. It is important to understand
    that `docker-compose up` does more than merely execute all the components. In
    this case, we built our components first, but the `docker-compose up` instruction
    will verify that component images are present on the Docker host. If not, it will
    build or pull them. If the images are not present, they should be downloaded,
    and that is what the Docker daemon will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application should be running. Let''s verify the execution of all components.
    We will use `docker-compose ps` to obtain the application component status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the application component names. They are all created with the
    `simplest-lab` prefix, followed by `_` and the name used in the service definition.
    This is what we expected because we have not defined a project name. The directory
    name was used as the project name by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that component names end with `_`, followed by a number (in
    this case, `1`). This indicates the number of replicas we have for this component.
    We use more than one replica for some application components. Keep in mind that
    Docker Compose does not know anything about our application logic. Therefore,
    it is up to us to code this component to make it scalable. In our example, we
    have a three-layer application with three components: a simple load balancer,
    `lb`, an application''s backend, `app`, and a database component, `db`. We will
    not be able to scale up our database component because this will corrupt the database
    data. No more than one `postgres` process can use a specific set of data files,
    and this applies to our case. On the other hand, our `app` sample application
    component is prepared to run multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our application environment. By reviewing the output
    of `docker-compose ps`, we can see that only one component is exposing its service.
    We have only published the `lb`component. This is our application frontend (in
    fact, it is a load balancer component that will route traffic to different `app`
    component backends). If we open a web browser on `http://0.0.0.0:8080`, we will
    have a web application similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dade774-d569-4a90-ace9-8413d2c3bd7a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the application is already deployed. We can review the component
    logs using the service name with the `docker-compose logs` action. If we do not
    add a service name, we will be reviewing the logs of all the containers deployed
    with this `docker-compose.yaml` file. This is very useful because we will be able
    to review all their outputs from a single endpoint. Each component's log will
    appear in a different color to help us distinguish between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to review the database component log, we will use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is important to notice that the service name is the name defined in our `docker-compose.yaml`
    file. It is not the name of the service running.
  prefs: []
  type: TYPE_NORMAL
- en: All `docker-compose` commands need a `docker-compose.yaml` file (or any other
    filename using the `--file` or `-f` options) and a project name (defined using
    the `--project` or `-p` options, or the current directory by default). These two
    parameters define the instances where all the `docker-compose` commands will be
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with containers in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*, we can run a new process within the container''s
    process namespaces using `docker-compose exec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it allocates a Terminal by default. Therefore, it is not necessary
    to use the `-t` and `-i` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `docker-compose top`, we will obtain the consumption of each process
    on each container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review some of the objects created by this multi-container deployment.
    We have a new network, with the name defined following the format we learned about
    previously; that is, `<project or directory name>_ <defined_network_name>`. We
    have not specified a special network type, so, by default, it is a bridge network,
    as expected. The output may vary in your environment, but the name for the newly
    deployed network will exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember that all custom bridge networks manage their own internal DNS resolution.
    As a result, all services (application components) deployed on the same network
    can be reached using their service names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same occurs with our defined volumes. If we list our local volume, we will
    get a new volume following the same naming convention. The output may vary in
    your environment, but the name for the newly deployed volume will exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can stop and start (or restart) any service defined in the `docker-compose.yaml`
    file using their names. The following action will restart all the instances of
    a defined service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to the concept of instances. We can have more than one instance
    of a defined process for a service. This is the reason we have numbered all our
    instances. As we mentioned previously, the ability of a process to be scaled up
    or down is not defined in Docker. It is related to your application logic. In
    this example, we can scale up the number of instances of the `app` component.
    We can use `docker-compose scale` to change the number of instances (containers)
    for a defined application component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `scale` action is deprecated, so nowadays, we should use `docker-compose
    up --scale <service=number_of_instances>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we now have five instances of the `app` application component.
    All the instances'' IP addresses are added to the internal DNS resolution. Therefore,
    we can resolve the service name to all the instances'' IP addresses in a round-robin
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to the application GUI at `http://localhost:8080/`, we''ll notice
    that the chart has changed because the requests are now distributed across five
    different backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6b7f950-71fd-4472-94ee-529dc36377d4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chart, we can see that we now have five different IP addresses and that
    requests are distributed between them. Because we have been running the application
    for a long time (and automated requests are executed during this period), we have
    more requests for the first IP address (the first instance launched).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove previous data from the database using the Reset App Databutton.
    Let''s click this button and review the requests count. You can either wait for
    more requests (a new request is made every 5 seconds) or simply click the Make
    Requestbutton a few times. You should now have something similar to the following
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d394fc35-5994-4d32-ba6c-128d21250caf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chart shows the request distribution of the five defined instances of
    the `app` component. Now, let''s scale down to three instances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can review the `app` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The chart will change again and only three backends will receive requests (there
    are only three running). Once again, we will use the Reset App Databutton and
    get a chart similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9554c1c5-b383-4c91-946f-69df30db4cb9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a quick look at the running containers associated with the deployed `docker-compose.yaml`
    application file. In this case, we are using a filter to obtain all the containers
    with names starting with the `simplest` pattern. We formatted the result to obtain
    only their names and labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98848394-2b35-45ff-a65a-605e71af5009.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that `docker-compose` has added labels for each application component,
    indicating the name of the project, the container name, and the associated service
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily stop or kill a single component or all of them at once. We can
    also remove all the components using the `down` or `rm` options. Usually, we use
    `docker-compose down` because it is easier to remember. We can also define a timeout
    for components to stop using `stop_grace_period`, which defaults to 10 seconds
    (review the `docker-compose` file reference for available options at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)).
    Using `docker-compose down`, components will be removed once they are stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at all the application-related objects. Here, we can see
    that `network` was removed but `volume` persists. This is because Docker does
    not know what to do with the volume. Are we going to use it later? Consequently,
    it is preferred not to delete the volume unless we use the `docker-compose down
    --volumes` (or `-v`) option to remove all the volumes associated with the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned about all of the main `docker-compose` actions
    associated with the usual Docker workflow. In the next section, we will review
    some specific options for building images.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing images with docker-compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building applications using `docker-compose` is very useful because we can use
    it for creating all the images in Docker Swarm or Kubernetes environments. We
    just need a `docker-compose` file definition and the application components' code.
  prefs: []
  type: TYPE_NORMAL
- en: We have been using a static `docker-compose` file definition, but in many cases,
    we will use some variables to fulfill their values for specific needs. In fact,
    we could use variables in Dockerfiles as well, to complete the dynamic configurations
    at all levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce some variables to our application''s `docker-compose.yaml`
    file (we do this to allow different behaviors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You will find this file in [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
    as `docker-compose.dev.yaml`, along with all the other code files that were used
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll review the definition configuration using the `docker-compose
    config` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These warnings and errors indicate that the following variables must be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dockerhubid`: By default, this will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LB_PORT`: This must be set to a port number because it is the one we will
    publish to consume the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to have values for these variables. We can also use variables on Dockerfiles
    to add even more granularity. However, this is not the point here and we will
    not deep dive into Dockerfile variable usage again. For the Docker Certified Associate
    exam, it is important to know how to use variables to provide values to `docker-compose`
    deployments. We can use dynamic configurations with variables to deploy different
    projects using just one `docker-compose.yaml` file. This is very useful for building
    debugging images with developer tools, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the `LB_PORT` and `dockerhubid` variables and review our project
    configuration once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The other variables have been left empty. We defined different configurations
    to provide some features for production, for example, using specific credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we review the new build image, we will notice that it now has a new label
    and was created using `alpine:3.6` instead of the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have learned how we can prepare different environments using
    variables. With variables, we can use one `docker-compose.yaml` file for any stage
    in our environment. We have learned how to prepare a deployment for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development, using images with compilers or debugging utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests, thereby adding tools to verify connectivity with third-party applications,
    for example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-production or integration, with libraries to execute load and performance
    tests before passing the application to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The production stage, with only well-tested application components within images
    being tagged as `release`, for example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose allows us to keep track of all configurations required for each
    stage with a YAML file. This file will be stored in our infrastructure as a code
    repository. Versioning will help us keep control of deployed applications in production.
  prefs: []
  type: TYPE_NORMAL
- en: Automating your desktop and CI/CD with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose allows us to easily develop on our own laptops. DevOps teams
    will provide complete application stack files, `docker-compose.yaml` files, along
    with all the required components and configurations. Developers do not have to
    learn how all the components work. They can focus on the component they are developing
    because the rest of the components will run automatically thanks to `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Docker Compose on a **Continuous Integration**/**C****ontinuous Deployment**
    (**CI**/**CD**) pipeline, building all the components at once.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose helps us build all the application components at the development
    stage, but we can also use this tool to run all the components together. CI/CD
    orchestrators will execute `docker-compose` files at different stages.
  prefs: []
  type: TYPE_NORMAL
- en: With the described steps and variables, it is easy to imagine how to implement
    a pipeline starting at the development stages and ending with the application
    in production. We would use different image tags in production, which are created
    by applying different variable values between environments.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that `docker-compose.yaml` files are key
    in **Infrastructure-as-Code** (**IaC**) environments. We need to store them and
    use version control systems. These files describe what application components
    will run and what resources they will use. We can add variables for an application's
    published ports, for example, to avoid port conflicts if we deploy a couple of
    applications using the same `docker-compose` files in the same host. We can also
    use the same `docker-compose` file for development and testing, as well as deploying
    applications to these environments. To avoid environment conflicts, we can use
    variables to define an application's component endpoints, such as databases or
    any connection chain that should be different between environments.
  prefs: []
  type: TYPE_NORMAL
- en: Developers will use these files to launch the required application components
    on their laptops while they are developing new features or fixing code errors.
    They can focus on coding because they do not need to create complex infrastructures
    to test what they are coding. In fact, they do not need development infrastructures
    at all, as they can use their own computers.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue this chapter by reviewing some labs to help us understand and
    build on the concepts we've learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter labs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will deploy a simple lab to review the different steps described during this
    chapter. First, we will build the images required and will continue executing
    and scaling up components. We will use a CentOS Linux host with Docker Engine
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy `environments/standalone-environment`from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment`folder to start your virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `standalone-environment`, wait until it is running. We can
    check the node''s status using `vagrant status`. Connect to your lab node using
    `vagrant ssh standalone`. Now, `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now connect to the `standalone` node using `vagrant ssh standalone`.
    This process may vary if you deployed the `standalone` virtual node previously
    and you started it using `vagrant up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are reusing your `standalone-environment` instance, this means that
    Docker Engine is already installed. If you started a new instance, please execute
    the `/vagrant/install_requirements.sh` script to get access to all the required
    tools (Docker Engine and `docker-compose`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are ready to start the labs.
  prefs: []
  type: TYPE_NORMAL
- en: Colors application lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start these labs by deploying a simple application that will run a small
    Python process. This process is a web server that was developed using Flask that
    will show a colored page (a random color, by default) with some information about
    the container name, its IP address, and the application version.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the files required for this lab can be found in the `Docker-Certified-Associate-DCA-Exam-Guide/chapter5`
    folder in this book''s GitHub repository at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by cloning our repository, navigating to our folder, and listing
    the files present inside the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly review the `docker-compose.random.yaml`file''s content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is very simple. We defined a `random`service using the code contained in
    the `app` directory. We will expose container port `3000` to a random host one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now build images using `lab1`as the project name. Notice that we defined
    the `lab` network. The Docker daemon will create a `lab1_random`image and the
    `lab1_lab`network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we execute our multi-container application (in this case, we just have
    one service definition):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the `docker-compose` project''s `lab1`execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the application's port, `3000`, is linked to the Docker host port
    `32780` (using NAT).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the application via that random port; that is, `32780`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a web browser to access the running application. We can also use
    `curl` because the application is prepared to show a text response using the `/text`URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/570ea77a-ec62-4eda-9555-03b83433f418.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A random color will be used. In this case, we get a blue page. It may vary in
    your environment because a random color will be chosen if the `COLOR` variable
    is not set.
  prefs: []
  type: TYPE_NORMAL
- en: If you deployed the `random color` application using the provided `vagrant`
    standalone environment, you should use `192.168.56.11:<PUBLISHED_PORT>` in your
    browser because you are using a virtual machine. However, we prepared a host-to-virtual
    node interface (the `192.168.56.11` IP address).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now remove the application and continue to the next lab using `docker-compose
    down`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create a `red` application, defining a simple variable to change
    the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a red application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we will change the application's behavior by setting the `COLOR`
    environment variable. In this case, we will execute our `red` application. This
    new application can be deployed with just a few changes, which will help us integrate
    more components in the following labs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s execute a `red`application. In this case, we just change the service
    name and add an environment variable to define the backend color (a `COLOR` key
    and a `red` value). The following is the content of the `docker-compose.red.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reuse the `lab1` project name or create a new one. If we use `lab2`
    as the new project name, new tags will be added. Building it will not create new
    layers because we haven''t changed any code. We will simply use `docker-compose
    up -d`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can review the deployment status using `docker-compose ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily access `0.0.0.0:32781` to access the `red`application using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try to scale up the number of application instances.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the red application's backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we will increase the number of application backends by scaling
    one of its components up using `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the new number of instances required for the application using `docker-compose
    scale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in this case, we are deploying a stateless application, without
    any persistence. There is something else to take note of in this case – we left
    the host-linked port unset. Therefore, a random one is always used for each container
    instance. Let''s review the new instance port number with `docker-compose ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can access all the instances. Each one is using its own NAT port, all
    of which are available in the Docker host. We can check this again using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: All the IP addresses are different because we are accessing different containers.
    However, all of them are `red`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove all the application instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the next lab, we will add more colors using a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now increase our application's components by adding more colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add more color applications. In the `docker-compose.multicolor.yaml`
    file, we''ll add a couple of services, along with their own `COLOR` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We will launch our `red`, `green`, and `white` applications using `docker-compose
    up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to access different applications. Let''s review their processes
    and ports using `docker-compose ps` and then access each instance using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, all application components are accessible using random published
    ports. We can use fixed ports to route users' requests to external load balancers,
    for example. We would not use random ports in production.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the backend ports are dynamically associated with random ports. This
    allows us to run this application more than once without any `docker-compose`
    file changes. We will just need to use another project name to ensure the created
    objects' uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add a simple load balancer to see some other deployment features.
    We will publish this load balancer, and other services will only be accessible
    through this component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a simple load balancer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we will add a simple `nginx` load balancer to route traffic to
    different color backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the new deployment file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have removed all the color's service backends' ports. Now, we
    are just exposing port `8080`, which is linked to the internal `nginx` component's
    port; that is, port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s launch the application deployment and review the results using `docker-compose
    up -d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all our components are ready, we can test all the color backends using
    different host headers to reach each backend. We prepared a simple `nginx` load
    balancing configuration for this (we''ve provided a quick review of the load balancer
    configuration file in `lb/nginx.conf`). Every time we ask for a specific host
    header using each color, we will be routed to the right backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `curl`, we can test all the backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, none of the services are accessible except `loadbalancer`. Let''s
    review the published ports using `docker-compose ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'What will happen if we scale up the `green` service to four instances? We expect
    to reach all the instances because the service instances will be added to the
    internal DNS. Let''s scale up this service using `docker-compose up -d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s ask for the `green` service again using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we expected, we get different backends on each request because the DNS gave
    the load balancer a different backend IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this lab, let''s install the `bind-tools`package on the `loadbalancer`
    container to query the internal DNS using the `host` tool. We will query the `red`
    and `green` services to verify the internal DNS resolution. This is key in application
    deployment when using components'' names. We will use `docker-compose exec` to
    install the `bind-tools`package in the `loadbalancer` container. Once the package
    is installed, we will use `docker-compose exec` again with the `host` command
    to query the DNS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The internal DNS gave us all the IP addresses associated with the `green`and
    `red` services. Those are the associated containers' IP addresses. Therefore,
    our defined `green`service is load-balanced to all running `green`backends.
  prefs: []
  type: TYPE_NORMAL
- en: Remove all the labs using `docker-compose down` with the appropriate `docker-compose`
    file and project name.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered how to deploy multi-container applications on Docker hosts.
    We learned that the `docker-compose` command does not just deploy applications,
    but allows us to build and share all application components. Reviewing all the
    components'' statuses is also easier because `docker-compose` provides a command-line
    interface for retrieving all the application container''s standard and error outputs.
    We can start and stop all the components at once. But we can go even further than
    this: we are also able to scale the number of instances of each component up and
    down. This feature depends on our application logic because the Docker daemon
    does not know anything about our application processes.'
  prefs: []
  type: TYPE_NORMAL
- en: All application components are defined in a YAML-formatted file that can be
    customized using variables. We learned about the most important keys and their
    default values in this instance. The `docker-compose` file is key as it describes
    all the application components and its resources, as well as their interactions.
    Each component has its own version because we use images with their tags and arguments.
    We can also code versioning systems to be able to track `docker-compose` changes
    because this provides IaC information. We need to know exactly what application
    components are running in production, and Docker Compose allows us to apply release
    numbers to the files used for application deployments. This will ensure that the
    right application components are running. Introducing variables in these files
    allows us to use them at different development and deployment stages with only
    minor changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, there are some questions that you can have a go at
    to consolidate your understanding of the topics that we've learned about in this
    chapter. The next chapter will teach us how to manage image ownership and content
    using Docker Content Trust.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these statements is not true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Compose can run multi-service applications distributed on different
    services.
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Compose can run multi-container applications on a Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Compose is a software application that is not installed with standard
    Docker packages.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above are true.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do with `docker-compose`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We can build all application images.
  prefs: []
  type: TYPE_NORMAL
- en: b) We can pull and push application component images.
  prefs: []
  type: TYPE_NORMAL
- en: c) We can run all application components at once.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if we execute `docker-compose up` with a `docker-compose` file
    in which we have defined the frontend, backend, and database services? (Choose
    all of the correct statements out of the following options.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Compose will look for all the services' defined images and will pull
    them if they are not present in the current host.
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Compose will execute only images with the `start` key defined.
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Compose will run all containers at once and your terminal will be
    attached to their standard and error outputs.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above are false.
  prefs: []
  type: TYPE_NORMAL
- en: How can we use a `docker-compose` file to launch application services more than
    once?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) In actual fact, we cannot do that, but we can launch service process instances
    using the `scale` action. This service name will resolve to all replica IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Compose will only execute images with the `start` key defined.
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Compose will run all the containers at once, without any precedence.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above are false.
  prefs: []
  type: TYPE_NORMAL
- en: What does the execution of `docker-compose down` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) It will stop all running containers associated with an application.
  prefs: []
  type: TYPE_NORMAL
- en: b) It will try to stop all running containers associated with an application.
  prefs: []
  type: TYPE_NORMAL
- en: c) It will try to stop all running containers associated with an application.
    Once they're all stopped, it will remove them.
  prefs: []
  type: TYPE_NORMAL
- en: d) It will try to stop all running containers associated with an application.
    Once they're all stopped, it will remove them, along with all of their associated
    resources, unless they were defined externally.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information regarding the topics
    that were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Compose file reference: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose''s GitHub repository: [https://github.com/docker/compose.git](https://github.com/docker/compose.git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose with Visual Studio Code: [https://code.visualstudio.com/docs/containers/docker-compose](https://code.visualstudio.com/docs/containers/docker-compose)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose samples: [https://github.com/dockersamples/example-voting-app](https://github.com/dockersamples/example-voting-app)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose releases: [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
