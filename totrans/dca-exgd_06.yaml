- en: Deploying Multi-Container Applications
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 部署多容器应用程序
- en: In this chapter, we will learn about the Docker Compose tool, a key component
    of any Docker environment. Using Docker Compose, we can manage multi-container
    applications, and all the actions and functionalities we usually use to manage
    a container-based application will be made available in multi-container environments
    by Docker Compose. We are able to build all the required images for a project
    at once. There is no need to build, pull/push, and execute containers one by one.
    We can declare all the pieces, along with their interconnections, storage, environments,
    and so on, in a single file. We are also able to debug multi-container applications
    from a single endpoint, which is vital when you have many separate elements running
    on production environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Docker Compose 工具，这是任何 Docker 环境中的关键组件。使用 Docker Compose，我们可以管理多容器应用程序，所有我们通常用来管理基于容器的应用程序的操作和功能，Docker
    Compose 都能在多容器环境中提供。我们可以一次性构建项目所需的所有镜像，无需逐个构建、拉取/推送和执行容器。我们可以在一个文件中声明所有组件及其相互连接、存储、环境等。我们还能够从单一端点调试多容器应用程序，这在生产环境中有许多独立元素运行时尤为重要。
- en: But this is not just a tool. Docker Compose declares a new type of file, `docker-compose.yaml`.
    This file provides all the requirements for multi-container applications and can
    be used with other Docker tools. The introduction of this kind of file is very
    important because it was the basis for Swarm-orchestrated deployments and the
    newest CNAB-based applications. We will not cover **Cloud-Native Application Bundles**
    (**CNABs**) in this book, but if you are interested, take a look at [https://cnab.io.](https://cnab.io.)
    Docker has its own CNAB implementation, but it is in the experimental stage at
    the time of writing this book and is not part of the DCA exam.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不仅仅是一个工具。Docker Compose 声明了一种新类型的文件，`docker-compose.yaml`。该文件提供了多容器应用程序的所有要求，并可与其他
    Docker 工具一起使用。引入这种文件类型非常重要，因为它是 Swarm 编排部署和最新的基于 CNAB 的应用程序的基础。我们在本书中不会介绍**云原生应用程序捆绑包**（**CNABs**），但如果你感兴趣，可以查看[https://cnab.io](https://cnab.io)。Docker
    有自己的 CNAB 实现，但在编写本书时，它处于实验阶段，并且不属于 DCA 考试的内容。
- en: In this chapter, we will review Docker Compose. We will learn how to install
    this tool with different methods, along with its keys and how we should use them.
    We will discover some of the actions provided by the tool and their use cases.
    We will finish with some tips that will help us to use `docker-compose` with variables.
    This allows us to provision dynamic content for different environments using the
    same deployment files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾 Docker Compose。我们将学习如何通过不同方法安装该工具，并了解其关键内容以及如何使用它们。我们将探索该工具提供的一些操作及其应用场景。最后，我们将给出一些使用
    `docker-compose` 和变量的技巧，这可以让我们使用相同的部署文件为不同环境提供动态内容。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing and using Docker Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用 Docker Compose
- en: Understanding the docker-compose.yaml file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 docker-compose.yaml 文件
- en: Using docker-compose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 docker-compose
- en: Customizing images with docker-compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 docker-compose 自定义镜像
- en: Automating your desktop and CI/CD with docker-compose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 docker-compose 自动化你的桌面和 CI/CD
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will learn about Dockerized multi-container applications.
    We'll provide some labs at the end of this chapter that will help you understand
    and learn the concepts covered. These labs can be run on your laptop or PC using
    the provided Vagrant standalone environment or any already deployed Docker host
    of your own. Check the additional information in this book's GitHub code repository
    at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Docker 化的多容器应用程序。我们将在本章的最后提供一些实验室练习，帮助你理解和学习所涵盖的概念。这些实验室可以在你的笔记本电脑或
    PC 上运行，使用提供的 Vagrant 独立环境或你自己已经部署的 Docker 主机。查看本书 GitHub 代码库中的额外信息：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，查看代码的实际操作：
- en: '"[https://bit.ly/3hz0IB0](https://bit.ly/3hz0IB0)"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/3hz0IB0](https://bit.ly/3hz0IB0)"'
- en: Installing and using Docker Compose
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用 Docker Compose
- en: 'Before deep-diving into the Docker Compose tool, let''s learn about the differences
    between multi-container applications and multi-service applications:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 Docker Compose 工具之前，让我们先了解一下多容器应用和多服务应用之间的区别：
- en: Multi-container applications are applications based on multiple containers.
    These containers will run together on the same host. Therefore, we can deploy
    multi-container applications on our laptop or on any other Docker daemon. All
    application components will run together on a host. As a result, possible network
    performance issues will be mitigated because all the pieces will run together.
    Take into account that this deployment will not provide high availability if the
    host goes down. We will be able to configure the automatic restart of all components,
    but that is not enough for production.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多容器应用是基于多个容器的应用。这些容器将一起在同一主机上运行。因此，我们可以在我们的笔记本电脑或任何其他 Docker 守护进程上部署多容器应用。所有应用组件将一起在一台主机上运行。因此，可能的网络性能问题将得到缓解，因为所有组件会一起运行。请注意，这种部署方式如果主机宕机将无法提供高可用性。我们可以配置所有组件的自动重启，但这对于生产环境来说还不够。
- en: Multi-service applications are applications based on multiple services. These
    applications will run using Swarm orchestration and containers will run distributed
    on different hosts. We will learn about Docker Swarm orchestration in [Chapter
    8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml), *Orchestrating with Docker Swarm*.
    But you should understand that services are the smallest unit of scheduling on
    Docker Swarm environments. We will not schedule containers; we will schedule a
    service, based on the execution of a number of tasks. Those tasks are associated
    with containers; in fact, one container per task. Therefore, a service is represented
    by a number of tasks (known as replicas) that run containers. We schedule a service
    in Docker Swarm, setting the number of replicas required to be healthy. Docker
    Swarm will take care of the container's status. As we mentioned previously, services
    will run distributed on different hosts. Multi-service application components
    will usually run distributed cluster-wide. Components' interconnections will rely
    on internal and external networking, while Swarm provides out-of-the-box high
    availability based on resilience for all services' tasks. Keep these features
    in mind. We will learn about the great features behind Swarm and Kubernetes orchestrations
    in the *Container orchestration* section.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多服务应用是基于多个服务的应用。这些应用将通过 Swarm 编排运行，容器将分布在不同的主机上。我们将在[第 8 章](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml)《*使用
    Docker Swarm 编排*》中了解 Docker Swarm 编排。但你应该理解，服务是 Docker Swarm 环境中调度的最小单元。我们不会调度容器；我们会调度一个服务，基于执行多个任务的情况。这些任务与容器相关联；事实上，每个任务对应一个容器。因此，一个服务由多个任务（称为副本）组成，负责运行容器。我们在
    Docker Swarm 中调度服务，设置所需的副本数量以确保服务健康。Docker Swarm 会处理容器的状态。正如我们之前提到的，服务将分布在不同的主机上运行。多服务应用的组件通常会在整个集群中分布运行。组件之间的互联将依赖于内部和外部网络，而
    Swarm 则提供基于弹性的开箱即用高可用性，确保所有服务任务的可用性。请牢记这些特性。我们将在《*容器编排*》部分学习 Swarm 和 Kubernetes
    编排背后的强大功能。
- en: In summary, we deploy multi-container applications on one node while multi-service
    applications run distributed in different nodes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们在一个节点上部署多容器应用，而多服务应用则分布在不同的节点上运行。
- en: '`docker-compose` does not come with Docker packages when you install it. It
    is a different product. On Docker Desktop for macOS and Windows, Docker Compose
    is included and ready to use.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 在安装 Docker 时并不随附。它是一个不同的产品。在 macOS 和 Windows 上的 Docker Desktop
    中，Docker Compose 已包含并可以直接使用。'
- en: The first thing we have to learn about Docker Compose is that it is a Python-based
    application. Therefore, we can install it as we would any other Python module
    or download it as a binary file. We can also run `docker-compose` within a container.
    We can find easy instructions at [https://docs.docker.com/compose/install](https://docs.docker.com/compose/install).
    Notice that at the time of writing, the latest `docker-compose` release was 1.24.1\.
    We will use this version for all of the following installation methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要了解 Docker Compose 是一个基于 Python 的应用。因此，我们可以像安装其他 Python 模块一样安装它，或者下载它作为二进制文件。我们还可以在容器内运行
    `docker-compose`。我们可以在[https://docs.docker.com/compose/install](https://docs.docker.com/compose/install)找到简单的安装说明。请注意，在撰写本文时，最新的
    `docker-compose` 版本是 1.24.1。我们将使用此版本来进行接下来的所有安装方法。
- en: Installing docker-compose as a Python module
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 docker-compose 作为 Python 模块
- en: Installation using `pip` (the Python module installer) is easy on Linux systems.
    We will review this method and we will also download the Docker Compose binary.
    First, we need to have `pip` installed on our system. It is a package that's available
    on almost all Linux systems and, consequently, whether it's already installed
    or not will depend on the Linux flavor used (the package name can be `py-pip`,
    `python3-pip`, or `pip-python`; it really depends on your operating system and
    the Python version used).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`（Python模块安装程序）在Linux系统上安装很容易。我们将回顾这种方法，并且还将下载Docker Compose二进制文件。首先，我们需要在系统中安装`pip`。它是几乎所有Linux系统上都能找到的包，因此是否已经安装取决于所使用的Linux版本（包名可能是`py-pip`、`python3-pip`或`pip-python`；这实际上取决于你的操作系统和使用的Python版本）。
- en: We will not cover this package installation and will assume you have `pip` installed
    on your system. We will install the `docker-compose` module as the root user to
    allow all host users to use it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖这个软件包的安装，并假设您已在系统中安装了`pip`。我们将以root用户身份安装`docker-compose`模块，以便所有主机用户都可以使用它。
- en: There is a version of `pip` for Python 2.x and another for Python 3.x. Remember
    that Python 2.x is obsolete nowadays, so it might be time to move to Python 3.x.
    We will cover Python 3 installation only, for this reason.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个适用于Python 2.x的`pip`版本和一个适用于Python 3.x的版本。记住，Python 2.x现在已经过时，所以可能是时候迁移到Python
    3.x了。出于这个原因，我们只会讨论Python 3的安装。
- en: 'We use `sudo` as root with `-H` to use our logged-in user''s home path:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sudo`作为root，并加上`-H`来使用我们登录用户的主目录：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After execution, we will have `docker-compose` installed at `/usr/local/bin/docker-compose`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们将在`/usr/local/bin/docker-compose`安装`docker-compose`。
- en: Installing docker-compose using downloaded binaries
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用下载的二进制文件安装docker-compose
- en: 'Here, we just need `curl` or `wget` to download the defined version binaries
    from this project''s GitHub page ([https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)).
    Make sure to choose the right binary and version for your architecture processor
    and system. We will review the installation for the CentOS 7 Linux system, which
    is used for all our labs:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要`curl`或`wget`来从该项目的GitHub页面（[https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)）下载定义版本的二进制文件。确保选择适合您架构处理器和系统的正确二进制文件和版本。我们将回顾CentOS
    7 Linux系统的安装，它用于我们的所有实验室：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can also use a container to execute `docker-compose`, as we will learn in
    the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用容器来执行`docker-compose`，如下一节中所述。
- en: Executing docker-compose using a container
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器执行docker-compose
- en: 'This is quite interesting because, as we have learned, executing applications
    as containers just requires a Docker daemon running on our system. It is a great
    way to execute applications! In this case, `run.sh` is a script that will prepare
    all the required volumes and parameters (`curl -L` will follow redirections and
    the `-o` argument will allow us to choose the destination filename):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点相当有趣，因为正如我们所学，作为容器执行应用程序只需要在我们的系统上运行Docker守护进程。这是执行应用程序的一个好方法！在这种情况下，`run.sh`是一个脚本，它将准备所有所需的卷和参数（`curl
    -L`将跟随重定向，`-o`参数将允许我们选择目标文件名）：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Docker Compose can also be installed on Windows nodes, as we will learn in the
    next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose也可以安装在Windows节点上，如下一节中所述。
- en: Installing docker-compose on Windows servers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows服务器上安装docker-compose
- en: On Windows servers, we will use an elevated PowerShell (that is, run it as administrator).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows服务器上，我们将使用提升的PowerShell（即以管理员身份运行）。
- en: 'Since GitHub now requires TLS1.2, it is required to run the following on our
    administrator PowerShell before executing the installation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitHub现在要求使用TLS1.2，在执行安装之前，需要在管理员PowerShell中运行以下命令：
- en: '`[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12`'
- en: 'Once in the administrator''s PowerShell, we need to run the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入管理员PowerShell，我们需要运行以下命令：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the next section, we will learn about Docker Compose files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习Docker Compose文件。
- en: Understanding the docker-compose.yaml file
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解docker-compose.yaml文件
- en: Docker Compose introduces the concept of multi-container applications using
    an all-in-one application components' definition file. This file is known as `docker-compose.yaml`.
    Usually, we will manage a `docker-compose.yaml` file. Notice that this is a YAML
    file; therefore, indentation is fundamental. The file will contain all of the
    application components and their properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose引入了多容器应用程序的概念，使用一个集成所有应用组件定义的文件。这个文件被称为`docker-compose.yaml`。通常，我们会管理一个`docker-compose.yaml`文件。请注意，这是一个YAML文件，因此缩进至关重要。该文件将包含所有应用组件及其属性。
- en: 'This is how a simple `docker-compose.yaml` file looks (we can use either the
    `.yaml` or `.yml` extension for YAML files):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`docker-compose.yaml`文件的样子（我们可以使用`.yaml`或`.yml`扩展名来表示YAML文件）：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `docker-compose.yaml` file will contain definitions for all Docker-based
    application components (services, networks, and volumes). In this file, we first
    declare the file definition version. This definition manages how Docker Compose
    should interpret some of the directives written. We will use version 3.x for our
    file definition because it is the most up to date and is recommended at the time
    of writing. There are a few differences between versions, although `docker-compose`
    provides backward compatibility, so you should check the Docker documentation
    for more information. It is important to know that keys and definition structures
    may vary between versions, and you should use specific versions with older Docker
    engines. We will use version 3.7 (the current version at the time of writing).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yaml`文件将包含所有基于Docker的应用组件（服务、网络和卷）的定义。在此文件中，我们首先声明文件定义的版本。这个定义管理Docker
    Compose如何解释一些编写的指令。我们将使用版本3.x的文件定义，因为它是最新的并且是目前推荐的版本。不同版本之间有一些差异，尽管`docker-compose`提供了向后兼容性，所以你应该查阅Docker文档获取更多信息。需要注意的是，版本之间的键和值结构可能有所不同，因此在使用较旧的Docker引擎时，应该使用特定的版本。我们将使用版本3.7（这是编写时的当前版本）。'
- en: Let's learn a bit about the file contents.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来学习一下文件的内容。
- en: We are using environment variables to provide credentials and access to some
    services. This is just for demo purposes – never use environment variables for
    your passwords, credentials, or connection strings. In Docker Swarm, we use secrets
    and configuration objects. In Docker Compose, we do not have this kind of object,
    so it's preferred to use external configuration tools or secure key-value stores
    to manage these values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用环境变量来提供凭证并访问某些服务。这只是为了演示目的——绝不要使用环境变量来存储密码、凭证或连接字符串。在Docker Swarm中，我们使用`secrets`和`configuration`对象。在Docker
    Compose中，我们没有这种类型的对象，因此建议使用外部配置工具或安全的键值存储来管理这些值。
- en: We have a section for `services` and another one for `networks`. We can also
    have a `volumes` section. The `volumes` and `networks` sections will define their
    properties for the application. In these sections, we will declare special features
    and the drivers used for them. In the example file, we have declared a special
    subnet to use on the `simplestlab` network with the default bridge driver. This
    is the network that will be created and used for all the components, as we can
    see in all of our service definitions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于`services`的部分和另一个用于`networks`的部分。我们还可以有一个`volumes`部分。`volumes`和`networks`部分将为应用程序定义它们的属性。在这些部分，我们将声明特殊功能以及为其使用的驱动程序。在示例文件中，我们声明了一个特殊的子网，用于在`simplestlab`网络上使用默认的桥接驱动程序。正如我们在所有服务定义中看到的，这将是为所有组件创建并使用的网络。
- en: In Docker Swarm, we can also define `Configs` and `Secrets`, which are cluster
    objects. We will declare objects in one section of the file and then we will use
    these objects inside each service definition.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Swarm中，我们还可以定义`Configs`和`Secrets`，它们是集群对象。我们将在文件的一个部分中声明这些对象，然后在每个服务定义中使用这些对象。
- en: Each service represents one component. Let's take a closer look at the definitions
    of the `app` service, for example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务代表一个组件。让我们以`app`服务的定义为例，详细了解一下。
- en: Each service definition has some key configurations to explain how this application
    component will run. In the `app` service, we have a `build` definition, which
    indicates how this component will be created. The value of the `build` key indicates
    the context path for building an image for these components (the `simplestapp`
    directory). Therefore, we can build this component with this `docker-compose.yaml`
    file and the `simplestapp` directory content. We've learned that to build an image,
    we need a Dockerfile; consequently, a Dockerfile is mandatory inside the `simplestapp`
    directory. All the files required to compile the `myregistry/simplest-lab:simplestapp`
    image should be in this directory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务定义都有一些关键配置，用来说明该应用组件如何运行。在`app`服务中，我们有一个`build`定义，指示如何创建这个组件。`build`键的值指示用于构建这些组件镜像的上下文路径（即`simplestapp`目录）。因此，我们可以使用这个`docker-compose.yaml`文件和`simplestapp`目录中的内容来构建这个组件。我们已经学到，为了构建镜像，我们需要一个Dockerfile；因此，`simplestapp`目录中必须包含一个Dockerfile。所有需要编译`myregistry/simplest-lab:simplestapp`镜像的文件都应该在这个目录中。
- en: When we talk about multi-container applications with Docker Compose, services
    definitions are different from Swarm Services, which are managed by Swarm orchestration.
    In non-Swam environments, we refer to services as application components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论Docker Compose中的多容器应用时，服务定义与Swarm服务不同，后者由Swarm编排管理。在非Swarm环境中，我们将服务称为应用组件。
- en: The next line, which contains the `image` key, defines the name of the image.
    If the image does not exist in your host, it will be built with this name. If
    we do not have a `build` definition, the Docker daemon will try to download the
    defined image from the registry.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行包含`image`键，定义了镜像的名称。如果该镜像在主机中不存在，它将使用这个名称进行构建。如果没有`build`定义，Docker守护进程将尝试从镜像仓库下载已定义的镜像。
- en: The next key defines a list of variables and their values to be used as environment
    variables during container execution. We can override the image-defined `ENVIRONMENT`,
    `CMD`, `ENTRYPOINT`, and `VOLUME` values, among others, as we usually do within
    containers. We will take a look at the Docker Compose definitions later, but keep
    in mind that almost every option we use on the `docker container run` or `docker
    container create` actions is available as a key on `docker-compose.yaml`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个键定义了一组变量及其值，在容器执行期间作为环境变量使用。我们可以覆盖镜像定义的`ENVIRONMENT`、`CMD`、`ENTRYPOINT`和`VOLUME`值等，正如我们在容器中通常所做的那样。稍后我们将进一步了解Docker
    Compose定义，但请记住，我们在`docker container run`或`docker container create`操作中使用的几乎每个选项，都可以作为`docker-compose.yaml`中的一个键来使用。
- en: Then, we define the networks to be used in this component. We also defined an
    alias name to use in this network. This component will be known as `app`, which
    is its service name, and also by its defined alias, which is `simplestapp`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们定义了此组件中要使用的网络。我们还定义了一个别名，用于在该网络中使用。这个组件将被称为`app`，这是它的服务名称，同时也使用其定义的别名`simplestapp`。
- en: It is important to note that Docker Compose allows us to define an order of
    execution, as we can see in the last few lines. We used the `depends_on` key to
    wait until all the components in the list were available (that is, all the containers
    were marked as healthy).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Docker Compose允许我们定义执行顺序，正如在最后几行中看到的那样。我们使用了`depends_on`键，直到列表中的所有组件都可用（即所有容器都被标记为健康）后才继续执行。
- en: With that, we have reviewed the `services` section of the preceding code file.
    In this example, we also have `volumes` and `networks` sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经回顾了前面代码文件中的`services`部分。在这个例子中，我们还有`volumes`和`networks`部分。
- en: In the `volumes` section, we have the simplest definition. It is empty and just
    defines a volume with the default parameters (the local driver). In the `services`
    section, we define where and how these volumes should be attached.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`volumes`部分，我们有最简单的定义。它是空的，仅定义了一个具有默认参数（本地驱动程序）的卷。在`services`部分，我们定义了这些卷应该在哪里以及如何附加。
- en: 'Now that we know the basics, we can take a look at some of the most used key
    definitions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了基本概念，可以看看一些最常用的键定义：
- en: '| **Key** | **Definitions** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **Key** | **Definitions** |'
- en: '| `build` | This key will define the options used to build the application
    images. These are some of the most used options:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| `build` | 这个键定义了用于构建应用程序镜像的选项。以下是一些最常用的选项：'
- en: '`context`: This option defines the path to the build context, the directory
    that contains the Dockerfile, and all the other files required for the image.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：此选项定义了构建上下文的路径，即包含Dockerfile和所有其他所需文件的目录。'
- en: '`dockerfile`: This defines an alternative Dockerfile name.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerfile`: 这定义了一个替代的 Dockerfile 名称。'
- en: '`args`: We can set Dockerfile arguments here.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`: 我们可以在这里设置 Dockerfile 参数。'
- en: '`labels`: This option allows us to set image labels.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels`: 此选项允许我们设置镜像标签。'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `image` | This is the name of the image to be used. If the image does not
    exist, it will be pulled from the registry. If the image must be built, it will
    use this value for its name. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `image` | 这是要使用的镜像名称。如果镜像不存在，将从注册表中拉取。如果必须构建镜像，则会使用此值作为其名称。 |'
- en: '| `environment` | We are able to set environment variables within containers.
    This will overwrite any image-defined values. We can also use `env_file` to define
    a file with many values. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `environment` | 我们可以在容器内设置环境变量。这将覆盖任何镜像定义的值。我们也可以使用`env_file`来定义一个包含许多值的文件。
    |'
- en: '| `command` | This will set or overwrite the image''s `command` definition.
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `command` | 这将设置或覆盖镜像的`command`定义。 |'
- en: '| `entrypoint` | This will set or overwrite the image''s `entrypoint` definition.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `entrypoint` | 这将设置或覆盖镜像的`entrypoint`定义。 |'
- en: '| `ports` | These are the ports to be exposed by the services to be reachable
    at the host level. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `ports` | 这些是服务要公开的端口，以便在主机级别可达。 |'
- en: '| `expose` | This option defines which service ports will be available for
    other services. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `expose` | 此选项定义了哪些服务端口将对其他服务可用。 |'
- en: '| `privileged``cap_add/cap_drop``read_only` | These options will set the same
    features we learned about when we talked about container execution in [Chapter
    3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml), *Running Docker Containers*. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `privileged``cap_add/cap_drop``read_only` | 这些选项将设置与我们在[第 3 章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)中讨论的容器执行相同的功能。
    |'
- en: '| `user` | This will set or overwrite the image''s `user` definition. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 这将设置或覆盖镜像的`user`定义。 |'
- en: '| `labels` | This will set or overwrite image labels. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `labels` | 这将设置或覆盖镜像的标签。 |'
- en: '| `restart` | With `restart`, we can set how associated containers should be
    managed. If they die, should Docker restart them or leave them stopped? Remember
    the options defined for our containers – we will use the same values here. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `restart` | 使用`restart`，我们可以设置关联容器的管理方式。如果它们停止了，Docker 是否应该重新启动它们或者保持停止状态？请记住为我们的容器定义的选项
    - 我们将在这里使用相同的值。 |'
- en: '| `container_name` | We are able to set the container name using this variable.
    If not defined, the container name will be generated using the service project
    name as a prefix, followed by the service name and the instance number, starting
    from `1`. Take care with this parameter; as you''ve already learned, there can
    only be one container with a defined name per host. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `container_name` | 我们可以使用此变量设置容器名称。如果未定义，容器名称将使用服务项目名称作为前缀，后跟服务名称和实例编号，从`1`开始。请注意此参数；正如您已经了解的那样，每台主机只能有一个定义名称的容器。
    |'
- en: '| `hostname``domainname` | These options will allow us to change the container
    hostname and its domain name. Under the `network` definition, we are able to add
    as many DNS aliases as required. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `hostname``domainname` | 这些选项将允许我们更改容器的主机名和其域名。在`network`定义下，我们可以添加任意数量的
    DNS 别名。 |'
- en: '| `extra_hosts` | With this option, we can add external hosts to be discovered
    via internal DNS. This will help us reach external services as if they were running
    within containers. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `extra_hosts` | 使用此选项，我们可以添加外部主机以通过内部 DNS 发现。这将帮助我们像在容器内运行一样访问外部服务。 |'
- en: '| `depends_on` | This key allows us to set components'' dependencies. It is
    deprecated now in version `3` but is included here to explain to you that it did
    not provide real dependency. This option will just control the boot order. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `depends_on` | 此键允许我们设置组件的依赖关系。它在版本`3`中已被弃用，但在这里包括是为了解释它实际上并未提供真正的依赖性。此选项只会控制启动顺序。
    |'
- en: '| `networks` | We can set which network drivers to use, their options and subnet
    ranges, and how they will be accessible (internal and/or attachable). Let''s review
    a simple example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '| `networks` | 我们可以设置要使用的网络驱动程序、它们的选项和子网范围，以及它们将如何可访问（内部和/或可附加）。让我们来看一个简单的例子：
    |'
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we have defined `mynet` as a bridge network with a defined
    subnet for all our containers. We can use this defined network on each service
    section:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已将`mynet`定义为所有容器的桥接网络，并为其定义了一个子网。我们可以在每个服务部分使用这个定义的网络：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `volumes` | Volumes are defined in the `volumes` section. We will be able
    to set their drivers and special options. The following is an example of a simple
    local definition that we can use in the `services` section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '| `volumes` | 卷在`volumes`部分中定义。我们可以设置它们的驱动程序和特殊选项。以下是一个我们可以在`services`部分中使用的简单本地定义示例：'
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `tmpfs` | We can use an in-memory filesystem with `tmpfs`. This option is
    very useful for bypassing the overlay filesystem to improve I/O performance or
    for security reasons. The in-memory filesystem will disappear when the container
    dies:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| `tmpfs` | 我们可以使用`tmpfs`创建一个内存文件系统。此选项对于绕过叠加文件系统以提高I/O性能或出于安全原因非常有用。当容器终止时，内存文件系统会消失：'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `healthcheck` | This will set or overwrite the image''s `healthcheck` definitions.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `healthcheck` | 这将设置或覆盖镜像的`healthcheck`定义。 |'
- en: These keys are the most commonly used ones. Consult the Docker Compose documentation
    for more information, which is available on the Docker website at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常用的键。有关更多信息，请查阅Docker Compose文档，文档可以在Docker官方网站上找到，网址为[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)。
- en: There are many keys that are only allowed on Docker Swarm environments. We didn't
    include them in the preceding information table because the Swarm options will
    be shown in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml), *Orchestration
    Using Docker Swarm*. Defining container resource limits in `docker-compose.yaml`
    files is only allowed either using Docker Swarm mode or using Docker Compose version
    2.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多仅允许在Docker Swarm环境中使用的键。我们没有在前面的信息表中包含它们，因为Swarm选项将在[第8章](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml)，*使用Docker
    Swarm进行编排*中展示。在`docker-compose.yaml`文件中定义容器资源限制仅在使用Docker Swarm模式或Docker Compose版本2时允许。
- en: Once we have created our `docker-compose.yaml` file, we will be able to use
    the Docker Compose command-line definitions written in this file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`docker-compose.yaml`文件，就可以使用文件中编写的Docker Compose命令行定义。
- en: Using the Docker Compose command-line interface
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose命令行界面
- en: 'We installed the `docker-compose` binary in the previous section, which means
    we can now review the actions available to us. `docker-compose` will provide most
    of the actions available for Docker because we will execute them on multiple containers
    at once. Let''s review the available `docker-compose` actions in the following
    table:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中安装了`docker-compose`二进制文件，这意味着我们现在可以查看可用的操作。`docker-compose`将提供大部分适用于Docker的操作，因为我们将同时在多个容器上执行这些操作。让我们在下表中查看可用的`docker-compose`操作：
- en: '| **Command** | **Definition** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **定义** |'
- en: '| `build` | As expected, this action will build or rebuild all `docker-compose.yaml`
    file components, or just the selected ones. This action will look for any `build`
    keys in our `docker-compose.yaml` file and launch a build or rebuild. If we set
    a project name using `--project`, all images will be created as `<project_name>_<service_name>`
    if no image name is defined. If so, this is the name that will be used if we push
    them to a registry. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `build` | 如预期的那样，此操作将构建或重建所有`docker-compose.yaml`文件中的组件，或者仅构建选定的组件。此操作将查找`docker-compose.yaml`文件中的任何`build`键，并启动构建或重建。如果我们使用`--project`设置了项目名称，则所有镜像将在没有定义镜像名称的情况下被创建为`<project_name>_<service_name>`。如果定义了镜像名称，这个名称将在我们将其推送到注册表时使用。
    |'
- en: '| `pull`/`push` | We will be able to push or pull all images at once because
    we manage all the application components with `docker-compose`. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `pull`/`push` | 我们将能够一次性推送或拉取所有镜像，因为我们使用`docker-compose`管理所有应用程序组件。 |'
- en: '| `images` | This action will list all application images. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `images` | 此操作将列出所有应用程序镜像。 |'
- en: '| `create` | Remember that we can create containers. In this case, we will
    create all containers required by the application, but they will not be launched
    until a `start` action is executed. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 请记住，我们可以创建容器。在这种情况下，我们将创建应用程序所需的所有容器，但直到执行`start`操作时，它们才会被启动。
    |'
- en: '| `rm` | This action will remove all stopped containers. Remember to use the
    project name, or leave it empty to use the current directory as the application
    name. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | 此操作将删除所有已停止的容器。记得使用项目名称，或者留空以使用当前目录作为应用程序名称。 |'
- en: '| `up` (`-d` or `--detach`) | We will create and start all components with
    this simple action. All the components will run at once. We will use `--detach`
    to run the application in the background, as we learned with containers. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `up` (`-d` 或 `--detach`) | 我们将通过这个简单的动作创建并启动所有组件。所有组件将一次性运行。我们将使用 `--detach`
    使应用在后台运行，就像我们在容器中学到的那样。 |'
- en: '| `down` | To remove all application components, we will use the `down` action.
    This will end all application containers or just the specified ones. Take care
    as externally defined resources will not be deleted and must be removed manually.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `down` | 要移除所有应用组件，我们将使用 `down` 动作。这将结束所有应用容器，或仅结束指定的容器。请注意，外部定义的资源不会被删除，必须手动移除。
    |'
- en: '| `start/stop/restart` | These options will allow us to manage components,
    applying either to all components at once or only those specified. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `start/stop/restart` | 这些选项将允许我们管理组件，可以一次性应用于所有组件，或仅应用于指定的组件。 |'
- en: '| `run` | With this option, we can execute one component to run a specified
    command, such as to initialize a database or create a required file. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 通过这个选项，我们可以执行一个组件来运行指定的命令，例如初始化数据库或创建所需文件。 |'
- en: '| `pause`/`unpause` | As we learned with containers, we can pause and unpause
    application components. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `pause`/`unpause` | 就像我们在容器中学到的那样，我们可以暂停和恢复应用组件。 |'
- en: '| `ps` | `docker-compose` will show all application containers (processes)
    and their ports. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | `docker-compose` 将显示所有应用容器（进程）及其端口。 |'
- en: '| `top` | This option will show the processes running on each container deployed
    for the application. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `top` | 这个选项将显示为应用程序部署的每个容器上运行的进程。 |'
- en: '| `exec` | We will be able to run a process within any application container
    namespace. Remember what we learned in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `exec` | 我们可以在任何应用容器的命名空间内运行一个进程。记住我们在[第3章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)中学到的内容，*运行
    Docker 容器*。 |'
- en: '| `logs` | It is very useful to be able to retrieve all application container''
    logs using a single command. We can use the `logs` action to retrieve all application
    logs at once. Logs will appear together, along with their service names, to help
    us identify each component. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `logs` | 使用单个命令检索所有应用容器的日志非常有用。我们可以使用 `logs` 动作一次性检索所有应用日志。日志将按服务名称一起显示，帮助我们识别每个组件。
    |'
- en: '| `config` | We can verify a Docker Compose definition using the `config` action.
    We can also list the defined services using `services` as the argument. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `config` | 我们可以使用 `config` 动作验证 Docker Compose 定义。我们还可以使用 `services` 参数列出已定义的服务。
    |'
- en: With this information, we can quickly see how the usual container workflow can
    be achieved in multi-container environments with Docker Compose, which gives us
    a new command-line interface to build, share, and run all our application components
    at once.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以快速了解如何在多容器环境中通过 Docker Compose 实现常见的容器工作流程，它为我们提供了一个新的命令行界面来构建、共享并一次性运行所有应用组件。
    |
- en: 'We can define external resources such as `volume` or `networks`. We will use
    the `external: true` option in these cases and you''ll have to create these resources
    manually.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以定义外部资源，如 `volume` 或 `networks`。在这些情况下，我们将使用 `external: true` 选项，并且必须手动创建这些资源。
    |'
- en: Each application that's deployed using `docker-compose` will have its own project
    definition. Each project will run in isolation alongside others in the same host.
    By default, `docker-compose` will use the current directory name as the project's
    name. We can override this behavior using `--project-name` or `-p` to set a more
    descriptive name.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-compose` 部署的每个应用将有自己的项目定义。每个项目将在同一主机上与其他项目隔离运行。默认情况下，`docker-compose`
    将使用当前目录名作为项目名。我们可以使用 `--project-name` 或 `-p` 覆盖此行为，设置一个更具描述性的名称。
- en: In [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*, we learned that object names are unique (we can
    have objects with many names, but each is unique, and we cannot have repeated
    names); therefore, `docker-compose` adds the project's name as a prefix to each
    created object. This way, we identify all application components and ensure that
    they have unique names. Of course, we can use the same `docker-compose` file to
    deploy the same application twice, but we should choose a different project name
    each time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml)，*使用 Docker 构建现代基础设施与应用程序*中，我们了解到对象名称是唯一的（我们可以为对象分配多个名称，但每个名称都是唯一的，且不能有重复的名称）；因此，`docker-compose`
    会将项目名称作为前缀添加到每个创建的对象。这使得我们能够识别所有应用程序组件并确保它们具有唯一的名称。当然，我们可以使用相同的 `docker-compose`
    文件两次部署相同的应用程序，但每次应选择不同的项目名称。
- en: We can use the `docker-compose.yaml` file to launch the same application multiple
    times, but we cannot share unique resources such as ports, volumes, and IP addresses
    between volumes. Sharing a volume between components depends on application behavior,
    but IP addresses or ports will be unique to a given Docker host.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker-compose.yaml` 文件多次启动相同的应用程序，但我们不能在卷之间共享唯一资源，如端口、卷和 IP 地址。组件间共享卷取决于应用程序行为，但
    IP 地址或端口将在给定的 Docker 主机上保持唯一。
- en: Let's review the complete application deployment workflow with the previous
    `docker-compose.yaml` file (seen in the *Understanding the docker-compose file*
    section).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使用之前的 `docker-compose.yaml` 文件（见 *理解 docker-compose 文件* 部分）进行完整应用程序部署的工作流程。
- en: First, we need to build the application images. You can download all the application
    code from this book's GitHub repository at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git.](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要构建应用程序镜像。你可以从本书的 GitHub 仓库下载所有应用程序代码，链接地址为 [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)。
- en: 'Let''s clone the repository to get all the source code directories and configuration
    files. Your output may vary from the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们克隆这个仓库，以获取所有源代码目录和配置文件。你的输出可能与以下内容不同：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will have a directory for the `simplest-lab` project with a `docker-compose.yaml`
    file and different directories for each application component:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 `simplest-lab` 项目创建一个目录，其中包含 `docker-compose.yaml` 文件以及每个应用程序组件的不同目录：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In each project directory, there is a Dockerfile we can use to build that specific
    component. So, let's build all the components at once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个项目目录中，都有一个 Dockerfile，我们可以用来构建该特定组件。所以，让我们一次性构建所有组件。
- en: We have the same options for removing the intermediate containers (used for
    building and disallowing image caching) as we had with the `docker image build`
    command. We will use `--force-rm` and `--no-cache`, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在移除中间容器（用于构建并禁止镜像缓存）时，拥有与 `docker image build` 命令相同的选项。我们将分别使用 `--force-rm`
    和 `--no-cache`。
- en: 'To ensure that the defined `docker-compose.yaml` file is valid, we can use
    `docker-compose config --quiet`. If there is an issue, it will be reported. We
    can also list the names of the services or volumes that have been defined:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保定义的 `docker-compose.yaml` 文件有效，我们可以使用 `docker-compose config --quiet`。如果有问题，它将被报告。我们还可以列出已定义的服务或卷的名称：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will use these service name definitions later on in this section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节后面使用这些服务名称定义。
- en: 'We will execute `docker-compose build` to build all the component images defined
    in our `docker-compose.yaml` file. This command will take some time because we
    are not just building an image, but all the images required. The following output
    is truncated:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行 `docker-compose build` 来构建在 `docker-compose.yaml` 文件中定义的所有组件镜像。此命令将花费一些时间，因为我们不仅仅是在构建一个镜像，而是在构建所有必需的镜像。以下输出已被截断：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After a few minutes (or seconds, depending on your internet connection and processor
    speed), all three images will be created. As we have not set a project name, `docker-compose`
    has created one for you. As we mentioned previously, by default, all the components
    will be created with the directory name prefixed. In this case, we have an image
    key on our `docker-compose.yaml` file, so that image naming syntax will be used
    instead of a local directory reference.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后（或几秒钟，取决于您的互联网连接和处理器速度），将创建所有三个映像。由于我们尚未设置项目名称，`docker-compose`已为您创建了一个项目名称。如前所述，默认情况下，所有组件都将使用目录名作为前缀创建。在这种情况下，我们在`docker-compose.yaml`文件上有一个映像键，因此将使用映像命名语法，而不是本地目录引用。
- en: 'Notice that we have used a dummy registry name (`myregistry`). This means that
    we cannot push images to this dummy registry, but it is important to understand
    the logic behind image names. If we list current images on our Docker daemon,
    we should have all the images created for this project:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了一个虚拟的注册表名称（`myregistry`）。这意味着我们无法将映像推送到这个虚拟注册表，但重要的是理解映像名称背后的逻辑。如果我们在Docker守护程序上列出当前映像，我们应该有为这个项目创建的所有映像。
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have our images, we can share them. We can now execute the `docker-compose
    push` command to push them to `myregistry` (in our example file). This will upload
    the images one by one with defined tags.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的映像，我们可以分享它们。我们现在可以执行`docker-compose push`命令将它们推送到`myregistry`（在我们的示例文件中）。这将逐个上传带有定义标签的映像。
- en: 'We are ready to run all the application components together using `docker-compose
    up`. To launch it in the background, we will use the `--detach` option. If we
    do not use this option, we will be attached to all our container''s standard and
    error outputs. We learned how to attach to container output in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*. Remember that this behavior is expected on `docker
    container run` without the `--detach` or `-d` option:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备使用`docker-compose up`一起运行所有应用程序组件。为了在后台启动它，我们将使用`--detach`选项。如果我们不使用此选项，我们将连接到所有容器的标准输出和错误输出。我们学会了如何在[第3章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)，*运行Docker容器*中附加到容器输出。请记住，在`docker
    container run`中没有`--detach`或`-d`选项时，这种行为是预期的：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this line, we have just started our application. It is important to understand
    that `docker-compose up` does more than merely execute all the components. In
    this case, we built our components first, but the `docker-compose up` instruction
    will verify that component images are present on the Docker host. If not, it will
    build or pull them. If the images are not present, they should be downloaded,
    and that is what the Docker daemon will do.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这行，我们刚刚启动了我们的应用程序。重要的是要理解`docker-compose up`不仅仅执行所有组件。在这种情况下，我们首先构建了我们的组件，但是`docker-compose
    up`指令将验证组件映像是否存在于Docker主机上。如果不存在，它将构建或拉取它们。如果映像不存在，它们应该被下载，这就是Docker守护程序将要做的事情。
- en: 'The application should be running. Let''s verify the execution of all components.
    We will use `docker-compose ps` to obtain the application component status:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该正在运行。让我们验证所有组件的执行。我们将使用`docker-compose ps`来获取应用程序组件的状态：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take a look at the application component names. They are all created with the
    `simplest-lab` prefix, followed by `_` and the name used in the service definition.
    This is what we expected because we have not defined a project name. The directory
    name was used as the project name by default.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 查看应用程序组件名称。它们都使用`simplest-lab`前缀创建，后跟`_`和服务定义中使用的名称。这是我们预期的，因为我们还没有定义项目名称。默认情况下，目录名被用作项目名称。
- en: 'We can also see that component names end with `_`, followed by a number (in
    this case, `1`). This indicates the number of replicas we have for this component.
    We use more than one replica for some application components. Keep in mind that
    Docker Compose does not know anything about our application logic. Therefore,
    it is up to us to code this component to make it scalable. In our example, we
    have a three-layer application with three components: a simple load balancer,
    `lb`, an application''s backend, `app`, and a database component, `db`. We will
    not be able to scale up our database component because this will corrupt the database
    data. No more than one `postgres` process can use a specific set of data files,
    and this applies to our case. On the other hand, our `app` sample application
    component is prepared to run multiple times.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到组件名称以 `_` 结尾，后跟一个数字（在本例中为 `1`）。这表示我们为此组件有多个副本。我们对某些应用程序组件使用多个副本。请记住，Docker
    Compose 不了解我们应用程序的逻辑。因此，我们需要编写此组件以使其可伸缩。在我们的示例中，我们有一个三层应用程序，包括一个简单的负载均衡器 `lb`，一个应用程序后端
    `app` 和一个数据库组件 `db`。我们将无法扩展我们的数据库组件，因为这将破坏数据库数据。不超过一个 `postgres` 进程可以使用特定的数据文件集，这也适用于我们的情况。另一方面，我们的
    `app` 示例应用程序组件准备好多次运行。
- en: 'Let''s take a look at our application environment. By reviewing the output
    of `docker-compose ps`, we can see that only one component is exposing its service.
    We have only published the `lb`component. This is our application frontend (in
    fact, it is a load balancer component that will route traffic to different `app`
    component backends). If we open a web browser on `http://0.0.0.0:8080`, we will
    have a web application similar to the one shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的应用程序环境。通过查看 `docker-compose ps` 的输出，我们可以看到只有一个组件在暴露其服务。我们只发布了 `lb`
    组件。这是我们的应用程序前端（实际上，它是一个负载均衡器组件，将流量路由到不同的 `app` 组件后端）。如果我们在 `http://0.0.0.0:8080`
    上在Web浏览器中打开，我们将获得一个类似于以下截图中显示的Web应用程序：
- en: '![](img/6dade774-d569-4a90-ace9-8413d2c3bd7a.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dade774-d569-4a90-ace9-8413d2c3bd7a.jpg)'
- en: At this point, the application is already deployed. We can review the component
    logs using the service name with the `docker-compose logs` action. If we do not
    add a service name, we will be reviewing the logs of all the containers deployed
    with this `docker-compose.yaml` file. This is very useful because we will be able
    to review all their outputs from a single endpoint. Each component's log will
    appear in a different color to help us distinguish between them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，应用程序已经部署完成。我们可以使用服务名称和 `docker-compose logs` 命令来查看组件日志。如果不添加服务名称，我们将查看使用此
    `docker-compose.yaml` 文件部署的所有容器的日志。这非常有用，因为我们可以从单一端点查看所有输出。每个组件的日志将以不同的颜色显示，以帮助我们区分它们。
- en: 'For example, to review the database component log, we will use the following
    command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查看数据库组件日志，我们将使用以下命令：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is important to notice that the service name is the name defined in our `docker-compose.yaml`
    file. It is not the name of the service running.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，服务名称是我们 `docker-compose.yaml` 文件中定义的名称，而不是正在运行的服务名称。
- en: All `docker-compose` commands need a `docker-compose.yaml` file (or any other
    filename using the `--file` or `-f` options) and a project name (defined using
    the `--project` or `-p` options, or the current directory by default). These two
    parameters define the instances where all the `docker-compose` commands will be
    applied.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `docker-compose` 命令都需要一个 `docker-compose.yaml` 文件（或使用 `--file` 或 `-f` 选项指定的任何其他文件名）和一个项目名称（默认情况下使用
    `--project` 或 `-p` 选项定义，或者使用当前目录）。这两个参数定义了所有 `docker-compose` 命令将应用的实例。
- en: 'As we did with containers in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*, we can run a new process within the container''s
    process namespaces using `docker-compose exec`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 [第三章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml) 中处理容器时，*运行 Docker 容器*，我们可以使用
    `docker-compose exec` 在容器的进程命名空间内运行新的进程：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that it allocates a Terminal by default. Therefore, it is not necessary
    to use the `-t` and `-i` options.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下它分配一个终端。因此，不需要使用 `-t` 和 `-i` 选项。
- en: 'Using `docker-compose top`, we will obtain the consumption of each process
    on each container:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-compose top` 命令，我们将获取每个容器中每个进程的消耗情况：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s review some of the objects created by this multi-container deployment.
    We have a new network, with the name defined following the format we learned about
    previously; that is, `<project or directory name>_ <defined_network_name>`. We
    have not specified a special network type, so, by default, it is a bridge network,
    as expected. The output may vary in your environment, but the name for the newly
    deployed network will exist:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个多容器部署创建的一些对象。我们有一个新的网络，名称按照我们之前学过的格式定义；即，`<项目或目录名>_<定义的网络名>`。我们没有指定特定的网络类型，因此，默认情况下，它是一个桥接网络，符合预期。输出可能会在您的环境中有所不同，但新部署的网络名称将会存在：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that all custom bridge networks manage their own internal DNS resolution.
    As a result, all services (application components) deployed on the same network
    can be reached using their service names.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有自定义桥接网络都管理其自己的内部DNS解析。因此，在同一网络上部署的所有服务（应用组件）都可以通过它们的服务名称进行访问。
- en: 'The same occurs with our defined volumes. If we list our local volume, we will
    get a new volume following the same naming convention. The output may vary in
    your environment, but the name for the newly deployed volume will exist:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义的卷也会如此。如果列出本地卷，我们会得到一个新的卷，遵循相同的命名约定。输出可能会因您的环境而异，但新部署的卷名称将会存在：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can stop and start (or restart) any service defined in the `docker-compose.yaml`
    file using their names. The following action will restart all the instances of
    a defined service:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker-compose.yaml`文件中定义的服务名称来停止和启动（或重启）任何服务。以下操作将重启一个定义服务的所有实例：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s go back to the concept of instances. We can have more than one instance
    of a defined process for a service. This is the reason we have numbered all our
    instances. As we mentioned previously, the ability of a process to be scaled up
    or down is not defined in Docker. It is related to your application logic. In
    this example, we can scale up the number of instances of the `app` component.
    We can use `docker-compose scale` to change the number of instances (containers)
    for a defined application component:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实例的概念，我们可以为一个服务定义多个实例。这就是为什么我们给所有实例编号的原因。如前所述，进程是否能扩展并不是Docker定义的，它与您的应用逻辑相关。在这个例子中，我们可以扩展`app`组件的实例数量。我们可以使用`docker-compose
    scale`命令来改变某个定义的应用组件的实例（容器）数量：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the `scale` action is deprecated, so nowadays, we should use `docker-compose
    up --scale <service=number_of_instances>`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`scale`操作已被弃用，因此现在我们应该使用`docker-compose up --scale <service=number_of_instances>`。
- en: 'As a result, we now have five instances of the `app` application component.
    All the instances'' IP addresses are added to the internal DNS resolution. Therefore,
    we can resolve the service name to all the instances'' IP addresses in a round-robin
    sequence:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们现在有了五个`app`应用组件实例。所有实例的IP地址都被添加到了内部DNS解析中。因此，我们可以通过轮询的方式将服务名称解析到所有实例的IP地址：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we go back to the application GUI at `http://localhost:8080/`, we''ll notice
    that the chart has changed because the requests are now distributed across five
    different backends:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到应用程序的GUI界面`http://localhost:8080/`，会发现图表已经发生变化，因为请求现在已分配到五个不同的后端：
- en: '![](img/d6b7f950-71fd-4472-94ee-529dc36377d4.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6b7f950-71fd-4472-94ee-529dc36377d4.jpg)'
- en: In this chart, we can see that we now have five different IP addresses and that
    requests are distributed between them. Because we have been running the application
    for a long time (and automated requests are executed during this period), we have
    more requests for the first IP address (the first instance launched).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以看到现在有五个不同的IP地址，请求在它们之间分配。由于我们已经运行应用程序很长时间（期间自动化请求一直在执行），所以第一IP地址（启动的第一个实例）的请求会更多。
- en: 'We can remove previous data from the database using the Reset App Databutton.
    Let''s click this button and review the requests count. You can either wait for
    more requests (a new request is made every 5 seconds) or simply click the Make
    Requestbutton a few times. You should now have something similar to the following
    chart:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“Reset App Data”按钮从数据库中删除之前的数据。点击这个按钮后，查看请求计数。你可以选择等待更多请求（每5秒会生成一个新请求），或者直接点击“Make
    Request”按钮几次。现在，你应该看到类似于下面的图表：
- en: '![](img/d394fc35-5994-4d32-ba6c-128d21250caf.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d394fc35-5994-4d32-ba6c-128d21250caf.jpg)'
- en: 'This chart shows the request distribution of the five defined instances of
    the `app` component. Now, let''s scale down to three instances, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can review the `app` instances:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The chart will change again and only three backends will receive requests (there
    are only three running). Once again, we will use the Reset App Databutton and
    get a chart similar to the following one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9554c1c5-b383-4c91-946f-69df30db4cb9.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Take a quick look at the running containers associated with the deployed `docker-compose.yaml`
    application file. In this case, we are using a filter to obtain all the containers
    with names starting with the `simplest` pattern. We formatted the result to obtain
    only their names and labels:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98848394-2b35-45ff-a65a-605e71af5009.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Notice that `docker-compose` has added labels for each application component,
    indicating the name of the project, the container name, and the associated service
    name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily stop or kill a single component or all of them at once. We can
    also remove all the components using the `down` or `rm` options. Usually, we use
    `docker-compose down` because it is easier to remember. We can also define a timeout
    for components to stop using `stop_grace_period`, which defaults to 10 seconds
    (review the `docker-compose` file reference for available options at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)).
    Using `docker-compose down`, components will be removed once they are stopped:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s take a look at all the application-related objects. Here, we can see
    that `network` was removed but `volume` persists. This is because Docker does
    not know what to do with the volume. Are we going to use it later? Consequently,
    it is preferred not to delete the volume unless we use the `docker-compose down
    --volumes` (or `-v`) option to remove all the volumes associated with the application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this section, we have learned about all of the main `docker-compose` actions
    associated with the usual Docker workflow. In the next section, we will review
    some specific options for building images.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Customizing images with docker-compose
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building applications using `docker-compose` is very useful because we can use
    it for creating all the images in Docker Swarm or Kubernetes environments. We
    just need a `docker-compose` file definition and the application components' code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We have been using a static `docker-compose` file definition, but in many cases,
    we will use some variables to fulfill their values for specific needs. In fact,
    we could use variables in Dockerfiles as well, to complete the dynamic configurations
    at all levels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce some variables to our application''s `docker-compose.yaml`
    file (we do this to allow different behaviors):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You will find this file in [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
    as `docker-compose.dev.yaml`, along with all the other code files that were used
    in the previous section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
    找到这个文件，名为 `docker-compose.dev.yaml`，以及前一部分中使用的所有其他代码文件。
- en: 'First, we''ll review the definition configuration using the `docker-compose
    config` action:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `docker-compose config` 命令检查定义的配置：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These warnings and errors indicate that the following variables must be set:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告和错误表明，必须设置以下变量：
- en: '`dockerhubid`: By default, this will be empty.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerhubid`：默认情况下，此项为空。'
- en: '`LB_PORT`: This must be set to a port number because it is the one we will
    publish to consume the application.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LB_PORT`：必须设置为一个端口号，因为这是我们将发布用于消费应用程序的端口。'
- en: We need to have values for these variables. We can also use variables on Dockerfiles
    to add even more granularity. However, this is not the point here and we will
    not deep dive into Dockerfile variable usage again. For the Docker Certified Associate
    exam, it is important to know how to use variables to provide values to `docker-compose`
    deployments. We can use dynamic configurations with variables to deploy different
    projects using just one `docker-compose.yaml` file. This is very useful for building
    debugging images with developer tools, for example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这些变量设置值。我们还可以在 Dockerfile 中使用变量来添加更多的细节。然而，这不是我们要讨论的重点，我们也不会深入探讨 Dockerfile
    变量的使用。对于 Docker 认证助理考试，重要的是要了解如何使用变量为 `docker-compose` 部署提供值。我们可以使用带变量的动态配置，通过一个
    `docker-compose.yaml` 文件来部署不同的项目。例如，这在构建带有开发者工具的调试镜像时非常有用。
- en: 'Let''s set the `LB_PORT` and `dockerhubid` variables and review our project
    configuration once more:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 `LB_PORT` 和 `dockerhubid` 变量，并再次检查我们的项目配置：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The other variables have been left empty. We defined different configurations
    to provide some features for production, for example, using specific credentials:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其他变量尚未设置。我们定义了不同的配置，以提供一些生产环境功能，例如，使用特定的凭证：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we review the new build image, we will notice that it now has a new label
    and was created using `alpine:3.6` instead of the latest version:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看新的构建镜像，我们会注意到它现在有了一个新的标签，并且是使用 `alpine:3.6` 创建的，而不是使用最新版本：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With that, we have learned how we can prepare different environments using
    variables. With variables, we can use one `docker-compose.yaml` file for any stage
    in our environment. We have learned how to prepare a deployment for the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就学会了如何使用变量准备不同的环境。通过变量，我们可以使用一个 `docker-compose.yaml` 文件来适应环境中的任何阶段。我们已经学会了如何为以下内容准备部署：
- en: Development, using images with compilers or debugging utilities
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发环境，使用带有编译器或调试工具的镜像
- en: Tests, thereby adding tools to verify connectivity with third-party applications,
    for example
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，通过添加工具来验证与第三方应用程序的连接，例如
- en: Pre-production or integration, with libraries to execute load and performance
    tests before passing the application to production
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预生产或集成阶段，使用库执行负载和性能测试，在将应用程序推向生产环境之前
- en: The production stage, with only well-tested application components within images
    being tagged as `release`, for example
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产阶段，只有经过充分测试的应用程序组件才会在镜像中标记为 `release`，例如
- en: Docker Compose allows us to keep track of all configurations required for each
    stage with a YAML file. This file will be stored in our infrastructure as a code
    repository. Versioning will help us keep control of deployed applications in production.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 允许我们通过 YAML 文件跟踪每个阶段所需的所有配置。该文件将作为代码库存储在我们的基础设施中。版本控制将帮助我们在生产中控制已部署的应用程序。
- en: Automating your desktop and CI/CD with Docker Compose
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 自动化桌面和 CI/CD 流程
- en: Docker Compose allows us to easily develop on our own laptops. DevOps teams
    will provide complete application stack files, `docker-compose.yaml` files, along
    with all the required components and configurations. Developers do not have to
    learn how all the components work. They can focus on the component they are developing
    because the rest of the components will run automatically thanks to `docker-compose`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 让我们能够轻松地在自己的笔记本电脑上进行开发。DevOps 团队将提供完整的应用程序堆栈文件、`docker-compose.yaml`
    文件，以及所有必需的组件和配置。开发人员无需了解所有组件的工作原理。他们可以专注于自己正在开发的组件，因为其他组件将通过 `docker-compose`
    自动运行。
- en: We can use Docker Compose on a **Continuous Integration**/**C****ontinuous Deployment**
    (**CI**/**CD**) pipeline, building all the components at once.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose helps us build all the application components at the development
    stage, but we can also use this tool to run all the components together. CI/CD
    orchestrators will execute `docker-compose` files at different stages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: With the described steps and variables, it is easy to imagine how to implement
    a pipeline starting at the development stages and ending with the application
    in production. We would use different image tags in production, which are created
    by applying different variable values between environments.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that `docker-compose.yaml` files are key
    in **Infrastructure-as-Code** (**IaC**) environments. We need to store them and
    use version control systems. These files describe what application components
    will run and what resources they will use. We can add variables for an application's
    published ports, for example, to avoid port conflicts if we deploy a couple of
    applications using the same `docker-compose` files in the same host. We can also
    use the same `docker-compose` file for development and testing, as well as deploying
    applications to these environments. To avoid environment conflicts, we can use
    variables to define an application's component endpoints, such as databases or
    any connection chain that should be different between environments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Developers will use these files to launch the required application components
    on their laptops while they are developing new features or fixing code errors.
    They can focus on coding because they do not need to create complex infrastructures
    to test what they are coding. In fact, they do not need development infrastructures
    at all, as they can use their own computers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We will continue this chapter by reviewing some labs to help us understand and
    build on the concepts we've learned so far.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Chapter labs
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will deploy a simple lab to review the different steps described during this
    chapter. First, we will build the images required and will continue executing
    and scaling up components. We will use a CentOS Linux host with Docker Engine
    installed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Deploy `environments/standalone-environment`from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment`folder to start your virtual
    environment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `standalone-environment`, wait until it is running. We can
    check the node''s status using `vagrant status`. Connect to your lab node using
    `vagrant ssh standalone`. Now, `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now connect to the `standalone` node using `vagrant ssh standalone`.
    This process may vary if you deployed the `standalone` virtual node previously
    and you started it using `vagrant up`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you are reusing your `standalone-environment` instance, this means that
    Docker Engine is already installed. If you started a new instance, please execute
    the `/vagrant/install_requirements.sh` script to get access to all the required
    tools (Docker Engine and `docker-compose`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, you are ready to start the labs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Colors application lab
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start these labs by deploying a simple application that will run a small
    Python process. This process is a web server that was developed using Flask that
    will show a colored page (a random color, by default) with some information about
    the container name, its IP address, and the application version.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'All the files required for this lab can be found in the `Docker-Certified-Associate-DCA-Exam-Guide/chapter5`
    folder in this book''s GitHub repository at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
    Let''s get started:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by cloning our repository, navigating to our folder, and listing
    the files present inside the folder:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s quickly review the `docker-compose.random.yaml`file''s content:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is very simple. We defined a `random`service using the code contained in
    the `app` directory. We will expose container port `3000` to a random host one.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now build images using `lab1`as the project name. Notice that we defined
    the `lab` network. The Docker daemon will create a `lab1_random`image and the
    `lab1_lab`network:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we execute our multi-container application (in this case, we just have
    one service definition):'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s review the `docker-compose` project''s `lab1`execution:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that the application's port, `3000`, is linked to the Docker host port
    `32780` (using NAT).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the application via that random port; that is, `32780`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can use a web browser to access the running application. We can also use
    `curl` because the application is prepared to show a text response using the `/text`URI:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/570ea77a-ec62-4eda-9555-03b83433f418.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: A random color will be used. In this case, we get a blue page. It may vary in
    your environment because a random color will be chosen if the `COLOR` variable
    is not set.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: If you deployed the `random color` application using the provided `vagrant`
    standalone environment, you should use `192.168.56.11:<PUBLISHED_PORT>` in your
    browser because you are using a virtual machine. However, we prepared a host-to-virtual
    node interface (the `192.168.56.11` IP address).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now remove the application and continue to the next lab using `docker-compose
    down`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we will create a `red` application, defining a simple variable to change
    the application's behavior.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Executing a red application
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we will change the application's behavior by setting the `COLOR`
    environment variable. In this case, we will execute our `red` application. This
    new application can be deployed with just a few changes, which will help us integrate
    more components in the following labs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s execute a `red`application. In this case, we just change the service
    name and add an environment variable to define the backend color (a `COLOR` key
    and a `red` value). The following is the content of the `docker-compose.red.yaml`
    file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can reuse the `lab1` project name or create a new one. If we use `lab2`
    as the new project name, new tags will be added. Building it will not create new
    layers because we haven''t changed any code. We will simply use `docker-compose
    up -d`, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can review the deployment status using `docker-compose ps`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can easily access `0.0.0.0:32781` to access the `red`application using `curl`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let's try to scale up the number of application instances.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the red application's backends
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we will increase the number of application backends by scaling
    one of its components up using `docker-compose`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the new number of instances required for the application using `docker-compose
    scale`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that in this case, we are deploying a stateless application, without
    any persistence. There is something else to take note of in this case – we left
    the host-linked port unset. Therefore, a random one is always used for each container
    instance. Let''s review the new instance port number with `docker-compose ps`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can access all the instances. Each one is using its own NAT port, all
    of which are available in the Docker host. We can check this again using `curl`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All the IP addresses are different because we are accessing different containers.
    However, all of them are `red`, as expected.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove all the application instances:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the next lab, we will add more colors using a single file.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Adding more colors
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now increase our application's components by adding more colors.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add more color applications. In the `docker-compose.multicolor.yaml`
    file, we''ll add a couple of services, along with their own `COLOR` variables:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will launch our `red`, `green`, and `white` applications using `docker-compose
    up`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will be able to access different applications. Let''s review their processes
    and ports using `docker-compose ps` and then access each instance using `curl`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this situation, all application components are accessible using random published
    ports. We can use fixed ports to route users' requests to external load balancers,
    for example. We would not use random ports in production.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Note that the backend ports are dynamically associated with random ports. This
    allows us to run this application more than once without any `docker-compose`
    file changes. We will just need to use another project name to ensure the created
    objects' uniqueness.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add a simple load balancer to see some other deployment features.
    We will publish this load balancer, and other services will only be accessible
    through this component.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Adding a simple load balancer
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we will add a simple `nginx` load balancer to route traffic to
    different color backends.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the new deployment file:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice that we have removed all the color's service backends' ports. Now, we
    are just exposing port `8080`, which is linked to the internal `nginx` component's
    port; that is, port `80`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s launch the application deployment and review the results using `docker-compose
    up -d`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once all our components are ready, we can test all the color backends using
    different host headers to reach each backend. We prepared a simple `nginx` load
    balancing configuration for this (we''ve provided a quick review of the load balancer
    configuration file in `lb/nginx.conf`). Every time we ask for a specific host
    header using each color, we will be routed to the right backend:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using `curl`, we can test all the backends:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Remember, none of the services are accessible except `loadbalancer`. Let''s
    review the published ports using `docker-compose ps`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'What will happen if we scale up the `green` service to four instances? We expect
    to reach all the instances because the service instances will be added to the
    internal DNS. Let''s scale up this service using `docker-compose up -d`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s ask for the `green` service again using `curl`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we expected, we get different backends on each request because the DNS gave
    the load balancer a different backend IP address.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this lab, let''s install the `bind-tools`package on the `loadbalancer`
    container to query the internal DNS using the `host` tool. We will query the `red`
    and `green` services to verify the internal DNS resolution. This is key in application
    deployment when using components'' names. We will use `docker-compose exec` to
    install the `bind-tools`package in the `loadbalancer` container. Once the package
    is installed, we will use `docker-compose exec` again with the `host` command
    to query the DNS:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The internal DNS gave us all the IP addresses associated with the `green`and
    `red` services. Those are the associated containers' IP addresses. Therefore,
    our defined `green`service is load-balanced to all running `green`backends.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Remove all the labs using `docker-compose down` with the appropriate `docker-compose`
    file and project name.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered how to deploy multi-container applications on Docker hosts.
    We learned that the `docker-compose` command does not just deploy applications,
    but allows us to build and share all application components. Reviewing all the
    components'' statuses is also easier because `docker-compose` provides a command-line
    interface for retrieving all the application container''s standard and error outputs.
    We can start and stop all the components at once. But we can go even further than
    this: we are also able to scale the number of instances of each component up and
    down. This feature depends on our application logic because the Docker daemon
    does not know anything about our application processes.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: All application components are defined in a YAML-formatted file that can be
    customized using variables. We learned about the most important keys and their
    default values in this instance. The `docker-compose` file is key as it describes
    all the application components and its resources, as well as their interactions.
    Each component has its own version because we use images with their tags and arguments.
    We can also code versioning systems to be able to track `docker-compose` changes
    because this provides IaC information. We need to know exactly what application
    components are running in production, and Docker Compose allows us to apply release
    numbers to the files used for application deployments. This will ensure that the
    right application components are running. Introducing variables in these files
    allows us to use them at different development and deployment stages with only
    minor changes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, there are some questions that you can have a go at
    to consolidate your understanding of the topics that we've learned about in this
    chapter. The next chapter will teach us how to manage image ownership and content
    using Docker Content Trust.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these statements is not true?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Compose can run multi-service applications distributed on different
    services.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Compose can run multi-container applications on a Docker host.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Compose is a software application that is not installed with standard
    Docker packages.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above are true.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: What can we do with `docker-compose`?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We can build all application images.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: b) We can pull and push application component images.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: c) We can run all application components at once.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if we execute `docker-compose up` with a `docker-compose` file
    in which we have defined the frontend, backend, and database services? (Choose
    all of the correct statements out of the following options.)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Compose will look for all the services' defined images and will pull
    them if they are not present in the current host.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Compose will execute only images with the `start` key defined.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Compose will run all containers at once and your terminal will be
    attached to their standard and error outputs.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above are false.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: How can we use a `docker-compose` file to launch application services more than
    once?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) In actual fact, we cannot do that, but we can launch service process instances
    using the `scale` action. This service name will resolve to all replica IP addresses.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Compose will only execute images with the `start` key defined.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Compose will run all the containers at once, without any precedence.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above are false.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: What does the execution of `docker-compose down` do?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) It will stop all running containers associated with an application.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: b) It will try to stop all running containers associated with an application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: c) It will try to stop all running containers associated with an application.
    Once they're all stopped, it will remove them.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: d) It will try to stop all running containers associated with an application.
    Once they're all stopped, it will remove them, along with all of their associated
    resources, unless they were defined externally.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information regarding the topics
    that were covered in this chapter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Compose file reference: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose''s GitHub repository: [https://github.com/docker/compose.git](https://github.com/docker/compose.git)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose with Visual Studio Code: [https://code.visualstudio.com/docs/containers/docker-compose](https://code.visualstudio.com/docs/containers/docker-compose)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose samples: [https://github.com/dockersamples/example-voting-app](https://github.com/dockersamples/example-voting-app)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Compose releases: [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
