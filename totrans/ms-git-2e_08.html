<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor140" class="pcalibre1 pcalibre calibre6"/>6</h1>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor141" class="pcalibre1 pcalibre calibre6"/>Collaborative Development with Git</h1>
<p class="calibre3"><a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a><em class="italic">, Developing with Git</em>, and <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a><em class="italic">, Managing Your Worktrees</em>, taught you how to make new contributions to a project, but limited this information to affecting only your own clone of the project’s repository on your computer. <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a> described how to commit new revisions, while <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a> showed you how Git can help you prepare it.</p>
<p class="calibre3">This chapter and <a href="B21194_07.xhtml#_idTextAnchor172" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 7</em></a><em class="italic">, </em><em class="italic">Publishing Your</em><em class="italic"> Changes</em>, present a bird’s-eye view of the various ways to collaborate with others, showing centralized and distributed workflows. These two chapters will focus on the repository-level interactions in collaborative development, while the patterns of branches used will be covered in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced </em><em class="italic">Branching Techniques</em>.</p>
<p class="calibre3">This chapter describes different collaborative workflows, explaining the advantages and disadvantages of each one. You will also learn about the chain of trust concept and how to use <strong class="bold">signed tags</strong>, <strong class="bold">signed merges</strong>, and <strong class="bold">signed commits</strong>.</p>
<p class="calibre3">The following topics will be covered in this chapter:</p>
<ul class="calibre16">
<li class="calibre15">Centralized and distributed workflows, and bare repositories</li>
<li class="calibre15">Managing remotes and one-off single-shot collaboration</li>
<li class="calibre15">How versions are addressed—the chain of trust</li>
<li class="calibre15">Tagging; lightweight tags versus signed tags</li>
<li class="calibre15">Signed tags, signed merges, and signed commits</li>
</ul>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor142" class="pcalibre1 pcalibre calibre6"/>Collaborative workflows</h1>
<p class="calibre3">There are various levels of engagement while using a version control system. One might, for example, only be interested in using Git to examine how the project came to be. <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>,<em class="italic"> Exploring Project History</em>, and <a href="B21194_05.xhtml#_idTextAnchor113" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 5</em></a>, <em class="italic">Searching Through the Repository</em>, covered this use<a id="_idIndexMarker418" class="pcalibre1 pcalibre calibre6"/> of Git. Of course, examining a project’s history is an important part of development, too.</p>
<p class="calibre3">One might use version control for one’s private development, using it for a single developer project, on a single machine. <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>,<em class="italic"> Developing with Git</em>, and <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>,<em class="italic"> Managing Your </em><em class="italic">Worktrees</em>, show how to do this with Git. Of course, people usually don’t work in isolation, but in a team: one’s own development is usually part of a collaboration.</p>
<p class="calibre3">But one of the main goals of version control systems is to help multiple developers work together on a project, collaboratively. Version control makes it possible for them to work simultaneously on a given piece of software in an effective way, ensuring that their changes do not conflict with each other, and thus helping with merging those changes.</p>
<p class="calibre3">One might work on a project together with a few other developers, or with many. One might be a contributor, or a project maintainer. Maybe the project is so large that it needs subsystem maintainers. One might work in tight software teams, or one might want to make it easy for external contributors to provide proposed changes (for example, to fix bugs, or fix an error in the documentation). Various workflows might be best suited for those different situations:</p>
<ul class="calibre16">
<li class="calibre15">Centralized workflow</li>
<li class="calibre15">Peer-to-peer workflow</li>
<li class="calibre15">Maintainer workflow</li>
<li class="calibre15">Hierarchical workflow</li>
</ul>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor143" class="pcalibre1 pcalibre calibre6"/>Bare repositories</h2>
<p class="calibre3">There are two types of repositories:</p>
<ul class="calibre16">
<li class="calibre15">One <a id="_idIndexMarker419" class="pcalibre1 pcalibre calibre6"/>with a working<a id="_idIndexMarker420" class="pcalibre1 pcalibre calibre6"/> directory, and a staging area (<strong class="bold">non-bare</strong>)</li>
<li class="calibre15">A <strong class="bold">bare repository</strong>, without the <a id="_idIndexMarker421" class="pcalibre1 pcalibre calibre6"/>working directory</li>
</ul>
<p class="calibre3">The former type is meant for private solo development, and creating new history, while the latter is intended for collaboration and <a id="_idIndexMarker422" class="pcalibre1 pcalibre calibre6"/>synchronizing development results.</p>
<p class="calibre3">By convention, <code>.git</code> extension—for example, <code>project.git</code>—while <code>project</code> (with the administrative area <a id="_idIndexMarker423" class="pcalibre1 pcalibre calibre6"/>and the local repository in <code>project/.git</code>).</p>
<p class="calibre3">You can usually omit this extension when cloning the repository, pushing to it, or fetching from it; using either <code>https://github.com/git/git.git</code> as the repository URL or <a href="https://github.com/git/git" class="pcalibre1 pcalibre calibre6">https://github.com/git/git</a> will work the same.</p>
<p class="calibre3">To create the bare repository, you need to add the <code>--bare</code> option to the <code>git init</code> or <code>git clone</code> commands, as in the following example:</p>
<pre class="console">
$ git init --bare project.git
Initialized empty Git repository in /home/user/project.git/</pre>
<h2 id="_idParaDest-138" class="calibre7"><a id="_idTextAnchor144" class="pcalibre1 pcalibre calibre6"/>Interacting with other repositories</h2>
<p class="calibre3">After creating a set of revisions<a id="_idIndexMarker424" class="pcalibre1 pcalibre calibre6"/> and extending the project’s history, you usually need to share it with other developers. You need to synchronize with other repository instances: publish your changes, and get changes from others.</p>
<p class="calibre3">From the perspective of the local repository instance – your own clone of the repository – you need to <strong class="bold">push</strong> your changes to the repository meant for publishing changes and <strong class="bold">fetch</strong> changes from other repositories. Often the only repository you need to interact with is simply the repository you cloned from. <a href="B21194_07.xhtml#_idTextAnchor172" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 7</em></a>, <em class="italic">Publishing Your Changes,</em> will describe this process (and its alternatives) in more detail.</p>
<p class="calibre3">After fetching changes, you sometimes need to incorporate them into your work by <strong class="bold">merging</strong> two lines of development (or <strong class="bold">rebasing</strong>)—which <a id="_idIndexMarker425" class="pcalibre1 pcalibre calibre6"/>you can do in one operation with <strong class="bold">pull</strong>. Merging and rebasing operations will be described in more detail in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<p class="calibre3">Git assumes that you don’t want your local repository to be visible to the public, because these repositories are intended for private work (which helps to keep work not yet ready for the public<a id="_idIndexMarker426" class="pcalibre1 pcalibre calibre6"/> from being visible).</p>
<p class="calibre3">This means that there is an additional step required to make your finished work available: you need to <code>git </code><code>push</code> command.</p>
<p class="calibre3">The diagram in <em class="italic">Figure 6</em><em class="italic">.1</em>, which is an extension of the one in <em class="italic">Figure 2</em><em class="italic">.2</em> in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>,<em class="italic"> Developing with Git</em>, demonstrates the steps one can take when creating and publishing commits. The arrows in this diagram show the Git commands used to copy contents from one place to another, including to and from the remote repository.</p>
<div><div><img alt="Figure 6.1 – Creating commits, publishing commits, and fetching changes published by other developers into your local repository" src="img/B21194_06_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Creating commits, publishing commits, and fetching changes published by other developers into your local repository</p>
<p class="calibre3">Now, let us understand the centralized wo<a id="_idTextAnchor145" class="pcalibre1 pcalibre calibre6"/>rkflow.</p>
<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor146" class="pcalibre1 pcalibre calibre6"/>The centralized workflow</h2>
<p class="calibre3">With distributed version <a id="_idIndexMarker427" class="pcalibre1 pcalibre calibre6"/>control systems, you can use<a id="_idIndexMarker428" class="pcalibre1 pcalibre calibre6"/> different collaboration models, some more distributed, some less distributed. In a <strong class="bold">centralized workflow</strong>, there is one central hub: a shared repository, usually bare, that everyone uses to synchronize their work.</p>
<div><div><img alt="Figure 6.2 – Centralized workflow – the shared repository is bare" src="img/B21194_06_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Centralized workflow – the shared repository is bare</p>
<p class="calibre3">In this workflow, each developer has their own <strong class="bold">non-bare clone</strong> of the central shared repository, which they use to develop new revisions of software. When changes are ready, they push those changes to the central repository, and fetch (or pull) changes from other developers <a id="_idIndexMarker429" class="pcalibre1 pcalibre calibre6"/>from it. One might have to<a id="_idIndexMarker430" class="pcalibre1 pcalibre calibre6"/> merge changes before being able to push. In this workflow integration of changes is distributed. This workflow is shown in <em class="italic">Figure 6</em><em class="italic">.2</em>.</p>
<p class="calibre3">Let us now look into the advantages and disadvantages of a <em class="italic">centralized workflow</em>.</p>
<h3 class="calibre9">Advantages of a centralized workflow</h3>
<p class="calibre3">Some of the key advantages of <a id="_idIndexMarker431" class="pcalibre1 pcalibre calibre6"/>centralized workflows include the following:</p>
<ul class="calibre16">
<li class="calibre15">This workflow has a simple setup; it is a familiar paradigm for people coming from centralized version control systems and used to working with centralized management. It provides centralized access control and easy backups.</li>
<li class="calibre15">It makes it easy to<a id="_idIndexMarker432" class="pcalibre1 pcalibre calibre6"/> set up <strong class="bold">continuous </strong><strong class="bold">integration</strong> (<strong class="bold">CI</strong>).</li>
<li class="calibre15">The process of merging changes is shared among developers, with no person solely responsible for integrating changes.</li>
<li class="calibre15">It might be a good setup for a private project with a small team, or where all developers are trusted and capable.</li>
</ul>
<h3 class="calibre9">Disadvantages of a centralized workflow</h3>
<p class="calibre3">Some of the disadvantages of <a id="_idIndexMarker433" class="pcalibre1 pcalibre calibre6"/>centralized workflows are as follows:</p>
<ul class="calibre16">
<li class="calibre15">The shared repository is a single point of failure: if there are problems with the central repository, then there is no way to synchronize changes.</li>
<li class="calibre15">Each developer pushing changes (making them available for other developers) might require updating one’s own repository first, and merging changes from others. Shared integration means that each developer needs to know how to do it.</li>
<li class="calibre15">You also need to trust developers with access to the shared repository in this setup, or to provide acc<a id="_idTextAnchor147" class="pcalibre1 pcalibre calibre6"/>ess controls.</li>
</ul>
<h2 id="_idParaDest-140" class="calibre7"><a id="_idTextAnchor148" class="pcalibre1 pcalibre calibre6"/>The peer-to-peer or forking workflow</h2>
<p class="calibre3">The opposite of a centralized workflow is a <strong class="bold">peer-to-peer</strong> or <strong class="bold">forking workflow</strong>. Instead of using a single <a id="_idIndexMarker434" class="pcalibre1 pcalibre calibre6"/>central shared public<a id="_idIndexMarker435" class="pcalibre1 pcalibre calibre6"/> repository, each developer has a public repository (which is<a id="_idIndexMarker436" class="pcalibre1 pcalibre calibre6"/> bare), in addition to a private working repository (with a working directory), like in the <em class="italic">Figure 6</em><em class="italic">.3</em>.</p>
<div><div><img alt="Figure 6.3 – Peer-to-peer workflow – here, lines pointing up represent push operation, while lines pointing down represent fetch/pull operation" src="img/B21194_06_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Peer-to-peer workflow – here, lines pointing up represent push operation, while lines pointing down represent fetch/pull operation</p>
<p class="calibre3">When the changes are ready, developers push to their own public repositories. To incorporate changes from other developers, one needs to fetch them from the public repositories of each of the other developers.</p>
<p class="calibre3">The advantages and <a id="_idIndexMarker437" class="pcalibre1 pcalibre calibre6"/>disadvantages<a id="_idIndexMarker438" class="pcalibre1 pcalibre calibre6"/> of this rarely used peer-to-peer workflow, also called forking<a id="_idIndexMarker439" class="pcalibre1 pcalibre calibre6"/> workflow, are as follows:</p>
<h3 class="calibre9">Advantages of the peer-to-peer workflow</h3>
<ul class="calibre16">
<li class="calibre15">One advantage of the<a id="_idIndexMarker440" class="pcalibre1 pcalibre calibre6"/> forking workflow is that contributions can be integrated without the need for a central repository; it is a fully distributed workflow</li>
<li class="calibre15">Another advantage is that you are not forced to integrate if you want to publish your changes; you can merge at your leisure</li>
<li class="calibre15">It is a good workflow for organic teams without requiring much setup</li>
</ul>
<h3 class="calibre9">Disadvantages of the peer-to-peer workflow</h3>
<ul class="calibre16">
<li class="calibre15">The disadvantages are a lack of the canonical version, no centralized management, and the<a id="_idIndexMarker441" class="pcalibre1 pcalibre calibre6"/> fact that in the basic form of this workflow you need to interact with many repositories. Though the <strong class="source-inline1">git remote update</strong> or <strong class="source-inline1">git fetch --multiple</strong> commands can help here by doing multiple fetches with a single command.</li>
<li class="calibre15">Setting up this workflow requires developers’ public repositories to be reachable from other<a id="_idIndexMarker442" class="pcalibre1 pcalibre calibre6"/> developers’ workstations, which might not be as easy as using one’s own machine as a server for one’s public repositories</li>
<li class="calibre15">Also, as can be seen in <em class="italic">Figure 6</em><em class="italic">.3</em>, collaboration gets more complicated with the growing number of developers; this workflo<a id="_idTextAnchor149" class="pcalibre1 pcalibre calibre6"/>w does not scale well</li>
</ul>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor150" class="pcalibre1 pcalibre calibre6"/>The maintainer or integration manager workflow</h2>
<p class="calibre3">One of the problems with <a id="_idIndexMarker443" class="pcalibre1 pcalibre calibre6"/>peer-to-peer workflows is that there is no canonical version of a project, something that non-developers can use. Another is that each developer has to do their own integration (which was <a id="_idIndexMarker444" class="pcalibre1 pcalibre calibre6"/>also the case for the centralized workflow). If we promote one of the public repositories in <em class="italic">Figure 6</em><em class="italic">.3</em> to be the canonical (official) repository and make one of the developers responsible for integration, we arrive at the <strong class="bold">integration manager workflow</strong> (or <strong class="bold">maintainer workflow</strong>). The<a id="_idIndexMarker445" class="pcalibre1 pcalibre calibre6"/> following diagram shows this workflow, with bare repositories at the top and non-bare at the bottom.</p>
<div><div><img alt="Figure 6.4 – Integration-manager (maintainer) workflow – lines pointing up are push operations, while lines pointing down are fetch operations" src="img/B21194_06_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Integration-manager (maintainer) workflow – lines pointing up are push operations, while lines pointing down are fetch operations</p>
<p class="calibre3">In this workflow, when <a id="_idIndexMarker446" class="pcalibre1 pcalibre calibre6"/>changes are ready, the developer pushes those changes to their own public repository and tells the maintainer (for example, via a <strong class="bold">pull request</strong>) that they are ready. The <strong class="bold">maintainer</strong> pulls changes from the <a id="_idIndexMarker447" class="pcalibre1 pcalibre calibre6"/>developer’s repository into their own working repository and integrates the changes. Then the maintainer pushes the merged changes to the <strong class="bold">“blessed” repository</strong>, for all to see, making them available to be fetched.</p>
<p class="calibre3">The advantages and disadvantages are as follows:</p>
<h3 class="calibre9">Advantages of the integration manager workflow</h3>
<ul class="calibre16">
<li class="calibre15">The advantages are<a id="_idIndexMarker448" class="pcalibre1 pcalibre calibre6"/> having an official version of a project, and that developers can continue to work without doing or waiting for integration, as maintainers can pull their changes at any time.</li>
<li class="calibre15">It is a good workflow for a large organic team, as in open source projects.</li>
<li class="calibre15">The fact that the blessed repository is decided by social consensus makes it easy to switch to other maintainers, either temporarily (for example, when one maintainer takes some time off) or permanently (such as when forking a project), without the need to hand out access rights.</li>
<li class="calibre15">This setup makes it easy for a smaller group of developers to collaborate by simply denoting one of the repositories in the group as the one to fetch from. The dotted<a id="_idIndexMarker449" class="pcalibre1 pcalibre calibre6"/> line in <em class="italic">Figure 6</em><em class="italic">.4</em> shows this possibility of fetching from a non-official repository.</li>
</ul>
<h3 class="calibre9">Disadvantages of the integration manager workflow</h3>
<ul class="calibre16">
<li class="calibre15">The primary <a id="_idIndexMarker450" class="pcalibre1 pcalibre calibre6"/>disadvantage is that the ability of the maintainer to integrate changes can be a bottleneck (as opposed to the centralized workflow, with distributed integration).<p class="calibre3">This can happen especially for large teams and large projects. Thus, for very large organic teams, such as in Linux kernel development, it is better to use the hierarchical workflow, described in the next section.</p></li>
<li class="calibre15">There needs to be dedicated person that does the merging and is responsible for the state of the “<em class="italic">blessed</em>” repository.</li>
<li class="calibre15">Another disadvantage is that it is more difficult to set up continuous integration than in the cent<a id="_idTextAnchor151" class="pcalibre1 pcalibre calibre6"/>ralized repository workflow.</li>
</ul>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor152" class="pcalibre1 pcalibre calibre6"/>The hierarchical or dictator-and-lieutenants workflow</h2>
<p class="calibre3">The <strong class="bold">hierarchical workflow</strong> is a variant of the blessed repository workflow, generally used in huge projects with hundreds of collaborators. In this workflow, the project maintainer (sometimes<a id="_idIndexMarker451" class="pcalibre1 pcalibre calibre6"/> called the <strong class="bold">benevolent dictator</strong>) is<a id="_idIndexMarker452" class="pcalibre1 pcalibre calibre6"/> accompanied by additional integration managers, usually in charge of certain parts of the repository (subsystems). They are<a id="_idIndexMarker453" class="pcalibre1 pcalibre calibre6"/> called <strong class="bold">lieutenants</strong>. The benevolent <a id="_idIndexMarker454" class="pcalibre1 pcalibre calibre6"/>dictator’s public repository serves as the <em class="italic">blessed</em> reference repository from which all the collaborators need to pull. Lieutenants pull from developers and the maintainer pulls from the lieutenants, as shown in <em class="italic">Figure 6</em><em class="italic">.5</em>. (Note that in the following diagram, repositories shown with dashed patterns are actually pairs of private and public repositories of a developer or a lieutenant).</p>
<div><div><img alt="Figure 6.5 – Dictator and lieutenants workflow (hierarchical workflow)" src="img/B21194_06_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Dictator and lieutenants workflow (hierarchical workflow)</p>
<p class="calibre3">In a <strong class="bold">dictator</strong> <strong class="bold">and</strong> <strong class="bold">lieutenants</strong> workflow, there is a hierarchy (a network) of repositories. Before <a id="_idIndexMarker455" class="pcalibre1 pcalibre calibre6"/>starting work, either development or merging, one would usually pull updates from the canonical <strong class="bold">(blessed) repository</strong> for a project.</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Developers</strong> prepare changes in their own private repository, then send changes to an appropriate subsystem maintainer (lieutenant).<p class="calibre3">Changes can be sent as patches in email, or by pushing them to the <strong class="bold">developer’s</strong> public repository and sending a pull request to an appropriate integration manager (appropriate subsystem maintainer).</p></li>
<li class="calibre15"><strong class="bold">Lieutenants</strong> are<a id="_idIndexMarker456" class="pcalibre1 pcalibre calibre6"/> responsible for merging changes in their respective areas of responsibility.</li>
<li class="calibre15">The master maintainer (<strong class="bold">dictator</strong>) pulls from the lieutenants (and occasionally directly from developers). The <strong class="bold">dictator</strong> is also responsible for pushing merged changes to the reference (canonical) repository, and usually also for release management (for <a id="_idIndexMarker457" class="pcalibre1 pcalibre calibre6"/>example, creating tags for releases).</li>
</ul>
<p class="calibre3">An overview of the advantages and disadvantages of this workflow follows.</p>
<h3 class="calibre9">Advantages of the hierarchical workflow</h3>
<ul class="calibre16">
<li class="calibre15">The advantage of this<a id="_idIndexMarker458" class="pcalibre1 pcalibre calibre6"/> workflow is that it allows the project leader (the dictator) to delegate much of the integration work.</li>
<li class="calibre15">This can be useful in very big projects (concerning the number of developers and/or changes), or in highly hierarchical environments. Such a workflow is used, for example, to develop the Linux kernel.</li>
</ul>
<h3 class="calibre9">Disadvantages of the hierarchical workflow</h3>
<ul class="calibre16">
<li class="calibre15">Its complicated setup is<a id="_idIndexMarker459" class="pcalibre1 pcalibre calibre6"/> a disadvantage of this workflow. It is usually overkill for an ordinary project.</li>
<li class="calibre15">Almost all other disadvantages of the integration manager workflow are present in this workflow, which is its more complex variant.</li>
</ul>
<p class="calibre3">Which workflow to choose, and how to set up repositories, depend on how the project is developed. You need to decide which drawbacks are acceptable and which advantages matter <a id="_idIndexMarker460" class="pcalibre1 pcalibre calibre6"/>most.</p>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor153" class="pcalibre1 pcalibre calibre6"/>Managing remote repositories</h1>
<p class="calibre3">When collaborating on <a id="_idIndexMarker461" class="pcalibre1 pcalibre calibre6"/>any project managed with Git, you will interact often with a constant set of other repositories. For example, using the integration-manager workflow will involve (at least) the canonical blessed repository of a project. In many cases, you will interact with more than one remote repository.</p>
<p class="calibre3">Git allows us to save the information about a remote repository (or just <code>git </code><code>remote</code> command.</p>
<p class="callout-heading">Legacy mechanisms for storing remote repository information</p>
<p class="callout">There are also two legacy mechanisms to store the information about remote repositories.</p>
<p class="callout">This first is a named file in <strong class="source-inline1">.git/remotes</strong>—the name of this file will be the nickname of the remote. This file can contain information about the URL or URLs, and fetch and push refspecs.</p>
<p class="callout">The second is a named file in <strong class="source-inline1">.git/branches</strong>—the name of this file will also be the nickname of the remote. The contents of this file are just a URL for the repository, optionally followed by <strong class="source-inline1">#</strong> and the branch name.</p>
<p class="callout">Neither of those mechanisms is likely to be found in modern repositories. See the <em class="italic">Remotes</em> section in the <strong class="source-inline1">git-fetch(1)</strong> manpage for more details.</p>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor154" class="pcalibre1 pcalibre calibre6"/>The “origin” remote</h2>
<p class="calibre3">When cloning a repository, Git will create one remote for you—the <strong class="bold">origin remote</strong>, which stores<a id="_idIndexMarker462" class="pcalibre1 pcalibre calibre6"/> information about where you cloned from—that is the origin of your copy of the repository (hence the name). You can use this remote to fetch updates.</p>
<p class="calibre3">This is the default remote; for example, <code>git fetch</code> without the remote name will use the origin remote. You <a id="_idIndexMarker463" class="pcalibre1 pcalibre calibre6"/>can change this using the <code>remote.default</code> configuration variable on a per-repository basis, or you can set up a default remote differently for a given branch with <code>branch.&lt;branchname&gt;.remote</code>.</p>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor155" class="pcalibre1 pcalibre calibre6"/>Listing and examining remotes</h2>
<p class="calibre3">To see which remote <a id="_idIndexMarker464" class="pcalibre1 pcalibre calibre6"/>repositories you have configured, you can run the <code>git remote</code> command. It lists the short names of each remote you’ve got. In a<a id="_idIndexMarker465" class="pcalibre1 pcalibre calibre6"/> cloned repository you will have at least one remote named <code>origin</code>:</p>
<pre class="console">
$ git remote
origin</pre>
<p class="calibre3">To see the URL together with remotes, you can use the <code>-v</code> or <code>--</code><code>verbose</code> options:</p>
<pre class="console">
$ git remote --verbose
origin  https://github.com/git/git.git (fetch)
origin  https://github.com/git/git.git (push)</pre>
<p class="calibre3">From the output of this command, you can easily guess that the fetch and push URLs can be <a id="_idIndexMarker466" class="pcalibre1 pcalibre calibre6"/>different (in a so-called <strong class="bold">triangular workflow</strong>).</p>
<p class="calibre3">If you want to inspect remotes to see more information about a particular remote, you can use the <code>git remote show &lt;</code><code>remote&gt;</code> subcommand:</p>
<pre class="console">
$ git remote show origin
remote origin
  Fetch URL: https://github.com/git/git.git
  Push  URL: https://github.com/git/git.git
  HEAD branch: master
  Remote branches:
    maint  tracked
    master tracked
    next   tracked
    pu     tracked
    todo   tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)</pre>
<p class="calibre3">Git will consult the remote <a id="_idIndexMarker467" class="pcalibre1 pcalibre calibre6"/>configuration, the branch configuration, and the remote repository itself (for <a id="_idIndexMarker468" class="pcalibre1 pcalibre calibre6"/>an up-to-date status). If you want to skip contacting the remote repository and use cached information instead, add the <code>-n</code> option to <code>git remote show</code>. If there is no internet connection,and you did not use <code>'-n'</code> option, Git will tell you that it was unable to contact the repository.</p>
<p class="calibre3">As the information about remotes is stored in the repository configuration file, you can simply examine <code>.git/config</code>:</p>
<pre class="source-code">
[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*
    url = git://git.kernel.org/pub/scm/git/git.git</pre>
<p class="calibre3">The difference between local and <a id="_idIndexMarker469" class="pcalibre1 pcalibre calibre6"/>remote branches (and <code>+refs/heads/*:refs/remotes/origin/*</code> . You can see it in the second line in the preceding example.</p>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor156" class="pcalibre1 pcalibre calibre6"/>Adding a new remote</h2>
<p class="calibre3">To add a new remote Git repository and to<a id="_idIndexMarker472" class="pcalibre1 pcalibre calibre6"/> store its information under a short name, run <code>git remote add &lt;</code><code>shortname&gt; &lt;URL&gt;</code>:</p>
<pre class="console">
$ git remote add alice \
  https://git.company.com/alice/random.git</pre>
<p class="calibre3">Adding remote doesn’t fetch from it automatically—you need to use the <code>-f</code> option for that (or run <code>git fetch &lt;</code><code>shortname&gt;</code> afterwards).</p>
<p class="calibre3">This command has a few options that affect how Git creates a new remote. You can select which branches in the remote repository you are interested in with the <code>-t &lt;branch&gt;</code> option. You can change which branch is the default one in the remote repository (and which you can refer to by the remote name) using the <code>-m &lt;branch&gt;</code> option; otherwise, it would be the current branch in the remote repository. You can fetch all tags or no tags with <code>--tags</code> or <code>--no-tags</code>, respectively; otherwise, only tags on fetched branches would be imported. Or you can configure the remote repository for mirroring rather than for collaboration with <code>--mirror=push</code> or <code>--mirror=fetch</code>.</p>
<p class="calibre3">For example, running the following command:</p>
<pre class="console">
$ git remote add -t master -t next -t maint github \
  https://github.com/jnareb/git.git</pre>
<p class="calibre3">will result in the following configuration of the remote:</p>
<pre class="source-code">
[remote "github"]
    url = https://github.com/jnareb/git.git
    fetch = +refs/heads/master:refs/remotes/github/master
    fetch = +refs/heads/next:refs/remotes/github/next
    fetch = +refs/heads/maint:refs/remotes/github/maint</pre>
<h2 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor157" class="pcalibre1 pcalibre calibre6"/>Updating information about remotes</h2>
<p class="calibre3">The information about<a id="_idIndexMarker473" class="pcalibre1 pcalibre calibre6"/> the remote repository is stored in three places:</p>
<ul class="calibre16">
<li class="calibre15">In the remote configuration: <strong class="source-inline1">remote.&lt;remote</strong><strong class="source-inline1"> name&gt;</strong>,</li>
<li class="calibre15">In remote-tracking branches and in the remote-HEAD (<strong class="source-inline1">refs/remotes/&lt;remote name&gt;/HEAD</strong>)</li>
<li class="calibre15">And optionally, in the per-branch configuration: <strong class="source-inline1">branch.&lt;branch name&gt;</strong></li>
</ul>
<p class="calibre3">The remote-HEAD is a symbolic <a id="_idIndexMarker474" class="pcalibre1 pcalibre calibre6"/>reference (<code>symref</code>) that defines the <code>&lt;remote name&gt;</code> refers to when used as a branch name, such as in the command <code>'git log &lt;</code><code>remote name&gt;'</code>.</p>
<p class="calibre3">You could manipulate this information directly—either by editing the appropriate files or using manipulation commands such as <code>git config</code> and <code>git symbolic-ref</code>—but Git provides various <code>git remote</code> subcommands for this.</p>
<h3 class="calibre9">Renaming remotes</h3>
<p class="calibre3">Renaming the<a id="_idIndexMarker475" class="pcalibre1 pcalibre calibre6"/> remote—that is, changing its nickname—is quite a complicated operation. Running <code>git remote rename &lt;old&gt; &lt;new&gt;</code> will not only change the section name in <code>remote.&lt;old&gt;</code>, but also the remote-tracking branches and accompanying <code>refspec</code>, their reflogs (if there are any—see the <code>core.logAllRefUpdates</code> configuration variable), and the respective branch configurations.</p>
<h3 class="calibre9">Changing the remote URLs</h3>
<p class="calibre3">You can add or replace the URL for a remote with <code>git remote set-url</code>, but it is also quite easy to simply directly edit the configuration.</p>
<p class="calibre3">You can also use the <code>insteadOf</code> (and <code>pushInsteadOf</code>) configuration variables. This can be useful if you want to temporarily use another server, for example, if the canonical repository is<a id="_idIndexMarker476" class="pcalibre1 pcalibre calibre6"/> temporarily down. Say that you want to fetch Git from the repository on GitHub, because <a href="https://www.kernel.org" class="pcalibre1 pcalibre calibre6">https://www.kernel.org</a> that you cloned Git from is down. You can do this by adding the following text to the config file:</p>
<pre class="source-code">
[url "https://github.com/git/git.git"]
    insteadOf = git://git.kernel.org/pub/scm/git/git.git</pre>
<p class="calibre3">Another use case for this feature is handling repository migration. You can use <code>insteadOf</code> rewriting in the per-user configuration file, that is, in <code>~/.gitconfig</code> (or <code>~/.config/git/config</code>), without having to change the URL in each and every repository’s <code>.git/config</code> file. In the case of more than one match, the longest match is used.</p>
<p class="callout-heading">Tip – multiple URLs for a remote</p>
<p class="callout">You can set multiple URLs for a remote. Git will try all these URLs sequentially when fetching and use the first one that works. When pushing, Git will publish to all URLs (all servers) simultaneously.</p>
<h3 class="calibre9">Changing the list of branches tracked by remote</h3>
<p class="calibre3">A similar situation to <a id="_idIndexMarker477" class="pcalibre1 pcalibre calibre6"/>changing the URL occurs when changing the list of branches tracked by a remote (that is, the contents of <code>fetch</code> lines). You can use <code>git remote set-branches</code> (with a sufficiently modern Git client) or edit the config file directly.</p>
<p class="callout-heading">Note – stale remote-tracking branches</p>
<p class="callout">Freeing a branch in a remote repository from being tracked does not remove the remote-tracking branch—the latter is simply no longer updated on fetch. This is explained in more detail in the <em class="italic">Deleting remote-tracking branches and remotes</em> section later in this chapter, which describes how to prune remote-tracking branches that correspond to <a id="_idIndexMarker478" class="pcalibre1 pcalibre calibre6"/>branches deleted in remote the repository.</p>
<h3 class="calibre9">Setting the default branch of the remote</h3>
<p class="calibre3">Having a <code>origin</code>) instead of a <a id="_idIndexMarker479" class="pcalibre1 pcalibre calibre6"/>specific remote-tracking branch (for example, <code>origin/master</code>). This information is stored in the symbolic ref <code>&lt;remote name&gt;/HEAD</code> (for example, <code>origin/HEAD</code>).</p>
<p class="calibre3">You can set this with <code>git remote set-head</code> command. The <code>--auto</code> option does that based on what the current branch in the remote repository is:</p>
<pre class="console">
$ git remote set-head origin master
$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/master</pre>
<p class="calibre3">You can delete the default branch on the remote with the <code>--</code><code>delete</code> option.</p>
<h3 class="calibre9">Deleting remote-tracking branches and remotes</h3>
<p class="calibre3">When a public branch<a id="_idIndexMarker480" class="pcalibre1 pcalibre calibre6"/> is deleted in the remote repository, Git nevertheless keeps the corresponding remote-tracking branch. It does that because you might want to do, or might<a id="_idIndexMarker481" class="pcalibre1 pcalibre calibre6"/> have already done, your own work on top of it. You can, however, delete the remote-tracking branch with <code>git branch -r -d</code>, or you can ask Git to prune all stale remote-tracking branches under the remote with <code>git remote prune</code>. You can configure Git to do this automatically on every fetch, as if <code>git fetch</code> were run with the <code>--prune</code> option, by setting the <code>fetch.prune</code> and/or <code>remote.&lt;name&gt;.prune</code> configuration variables (the latter on a per-remote basis).</p>
<p class="calibre3">You can check which remote-tracking branches are stale with the <code>--dry-run</code> option to <code>git remote prune</code>, or with the <code>git remote </code><code>show</code> command.</p>
<p class="calibre3">Deleting remote is as simple as running <code>git remote delete</code> (or its alias, <code>git remote rm</code>). It also removes remote-tracking branches for the deleted remote.</p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor158" class="pcalibre1 pcalibre calibre6"/>Support for triangular workflows</h2>
<p class="calibre3">In many collaborative<a id="_idIndexMarker482" class="pcalibre1 pcalibre calibre6"/> workflows, such as the maintainer (or integration manager) workflow, you fetch from one URL (from the blessed repository), but push to another URL (to your own public repository).</p>
<p class="calibre3">As shown in <em class="italic">Figure 6</em><em class="italic">.4</em>, the developer interacts with three repositories: they fetch from the <strong class="bold">blessed</strong> repository (top left) into their own private repository (darker, at the bottom), then push their work into their own public repository (lighter, at the top).</p>
<p class="calibre3">In such a <code>origin</code> remote (or <code>remote.default</code>). One option for configuring which repository you push to is to add this repository as a separate remote, and perhaps also set it up <a id="_idIndexMarker484" class="pcalibre1 pcalibre calibre6"/>as the default with <code>remote.pushDefault</code>:</p>
<pre class="source-code">
[remote "origin"]
    url = https://git.company.com/project 
    fetch = +refs/heads/*:refs/remotes/origin/* 
[remote "myown"] 
    url = git@work.company.com:user/project
fetch = +refs/heads/*:refs/remotes/myown/* 
[remote]
    pushDefault = myown</pre>
<p class="calibre3">You could also set it as <code>pushRemote</code> in the per-branch configuration:</p>
<pre class="source-code">
[branch "master"]
    remote = origin
    pushRemote = myown
    merge = refs/heads/master</pre>
<p class="calibre3">Another option is to use a single remote (perhaps even <code>origin</code>) but set it up with a separate <code>pushurl</code>. This solution, however, has the slight disadvantage that you don’t have separate remote-tracking branches for the push repository (and thus there is no support <code>@{push}</code> notation in addition to having <code>@{upstream}</code> as a shortcut for specifying the appropriate remote-tracking branches):</p>
<pre class="source-code">
[remote "origin"]
    url = https://git.company.com/project
    pushurl = git@work.company.com:user/project
    fetch = +refs/heads/*:refs/remotes/origin/*</pre>
<p class="calibre3">Having separate remote-tracking branches for the push repository allows you to track which branches were<a id="_idIndexMarker485" class="pcalibre1 pcalibre calibre6"/> pushed<a id="_idTextAnchor159" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor160" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor161" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor162" class="pcalibre1 pcalibre calibre6"/> to the push remote, and which have local unpublished changes.</p>
<h1 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor163" class="pcalibre1 pcalibre calibre6"/>Chain of trust</h1>
<p class="calibre3">An important part of collaborative efforts during the development of a project is ensuring the quality of its code. This includes protection against the accidental corruption of the repository, and <a id="_idIndexMarker486" class="pcalibre1 pcalibre calibre6"/>also from <strong class="bold">malicious intent</strong>—a task that the version control system can help with. Git needs to ensure trust in the repository contents: both your own and other developers’ (especially trust in the canonical repository of the project).</p>
<h2 id="_idParaDest-150" class="calibre7"><a id="_idTextAnchor164" class="pcalibre1 pcalibre calibre6"/>Content-addressed storage</h2>
<p class="calibre3">In <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>,<em class="italic"> Exploring Project History</em>, in the <em class="italic">SHA-1 and the shortened SHA-1 identifier</em> section, we learned that <a id="_idIndexMarker487" class="pcalibre1 pcalibre calibre6"/>Git currently uses SHA-1 hashes as a native identifier of commit objects (which represent revisions of the project and form the project’s history). This mechanism makes it possible to generate commit identifiers in a distributed way, taking a cryptographic hash of the commit object. This hash is then used to link to the previous commit (to the parent commit or commits).</p>
<p class="calibre3">Moreover, all other data stored in the repository (including the file contents in the revision represented by the blob objects, and the file hierarchy represented by the tree objects) also use the same mechanism. All types of object are addressed by their contents, or to be more accurate, the hash function of the object. You can say that the base of a Git repository is the <em class="italic">content-addressed </em><em class="italic">object database</em>.</p>
<p class="calibre3">Thus, Git provides a built-in <strong class="bold">trust chain</strong> through secure SHA-1 hashes, via a kind of a hash tree, also known as a Merkle tree. In one<a id="_idIndexMarker488" class="pcalibre1 pcalibre calibre6"/> dimension, the SHA-1 hash of a commit depends on its contents, which includes the SHA-1 hash of the parent commit or commits, which depends on the contents of the parent commit, and so forth down to the initial root commit. In the other dimension, the content of a commit object includes the SHA-1 hash of the tree representing the top directory of a project, which in turn depends on its contents, and<a id="_idIndexMarker489" class="pcalibre1 pcalibre calibre6"/> these contents include the SHA-1 hash of the subdirectory trees and blobs of file contents, and so forth down to the individual files.</p>
<div><div><img alt="Figure 6.6 – Hash tree of a short history of a project, with a tag, two commits, and their contents. The SHA-1 hashes, shown in shortened form, ﻿depending on their contents" src="img/B21194_06_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Hash tree of a short history of a project, with a tag, two commits, and their contents. The SHA-1 hashes, shown in shortened form, depending on their contents</p>
<p class="calibre3">All of this allows SHA-1 hashes to be used to verify whether objects obtained from a (potentially untrusted) source have been corrupted or modified since they were created.</p>
<h2 id="_idParaDest-151" class="calibre7"><a id="_idTextAnchor165" class="pcalibre1 pcalibre calibre6"/>Lightweight, annotated, and signed tags</h2>
<p class="calibre3">The trust chain allows us to verify the contents but does not verify the identity of the person who created the content (the author and committer name are fully configurable and under user control). This is the task for GPG/PGP signatures: signed tags, signed commits, and signed merges.</p>
<p class="calibre3">Since Git version 2.34, you can also use SSH keys for signing by setting the <code>gpg.format</code> configuration variable to the value <code>ssh</code>, for example with <code>git config gpg.format ssh</code> (you may also need to use your public key as the configuration value for the <code>user.signingKey</code> configuration variable).</p>
<h3 class="calibre9">Lightweight tags</h3>
<p class="calibre3">Git uses two types<a id="_idIndexMarker490" class="pcalibre1 pcalibre calibre6"/> of tags: lightweight tags and annotated tags (there are also signed tags, which are a special case of annotated tags).</p>
<p class="calibre3">A <code>refs/tags/</code> namespace rather than in <code>refs/heads/</code>.</p>
<h3 class="calibre9">Annotated tags</h3>
<p class="calibre3"><code>refs/tags/</code> namespace) points to <a id="_idIndexMarker493" class="pcalibre1 pcalibre calibre6"/>a tag object, which in turn points to a commit. Tag objects contain a creation date, the tagger identity (name and e-mail), and a tagging message. You create an annotated tag with <code>git tag -a</code> (or <code>--annotate</code>). If you don’t specify a message for <a id="_idIndexMarker494" class="pcalibre1 pcalibre calibre6"/>an annotated tag on the command line (for example, with <code>-m "&lt;message&gt;"</code>), Git will launch your editor so you can enter it.</p>
<p class="calibre3">You can view the tag data along with the tagged commit with the <code>git show</code> command as follows (commit skipped):</p>
<pre class="console">
$ git show v0.2
tag v0.2
Tagger: Joe R Hacker &lt;joe@company.com&gt;
Date:   Sun Jun 1 03:10:07 2014 -0700
random v0.2
commit 5d2584867fe4e94ab7d211a206bc0bc3804d37a9</pre>
<h3 class="calibre9">Signed tags</h3>
<p class="calibre3">Signed tags are annotated<a id="_idIndexMarker495" class="pcalibre1 pcalibre calibre6"/> tags with a clear text PGP signature (or, with modern Git, an <a id="_idIndexMarker496" class="pcalibre1 pcalibre calibre6"/>SSH signature) of the tag data attached. You can create them with <code>git tag -s</code> (which uses your committer identity to select the signing key, or <code>user.signingKey</code> if set), or with <code>git tag -u &lt;key-id&gt;</code>; both versions assume that you<a id="_idIndexMarker497" class="pcalibre1 pcalibre calibre6"/> have a <code>gpg --gen-key</code>).</p>
<p class="callout-heading">Lightweight tags versus annotated and signed tags</p>
<p class="callout">Annotated or signed tags are meant for marking a release, while lightweight tags are meant for private or temporary revision labels. For this reason, some Git commands (such as <strong class="source-inline1">git describe</strong>) will ignore lightweight tags by default.</p>
<p class="calibre3">Of course in collaborative workflows, it is important that the signed tag is <em class="italic">made public</em>, and that there is a way to <em class="italic">verify it</em>; both of those operations will be described in the following sections.</p>
<h3 class="calibre9">Publishing tags</h3>
<p class="calibre3">Git does not push tags by default: you<a id="_idIndexMarker498" class="pcalibre1 pcalibre calibre6"/> need to do it explicitly. One solution is to individually <code>git push &lt;remote&gt; tag &lt;tag-name&gt;</code> (here, <code>tag &lt;tag&gt;</code> is equivalent to the longer <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>); however, if you don’t have the naming conflict between a branch and a tag (i.e., you don’t have branch and tag with the same name), then you can skip the word <code>tag</code> here in this operation.</p>
<p class="calibre3">Another solution is to push tags en masse: either all the tags—both lightweight and annotated—with the use of the <code>--tags</code> option, or just all annotated tags that point to pushed commits with <code>--follow-tags</code>. This explicitness allows you to re-tag (using <code>git tag -f</code>) with impunity if it turns out that you tagged the wrong commit, or there is a need for a last-minute fix—but only if the tag was not made public. Git does not (and should not) change tags behind the user’s back; thus, if you pushed the wrong tag, you need to ask others to delete this old tag to change it.</p>
<p class="calibre3">When fetching changes, Git automatically <strong class="bold">follows tags</strong>, downloading annotated tags that point to fetched commits. This<a id="_idIndexMarker500" class="pcalibre1 pcalibre calibre6"/> means that downstream developers will automatically get signed tags, and will be able to verify releases.</p>
<h3 class="calibre9">Tag verification</h3>
<p class="calibre3">To verify a signed<a id="_idIndexMarker501" class="pcalibre1 pcalibre calibre6"/> tag, you use <code>git tag --verify &lt;tag-name&gt;</code> (or <code>-v</code> for short). You need the signer’s <code>gpg --import</code> or <code>gpg --keyserver &lt;key-server&gt; --recv-key &lt;key-id&gt;</code>), and of course the tagger’s key needs to be vetted in your chain of trust. For <code>gpg.ssh.allowedSignersFile</code> configuration variable.</p>
<pre class="console">
$ git tag --verify v0.2
object 1085f3360e148e4b290ea1477143e25cae995fdd
type commit
tag signed
tagger Joe Random  1411122206 +0200
project v0.2
gpg: Signature made Fri Jul 19 12:23:33 2014 CEST using RSA key ID A0218851
gpg: Good signature from "Joe Random &lt;jrandom@example.com&gt;"</pre>
<h2 id="_idParaDest-152" class="calibre7"><a id="_idTextAnchor166" class="pcalibre1 pcalibre calibre6"/>Signed commits</h2>
<p class="calibre3">Signed tags are a good solution <a id="_idIndexMarker502" class="pcalibre1 pcalibre calibre6"/>for users and developers to verify that the tagged release was created by the maintainer. But how do we make sure that a commit purporting to be by somebody named Jane Doe, with the <code>jane@company.com</code> e-mail, is <em class="italic">actually</em> a commit from her? How can we make it so anybody can check this?</p>
<p class="calibre3">One possible solution is to sign individual commits. You can do this with <code>git commit</code> <code>--gpg-sign[=&lt;keyid&gt;]</code> (or <code>-S</code> for short). The key identifier is optional—without this, Git would use your identity as the author. Note that <code>-S</code> (capital <em class="italic">S</em>) is different from <code>-s</code> (small <em class="italic">s</em>); the latter adds a <em class="italic">Signed-off-by</em> line at the end of the commit message for the <em class="italic">Digital Certificate </em><em class="italic">of Ownership</em>:</p>
<pre class="console">
$ git commit -a --gpg-sign
You need a passphrase to unlock the secret key for
user: "Jane Doe &lt;jane@company.com&gt;"
2048-bit RSA key, ID A0218851, created 2014-03-19
[master 1085f33] README: eol at eof
 1 file changed, 1 insertion(+), 1 deletion(-)</pre>
<p class="calibre3">To make commits available for verification, just push them. Anyone can then verify them with the <code>--show-signature</code> option to <code>git log</code> (or <code>git show</code>), or with one of the <code>%Gx</code> placeholders<a id="_idIndexMarker503" class="pcalibre1 pcalibre calibre6"/> in <code>git </code><code>log --format=&lt;format&gt;</code>:</p>
<pre class="console">
$ git log -1 --show-signature
commit 1085f3360e148e4b290ea1477143e25cae995fdd
gpg: Signature made Wed Mar 19 11:53:49 2014 CEST using RSA key ID A0218851
gpg: Good signature from "Jane Doe &lt;jane@company.com&gt;
Author: Jane Doe &lt;jane@company.com&gt;
Date:   Wed Mar 19 11:53:48 2014 +0200
    README: eol at eof</pre>
<p class="calibre3">You can also use the <code>git verify-commit</code> command for this.</p>
<h2 id="_idParaDest-153" class="calibre7"><a id="_idTextAnchor167" class="pcalibre1 pcalibre calibre6"/>Merging signed tags (merge tags)</h2>
<p class="calibre3">The <em class="italic">signed commit</em> mechanism, described in the previous section, may be useful in some workflows, but it is<a id="_idIndexMarker504" class="pcalibre1 pcalibre calibre6"/> inconvenient in an environment where you push commits out early, and only after a while do you decide whether they are worth including in the upstream. In such cases, you would want to sign only those parts that are ready to be published.</p>
<p class="calibre3">This situation can happen if you follow the recommendations in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>,<em class="italic"> Keeping History Clean</em>; you know only after the fact (long after the commit was created) that the given iteration of the commit series passes code review. Commits need to be signed at commit creation time, but you can create a signed tag after the fact, after the series of commits gets accepted.</p>
<p class="calibre3">You can deal with this issue by rewriting the whole commit series after its shape is finalized (after passing the review), signing each rewritten commit, or just by amending and signing only the top commit. Both of those solutions would require a forced push to replace the old history where commits were not signed. You can always sign every commit, or you can create an empty commit (with <code>--allow-empty</code>), sign it, and push it on top of the series. But there is a better solution: requesting the pull of a signed tag.</p>
<p class="calibre3">In this workflow, you <a id="_idIndexMarker505" class="pcalibre1 pcalibre calibre6"/>work on your changes and, when they are ready, you create and push a signed tag (tagging the last commit in the series). You don’t have to push your working branch—pushing the tag is enough. If the workflow involves sending a pull request to the integrator, you create it using a signed tag instead of the end commit:</p>
<pre class="console">
$ git tag -s 1253-for-maintainer
$ git request-pull origin/master public-repo \
  1253-for-maintainer &gt;msg.txt</pre>
<p class="calibre3">The signed tag message is shown between the dashed lines in the pull request, which means that you may want to explain your work in the tag message when creating the signed tag. The maintainer, after receiving such a pull request, can copy the repository line from it, fetching and integrating the named tag. When recording the merge result of pulling the named tag, Git will open an editor and ask for a commit message. The integrator will see a template starting with the following:</p>
<pre class="source-code">
Merge tag '1252-for-maintainer'
Work on task tsk-1252
# gpg: Signature made Wed Mar 19 12:23:33 2014 CEST using RSA key ID A0218851
# gpg: Good signature from "Jane Doe &lt;jane@company.com&gt;"</pre>
<p class="calibre3">This commit template includes the commented-out output of the verification of the signed tag object being merged (so it won’t be in the final merge commit message). The tag message helps describe the merge better.</p>
<p class="calibre3">The signed tag being pulled is <em class="italic">not</em> stored in the integrator’s repository, not as a tag object. Its content is stored, hidden, in a merge commit. This is done to avoid polluting the tag namespace with a large number of such working tags. The developer can safely delete the tag (<code>git push public-repo --delete 1252-for-maintainer</code>) after it gets integrated.</p>
<p class="calibre3">Recording the signature inside<a id="_idIndexMarker506" class="pcalibre1 pcalibre calibre6"/> the merge commit allows for after-the-fact verification with the <code>--</code><code>show-signature</code> option:</p>
<pre class="console">
$ git log -1 --show-signature
commit 0507c804e0e297cd163481d4cb20f3f48ceb87cb
merged tag '1252-for-maintainer'
gpg: Signature made Wed Mar 19 12:23:33 2014 CEST using RSA key ID A0218851
gpg: Good signature from "Jane Doe &lt;jane@company.com&gt;"
Merge: 5d25848 1085f33
Author: Jane Doe &lt;jane@company.com&gt;
Date:   Wed Mar 19 12:25:08 2014 +0200
    Merge tag 'for-maintainer'
    Work on task tsk-1252</pre>
<h1 id="_idParaDest-154" class="calibre5"><a id="_idTextAnchor168" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">Through this chapter, we learned how to use Git for collaborative development and how to work together in a team on a project. We got to know different collaborative workflows, that is, different ways of setting up repositories for collaboration. Which one to use depends on circumstances: how large the team is, how diverse, and so on. This chapter focuses on repository-to-repository interaction; the interplay between branches and remote-tracking branches in those repositories is left for <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced </em><em class="italic">Branching Techniques</em>.</p>
<p class="calibre3">We learned how Git can help manage information about remote repositories involved in the chosen workflow. We were shown how to store, view, and update this information. This chapter explains how one can manage triangular workflows, in which you fetch from one repository (canonical), and push to the other (public).</p>
<p class="calibre3">We learned about the chain of trust: how to verify that a release comes from the maintainer, how to sign your work so that the maintainer can verify that it comes from you, and how the Git architecture helps with this.</p>
<p class="calibre3">The next chapter, namely <a href="B21194_07.xhtml#_idTextAnchor172" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 7</em></a>, <em class="italic">Publishing Your</em><em class="italic"> Changes</em>, will talk about how to get your contribution to other remote repositories. The two further following chapters will expand on the topic of collaboration: <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced Branching Techniques</em>, will explore relations between local branches and branches in a remote repository and how to set up branches for collaboration, while <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>,<em class="italic"> Merging Changes Together</em>, will talk about the opposite issue—how to join the results of parallel work.</p>
<h1 id="_idParaDest-155" class="calibre5"><a id="_idTextAnchor169" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">What operation do you need to publish your changes to your public remote repository, and what operation do you need to get changes from a remote?</li>
<li class="calibre15">What is the difference between <strong class="source-inline1">git fetch</strong> and <strong class="source-inline1">git pull</strong>?</li>
<li class="calibre15">How can you remove stale remote-tracking branches (that is, remote-tracking branches where the corresponding branch on the remote was deleted)?</li>
</ol>
<h1 id="_idParaDest-156" class="calibre5"><a id="_idTextAnchor170" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li class="calibre15">Use <strong class="source-inline1">git push</strong> to publish your changes, and use <strong class="source-inline1">git fetch</strong> or <strong class="source-inline1">git pull</strong> (or <strong class="source-inline1">git remote update</strong>) to get changes from the remote repository.</li>
<li class="calibre15">The <strong class="source-inline1">fetch</strong> operation only downloads changes and updates the remote-tracking branches, while the <strong class="source-inline1">pull</strong> operation also tries to update the current branch with <strong class="source-inline1">merge</strong> or <strong class="source-inline1">rebase</strong> (if it is configured as tracking some branch in the remote repository).</li>
<li class="calibre15">You can use <strong class="source-inline1">git branch -d -r</strong> to delete individual remote-tracking branches, or <strong class="source-inline1">git remote prune</strong> to delete all stale remote-tracking branches.</li>
</ol>
<h1 id="_idParaDest-157" class="calibre5"><a id="_idTextAnchor171" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon and Ben Straub: <em class="italic">Pro Git, 2nd Edition</em> (2014) <a href="https://git-scm.com/book/en/v2" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2</a><ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 5.1 Distributed Git - </em><em class="italic">Distributed Workflows</em></li><li class="calibre15"><em class="italic">Chapter 2.5 Git Basics - Working </em><em class="italic">with Remotes</em></li><li class="calibre15"><em class="italic">Chapter 7.4 Git Tools - Signing </em><em class="italic">Your Work</em></li></ul></li>
<li class="calibre15">Ryan Brown: <em class="italic">gpg-sign releases</em> (2014) <a href="https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html" class="pcalibre1 pcalibre calibre6">https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html</a></li>
<li class="calibre15">Danilo Bargen: <em class="italic">Signing Git Commits with SSH Keys</em> (2021) https://blog.dbrgn.ch/2021/11/16/git-ssh-signatures/</li>
<li class="calibre15">Carl Tashian: <em class="italic">SSH Tips &amp; Trick</em> – <em class="italic">Add a second factor to your SSH login</em> (2020) <a href="https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh" class="pcalibre1 pcalibre calibre6">https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh</a></li>
<li class="calibre15">Junio C Hamano: <em class="italic">Git Blame: Fun (?) with GnuPG</em> (2014) <a href="https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html</a></li>
</ul>
</div>
</body></html>