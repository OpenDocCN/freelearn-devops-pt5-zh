<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Orchestrating Infrastructure with Ansible</h1></div></div></div><p>Orchestration can mean different things at different times when used in different scenarios. The following are some of the orchestration scenarios described:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running ad hoc commands in parallel on a group of hosts, for example, using a <code class="literal">for</code> loop to walk over a group of web servers to restart the Apache service. This is the crudest form of orchestration.</li><li class="listitem" style="list-style-type: disc">Invoking an orchestration engine to launch another configuration management tool to enforce correct ordering.</li><li class="listitem" style="list-style-type: disc">Configuring a multitier application infrastructure in a certain order with the ability to have fine-grained control over each step, and the flexibility to move back and forth while configuring multiple components. For example, installing the database, setting up the web server, coming back to the database, creating a schema, going to web servers to start services, and more.</li></ul></div><p>Most real-world scenarios are similar to the last scenario, which involve a multitier application stacks and more than one environment, where it's important to bring up and update nodes in a certain order, and in a coordinated way. It's also useful to actually test that the application is up and running before moving on to the next. The workflow to set up the stack for the first time versus pushing updates can be different. There can be times when you would not want to update all the servers at once, but do them in batches so that downtime is avoided.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Orchestration scenarios</li><li class="listitem" style="list-style-type: disc">Using Ansible as an infrastructure orchestrating engine</li><li class="listitem" style="list-style-type: disc">Implementing rolling updates</li><li class="listitem" style="list-style-type: disc">Using tags, limits and patterns</li><li class="listitem" style="list-style-type: disc">Building tests into playbooks</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Ansible as an orchestrator</h1></div></div></div><p>When it comes to <a id="id283" class="indexterm"/>orchestration of any sort, Ansible really shines over other tools. Of course, as the creators of Ansible would say, it's more than a configuration <a id="id284" class="indexterm"/>management tool, which is true. Ansible can find a place for itself in any of the orchestration scenarios discussed earlier. It was designed to manage complex multitier deployments. Even if you have your infrastructure being automated with other configuration management tools, you can consider Ansible to orchestrate those.</p><p>Let's discuss the specific features that Ansible ships with, which are useful for orchestration.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec57"/>Multiple playbooks and ordering</h2></div></div></div><p>Unlike most other <a id="id285" class="indexterm"/>configuration management systems, Ansible supports running different playbooks at different times to configure or manage the same infrastructure. You can create one playbook to set up the application stack for the first time, and another to push updates over time in a certain manner. Another property of the playbook is that it can contain more than one play, which allows the separation of groups of hosts for each tier in the application stack, and configures them at the same time.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec58"/>Pre-tasks and post-tasks</h2></div></div></div><p>We have used <a id="id286" class="indexterm"/>pre-tasks and post-tasks earlier, which are very relevant while orchestrating, as these allow us to execute a task or run validations before and after running a play. Let's use the example of updating web servers that are registered with the load balancer. Using pre-tasks, a web server can be taken out of a load balancer, then the role is applied to the web servers to push updates, followed by post-tasks which register the web server back to the load balancer. Moreover, if these servers are being monitored by <strong>Nagios</strong>, alerts can be disabled during the update process and <a id="id287" class="indexterm"/>automatically enabled again using pre-tasks and post-tasks. This can avoid the noise that the monitoring tool may generate in the form of alerts.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec59"/>Delegation</h2></div></div></div><p>If you would like tasks to be selectively run on a certain class of hosts, especially the ones outside the current play, the delegation feature of Ansible can come in handy. This is relevant to the scenarios <a id="id288" class="indexterm"/>discussed previously and is commonly used with pre-tasks and post-tasks. For example, before updating a web server, it needs to be deregistered from the load balancer. Now, this task should be run on the load balancer, which is not part of the play. This dilemma can be solved by using the delegation feature. With pre-tasks, a script can be launched on the load balancer using the <code class="literal">delegate_to</code> keyword, which does the deregistering part as follows:</p><div><pre class="programlisting">- name: deregister web server from lb
  shell: &lt; script to run on lb host &gt;
  delegate_to: lbIf there areis more than one load balancers, anan inventory group can be iterated over as, follows: 
- name: deregister web server from lb
  shell: &lt; script to run on lb host &gt;
  delegate_to: "{{ item }}"
  with_items: groups.lb</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec60"/>Rolling updates</h2></div></div></div><p>This is also <a id="id289" class="indexterm"/>called batch updates or zero-downtime updates. Let's <a id="id290" class="indexterm"/>assume that we have 100 web servers that need to be updated. If we <a id="id291" class="indexterm"/>define these in an inventory and launch a playbook against them, Ansible will start updating all the hosts in parallel. This can also cause downtime. To avoid complete downtime and have a seamless update, it would make sense to update them in batches, for example, 20 at a time. While running a playbook, batch size can be mentioned by using the <code class="literal">serial</code> keyword in the play. Let's take a look at the following code snippet:</p><div><pre class="programlisting">- hosts: www
  remote_user: vagrant
  sudo: yes
  serial: 20 </pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec61"/>Tests</h2></div></div></div><p>While orchestrating, it's not only essential to configure the applications in order, but also to ensure that they are actually <a id="id292" class="indexterm"/>started, and functioning as expected. Ansible modules, such as <code class="literal">wait_for</code> and <code class="literal">uri</code>, help you build that testing into the playbooks, for example:</p><div><pre class="programlisting">- name: wait for mysql to be up
  wait_for: host=db.example.org port=3106 state=started
- name: check if a uri returns content
  uri: url=http://{{ inventory_hostname }}/api
  register: apicheck</pre></div><p>The <code class="literal">wait_for</code> module can be additionally used to test the existence of a file. It's also useful when you would like to wait until a service is available before proceeding.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec62"/>Tags</h2></div></div></div><p>Ansible plays map roles to <a id="id293" class="indexterm"/>specific hosts. While the plays are run, the entire logic that is called from the main task is executed. While orchestrating, we may need to just run a part of the tasks based on the phases that we want to bring the infrastructure in. One example is a zookeeper cluster, where it's important to bring up all the nodes in the cluster at the same time, or in a gap of a few seconds. Ansible can orchestrate this easily with a two-phase execution. In the first phase, you can install and configure the application on all nodes, but not start it. The second phase involves starting the application on all nodes almost simultaneously. This can be achieved by tagging individual tasks, for example, configure, install, service, and more.</p><p>For example, let's take a look at the following screenshot:</p><div><img src="img/B03800_10_01.jpg" alt="Tags"/></div><p>While running a playbook, all tasks with a specific tag can be called using <code class="literal">–-tags</code> as follows:</p><div><pre class="programlisting">
<strong>$ Ansible-playbook -i customhosts site.yml –-tags install</strong>
</pre></div><p>Tags can not only be applied to tasks, but also to the roles, as follows:</p><div><pre class="programlisting">{ role: nginx, when: Ansible_os_family == 'Debian', tags: 'www' }</pre></div><p>If a specific task needs to be <a id="id294" class="indexterm"/>executed always, even if filtered with a tag, use a special tag called <code class="literal">always</code>. This will make the task execute unless an overriding option, such as <code class="literal">--skip-tags always</code> is used.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec63"/>Patterns and limits</h2></div></div></div><p>Limits can be <a id="id295" class="indexterm"/>used to run tasks on a subset of hosts, which are filtered by patterns. For example, the following code would run tasks only on hosts that are part of the <code class="literal">db</code> group:</p><div><pre class="programlisting">
<strong>$ Ansible-playbook -i customhosts site.yml --limit db</strong>
</pre></div><p>Patterns usually <a id="id296" class="indexterm"/>contain a group of hosts to include or exclude. A combination <a id="id297" class="indexterm"/>of more than one pattern can be specified as follows:</p><div><pre class="programlisting">
<strong>$ Ansible-playbook -i customhosts site.yml --limit db,lb</strong>
</pre></div><p>Having a  colon as separator can <a id="id298" class="indexterm"/>be used to filter hosts further. The following command would run tasks on all hosts except for the ones that belong to the groups <code class="literal">www</code> and <code class="literal">db</code>:</p><div><pre class="programlisting">
<strong>$ Ansible-playbook -i customhosts site.yml --limit 'all:!www:!db'</strong>
</pre></div><p>Note that this usually needs to be enclosed in quotes. In this pattern, we used the <code class="literal">all</code> group, which matches all hosts in the inventory, and can be replaced with <code class="literal">*</code>. That was followed by <code class="literal">!</code> to exclude hosts in the <code class="literal">db</code> group. The output of this command is as follows, which shows that plays by the name <code class="literal">db</code> and <code class="literal">www</code> were skipped as no hosts matched due to the filter we used previously:</p><div><img src="img/B03800_10_02.jpg" alt="Patterns and limits"/></div><p>Let's now see these <a id="id299" class="indexterm"/>orchestration features in action. We will begin by tagging the <a id="id300" class="indexterm"/>role and do the multiphase execution followed by <a id="id301" class="indexterm"/>writing a new <a id="id302" class="indexterm"/>playbook to manage updates to the WordPress application.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Tagging the roles</h1></div></div></div><p>Let's now start <a id="id303" class="indexterm"/>tagging the roles we created earlier. We will create the following tags that map to the phases the applications are managed in:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Install</li><li class="listitem" style="list-style-type: disc">Configure</li><li class="listitem" style="list-style-type: disc">Start</li></ul></div><p>Here is an example of adding tags to the <code class="literal">haproxy</code> role. Tagging other roles is excluded from the text to avoid redundancy. We can either add tags to the tasks inside the role or tag the complete roles in a playbook. Let's begin by tagging tasks:</p><div><pre class="programlisting">---
# filename: roles/haproxy/tasks/install.yml
  - name: install haproxy
    apt:
      name: "{{ haproxy['pkg'] }}"
    tags:
     - install

---
# filename: roles/haproxy/tasks/configure.yml
 - name: create haproxy config
    template: src="img/haproxy.cfg.j2" dest="{{ haproxy['config']['cnfpath'] }}" mode=0644
   notify:
    - restart haproxy service
   tags:
    - configure

 - name: enable haproxy
    template: src="img/haproxy.default.j2" dest=/and more/default/haproxy mode=0644
    notify:
    - restart haproxy service
    tags:
    - configure

---
# filename: roles/haproxy/tasks/service.yml
 - name: start haproxy server
    service:
      name: "{{ haproxy['service'] }}" 
      state: started
    tags:
    - start</pre></div><p>After tagging tasks in a <a id="id304" class="indexterm"/>role, we will additionally tag the roles in the playbooks too, as follows:</p><div><pre class="programlisting"># filename: db.yml
  roles:
- { role: mysql, tags: 'mysql' }

#filename: www.yml
  roles:
     - { role: nginx, when: Ansible_os_family == 'Debian', tags: [ 'www', 'nginx' ] }
     - { role: php5-fpm, tags: [ 'www', 'php5-fpm' ] }
     - { role: wordpress, tags: [ 'www', 'wordpress' ] }

#filename: lb.yml
  roles:
- { role: haproxy, when: Ansible_os_family == 'Debian', tags: 'haproxy' }</pre></div><p>Once applied, the tags for our <a id="id305" class="indexterm"/>main playbook can be listed as follows:</p><div><pre class="programlisting">
<strong>$ Ansible-playbook -i customhosts site.yml --list-tags</strong>

<strong>#Output:</strong>
<strong>playbook: site.yml</strong>

<strong>  play #1 (db): TAGS: []</strong>
<strong>    TASK TAGS: [configure, install, mysql, start]</strong>

<strong>  play #2 (www): TAGS: []</strong>
<strong>    TASK TAGS: [configure, install, nginx, php5-fpm, ssl, start, wordpress, www]</strong>

<strong>  play #3 (lb): TAGS: []</strong>
<strong>    TASK TAGS: [configure, haproxy, install, start]</strong>
</pre></div><p>Using the combination of tags and limits gives us a fine-grained control over what gets executed in a playbook run, for example:</p><div><pre class="programlisting">
<strong># Run install tasks for haproxy, </strong>
<strong>$ Ansible-playbook -i customhosts site.yml --tags=install --limit lb</strong>

<strong># Install and configure all but web servers</strong>
<strong>$ Ansible-playbook -i customhosts site.yml --tags=install,configure --limit 'all:!www'</strong>

<strong># Run all tasks with tag nginx</strong>
<strong>$ Ansible-playbook -i customhosts site.yml --tags=nginx</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Creating an orchestration playbook for WordPress</h1></div></div></div><p>We have a site-wide <a id="id306" class="indexterm"/>playbook, that is, the <code class="literal">site.yml</code> file that serves us to install and configure the complete WordPress stack. For updating the application with zero downtime and deploying new revisions, the <code class="literal">site.yml</code> file is not the ideal playbook though. We would want to follow a workflow that would involve the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Update the web <a id="id307" class="indexterm"/>servers one at a time. This will avoid any downtime.</li><li class="listitem">Before updating, deregister the web server from the haproxy load balancer. This will stop the traffic to the web server in order to avoid downtime.</li><li class="listitem">Run roles related to the WordPress application, that is, Nginx, php5-fpm, and WordPress.</li><li class="listitem">Ensure that the web server is running and is listening to port 80.</li><li class="listitem">Register the server back on haproxy and start sending the traffic again.</li></ol></div><p>Let's create a playbook by the name <code class="literal">update.yml</code>, which does the orchestration just as explained earlier and uses most of the features discussed previously in this chapter. Here is the playbook:</p><div><pre class="programlisting"> ---
# Playbook for updating web server in batches
# filename: update_www.yml
- hosts: www
  remote_user: vagrant
  sudo: yes
  serial: 1
  pre_tasks:
    - name: deregister web server from  load balancer
    shell: echo "disable server fifanews/{{ Ansible_hostname }}" | socat stdio /var/lib/haproxystats
    delegate_to: "{{ item }}"
    with_items: groups.lb
  roles:
    - { role: nginx, when: Ansible_os_family == 'Debian' }
    - php5-fpm
    - wordpress
  post_tasks:
    - name: wait for web server to come up 
    wait_for: host={{ inventory_hostname }} port=80 state=started
    - name: register webserver from  load balancer
    shell: echo "enable server fifanews/{{ Ansible_hostname }}" | socat stdio /var/lib/haproxystats
    delegate_to: "{{ item }}"
    with_items: groups.lb</pre></div><p>Let's analyze <a id="id308" class="indexterm"/>this code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The playbook contains just one play, which runs on the hosts that belong to the <code class="literal">www group in</code> inventory.</li><li class="listitem" style="list-style-type: disc">The serial keyword specifies the batch size, and allows rolling updates with zero downtime. In our case, since we have fewer hosts, we chose one web server to be updated at a time.</li><li class="listitem" style="list-style-type: disc">Before applying the role, the host is deregistered from the load balancer using the pre-tasks section ,which runs a shell command with <strong>socat</strong>. This is run on all load balancers using the <code class="literal">delegate</code> keyword. Socat is a Unix utility similar to and more at (nc) but has a richer feature set.</li><li class="listitem" style="list-style-type: disc">After deregistering the host, roles are applied to it; this will update the configurations for the web server or deploy new code.</li><li class="listitem" style="list-style-type: disc">Once updated, the <a id="id309" class="indexterm"/>post-tasks kick in, which first wait until the web server is up and listening to port 80, and only after its ready, then it registers it back to the load balancer.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Review questions</h1></div></div></div><p>Do you think you've understood the chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">Is it possible to use Ansible to orchestrate another configuration management tool?</li><li class="listitem">How can you achieve zero downtime while deploying applications with Ansible?</li><li class="listitem">What does the <code class="literal">--limit</code> command do to Ansible playbook?</li><li class="listitem">How would you run a subset of tasks for a given role in a playbook?</li><li class="listitem">What is the purpose of using pre-tasks and post-tasks?</li><li class="listitem">What modules can be used to run tests from playbooks?</li><li class="listitem">Why is the <code class="literal">always</code> tag special?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Summary</h1></div></div></div><p>We started this chapter by discussing what orchestration is, what different orchestration scenarios are, and how Ansible can fit in. You learned about Ansible's set of rich features in the context or orchestration. This includes multi-playbook support, pre-tasks and post-tasks, tags and limits, running tests, and a lot more. We went on to tag the roles we created earlier and learned how to control what portion of code runs on which machines using a combination of tags, patterns, and limits. Finally, we created a new playbook to orchestrate the workflow to update web servers, which involves zero-downtime deployment, delegation, pre-tasks and post-tasks, and tests. You also learned that Ansible can be a good fit in any orchestration scenario.</p><p>This brings us to the end of this book. Before we conclude, on behalf of the reviewers, editors, contributors, and rest of the publishing team, I would like to thank you for considering this book as a companion in your journey towards being an Ansible practitioner.</p><p>We hope that by now you have become comfortable with the various primitives that Ansible offers to automate common infrastructure tasks, create dynamic roles, manage multitier application configurations, zero-downtime deployments, orchestrate complex infrastructure, and more. We hope that you will be able to apply the knowledge acquired in this book to create effective Ansible playbooks.</p></div></body></html>