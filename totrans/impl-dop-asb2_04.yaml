- en: Playbooks and Inventory Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discovered in the previous chapters, Ansible offers unique, easy-to-comprehend
    implementations for creating automation, implementing Configuration Management
    solutions, maintaining infrastructure, and scaling out automation. Automation
    and Configuration Management implementations are developed and maintained using
    Ansible playbooks (as we discussed in the previous chapter), whereas infrastructure
    inventory is managed through one or many Ansible inventory hosts file. A playbook
    in Ansible is really quite simple to understand; it's simply a set of tasks to
    execute that are ordered in a structured format. These two very easy-to-understand
    concepts have helped pave the way and made Ansible as popular and robust as it
    is today.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of an Ansible playbook is an easy one to grasp and understand. The
    same can be said for the the implementation of Ansible inventory files. Playbook's
    and roles in Ansible make up the bulk of the automation we will be developing
    throughout this book and are a core construct of the Ansible implementation. This
    chapter however will focus on Playbook's and Inventory files specifically. Inventory
    files exist to help us maintain the infrastructure we will target via a playbook
    and allow us to group similar devices and infrastructure when targeting remote
    hosts. These two constructs combined provide a highly scalable automation solution
    that can be used to maintain one machine or 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss and learn all about Ansible playbook''s and
    Inventory solutions, and learn how to develop, maintain, and expand an Ansible
    footprint within an organization. The learning areas we are going to cover will
    include the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Playbook Constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Play's and Task's
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and Variable Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosts and Inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting Infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we progress through this chapter, we will try to gain a clear understanding
    of how Ansible playbooks are created and how to create automation that is fault
    tolerant, robust, and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Playbook Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible playbook is at the heart of the Ansible Configuration Management
    and Automation System. Each playbook is made up of one or more plays. The concept
    of a playbook was derived from sporting references, where a coach would create
    a set of plays off the field and execute them during a game. The creators of Ansible
    leveraged this idea to create and successfully deliver an easy-to-use automation
    and Configuration Management solution. Playbook's are developed using YAML (more
    about this in the next section), and optionally Jinja2 for more comprehensive
    automation implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible playbook comprise a few specific structural and formatting elements,
    namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML syntax (the language Ansible leverages for automation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jinja2 (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hosts section (which defines the host groups to target during execution)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or many configuration overrides (this section allows playbook developers
    to override configuration options or set specific playbook flags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vars section (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plays with tasks inside them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these elements, YAML (and by nature Ansible) supports commenting
    within the YAML file. Comments are simply notation documentation that has no programmatic
    meaning but is useful for developers and playbook authors to keep notes within
    the playbook directly. Comments in YAML are initiated with the `#` operator, and
    everything on that line after the `#` is ignored by YAML and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's spend a few minutes looking at the hosts, vars, and play sections of an
    Ansible playbook and learn how we can leverage them to create effective and maintainable
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: The programming languages that make up a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Ansible world, playbook's are developed using YAML and Jinja. **YAML**
    stands for **YAML Ain't Another Markup Language**, and Jinja2 is its own independent
    name. Of the two, YAML is the primary language whereas Jinja is supplementary.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, YAML™ is the primary language used to create playbooks.
    But what exactly is YAML? Here is what [http://yaml.org/](http://yaml.org/) has
    to say on the subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '"YAML (rhymes with "camel") is a human-friendly, cross language, Unicode based
    data serialization language designed around the common native data types of agile
    programming languages. It is broadly useful for programming needs ranging from
    configuration files to internet messaging to object persistence to data auditing.
    Together with the Unicode standard for characters ([http://unicode.org/](http://unicode.org/)),
    this specification provides all the information necessary to understand YAML version
    1.2 and to create programs that process YAML information."'
  prefs: []
  type: TYPE_NORMAL
- en: As described in the excerpt, YAML is designed to be human-friendly. This means
    that while it can contain data and basic logic (typically provided by Jinja2),
    it emphasizes the concept of readability and convention over complexity and features.
    Additional information on YAML can be found at [http://www.yaml.org](http://www.yaml.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'YAML uses tab-indented formatting and key/value pair dictionaries to express
    the data that is inside a given YAML file. This makes it parseable for Ansible
    and makes it easy to read at the same time. YAML''s unique yet simplistic structure
    provides Ansible playbook developers with a guess-free way of developing playbooks
    and ensuring that they will be executable through Ansible. While YAML''s structure
    is easy to read, sometimes it''s tabbing can trip some users up. Let''s take a
    look at a couple of simple examples of YAML files and see what the basic data
    structure looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the previous example, we can easily see the content is simply a list of
    planets, species, and greetings. Are we saying that all YAML really is is an easy-to-read
    way of managing lists? In a way, yes. Let's explore this idea further.
  prefs: []
  type: TYPE_NORMAL
- en: Basic data in YAML is structured into key/value pairs; the information is organized
    by indentation. For programmers, this is nothing surprising, but for a novice
    this may sound confusing. A basic key/value-paired data structure is similar to
    a list of items. In a key/value data structure, there are two intrinsically linked
    data items. A **key** is essentially a pointer, which references the value. The
    **value** can be raw data (a simple bit of text) or even another set of key/value
    pairs. This makes managing lists of key/value pairs very easy. The indentation
    in YAML syntax makes organizing the data it represents easy to read. It ensures
    that nothing is garbled or badly formatted and the information is easily identifiable
    and legible.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the previous YAML example, YAML is a well-formatted (tab-enforced)
    language. Tabs in YAML are a bit of a misnomer, as you can't actually use the
    Tab key. Use spaces instead. Tabs are forbidden in YAML because different text
    editors provide different implementations of tabbing and the implementations are
    not consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 – a brief introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jinja on the other hand is a bit more feature rich than YAML. It has been integrated
    into Ansible''s runtime engine and provides a bit of the more scripting language-like
    features that developers are used to. Its syntax fits nicely into YAML (as described
    previously) and allows the developer to use things such as conditionals, loops,
    variable substitution, and environment variable retrieval. Further information
    related to jinja2 and its syntax can be found at [http://jinja.pocoo.org/docs/2.9/](http://jinja.pocoo.org/docs/2.9/).
    Let''s take a quick look at some basic Jinja syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code doesn''t look very useful at first, but once we put it in context,
    it becomes much more valuable. Let''s take a peek at how Jinja fits in with YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This simple example of an Ansible playbook with YAML and Jinja combined provides
    a way for us to use the contents of a system environment variable within our playbook.
    We will go into this type of implementation in much more detail later within this
    book, but for now, we at least can see one structured example of how Jinja can
    be leveraged within a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja offers many more solutions and manipulations of an Ansible playbook, which
    we will discuss in [Chapter 6](af2931a0-b22f-4501-8d98-fb54e3d081f9.xhtml), *Jinja
    in Ansible*. This introduction is simply to provide you with an understanding
    of how YAML and Jinja can coexist.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing an Ansible playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'YAML''s unique and well-formatted syntax provides a highly structured yet human-readable
    format for expressing data. More specifically, YAML''s data structure is expressed
    in lists, with each list item containing key/value pairs (or dictionaries). At
    the beginning of each YAML file, YAML optionally supports a `---` initiator (to
    notate the beginning of the YAML file), and conversely, at the end of each, YAML
    supports a `...` terminator, which (as you may have guessed) indicates the end
    of a YAML file. Let''s take a look at a very simple playbook as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen an example of an Ansible playbook, let's look at the possible
    available sections within a playbook, and see what each does.
  prefs: []
  type: TYPE_NORMAL
- en: Hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hosts section is where we can target groups of inventory. The inventory
    in Ansible represents one or many devices that Ansible can connect to and run
    automation against.
  prefs: []
  type: TYPE_NORMAL
- en: Variables (vars/vars_files)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vars` and `vars_file` sections of an Ansible playbook contain a set of
    variable data that can be used later in the playbook. This information is known
    as **facts**. The variable concept in Ansible is identical in nature to computer
    programming variables but with different scopes, depending on where it's defined.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks/plays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of Ansible plays is to connect one or more groups of hosts to a set
    of roles, represented by things, which Ansible calls tasks. At its most basic
    definition, an Ansible task is nothing more than a callout to an Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: Great; we now have a basic understanding of the sections that make up a playbook,
    but we really don't know how to effectively use them to create a playbook or how
    to target a specific set of servers or infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Play's and Task's
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discovered, within the heart of the Ansible configuration
    and Automation System is the the playbook. The most important element of the playbook
    is the idea of plays and tasks. Plays represent a categorization of a collection
    of Ansible tasks, whereas tasks are individual automation steps that make up the
    play.
  prefs: []
  type: TYPE_NORMAL
- en: Consider plays as the overarching grouping and tasks as the items that reside
    within a given play. For example, you may have a database play, a web server play,
    or even a load balancer play. In this section, we will discover how plays and
    tasks work in the Ansible world.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible plays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible plays are named after sports plays. In YAML, plays are represented via
    one or more tasks sections within a playbook. The plays section (or sections)
    of an Ansible playbook represents the heart of the Ansible automation engine.
    In Ansible, each task has a name (a user-friendly description of the action to
    be executed) and a set of parameters that define how the system should execute,
    report on, or handle the aftermath of the execution. Let's take a look at a couple
    of ways in which we can implement Ansible plays within a given playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example provided next provides us with a glimpse into an Ansible playbook
    with a single play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks pretty basic, right? Plays can have one or more tasks underneath them.
    They are pretty easy to read and very easy to write. However, a playbook does
    not need to be isolated into a single play. For example, we could just as easily
    do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This second example is also human-readable but has two specific plays defined
    within. The first play handles the installation of nginx, whereas the second play
    handles the installation of the MySQL server. By using multiple plays in a single
    playbook, we can group automation into a single playbook yet segregate the actual
    tasks. Neat, huh? Now that we have a good understanding of what an Ansible play
    is, let's take a look at Ansible tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we talked primarily about Ansible plays. Underneath
    a given play is a set of Ansible tasks. Ansible tasks can perform numerous actions
    on a local or target system. This includes installing packages (such as `apt`,
    `yum`, and `opencsw`), copying files, starting services, and much, much more.
    Ansible tasks make up the glue that binds automation and human-readable actions.
    Let''s take a look at the elements of the Ansible tasks section and see how to
    write them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet is pretty simplistic; there is a single play (notated by tasks:)
    and a single task underneath the play. Within the task itself, the name parameter
    has (in plain English) a description of what we are trying to accomplish when
    this task is executed. The `<API>` tag on the next line (below the `name` definition)
    will simply be the Ansible module we are invoking. After the module `name`, there
    is a set of parameters that are passed to the module that specify more granularly
    the details about the module we are invoking. So to have a better real-world example,
    let''s take a look at the following code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned play simply tells Ansible to install the nginx web server
    on an Ubuntu-based system. We know this because the module the task is calling
    is `apt` and the parameters instruct Ansible to ensure the package (`pkg`) `nginx`
    is in the state installed. Additionally, prior to installing the package, we have
    also instructed the `apt` module to update its local cache. Simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: One of the nicest things about Ansible is its ability to skip over tasks that
    will not effect change on a given system. For example, if the package `nginx`
    is already installed, Ansible will skip the step entirely as it is smart enough
    to know that the `nginx` package already exists on the system.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we know the basic structures of an Ansible playbook, we will want
    to know how to extend our playbooks to handle more complex parameters within our
    tasks. The next step in this learning process is understanding multiline parameters.
    Let's proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline task parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some Ansible tasks can have a bunch of parameters (so much so that the simplicity
    and readability of the task become ambiguous). The YAML implementation has also
    matured in such a way as to support parameters across multiple lines for better
    readability. This is specifically a *scalar folded approach* that is available
    within the YAML language directly. Let''s take a look at an example provided by
    the YAML creators to understand how line folding works in YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So in the context of Ansible playbook''s we can use the scalar folded approach
    to perform multiline playbook tasks. As a result, we can reformat a task as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Multiline implementations of Ansible tasks are based on preference and formatting.
    So in some cases you may have a playbook task that is really long and in that
    case you would want to consider using a multiline task. On the converse, shorter
    playbook tasks would probably not need such an implementation. Again its simply
    a matter of readability and preference.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good idea of how to better organize our playbook data structures,
    let's look at variables and how those fit into our playbook creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Variable Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables are a critical part of any scripting or development language, and
    Ansible is no different. Variables act as named placeholders for data elements,
    important information, numerical values, and more. Ansible provides a `vars` section
    and a `vars_files` section, which are optionally included in a playbook. Variables
    defined here are playbook-centric and can be used within the playbook. These sections
    of the playbook allow us to define variables in two unique ways. Let''s look at
    an example to better understand how variables are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the example, we can be rather creative when defining variables
    that Ansible can use in its playbook. Variables can be specified via the `vars`
    section, the `vars_files` section, or even via the command line through the `ExtraVars`
    parameter. Let's take a look at the key/value implementation of variables as well
    as a `vars_file` implementation and discover how these can be leveraged to provide
    reusable data to our Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Basic variable syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most obvious solution for managing variables within Ansible is to leverage
    the key/value vars section in the beginning of an Ansible playbook, which allows
    us to define a set of simple key/value datasets that we can make available to
    the remaining tasks in our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The `vars` section in an Ansible playbook provides us with an easy location
    from where we can create a list of globally available Ansible variables. Ansible
    reads this `vars` section and its associated key/value based variables during
    the initialization of a playbook (specifically, during the facts-gathering phase).
    Each data item retrieved during this phase is known as a **fact**. The variables
    can then be used elsewhere in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples of key/value variable sets in Ansible and how
    to use them in a playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The example shows how to create and use a simple `$myvar` variable and use
    it in a playbook play. Next, let''s look at a slightly different implementation
    of Ansible variables (at the task level). Consider the following playbook fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we have illustrated a simple iterative loop of sorts to copy
    the files `foo` and `bar` into the specified destination. Now that we have a good
    idea of basic Ansible variables, let's take a look at some more scalable ways
    to manage Ansible variable data.
  prefs: []
  type: TYPE_NORMAL
- en: Variable files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we just discussed, Ansible has the `vars` section within a playbook. This
    is perfectly sufficient for a limited number of data points. However, if the amount
    of information is expected to grow or pertain to various environments, the `vars`
    section can get highly unwieldy if not managed carefully. Instead of using the
    vars section for managing data, we can use a `vars` file (or many `vars` files).
    A `vars` file represents a way to encapsulate a set of data points into an external
    file on the Ansible control server's disk. We then specify the `vars` file in
    our Ansible playbook, and Ansible will load it at the appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a `vars` file, it''s important to note that we can include the `vars`
    file in our playbook in a couple of possible locations: a `vars_file` section
    or within an Ansible task (task-specific scoped). The examples provided next will
    help better illustrate this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of the `vars` files in action. The following example
    shows the contents of a simple `vars` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the content of the `vars` file, it''s nothing more than
    a YAML file. Who would have guessed? The neat thing here really isn''t its content
    but rather the construction. But before we move on to any really neat things,
    let''s take a look at how to reference the file and data within via a playbook.
    The corresponding playbook for the previous `vars` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So based on the content of this playbook, we can see that it simply has an added
    `vars_file` section, which is loaded during startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two file examples are very simple in nature. Let''s look at another way
    of loading a variables file based on the context of the aforementioned examples.
    Here is an alternate playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So we can see based on this code provided that we can scope a `vars` file to
    a specific task as well. This can be very handy for altering certain data points
    in a task based on specific criteria (per environment or per host).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a good idea of how `vars` files work, let''s take a look at
    one more example of how a `vars` file might be leveraged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess what this will do yet? Let''s take a look at how we might execute
    this playbook from the command line for a hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Okay so let's understand how this works. Basically, the command specifies a
    variable of `env_vars=dev`, and this makes the playbook then load a `vars` file
    it thinks should be located at `/opt/varsfiles/dev.yml`. So we can set specific
    variable data for different environments (dev, QA, and so on) and reuse our playbooks.
    Nice, right?
  prefs: []
  type: TYPE_NORMAL
- en: Hosts and Inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible offers an inventory system that helps administrators manage the devices
    they intend to target via Ansible playbook execution or ad hoc command execution.
    The inventory system allows the administrator to identify inventory items (devices)
    and group them according to their needs. These inventory items are maintained
    via Ansible inventory files, which can then be targeted directly via the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out-of-the-box, Ansible offers a default inventory file, which is typically
    located in the `/etc/ansible/hosts` file location. If one inventory file is not
    enough to effectively manage your inventory, additional inventory files can be
    created and stored either in the same location or in a location of your choosing.
    When calling the `ansible-playbook` command to invoke Ansible and execute either
    an ad hoc command or trigger a `playbook run`, Ansible has the `-i` option to
    allow alternate inventory files to be specified directly on the command line.
    The following is a set of examples that illustrate targeting inventory files from
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a good idea of how to specify alternate inventory files via
    the command line, let's take a look at some ways in which we can leverage an Ansible
    inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating automation that is aimed at targeting one or multiple devices,
    we need a way to instruct Ansible which hosts to target and which playbooks should
    target which hosts. In order for Ansible to maintain an orderly congregation of
    hostnames, IP addresses, and domain names, the creators of Ansible have provided
    an Ansible inventory hosts file and the ability to group and target groups of
    hosts via Ansible playbooks. Ansible host are generally defined within the Ansible
    inventory `hosts` file, which is traditionally located at the following file location
    on the Ansible control server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned in the previous chapter, the Ansible `hosts` file allows the
    Ansible developer to maintain a list or set of groups of devices that Ansible
    can target via playbooks. The way we instruct Ansible to target specific groups
    of hosts is through the `hosts` line entry within a given Ansible playbook. Let''s
    consider the following hosts groups and Ansible playbook examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible hosts file example (**`/etc/ansible/hosts`**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Targeting the `WEB` hosts group via an Ansible playbook (`playbook.yml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the previous example, simply change into the directory that contains
    the `playbook.yml` file and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to understand that Ansible doesn''t necessarily need to target
    an inventory group via the hosts line entry in a playbook. It can also target
    multiple groups, single hosts, wild cards, and more. Let''s take a look at some
    examples of other ways in which we can input the data within the `hosts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to these examples of loose host line values, the `hosts` section
    can also contain groupings such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to these examples, the `hosts` section can also leverage Ansible
    variables to target specific hosts. An example of this type of implementation
    is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the playbook reflects the `$myhosts` variable, we can set that variable
    with something like the example provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Based on this command, we can see that the we are able to target the production
    group (defined in the previous `hosts` file).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a very robust set of tools that can aid immensely in operational
    implementations. Common operational implementations include managing the configuration
    of a given system (ensuring that packages are installed, files are present, directory
    structures exist, and so on), provisioning a given system to meet a set of prerequisites,
    and more. As we discovered earlier, playbooks and their tasks help us achieve
    these goals by executing a set of automations against a given system.
  prefs: []
  type: TYPE_NORMAL
- en: While the knowledge we have gained can give us the basics we need to implement
    simple automations, we have really just barely scratched the surface of how Ansible
    works. Ansible integrates with hundreds of system-level tasks and thousands of
    external third-party solutions and can be leveraged in ways we haven't even begun
    to fathom. Let's peel back the layers a bit and see how we can leverage Ansible
    for basic Configuration Management.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible provides the bulk of its task functionality through Ansible modules.
    Ansible modules are essentially standalone interfaces that integrate Ansible with
    an OS or another technology. For example, Ansible has a module that integrates
    Ansible playbook automation with JIRA. So the JIRA module provides a direct link
    between the functionality available via the JIRA API and the automation formatting
    that makes up an Ansible playbook task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible implementation has three different module types. These module types
    are Core, Curated, Community, and Custom. Each of these modules have their own
    specific function and role within the Ansible solution. Let''s take a minute to
    look at what the Ansible documentation has to say about these different module
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core**: These are modules that the core Ansible team maintains and will always
    ship with ansible itself. They will also receive slightly higher priority for
    all requests. Non-core modules are still fully usable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curated**: Some examples of curated modules are submitted by other companies
    or maintained by the community. Maintainers of these types of modules must watch
    for any issues reported or pull requests raised against the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core committers will review all modules becoming curated. Core committers will
    review proposed changes to existing curated modules once the community maintainers
    of the module have approved the changes. Core committers will also ensure that
    any issues that arise due to Ansible engine changes will be remediated. Also,
    it is strongly recommended (but not presently required) for these types of modules
    to have unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: These modules are currently shipped with Ansible, but might be shipped separately
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**Community**: These modules are not supported by core committers or by companies/partners
    associated to the module. They are maintained by the community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are still fully usable, but the response rate to issues is purely up to
    the community. Best effort support will be provided but is not covered under any
    support contracts.
  prefs: []
  type: TYPE_NORMAL
- en: These modules are currently shipped with Ansible, but will most likely be shipped
    separately in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we are going to look at the core module solution and try to
    understand how it functions and the capabilities that it provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there are 1,021 unique Ansible modules available and
    provided by Ansible''s out-of-the-box solution. This means that Ansible has the
    potential to integrate very tightly with any number of operating systems, tools,
    and open source software. To better illustrate this, let''s take a quick look
    at just the categories of the Ansible modules provided at the official documentation
    ([http://docs.ansible.com/ansible/modules_by_category.html](http://docs.ansible.com/ansible/modules_by_category.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crypto modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote management modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web infrastructure modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see from the list, Ansible's integration is highly robust. Let's explore
    some of the more common modules and see how we can use them within our playbook
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Managing packages in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible integrates very tightly with a number of Linux flavors. This integration
    enables Ansible playbooks to maintain packages on target systems in a succinct
    and structured manner. From `yum` to `apt` and `opencws`, the package-management
    solution provided by the Ansible developers is robust and feature-rich. In this
    section, we will understand the fundamentals of package management through Ansible
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Yum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides a complete yum module, which effectively integrates it with
    common RHEL implementations of the yum repository system. Through Ansible''s yum
    interface, it is possible to perform almost all yum-related operations. Some examples
    of Ansibe''s yum capabilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing GPG checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a good idea of Ansible''s yum ninja skills, let''s take a
    look at some basic examples of how to perform operations with yum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The apt-get and dpkg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible''s integration with `apt-get` is equally as tight as Ansible''s integration
    with yum. The `apt-get` package, for those who are not familiar with it, is a
    package-management solution leveraged by Debian-based operating systems. The implementation
    of `apt-get` actuality sits on top of another solution called `dpkg`, and Ansible
    provides modules that support both. In this specific section, we will discuss
    apt-get specifically. In order to better understand the architecture that we are
    referencing, an illustration is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be077343-54d0-4b60-827d-6f344a4b7ca3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a good understanding of how `apt-get` works, let''s take a
    look at some examples of how Ansible integrates with this specific package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to `yum` and `apt` integration, Ansible actually integrates very
    well with a number of additional package-management solutions for other Linux
    distributions. Each of these (like the previous two) is supported through an Ansible
    module. The modules for these other flavors of Linux are crafted in such a way
    so as to provide as robust an integration as possible. For a complete module list
    of supported package-management solutions, the following link should provide a
    comprehensive guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.ansible.com/ansible/list_of_packaging_modules.html](http://docs.ansible.com/ansible/list_of_packaging_modules.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing users in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing users within an Ansible playbook need not be a daunting task. Ansible''s
    `user` module set provides tight integration with the Ansible core and the system-level
    users solution. The Ansible user module provides us with the ability to manage
    users and user attributes via YAML. As a result, operations such as add, remove,
    and update are usually quite easy to implement. Let''s take a look at how to perform
    some basic user operations using Ansible in conjunction with the users module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For a complete list of parameters that can be passed through the Ansible users
    module, refer to the official documentation on the users module located at [http://docs.ansible.com/ansible/user_module.html](http://docs.ansible.com/ansible/user_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: File and directory management in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible's file module provides integration between Ansible playbooks and the
    filesystem itself. This enables us to perform directory operations and basic file
    operations via an Ansible playbook task. In addition to basic **create**, **remove**,
    **update**, and **delete** (**CRUD**) operations, we can also set permissions,
    change owners, set group owners, operate on recursive folder trees, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some examples of basic file and directory management
    operations using the `file` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These examples provide just a glimpse into file management and Ansible's file
    module. For a complete list of available options, consult the Ansible documentation
    located at [http://docs.ansible.com/ansible/file_module.html](http://docs.ansible.com/ansible/file_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Managing services in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing services using Ansible is a breeze. Service management can be a complex
    operation and is usually highly dependent on the OS and system type. However,
    with Ansible''s service module, we can easily stop, start, and restart services.
    This integration provides a high level of reliability and abstracts the fundamental
    OS-level operations that must be performed. Let''s take a look at the Ansible
    `service` module and see its capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These examples provide us with some insight into Ansible's service control solution
    and how to manage services using Ansible playbooks. Now that we have a grasp on
    that, let's take a look at how to transfer files using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transferring files from the local Ansible control server to a set of target
    machines is critical for software deployment implementations. Ansible provides
    a very handy `copy` module that can help us accomplish exactly this. The `copy`
    module provides a number of handy property knobs, which can further our goal by
    allowing us to set file permissions, change ownership, decrypt the file, create
    backups, and more. Let''s take a look at how to deliver files from the local Ansible
    control server over to target machines using the `copy` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a good idea of how Ansible modules work and some implementation
    details, let's look at how to expand our knowledge and capabilities in developing
    robust and easy to maintain playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was quite a chapter. And we are nearing the halfway point in our journey
    through this book. In this chapter, we learned the basic constructs of Ansible
    playbook files, what YAML is, and the basic idea of how Jinja is incorporated
    as well. In addition to understanding the basic constructs, we learned how to
    create Ansible playbook YAML files, how to create and manage inventory files,
    and so much more. This chapter was quite a ride: acquiring knowledge and implementing
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at playbook syntax. This includes roles, includes,
    playbook directory structures, and loops and blocks. Consider the next chapter
    to be progression from of this chapter. Let's get started on it then, shall we?
  prefs: []
  type: TYPE_NORMAL
