<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Giving Containers Data and Parameters</h1></div></div></div><p>The WordPress data inside the WordPress container and the database's data inside the MySQL container may not be what we want. It's considered good practice to keep the data outside the service containers because you may want to separate the data from the service container. In this chapter, we'll cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data volumes</li><li class="listitem" style="list-style-type: disc">Creating a data volume image</li><li class="listitem" style="list-style-type: disc">Host on GitHub</li><li class="listitem" style="list-style-type: disc">Publishing on Docker Registry Hub</li><li class="listitem" style="list-style-type: disc">Running on Docker Registry Hub</li><li class="listitem" style="list-style-type: disc">Passing parameters to containers</li><li class="listitem" style="list-style-type: disc">Creating a parameterized image</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Data volumes</h1></div></div></div><p>There are two <a class="indexterm" id="id188"/>ways in which we can mount external volumes on our containers. A data volume lets you share data between containers, and the data inside the data volume is untouched if you update, stop, or even delete your service container.</p><p>A data volume is mounted with the <code class="literal">–v</code> option in the <code class="literal">docker run</code> statement:</p><div><pre class="programlisting">
<strong>docker run –v /host/dir:container/dir</strong>
</pre></div><p>You can add as many data volumes as you want to a container, simply by adding multiple <code class="literal">–v</code> directives.</p><p>A very good thing about data volumes is that the containers that get data volumes passed into them don't know about it, and don't need to know about it either. No changes are needed for the container; it works just as if it were writing to the local filesystem. You can override existing directories inside containers, which is a common thing to do. One usage of this is to have the web root (usually at <code class="literal">/var/www</code> inside the container) in a directory at the Docker host.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Mounting a host directory as a data volume</h2></div></div></div><p>You <a class="indexterm" id="id189"/>can mount a directory (or file) from your host <a class="indexterm" id="id190"/>on your container:</p><div><pre class="programlisting">
<strong>docker run –d --name some-wordpress –v /home/web/wp-one:/var/www wordpress</strong>
</pre></div><p>This will mount the host's local directory, <code class="literal">/home/web/wp-one</code>, as <code class="literal">/var/www</code> on the container. If you want to give the container only the read permission, you can change the directive to <code class="literal">–v /home/web/wp-one:/var/www:ro</code> where the <code class="literal">:ro</code> is the read-only flag.</p><p>It's not very common to use a <code class="literal">host</code> directory as a data volume in production, since data in a directory isn't very portable. But it's very convenient when testing how your service container behaves when the source code changes.</p><p>Any change you make in the host directory is direct in the container's mounted data volume.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Mounting a data volume container</h2></div></div></div><p>A more<a class="indexterm" id="id191"/> common way of handling <a class="indexterm" id="id192"/>data is to use a container whose only task is to hold data. The services running in the container should be as few as possible, thus keeping it as stable as possible.</p><p>Data volume containers can have exposed volumes via the Dockerfile's <code class="literal">VOLUME</code> keyword, and these volumes will be mounted on the service container while using the data volume container with the <code class="literal">--volumes-from</code> directive.</p><p>A very simple Dockerfile with a <code class="literal">VOLUME</code> directive can look like this:</p><div><pre class="programlisting">
<strong>FROM ubuntu:latest</strong>
<strong>VOLUME ["/var/www"]</strong>
</pre></div><p>A container using the preceding Dockerfile will mount <code class="literal">/var/www</code>. To mount the volumes from a data container onto a service container, we create the data container and then mount it, as follows:</p><div><pre class="programlisting">
<strong>docker run –d --name data-container our-data-container</strong>
<strong>docker run –d --name some-wordpress --volumes-from data-container wordpress</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Backing up and restoring data volumes</h2></div></div></div><p>Since the <a class="indexterm" id="id193"/>data in a data volume is shared between containers, it's <a class="indexterm" id="id194"/>easy to access the data by mounting it onto a temporary container. Here's how you can create a <code class="literal">.zip</code> file (from your host) from the data inside a data volume container that has <code class="literal">VOLUME ["/var/www"]</code> in its Dockerfile:</p><div><pre class="programlisting">
<strong>docker run --volumes-from data-container -v $(pwd):/host ubuntu zip -r /host/data-containers-www /var/www</strong>
</pre></div><p>This <a class="indexterm" id="id195"/>creates a <code class="literal">.zip</code> file named <code class="literal">data-containers-www.zip</code>, containing <a class="indexterm" id="id196"/>what was in the. <code class="literal">www</code> data container from <code class="literal">var</code> directory. This <code class="literal">.zip</code> file places that content in your current host directory.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Creating a data volume images</h1></div></div></div><p>Since our <a class="indexterm" id="id197"/>data volume container will just hold our data, we should keep it as small as possible to start with so that it doesn't take lots of unnecessary space on the server. The data inside the container can, of course, grow to be as big as the space on the server's disk. We don't need anything fancy at all; we just need a working file storage system.</p><p>For this book, we'll keep all our data (MySQL database files and WordPress files) in the same container. You can, of course, separate them into two data volume containers named something like <code class="literal">dbdata</code> and <code class="literal">webdata</code>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Data volume image</h2></div></div></div><p>Our data volume image does not need anything other than a working filesystem that we can read and write to. That's why our base image of choice will be BusyBox. This is how BusyBox<a class="indexterm" id="id198"/> describes<a class="indexterm" id="id199"/> itself:</p><div><blockquote class="blockquote"><p><em>"BusyBox combines tiny versions of many common UNIX utilities into a single small executable. It provides replacements for most of the utilities you usually find in GNU fileutils, shellutils, etc. The utilities in BusyBox generally have fewer options than their full-featured GNU cousins; however, the options that are included provide the expected functionality and behave very much like their GNU counterparts. BusyBox provides a fairly complete environment for any small or embedded system."</em></p></blockquote></div><p>That sounds great! We'll go ahead and add this to our Dockerfile:</p><div><pre class="programlisting">
<strong>FROM busybox:latest</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Exposing mount points</h3></div></div></div><p>There is <a class="indexterm" id="id200"/>a <code class="literal">VOLUME</code> instruction for the Dockerfile, where you can define which directories to expose to other containers when this data volume container is added using <code class="literal">--volumes-from</code> attribute. In our data volume containers, we first need to add a directory for MySQL data. Let's take a look inside the MySQL image we will be using to see which directory is used for the data storage, and expose that<a class="indexterm" id="id201"/> directory to our data volume container so that we can own it:</p><div><pre class="programlisting">
<strong>RUN mkdir –p /var/lib/mysql</strong>
<strong>VOLUME ["/var/lib/mysql"]</strong>
</pre></div><p>We also want our WordPress installation in this container, including all <code class="literal">.php</code> files and graphic images. Once again, we go to the image we will be using and find out which directory will be used. In this case, it's <code class="literal">/var/www/html</code>. When you add this to the Dockerfile, don't add new lines; just append the lines with the MySQL data directory:</p><div><pre class="programlisting">
<strong>RUN mkdir -p /var/lib/mysql &amp;&amp; mkdir -p /var/www/html</strong>
<strong>VOLUME ["/var/lib/mysql", "/var/www/html"]</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>The Dockerfile</h3></div></div></div><p>The <a class="indexterm" id="id202"/>following is a simple Dockerfile for the data image:</p><div><pre class="programlisting">
<strong>FROM busybox:latest</strong>
<strong>MAINTAINER Oskar Hane &lt;oh@oskarhane.com&gt;</strong>
<strong>RUN mkdir -p /var/lib/mysql &amp;&amp; mkdir -p /var/www/html</strong>
<strong>VOLUME ["/var/lib/mysql", "/var/www/html"]</strong>
</pre></div><p>And that's it! When publishing images to the Docker Registry Hub, it's good to include a <code class="literal">MAINTAINER</code> instruction in the Dockerfiles so that you can be contacted if someone wants, for some reason.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Hosting on GitHub</h1></div></div></div><p>When we <a class="indexterm" id="id203"/>use our knowledge on how to host Docker image <a class="indexterm" id="id204"/>sources on GitHub and how to publish images on the Docker Registry Hub, it'll be no problem creating our data volume image.</p><p>Let's create a branch and a Dockerfile and add the content for our data volume image:</p><div><pre class="programlisting">
<strong>git checkout -b data</strong>
<strong>vi Dockerfile</strong>
<strong>git add Dockerfile</strong>
</pre></div><p>On line number 2 in the preceding code, you can use the text editor of your choice. I just happen to find <code class="literal">vi</code> suits my needs. The content you should add to the Dockerfile is this:</p><div><pre class="programlisting">
<strong>FROM busybox:latest</strong>
<strong>MAINTAINER Oskar Hane &lt;oh@oskarhane.com&gt;</strong>
<strong>RUN mkdir /var/lib/mysql &amp;&amp; mkdir /var/www/html</strong>
<strong>VOLUME ["/var/lib/mysql", "/var/www/html"]</strong>
</pre></div><p>Replace<a class="indexterm" id="id205"/> the maintainer information with your name and<a class="indexterm" id="id206"/> e-mail.</p><p>You can—and should—always ensure that it works before committing and pushing to GitHub. To do so, you need to build a Docker image from your Dockerfile:</p><div><pre class="programlisting">
<strong>docker build –t data-test .</strong>
</pre></div><p>Make sure you notice the dot at the end of the line, which means that Docker should look for a Dockerfile in the current directory. Docker will try to build an image from the instructions in our Dockerfile. It should be pretty fast, since it's a small base image and there's nothing but a couple of <code class="literal">VOLUME</code> instructions on top of it.</p><p>The screenshot is as follows:</p><div><img alt="Hosting on GitHub" src="img/3946OT_04_01.png.jpg"/></div><p>When everything works as we want, it's time to commit the changes and push it to our GitHub repository:</p><div><pre class="programlisting">
<strong>git commit –m "Dockerfile for data volume added."</strong>
<strong>git push origin data</strong>
</pre></div><p>When <a class="indexterm" id="id207"/>you have pushed it to the repository, head over<a class="indexterm" id="id208"/> to GitHub to verify that your new branch is present there.</p><p>The following screenshot shows the GitHub repository:</p><div><img alt="Hosting on GitHub" src="img/3946OT_04_02.png.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Publishing on the Docker Registry Hub</h1></div></div></div><p>Now that <a class="indexterm" id="id209"/>we have our new branch on <a class="indexterm" id="id210"/>GitHub, we can go to the Docker Hub Registry and create a new automated build, named <code class="literal">data</code>. It will have our GitHub data branch as source.</p><div><img alt="Publishing on the Docker Registry Hub" src="img/3946OT_04_03.png.jpg"/></div><p>Wait for <a class="indexterm" id="id211"/>the build to finish, and then try to<a class="indexterm" id="id212"/> pull the image with your Docker daemon to verify that it's there and it's working.</p><p>The screenshot will be as follows:</p><div><img alt="Publishing on the Docker Registry Hub" src="img/3946OT_04_04.png.jpg"/></div><p>Amazing! Check out the size of the image; it's just less than 2.5 MB. This is perfect since we just want to store data in it. A container on top of this image can, of course, be as big as your hard drive allows. This is just to show how big the image is. The image is read-only, remember?</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Running a data volume container</h1></div></div></div><p>Data volume <a class="indexterm" id="id213"/>containers are special; they can be stopped and still fulfill their purpose. Personally, I like to see all containers in use when executing <code class="literal">docker ps</code> command, since I like to delete stopped containers once in a while.</p><p>This is totally up to you. If you're okay with keeping the container stopped, you can start it using this command:</p><div><pre class="programlisting">
<strong>docker run –d oskarhane/data true</strong>
</pre></div><p>The <code class="literal">true</code> argument is just there to enter a valid command, and the <code class="literal">–d</code> argument places the container in detached mode, running in the background.</p><p>If you want to keep the container running, you need to place a service in the foreground, like this:</p><div><pre class="programlisting">
<strong>docker run –d oskarhane/data tail –f /dev/null</strong>
</pre></div><p>The output of the preceding command is as follows:</p><div><img alt="Running a data volume container" src="img/3946OT_04_05.png.jpg"/></div><p>The <code class="literal">tail –f /dev/null</code> command is a command that never ends, so the container will be running until we stop it. Resource-wise, the <code class="literal">tail</code> command is pretty harmless.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Passing parameters to containers</h1></div></div></div><p>We have <a class="indexterm" id="id214"/>seen how to give containers parameters or environment variables when starting the official MySQL container:</p><div><pre class="programlisting">
<strong>docker run --name mysql-one -e MYSQL_ROOT_PASSWORD=pw -d mysql</strong>
</pre></div><p>The <code class="literal">–e MYSQL_ROOT_PASSWORD=pw command</code> is an example showing how you can do it. It means that the <code class="literal">MYSQL_ROOT_PASSWORD</code> environment variable inside the container has <code class="literal">pw</code> as the value.</p><p>This is a <a class="indexterm" id="id215"/>very convenient way to have configurable containers where you can have a setup script as <code class="literal">ENTRYPOINT</code> or a foreground script configuring passwords; hosts; test, staging, or production environments; and other settings that the container needs.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Creating a parameterized image</h1></div></div></div><p>Just to get the hang of this feature, which is very good, let's create a small Docker image that converts a string to uppercase or lowercase, depending on the state of an environment <a class="indexterm" id="id216"/>variable.</p><p>The Docker image will be based on the latest Debian distribution and will have only an <code class="literal">ENTRYPOINT</code> command. This is the <code class="literal">Dockerfile</code>:</p><div><pre class="programlisting">
<strong>FROM debian:latest</strong>
<strong>ADD ./case.sh /root/case.sh</strong>
<strong>RUN chmod +x /root/case.sh</strong>
<strong>ENTRYPOINT /root/case.sh</strong>
</pre></div><p>This takes the <code class="literal">case.sh</code> file from our current directory, adds it to the container, makes it executable, and assigns it as <code class="literal">ENTRYPOINT</code>.</p><p>The <code class="literal">case.sh</code> file may look something like this:</p><div><pre class="programlisting">
<strong>#!/bin/bash</strong>

<strong>if [ -z "$STR" ]; then</strong>
<strong>        echo "No STR string specified."</strong>
<strong>        exit 0</strong>
<strong>fi</strong>

<strong>if [ -z "$TO_CASE" ]; then</strong>
<strong>        echo "No TO_CASE specified."</strong>
<strong>        exit 0</strong>
<strong>fi</strong>

<strong>if [ "$TO_CASE" = "upper" ]; then</strong>
<strong>        echo "${STR^^*}"</strong>
<strong>        exit 0</strong>
<strong>fi</strong>
<strong>if [ "$TO_CASE" = "lower" ]; then</strong>
<strong>        echo "${STR,,*}"</strong>
<strong>        exit 0</strong>
<strong>fi</strong>
<strong>echo "TO_CASE was not upper or lower"</strong>
</pre></div><p>This file checks whether the <code class="literal">$STR</code> and <code class="literal">$TO_CASE</code> environment variables are set. If the check on whether <code class="literal">$TO_CASE</code> is <code class="literal">upper</code> or <code class="literal">lower</code> is done and if that fails, an error message <a class="indexterm" id="id217"/>saying that we only handle <code class="literal">upper</code> and <code class="literal">lower</code> is displayed.</p><p>If <code class="literal">$TO_STR</code> was set to <code class="literal">upper</code> or <code class="literal">lower</code>, the content of the environment variable <code class="literal">$STR</code> is transformed to uppercase or lowercase respectively, and then printed to <code class="literal">stdout</code>.</p><p>Let's try this!</p><div><img alt="Creating a parameterized image" src="img/3946OT_04_06.png.jpg"/></div><p>Here are some commands we can try:</p><div><pre class="programlisting">
<strong>docker run –i case</strong>
<strong>docker run –i -e STR="My String" case</strong>
<strong>docker run –i -e STR="My String" –e TO_CASE=camel case</strong>
<strong>docker run –i -e STR="My String" –e TO_CASE=upper case</strong>
<strong>docker run –i -e STR="My String" –e TO_CASE=lower case</strong>
</pre></div><p>This <a class="indexterm" id="id218"/>seems to be working as expected, at least for this purpose. Now we have created a container that takes parameters and acts upon them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, you learned that you can keep your data out of your service containers using data volumes. Data volumes can be any one of directories, files from the host's filesystem, or data volume containers.</p><p>We explored how we can pass parameters to containers and how to read them from inside <code class="literal">ENTRYPOINT</code>. Parameters are a great way to configure containers, making it easier to create more generalized Docker images.</p><p>We created a data volume container and published it to the Docker Registry Hub, preparing us for the next chapter, where we will connect our three containers to create one loosely coupled unit.</p></div></body></html>