- en: Chapter 5. Implementation of the Deployment Pipeline – Initial Stages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 部署管道的实现 - 初始阶段
- en: Let us start with some basic (and minimum) steps of the continuous deployment
    pipeline. We'll check out the code, run pre-deployment tests and, if they are
    successful, build a container and push it to the Docker registry. With the container
    safely available in the registry, we'll switch to a different VM that will serve
    as an imitation of a production server, run the container and perform post-deployment
    tests to ensure that everything works as expected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从持续部署管道的一些基本（和最小）步骤开始。我们将查看代码，运行部署前的测试，如果测试成功，将构建一个容器并将其推送到 Docker 注册表。容器安全地保存在注册表中后，我们将切换到另一台虚拟机，作为生产服务器的模拟，运行容器并进行部署后的测试，以确保一切按预期工作。
- en: Those steps will cover the most basic flow of what could be considered the continuous
    deployment process. Later on, in the next chapters, once we are comfortable with
    the process we did so far, we'll go ever further. We'll explore all the steps
    required for our microservice to safely and reliably reach the production servers
    with zero-downtime, in a way that allows us to scale easily, with the ability
    to rollback, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将涵盖被认为是持续部署流程中最基本的流程。在接下来的章节中，当我们对迄今为止所做的过程感到熟悉时，我们将进一步深入探讨。我们将探索所有必要的步骤，以确保我们的微服务能够安全可靠地无停机时间地到达生产服务器，并且可以轻松扩展，具备回滚能力，等等。
- en: Spinning Up the Continuous Deployment Virtual Machine
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动持续部署虚拟机
- en: We'll start by creating the continuous delivery server. We'll do that by creating
    a VM with Vagrant. While using VMs is useful as a mean to perform easy to follow
    exercises, in the real world scenario you should skip VM altogether and install
    everything directly on the server. Remember, containers are in many cases a better
    substitute for some of the things we are used to doing with VMs and using both,
    as we'll do throughout this book, is in most case only a waste of resources. With
    that being said, let us create the `cd` and `prod` VMs. We'll use the first one
    as a continuous deployment server and the second as an imitation of the production
    environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建持续交付服务器开始。我们将通过使用 Vagrant 创建一个虚拟机来实现这一点。虽然使用虚拟机作为一种执行易于跟随的练习的手段很有用，但在实际场景中，你应该完全跳过虚拟机，直接在服务器上安装一切。请记住，在许多情况下，容器是我们习惯用虚拟机做的一些事情的更好替代品，而我们在本书中将同时使用虚拟机和容器，但通常来说，这样做只是浪费资源。话虽如此，让我们创建
    `cd` 和 `prod` 虚拟机。我们将使用第一个作为持续部署服务器，第二个作为生产环境的模拟。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We cloned the GitHub repository, brought up the `cd` virtual machine and entered
    it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们克隆了 GitHub 仓库，启动了 `cd` 虚拟机并进入了其中。
- en: There are a few basic Vagrant operations you might need to know to follow this
    book. Specifically, how to stop and run the VM again. You never know when you
    might be left with an empty battery on your laptop or have a need to free your
    resources for some other tasks. I wouldn't like you to get into a situation where
    you are not able to follow the rest of the book just because you shut down your
    laptop and was not able to get back to the same situation you were before. Therefore,
    let's go through two basic operations; stopping the VM and bringing it up again
    with the provisioners.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基本的 Vagrant 操作你可能需要了解，以便跟上本书的内容。具体来说，如何停止虚拟机并再次启动它。你永远不知道什么时候你的笔记本电脑可能没电，或者你需要腾出资源处理其他任务。我不希望你在关闭笔记本电脑后无法重新进入到之前的状态，导致无法继续阅读本书。因此，让我们来了解两项基本操作：停止虚拟机和带有配置程序重新启动虚拟机。
- en: 'If you want to stop this VM, all you have to do is run the `vagrant halt` command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想停止这台虚拟机，只需运行 `vagrant halt` 命令：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this, VM will be stopped and your resources free for other things. Later
    on, you can start the VMs again with the `vagrant up`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，虚拟机将停止，并且你的资源将释放出来，供其他任务使用。稍后，你可以使用 `vagrant up` 命令再次启动虚拟机：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `--provision` flag will, among other things, make sure that all the containers
    we need are indeed up and running. The `prod` VM, unlike the `cd`, does not use
    any provisioning, so the `--provision` argument is not needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`--provision` 标志将确保我们需要的所有容器都已经启动并运行。与 `cd` 虚拟机不同，`prod` 虚拟机没有使用任何配置程序，因此不需要
    `--provision` 参数。'
- en: Deployment Pipeline Steps
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署管道步骤
- en: 'With the VM up and running (or soon to be), let us quickly go through the process.
    We should perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机已经启动并运行（或者即将启动），让我们快速浏览一下这个过程。我们应该执行以下步骤：
- en: Check out the code
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看代码
- en: Run pre-deployment tests
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行部署前的测试
- en: Compile and/or package the code
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和/或打包代码
- en: Build the container
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建容器
- en: Push the container to the registry
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器推送到注册中心
- en: Deploy the container to the production server
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器部署到生产服务器
- en: Integrate the container
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成容器
- en: Run post-integration tests
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行集成后测试
- en: Push the tests container to the registry![Deployment Pipeline Steps](img/B04858_05_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试容器推送到注册中心！[部署管道步骤](img/B04858_05_01.jpg)
- en: Figure 5-1 – The Docker deployment pipeline process
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5-1 – Docker部署管道流程
- en: At the moment we'll limit ourselves to manual execution and once we're comfortable
    with the way things work we'll transfer our knowledge to one of the CI/CD tools.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们将局限于手动执行，一旦我们对操作方式感到舒适，就会将这些知识迁移到其中一个CI/CD工具中。
- en: Checking Out the Code
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检出代码
- en: 'Checking out the code is easy, and we already did it a couple of times:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 检出代码很简单，我们已经做了几次：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running Pre – Deployment Tests, Compiling, and Packaging the Code
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行预部署测试、编译和打包代码
- en: With the code checked out, we should run all the tests that do not require the
    service to be deployed. We already did the procedure when we tried different things
    we could do in the development environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在检出代码后，我们应运行所有不需要服务已部署的测试。我们在尝试不同的开发环境操作时已经执行过这个过程。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First we built the tests container defined in the Dockerfile.test file and tagged
    it with the `-t` argument. The name (or tag) of the container is `10.100.198.200:5000/books-ms-tests`.
    That is the special syntax with the first part being the address of the local
    registry and the second part the actual name of the container. We'll discuss and
    use the Registry later on. For now, it's important to know that we use it to store
    and retrieve containers we're building.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构建了在Dockerfile.test文件中定义的测试容器，并使用`-t`参数为它打了标签。容器的名称（或标签）是`10.100.198.200:5000/books-ms-tests`。这是一个特殊语法，第一部分是本地注册中心的地址，第二部分是容器的实际名称。稍后我们将讨论并使用注册中心。目前，重要的是要知道我们用它来存储和检索我们构建的容器。
- en: The second command run all the pre-deployment tests and compiled the Scala code
    into a JAR file ready for the distribution. The third command is only for demonstration
    purposes so that you can confirm that the JAR file is indeed created and resides
    in the `scala-2.10` directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令运行所有的预部署测试，并将Scala代码编译成一个准备分发的JAR文件。第三个命令仅用于演示，目的是让你确认JAR文件确实已创建，并且位于`scala-2.10`目录中。
- en: Keep in mind that the reason for such a long time it took to build the container
    is because of a lot of things had to be downloaded for the first time. Each consecutive
    build will be much faster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，构建容器所需的时间较长是因为许多东西需要第一次下载。每次之后的构建都会快得多。
- en: All we did up to now was running different commands without trying to understand
    what is behind them. Please note that commands to build Docker containers can
    be repeated in case of a failure. For example, you might lose your internet connection
    and, in such a case, building container would fail. If you repeat the build command,
    Docker will continue from the images that failed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的只是运行不同的命令，而没有尝试理解它们背后的原理。请注意，构建Docker容器的命令在失败时可以重复执行。例如，你可能会失去互联网连接，在这种情况下，构建容器会失败。如果你重复构建命令，Docker会从上次失败的镜像继续。
- en: I wanted you to get a feeling of how Docker works from the perspective of those
    who just use pre-made containers or Dockerfile definitions created by others.
    Let us change this rhythm and dive into Dockerfile that is used to define containers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能从那些仅使用预制容器或其他人创建的Dockerfile定义的角度，了解Docker是如何工作的。让我们改变节奏，深入研究用于定义容器的Dockerfile。
- en: Building Docker Containers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Docker容器
- en: 'With all the tests passed and the JAR file created, we can build the container
    that we''ll deploy to production later on. Before we do that, let us examine the
    Dockerfile that contains all the information Docker needs for building the container.
    Contents of the Dockerfile are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试通过并且JAR文件已创建后，我们可以构建要部署到生产环境的容器。在此之前，让我们先检查包含所有Docker构建容器所需信息的Dockerfile。Dockerfile的内容如下：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can find the *Dockerfile* file together with the rest of the `books-ms`
    code in the [https://github.com/vfarcic/books-ms](https://github.com/vfarcic/books-ms)
    GitHub repository.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/vfarcic/books-ms](https://github.com/vfarcic/books-ms)
    GitHub库中找到*Dockerfile*文件以及其他`books-ms`代码。
- en: 'Let us go through it line by line:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line specifies which image should be used as the base of the container
    we're building. In our case, we are using *Debian* (version *Jessie*). That means
    that we should have most of the functionality we would get with Debian OS. However,
    that is not to say that the whole OS is downloaded when we pull this container.
    Remember, Docker is using host kernel so when we specify that container should
    use, for example, Debian as its base, we are only downloading image that has things
    specific to the OS we specified, like, for instance, packaging mechanism (*apt*
    in the case of Debian). What are the differences between various base images?
    Why did we choose the *debian* image to part from?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指定了我们正在构建的容器应使用的基础镜像。在我们的案例中，我们使用的是*Debian*（版本*Jessie*）。这意味着我们应该拥有与Debian操作系统相同的大部分功能。然而，这并不意味着当我们拉取这个容器时会下载整个操作系统。请记住，Docker使用的是主机内核，所以当我们指定容器应使用，例如Debian作为其基础时，我们仅下载包含我们指定操作系统特定内容的镜像，比如Debian的打包机制（在Debian中是*apt*）。不同的基础镜像之间有什么区别？为什么我们选择了*debian*镜像作为起点？
- en: In most cases the best choice for a base image is one of the official Docker
    images. Since Docker itself maintains those, they tend to be better controlled
    than those created by the community. The choice of the exact image one should
    use depends on the needs. Debian is my preference in many cases. Besides my liking
    of Debian-based Linux distributions, it is relatively small (~125 MB) and still
    a full distribution with everything you might need from a Debian OS. On the other
    hand, you might be familiar with RPM packaging and prefer, for example, CentOS.
    Its size is around 175 MB (approximately 50 % bigger than Debian). There are,
    however, some other cases when size is of utmost importance. That is especially
    true for images that would serve as utilities that are run once in a while to
    perform some specific actions. In such cases, Alpine might be a good start. Its
    size is 5 MB making it minuscule. However, bear in mind that, due to its minimalistic
    approach, this image might be hard to reason with when more complicated commands
    are run on top of it. Finally, in many cases, you might want to use more specific
    images as a base of your containers. For example, if you need a container with
    MongoDB but have few specific actions to perform on its initialization, you should
    use the mongo image.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，基础镜像的最佳选择是官方Docker镜像之一。由于Docker本身维护这些镜像，它们通常比社区创建的镜像更受控制。选择使用哪种镜像取决于需求。Debian是我在许多情况下的首选。除了我喜欢基于Debian的Linux发行版外，它相对较小（大约125MB），并且仍然是一个完整的发行版，包含你从Debian操作系统中可能需要的一切。另一方面，你可能熟悉RPM打包，偏好使用例如CentOS。它的大小大约是175MB（大约比Debian大50%）。然而，也有一些情况，大小是最重要的，尤其是对于那些偶尔运行以执行特定操作的工具镜像。在这种情况下，Alpine可能是一个不错的选择。它的大小为5MB，非常小。然而，要注意，由于它的极简主义方式，当在其上执行更复杂的命令时，可能会比较难以理解。最后，在许多情况下，你可能希望使用更具体的镜像作为容器的基础。例如，如果你需要一个包含MongoDB的容器，并且需要在初始化时执行一些特定操作，那么你应该使用mongo镜像。
- en: In systems that host many containers, the size of the base image is less important
    than how many different base images are used. Remember, each image is cached on
    the server and reused across all containers that use it. If all your containers
    are, for example, extending from the **debian** image, the same cached copy will
    be reused in all cases meaning that it will be downloaded only once.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管多个容器的系统中，基础镜像的大小比使用多少种不同的基础镜像更不重要。记住，每个镜像都会被缓存到服务器上，并且在所有使用它的容器中重复使用。如果你的所有容器都，例如，继承自**debian**镜像，那么相同的缓存副本将在所有容器中被重用，这意味着它只会被下载一次。
- en: What we use as a base image is a container like any other. That means that you
    can use your containers as a base for others. For example, you might have many
    cases with applications that require NodeJS in combination with Gulp and few scripts
    specific to your organization. This scenario would be a good candidate for a container
    that would be extended (through the `FROM` instruction) by others.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为基础镜像使用的也是一个容器，和其他容器没有区别。这意味着你可以使用你的容器作为其他容器的基础。例如，你可能有许多应用程序需要将NodeJS与Gulp结合使用，并且有一些特定于你组织的脚本。这种情况是一个很好的候选场景，适合使用容器并通过`FROM`指令被其他容器扩展。
- en: 'Let us move to the next instruction:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个指令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The maintainer is purely informational providing information about the author;
    a person who maintains the container. Not much to do here. Moving on:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 维护者字段纯粹是提供关于作者的信息；即维护该容器的人员。这里没什么可做的。继续：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `RUN` instruction executes any set of commands that run in the same way
    as if those commands are run in the command prompt. You might have noticed that
    each but the last line in our example ends with `&& \`. We are joining several
    separate commands instead of running each of them as a separate RUN instruction.
    The same result (from the operational perspective) could be accomplished with
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令执行的一组命令，就像这些命令在命令提示符下运行一样。你可能注意到，除了最后一行外，我们示例中的每一行都以`&& \`结尾。我们将多个独立的命令连接在一起，而不是将它们每个作为独立的`RUN`指令执行。从操作的角度来看，以下方式也能实现相同的结果：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That certainly looks cleaner and easier to maintain. However, it has its set
    of problems. One of them is that each instruction in the Dockerfile generates
    a separate image. A container is a collection of images stacked one on top of
    the other. Knowing that, last two `RUN` instructions (`clean` and `rm`) do not
    provide any value. Let's illustrate it by putting (invented numbers) of the size
    of each image. First two instructions (`apt-get update` and `apt-get install`)
    are adding packages (let's say 100 MB). The second two (`apt-get clean` and `rm`)
    are removing files (let's say 10 MB). While removal of files on a normal system
    does reduce the size of what we have stored on the HD, in the case of Docker containers
    it only removes things from the current image. Since each image is *immutable*,
    previous two images continue to have the size of 100 MB thus not removing the
    overall size of the container even though files removed later on are not accessible
    within the container. The size of those four images continues being 100 MB. If
    we go back to the first example where all commands are executed within the same
    `RUN` instruction thus creating a single image, the size is smaller (100 MB -
    10 MB = 90 MB).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实看起来更干净且更易于维护。然而，它也有一系列问题。其中之一是，Dockerfile中的每个指令都会生成一个单独的镜像。容器是由一层层叠加的镜像组成的。知道这一点后，最后两个`RUN`指令（`clean`和`rm`）并没有带来任何价值。我们可以通过假设每个镜像的大小来说明这一点（假设的数字）。前两个指令（`apt-get
    update`和`apt-get install`）是添加软件包（假设为100 MB）。后两个指令（`apt-get clean`和`rm`）是删除文件（假设为10
    MB）。虽然在普通系统中删除文件确实会减少硬盘上存储的大小，但在Docker容器中，它仅仅是从当前镜像中删除了东西。由于每个镜像是*不可变的*，之前的两个镜像仍然保持100
    MB的大小，因此即使删除的文件在容器内不可访问，整体容器的大小也没有减少。这四个镜像的大小依然是100 MB。如果我们回到第一个示例，其中所有命令都在同一个`RUN`指令内执行，从而创建了一个单一的镜像，那么大小会更小（100
    MB - 10 MB = 90 MB）。
- en: The important thing to note is that the size is not the only important consideration
    and we should try to balance it with maintainability. *Dockerfile* needs to be
    readable, easy to maintain and with a clear intention behind it. That means that
    in some cases the benefits of having one huge `RUN` instruction might not be the
    best option if that means that it will be hard to maintain it later on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，大小并不是唯一需要考虑的因素，我们应该尝试将其与可维护性进行平衡。*Dockerfile*需要具有可读性、易于维护，并且要有明确的意图。这意味着在某些情况下，如果一个巨大的`RUN`指令让后期维护变得困难，那么这种方式可能并不是最佳选择。
- en: All that being said, the purpose of the RUN command in our example is to update
    the system with latest packages (`apt-get update`), install JDK 7 (`apt-get install`)
    and remove unnecessary files created during the process (`apt-get clean` and `rm`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们示例中`RUN`命令的目的是更新系统中的最新软件包（`apt-get update`）、安装JDK 7（`apt-get install`）以及删除在此过程中创建的不必要的文件（`apt-get
    clean`和`rm`）。
- en: 'The next set of instructions provides the container with environment variables
    that can be changed at runtime:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组指令为容器提供了可在运行时更改的环境变量：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this particular case, we are declaring variables `DB_DBNAME` and `DB_COLLECTION`
    with default values. The code of the service uses those variables to create the
    connection to the *Mongo DB*. If, for some reason, we'd like to change those values,
    we could set them when executing the `docker run` command (as we'll see later
    on throughout the book).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们声明了`DB_DBNAME`和`DB_COLLECTION`变量并为其赋予了默认值。服务的代码使用这些变量来连接*Mongo DB*。如果出于某种原因，我们想要更改这些值，我们可以在执行`docker
    run`命令时进行设置（正如我们将在本书后续章节中看到的那样）。
- en: In the container world, we are discouraged from passing environment specific
    files to containers running on different servers. Ideally, we should run a container
    without any other external files. While that is in some cases impractical (as,
    for example, with *nginx* that we'll use later on for reverse proxy), environment
    variables are a preferred way of passing environment specific information to the
    container at runtime.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器世界中，我们不鼓励将特定于环境的文件传递给在不同服务器上运行的容器。理想情况下，我们应该在没有任何外部文件的情况下运行容器。虽然在某些情况下这不太实际（例如，稍后我们将使用的*nginx*进行反向代理），但环境变量是传递特定于环境的信息到容器的首选方式。
- en: 'Next, in our example, are a couple of `COPY` instructions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的示例中，有几个`COPY`指令：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`COPY` instruction is true to its name. It copies files from the host file
    system to the container we are building. It should be written in the `COPY <source>...
    <destination>` format. The `source` is relative to the location of the *Dockerfile*
    and must be inside the context of the build. What the latter statement means is
    that you cannot copy files that are not inside the directory where *Dockerfile*
    resides or one of its child directories. For example, `COPY ../something /something`
    is not allowed. The source can be a file or a whole directory and can accept wildcards
    matching the Go''s `filepath.Match` rules. The destination can also be a file
    or a directory. Destination matches the type of the source. If the source is a
    file, destination will be a file as well. Same is true when the source is a directory.
    To force destination to be a directory, end it with a slash (`/`).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令顾名思义，它会将文件从主机文件系统复制到我们正在构建的容器中。它的写法应该是`COPY <source>... <destination>`格式。`source`相对于*Dockerfile*的位置，并且必须在构建的上下文内。后者的意思是，你不能复制不在*Dockerfile*所在目录或其子目录中的文件。例如，`COPY
    ../something /something`是不允许的。源文件可以是单个文件或整个目录，并且可以使用符合Go的`filepath.Match`规则的通配符。目标可以是文件或目录。目标与源类型匹配。如果源是文件，目标也会是文件；如果源是目录，目标也会是目录。为了强制目标为目录，可以在目标路径末尾加上斜杠（`/`）。'
- en: While we haven't used `ADD` in our example, it is worth noting that it is very
    similar to `COPY`. In most cases I encourage you to use `COPY` unless you need
    additional features that `ADD` provides (most notably `TAR` extraction and URL
    support).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在示例中没有使用`ADD`指令，但值得注意的是，它与`COPY`非常相似。在大多数情况下，我鼓励你使用`COPY`，除非你需要`ADD`提供的额外功能（最明显的是`TAR`解压和URL支持）。
- en: In our example, we are copying `run.sh` and making it executable through the
    `chmod RUN` instruction. Next, we are copying the rest of the files (back-end
    `JAR` and front-end *components*).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们正在复制`run.sh`并通过`chmod RUN`指令使其可执行。接着，我们将复制其余的文件（后端的`JAR`文件和前端的*组件*）。
- en: Let us go through the last two instructions from our Dockerfile.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起了解一下我们Dockerfile中的最后两个指令。
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `CMD` specifies the command that will be executed when the container starts.
    The format is [`executable`, `parameter1`, `parameter2` and so on]. In our case
    `/run.sh` will run without any parameters. At the moment, the script contains
    a single command `java -jar bs.jar` that will start the Scala/Spray server. Keep
    in mind that `CMD` provides only the default executor that can be easily overwritten
    when a container is run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指定容器启动时将执行的命令。格式为[`executable`, `parameter1`, `parameter2`，以此类推]。在我们的示例中，`/run.sh`将无参数运行。目前，脚本包含一个命令`java
    -jar bs.jar`，它将启动Scala/Spray服务器。请记住，`CMD`只提供默认的执行命令，在容器运行时可以轻松地被覆盖。'
- en: The `EXPOSE` instruction specifies which port inside the container will be available
    at runtime.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令指定容器内哪个端口将在运行时可用。'
- en: The example *Dockerfile* we explained does not contain all the instructions
    we could use. Throughout this book, we'll work with a couple of others and get
    more familiar with the format. In the meantime, please visit the Dockerfile reference
    for more information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释的这个示例*Dockerfile*并不包含我们可以使用的所有指令。在本书中，我们将与其他一些指令一起工作，并更熟悉它们的格式。在此期间，请访问Dockerfile参考文档了解更多信息。
- en: 'Equipped with this knowledge, let us build the container. The command is as
    follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，让我们来构建容器。命令如下：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let us use the time it takes for this command run (the first build always takes
    longer than the others) and go through the arguments we used. The first argument
    is `build` used for building containers. Argument `-t` allows us to tag the container
    with a particular name. If you'd like to push this container to the public Hub,
    the tag would be using the `/` format. If you have the account on Docker Hub,
    the username is used to identify you and can be used later on to push the container
    making it available for pulling on any server connected to the internet. Since
    I'm not willing to share my password, we took a different approach and used the
    *registry* IP and port instead of the Docker Hub username. That allows us to push
    it to the private registry instead. This alternative is usually better because
    it provides us with a complete control over our containers, tends to be faster
    over the local network and won't give CEO of your company a heart attack for sending
    your applications to the cloud. Finally, the last argument is a dot (`.`) specifying
    that the Dockerfile is located in the current directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用此命令的运行时间（第一次构建通常比其他构建花费更长时间），并回顾我们使用的参数。第一个参数是`build`，用于构建容器。参数`-t`允许我们为容器打上特定的标签。如果你想将容器推送到公共Hub，标签应该使用`/`格式。如果你在Docker
    Hub上有账号，用户名用于标识你，并且可以在后续推送容器时使用，从而使容器在任何连接到互联网的服务器上都可以拉取。由于我不愿意分享我的密码，我们采取了不同的方法，使用*注册表*的IP和端口，而不是Docker
    Hub的用户名。这样我们就能将容器推送到私有注册表。这种方法通常更好，因为它能提供我们对容器的完全控制，通常在本地网络上速度更快，并且不会让你公司的CEO因将应用推送到云端而心脏病发作。最后，最后一个参数是一个点（`.`），表示Dockerfile位于当前目录。
- en: One important thing left to discuss is the order of instructions in the *Dockerfile*.
    On one hand, it needs to be in logical. We can not, for example, run an executable
    before installing it or, as in our example, change permissions of the `run.sh`
    file before we copy it. On the other hand, we need to take in account Docker caching.
    When a `docker build` command is run, Docker will go instruction by instruction
    and check whether some other build process already created the image. Once an
    instruction that will build a new image is found, Docker will build not only that
    instruction but of all those that follow. That means that, in most cases, `COPY`
    and `ADD` instructions should be placed near the bottom of the *Dockerfile*. Even
    within a group of `COPY` and `ADD` instructions, we should make sure to place
    higher those files that are less likely to change. In our example, we're adding
    `run.sh` before the `JAR` file and front-end components since latter are likely
    to change with every build. If you execute the `docker build` command the second
    time you'll notice that Docker outputs `---> Using cache` in all steps. Later
    on, when we change the source code, Docker will continue outputting `---> Using
    cache` only until it gets to one of the last two `COPY` instructions (which one
    it will be, depends on whether we changed the `JAR` file or the front-end components).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件重要的事情需要讨论，那就是*Dockerfile*中指令的顺序。一方面，它需要有逻辑性。例如，我们不能在安装可执行文件之前运行它，或者像我们例子中那样，在复制`run.sh`文件之前就改变它的权限。另一方面，我们需要考虑到Docker的缓存。当运行`docker
    build`命令时，Docker会逐条检查指令，看看是否已有其他构建过程创建了镜像。一旦找到一个会创建新镜像的指令，Docker不仅会执行该指令，还会执行所有后续的指令。这意味着，在大多数情况下，`COPY`和`ADD`指令应该放在*Dockerfile*的底部。即使在`COPY`和`ADD`指令的分组中，我们也应该确保把不太可能更改的文件放在上面。在我们的例子中，我们先添加`run.sh`，再添加`JAR`文件和前端组件，因为后者在每次构建时更可能发生变化。如果你第二次执行`docker
    build`命令，你会注意到Docker在所有步骤中输出`---> 使用缓存`。稍后，当我们更改源代码时，Docker将继续输出`---> 使用缓存`，直到遇到最后两个`COPY`指令中的一个（具体是哪个，取决于我们是更改了`JAR`文件还是前端组件）。
- en: We'll be using Docker commands a lot, and you'll have plenty opportunity to
    get more familiar with them. In the meantime, please visit the Using the command
    line page for more information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常使用Docker命令，你将有很多机会更加熟悉它们。与此同时，请访问[使用命令行页面](https://example.org)获取更多信息。
- en: Hopefully, by this time, the container is already built. If not, take a short
    break. We are about to run our newly built container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到此时，容器已经构建完成。如果没有，请休息一下。我们即将运行我们新构建的容器。
- en: Running Containers
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'Running containers is easy as long as you know which arguments to use. The
    container we just built can be run with the following commands:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你知道使用哪些参数，运行容器就非常简单。我们刚刚构建的容器可以使用以下命令来运行：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first command started the database container required by our service. The
    argument `-d` allows us to run a container in detached mode, meaning that it will
    run in the background. The second one, `--name books-db`, gives the container
    a name. If not specified, Docker would assign a random one. Finally, the last
    argument is the name of the image we want to use. In our case, we're using *mongo*,
    the official Docker MongoDB image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令启动了我们的服务所需的数据库容器。参数`-d`让我们可以在分离模式下运行容器，意味着它将运行在后台。第二个命令`--name books-db`为容器指定了一个名称。如果不指定，Docker会分配一个随机名称。最后，最后一个参数是我们想要使用的镜像名称。在我们的例子中，我们使用的是官方的Docker
    MongoDB镜像*mongo*。
- en: This command shows one of very useful Docker features. Just as GitHub revolutionized
    the way we share code between different developers and projects, Docker Hub changed
    the way we deploy not only applications we are building but also those built by
    others. Please feel free to visit [https://hub.docker.com/](https://hub.docker.com/)
    and search for your favorite application, service, or a database. Chances are
    you'll find not only one (often official docker container) but many others done
    by the community. Efficient usage of Docker is often a combination of running
    images built by yourself and those built by others. Even if no image serves your
    purpose, it is often a good idea to use existing one as a base image. For example,
    you might want MongoDB with *replication set* enabled. The best way to obtain
    such an image would be to use *mongo* as the `FROM` instruction in your *Dockerfile*
    and add replication commands below it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令展示了Docker的一个非常有用的功能。就像GitHub彻底改变了我们在不同开发者和项目之间共享代码的方式一样，Docker Hub也改变了我们部署应用程序的方式，不仅是我们自己构建的应用程序，也包括其他人构建的应用程序。欢迎访问[https://hub.docker.com/](https://hub.docker.com/)并搜索你喜欢的应用、服务或数据库。你很可能会找到不仅是一个（通常是官方的docker容器），而且还有很多社区创建的其他容器。高效使用Docker通常是自己构建的镜像和其他人构建的镜像相结合的结果。即使没有一个镜像完全符合你的需求，通常也可以使用现有的镜像作为基础镜像。例如，如果你想要启用*复制集*的MongoDB，最好的方法是将*mongo*作为`FROM`指令在你的*Dockerfile*中，并在其下方添加复制集命令。
- en: The second `docker run` is a little bit more complicated. Besides running in
    detached mode and giving it a name, it also exposes port 8080 and links with the
    `books-ms-db` container. Exposing port is easy. We can provide a single port,
    for example `-p 8080`. In such a case, Docker will expose its internal port `8080`
    as a random port. We'll use this approach later on when we start working with
    *service discovery tools*. In this example, we used two ports separated by a colon
    (`-p 8080:8080`). With such argument, Docker exposed its internal port 8080 to
    8080\. The next argument we used is `--link books-db:db` and allows us to link
    two containers. In this example, the name of the container we want to link to
    is *books-ms-db*. Inside the container, this link will be converted into environment
    variables. Let see how those variables look like.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`docker run`命令稍微复杂一些。除了在分离模式下运行并指定名称外，它还暴露了8080端口并与`books-ms-db`容器进行连接。暴露端口非常简单。我们可以提供一个端口，例如`-p
    8080`。在这种情况下，Docker会将其内部端口`8080`暴露为一个随机端口。稍后我们在使用*服务发现工具*时会采用这种方法。在这个例子中，我们使用了两个端口，由冒号分隔（`-p
    8080:8080`）。使用此参数时，Docker会将其内部端口8080暴露为外部端口8080。接下来的参数是`--link books-db:db`，它允许我们将两个容器连接起来。在这个例子中，我们要连接的容器名称是*books-ms-db*。在容器内部，这个链接将转换为环境变量。让我们看看这些变量是什么样的。
- en: 'We can enter the running container using the `exec` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`exec`命令进入正在运行的容器：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Arguments `-it` tells Docker that we want this execution to be interactive
    and with a terminal. It is followed by the name of the running container. Finally,
    we are overwriting the default command specified as the `CMD` instruction in the
    *Dockerfile* with *bash*. In other words, we entered into the running container
    by running *bash*. Once inside the container, we listed all environment variables
    and filtered them so that only those containing `DB` are output. When we run the
    container, we specified that it should link with `books-ms-db` as `db`. Since
    all environment variables are always in uppercase, Docker created quite a few
    of them with names starting with `DB`. The output of `env` was as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`-it`告诉Docker我们希望此执行为交互式并且带有终端。接着是运行中的容器名称。最后，我们通过`bash`覆盖了在*Dockerfile*中指定的默认命令`CMD`。换句话说，我们通过运行*bash*进入了正在运行的容器。进入容器后，我们列出了所有的环境变量并进行了筛选，仅输出包含`DB`的环境变量。运行容器时，我们指定它应当与`books-ms-db`连接，命名为`db`。由于所有环境变量通常都是大写的，Docker创建了许多以`DB`开头的环境变量。`env`命令的输出如下：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All but the last two are a result of linking with the other container. We got
    the name of the link, TCP, port, and so on. The last two (`DB_COLLECTION` and
    `DB_DBNAME`) are not the result of linking but variables we defined inside the
    *Dockerfile*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除最后两个外，其他都是通过与另一个容器的链接而得到的。我们获取了链接的名称、TCP、端口等信息。最后两个（`DB_COLLECTION` 和 `DB_DBNAME`）不是通过链接得到的，而是我们在
    *Dockerfile* 中定义的变量。
- en: Finally, we exited the container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们退出了容器。
- en: 'There are few more things we can do to ensure that everything is running correctly:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他操作可以确保一切正常运行：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ps -a` command listed all (`-a`) containers. This command should output
    both `books-ms` and `books-ms-db`. The `logs` command, as the name says, outputs
    logs of the container `books-ms`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps -a` 命令列出了所有 (`-a`) 容器。该命令应该输出 `books-ms` 和 `books-ms-db`。`logs` 命令顾名思义，输出容器
    `books-ms` 的日志。'
- en: 'Even though it was very easy to run the Mongo DB and our container, `books-ms`,
    we are still required to remember all the arguments. Much easier way to accomplish
    the same result is with **Docker Compose**. Before we see it in action, let us
    remove the container we are running:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管运行 Mongo DB 和我们的容器 `books-ms` 非常简单，但我们仍然需要记住所有参数。实现相同结果的更简单方法是使用 **Docker
    Compose**。在看到它如何工作的之前，让我们先删除我们正在运行的容器：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first command (`rm`) removes all listed containers. The argument `-f` forces
    that removal. Without it, only stopped containers could be removed. The `rm` command
    combined with the `-f` argument is equivalent to stopping containers with the
    `stop` command and then removing them with `rm`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令（`rm`）删除所有列出的容器。`-f` 参数强制删除。如果没有它，只有停止的容器可以被删除。将 `rm` 命令与 `-f` 参数结合使用，相当于先通过
    `stop` 命令停止容器，然后通过 `rm` 删除它们。
- en: 'Let us run the same two containers (`mongo` and `books-ms`) with **Docker Compose**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 **Docker Compose** 运行相同的两个容器（`mongo` 和 `books-ms`）：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the command is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time, we run both containers with a single `docker-compose` command. The
    `-f` argument specifies the specification file we want to use. I tend to define
    all development configurations in `docker-compose-dev.yml` and production in the
    default `docker-compose.yml`. When default file name is used, there is no need
    for the `-f` argument. Next is the `up` command that brought up the `app` container
    in detached mode (`-d`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们通过一个 `docker-compose` 命令运行了两个容器。`-f` 参数指定了我们想要使用的配置文件。我倾向于在 `docker-compose-dev.yml`
    中定义所有开发配置，在默认的 `docker-compose.yml` 中定义生产环境配置。使用默认文件名时，无需使用 `-f` 参数。接下来是 `up`
    命令，它以分离模式 (`-d`) 启动了 `app` 容器。
- en: 'Let''s take a look at the contents of the `docker-compose-dev.yml` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `docker-compose-dev.yml` 文件的内容：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The above output only displays the targets we are interested right now. There
    are others primarily dedicated to testing and compiling. We used them before when
    we set up the development environment. We'll use them again later on. For now,
    let us discuss the `app` and `db` targets. Their definition is very similar to
    Docker commands and arguments we already used and should be easy to understand.
    The interesting one is `links`. Unlike linking with manual commands where we need
    first to start the source container (in our case `mongo`) and then the one that
    links to it (`books-ms`), `docker-compose` will start all dependant containers
    automatically. We run the `app` target and Docker compose realized that it depends
    on the `db` target, so it started it first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出仅显示了我们现在关注的目标。还有其他主要用于测试和编译的目标。我们之前在设置开发环境时使用过它们，稍后我们还会使用它们。现在，让我们讨论一下
    `app` 和 `db` 目标。它们的定义与我们已经使用过的 Docker 命令和参数非常相似，应该很容易理解。最有意思的是 `links`。与手动命令的链接不同，手动命令需要先启动源容器（在我们案例中是
    `mongo`），然后再启动与之链接的容器（`books-ms`），而 `docker-compose` 会自动启动所有依赖的容器。我们运行 `app` 目标时，Docker
    Compose 发现它依赖于 `db` 目标，因此它首先启动了 `db`。
- en: 'As before, we can verify that both containers are up and running. This time,
    we''ll do it with the Docker Compose:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们可以验证两个容器是否都已启动并运行。这次，我们将使用 Docker Compose 来验证：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output should be similar to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Docker Compose, by default, names running containers using the combination of
    the project name (which default to the name of the directory), the name of the
    target (`app`) and the instance number (`1`). Later on, we'll run multiple instances
    of the same container distributed across multiple servers, and you'll have the
    chance to see this number increase.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 默认使用项目名称（默认为目录名称）、目标名称（`app`）和实例编号（`1`）来命名运行中的容器。稍后，我们将运行多个相同容器实例，分布在多个服务器上，你将有机会看到这个数字的增加。
- en: With both containers up and running, we can check the logs of the containers
    we run with Docker Compose.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 两个容器都启动并运行后，我们可以检查 Docker Compose 运行的容器日志。
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Please note that Docker Compose logs are in the `follow` mode, and you need
    to press *Ctrl* + *C* to stop it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker Compose 的日志是以 `follow` 模式显示的，您需要按 *Ctrl* + *C* 来停止它。
- en: I prefer as much testing as possible to be automatic, but that subject is left
    for later chapters so a brief manual verification will have to do for now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于尽可能让测试自动化，但这个话题留到后续章节再讨论，所以目前只能进行简短的手动验证。
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For those unfamiliar with `curl`, it is a command line tool and library for
    transferring data with URL syntax. In our case, we're using it to send three `PUT`
    requests to the service that, in turn, stored data to the MongoDB. Last two commands
    invoked the service APIs to retrieve a list of all books, as well as data related
    to a particular book with the ID 1\. With those manual verifications, we confirmed
    that the service works and can communicate with the database. Please note that
    we used `jq` to format JSON output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉 `curl` 的人来说，它是一个用于通过 URL 语法传输数据的命令行工具和库。在我们的案例中，我们用它向服务发送了三个 `PUT` 请求，服务随后将数据存储到
    MongoDB 中。最后两个命令调用了服务的 API 来获取所有书籍的列表，以及与特定书籍（ID 为 1）相关的数据。通过这些手动验证，我们确认了该服务可以正常工作并与数据库进行通信。请注意，我们使用了
    `jq` 来格式化 JSON 输出。
- en: Remember, this service also contains front-end Web components, but we won't
    try them out at this time. That is reserved for later, when we deploy this service
    to production together with the Web site that will import them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个服务还包含前端 Web 组件，但我们暂时不会尝试它们。这些留待稍后，当我们将此服务与将导入它们的网站一起部署到生产环境时再进行。
- en: Containers that we are running are misplaced. The VM that we're using is supposed
    to be dedicated to continuous deployment, and the containers that we built should
    run on a separate production server (or in our case a separate VM that should
    simulate such a server). Before we start deploying to production, we should go
    through *configuration management* that will allow us not only to streamline the
    deployment but also to setup the servers. We already used `Ansible` to create
    the `cd` VM, but we haven't had time to explain how it works. Even worst, we are
    yet to make a choice which tool to use.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的容器位置不对。我们使用的虚拟机本应专门用于持续部署，而我们构建的容器应该在一个独立的生产服务器上运行（或者在我们的案例中，一个独立的虚拟机模拟这样的服务器）。在开始部署到生产环境之前，我们应该进行
    *配置管理*，以便不仅能简化部署，还能配置服务器。我们已经使用 `Ansible` 创建了 `cd` 虚拟机，但还没有时间解释它是如何工作的。更糟糕的是，我们还没有决定使用哪个工具。
- en: For now, let us stop and remove the `books-ms` container and its dependencies
    thus freeing the `cd` server to do what it was intended to do in the first place;
    enable continuous deployment pipeline.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们停止并删除 `books-ms` 容器及其依赖项，从而释放 `cd` 服务器，让它能够执行最初的目的：启用持续部署管道。
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pushing Containers to the Registry
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送容器到注册中心
- en: 'Docker Registry can be used to store and retrieve containers. We already run
    it with the `cd` VM we created at the beginning of this chapter. With the `books-ms`
    built, we can push it to the registry. That will allow us to pull the container
    from any place that can access the `cd` server. Please run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Registry 可用于存储和检索容器。我们已经在本章开始时创建的 `cd` 虚拟机上运行它。构建好 `books-ms` 后，我们可以将其推送到注册中心。这将使我们能够从任何可以访问
    `cd` 服务器的地方拉取该容器。请运行以下命令：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Earlier in this chapter, we built the container using the `10.100.198.200:5000/books-ms`
    tag. That was a special format used for pushing to private registries; `:/`. After
    the container has been tagged, we pushed it to the registry running on IP `10.100.198.200`
    and port `5000\. 10.100.198.200` is the IP of our `cd` VM.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们使用 `10.100.198.200:5000/books-ms` 标签构建了容器。这是一个用于推送到私有注册中心的特殊格式；`:/`。在容器标记后，我们将其推送到运行在
    IP `10.100.198.200` 和端口 `5000` 上的注册中心。`10.100.198.200` 是我们的 `cd` 虚拟机的 IP 地址。
- en: With the container safely stored to the registry, we can run it on any server.
    Soon, once we go through configuration management, we'll have additional servers
    where we'll run containers stored in this registry.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全地存储到注册表后，我们可以在任何服务器上运行它。不久之后，一旦我们通过配置管理，我们将拥有额外的服务器，在这些服务器上运行存储在此注册表中的容器。
- en: 'Let''s finish this chapter by destroying all the VMs. The next chapter will
    create those we need. That way you can take a break before continuing our adventure
    or jump into any chapter without the fear that something will fail due to tasks
    we did before. Each chapter is fully autonomous. While you will benefit from the
    knowledge obtained from previous chapters, technically, each of them works on
    its own. Before we destroy everything we did, we''ll push the tests container
    so that we do not have to re-built it again from scratch. Registry container has
    a volume that maps our host directory to the internal path where images are stored.
    That way, all pushed images are stored on the host (directory `registry`) and
    do not depend on the VM where it''s running:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过销毁所有虚拟机来结束本章。下一章将创建我们需要的虚拟机。这样，你可以在继续我们的冒险之前休息一下，或者跳到任何章节，不用担心之前做的任务会导致失败。每个章节都是完全独立的。虽然你会受益于之前章节获得的知识，但从技术上讲，每一章都是独立运作的。在我们销毁之前所做的一切之前，我们将推送测试容器，这样我们就不必从头开始重新构建它。注册表容器具有一个映射我们主机目录到内部路径的卷，该路径用于存储镜像。这样，所有推送的镜像都存储在主机（`registry`目录）上，并不依赖于运行它的虚拟机：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Checklist
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清单
- en: 'We are still a few steps short of the basic implementation of the deployment
    pipeline. As a reminder, the steps are following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还差几个步骤就能完成部署流水线的基本实现。提醒一下，步骤如下：
- en: Checkout the code - Done
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出代码 - 完成
- en: Run pre-deployment tests - Done
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行预部署测试 - 完成
- en: Compile and/or package the code - Done
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和/或打包代码 - 完成
- en: Build the container - Done
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建容器 - 完成
- en: Push the container to the registry - Done
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器推送到注册表 - 完成
- en: Deploy the container to the production server - Pending
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器部署到生产服务器 - 待处理
- en: Integrate the container - Pending
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成容器 - 待处理
- en: Run post-deployment tests - Pending
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行后部署测试 - 待处理
- en: Push the tests container to the registry - Pending
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试容器推送到注册表 - 待处理
- en: 'It is important to notice that all the steps we run by now were performed on
    the `cd` VM. We want to reduce the impact on the production environment as much
    as possible so we''ll continue running steps (or part of them) outside the destination
    server as much as possible:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，迄今为止我们执行的所有步骤都是在`cd`虚拟机上完成的。为了尽量减少对生产环境的影响，我们将尽可能继续在目标服务器外运行步骤（或其一部分）。
- en: '![The Checklist](img/B04858_05_02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![清单](img/B04858_05_02.jpg)'
- en: Figure 5-2 – The initial stages of the deployment pipeline with Docker
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2 – 使用Docker的部署流水线初始阶段
- en: We did the first five steps, or, at least, their manual version. The rest will
    have to wait until we set up our production server. In the next chapter, we'll
    discuss the options we have to accomplish this task.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了前五个步骤，或者至少完成了它们的手动版本。其余的步骤将等到我们设置好生产服务器后再继续。在下一章中，我们将讨论完成此任务的可选方案。
