["```\n// This function is called when a request hits the\n// \"/mutate\" endpoint\nfunction acceptAdmissionWebhookRequest(req)\n{\n  // First, we need to validate the incoming req\n  // This function will check if the request is formatted properly\n  // and will add a \"valid\" attribute If so\n  // The webhook will be a POST request from Kubernetes in the\n  // \"AdmissionReviewRequest\" schema\n  req = validateRequest(req);\n  // If the request isn't valid, return an Error\n  if(!req.valid) return Error; \n  // Next, we need to decide whether to accept or deny the Admission\n  // Request. This function will add the \"accepted\" attribute\n  req = decideAcceptOrDeny(req);\n  if(!req.accepted) return Error;\n  // Now that we know we want to allow this resource, we need to\n  // decide if any \"patches\" or changes are necessary\n  patch = patchResourceFromWebhook(req);\n  // Finally, we create an AdmissionReviewResponse and pass it back\n  // to Kubernetes in the response\n  // This AdmissionReviewResponse includes the patches and\n  // whether the resource is accepted.\n  admitReviewResp = createAdmitReviewResp(req, patch);\n  return admitReviewResp;\n}\n```", "```\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-custom-webhook-server\nspec:\n  selector:\n    app: my-custom-webhook-server\n  ports:\n    - port: 443\n      targetPort: 8443\n```", "```\napiVersion: admissionregistration.k8s.io/v1beta1\nkind: MutatingWebhookConfiguration\nmetadata:\n  name: my-service-webhook\nwebhooks:\n  - name: my-custom-webhook-server.default.svc\n    rules:\n      - operations: [ \"CREATE\" ]\n        apiGroups: [\"\"]\n        apiVersions: [\"v1\"]\n        resources: [\"pods\", \"deployments\", \"configmaps\"]\n    clientConfig:\n      service:\n        name: my-custom-webhook-server\n        namespace: default\n        path: \"/mutate\"\n      caBundle: ${CA_PEM_B64}\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod-to-deny\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n```", "```\nkubectl create -f to-deny-pod.yaml\n```", "```\nError from server (InternalError): error when creating \"to-deny-pod.yaml\": Internal error occurred: admission webhook \"my-custom-webhook-server.default.svc\" denied the request: Pod name contains \"to-deny\"!\n```", "```\nkube-apiserver --enable-admission-plugins=PodSecurityPolicy,ServiceAccount…<all other desired admission controllers>\n```", "```\nkube-apiserver -h | grep enable-admission-plugins\n```", "```\nNamespaceLifecycle, LimitRanger, ServiceAccount…\n```", "```\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: privileged-psp\n  annotations:\n    seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'\nspec:\n  privileged: true\n  allowedCapabilities:\n  - '*'\n  volumes:\n  - '*'\n  hostNetwork: true\n  hostPorts:\n  - min: 2000\n    max: 65535\n  hostIPC: true\n  hostPID: true\n  allowPrivilegeEscalation: true\n  runAsUser:\n    rule: 'RunAsAny'\n  supplementalGroups:\n    rule: 'RunAsAny'\n  fsGroup:\n    rule: 'RunAsAny'\n```", "```\napiVersion: rbac.authorization.k8s.io\nkind: ClusterRole\nmetadata:\n  name: privileged-role\nrules:\n- apiGroups: ['policy']\n  resources: ['podsecuritypolicies']\n  verbs:     ['use']\n  resourceNames:\n  - privileged-psp\n```", "```\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: privileged-crb\nroleRef:\n  kind: ClusterRole\n  name: privileged-role\n  apiGroup: rbac.authorization.k8s.io\nsubjects:\n- kind: Group\n  apiGroup: rbac.authorization.k8s.io\n  name: system:authenticated\n```", "```\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: unprivileged-psp\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  volumes:\n    - 'configMap'\n    - 'emptyDir'\n    - 'projected'\n    - 'secret'\n    - 'downwardAPI'\n    - 'persistentVolumeClaim'\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: 'MustRunAsNonRoot'\n  supplementalGroups:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  fsGroup:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  readOnlyRootFilesystem: false\n```", "```\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: specific-user-psp\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 3000\n  readOnlyRootFilesystem: false\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: specific-user-pod\nspec:\n  securityContext:\n    runAsUser: 1000\n  containers:\n  - name: test\n    image: busybox\n    securityContext:\n      allowPrivilegeEscalation: false\n```", "```\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: server\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 80\n```", "```\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: full-restriction-policy\n  namespace: development\nspec:\n  policyTypes:\n  - Ingress\n  - Egress\n  podSelector: {}\n```", "```\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: override-restriction-policy\n  namespace: development\nspec:\n  podSelector:\n    matchLabels:\n      app: server\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 443\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: database\n    ports:\n    - protocol: TCP\n      port: 6379\n```", "```\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-all-egress\nspec:\n  podSelector: {}\n  egress:\n  - {}\n  ingress:\n  - {}\n  policyTypes:\n  - Egress\n  - Ingress\n```", "```\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: specific-ip-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: worker\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - ipBlock:\n        cidr: 157.10.0.0/16\n        except:\n        - 157.10.1.0/24\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 157.10.0.0/16\n        except:\n        - 157.10.1.0/24\n```", "```\n    helm repo add falcosecurity https://falcosecurity.github.io/charts\n    helm repo update\n    ```", "```\n    helm install falco falcosecurity/falco\n    ```", "```\ncustomRules:\n  my-rules.yaml: |-\n    Rule1\n    Rule2\n    etc...\n```", "```\n- rule: Launch Privileged Container\n  desc: Detect the initial process started in a privileged container. Exceptions are made for known trusted images.\n  condition: >\n    container_started and container\n    and container.privileged=true\n    and not falco_privileged_containers\n    and not user_privileged_containers\n  output: Privileged container started (user=%user.name command=%proc.cmdline %container.info image=%container.image.repository:%container.image.tag)\n  priority: INFO\n  tags: [container, cis, mitre_privilege_escalation, mitre_lateral_movement]\n```", "```\n- macro: container\n  condition: (container.id != host)\n- macro: container_started\n  condition: >\n    ((evt.type = container or\n     (evt.type=execve and evt.dir=< and proc.vpid=1)) and\n     container.image.repository != incomplete)\n- macro: user_sensitive_mount_containers\n  condition: (container.image.repository = docker.io/sysdig/agent)\n- macro: falco_privileged_containers\n  condition: (openshift_image or\n              user_trusted_containers or\n              container.image.repository in (trusted_images) or\n              container.image.repository in (falco_privileged_images) or\n              container.image.repository startswith istio/proxy_ or\n              container.image.repository startswith quay.io/sysdig)\n- macro: user_privileged_containers\n  condition: (container.image.repository endswith sysdig/agent)\n```", "```\n- list: trusted_images\n  items: []\n```", "```\n- rule: Create Disallowed Pod\n  desc: >\n    Detect an attempt to start a pod with a container image outside of a list of allowed images.\n  condition: kevt and pod and kcreate and not allowed_k8s_containers\n  output: Pod started with container not in allowed list (user=%ka.user.name pod=%ka.resp.name ns=%ka.target.namespace images=%ka.req.pod.containers.image)\n  priority: WARNING\n  source: k8s_audit\n  tags: [k8s]\n```", "```\n- rule: Create HostNetwork Pod\n  desc: Detect an attempt to start a pod using the host network.\n  condition: kevt and pod and kcreate and ka.req.pod.host_network intersects (true) and not ka.req.pod.containers.image.repository in (falco_hostnetwork_images)\n  output: Pod started using host network (user=%ka.user.name pod=%ka.resp.name ns=%ka.target.namespace images=%ka.req.pod.containers.image)\n  priority: WARNING\n  source: k8s_audit\n  tags: [k8s]\n```"]