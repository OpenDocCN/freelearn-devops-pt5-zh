- en: Debugging Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging has been an artistic component in the field of software engineering.
    All kinds of software building blocks individually, as well as collectively, need
    to go through a stream of deeper and decisive investigations by software development
    and testing professionals to ensure the security and safety of the resulting software
    applications. As Docker containers are said to be key runtime environments for
    next generation mission-critical software workloads, it is pertinent and paramount
    for containers, crafters, and composers to embark on a systematic and sagacious
    verification and validation of containers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has been dedicatedly written to enable technical guys who have
    all the accurateÂ and relevant information to meticulously debug both the applications
    running inside containers and the containers themselves. In this chapter, we will
    also look at the theoretical aspects of process isolation for processes running
    as containers. A Docker container runs at a user-level process on host machines
    and typically has the same isolation level as provided by the operating system.
    With the latest Docker releases, many debugging tools are available which can
    be efficiently used to debug your applications. We will also cover the primary
    Docker debugging tools, such as `docker exec`, `stats`, `ps`, `top`, `events`,
    and `logs`. The current version of Docker is written in Go and it takes advantage
    of several features of the Linux kernel to deliver its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of topics that will be covered in this chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Process-level isolation for Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a `Dockerfile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a containerized application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the commands in this chapter are tested on an Ubuntu environment and if
    you are running them on a local Mac environment, the results would differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the Docker Engine on your host machine, the Docker daemon
    can be started with the `-D` debug option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `-D` debug flag can be enabled to the Docker configuration file (`/etc/default/docker`)
    also in the debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After saving and closing the configuration file, restart the Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Process-level isolation for Docker containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the virtualization paradigm, the hypervisor emulates computing resources
    and provides a virtualized environment called a VM to install the operating system
    and applications on top of it. Whereas, in the case of the container paradigm,
    a single system (bare metal or VM) is effectively partitioned to run multiple
    services simultaneously without interfering with each other. These services must
    be isolated from each other in order to prevent them from stepping on each other''s
    resources or dependency conflict (also known as dependency hell). The Docker container
    technology essentially achieves process-level isolation by leveraging the Linux
    kernel constructs, such as namespaces and cgroups, particularly, the namespaces.
    The Linux kernel provides the following five powerful namespace levers for isolating
    the global system resources from each other. These are the **Interprocess Communication**
    (**IPC**) namespaces used to isolate the IPC resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**network**: This namespace is used to isolate networking resources such as
    the network devices, network stack, and port number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mount**: This namespace isolates the filesystem mount points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PID**: This namespace isolates the process identification number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**user**: This namespace is used to isolate the user ID and group ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UTS**: This namespace is used to isolate the hostname and the NIS domain
    name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These namespaces add an additional level of complexity when we have to debug
    the services running inside the containers, which you will learn more about in
    detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss how the Docker Engine provides process-level
    isolation by leveraging the Linux namespaces through a series of practical examples,
    and one of them is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by launching an Ubuntu container in an interactive mode using the `docker
    run` subcommand, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed to find the process ID of the preceding `93f5d72c2f21` container, using
    the `docker inspect` subcommand in a different Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, from the preceding output, the process ID of the container `93f5d72c2f21`
    is `2543`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having got the process ID of the container, let''s continue to see how the
    process associated with the container looks in the Docker host, using the `ps`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Amazing, isn't it? We launched a container with `/bin/bash` as its command,
    and we have the `/bin/bash` process in the Docker host as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go one step further and display the `/proc/2543/environ` file in the
    Docker host using the `cat` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, `HOSTNAME=93f5d72c2f21` stands out from the other environment
    variables because `93f5d72c2f21` is the container ID, as well as the hostname
    of the container, which we launched previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s get back to the Terminal, where we are running our interactive
    container `93f5d72c2f21`, and list all the processes running inside this container
    using the `ps` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Surprising, isn't it? Inside the container, the process ID of the `/bin/bash`
    process is `1`, whereas outside the container, in the Docker host, the process
    ID is `2543`. Besides, the **Parent Process ID** (**PPID**) is `0` (zero).
  prefs: []
  type: TYPE_NORMAL
- en: In the Linux world, every system has just one `root` process with the PID `1`
    and PPID `0`, which is the root of the complete process tree of that system. The
    Docker framework cleverly leverages the Linux PID namespace to spin a completely
    new process tree; thus, the processes running inside a container have no access
    to the parent process of the Docker host. However, the Docker host has a complete
    view of the child PID namespace spun by the Docker Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The network namespace ensures that all containers have independent network
    interfaces on the host machine. Also, each container has its own Loopback interface.
    Each container talks to the outside world using its own network interface. You
    will be surprised to know that the namespace not only has its own routing table,
    but also has its own iptables, chains, and rules. The author of this chapter is
    running three containers on his host machine. Here, it is natural to expect three
    network interfaces for each container. Let''s run the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, there are three interfaces, one for each container. Let''s get their details
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The mount namespace ensures that the mounted filesystem is accessible only
    to the processes within the same namespace. The container A cannot see the mount
    points of the container B. If you want to check your mount points, you need to
    first log in to your container using the `exec` command (described in the next
    section), and then go to `/proc/mounts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's run a container with a mount point that runs as the **Storage Area Network**
    (**SAN**) or **Network Attached Storage** (**NAS**) device and access it by logging
    in to the container. This is given to you as an exercise. I have implemented this
    in one of my projects at work.
  prefs: []
  type: TYPE_NORMAL
- en: There are other namespaces that these containers/processes can be isolated into,
    namely, user, IPC, and UTS. The user namespace allows you to have root privileges
    within the namespace without giving that particular access to processes outside
    the namespace. Isolating a process with the IPC namespace gives it its own IPC
    resources, for example, System V IPC and POSIX messages. The UTS namespace isolates
    the hostname of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker has implemented this namespace using the `clone` system call. On the
    host machine, you can inspect the namespace created by Docker for the container
    (with PID `3728`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In most industrial deployments of Docker, people are extensively using patched
    Linux kernels to provide specific needs. Also, a few companies have patched their
    kernels to attach arbitrary processes to the existing namespaces because they
    feel that this is the most convenient and reliable way to deploy, control, and
    orchestrate containers.
  prefs: []
  type: TYPE_NORMAL
- en: Control groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux containers rely on **Control groups** (**cgroups**), which not only track
    groups of processes, but also expose metrics of the CPU, memory, and block I/O
    usage. You can access these metrics and obtain network usage metrics as well.
    Cgroups are another important component of Linux containers. Cgroups have been
    around for a while and were initially merged into the Linux kernel code 2.6.24\.
    They ensure that each Docker container will get a fixed amount of memory, CPU,
    and disk I/O, so that any container will not able to bring the host machine down
    at any point of time under any circumstances. Cgroups do not play a role in preventing
    one container from being accessed, but they are essential to fend off some **Denial
    of Service** (**DoS**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: On Ubuntu 16.04, a cgroup is implemented in the `/sys/fs/cgroup` path. The memory
    information of Docker is available at the `/sys/fs/cgroup/memory/docker/` path.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the CPU details are made available in the `/sys/fs/cgroup/cpu/docker/`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out the maximum limit of memory that can be consumed by the container
    (`41668be6e513e845150abd2dd95dd574591912a7fda947f6744a0bfdb5cd9a85`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can go to the cgroup memory path and check for the `memory.max_usage_in_bytes`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command to see the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, by default, any container can use up to 13.18 MB memory only. Similarly,
    CPU parameters can be found in the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Traditionally, Docker runs only one process inside the containers. So typically,
    you have seen people running three containers each for PHP, NGINX, and MySQL.
    However, this is a myth. You can run all your three processes inside a single
    container also.
  prefs: []
  type: TYPE_NORMAL
- en: Docker isolates many aspects of the underlying host from an application running
    in a container without the root privileges. However, this separation is not as
    strong as that of virtual machines, which run independent OS instances on top
    of a hypervisor without sharing the kernel with the underlying OS. It's not a
    good idea to run applications with different security profiles as containers on
    the same host, but there are security benefits to encapsulate different applications
    into containerized applications that would otherwise run directly on the same
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a containerized application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computer programs (software) sometimes fail to behave as expected. This is due
    to faulty code or due to the environmental changes between the development, testing,
    and deployment systems. Docker container technology eliminates the environmental
    issues between development, testing, and deployment as much as possible by containerizing
    all the application dependencies. Nonetheless, there could be still anomalies
    due to faulty code or variations in the kernel behavior, which needs debugging.
    Debugging is one of the most complex processes in the software engineering world
    and it becomes much more complex in the container paradigm because of the isolation
    techniques. In this section, we are going to learn a few tips and tricks to debug
    a containerized application using the tools native to Docker, as well as the tools
    provided by external sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, many people in the Docker community individually developed their
    own debugging tools, but later Docker started supporting native tools, such as
    `exec`, `top`, `logs`, and `events`. In this section, we will dive deep into the
    following Docker tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stats`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall also consider debugging a `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: The docker exec command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker exec` command provides the much-needed help to users, who are deploying
    their own web servers or have other applications running in the background. Now,
    it is not necessary to log in to run the SSH daemon in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a Docker container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the `docker ps -a` command to get the container ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the `docker exec` command to log in to the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `docker exec` command can only access the running containers,
    so if the container stops functioning, then you need to restart the stopped container
    in order to proceed. The `docker exec` command spawns a new process in the target
    container using the Docker API and CLI. So if you run the `ps -aef` command inside
    the target container, it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `python app.y` is the application that is already running in the target
    container, and the `docker exec` command has added the `bash` process inside the
    container. If you run `kill -9 pid(45)`, you will be automatically logged out
    of the container.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an enthusiastic developer, and you want to enhance the `exec` functionality,
    you can refer to [https://github.com/chris-rock/docker-exec](https://github.com/chris-rock/docker-exec).
  prefs: []
  type: TYPE_NORMAL
- en: Using the `docker exec` command only for monitoring and diagnostic purposes
    is recommended, and I personally believe in the concept of one process per container,
    which is one of the best practices widely accentuated.
  prefs: []
  type: TYPE_NORMAL
- en: The docker ps command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker ps` command, which is available inside the container, is used to
    see the status of the process. This is similar to the standard `ps` command in
    the Linux environment and is *not* a `docker ps` command that we run on the Docker
    host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command runs inside the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Use `ps --help <simple|list|output|threads|misc|all>` or `ps --help <s|l|o|t|m|a>`
    for additional help text.
  prefs: []
  type: TYPE_NORMAL
- en: The docker top command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run the `top` command from the Docker host machine using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a list of the running processes of a container without logging in
    to the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Docker `top` command provides information about the CPU, memory, and swap
    usage if you run it inside a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you get theÂ `error - TERM environment variable not set`Â error while
    running the `top` command inside the container, perform the following steps to
    resolve it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `echo $TERM` command. You will get the result as `dumb`. Then, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will resolve the error.
  prefs: []
  type: TYPE_NORMAL
- en: The docker stats command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `docker stats` command provides you with the capability to view the memory,
    CPU, and the network usage of a container from a Docker host machine, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the `stats` command to also view the usage for multiple containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Docker provides access to container statistics *read only* parameters. This
    streamlines the CPU, memory, network IO, and block IO of containers. This helps
    you choose the resource limits and also in profiling. The Docker `stats` utility
    provides you with these resource usage details only for running containers.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker events command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker containers will report the following real-time events: `create`, `destroy`,
    `die`, `export`, `kill`, `omm`, `pause`, `restart`, `start`, `stop`, and `unpause`.
    The following are a few examples that illustrate how to use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Docker image will also report the untag and delete events.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of multiple filters will be handled as an AND operation; for example,
  prefs: []
  type: TYPE_NORMAL
- en: '`--filter container= a245253db38b --filter event=start` will display events
    for the container `a245253db38b` and the event type is `start`.'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the supported filters are container, event, and image.
  prefs: []
  type: TYPE_NORMAL
- en: The docker logs command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command fetches the log of a container without logging in to the container.
    It batch-retrieves logs present at the time of execution. These logs are the output
    of stdout and stderr. The general usage is shown in `docker logs [OPTIONS] CONTAINER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-follow` option will continue to provide the output till the end,Â `-t`Â will
    provide the timestamp, and `--tail= <number of lines>`Â will show the number of
    lines of the log messages of your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We also used the `docker logs` utility in [Chapter 2](../Text/Ch02.xhtml), *Handling
    Docker Containers* and [Chapter 6](../Text/Ch06.xhtml), *Running Services in a
    Container*, to view the logs of our containers.
  prefs: []
  type: TYPE_NORMAL
- en: The docker attach command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `docker attach` command attaches the running container and it is very helpful
    when you want to see what is written in stdout in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By default, this command attaches stdin and proxies signals to the remote process.
    Options are available to control both of these behaviors. To detach from the process,Â use
    the default *Ctrl* + *C* sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes creating a `Dockerfile` may not start with everything working. A `Dockerfile`Â does
    not always build images and sometimes it does, but starting a container would
    crash on startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every instruction we set in the `Dockerfile` is going to be built as a separate,
    temporary image for the other instruction to build itself on top of the previous
    instruction. The followingÂ example explains this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Dockerfile` using your favorite editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build the image by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `---> Running in 7b47d3c46cfa` line. `7b47d3c46cfa` is a valid image
    and can be used to retry the failed instruction and see what's happening
  prefs: []
  type: TYPE_NORMAL
- en: To debug this image, we need to create a container and then log in to analyze
    the error. Debugging is a process of analyzing what's going on and it's different
    for every situation, but usually, the way we start debugging is by trying to manually
    make the instruction that fails work manually and understand the error. When I
    get the instruction to work, I usually exit the container, update my `Dockerfile`,
    and repeat the process until I have something working.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you have seen the isolation of containers using the Linux container
    technology, such as LXC and now Libcontainer. Libcontainer is Docker's own implementation
    in the Go programming language to access the kernel namespace and cgroups. This
    namespace is used for process-level isolation, while cgroups are used for restricting
    the resource usage of running containers. Since the containers run as independent
    processes directly over the Linux kernel, the **Generally Available** (**GA**)
    debugging tools are not fit enough to work inside the containers to debug the
    containerized processes. Docker now provides you with a rich set of tools to effectively
    debug the container as well as processes inside the container itself. The `docker
    exec`Â command will allow you to log in to the container without running an SSH
    daemon in the container. You have seen the details of each debugging tool in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker stats`Â command provides information about the container's memory
    and CPU usage. The `docker events` command reports the events, such as create,
    destroy, and kill. Similarly, the `docker logs` command fetches the logs from
    the container without logging in to the container.
  prefs: []
  type: TYPE_NORMAL
- en: As a next step, you can try the latest Microsoft Visual Studio Tools for Docker.
    It provides a consistent way to develop and validate your application in the Linux
    Docker container. For details, you can refer toÂ [https://docs.microsoft.com/en-us/azure/vs-azure-tools-docker-edit-and-refresh](https://docs.microsoft.com/en-us/azure/vs-azure-tools-docker-edit-and-refresh).
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you would like to debug the Node.js application live running in IDE
    (Visual Studio Code), try this blog:Â [https://blog.docker.com/2016/07/live-debugging-docker/](https://blog.docker.com/2016/07/live-debugging-docker/).
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter expounds the plausible security threats of Docker containers
    and how they can be subdued with a variety of security approaches, automated tools,
    best practices, key guidelines, and metrics. We will discuss the security of containers
    versus virtual machines with Docker's adaptability of third-party security tools
    and practices.
  prefs: []
  type: TYPE_NORMAL
