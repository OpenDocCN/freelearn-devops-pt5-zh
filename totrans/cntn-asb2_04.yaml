- en: What&#x27;s in a Role?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](4b15cefb-8d9c-48b7-8927-126501886315.xhtml), *Your First Ansible
    Container Project*, we learned the basics about Ansible Container roles, what
    they do, and how to download, install, and tweak them from Ansible Galaxy. In
    this chapter, we will look at writing our own Ansible Container roles that we
    can use to build custom container images from scratch. You will learn that Ansible
    provides an easy-to-learn, expressive language for defining desired states, and
    service configurations. To illustrate how Ansible Container can be used to quickly
    build services and run containers, over the course of this chapter we will write
    a role that builds a MariaDB MySQL container that can be run on your local workstation.
    In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom roles with Ansible Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of MariaDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing an Ansible Container role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's in a container-enabled role?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MariaDB project and role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a container-enabled role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing a container-enabled role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom roles with Ansible Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One growing theme throughout the course of this book is how much freedom Ansible
    Container gives you to build and deploy custom container images quickly, efficiently,
    securely, and reliably. So far, we have looked at using Ansible Container to define
    and run services from prebuilt community containers, as well as leveraging community-written
    roles to instantiate, build, and customize our containers. This is an excellent
    way to get started with Ansible Container and get a head start in familiarizing
    yourself with the Ansible Container workflow. However, the real power of Ansible
    Container begins to really show itself when you start writing roles that build
    custom container images.
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience using Ansible as a configuration management tool, you
    might be familiar with writing Ansible playbooks and roles already. This will
    definitely give you a head start with writing containerized roles, but it is not
    a prerequisite for working through the examples in this chapter. To put everyone
    on a level playing field, I am going to assume that you have no experience writing
    Ansible playbooks or roles, and we will essentially start from scratch. For those
    of you who are Ansible veterans, a lot of this will be a review, but hopefully
    you may learn something new. For Ansible beginners, I hope this chapter will excite
    your curiosity, not only to go forward into building more advanced Ansible Container
    roles but also to go further and explore Ansible Core configuration management
    concepts as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original motivation behind Ansible was to create a configuration management
    and orchestration system that is easy for just about anyone to pick up and start
    working with. Ansible quickly became immensely popular amongst software developers,
    system administrators, and DevOps engineers as a tool that is not only easy to
    adopt, but also easy to customize, and even incorporate into existing platforms
    and configuration management tools. I first started using Ansible because, at
    the time, I was working on projects that required me to log into numerous bare-metal
    servers and virtual machines to perform the same set of commands over and over
    again. At that time, I was trying to hack my way into making this easier by writing
    flaky shell scripts that would use SSH to push remote commands to the servers.
    Over the course of my research into how to make these scripts more resilient,
    I discovered Ansible, which I immediately adopted and it made my work far easier
    and more reliable then I had imagined. I believe there are two primary reasons
    that Ansible is so popular in the IT industry:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to understand YAML syntax for playbooks and roles. YAML is easy to learn
    and write, which makes it perfect for Ansible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hundreds, if not thousands, of built-in modules that come with Ansible Core.
    These modules allow us to do almost anything you can imagine, right out of the
    box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these two unique aspects of Ansible and understand how we can
    leverage this ease of use in our own projects.
  prefs: []
  type: TYPE_NORMAL
- en: YAML syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'YAML is a data serialization format that recursively stands for, *YAML Ain''t
    Markup Language*. You may have worked with other serialization formats in the
    past, such as XML or JSON. What makes YAML unique is that it is easy to write,
    and quite possibly the most human-readable data format currently used. Ansible
    chose to use YAML as the basis for defining its playbook syntax and language due
    to the fact that, even if you do not come from a programming background, YAML
    is super-easy to get started with writing, using, and understanding. YAML is unique
    in the way that it uses a series of colons (`:`), dashes (`-`), and indentations
    (spaces, not tabs) to define key-value pairs. These key-value pairs can be used
    to define almost every type of computer science data types, such as integers,
    Booleans, strings, arrays, and hash tables. Following is an example of a YAML
    document, illustrating some of these constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example demonstrates a simple YAML file consisting of the most
    basic constructs: a string variable, an array (list of items), a Boolean (true/false)
    variable, an integer variable, and a hash table holding a series of key-value
    pairs. This may look quite similar to work we have done previously in this book
    when modifying the `container.yml` files, as well as the Docker Compose files.
    These formats are also defined in YAML and consist of many of the same constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things that I would like to call your attention to in the preceding example
    (you should also keep in them mind when you begin writing Ansible playbooks and
    roles) are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All YAML documents begin with three dashes: `---`. This is important because
    you may have multiple YAML documents defined in the same single file. Documents
    would then be separated using the three dashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comments are defined using the hash sign: `#`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are surrounded by quotation marks. This separates strings from literals,
    such as Booleans (true or false words without quotation marks), or integers (numbers
    without quotation marks). If you surrounded the words *true*/*false*, or a numerical
    value with quotation marks, they will be interpreted as strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colons (`:`) are used to separate key-value pairs, which define almost everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indentation is indicated by two spaces. Tabs are not recognized in the YAML
    format. When getting started with writing YAML documents, make sure your text
    editor is configured to place two spaces into your document when you hit the *Tab*
    key. This makes it easy to quickly and naturally indent text as you type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I realize that there is much more to YAML syntax than what I have provided
    in this example. My goal here is to dig a little deeper than in the earlier chapters
    to help give the reader a deeper understanding of the YAML format going forward.
    This is by no means a full description of the entire YAML format. If you want
    to read more about YAML, I would recommend you check out the official YAML specification
    website: [http://yaml.org](http://yaml.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second part of what makes Ansible so popular and easy to use is the plethora
    of modules that Ansible can leverage right out of the box, which can do almost
    anything the user can think of. Think of modules as the building blocks of Ansible,
    that define what your playbook does. There are Ansible modules that can edit the
    content of files on remote systems, add or delete users, install service packages,
    and even interact with APIs for remote applications. Modules themselves are written
    in Python and get called in a scripted format from YAML playbooks. The playbooks
    themselves are simply just a series of calls to Ansible modules that perform a
    specific series of tasks. Let''s look at a very simple playbook to understand
    how this works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple playbook consists of two separate tasks: creating a user account
    and installing the Vim text editor. Each task in Ansible calls for exactly one
    module to perform an action. Tasks in Ansible are defined using YAML dashes, followed
    by the name of the task, the name of the module, and all of the parameters you
    want to feed into that module indented as mentioned in the following. In our first
    task, we are creating a user account by calling the `user` module. We are giving
    the user module two parameters: `name` and `state`. The `name` represents the
    name of the user we want to create, and the `state` represents how we want the
    desired state on our remote system or container to look. In this case, we want
    a user to exist called `MyUser` and the state we want that user to be in is `present`.
    If this Ansible playbook gets executed and the user called `MyUser` already exists,
    Ansible will take no action since the system is in the desired state.'
  prefs: []
  type: TYPE_NORMAL
- en: The second task in this playbook installs the text editor Vim on our remote
    system or container. To accomplish this, we are going to use the `apt` module
    to install a Debian APT package. If this was a Red Hat or CentOS system, we would
    similarly use the `yum` or `dnf` module. The name represents the name of the package
    we want to install, and the state represents the desired state of the server or
    container. Thus, we would like the Vim Debian package to be installed. As we mentioned
    earlier, there are hundreds, if not thousands, of Ansible modules that can be
    leveraged in playbooks and roles. You can find the full list of Ansible modules
    by category as well as excellent examples of parameters that the modules take,
    in the Ansible documentation at [http://docs.ansible.com/ansible/latest/modules_by_category.html](http://docs.ansible.com/ansible/latest/modules_by_category.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `state` parameter also takes the value `absent` to remove a user, package,
    or almost anything else that could be defined.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major benefits of Ansible Container is that, in writing container
    configuration using Ansible roles, you have the entire universe of Ansible modules
    available to you to choose from. Unfortunately, not all Ansible modules work in
    the context of a container. A traditional example of this is modules that manage
    the state of running services, such as the `service` module. The `service` module
    does not run in containers, since application containers typically lack traditional
    init systems that you would find in a full operating system to start, stop, and
    restart running services. In a containerized context, this is handled by starting
    your container with a `CMD` or `entrypoint` statement that directly executes a
    service binary.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, almost any module that manages the orchestration of cloud services
    or call external APIs will not run in a containerized context. This is pretty
    straightforward since you would usually not want to orchestrate the state of external
    services when you are building an independent containerized microservice. Of course,
    if you are writing an Ansible playbook that deploys a containerized application
    you previously built using Ansible Container, you can use these orchestration
    modules to react in certain ways when the container comes online. However, for
    the purposes of this chapter, we will limit our discussion only to writing roles
    that build containerized services.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of MariaDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be writing an Ansible Role that builds a MariaDB
    database container. MariaDB is a fork of the MySQL relational database server,
    which provides numerous customizations and optimizations that are not found in
    vanilla MySQL. Out of the box, MariaDB supports numerous optimizations, such as
    replication, query optimization, encryption, performance, and speed improvements
    over standard MySQL, yet remains fully MySQL-compatible, leveraging a free and
    open source GPL license. MariaDB was chosen for this example due to its relative
    simplicity to deploy and the free nature of the application itself. In this chapter,
    we will build a relatively basic single-node MariaDB installation that does not
    contain a lot of features and performance tweaks that you would find in a production-ready
    installation. The purpose of this chapter is not how to build a production-ready
    MariaDB container, but rather to illustrate the concepts of building a containerized
    service using Ansible Container. If you want to go further with this example,
    feel free to tweak this code in any way you see fit. Extra credit to those of
    you who build production-ready containers!
  prefs: []
  type: TYPE_NORMAL
- en: Initializing an Ansible Container role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, Ansible roles are a self-contained, reusable set of
    playbooks, templates, variables, and other metadata that defines an application
    or service. Since Ansible roles are designed to work with Ansible Galaxy, Ansible
    Galaxy command-line tools have built-in functionality to initialize roles that
    contain all of the proper directories, default files, and scaffolding designed
    to create a functioning Ansible role with minimal hassle. This works very similarly
    to the `ansible container init` command for creating Ansible Container projects.
  prefs: []
  type: TYPE_NORMAL
- en: What's in a container-enabled role?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new container-enabled role in Ansible Container, we are going to
    use the `ansible-galaxy init` command with the `container-enabled` flag to create
    the new role directory structure for us. To examine what happens when we use this
    command, let''s initialize a role in the `/tmp` directory on our Vagrant VM and
    see what Ansible creates for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful execution of the `init` command, Ansible should return a message
    indicating that your new role was `created successfully`. If you run the `ls`
    command, you will find a new directory named after the role we just initialized.
    Everything that comprises of the role resides in this directory, according to
    the default directory structure. When you call a role from Ansible, Ansible will
    look in all of the locations you indicated your roles should live in and will
    look for a directory with the same name as your role. We will see this in more
    detail later in this chapter. If you navigate inside this directory, you will
    find a folder structure similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at what each of these directories and files does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaults/`: `defaults` is a directory that contains variables specific to
    your role and has the lowest priority for overriding the values. Any variables
    that you want to place in your role that you definitely want or require the user
    to override should go in the `main.yml` file of this directory. This is not to
    be confused with the `vars/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handlers/`: `handlers` are a concept in Ansible that defines tasks that should
    be executed in response to notify events sent from other tasks during a role execution.
    For example, you may have a task that updates a configuration file in your role.
    If your service needs to be restarted in response to that configuration file update,
    you could specify a `notify:` the step in your task, as well as the name of your
    handler. If the parent task executes and resolves a `CHANGED` status, Ansible
    will look inside of the `handlers/` directory for the task specified by the notify
    statement and then execute that task. Please note that handlers do not execute
    unless another playbook task specifically calls that task using the `notify:`
    statement and results in a changed status. Handlers are not quite as common in
    container-enabled roles since containers usually aren''t dependent on external
    events and circumstances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta`: `Meta` is a directory which contains the metadata for Ansible roles.
    In a container-enabled role, it contains two primary files: `main.yml` which contains
    general metadata about the role, such as dependencies, Ansible Galaxy data, and
    conditions upon which the role is contingent. For the purposes of this example,
    we will not do very much with this file. The second file, `container.yml`, is
    more important to us. This `container.yml` is specific to container-enabled roles
    and is critical for specifying the default values that will be injected into the
    project-level `container.yml` file when we call our role. Here, we can specify
    the container image, volume information, as well as the default command and `entrypoint`
    data that we want our container to run with by default. All of this data can be
    overridden in our parent `container.yml` file if we so choose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tasks`: The `tasks` directory is where we specify the tasks that actually
    get executed inside our container and build the service. By default, Ansible will
    execute the `main.yml` file and execute all tasks in the order as specified. Any
    other task files can go into this directory as well and can be executed using
    the `include:` statement from our `main.yml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: The templates directory stores the configuration file templates
    we want to use in our role. Since Ansible is Python-based, it uses the Jinja2
    templating engine to place configuration templates into the container and update
    values based on variables identified in the `defaults/` and `vars/` directories.
    All files in this directory should have the `.j2` file extension, although this
    is not required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: Any automated testing that you would like a CICD tool to perform would
    go here. Usually, developers would put any custom Ansible configurations, parameters,
    or inventories that the CI/CD tool will requires as input in the directories and
    files that are autogenerated in this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars`: The `vars/` directory is the location in which a developer can specify
    other variables available to the role here. It is important to note that the `vars/`
    directory has a lower precedence than the `defaults/` directory, so variables
    defined here are more difficult to override than the ones specified in `defaults`.
    Usually, when I write a role, I will make all of my variables available in the
    `defaults` directory, as I want the user to have full power to override anything
    they desire. There might be circumstances in which you may not want your variables
    as easy to access, in which case they could be specified in the `vars/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any file in your role named, `main.yml` indicates that the file is a default
    and will be executed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what makes up a container-enabled role, we can take this knowledge
    and create a new Ansible Container project that will build our MariaDB MySQL role.
    To accomplish this, we are going to initialize a new project and create a subdirectory
    called `roles/`, which will contain the role we will create. When we build our
    project, Ansible will know to look inside of our `roles/` directory and find all
    of the roles we have specified and created there. Please note that the following
    sections of this chapter will get quite code-heavy. To make the process of following
    along easier, the completed example can be found in the official book GitHub repository
    under the `AnsibleContainer/mariadb_demo` directory. However, the best way to
    learn how to write Ansible code is by repetition and practice, which can only
    be attained by writing the code yourself. It is strongly suggested that, while
    it may not be practical to copy the code written in this chapter verbatim, one
    should obtain practice writing Ansible code by using these examples to create
    your own project or modifying the example in the Git repository. The more code
    you write, the better and more fluent of an Ansible developer you will become.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the MariaDB project and role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a feel for how a container-enabled role is structured, we
    can start our MariaDB container by initializing a new Ansible Container project.
    In a new directory on your Vagrant host, start a new project as usual by using
    the `ansible-container init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of our `project` directory, we can create a directory that will store
    our roles. In the Ansible Core, the default location for a role is in the `/etc/ansible/roles`
    or a `roles/` directory relative to the playbook you are executing. It should
    be noted, however, that roles can be stored in any location provided the Ansible
    installation has read access to the path. For the purposes of this demonstration,
    we are going to create our roles path as a `child` directory of our project. Within
    our `project` directory, create a new directory called `roles` and initialize
    our Ansible Container role inside of that directory. We will call our role `mariadb_role`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that our role has been created inside of our project, we need to modify
    our project `container.yml` file so that it knows the path we are sourcing our
    roles from, as well as to create a service that we will build using our role.
    The roles location can be specified using the `roles_path` option as a child parameter
    of `settings:` in the `container.yml` file. Here, we can specify the paths we
    want Ansible to search for roles as list items of `roles_path` using the hyphen
    notation (`-`). We will specify the `roles` directory we just created. Under the
    `services:` subsection, we can create a new service called `MySQL_database_container`.
    This will leverage the role `mariadb_role` that we just created. We also want
    to make sure that we specify the base image we want to use for our service.  For
    this example, the MariaDB container will be based on Ubuntu 16.04, so we want
    to make sure our `conductor_base` image is the same to ensure compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: container.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is a sample of the `container.yml` file that provides these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we could build our project, but it would result in an empty container
    since our role contains no tasks from which we can build a container image. Let's
    make things interesting by adding tasks as well as updating the role-specific
    `container.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to use the same conductor base image that your service containers
    will use. This will ensure maximum compatibility when building your project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a container-enabled role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed previously, it is quite difficult to walk the reader through
    writing code from scratch, due to the fact that file paths can get complicated
    rather quickly, making it easy to lose your place. In this section, I will show
    what the modified files look like and draw the reader''s attention to the parts
    of the files that require explanation. Since it is quite easy to get lost, I will
    direct the reader to follow along in the official book GitHub repository located
    at the following URL: [https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo](https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo).'
  prefs: []
  type: TYPE_NORMAL
- en: As developers of a container-enabled role, the most important parts of writing
    a role is the role-specific `container.yml` file, which specifies the default
    values the container will run with, as well as the tasks that are used to build
    the container and put all of the pieces in place. The tasks you build the container
    with will often determine the parameters in the role-specific `container.yml`
    file. When writing a role, developers will often tweak and modify the `container.yml`
    file as they are writing the playbook tasks. When you call a role from the project-specific
    `container.yml` file, the contents of the role-specific `container.yml` file will
    be used to build your container. At any point, a developer can override the role-specific
    `container.yml` file by simply modifying the parameters in the project `container.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important as a role developer to write sane defaults for your role''s
    `container.yml` to enable other users to leverage your role quickly. For our MariaDB
    demonstration, we will create a simple role-specific `container.yml` file that
    resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: roles/mariadb_role/meta/container.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file is located in the `meta` directory of the MariaDB role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The parameters we are defining in the role-specific `container.yml` should immediately
    jump out at you in the exact same way in which we would define them in the project-specific
    `container.yml` services section. Here, we are using the Ubuntu 16.04 base image,
    which is the same as our conductor container. In order to make our MySQL service
    accessible to outside users, we are going to expose the MySQL ports `3306` on
    the host to ports `3306` on the container. Finally, we are going to specify a
    default entry point and command that the container should run when it starts.
    A common practice among container developers recently is to leverage lightweight
    init systems to start and manage processes inside of containers. A popular init
    system for containers is `dumb-init`, written by Yelp in 2013 to provide an easy
    to install, lightweight init binary for managing processes inside of containers.
    `dumb-init` essentially starts as PID 1 inside of the container and takes the
    container service executable as an argument provided to it. The benefit is that,
    since `dumb-init` is running as PID 1, all kernel signals will first be intercepted
    by `dumb-init` and forwarded to the container service (`mysqld`). `dumb-init`
    will also provide reaping services for our child process, should our container
    be suddenly stopped or restarted ungracefully. Keep in mind, using a container
    `init` system is not a requirement when building containers, but in some cases,
    it will help with running, stopping, and restarting containers if the processes
    don't exit cleanly. In this example, we will use `dumb-init` as our `entrypoint`
    for the container, and use the `command:` parameter to specify the `/usr/sbin/MySQLd`
    command as an argument into it. This will start the `mysqld` process under the
    supervision of `dumb-init`, which will intercept all of the POSIX signals and
    forward them over to `mysqld`.
  prefs: []
  type: TYPE_NORMAL
- en: The second most important aspect of a containerized role is actually writing
    tasks that are executed in our base image to create the project container. All
    tasks are YAML files in the `tasks` directory of the role. Each task has a name
    and calls a single Ansible module with parameters to perform a unit of work in
    the container. Although there are no strict requirements on how to name tasks,
    or which order to place them in, you do want to keep in mind the flow of the playbook
    in terms of dependencies on other tasks that may come before or after certain
    steps. You also want to make sure you name tasks in such a way that any user watching
    the build process has a fairly good idea what is going on, even if they are not
    an Ansible developer. Named tasks are what give Ansible the reputation of being
    *self-documenting*. This means that, as you write code, the code basically documents
    itself since almost any user reading your code should know immediately what it
    does based on the naming of the tasks. It should also be noted that, as all services
    and applications are different, they are all deployed and configured differently
    as well. With Ansible and containerization, there is no *one-size-fits-all* approach
    that can adequately capture the best practices for deploying and configuring your
    application.  One of the benefits of Ansible is that Ansible provides the tools
    needed to automate almost any configuration one can think of to ensure applications
    get built and deployed reliably. The following is the content of the `tasks/main.yml`
    file in the MariaDB role we are in the process of writing. Take a moment and read
    through the playbook as it is; we will go through each of these tasks one-by-one
    to provide more detail as to how the playbook runs. As I describe how the playbook
    works, it would be helpful to glance back at each task as you read the description.
  prefs: []
  type: TYPE_NORMAL
- en: tasks/main.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file is located in `roles/mariadb_role/tasks/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Task breakdown (main.yml)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Install Base Packages`: Since we are building an Ubuntu 16.04 image, the `Install
    Base Packages` task calls the `apt` package module to install two packages: `ca-certificates` and
    `apt-utils`, which are required for the preceding tasks. We want the state of
    these packages to be present and installed in the `container` and the `apt` database
    cache to be updated prior to installing the packages as well. We are able to install
    multiple packages using the `with_items` operator. `with_items` iterates over
    the list items specified and run each value through the apt module. Using `with_items`,
    we don''t have to create two or more separate tasks to perform the same action
    repeatedly. In the `name` section of the task, we specify `{{ item }}`, which
    is a Jinja2 keyword variable that tells Ansible that it is about to iterate over
    a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Install dumb-init for the Container Init System`: This task leverages the
    `get_url` module in order to download a remote file from the internet into the
    container. In this particular case, we are downloading the `dumb-init` binary
    and placing it in the container at the destination `/usr/bin/dumb-init`. We are
    changing the permissions so the file will be owned by root, in the root group,
    and will be executable. Ansible allows us to perform all of these actions in a
    single module call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create MySQL User and Group`: The next two tasks are quite similar. With these
    tasks, we are starting to lay the groundwork for installing our MariaDB MySQL
    service. We are calling the `user` and `group` module to create a user called
    `mysql`, create a group also called `mysql`, and add the user to the group. Notice
    that, in the group module, we specify `append: true`. This indicates that whatever
    groups are already assigned to the `mysql` user, we also want to append `mysql`.
    This is a safe option to add to any group declaration so that we don''t accidentally
    remove users from other groups they may need to belong to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Install the MySQL Server`: This task functions in a very similar way to the
    first task that we saw in the playbook. However, instead of installing multiple
    packages, we are calling the apt module to install only one package, the MariaDB
    server. As usual, we want the package to be installed and present, as well as
    having the package cache updated. Arguably, we could have added this package to
    the list of installed packages in our very first task, and that would definitely
    work. However, as a matter of development style, I like to provide a logical distinction
    between steps in my playbooks so that things do not get confusing further on.
    After all, installing the base packages is usually a separate and distinct step
    from installing the core service package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Change permissions on directories`: This task is one of the more complex tasks
    in the playbook. In this task, we have a handful of directory paths that need
    to have their permissions changed so that the MySQL service can write data to
    them. The `file` module allows us to create, delete, or modify any file present
    in our container. Similarly to our first task, we are going to call the file module
    on our `{{ item }}` keyword variable so that each list item specified in our `with_items`
    will have the same permissions and attributes applied to it. If the paths specified
    do not exist, Ansible will create them with the state `directory` and apply the
    appropriate permissions to them. We are also providing the `recurse: true` option
    so that the permissions will apply to all subdirectories from those locations
    specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove my.cnf`: `my.cnf` is the primary configuration file that is used by
    MySQL to configure how the database service operates. When MariaDB is first installed,
    it creates `my.cnf` as a symlink, which leads to another configuration file it
    uses instead. We don''t want this behavior; hence, we are going to delete the
    default `my.cnf` file using the file module and set the state value to `absent`.
    We will use our own `my.cnf` file instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Install the MySQL Configuration File`: Now that the default `my.cnf` symlink
    has been removed, we can call the template module to place a new `my.cnf` file
    in its place. The `templates` module works by leveraging the local `templates`
    directory and looking for a file that matches the name of the source file we are
    specifying, `my.cnf.j2`. Templates use the Jinja2 templating language to put the
    new configuration in place and replace any variables sourced from the role. The
    location for the new configuration file will be `/etc/MySQL/my.cnf` and will have
    the appropriate permissions applied to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Initialize the Database`: The final task in this playbook is known as an `include`
    task. Include statements, logically enough, include other playbook YAML files
    for execution. Usually, include statements are a great way to break down your
    playbooks into logically grouped blocks of similar tasks. In this scenario, we
    want to include the playbook `initialize_database.yml`, based on the logical condition
    that the variable `initialize_database` is set to true. In other programming languages
    constructs such as *if, else...if*, and *else* exist, to indicate logical evaluations.
    Ansible handles this using the keyword `when` to list the conditions for *when*
    an action will occur. In this case, *when* the variable `initialize_database`
    is true, the playbook `initialize_database.yml` will be executed. If the variable
    is set to false, it will skip those tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a good understanding of what the tasks inside of the `main.yml`
    playbook are running, let''s take a look at the tasks inside of the `initialize_database.yml`
    playbook to see what will happen if the `initialize_database` variable evaluates
    to true:'
  prefs: []
  type: TYPE_NORMAL
- en: tasks/initialize_database.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file is located in `roles/mariadb_role/tasks/initialize_database.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Task breakdown (initialize_database.yml)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Temporarily Start MariaDB Server`: By default, when MariaDB is first installed,
    there are no databases created and no users have access to the database. In some
    cases, we may want to spin up a vanilla MariaDB server and have an external user
    or tool create the default databases and access credentials. However, there may
    also be an equal number of circumstances in which we might need to create database
    instances that come with built-in databases and user credentials. In order to
    create these defaults, we will first need to start the MySQL server so that it
    can be accessed from the command line. To start the server temporarily, we will
    call the `shell` module, which evaluates shell commands in a very similar manner,
    as if you were typing them on a Bash prompt. We will run the command `mysqld`,
    specifying the user to run as `mysql`, and force the server to run in the background
    using the ampersand indicator (`&`). The MySQL server will continue to run at
    this point until the build has completed and the container has been shut down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create Initial Accounts`: The create initial accounts step similarly calls
    the shell module in order to leverage the MySQL command-line client. The `-e`
    flag allows us to pass in executable SQL commands, which will be evaluated by
    the server. We will use this particular command to create a default username and
    password that we can use to log in to the database. The default credentials will
    be sourced from our variables, hence the double curly braces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grant Privileges to New Account`: Using the `shell` module again, we can call
    the MySQL client to grant privileges on the new account we created previously.
    In this example, we will grant all privileges, connecting from any network interface
    to have access to this MySQL server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create Default Databases`: Using our iteration or looping operator `with_items`,
    we can pass in a list of databases we want the MySQL client to create. In our
    `defaults/main.yml` file, we have specified the databases variable as an array
    or list of items. Ansible will identify the fact that our databases variable is
    actually a list of strings and iterate over that. The result is that any number
    of databases we specify as a list item of the databases variable will be iterated
    over and created in our MySQL container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flush Privileges`: One final call to the shell module will allow us to execute
    the SQL command, `FLUSH PRIVILEGES`, which allows the new user accounts to take
    effect in the database. After this command executes, the container build will
    have finished, signaling Ansible Container to shut down the intermediate container
    and commit the final changes to the container we just finished building.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have had a look inside the `tasks` directory and learned about
    how the role executes tasks, let''s look inside of the `templates/` directory
    to learn about the templated configuration files we are generating and passing
    into the container. You will observe that, in the `roles` templates directory,
    there is one file: `my.cnf.j2`. This is the template for `my.cnf` file that we
    want Ansible to compile and pass into the container during the build process.
    It is a best practice to always name your Ansible template file after the destination
    filename with the `.j2` extension. This indicates the file is a Jinja2 template
    and contains variables and Jinja2 logic for Ansible to evaluate.'
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 is a powerful templating language that can do some pretty neat stuff
    in your projects. Although not strictly required, having a working understanding
    of Jinja2 can help you a lot in your Ansible development. You can read more about
    the Jinja2 language at the official website:  [http://jinja.pocoo.org/.](http://jinja.pocoo.org/)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of the `my.cnf.j2` file in the `templates` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: templates/my.cnf.j2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file is located in `roles/mariadb_role/templates/my.cnf.j2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in the first line of the file, we are spelling out to the user
    in a comment block that the file is an *Ansible Container-Generated MariaDB Config
    File*. If you have experience of connecting into remote servers to troubleshoot
    problems, you will know how handy it is to know exactly where the files come from,
    where the values are populated from, and which configuration management tool is
    responsible for putting those files there. While not strictly required, and surely
    as a matter of taste, I like to place such banners on files that Ansible touches.
    This way, someone, later on, will know exactly how this container came to be in
    this state.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you will notice is that the last four lines of the configuration
    file have values set to double curly braces with the name of the configuration
    file key in between them. As we discussed earlier, the double curly braces indicate
    Jinja2 variable parameters. When Ansible evaluates this template prior to installing
    it in its destination inside the container, Ansible will parse the file for all
    Jinja2 blocks and execute the instructions it reads to bring the template into
    the desired state. This could mean populating the values of variables, evaluating
    logical conditions, or even sourcing environment information that the template
    requires. In this case, Ansible will see the double curly braces and replace them
    with the values defined for those variables. By changing or overriding the variables,
    Ansible makes it quite easy to change the way containers and applications function.
    Also, notice that the names of the variables match the configuration option they
    are modifying. Variable names are purely up to the developer, and as such, the
    developer may choose what they want the names to be. However, it is usually a
    best practice to use descriptive variable names so that it is very clear to the
    user what settings they are overriding or modifying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading through these role files, it is probably very clear to you that variables
    have a lot to do with how Ansible runs, how templates are populated, and even
    how tasks are executed and controlled. Let''s now take a look at how variables
    are defined in roles and how we can leverage variables to make roles more flexible
    and enable their reuse. As stated before, role variables can be stored in two
    places: the `defaults/` directory or the `vars/` directory. As the developer,
    you can choose which location (or both locations) you want to store your variables
    in. The only difference is the variable precedence in which the variables are
    evaluated in. The variables stored in `defaults/` are the easiest to override.
    Variables stored in `vars/` have a slightly lower precedence and thus are more
    difficult to override. In this example, I have opted to store all variables in
    the `defaults/` directory in the `main.yml` file. Let''s see what that file looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that these are all the variables we have seen before, referenced
    in the role tasks as well as the templated file for `my.cnf`. Variable YAML files
    are essentially just static YAML files that use exactly the same YAML constructs
    we explored in the beginning of the chapter. For example, this file is, by default,
    initializing the database by setting the `initialize_database` variable to the
    Boolean value of true. We also can see that the default credentials that will
    be created in the database are set to the strings `root` and `password`, as well
    as a list of test databases that will get created during the initialize database
    tasks. Finally, towards the bottom, we have a grouping of variables that define
    the values that will be incorporated into the template. If we build the role as-is,
    without providing any variable overrides, we will get a container built with exactly
    these specifications. However, this book would not be complete without exploring
    exactly how we can go about customizing the role we just wrote!
  prefs: []
  type: TYPE_NORMAL
- en: Building the container-enabled role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin customizing our role, let''s first build the role and demonstrate
    the default functionality using the default variables we specified. Let''s go
    ahead and return to our Ansible Container workflow and execute `ansible-container
    build`, followed by the `ansible-container run` commands from the `root` directory
    of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may note from the build output that Ansible is taking the list items we
    provided in the task using the `with_items` iteration operator and exactly building
    our image, bringing it into the desired state based on the variables we have provided
    in our role, which for now, are the default variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our project and attempt to access the MySQL services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `docker ps -a` will show that our container is running with port
    `3306` exposed on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To test to ensure everything is working, we can download and install the `mariadb-client`
    package, or any MySQL client of your choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the MariaDB client has been installed, you can use the following command
    to connect to the MariaDB container exposed on the localhost of the Vagrant VM.
    If you''re unfamiliar with the MySQL client, remember that all flags passed into
    the client do not have spaces after them. It looks a little strange, but it should
    drop you into a MySQL console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `show databases;` command to see if the test databases we have
    specified in our default variables are being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It appears as though everything was created properly and is working as expected.
    When you are done working in this session, you can exit from the MySQL CLI using
    the `exit` command. Use `ansible-container destroy` to reset your environment.
    Let's make things interesting by customizing our role and sourcing external variable
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the container-enabled role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, it is very easy to abstract away from changes
    in Ansible Container projects by adding variables directly to the project `container.yml`
    file and rebuilding the project. This provides the added convenience of having
    all of our configuration changes in a single location and functioning effectively
    as a single point of truth. This might be sufficient for some use cases, but what
    about circumstances in which one would need to provide containers configured differently
    to support multiple environments or locations, such as the development, testing,
    QA, and production environments? You could simply update the `container.yml` file
    and build separate images for these scenarios. However, Ansible Container provides
    us with a better way to handle this by providing the ability to source external
    variable files. A part of the `ansible-container` parent command is the `--var-files`
    flag, which provides the option to source an external YAML file for variable definitions.
    This provides us with an abstraction that allows separate builds to run and exist
    in parallel using different configuration options. This also allows us to customize
    our role using separate variable files for almost any circumstance that can be
    version-controlled along with our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this functionality, let''s create a directory in the root of our
    project (the same level as the project-specific `container.yml`) called `variable_files`.
    Inside of this directory, we will create three separate files: `dev.yml`, `test.yml`,
    and `prod.yml` with slightly different configuration options. The following are
    examples of these three files. Do enjoy my Star Trek references!'
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, it would be a good idea to perform an `ansible-container destroy` action
    before rebuilding the containers using different variables. This way, you can
    see exactly what is being changed during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the development, the primary user of our database will be Yeoman Rand. She
    will be primarily concerned with Starfleet data:'
  prefs: []
  type: TYPE_NORMAL
- en: variable_files/dev.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file is located in `<project_root>/variable_files/dev.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In `System Test`, Mr. Spock will be the primary user of our database. He has
    slightly more interest in data related to Planet Vulcan, ship ordinances, shuttlecraft,
    as well as federation data.
  prefs: []
  type: TYPE_NORMAL
- en: variable_files/test.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is located in `<project_root>/variable_files/test.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: variable_files/prod.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In production, Captain Kirk is going to need to store vastly different data
    than the other crew members. We will need to enhance our MySQL configuration from
    a bit to support the added overhead of storing the Captain''s Logs, Enterprise
    data, as well as federation mandates. This file is located  in: `<project_root>/variable_files/prod.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may also notice that not all variables are being overridden in every example
    shown here. In cases where variables are not being overridden by the sourced files,
    Ansible will take the values present in `defaults/main.yml` in the role. It is
    important that your role defaults provide values for all variables, as variables
    referenced without values will break the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Variable files can be named anything you want. Since we are sourcing these files
    during the build process, and they are not something that Ansible Container will
    automatically discover, the naming convention is entirely up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build containers based on any of these variables by executing our `ansible-container
    build` command and adding the `--vars-files` flag as a parameter of the `ansible-container`
    command. Remember, we always run `build` commands in the same directory as the
    project-specific `container.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'During the build, you should notice that many of the tasks look slightly different
    based on the variables we are providing. For example, when sourcing development
    variables, you will see that only one database gets created: `starfleet_data`.
    This is an indication that the new variables have been sourced and are populated
    correctly in the build process. Let''s perform an `ansible-container run` of the
    new version of our container and try to log in with the same credentials as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to log in using the MariaDB client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very clear to see that the default credentials we have in the role defaults
    are no longer working. Let''s try again using the credentials we specified in
    our development variable file for the Yeoman Rand user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like our new container is working using the sourced variable files
    for development. Let''s run the `show databases;` command to make sure the database
    was properly created and exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the database `starfleet_data` exists alongside the default
    MariaDB databases such as `information_schema`, `MySQL`, and `performance_schema`.
    It appears that the container was built properly and is ready for deployment in
    our development environment (for the purposes of this example). We can now push
    the image to a container registry of our choosing. For this example, I will add
    Docker Hub to the `registries` section of our project-specific `container.yml`
    file, specifying the namespace as my Docker Hub username (remember to remove the
    curly braces after the start of the registries stanza). Once that file is saved,
    let''s tag the image as `dev` and `push` it up to our Docker Hub repository so
    that we have a build image artifact that we can use to deploy our application:'
  prefs: []
  type: TYPE_NORMAL
- en: container.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project-specific `container.yml` file is located in the `root` directory
    of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the image using the `--push-to` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It's not completely necessary to configure Docker Hub as the image registry
    in the `container.yml` file, as Ansible Container will default to using Docker
    Hub. However, I like to make sure I don't accidentally push images to the wrong
    registries, so it is best practice to always provide the image repository in the
    `container.yml` file and always push using the `-–push-to` flag command to specify
    the correct repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same build process for our `test.yml` configuration as well as
    our `prod.yml` configurations and push those up to the Docker Hub repository (remembering
    to do a `destroy` between builds). Notice that, while uploading a different version
    of the image, Docker will automatically identify layers of the image that is identical
    to the previously uploaded version. In this case, Docker will help you to save
    bandwidth and resources by not pushing layers that are identical, but only the
    layers that have changed, as shown in the following. Note the `Layer already exists`
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have three different container image artifacts available to download.
    These images are available to download and deploy in our imaginary development
    lab, system test lab, as well as our production environment. These container images
    are guaranteed to run in these environments in the exact same way as they do in
    our local workstations. At this point, we can do a final exercise and run all
    three of these containers on different ports in order to simulate these containers
    running in different environments with different configurations. To quickly demonstrate
    this, we will use the native `docker run` command to specify our tagged image
    and the ports we want the container service to use; we also specify that our service
    should run in the background using the `-d` flag. Notice that each instance of
    our container that we are creating uses the `dev`, `test`, and `prod` tags as
    well as our user repository address. In my case, it is `aric49`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the container functionality is exactly the same process as before.
    We can use the MariaDB client to log into an instance of our containers. This
    time, however, we will need to specify which port our service is listening on
    since all three instances cannot listen on the default port `3306` on the host
    networking side. If we wanted to log into our production container, we could specify
    the credentials for Captain Kirk using port `33010` and the `ussenterprise` password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Leveraging the same Ansible Container project and container-enabled role, we
    were able to use the Ansible Container default primitives in order to build containers
    with a variety of configurations that are available for use under different circumstances
    and use cases. This approach enables us to be certain that the build process will
    remain exactly the same throughout future build iterations, but we will have the
    flexibility to supply new configuration values into our role without modifying
    the code we wrote previously. Using container tagging, a snapshot of container
    configurations can be captured and shared with other users. We now have a tremendously
    useful and repeatable pipeline to ensure that future versions of our application
    containers have traceability back to the source roles used to generate them. Even
    if the container images are accidentally deleted from our image registry, we can
    easily build and rebuild our containers at any time, since all configuration in
    our containers is declared as code using the Ansible playbook language. If you
    have worked in an IT-related DevOps or a systems administrator position for very
    long, you will understand how valuable it is to have this level of insight into
    your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Official YAML Standard Guide**: [http://yaml.org](http://yaml.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible Module Index**: [http://docs.ansible.com/ansible/latest/modules_by_category.html](http://docs.ansible.com/ansible/latest/modules_by_category.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible Playbook Specification**: [http://docs.ansible.com/ansible/latest/playbooks.html](http://docs.ansible.com/ansible/latest/playbooks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we looked at how roles not only enable reuse
    in Ansible Container but are actually the bread and butter of what makes Ansible
    Container a powerful tool for building and managing containers.
  prefs: []
  type: TYPE_NORMAL
- en: We first looked at how we can use the Ansible Galaxy command-line tools to create
    the shell for a container-enabled role, all necessary directories, and default
    YAML files from which we can build our role. From there, we wrote a custom role
    that builds a MariaDB container using a sane set of default configuration options.
    Finally, we developed an abstraction layer on top of our role by passing in custom
    variable configuration options, from which we can customize our container project
    without modifying any code.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this chapter has effectively demonstrated the raw power available to
    you using the Ansible Container project. Up until this point, I think it is easy
    to make the assumption that it is easier to build container images using Dockerfiles
    and not worrying about the added overhead of Ansible Container. I hope you will
    now understand that the benefits of using Ansible Container far outweigh the slight
    layer of additional complexity required. Using Ansible Container, you can create
    a powerful pipeline for building, running, testing, and pushing container images.
    By leveraging the easy-to-understand Ansible playbook syntax language, we have
    a basis from which we can start building a modern, agile, containerized infrastructure
    that gives us the ability to deploy changes quickly and truly begin to embrace
    the promise of genuinely modular infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to build and deploy truly custom containers we can
    start to look at Kubernetes, an open source framework for automating the deployment,
    orchestration, and management of containers at scale.
  prefs: []
  type: TYPE_NORMAL
