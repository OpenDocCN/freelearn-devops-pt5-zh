- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Automation – Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is open source automation and orchestration software that can be used
    for automating most of your operations with IT infrastructure components including
    servers, storage, networks, and application platforms. Ansible is one of the most
    popular automation tools in the IT world now and has strong community support
    with more than 5,000 contributors around the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Ansible? Where should I use this automation tool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your managed nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of today, Ansible is only available on Linux/Unix platforms, but that doesn't
    mean you cannot use Ansible to automate other **operating systems** (**OSs**)
    or devices. It is possible to use Ansible to automate almost all components involved
    in the IT infrastructure, as there are thousands of supported modules available
    to support Ansible automation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements to proceed with this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic understanding of the Linux OS and how to handle basic operations in
    Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more Linux machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The codes and snippets used in the chapter are tested in **Red Hat Enterprise
    Linux 8** (**RHEL8**). All the Ansible code, Ansible playbooks, commands, and
    snippets for this chapter can be found in the GitHub repository at [https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-01](https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-01).
  prefs: []
  type: TYPE_NORMAL
- en: Hello engineers!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary role of a systems engineer is building and managing IT infrastructure
    for hosting applications and their data. In the olden days, the number of applications
    used was a lot less, hence the infrastructure size. As the applications and components
    grew, the IT infrastructure also grew, and systems engineers and system administrators
    started experiencing resource conjunction. In other ways, systems engineers are
    spending more time on building, maintaining, and supporting the infrastructure
    rather than spending time on improving the infrastructure designs and optimizing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: For the support team, 90% of the event tickets are simple fixes including disk
    space full, user account locked, volumes not mounted, and so on. But the support
    engineer still needs to manually log in to each and every server and fix the issues
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The task can be fixing a low disk space issue on servers, installing some packages,
    patching OSs, creating virtual machines, or resetting a user password; engineers
    are doing the same job repeatedly for multiple systems, and this led to the invention
    of automated operations. Initially, the solution for automation was custom scripts
    developed and maintained by individual engineers, but it was never a real solution
    for the enterprises as there was no collaboration, maintenance, or accountability
    for such custom automation scripts. If the developer leaves the organization,
    the script will become an orphan and the next engineer will create their own custom
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of DevOps methodologies and practices, developers, systems
    engineers, operations teams, and other platform teams started working together,
    the boundaries between them became thinner, and a better accountable ecosystem
    evolved. Everyone started building and maintaining the applications and the underlying
    IT infrastructure, which, in turn, made the automation use case list bigger and
    more complex.
  prefs: []
  type: TYPE_NORMAL
- en: What is Ansible? Where should I use this tool?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is an open source automation tool that was written and released by Michael
    DeHaan on February 20, 2012\. In 2013, **Ansible, Inc.** (originally **AnsibleWorks,
    Inc.**) was founded by Michael DeHaan, Timothy Gerla, and Saïd Ziouani, and their
    intention was to commercially support and sponsor Ansible. In 2015, Ansible was
    acquired by Red Hat, and Red Hat supports and promotes Ansible as per the expectations
    of the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: As of today, the Ansible control node is only available for Linux/Unix based
    platforms (most of the general-purpose OSs, such as Red Hat Enterprise Linux,
    CentOS, Fedora, Debian, or Ubuntu) and you cannot install it on Windows natively
    (it is possible to use Windows Subsystem for Linux or virtual machines for the
    same). This does not mean that you cannot use Ansible to automate your Windows
    operations. It is possible to use the Ansible control node on Linux and manage
    your Windows machines together, with other devices and platforms such as network
    devices, firewall devices, cloud platforms, and container platforms. There are
    more than 3,200 Ansible modules (as of today) available to use and, for Windows
    alone, there are more than 100 Ansible modules to automate Windows OS-based operations.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible-Supported Windows OSs
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can manage desktop OSs including Windows 7, 8.1, and 10, and server
    OSs including Windows Server 2008, 2008 R2, 2012, 2012 R2, 2016, and 2019\. Refer
    to [https://docs.ansible.com/ansible/latest/user_guide/windows_setup.xhtml#host-requirements](https://docs.ansible.com/ansible/latest/user_guide/windows_setup.xhtml#host-requirements)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The community version of Ansible is free to use like other open source software,
    but there is also a product offering from Red Hat based on Ansible called Red
    Hat **Ansible Automation Platform**, which is available with a paid subscription.
    Use either the community version of Ansible or the Red Hat-supported version with
    a subscription. Ansible Automation Platform is for enterprise use with functionalities
    such as **role-based access control** (**RBAC**), **graphical user interface**
    (**GUI**), **Application Programming Interface** (**API**), redundancy, and scalability.
    Consider these options when you expand your automation use cases with a bigger
    team with many engineers working on automation and when you need auditing, tracing,
    and other integrations. Read more about Ansible Automation Platform at [https://www.ansible.com/products/automation-platform](https://www.ansible.com/products/automation-platform).
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat Ansible Automation Platform
  prefs: []
  type: TYPE_NORMAL
- en: The enterprise automation product from Red Hat was known as **Ansible Tower**
    until the announcement of the Red Hat Ansible Automation Platform in September
    2019 ([https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform](https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform)).
    The components inside Ansible Automation Platform were renamed with more meaningful
    names, such as automation controller and execution environment. Read more about
    Ansible Automation Platform at [https://www.redhat.com/en/technologies/management/ansible](https://www.redhat.com/en/technologies/management/ansible).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible documentation is available at [https://docs.ansible.com](https://docs.ansible.com).
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write automation steps in a YAML file called an **Ansible playbook**.
    Ansible will parse the playbook file and execute the tasks on target machines:'
  prefs: []
  type: TYPE_NORMAL
- en: You should know the basics of Linux; as I mentioned earlier, it is possible
    to install Ansible on a Linux or Unix machine only at the current time. That does
    not mean that you should be a Linux subject matter expert, but you need to be
    able to handle basic operations in Linux, such as file management and file editing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to understand the YAML syntax, which is easy, as YAML is one of the
    easiest human-readable file formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible is based on the Python programming language, but you don't need to learn
    Python or any kind of programming language to develop Ansible automation playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: What is YAML?
  prefs: []
  type: TYPE_NORMAL
- en: '**YAML Ain''t Markup Language** (**YAML**) is a human-readable language format
    used for most modern tools and software, including Ansible, Kubernetes, and OpenShift.
    YAML is often used as a file format for application data and configuration, for
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible control node requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are no specific hardware requirements for the Ansible control node machine.
    It is possible to use a machine with 512 MB memory and one **virtual central processing
    unit** (**vCPU**). Follow some standard **virtual machine** (**VM**) specifications,
    such as 4 GB or higher, as you may need more memory when you have more managed
    nodes and more tasks to run in parallel. For the disk, you may follow standard
    VM specifications, as Ansible is a small program and does not require much disk
    space. Use any Linux/Unix machine with Python 3.8 or newer installed.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Control Node Requirements
  prefs: []
  type: TYPE_NORMAL
- en: Find the Ansible control node requirements at https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#control-node-requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible managed node requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The target nodes (managed nodes) should be installed with Python 2.6 or later
    (3.x is recommended) to execute the task. For Windows machines, you need to install
    PowerShell and .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible is also supported for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public clouds such as AWS, Azure, and GCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2.x EOL
  prefs: []
  type: TYPE_NORMAL
- en: Install Ansible on a machine with Python 2.x, but Python 2.x is already **end-of-life**
    (**EOL**) by January 1, 2020, and it is best practice to use the latest Python
    version. For more detailsabout Python 2 end of life, visit [https://www.python.org/doc/sunset-python-2/](https://www.python.org/doc/sunset-python-2/).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is agentless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two types of machines involved in Ansible automation. The machine
    in which you install the Ansible program is known as the **Ansible control node**.
    The control node can be any machine, a dedicated server, or even your workstation,
    and it will have your Ansible playbook and other configurations. Then, the machines
    or devices that you want to automate are known as **managed hosts**. You will
    run the Ansible jobs and playbooks from the control node and the jobs will be
    executed on the target nodes or managed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the basic components of Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Ansible and components ](img/B18383_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Ansible and components
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is agentless and you do not need to install any kind of agents on the
    managed nodes. Ansible uses default connection methods to communicate with managed
    nodes, such as `ssh`, `WinRM`, `http`, or other appropriate protocols. During
    the onboarding, you need to configure the credentials for the managed nodes, such
    as an SSH credential, with SSH keys, or an SSL certificate for WinRM connection.
    This is a one-time setup, and it is possible to configure or change this anytime.
    It is possible to use the same or different credentials for different managed
    nodes, and configure this for individual nodes or a group of managed nodes. You
    will learn about managed nodes and inventory in the next sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the Ansible internals and its components'' structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Ansible and components ](img/B18383_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Ansible and components
  prefs: []
  type: TYPE_NORMAL
- en: Ansible inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ansible inventory is a file or script that will provide the details about
    the managed nodes, including the hostname, connection methods, credential to use,
    and many other details. It is possible to pass the inventory to Ansible using
    static inventory files, dynamic inventory scripts, or using the **configuration
    management database** (**CMDB**). The CMDB is the same CMDB that can provide the
    managed nodes information. It is best practice to integrate CMDB with Ansible
    in an environment to avoid frequent updates on the static inventory files, but
    this is not a mandatory component.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to add any number of managed nodes inside the inventory file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Ansible inventory with managed nodes ](img/B18383_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Ansible inventory with managed nodes
  prefs: []
  type: TYPE_NORMAL
- en: It is best practice to separate the managed nodes information in multiple inventory
    files based on the criticality, server types, and environment. You will learn
    more about inventory best practices in [*Chapter 16*](B18383_16.xhtml#_idTextAnchor294),
    *Storing Remote Host Information – Inventory Best Practices*.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic inventory plugins will collect the details of managed nodes from your
    virtualization platforms such as VMware, OpenStack, AWS, Azure, and GCP, or from
    other container platforms such as Kubernetes. There are more than 40 dynamic inventory
    plugins available to use in the Ansible GitHub repository. Use them if needed
    or create your own dynamic inventory scripts if those are not suitable for your
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Dynamic Inventory
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the Ansible dynamic inventory, look it up at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml)
    and [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible plugins are small pieces of code that help to enable a flexible and
    expandable architecture. You have Ansible executable, and add plugins as needed
    for other features and capabilities like any other software. There are different
    types of plugins in Ansible such as `ssh`, and it is possible to use connection
    plugins called `docker` or `buildah` for connecting to containers. If you need
    to, install and use these plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Plugins
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Ansible plugins at [https://docs.ansible.com/ansible/latest/plugins/plugins.xhtml](https://docs.ansible.com/ansible/latest/plugins/plugins.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ansible module is a piece of reusable and standalone script that can be used
    to achieve some specific tasks. Modules provide a defined interface with options
    to accept arguments and return information to Ansible in JSON format. When you
    execute a task using a module, the module script will be executed on the target
    machine using Python or using PowerShell for Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following Ansible content is using a `ping` module to verify
    the connectivity to the target machine and another task with the `yum` module
    for installing `httpd package` on a managed node using the `yum` package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Ansible ping module and yum module ](img/B18383_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Ansible ping module and yum module
  prefs: []
  type: TYPE_NORMAL
- en: I said earlier that we can automate network devices and firewall devices using
    Ansible, but, we all know that we cannot install Python or PowerShell on those
    devices. Unlike most of the Ansible modules, network modules do not run on network
    devices. Instead, these modules will be executed from the Ansible control node
    itself and run the appropriate commands on target network devices to achieve the
    task. From the user's point of view, there is no difference in the execution of
    network modules as you still use them like any other modules. It is possible to
    manage the network devices like other Linux machines and Windows machines but
    with different connection methods, such as `network_cli`, `netconf`, and `httpapi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read: How Network Automation Is Different'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml)
    to learn more about network device automation.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible content collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before version 2.10, Ansible was a big package with all modules and libraries
    inside, but the community grew very fast and thousands of new modules were contributed
    to Ansible. Whenever there is a new module or new version of a module available
    from the community or vendors, then users need to wait for the next release of
    Ansible to get the updated module. To resolve this dependency, a new way of distribution
    has started in which Ansible modules are separated from the Ansible base and distributed
    as **Ansible content collections**, or simply **Ansible collections**. You have
    the choice of installing Ansible alone or installing the Ansible package including
    Ansible collections. If you need to manage some different set of nodes or systems
    (for example, managing the VMware private cloud or automating Fortigate firewall
    devices), then install the required Ansible collection and use it. This modularity
    allows you to install only the required modules and plugins rather than all available
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the transition of the Ansible collection from old
    Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Ansible to Ansible core and Ansible collection transformation
    ](img/B18383_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Ansible to Ansible core and Ansible collection transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note some of the changes in the Ansible base and Ansible collection restructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before version 2.9.x: The package included `ansible` and all the Ansible modules
    and other plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From version 2.10++: Ansible was renamed to `ansible-base` and modules were
    moved to Ansible collections (vendors and communities).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From version 2.11++: `ansible-base` was renamed to `ansible-core`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you install Ansible 3.x or Ansible 4.x, then you are installing the Ansible
    community package, which includes `ansible-core` and all the Ansible collections
    (vendor and community).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restructuring the Ansible Project
  prefs: []
  type: TYPE_NORMAL
- en: Read the blog post [ansible.com/blog/thoughts-on-restructuring-the-ansible-project](http://ansible.com/blog/thoughts-on-restructuring-the-ansible-project)
    and [ansible.com/blog/the-future-of-ansible-content-delivery](http://ansible.com/blog/the-future-of-ansible-content-delivery)
    to know more about Ansible collection transition.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ansible playbook is a simple file written in YAML format with the instruction
    list of automation tasks. The following diagram explains the components, syntax,
    and structure of an Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Ansible playbook basic components ](img/B18383_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Ansible playbook basic components
  prefs: []
  type: TYPE_NORMAL
- en: Each task in the **play** runs a module to do some specific job on the target
    node. You can have multiple tasks in a play and multiple plays inside a single
    playbook, as shown in the diagram. The plays, tasks, and module arguments are
    identified by the indentation in YAML format. In this example, we have a playbook
    with two plays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first play, `Enable Intranet Services`, we are running the tasks against
    `node1` – see the `hosts: node1` line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the tasks, see two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The first task is using the `yum` module and installing the `httpd` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second task is using the `service` module to start the `httpd` service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we have a second play, `Test intranet web server`, in the playbook, in
    which you have only one task:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `uri` module to test the intranet web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible will parse this playbook and execute the tasks one by one on the target
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to build, manage, or maintain almost all components in IT infrastructure
    using Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: Servers and storages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network devices, firewalls, **software-defined networks** (**SDNs**), and load
    balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and container platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public cloud and private cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to find the use cases from your day-to-day work and find the highest
    number of tasks you are repeating every day and consider those tasks as automation
    candidates. The following is a sample list of such use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: OS patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application and package deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration of application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and compliance auditing and remediation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database provisioning and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will learn how to install and configure Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to install Ansible on your system, such as using the
    default package manager (`yum`, `apt`, `dnf`), using Python’s `pip`, or installing
    the source code itself. Depending on your environment and restrictions, follow
    any of the methods provided in the official documentation ([https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml)).
    If you are using the OS package manager, such as `dnf`, `yum`, or `apt`, then
    you need `sudo` privileges (or `root` access) to install Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Please note, you do not require `root` or `sudo` access on the Ansible control
    node for using Ansible. In the following snippet, `sudo` access is used for installing
    and updating packages.
  prefs: []
  type: TYPE_NORMAL
- en: Verify dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you learned that Ansible needs Python to work, you need to check the Python
    installation first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Checking installed Python packages and version ](img/B18383_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Checking installed Python packages and version
  prefs: []
  type: TYPE_NORMAL
- en: If you have a supported Python version installed, then proceed with the Ansible
    installation as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible using the package manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on the OS, you need to add and enable the appropriate repositories
    before installing Ansible. For example, if you are using **Red Hat Enterprise
    Linux** (**RHEL**), then you need to ensure the Red Hat subscriptions are in place
    and repositories are enabled to install Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Installing Ansible package ](img/B18383_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Installing Ansible package
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify an installed Ansible version with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Verifying Ansible installation ](img/B18383_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Verifying Ansible installation
  prefs: []
  type: TYPE_NORMAL
- en: From this output, see the version of Ansible (*2.9.27*), the default configuration
    file used(config file = `/etc/ansible/ansible.cfg`), the module search path, the
    Python version in use, and other details.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding Ansible version is coming from the default repository that you
    have configured on the OS. If you want to install the latest or different version
    of Ansible, then you need to follow different methods.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible using Python pip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to install `pip` if it is not already available on the system and
    then install Ansible using Python pip as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Installing Ansible using Python pip ](img/B18383_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Installing Ansible using Python pip
  prefs: []
  type: TYPE_NORMAL
- en: Please note, when you execute `pip install ansible`, you are installing the
    Ansible package, which contains `ansible-core` and Ansible collections. I have
    already explained Ansible collections earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Pip-Based Ansible Installation and Support
  prefs: []
  type: TYPE_NORMAL
- en: It is best practice to follow the installation based on the OS package manager
    to get the appropriate support and updates automatically. Also, pip-based installations
    are hard to maintain and upgrade when there are newer versions of software available.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to install a specific version of `ansible`, `ansible-base`, or
    `ansible-core`, then use the version information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Installing specific version of Ansible using pip  ](img/B18383_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Installing specific version of Ansible using pip
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the Ansible version now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Check Ansible version ](img/B18383_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Check Ansible version
  prefs: []
  type: TYPE_NORMAL
- en: See the `DEPRECATION WARNING` message and ignore that in a development environment.
    But in the production environment, you need to make sure you are using the supported
    Python version for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Installation
  prefs: []
  type: TYPE_NORMAL
- en: Check the Ansible documentation for instructions for different OSs and methods
    at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start with automation jobs, you need to configure Ansible for your
    environment using the `ansible.cfg` file. Ansible will look for a configuration
    file in four places in order, as listed in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ANSIBLE_CONFIG`: Configuration file path in an environment variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./ansible.cfg`: Configuration file in the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/.ansible.cfg`: Configuration file in the home directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/ansible/ansible.cfg`: Default configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is a best practice to keep the project-specific `ansible.cfg` file in the
    project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Creating the ansible.cfg file  ](img/B18383_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – Creating the ansible.cfg file
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some basic configurations inside the `ansible.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – Content of the ansible.cfg file  ](img/B18383_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – Content of the ansible.cfg file
  prefs: []
  type: TYPE_NORMAL
- en: It is not a best practice to keep `remote_user = devops` in `ansible.cfg`; instead,
    configure it inside the inventory for different hosts and host groups. You will
    learn about this later in this chapter, in the *Creating an Ansible inventory*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check the Ansible version again to see the difference and see that Ansible
    is taking `/home/ansible/ansible-demo/ansible.cfg` as the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – Checking which ansible.cfg is taken by Ansible  ](img/B18383_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – Checking which ansible.cfg is taken by Ansible
  prefs: []
  type: TYPE_NORMAL
- en: You have many other parameters to configure in `ansible.cfg` but not all of
    them are mandatory as if you have not specified parameters in your custom `ansible.cfg`
    file, then Ansible will load the default configurations as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'See another sample `ansible.cfg` file, which contains some of the important
    parameters, deciding the privilege escalation in Ansible. These parameters decide
    the `sudo` or `su` operation on the target nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 – Another ansible.cfg sample with privilege escalation parameters
    ](img/B18383_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16 – Another ansible.cfg sample with privilege escalation parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible will log in to the remote node as a `devops` user and without asking
    for a password (`ask_pass = false`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible will automatically escalate privilege (`become = true`) to `root` (`become_user
    = root`) by using the `sudo` method (`become_method = sudo`) and it will also
    ask for a `sudo` password for the user. Turn this off with the `become_ask_pass
    = false` setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure different credentials for different nodes in the Ansible inventory.
    You will learn about that in a later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also note, in the preceding example I have not created any inventory files yet.
    I just mentioned the inventory filename there as `./hosts`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Ansible inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use any name for your inventory file, such as `hosts`, `inventory`, `myhosts`,
    or `production-servers`. Do not confuse this hosts file with the `/etc/hosts`
    file. When you have more and more managed nodes in inventory files, split the
    inventory into groups or into separate inventory files. For example, put production
    servers and devices in a file called `production-hosts`, and staging nodes into
    the `staging-hosts` file; there are no restrictions on this. Also note, if you
    are installing Ansible using the `yum` or `apt` utilities, then there will be
    a default inventory file called `/etc/ansible/hosts` with sample inventory content.
    Refer to that file to start with, but it is best practice to create your project-specific
    inventory file inside your project directory itself. It is possible to create
    inventory files in the `ini` or `yaml` formats as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Creating inventory file inside project directory  ](img/B18383_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.17 – Creating inventory file inside project directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Add content inside the file as follows and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Sample inventory file  ](img/B18383_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18 – Sample inventory file
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not need to add `localhost` as the `localhost` entry is implicit in
    Ansible. That means we can still call the `localhost` node and Ansible will create
    an implicit entry. In the preceding demonstration, I have added this to show an
    entry as a sample. Since `localhost` is the local machine, you will not be using
    an SSH connection and it is possible tell Ansible the connection type for localhost
    as `local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is not easy to remember the nodes with IP addresses or nodes with long hostnames.
    In Ansible, use any name for your hosts, and mention the actual name or IP address
    using the `ansible_host` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your inventory with the correct entry name now. Please note, this is
    optional, but it is a best practice to use human-readable names rather than IP
    addresses and long **Fully Qualified Domain Names** (**FQDNs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Ansible inventory with human-readable names and ansible_host
    ](img/B18383_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Ansible inventory with human-readable names and ansible_host
  prefs: []
  type: TYPE_NORMAL
- en: The default `ansible_connection` is `ssh` and you do not need to mention that
    in the inventory. If you are using any other connection types, then you need to
    mention them, such as `local`, `winrm`, or `paramiko`.
  prefs: []
  type: TYPE_NORMAL
- en: Add any number of nodes here with multiple host groups (as the `dev` host group
    in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test your inventory to make sure Ansible is able to read and understand
    your inventory and hosts. Please note that you are not connecting to the hosts
    from Ansible using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – List inventory hosts  ](img/B18383_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – List inventory hosts
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another inventory file with some dummy managed nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – Another Ansible inventory with more hosts and groups  ](img/B18383_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – Another Ansible inventory with more hosts and groups
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding inventory, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have four host groups: `myself`, `intranet`, `database`, and `everyone`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`everyone` is the parent of the `myself`, `intranet`, and `database` host groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have two inventory files here now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22 – Multiple inventory files in project directory  ](img/B18383_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22 – Multiple inventory files in project directory
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a different inventory file, you do not need to change the content of
    `ansible.cfg`; instead, use the `-i` switch to specify the inventory file dynamically.
    Ansible will take the mentioned inventory files instead of the one configured
    in the `ansible.cfg` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23 – List inventory hosts with different a inventory file ](img/B18383_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.23 – List inventory hosts with different a inventory file
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `--help` options to see all the available switches with the Ansible
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24 – List inventory hosts with different a inventory file ](img/B18383_01_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.24 – List inventory hosts with different a inventory file
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use patterns to filter the managed hosts with supported
    patterns. For example, let us display only managed nodes with `*techbeatly.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25 – Host selection using patterns ](img/B18383_01_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.25 – Host selection using patterns
  prefs: []
  type: TYPE_NORMAL
- en: Ansible host patterns
  prefs: []
  type: TYPE_NORMAL
- en: Look up more information about patterns, targeting hosts, and groups at [https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Look up more information about the Ansible dynamic inventory at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml)
    and [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to configure managed nodes and connections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your managed nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use any supported authentication mechanisms to connect from the Ansible control
    node to managed node, such as SSH key-based authentication, username and password-based
    authentication, and SSL certificate authentication, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SSH key-based authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to automate most of the following steps using Ansible ad hoc
    commands, but we will be using the manual approach to understand what backend
    configurations are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to create a user (for example devops) and enable SSH key based access
    on node-1 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a dedicated user on the target node (e.g.: node01) as follows. (This
    is not mandatory, and it is possible to use any existing user accounts and configure
    that in Ansible.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.26 – Create new user and set password  ](img/B18383_01_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.26 – Create new user and set password
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have `ansible_host` option, or add entries in `/etc/hosts` as
    local DNS resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the `sudo` access for the new user because, for any kind of privileged
    operation on the target node, you will be required to have this access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.27 – Enabled privileged access for the new user  ](img/B18383_01_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.27 – Enabled privileged access for the new user
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `SSH` key pair on the **Ansible control** **node**. It is possible
    to create any supported type and size. Please note, if you have any existing key
    with the same name, please remember to use a different name or backup the original
    SSH key pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.28 – Generating SSH key pair on Ansible control node  ](img/B18383_01_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.28 – Generating SSH key pair on Ansible control node
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the SSH key permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.29 – Verify SSH key permission  ](img/B18383_01_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.29 – Verify SSH key permission
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the SSH public key from the Ansible control node to managed nodes under
    the `devops` user using the `ssh-copy-id` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.30 – Copy SSH public key to managed node  ](img/B18383_01_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.30 – Copy SSH public key to managed node
  prefs: []
  type: TYPE_NORMAL
- en: If you have issues with password authentication or copying, then manually copy
    the public key content from `/home/ansible/.ssh/id_rsa.pub` to the `/home/devops/.ssh./authorized_keys`
    file on the managed node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the passwordless SSH access from the Ansible control node to the managed
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.31 – Login to managed node without password ](img/B18383_01_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.31 – Login to managed node without password
  prefs: []
  type: TYPE_NORMAL
- en: How to Set Up SSH Key-Based Authentication
  prefs: []
  type: TYPE_NORMAL
- en: Check out the steps on how to set up SSH key-based authentication at [https://www.techbeatly.com/2018/06/how-to-setup-ssh-key-based-authentication.xhtml](https://www.techbeatly.com/2018/06/how-to-setup-ssh-key-based-authentication.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the option to use multiple credential for
    different managed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple users and credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have different credentials for different managed nodes, then configure
    the remote username, SSH key to be used, and more in your inventory file. Let
    me show a sample for our `node01` managed node in our inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.32 – Configuring SSH key information for managed nodes  ](img/B18383_01_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.32 – Configuring SSH key information for managed nodes
  prefs: []
  type: TYPE_NORMAL
- en: In the latter example, we have used a variable section for the `dev` host group
    and mentioned the SSH key and remote user details.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible ad hoc commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ansible` command can be used to execute single jobs on managed nodes without
    a playbook; this is called an `ping`) to the managed nodes, creating a user account,
    copying some files, or restarting a service, and execute these tasks without writing
    an Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it is possible to use the `ping` module to test the connection
    from Ansible to the managed node, `node01`, using this user and SSH key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.33 – Ansible ad hoc command using ping module  ](img/B18383_01_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.33 – Ansible ad hoc command using ping module
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, as you have `localhost` also in the inventory (by
    implicit), the task will be executed on both localhost and node01 nodes when you
    mention `all`. The Ansible `ping` module is not just a regular network ping (ICMP);
    instead, it will log in to the managed node and return the result, `pong`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute another Ansible ad hoc command using the `shell` module to check what
    remote user Ansible is using for connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.34 – Ansible ad hoc command using shell module  ](img/B18383_01_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.34 – Ansible ad hoc command using shell module
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, see that `localhost` is executed with the default
    `ansible` user and the `dev` node with the `devops` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute multiple commands using the `shell` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.35 – Multiple commands in shell module  ](img/B18383_01_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.35 – Multiple commands in shell module
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the preceding example was used to demonstrate the `shell` module,
    and similar details can be collected using `ansible_facts` without such tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.36 – Ansible ad hoc command using setup module ](img/B18383_01_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.36 – Ansible ad hoc command using setup module
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about `ansible_facts` in [*Chapter 3*](B18383_03.xhtml#_idTextAnchor052),
    *Automating Your Daily Jobs*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package using Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to ensure that you have package repositories (`yum` or `apt`) configured
    and enabled on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `vim` package on `node01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.37 – Ansible ad hoc command using dnf module ](img/B18383_01_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.37 – Ansible ad hoc command using dnf module
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, see that you are using the `devops` user for connecting
    to managed nodes, which is a normal user. You do not need to add the `become`
    details in `ansible.cfg`; instead, pass this `become` switch while executing the
    `ansible` command, which is `-b`. (For Ansible playbooks, you can enable or disable
    the privilege escalation at the play level or tasks level):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.38 – Installing package using dnf module and privileged mode  ](img/B18383_01_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.38 – Installing package using dnf module and privileged mode
  prefs: []
  type: TYPE_NORMAL
- en: The package installation is successful as per the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding ad hoc execution can be written in a playbook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.39 – Package installation using an Ansible playbook ](img/B18383_01_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.39 – Package installation using an Ansible playbook
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about writing playbooks in [*Chapter 2*](B18383_02.xhtml#_idTextAnchor043),
    *Starting with Simple Automation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remove the same package using an Ansible ad hoc command; instead of `state=latest`,
    use `state=absent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.40 – Removing package using Ansible ad hoc command  ](img/B18383_01_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.40 – Removing package using Ansible ad hoc command
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully installed and uninstalled a package using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the core concepts of Ansible, how Ansible
    works, and the key terminology, including Ansible inventory, playbooks, tasks,
    Ansible control node, managed nodes, and modules. You have also learned about
    basic Ansible installation, configuration, and deployment, and the importance
    of managed node configuration, SSH key credentials, and passwordless SSH.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to start with simple automation playbooks
    and execution. Then, you will learn how to find suitable Ansible modules for playbook
    development and remote node connection methods.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Ansible documentation*: https://docs.ansible.com/ansible/latest/index.xhtml'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible control node requirements*: https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#control-node-requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible dynamic inventory*: https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml
    and https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible Automation Platform*: https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Installing Ansible*: https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How network automation is different*: https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
