<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor378"/>9</h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor379"/>Advanced Ansible Topics</h1>
<p>Up to this point, we have worked hard to give you a solid foundation in Ansible so that, whatever your desired automation task, you can implement it with ease and confidence. However, when you really start to ramp up your automation, how do you ensure that you can handle any condition that arises in a graceful manner? For example, how can you ensure that when you have to initiate long-running actions, you can run them asynchronously and come back to them to check on the results reliably later? Or, if you are updating a large group of servers, how can you ensure that the play fails early if a handful of servers suffer failures? The last thing you want to do is to roll out a broken update (let’s face it, problems do occur with everyone’s code from time to time) across 100 servers—far better to detect that a small percentage have failed and abort the entire play on this basis than attempt to continue and break an entire load-balanced cluster.</p>
<p>In this chapter, we will look at how to solve these particular issues, as well as many more, using some of the more advanced features of Ansible to control playbook flow and error handling. We will explore, through practical examples, how to perform rolling updates with Ansible, how to work with proxies and jump hosts (which is vital for secure environments and often for core network configuration), and how to secure sensitive Ansible data at rest using the native Ansible Vault technology. By the end of this chapter, you will have a full picture of how to run Ansible not only in a small environment but also in a large, secure, mission-critical environment.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Asynchronous versus synchronous actions</li>
<li>Controlling play execution for rolling updates</li>
<li>Configuring the maximum failure percentage</li>
<li>Setting task execution delegation</li>
<li>Using the <code>run_once</code> option</li>
<li>Running playbooks locally</li>
<li>Working with proxies and jump hosts</li>
<li>Configuring playbook prompts</li>
<li>Placing tags in the plays and tasks</li>
<li>Securing data with Ansible Vault<a id="_idTextAnchor380"/></li>
</ul>
<h1 id="_idParaDest-130"><a id="_idTextAnchor381"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as detailed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and are using the most recent version available. The examples in this chapter are tested with Ansible 2.15. This chapter also assumes that you have at least one additional host to test against and, ideally, this should be Linux-based. Although we will give specific examples of hostnames in this chapter, you are free to substitute them with your own hostname and/or IP addresses; details of how to do this are provided at the appropriate places.</p>
<p>The code bundle for this chapter is available at <a href="https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%209">https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%209</a>.<a id="_idTextAnchor382"/></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor383"/>Asynchronous versus synchronous actions</h1>
<p>As we<a id="_idIndexMarker523"/> have seen in this book so far, Ansible plays are executed in sequence, with each task running to completion before the next task is started. Although this is often advantageous for flow control and logical sequencing, there are times when you may not want this. In particular, it might be the case that a particular task runs for longer than the configured SSH connection timeout, and as Ansible uses SSH to perform its automation tasks on most platforms, this would be an issue.</p>
<p>Fortunately, Ansible tasks can be run asynchronously—that is to say, tasks can be run in the background on the target host and polled on a regular basis. This is in contrast to synchronous tasks, where the connection to the target host is kept open until the task completes (which runs the risk of a timeout occurring).</p>
<p>As ever, let’s explore this through a practical example. Suppose we have two servers in a simple INI-formatted inventory:</p>
<pre class="source-code">
[frontends]
frt01.example.com
frt02.example.com</pre> <p>Now, in <a id="_idIndexMarker524"/>order to simulate a long-running task, we’ll run the <code>sleep</code> command using the <code>shell</code> module. However, rather than have it run with the SSH connection blocked for the duration of the <code>sleep</code> command, we’ll add two special parameters to the task, as shown:</p>
<pre class="source-code">
---
- name: Play to demonstrate asynchronous tasks
  hosts: frontends
  become: true
tasks:
  - name: A simulated long running task
    shell: "sleep 20"
    async: 30
    poll: 5</pre> <p>The two new parameters are <code>async</code> and <code>poll</code>. The <code>async</code> parameter tells Ansible that this task should be run asynchronously (so that the SSH connection will not be blocked) for a maximum of <code>30</code> seconds. If the task runs for longer than this configured time, Ansible considers the task to have failed and the play is failed, accordingly. When <code>poll</code> is set to a positive integer, Ansible checks the status of the asynchronous task at the specified interval—in this example, every <code>5</code> seconds. If <code>poll</code> is set to <code>0</code>, then the task is run in the background and never checked—it is up to you to write a task to manually check its status later on.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you don’t specify the <code>poll</code> value, it will be set to the default value defined by the <code>DEFAULT_POLL_INTERVAL</code> configuration parameter of Ansible (which is <code>10</code> seconds).</p>
<p>When<a id="_idIndexMarker525"/> you run this playbook, you will find that it runs just like any other playbook; from the terminal output, you won’t be able to see any difference. But behind the scenes, Ansible checks the task every <code>5</code> seconds until it succeeds or reaches the <code>async</code> timeout value of <code>30</code> seconds:</p>
<pre class="console">
$ ansible-playbook -i hosts async.yml
PLAY [Play to demonstrate asynchronous tasks] **********************************
TASK [Gathering Facts] *********************************************************
ok: [frt02.example.com]
ok: [frt01.example.com]
TASK [A simulated long running task] *******************************************
changed: [frt02.example.com]
changed: [frt01.example.com]
PLAY RECAP *********************************************************************
frt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt02.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>If you want to check on the task later (that is, if <code>poll</code> is set to <code>0</code>), you could add a second task to <a id="_idIndexMarker526"/>your playbook so that it looks as follows:</p>
<pre class="source-code">
---
- name: Play to demonstrate asynchronous tasks
  hosts: frontends
  become: true
tasks:
  - name: A simulated long running task
    shell: "sleep 20"
    async: 30
    poll: 0
    register: long_task
  - name: Check on the asynchronous task
  async_status:
    jid: "{{ long_task.ansible_job_id }}"
  register: async_result
  until: async_result.finished
  retries: 30</pre> <p>In this playbook, the initial asynchronous task is defined as before, except we have now set <code>poll</code> to <code>0</code>. We have also chosen to register the result of this task to a variable called <code>long_task</code>—this is so that we can query the job ID for the task when we check it later on. The next (new) task in the play uses the <code>async_status</code> module to check on the job ID we registered from the first task and loops until the job either finishes or reaches <code>30</code> retries—whichever comes first. When using these in a playbook, you almost certainly wouldn’t add the two tasks back to back like this—usually, you would perform additional tasks in between them—but to keep this example simple, we will run the two tasks sequentially. Running <a id="_idIndexMarker527"/>this playbook should yield an output similar to the following:</p>
<pre class="console">
$ ansible-playbook -i hosts async2.yml
PLAY [Play to demonstrate asynchronous tasks] **********************************
TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]
ok: [frt02.example.com]
TASK [A simulated long running task] *******************************************
changed: [frt02.example.com]
changed: [frt01.example.com]
TASK [Check on the asynchronous task] ******************************************
FAILED - RETRYING: Check on the asynchronous task (30 retries left).
FAILED - RETRYING: Check on the asynchronous task (30 retries left).
FAILED - RETRYING: Check on the asynchronous task (29 retries left).
FAILED - RETRYING: Check on the asynchronous task (29 retries left).
FAILED - RETRYING: Check on the asynchronous task (28 retries left).
FAILED - RETRYING: Check on the asynchronous task (28 retries left).
FAILED - RETRYING: Check on the asynchronous task (27 retries left).
FAILED - RETRYING: Check on the asynchronous task (27 retries left).
changed: [frt01.example.com]
changed: [frt02.example.com]
PLAY RECAP *********************************************************************
frt01.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt02.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>In the<a id="_idIndexMarker528"/> preceding code block, we can see that the long-running task is left running and the next task polls its status until the conditions we set are met. In this case, we can see that the task finished successfully and the overall play result was successful. Asynchronous actions are especially useful for large downloads, package updates, and other tasks that might take a long time to run. You may find them useful in your playbook development, especially in more complex infrastructures.</p>
<p>With this under our belt, let’s take a look at another advanced technique that might be useful in large infrastructures—performing rolling updates with An<a id="_idTextAnchor384"/>s<a id="_idTextAnchor385"/>ible.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor386"/>Controlling play execution for rolling updates</h1>
<p>By default, Ansible<a id="_idIndexMarker529"/> parallelizes tasks <a id="_idIndexMarker530"/>on multiple <a id="_idIndexMarker531"/>hosts at the same time to speed up automation tasks in large inventories. The setting for this is defined by the <code>forks</code> parameter in the Ansible configuration file, which defaults to <code>5</code> (so, by default, Ansible attempts to run its automation job on five hosts at the same time).</p>
<p>In a load-balanced <a id="_idIndexMarker532"/>environment, this is not ideal, especially if you want to avoid downtime. Suppose we have five frontend servers in an<a id="_idIndexMarker533"/> inventory (or perhaps even fewer). If we allow Ansible to update all of these at the same time, the end users may experience a loss of service. So, it is important to consider updating all of the servers at different times. Let’s reuse our inventory from the previous section with just two servers in it. Obviously, if these were in a load-balanced environment, it would be vital that we only update one of these at a time; if both were taken out of service simultaneously, then end users would definitely lose access to the service until the Ansible play completes successfully.</p>
<p>The answer to<a id="_idIndexMarker534"/> this is to use the <code>serial</code> keyword in the play definition to determine how many hosts are operated on at once. Let’s demonstrate this through a practical example:</p>
<ol>
<li>Create the following simple playbook to run two commands on the two hosts in our inventory. The content of the command is not important at this stage, but if you run the <code>date</code> command using the <code>command</code> module, you will be able to see the time that each task is run, as well as if you specify <code>-v</code> to increase the verbosity when you run the play:<pre class="source-code">
---
- name: Simple serial demonstration play
  hosts: frontends
  gather_facts: false
  tasks:
    - name: First task
      command: date
    - name: Second task
      command: date</pre></li> <li>Now, if you run this play, you will see that it performs all the operations on each host simultaneously, as we have fewer hosts than the defaul<a id="_idTextAnchor387"/>t number of forks—<code>5</code>. This <a id="_idIndexMarker535"/>behavior is normal for Ansible, but not really what<a id="_idIndexMarker536"/> we want as our users will<a id="_idIndexMarker537"/> experience a service outage:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts serial.yml</strong>
<strong class="bold">PLAY [Simple serial demonstration play] ****************************************</strong>
<strong class="bold">TASK [First task] **************************************************************</strong>
<strong class="bold">changed: [frt02.example.com]</strong>
<strong class="bold">changed: [frt01.example.com]</strong>
<strong class="bold">TASK [Second task] *************************************************************</strong>
<strong class="bold">changed: [frt01.example.com]</strong>
<strong class="bold">changed: [frt02.example.com]</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<code>tasks</code> sections exactly as they were in <em class="italic">Step 1</em>:<pre class="source-code">
---
- name: Simple serial demonstration play
  hosts: frontends
  serial: 1
  gather_facts: false</pre></li> <li>Notice the<a id="_idIndexMarker539"/> presence of the <code>serial: 1</code> line. This tells Ansible <a id="_idIndexMarker540"/>to complete the play on <code>1</code> host at a time before moving on to the next. If we run the play again, we can see this in action:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts serial.yml</strong>
<strong class="bold">PLAY [Simple serial demonstration play] ****************************************</strong>
<strong class="bold">TASK [First task] **************************************************************</strong>
<strong class="bold">changed: [frt01.example.com]</strong>
<strong class="bold">TASK [Second task] *************************************************************</strong>
<strong class="bold">changed: [frt01.example.com]</strong>
<strong class="bold">PLAY [Simple serial demonstration play] ****************************************</strong>
<strong class="bold">TASK [First task] **************************************************************</strong>
<strong class="bold">changed: [frt02.example.com]</strong>
<strong class="bold">TASK [Second task] *************************************************************</strong>
<strong class="bold">changed: [frt02.example.com]</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Much better! If <a id="_idIndexMarker541"/>you imagine that this playbook actually <a id="_idIndexMarker542"/>disables these hosts on a load balancer, performs an upgrade, and then re-enables the hosts on <a id="_idIndexMarker543"/>the load balancer, this is exactly how you would want the operation to proceed. Doing so without the <code>serial: 1</code> directive would result in all the hosts being removed from the load balancer at once, causing a loss of service.</p>
<p>It is useful to note that the <code>serial</code> directive can also take a percentage instead of an integer. When you specify a percentage, you are telling Ansible to run the play on that percentage of hosts at one time. So, if you have four hosts in your inventory and specify <code>serial: 25%</code>, Ansible will only run the play on one host at a time. If you have eight hosts in your inventory, it will run the play on two hosts at a time. I’m sure you get the idea!</p>
<p>You can even build on this by passing a list to the <code>serial</code> directive. Consider the following code:</p>
<pre class="source-code">
serial:
- 1
- 3
- 5</pre> <p>This tells Ansible to <a id="_idIndexMarker544"/>run the play on <code>1</code> host, initially, then on the next <code>3</code>, and then on batches of <code>5</code> at a time until the inventory is completed for deploying a new change to particular servers. You<a id="_idIndexMarker545"/> can also specify a list of percentages in place <a id="_idIndexMarker546"/>of the integer numbers of hosts. In doing this, you will build up a robust playbook that can perform rolling updates without causing a loss of service to end users. With this complete, let’s further build on this knowledge by looking at controlling the maximum failure percentage that Ansible can tolerate before it aborts a play, which will again be useful in highly available or load-balanced en<a id="_idTextAnchor388"/>v<a id="_idTextAnchor389"/>ironments such as this.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor390"/>Configuring the maximum failure percentage</h1>
<p>In its <a id="_idIndexMarker547"/>default mode of operation, Ansible continues to execute a play on a batch of servers (the batch size is determined by the <code>serial</code> directive we discussed in the preceding section) as long as there are hosts in the inventory and a failure isn’t recorded. Obviously, in a highly available or load-balanced environment (such as the one we discussed previously), this is not ideal. If there is a bug in your play, or perhaps a problem with the code being rolled out, the last thing that you want is for Ansible to faithfully roll it out to all servers in the cluster, causing a service outage because all the nodes suffered a failed upgrade. It would be far better, in this kind of environment, to fail early on and leave at least some hosts in the cluster untouched until someone can intervene and resolve the issue.</p>
<p>For our <a id="_idIndexMarker548"/>practical example, let’s consider an expanded inventory with 10 hosts in it. We’ll define this as follows:</p>
<pre class="source-code">
[frontends]
frt[01:10].example.com</pre> <p>Now, let’s create a simple playbook to run on these hosts. We will set our batch size to <code>5</code> and <code>max_fail_percentage</code> to <code>50%</code> in the play definition:</p>
<ol>
<li>Create the following play definition to demonstrate the use of the <code>max_fail_percentage</code> directive:<pre class="source-code">
---
- name: A simple play to demonstrate use of max_fail_percentage
  hosts: frontends
  gather_facts: no
  serial: 5
  max_fail_percentage: 50</pre></li> </ol>
<p>We have defined 10 hosts in our inventory, so it will process them in batches of 5 (as specified by <code>serial: 5</code>). The play will be aborted, and processing will stop if more than 50% of the hosts in one batch fail.</p>
<p class="callout-heading">Note</p>
<p class="callout">The percentage of failed hosts must exceed the value of <code>max_fail_percentage</code>; if it is equal, the play continues.</p>
<ol>
<li value="2">Next, we will define two simple tasks. The first task has a special clause under it that we use to deliberately simulate a failure—this line starts with <code>failed_when</code> and we use it to tell the task that if it runs this task on the first three hosts in the batch, then it should deliberately fail this task, regardless of the result; otherwise, it should allow the task to run as normal:<pre class="source-code">
tasks:
- name: A task that will sometimes fail
  debug:
    msg: This might fail
  failed_when: inventory_hostname in ansible_play_batch[0:3]</pre></li> <li>Finally, we <a id="_idIndexMarker549"/>will add a second task that will always succeed. This is run if the play is allowed to continue, but not if it is aborted:<pre class="source-code">
- name: A task that will succeed
  debug:
    msg: Success!</pre></li> </ol>
<p>So, we have deliberately constructed a playbook that will run on a 10-host inventory in batches of 5 hosts at a time, but the play is aborted if more than 50% of the hosts in any given batch experience a failure. We have also deliberately set up a failure condition that causes 3 of the hosts in the first batch of 5 (60%) to fail.</p>
<ol>
<li value="4">Run the playbook and observe what happens:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i morehosts maxfail.yml</strong>
<strong class="bold">PLAY [A simple play to demonstrate use of max_fail_percentage] *****************</strong>
<strong class="bold">TASK [A task that will sometimes fail] *****************************************</strong>
<strong class="bold">fatal: [frt01.example.com]: FAILED! =&gt; {</strong>
<strong class="bold"> "msg": "This might fail"</strong>
<strong class="bold">}</strong>
<strong class="bold">fatal: [frt02.example.com]: FAILED! =&gt; {</strong>
<strong class="bold"> "msg": "This might fail"</strong>
<strong class="bold">}</strong>
<strong class="bold">fatal: [frt03.example.com]: FAILED! =&gt; {</strong>
<strong class="bold"> "msg": "This might fail"</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [frt04.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "This might fail"</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [frt05.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "This might fail"</strong>
<strong class="bold">}</strong>
<strong class="bold">NO MORE HOSTS LEFT *************************************************************</strong>
<strong class="bold">NO MORE HOSTS LEFT *************************************************************</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=0 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=0 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt03.example.com : ok=0 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt04.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt05.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Notice the results<a id="_idIndexMarker550"/> of this playbook. We deliberately failed three of the first batch of five, exceeding the threshold for <code>max_fail_percentage</code> that we set. This immediately causes the play to abort and the second task is not performed on the first batch of five. You will also notice that the second batch of 5, out of the 10 hosts, is never processed, so our play was truly aborted. This is exactly the behavior you would want to see to prevent a failed update from rolling out across a cluster. Through the careful use of batches and <code>max_fail_percentage</code>, you can safely run automated tasks across an entire cluster without the fear of breaking the entire cluster in the event of an issue. In the next section, we will take a look at another feature of Ansible that can be incredibly useful when it comes to working wi<a id="_idTextAnchor391"/>t<a id="_idTextAnchor392"/>h clusters—task delegation.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor393"/>Setting task execution delegation</h1>
<p>In every <a id="_idIndexMarker551"/>play we have run so far, we have assumed that all the tasks are executed on each host in the inventory in turn. However, what if you need to run one or two tasks on a different host? For example, we have talked about the concept of automating upgrades on clusters. Logically, however, we would want to automate the entire process, including the removal of each host in turn from the load balancer and their return after the task is completed.</p>
<p>Although we still want to run our play across our entire inventory, we certainly don’t want to run the load balancer commands from those hosts. Let’s once again explain this in more detail with a practical example. We’ll reuse the two simple host inventories that we used earlier in this chapter:</p>
<pre class="source-code">
[frontends]
frt01.example.com
frt02.example.com</pre> <p>Now, to work <a id="_idIndexMarker552"/>on this, let’s create two simple shell scripts in the same directory as our playbook. These are only examples, as setting up a load balancer is beyond the scope of this book. However, imagine that you have a shell script (or other executables) that you can call that can add and remove hosts to and from a load balancer:</p>
<ol>
<li>For our example, create a script called <code>remove_from_loadbalancer.sh</code>, which will contain the following:<pre class="source-code">
<strong class="bold">#!/bin/sh</strong>
<code>add_to_loadbalancer.sh</code>, which will contain the following:<pre class="source-code">
<strong class="bold">#!/bin/sh</strong>
<strong class="bold">echo Adding $1 to load balancer...</strong></pre></li> </ol>
<p>Obviously, in a real-world example, there would be much more code in these scripts!</p>
<ol>
<li value="3">Now, create a playbook that will perform the logic we outlined here. We will first create a quite simple play definition (you are free to experiment with the <code>serial</code> and <code>max_fail_percentage</code> directives as you wish) and an initial task:<pre class="source-code">
---
- name: Play to demonstrate task delegation
  hosts: frontends
  tasks:
    - name: Remove host from the load balancer
      command: ./remove_from_loadbalancer.sh {{ inventory_hostname }}
      args:
        chdir: "{{ playbook_dir }}"
      delegate_to: localhost</pre></li> </ol>
<p>Notice the<a id="_idIndexMarker553"/> task structure—most of it will be familiar to you. We are using the <code>command</code> module to call the script we created earlier, passing the hostname from the inventory being removed from the load balancer to the script. We use the <code>chdir</code> argument with the <code>playbook_dir</code> magic variable to tell Ansible that the script is to be run from the same directory as the playbook.</p>
<p>The special part of this task is the <code>delegate_to</code> directive, which tells Ansible that even though we’re iterating through an inventory that does not contain <code>localhost</code>, we should run this action on <code>localhost</code> (we are not copying the script to our remote hosts, so it will not run if we attempt to run it from there).</p>
<ol>
<li value="4">After this, we add a task where the upgrade work is carried out. This task has no <code>delegate_to</code> directive, so it is run on the remote host from the inventory (as desired):<pre class="source-code">
- name: Deploy code to host
  debug:
    msg: Deployment code would go here....</pre></li> <li>Finally, we add the host back to the load balancer using the second script we created earlier. This task is almost identical to the first:<pre class="source-code">
- name: Add host back to the load balancer
  command: ./add_to_loadbalancer.sh {{ inventory_hostname }}
  args:
    chdir: "{{ playbook_dir }}"
  delegate_to: localhost</pre></li> <li>See this<a id="_idIndexMarker554"/> playbook in action:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts delegate.yml</strong>
<strong class="bold">PLAY [Play to demonstrate task delegation] *************************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">TASK [Remove host from the load balancer] **************************************</strong>
<strong class="bold">changed: [frt02.example.com -&gt; localhost]</strong>
<strong class="bold">changed: [frt01.example.com -&gt; localhost]</strong>
<strong class="bold">TASK [Deploy code to host] *****************************************************</strong>
<strong class="bold">ok: [frt01.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Deployment code would go here...."</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [frt02.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Deployment code would go here...."</strong>
<strong class="bold">}</strong>
<strong class="bold">TASK [Add host back to the load balancer] **************************************</strong>
<strong class="bold">changed: [frt01.example.com -&gt; localhost]</strong>
<strong class="bold">changed: [frt02.example.com -&gt; localhost]</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=4 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=4 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Notice how<a id="_idIndexMarker555"/> even though Ansible is working through the inventory (which doesn’t feature <code>localhost</code>), the load balancer-related scripts are actually run from <code>localhost</code>, while the upgrade task is performed directly on the remote host. This, of course, isn’t the only thing you can do with task delegation, but it’s a common example of a way that it can help you.</p>
<p>In truth, you can delegate any task to <code>localhost</code>, or even another non-inventory host. You could, for example, run an <code>rsync</code> command delegated to <code>localhost</code> to copy files to remote hosts using a similar task definition to the previous one. Also, note that you can choose to use a form of shorthand notation in your playbooks (and roles) for <code>delegate_to</code>, called <code>local_action</code>. This allows you to specify a task on a single line that would ordinarily be run with <code>delegate_to: localhost</code> added below it. Wrapping this all up into a second example, our playbook will look as follows:</p>
<pre class="source-code">
---
- name: Second task delegation example
  hosts: frontends
  tasks:
  - name: Perform an rsync from localhost to inventory hosts
    local_action: command rsync -a /tmp/ {{ inventory_hostname }}:/tmp/target/</pre> <p>The <a id="_idIndexMarker556"/>preceding shorthand notation is equivalent to the following:</p>
<pre class="source-code">
tasks:
- name: Perform an rsync from localhost to inventory hosts
  command: rsync -a /tmp/ {{ inventory_hostname }}:/tmp/target/
  delegate_to: localhost</pre> <p>If we run this playbook, we can see that <code>local_action</code> simply runs a module on the machine running Ansible (which is often <code>localhost</code>, but not necessarily always), enabling us to efficiently copy whole directory trees across to remote servers in the inventory:</p>
<pre class="console">
$ ansible-playbook -i hosts delegate2.yml
PLAY [Second task delegation example] ******************************************
TASK [Gathering Facts] *********************************************************
ok: [frt02.example.com]
ok: [frt01.example.com]
TASK [Perform a rsync from localhost to inventory hosts] **********************
changed: [frt02.example.com -&gt; localhost]
changed: [frt01.example.com -&gt; localhost]
PLAY RECAP *********************************************************************
frt01.example.com: ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt02.example.com: ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>This concludes <a id="_idIndexMarker557"/>our look at task delegation; although, as stated, these are just two common examples. I’m sure you can think up some more advanced use cases for this capability. Let’s continue looking at controlling the flow of Ansible code by proceeding, in the next section, to l<a id="_idTextAnchor394"/>o<a id="_idTextAnchor395"/>ok at the special <code>run_once</code> option.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor396"/>Using the run_once option</h1>
<p>When <a id="_idIndexMarker558"/>working with clusters, you will sometimes encounter a task that should only be executed once for the entire cluster. For example, you might want to upgrade the schema of a clustered database or issue a command to reconfigure a Pacemaker cluster, which would typically be issued on one node and then automatically propagated to all other nodes by the cluster management software. You could, of course, address this with a special inventory with only one host in it, or even by writing a special play that references one host from the inventory, but this is inefficient and starts to make your code fragmented.</p>
<p>Instead, you can write your code as you normally would but make use of the special <code>run_once</code> directive for any tasks you want to run only once on your inventory. For example, let’s reuse the 10-host inventory that we defined earlier in this chapter. Now, let’s proceed to demonstrate this option, as follows:</p>
<ol>
<li>Create the <a id="_idIndexMarker559"/>simple playbook as in the following code block. We are using a <code>debug</code> statement to display some output, but in real life, you would insert your script or command that performs your one-off cluster function here (for example, upgrading a database schema):<pre class="source-code">
---
- name: Play to demonstrate the run_once directive
  hosts: frontends
  tasks:
    - name: Upgrade database schema
      debug:
        msg: Upgrading database schema...
      run_once: true</pre></li> <li>Now, run this playbook and see what happens:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i morehosts runonce.yml</strong>
<strong class="bold">PLAY [Play to demonstrate the run_once directive] ******************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">ok: [frt05.example.com]</strong>
<strong class="bold">ok: [frt03.example.com]</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">ok: [frt04.example.com]</strong>
<strong class="bold">ok: [frt06.example.com]</strong>
<strong class="bold">ok: [frt08.example.com]</strong>
<strong class="bold">ok: [frt09.example.com]</strong>
<strong class="bold">ok: [frt07.example.com]</strong>
<strong class="bold">ok: [frt10.example.com]</strong>
<strong class="bold">TASK [Upgrade database schema] *************************************************</strong>
<strong class="bold">ok: [frt01.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Upgrading database schema..."</strong>
<strong class="bold">}</strong>
<strong class="bold">---</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt03.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt04.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt05.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt06.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt07.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt08.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt09.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt10.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Notice that, just as desired, although the playbook was run on all 10 hosts (and, indeed, gathered facts from all 10 hosts), Ansible only ran the upgrade task on one host.</p>
<ol>
<li value="3">It is <a id="_idIndexMarker560"/>important to note that the <code>run_once</code> option applies per batch of servers, so if we add <code>serial: 5</code> to our play definition (running our play in 2 batches of 5 on our inventory of 10 servers), the schema upgrade task runs twice! It runs once as requested, but once per batch of servers, not once for the entire inventory. Be careful of this nuance when working with this directive in a clustered environment.</li>
</ol>
<p>Add <code>serial: 5</code> to your play definition and rerun the playbook. The output should appear as follows:</p>
<pre class="source-code">
<strong class="bold">$ ansible-playbook -i morehosts runonce.yml</strong>
<strong class="bold">PLAY [Play to demonstrate the run_once directive] ******************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt04.example.com]</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">ok: [frt03.example.com]</strong>
<strong class="bold">ok: [frt05.example.com]</strong>
<strong class="bold">TASK [Upgrade database schema] *************************************************</strong>
<strong class="bold">ok: [frt01.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Upgrading database schema..."</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY [Play to demonstrate the run_once directive] ******************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt08.example.com]</strong>
<strong class="bold">ok: [frt06.example.com]</strong>
<strong class="bold">ok: [frt07.example.com]</strong>
<strong class="bold">ok: [frt10.example.com]</strong>
<strong class="bold">ok: [frt09.example.com]</strong>
<strong class="bold">TASK [Upgrade database schema] *************************************************</strong>
<strong class="bold">ok: [frt06.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Upgrading database schema..."</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt03.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt04.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt05.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt06.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt07.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt08.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt09.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<code>run_once</code> option is designed to work—you can observe, in the preceding output, that <a id="_idIndexMarker561"/>our schema upgrade ran twice, which is probably not something we wanted! However, with this awareness, you should be able to take advantage of this option to control your playbook flow across clusters and still achieve the results you want. Let’s now move away from cluster-related Ansible tasks and look at the subtle but important difference between running playbooks<a id="_idTextAnchor397"/> <a id="_idTextAnchor398"/>locally and running them on <code>localhost</code>.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor399"/>Running playbooks locally</h1>
<p>It is important to <a id="_idIndexMarker562"/>note that when we talk about running a playbook locally with Ansible, it is not the same as talking about running it on <code>localhost</code>. If we run a playbook on <code>localhost</code>, Ansible actually sets up an SSH connection to <code>localhost</code> (it doesn’t differentiate its behavior or attempt to detect whether a host in the inventory is local or remote—it simply tries faithfully to connect).</p>
<p>Indeed, we can try creating a <code>local</code> inventory file with the following contents:</p>
<pre class="source-code">
[local]
localhost</pre> <p>Now, if we attempt to run the <code>ping</code> module in an ad hoc command against this inventory, we see the following:</p>
<pre class="console">
$ ansible -i localhosts -m ping all --ask-pass
The authenticity of host 'localhost (::1)' can't be established.
ECDSA key fingerprint is SHA256:DUwVxH+45432pSr9qsN8Av4l0KJJ+r5jTo123n3XGvZs.
ECDSA key fingerprint is MD5:78:d1:dc:23:cc:28:51:42:eb:fb:58:49:ab:92:b6:96.
Are you sure you want to continue connecting (yes/no)? yes
SSH password:
localhost | SUCCESS =&gt; {
 "ansible_facts": {
 "discovered_interpreter_python": "/usr/bin/python"
 },
 "changed": false,
 "ping": "pong"
}</pre> <p>As you can<a id="_idIndexMarker563"/> see, Ansible set up an SSH connection that needed the host key to validate, as well as our SSH password. Now, although you could add the host key (as we did in the preceding code block), add key-based SSH authentication to your <code>localhost</code>, and so on, there is a more direct way of doing this.</p>
<p>We can now modify our inventory so that it looks as follows:</p>
<pre class="source-code">
[local]
localhost ansible_connection=local</pre> <p>We’ve added a special variable to our <code>localhost</code> entry—the <code>ansible_connection</code> variable—which defines which protocol is used to connect to this inventory host. So, we have told it to use a direct local connection instead of SSH-based connectivity (which is the default).</p>
<p>It should be noted that <code>ansible_connection</code> specifies the type of communication, such as <code>local</code>/<code>ssh</code>/<code>etc</code>. So, if we change our inventory to look as follows, Ansible will not even attempt to connect to the remote host called <code>frt01.example.com</code>—it will connect locally to the machine running the playbook (without SSH):</p>
<pre class="source-code">
[local]
frt01.example.com ansible_connection=local</pre> <p>We can demonstrate this very simply. Let’s first check for the absence of a test file in our local <code>/</code><code>tmp</code> directory:</p>
<pre class="console">
ls -l /tmp/foo
ls: cannot access /tmp/foo: No such file or directory</pre> <p>Now, let’s run an ad hoc command to touch this file on all hosts in the new inventory we just defined:</p>
<pre class="console">
$ ansible -i localhosts2 -m file -a "path=/tmp/foo state=touch" all
frt01.example.com | CHANGED =&gt; {
 "ansible_facts": {
 "discovered_interpreter_python": "/usr/bin/python"
 },
 "changed": true,
 "dest": "/tmp/foo",
 "gid": 0,
 "group": "root",
 "mode": "0644",
 "owner": "root",
 "size": 0,
 "state": "file",
 "uid": 0
}</pre> <p>The <a id="_idIndexMarker564"/>command ran successfully, so let’s see whether the test file is present on the local machine:</p>
<pre class="console">
$ ls -l /tmp/foo
-rw-r--r-- 1 root root 0 Apr 24 16:28 /tmp/foo</pre> <p>It is! So, the ad hoc command did not attempt to connect to <code>frt01.example.com</code>, even though this hostname was in the inventory. The presence of <code>ansible_connection=local</code> meant that this command was run on the local machine without using SSH.</p>
<p>This ability to run commands locally without the need to set up SSH connectivity, SSH keys, and so on can be incredibly valuable, especially if you need to get things up and running quickly on your local machine. With this complete, let’s take a look at how you can work <a id="_idTextAnchor400"/>w<a id="_idTextAnchor401"/>ith proxies and jump hosts using Ansible.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor402"/>Working with proxies and jump hosts</h1>
<p>Often, when<a id="_idIndexMarker565"/> it comes to configuring core network devices, these are isolated from the main network via a proxy or jump host. Ansible lends itself well to automating network device configuration as most of it is performed over SSH; however, this is only <a id="_idIndexMarker566"/>helpful in a scenario where Ansible can either be installed and operated from the jump host or, better yet, can operate via a host such as this.</p>
<p>Fortunately, Ansible can do exactly that. Let’s assume that you have two Cumulus Networks switches in your network (these are based on a special distribution of Linux for switching hardware, which is very similar to Debian). These two switches have the <code>cmls01.example.com</code> and <code>cmls02.example.com</code> hostnames, but both can only be accessed from a host called <code>bastion.example.com</code>.</p>
<p>The configuration to support our <code>bastion</code> host is performed in the inventory, rather than in the playbook. We begin by defining an inventory group with the switches in, in the normal manner:</p>
<pre class="source-code">
[switches]
cmls01.example.com
cmls02.example.com</pre> <p>However, we can now start to get clever by adding some special SSH arguments into the inventory variables for this group. Add the following code to your inventory file:</p>
<pre class="source-code">
[switches:vars]
ansible_ssh_common_args='-o ProxyCommand="ssh -W %h:%p -q bastion.example.com"'</pre> <p>This special variable content tells Ansible to add extra options when it sets up an SSH connection, including to proxy via the <code>bastion.example.com</code> host. The <code>-W %h:%p</code> options tell SSH to proxy the connection and to connect to the host specified by <code>%h</code> (this is either <code>cmls01.example.com</code> or <code>cmls02.example.com</code>) on the port specified by <code>%p</code> (usually port <code>22</code>).</p>
<p>Now, if we attempt to run the Ansible <code>ping</code> module against this inventory, we can see whether it works:</p>
<pre class="console">
$ ansible -i switches -m ping all
cmls02.example.com | SUCCESS =&gt; {
 "ansible_facts": {
 "discovered_interpreter_python": "/usr/bin/python"
 },
 "changed": false,
cmls01.example.com | SUCCESS =&gt; {
 "ansible_facts": {
 "discovered_interpreter_python": "/usr/bin/python"
 },
 "changed": false,
 "ping": "pong"
}</pre> <p>You will<a id="_idIndexMarker567"/> notice <a id="_idIndexMarker568"/>that we can’t actually see any differences in Ansible’s behavior from the command-line output. On the surface, Ansible works just as it normally does and connects successfully to the two hosts. However, behind the scenes, it proxies via <code>bastion.example.com</code>.</p>
<p>Note that this simple example assumes that you are connecting to both the <code>bastion</code> host and switches using the same username and SSH credentials (or in this case, keys). There are ways to provide separate credentials for both variables, but this involves more advanced usage of OpenSSH, which is beyond the scope of this book. However, this section intends to give you a starting point and demonstrate the possibility of this, and you are free to explore OpenSSH proxying by yourself.</p>
<p>Let’s now change track and explore how it is possible to set up Ansible <a id="_idTextAnchor403"/>t<a id="_idTextAnchor404"/>o prompt you for data during a playbook run.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor405"/>Configuring playbook prompts</h1>
<p>So far, all <a id="_idIndexMarker569"/>of our playbooks have had their data specified for them at runtime in variables we defined within the playbook. However, what if you actually want to obtain information from someone during a playbook run? Perhaps you want a user to select a version of a package to install? Or, perhaps you want to obtain a password from a user for an authentication task without storing it anywhere. (Although Ansible Vault can encrypt the data at rest, some companies may forbid the storing of passwords and other such credentials in tools that they have not evaluated.) Fortunately, for these instances (and many more), Ansible can prompt you for user input and store the input in a variable for future processing.</p>
<p>Let’s reuse the two host frontend inventories we defined at the beginning of this chapter. Now, let’s demonstrate how to capture data from users during a playbook run with a practical example:</p>
<ol>
<li>Create a simple play definition in the usual manner, as follows:<pre class="source-code">
---
- name: A simple play to demonstrate prompting in a playbook
  hosts: frontends</pre></li> <li>Now, we will add a special section to the play definition. We previously defined a <code>vars</code> section, but this time, we will define one called <code>vars_prompt</code> (which enables you to do just that—define variables through user prompts). In this section, we will prompt for two variables—one for a user ID and one for a password. One will be echoed to the screen, while the other will not be, by setting <code>private: yes</code>:<pre class="source-code">
vars_prompt:
  - name: loginid
    prompt: "Enter your username"
    private: no
  - name: password
    prompt: "Enter your password"
    private: yes</pre></li> <li>We will now add a single task to our playbook to demonstrate this prompting process of setting the variables:<pre class="source-code">
tasks:
- name: Proceed with login
  debug:
    msg: "Logging in as {{ loginid }}..."</pre></li> <li>Now, run <a id="_idIndexMarker570"/>the playbook and see how it behaves:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts prompt.yml</strong>
<strong class="bold">Enter your username: james</strong>
<strong class="bold">Enter your password:</strong>
<strong class="bold">PLAY [A simple play to demonstrate prompting in a playbook] ********************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">TASK [Proceed with login] ******************************************************</strong>
<strong class="bold">ok: [frt01.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Logging in as james..."</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [frt02.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Logging in as james..."</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>As you can see, we <a id="_idIndexMarker571"/>are prompted for both variables, yet the password is not echoed to the terminal, which is important for security reasons. We can then make use of the variables later in the playbook. Here, we just used a simple <code>debug</code> command to demonstrate that the variables have been set; however, you would instead implement an actual authentication function in place of this.</p>
<p>With this complete, let’s proceed to the next section and look at how you can selectively run your t<a id="_idTextAnchor406"/>a<a id="_idTextAnchor407"/>sks from within your plays with the use of tags.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor408"/>Placing tags in the plays and tasks</h1>
<p>We have discussed, at <a id="_idIndexMarker572"/>many points in this book, that as your confidence and experience with Ansible grows, it is likely that your playbooks will grow, both in scale and complexity. While this is undoubtedly a good thing, there may be times when you only want to run a subset of a playbook, rather than running it from beginning to end. We discussed how to conditionally run tasks based on the value of a variable or fact, but is there a way we can run them based on a selection made when the playbook is run?</p>
<p>Tags in <a id="_idIndexMarker573"/>Ansible plays are the solution to this, and in this section, we will build a simple playbook with two tasks—each bearing a different tag—to show you how tags work. We will work with the<a id="_idIndexMarker574"/> two simple host inventories that we worked with previously:</p>
<ol>
<li>Create the following simple playbook to perform two tasks—one to install the <code>nginx</code> package and the other to deploy a configuration file from a template:<pre class="source-code">
---
- name: Simple play to demonstrate use of tags
  hosts: frontends
  tasks:
    - name: Install nginx
      yum:
        name: nginx
        state: present
      tags:
        - install
    - name: Install nginx configuration from template
      template:
        src: templates/nginx.conf.j2
        dest: /etc/nginx.conf
      tags:
        - customize</pre></li> <li>Now, run the playbook in the usual manner, but with one difference—this time, we will add the <code>--tags</code> switch to the command line. This switch tells Ansible to only run the tasks that have tags matching the ones that are specified. So, for example, run the following command:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts tags.yml --tags install</strong>
<strong class="bold">PLAY [Simple play to demonstrate use of tags] **********************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">TASK [Install nginx] ***********************************************************</strong>
<strong class="bold">changed: [frt02.example.com]</strong>
<strong class="bold">changed: [frt01.example.com]</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Notice<a id="_idIndexMarker575"/> that the task to deploy the configuration file does not run. This is because it is tagged with <code>customize</code> and we did not specify this tag when running the playbook.</p>
<ol>
<li value="3">There is also a <code>--skip-tags</code> switch that does the reverse of the previous switch—it tells Ansible to skip the tags listed. So, if we run the playbook again but skip <a id="_idIndexMarker576"/>the <code>customize</code> tag, we should see an output like the following:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts tags.yml --skip-tags customize</strong>
<strong class="bold">PLAY [Simple play to demonstrate use of tags] **********************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">TASK [Install nginx] ***********************************************************</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>This play run is identical because, rather than including only the <code>install</code>-tagged tasks, we skipped the tasks tagged with <code>customize</code>.</p>
<p>Note that if you do not specify either <code>--tags</code> or <code>--skip-tags</code>, then all the tasks are run, regardless of their tag.</p>
<p>A few notes about tags. First of all, each task can have more than one tag, so we see them specified in a YAML list format. If you use the <code>--tags</code> switch, a task will run if any of its tags match the tag that was specified on the command line. Secondly, tags can be reused, so we could have five tasks that are all tagged <code>install</code>, and all five tasks would be performed or skipped if you requested them to do so via <code>--tags</code> or <code>--</code><code>skip-tags</code>, respectively.</p>
<p>You can also <a id="_idIndexMarker577"/>specify more than one tag on the command line, running all the tasks that match any of the specified tags. Although the logic behind tags is relatively simple, it can take a little while to get used to it, and the last thing you want to do is run your playbook on real hosts to check whether you understand tagging! A great way to figure this out is to add <code>--list-tasks</code> to your command, which, rather than running the playbook, lists the tasks from the playbook that would perform if you run it. Some examples are provided for you in the following code block, based on the example playbook we just created:</p>
<pre class="console">
$ ansible-playbook -i hosts tags.yml --skip-tags customize --list-tasks
playbook: tags.yml
 play #1 (frontends): Simple play to demonstrate use of tags TAGS: []
 tasks:
 Install nginx TAGS: [install]
$ ansible-playbook -i hosts tags.yml --tags install,customize --list-tasks
playbook: tags.yml
 play #1 (frontends): Simple play to demonstrate use of tags TAGS: []
 tasks:
 Install nginx TAGS: [install]
 Install nginx configuration from template TAGS: [customize]
$ ansible-playbook -i hosts tags.yml --list-tasks
playbook: tags.yml
 play #1 (frontends): Simple play to demonstrate use of tags TAGS: []
 tasks:
 Install nginx TAGS: [install]
 Install nginx configuration from template TAGS: [customize]</pre> <p>As you can <a id="_idIndexMarker578"/>see, not only does <code>--list-tasks</code> show you which tasks would run but it also shows you which tags are associated with them, which helps you further understand how tagging works and ensure that you achieve the playbook flow that you wanted. Tags are an incredibly simple yet powerful way to control which parts of your playbook run and, often, when it comes to creating and maintaining large playbooks, it is better to be able to run only selected parts of the playbook at once. From here, we will move on to the final section of this chapter, where we will look at securing your va<a id="_idTextAnchor409"/>r<a id="_idTextAnchor410"/>iable data at rest by encrypting it with Ansible Vault.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor411"/>Securing data with Ansible Vault</h1>
<p>Ansible Vault is<a id="_idIndexMarker579"/> a tool included with Ansible that allows you to encrypt your sensitive data at rest, while also using it in a playbook. Often, it is necessary to <a id="_idIndexMarker580"/>store login credentials or other sensitive data in a variable to allow a playbook to run unattended. However, this risks exposing your data to people who might use it with malicious intent. Fortunately, Ansible Vault secures your data at rest using AES-256 encryption, meaning your sensitive data is safe from prying eyes.</p>
<p>Let’s proceed <a id="_idIndexMarker581"/>with a simple example that shows you how you can use Ansible Vault:</p>
<ol>
<li>Start by creating a new vault to store sensitive data in; we will call this file <code>secret.yml</code>. You can create this using the following command:<pre class="source-code">
<strong class="bold">$ ansible-vault create secret.yml</strong>
<strong class="bold">New Vault password:</strong>
<strong class="bold">Confirm New Vault password:</strong></pre></li> </ol>
<p>Enter the password you have chosen for the vault when prompted and confirm it by entering it a second time (the vault that accompanies this book on GitHub is encrypted with the <code>secure</code> password).</p>
<ol>
<li value="2">When you have entered the password, you will be sent to your normal editor (defined by the <code>EDITOR</code> shell variable). On my test system, this is <code>vi</code>. Within this editor, you should create a <code>vars</code> file, in the normal manner, containing your sensitive data:<pre class="source-code">
---
secretdata: "Ansible is cool!"</pre></li> <li>Save and exit the editor (press <em class="italic">Esc</em>, then <code>:wq</code> in <code>vi</code>). You will exit the shell. Now, if you look at the contents of your file, you will see that they are encrypted and are safe from anyone who should not be able to read the file:<pre class="source-code">
<strong class="bold">$ cat secret.yml</strong>
<strong class="bold">$ANSIBLE_VAULT;1.1;AES256</strong>
<strong class="bold">63333734623764633865633237333166333634353334373862346334643631303163653931306138</strong>
<strong class="bold">6334356465396463643936323163323132373836336461370a343236386266313331653964326334</strong>
<strong class="bold">62363737663165336539633262366636383364343663396335643635623463626336643732613830</strong>
<strong class="bold">6139363035373736370a646661396464386364653935636366633663623261633538626230616630</strong>
<strong class="bold">35346465346430636463323838613037386636333334356265623964633763333532366561323266</strong>
<code>variables</code> file (although, obviously, you must tell Ansible your vault password). Create a simple playbook as follows:<pre class="source-code">
---
- name: A play that makes use of an Ansible Vault
hosts: frontends
vars_files:
- secret.yml
tasks:
- name: Tell me a secret
debug:
msg: "Your secret data is: {{ secretdata }}"</pre></li> </ol>
<p>The <code>vars_files</code> directive is used in the same way as it would be if you were using an unencrypted <code>variables</code> file. Ansible reads the headers of the <code>variables</code> files at runtime and determines whether they are encrypted or not.</p>
<ol>
<li value="5">Try running the<a id="_idIndexMarker584"/> playbook without telling Ansible what the vault password is—in this instance, you should receive an error such as this:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts vaultplaybook.yml</strong>
<code>variables</code> file that is encrypted with <code>ansible-vault</code>, but we must manually tell it about the password for it to proceed. There are several ways of specifying passwords for vaults (more on this in a minute), but for simplicity, try running the following command and enter your vault password when prompted:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts vaultplaybook.yml --ask-vault-pass</strong>
<strong class="bold">Vault password:</strong>
<strong class="bold">PLAY [A play that makes use of an Ansible Vault] *******************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [frt01.example.com]</strong>
<strong class="bold">ok: [frt02.example.com]</strong>
<strong class="bold">TASK [Tell me a secret] ********************************************************</strong>
<strong class="bold">ok: [frt01.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Your secret data is: Ansible is cool!"</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [frt02.example.com] =&gt; {</strong>
<strong class="bold"> "msg": "Your secret data is: Ansible is cool!"</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Success! Ansible <a id="_idIndexMarker586"/>decrypted our vault file and loaded the<a id="_idIndexMarker587"/> variables into the playbook, which we can see from the <code>debug</code> statement we created. This is a very simple example of what you can do with vaults. There are multiple ways that you can specify passwords; you don’t have to be prompted for them on the command line—they can be provided either by a plain text file that contains the vault password or via a script that could obtain the password from a secure location at runtime (think of a dynamic inventory script, only for returning a password rather than a hostname). The <code>ansible-vault</code> tool itself can also be used to edit, view, and change the passwords in a vault file, or even decrypt it and turn it back into plain text. The <a id="_idIndexMarker588"/>user guide for Ansible Vault is a great place to start for more information (<a href="https://docs.ansible.com/ansible/latest/user_guide/vault.xhtml">https://docs.ansible.com/ansible/latest/user_guide/vault.xhtml</a>).</p>
<p>One thing to note is that you don’t actually have to have a separate vault file for your sensitive data; you can include it inline in your playbook. For example, let’s try re-encrypting our sensitive data for inclusion in an otherwise unencrypted playbook (again, use the <code>secure</code> password for the vault if you are testing the examples from the GitHub repository accompanying this book). Run the following command in your shell (it should produce an output similar to what is shown):</p>
<pre class="console">
$ ansible-vault encrypt_string 'Ansible is cool!' --name secretdata
New Vault password:
Confirm New Vault password:
secretdata: !vault |
 $ANSIBLE_VAULT;1.1;AES256
 34393431303339353735656236656130336664666337363732376262343837663738393465623930
 3366623061306364643966666565316235313136633264310a623736643362663035373861343435
 62346264313638656363323835323833633264636561366339326332356430383734653030306637
 3736336533656230380a316364313831666463643534633530393337346164356634613065396434
 33316338336266636666353334643865363830346566666331303763643564323065
Encryption successful</pre> <p>You can<a id="_idIndexMarker589"/> copy and<a id="_idIndexMarker590"/> paste the output of this command into a playbook. So, if we modify our earlier example, it would appear as follows:</p>
<pre class="source-code">
---
- name: A play that makes use of an Ansible Vault
  hosts: frontends
  vars:
    secretdata: !vault |
        $ANSIBLE_VAULT;1.1;AES256
        34393431303339353735656236656130336664666337363732376262343837 663738393465623930
        3366623061306364643966666565316235313136633264310a623736643362 663035373861343435
        62346264313638656363323835323833633264636561366339326332356430 383734653030306637
        3736336533656230380a316364313831666463643534633530393337346164 356634613065396434
        33316338336266636666353334643865363830346566666331303763643564 323065
  tasks:
    - name: Tell me a secret
      debug:
        msg: "Your secret data is: {{ secretdata }}"</pre> <p>Now, when <a id="_idIndexMarker591"/>you run this playbook in exactly the same manner <a id="_idIndexMarker592"/>as we did before (specifying the vault password using a user prompt), you should see that it runs just as when we used an external encrypted <code>variables</code> file:</p>
<pre class="console">
$ ansible-playbook -i hosts inlinevaultplaybook.yml --ask-vault-pass
Vault password:
PLAY [A play that makes use of an Ansible Vault] *******************************
TASK [Gathering Facts] *********************************************************
ok: [frt02.example.com]
ok: [frt01.example.com]
TASK [Tell me a secret] ********************************************************
ok: [frt01.example.com] =&gt; {
 "msg": "Your secret data is: Ansible is cool!"
}
ok: [frt02.example.com] =&gt; {
 "msg": "Your secret data is: Ansible is cool!"
}
PLAY RECAP *********************************************************************
frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>Ansible Vault is a powerful and versatile tool for encrypting your sensitive playbook data at rest and should enable you (with a little care) to run most <a id="_idIndexMarker593"/>of your playbooks unattended without ever leaving passwords or other sensitive data in the clear. If you add multiple encrypted files in your <code>group_vars</code> directory, all files need to contain the same password. That conclude<a id="_idTextAnchor413"/>s<a id="_idTextAnchor414"/> this section and this chapter; I hope<a id="_idIndexMarker594"/> that it has been useful to you.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor415"/>Summary</h1>
<p>Ansible has many advanced features that allow you to run your playbooks in a variety of scenarios, whether that is upgrading a cluster of servers in a controlled manner; working with devices on a secure, isolated network; or controlling your playbook flow with prompts and tags. Ansible has been adopted by a large and ever-growing user base and, as such, is designed and evolved around solving real-world problems. Most of the advanced features of Ansible we discussed are centered around exactly this—solving real-world problems.</p>
<p>In this chapter, you learned about running tasks asynchronously in Ansible, before looking at the various features available for running playbooks to upgrade a cluster, such as running tasks on small batches of inventory hosts, failing a play early if a certain percentage of hosts fail, delegating tasks to a specific host, and even running tasks once, regardless of your inventory (or batch) size. You also learned about the difference between running playbooks locally as opposed to on <code>localhost</code> and how to use SSH-proxying to automate tasks on an isolated network via a <code>bastion</code> host. Finally, you learned about handling sensitive data without storing it unencrypted at rest, either through prompting the user at runtime or through the use of Ansible Vault. You even learned about running a subset of your playbook tasks with tagging.</p>
<p>In the next chapter, we will explore a topic we touched on briefly in this c<a id="_idTextAnchor416"/>h<a id="_idTextAnchor417"/>apter in more detail—automating network device management with Ansible.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor418"/>Questions</h1>
<ol>
<li>Which parameter allows you to configure the maximum number of hosts in a batch that will fail before a play is aborted?<ol><li><code>percentage</code></li><li><code>max_fail</code></li><li><code>max_fail_percentage</code></li><li><code>max_percentage</code></li><li><code>fail_percentage</code></li></ol></li>
<li>True or false? You can use the <code>--ask-vault-pass</code> parameter to use the vault to keep sensitive data at rest:<ol><li>True</li><li>False</li></ol></li>
<li>True or false? To run a<a id="_idTextAnchor419"/><a id="_idTextAnchor420"/> playbook asynchronously, you need to use the <code>async</code> keyword:<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-143"><a id="_idTextAnchor421"/>Further reading</h1>
<p>If you install Passlib, which is a password-hashing library for Python 3, <code>vars_prompt</code> is encrypted with any crypt scheme (such as <code>descrypt</code>, <code>md5crypt</code>, <code>sha56_crypt</code>, and more). You can learn more about this here:</p>
<p><a href="https://passlib.readthedocs.io/en/stable/">https://passlib.readthedocs.io/en/stable/</a></p>
</div>
</div>

<div><div><h1 id="_idParaDest-144" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor422"/>Part 3:Using Ansible in an Enterprise</h1>
<p>In this section, we will take a practical look at how to get the most out of Ansible in an enterprise environment. We will start by looking at how to automate your network devices with Ansible, before moving on to the use of Ansible to manage both cloud and container environments. We will then look at some of the more advanced testing and troubleshooting strategies that will assist you in your use of Ansible in an enterprise, before looking at the Ansible Automation Controller/ <strong class="bold">Ansible Web eXecutable</strong> (<strong class="bold">AWX</strong>) product, which provides rich <strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>) and auditing capabilities in enterprise settings in a variety of execution environments. Finally, we will deep dive into execution environments.</p>
<p>This section contains the following chapters:</p>
<ul>
<li><a href="B20846_10.xhtml#_idTextAnchor423"><em class="italic">Chapter 10</em></a>, <em class="italic">Network Automation with Ansible</em></li>
<li><a href="B20846_11.xhtml#_idTextAnchor456"><em class="italic">Chapter 11</em></a>, <em class="italic">Container and Cloud Management</em></li>
<li><a href="B20846_12.xhtml#_idTextAnchor523"><em class="italic">Chapter 12</em></a>, <em class="italic">Troubleshooting and Testing Strategies</em></li>
<li><a href="B20846_13.xhtml#_idTextAnchor562"><em class="italic">Chapter 13</em></a>, <em class="italic">Getting Started with Ansible Automation Controller</em></li>
<li><a href="B20846_14.xhtml#_idTextAnchor592"><em class="italic">Chapter 14</em></a>, <em class="italic">Execution Environments</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>