<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Adding and Removing Users</h1></div></div></div><p>Git supports two remote transports for general use—the ssh transport and the HTTP transport. Of these, the ssh transport is much easier to set up, since most systems already have an ssh server package installed, configured, and ready to accept authenticated connections. This is generally not true for HTTP, and even if an HTTP server was available, you'd still have to configure it for Gitolite.</p><p>Therefore, we will explore adding and removing users for a server using the ssh transport. Some of the earlier chapters have already shown you the basics of how to add a user. It is now time to dig a little deeper into this and explore a few nuances and special cases.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Adding users</h1></div></div></div><p>Strictly <a id="id78" class="indexterm"/>speaking,<a id="id79" class="indexterm"/> Gitolite doesn't know where users come from. If you recall the section on authentication and authorization from the previous chapter, you learned that Gitolite does not even do authentication—it leaves it up to the ssh server (or perhaps the HTTP server). However, Gitolite does help with ssh-based authentication, since that is the most common use of Gitolite, and the server and its configuration are fairly standard and predictable, in most cases.</p><p>A word of warning: do <em>not</em> add new users manually on the server. Gitolite users, repositories, and access rules are maintained by making changes to a special repository called <code class="literal">gitolite-admin</code> and pushing those changes to the server, as explained in <a class="link" href="ch02.html" title="Chapter 2. Installing Gitolite">Chapter 2</a>, <em>Installing Gitolite</em>. Thus, almost everything you do will be within a clone of the <code class="literal">gitolite-admin</code> repository.</p><p>To add a user, say Alice, obtain her public key (typically <code class="literal">$HOME/.ssh/id_rsa.pub</code> on her workstation). Then copy it to the directory called <code class="literal">keydir</code> (in your clone of the <code class="literal">gitolite-admin</code> repository), with the username as the basename (for example, <code class="literal">alice.pub</code> for user alice). Finally, add the key using git add <code class="literal">keydir/alice.pub</code>, then commit and push.</p><p>Here are some additional points to note in order to do this correctly:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All public key files must have names ending in <code class="literal">.pub</code>, and must be in openssh's default format.</li><li class="listitem" style="list-style-type: disc">Usernames <a id="id80" class="indexterm"/>must start with an alpha-numeric character, and can then contain alpha-numerics, hyphens, underscores, periods, and the @ sign. Examples of valid usernames are <code class="literal">sitaram</code>, <code class="literal">sitaram.chamarty</code>, <code class="literal">sitaramc@gmail.com</code>, and so on.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Behind the scenes</h2></div></div></div><p>Here's how Gitolite <a id="id81" class="indexterm"/>on the server processes users and keys. These actions are initiated from within a post-update hook for the <code class="literal">gitolite-admin</code> repository that Gitolite installs.</p><div><ol class="orderedlist arabic"><li class="listitem">Gitolite reads the authorized keys file <code class="literal">($HOME/.ssh/authorized_keys</code>), and makes a note of all the non-Gitolite keys (that is, keys that did not come from Gitolite).</li><li class="listitem">It then reads all the public keys in the <code class="literal">keydir</code> directory of the gitolite-admin repository. This is recursive; you can have keys in subdirectories to any level.</li><li class="listitem">As it reads each public key, it compares it to each of the public keys it has processed so far, including the non-Gitolite keys. If there is a match, it prints a warning to the effect that the ssh server will be ignoring the second and subsequent occurrences of the key in the authorized keys file.</li><li class="listitem">It then adds <code class="literal">ssh</code> options to each public key line. The options added are <code class="literal">no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty</code>. These security options are generally recommended for any ssh server that is <em>not</em> meant to be serving interactive or shell users.</li><li class="listitem">The <code class="literal">command</code> option is added, pointing to the installed <code class="literal">gitolite-shell</code> location, along with an additional argument: the Gitolite username. The username is usually the basename of the public key file (that is, removing any directory prefixes, and the <code class="literal">.pub</code> suffix); see the section on <em>Users with multiple key pairs</em> later when this may not be quite true.</li></ol></div><p>If you recall from <em>Figure 1</em> in <a class="link" href="ch02.html" title="Chapter 2. Installing Gitolite">Chapter 2</a>, <em>Installing Gitolite</em> (reproduced below for convenience), this ensures that when the user accesses the server and offers the corresponding public key for authentication, his connection, after the ssh daemon has successfully authenticated him, will be passed onto the <code class="literal">gitolite-shell</code> program, with his Gitolite username as a command-line argument.</p><div><img src="img/2371OS_04_01.jpg" alt="Behind the scenes"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Users with multiple key pairs</h1></div></div></div><p>Some users have<a id="id82" class="indexterm"/> multiple key pairs. For instance, they use a laptop as well as a desktop at work. Some may have another machine at home, or work directly on a server.</p><p>You might <a id="id83" class="indexterm"/>think it's best to use the same key pair on each machine—after all, they all belong to the same user—but this is not a good idea. The risk of a private key compromise increases with the number of machines that it is installed on, and that would not be a good thing at all.</p><p>As a result, Gitolite allows a user to have multiple public keys. There are in fact two ways to associate multiple public key files to the same Gitolite user.</p><p>The first way is to use subdirectories. Here's an example tree structure of the gitolite-admin repository showing a set of keys in the <code class="literal">keydir</code> subdirectory:</p><div><img src="img/2371OS_04_02.jpg" alt="Users with multiple key pairs"/></div><p>As you can see, there are two files called <code class="literal">carol.pub</code>. Both of these will generate lines in the authorized<a id="id84" class="indexterm"/> keys file as described earlier, with the username set to <code class="literal">carol</code>. Whichever key she uses, Gitolite will see the authenticated Gitolite username as <code class="literal">carol</code>, and authorize her access accordingly.</p><p>The second <a id="id85" class="indexterm"/>way to allow multiple public keys is to use a location suffix. A location suffix is an <code class="literal">@</code> sign followed by a single word consisting of alphanumerics, hyphens, or underscores. For example, if Alice had one key for her laptop and one for her desktop, she might send you the keys as <code class="literal">alice@laptop.pub</code> and <code class="literal">alice@desktop.pub</code>.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>The location suffix must <em>not</em> contain a period; otherwise it looks like an e-mail address. As far as Gitolite is concerned, a public key file called <code class="literal">alice@laptop.pub</code> pertains to a user called alice, but a file called <code class="literal">alice@lap.top.pub</code> pertains to a user called <code class="literal">alice@lap.top</code>, which is a perfectly valid email address at least as far as syntax is concerned.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Giving some users a shell</h1></div></div></div><p>Some of your <a id="id86" class="indexterm"/>users may have a legitimate need to log on to the server as the hosting user and use a shell command line. If this is required for just one or two users, the simplest way to deal with this is to have them use two different keys—one for Gitolite access and one for shell access. The second key would be installed manually in the authorized keys file on the server, and would not have the <code class="literal">command</code> and other options that Gitolite keys have.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Non-Gitolite keys must be added right at the start of the authorized keys file, or at least before the marker line that says <code class="literal"># gitolite start</code>. Keys added in between Gitolite's start and end marker lines will be deleted the next time the <code class="literal">gitolite-admin</code> repository is pushed.</p></div></div><p>However, <a id="id87" class="indexterm"/>this requires careful handling of the second key on both the server side, as well as the client side. Some users may not be interested in learning how to handle multiple keys on their side, and how to present the correct key for each access.</p><p>There is another way to handle this problem, using a single key. Here's what you need to do in order to give any user shell access.</p><p>First, determine who is to get this access and make a list of those users. The username should be the bare username as used in the <code class="literal">gitolite.conf</code> file, for example, <code class="literal">alice</code> and <code class="literal">bob</code>. Do not use <code class="literal">alice.pub</code>, <code class="literal">alice@laptop.pub</code>, or any such variants.</p><p>Next, add all these names to a simple file called <code class="literal">$HOME/.gitolite.shell-users</code> on the server. Put just one name on each line, without any extra spaces before or after.</p><p>Then, edit the file <code class="literal">$HOME/.gitolite.rc</code> on the server, and uncomment the following lines:</p><div><pre class="programlisting">
<strong># SHELL_USERS_LIST          =&gt;  "$ENV{HOME}/.gitolite.shell-users",</strong>
</pre></div><p>and</p><div><pre class="programlisting">
<strong># 'Shell',</strong>
</pre></div><p>Finally, run the following command:</p><div><pre class="programlisting">
<strong>gitolite trigger POST_COMPILE</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Managing keys outside Gitolite</h1></div></div></div><p>You do not have<a id="id88" class="indexterm"/> to let Gitolite manage the keys if you<a id="id89" class="indexterm"/> have a different method of managing them that you prefer. For example, you may be using an LDAP-backed ssh daemon, which manages users' keys centrally for several enterprise applications and systems, and therefore you wish to take advantage of that for Gitolite user management.</p><p>Gitolite will work fine with any method as long as you ensure that these points are covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">SSH_ORIGINAL_COMMAND</code> environment variable should contain the original Git command that the client sent out. Typically, this will be something like <code class="literal">git-upload-pack 'repo.git'</code> (including the single quotes) or, for pushes, <code class="literal">git-receive-pack 'repo.git</code>'.<p>This variable is automatically set by the ssh daemon when the ssh configuration specifies a forced command of some kind (please see the ssh documentation for details on how to force commands).</p></li><li class="listitem" style="list-style-type: disc">The <a id="id90" class="indexterm"/>command that is thus forced to<a id="id91" class="indexterm"/> run should be the full path to the gitolite-shell program, wherever you may have installed it. For example, it could be <code class="literal">/home/git/gitolite/src/gitolite-shell</code>.</li><li class="listitem" style="list-style-type: disc">This program should get exactly one argument: the Gitolite username of the ssh-authenticated user.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Getting user group information from LDAP</h1></div></div></div><p>Gitolite <a id="id92" class="indexterm"/>makes it possible to make some limited use of user data that may already be available in the enterprise.</p><p>The most <a id="id93" class="indexterm"/>common use case for this is that the enterprise already has an LDAP database that contains all the users and their roles in the organization. What the administrator would like to do is to use this information to reduce the burden of giving users rights to Gitolite repositories. It would be great if the administrator could merely specify rights in terms of group-names and Gitolite were to somehow figure out which groups a user is a member of.</p><p>Gitolite can facilitate the querying of the LDAP database and somehow acquire the information it needs. The solution involves writing a helper program, which does the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accept one Gitolite user ID as the first (and only) argument</li><li class="listitem" style="list-style-type: disc">If necessary, convert this user ID in some unspecified manner to make it suitable for the LDAP query. For example, you may have to add specific components to the name for the query to work.</li><li class="listitem" style="list-style-type: disc">Use this user ID as a query parameter and query the LDAP database to get user details. The program that does this will need to have credentials and permission to query the LDAP database.</li><li class="listitem" style="list-style-type: disc">Once the query returns, extract the user's role/group information from the result.</li><li class="listitem" style="list-style-type: disc">If required, again convert this group information to the names that you have used in Gitolite's access rules.</li><li class="listitem" style="list-style-type: disc">Print the list of groups that result, all on one line and separated by spaces.</li></ul></div><p>Once<a id="id94" class="indexterm"/> this program is done, save it as <code class="literal">$HOME/bin/ldap-query-groups</code> and test it. It's only taking one command-line argument and printing results to the terminal so there is no real harm in doing so, as far as Gitolite is concerned.</p><p>After<a id="id95" class="indexterm"/> testing it, edit Gitolite's rc file (<code class="literal">$HOME/.gitolite.rc</code>) and add the following line (including the trailing comma) somewhere within the definition of the <code class="literal">%RC</code> variable, preferably close to the top:</p><div><pre class="programlisting">
<strong>GROUPLIST_PGM           =&gt;  "$ENV{HOME}/bin/ldap-query-groups",</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Removing users</h1></div></div></div><p>Removing <a id="id96" class="indexterm"/>Gitolite <a id="id97" class="indexterm"/>users is pretty simple. Just remove all the keys pertaining to the user (in case they have more than one, as discussed in an earlier section) from a clone of the gitolite-admin repository. This should be done using the <code class="literal">git rm</code> command, not a plain <code class="literal">rm</code> command.</p><p>After that, commit the change and push it.</p><p>You can confirm the removal in a couple of different ways. First, the keys you just removed should no longer be available in <code class="literal">$HOME/.gitolite/keydir</code> on the server. Second, the user should not be found if you search for the name in the authorized keys file (<code class="literal">$HOME/.ssh/authorized_keys</code>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we saw how to add and remove users, as well as how to handle several other unusual requirements that may come up once in a while. In the next chapter, we will talk about adding and removing repositories.</p></div></body></html>