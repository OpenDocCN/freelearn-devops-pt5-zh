- en: Sharing Data with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Do one thing at a time and do it well," has been one of the successful mantras
    in the **Information Technology** (**IT**) sector for quite a long time now. This
    widely used tenet fits nicely to build and expose Docker containers too, and it
    is being prescribed as one of the best practices to avail the originally envisaged
    benefits of the Docker-inspired containerization paradigm. This means that, we
    must inscribe a single application along with its direct dependencies and libraries
    inside a Docker container in order to ensure the container''s independence, self-sufficiency,
    horizontal scalability, and maneuverability. Let''s see why containers are that
    important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The temporal nature of containers**: The container typically lives as long
    as the application lives and vice versa. However, this has some negative implications
    for the application data. Applications naturally go through a variety of changes
    in order to accommodate both business as well as technical changes, even in their
    production environments. There are other causes, such as application malfunctions,
    version changes, and application maintenance, for software applications to be
    consistently and constantly updated and upgraded. In the case of a general-purpose
    computing model, even when an application dies for any reason, the persistent
    data associated with this application can be preserved in the filesystem. However,
    in the case of the container paradigm, the application upgrades are usually performed
    by systematically crafting a new container with the newer version of the application
    by simply discarding the old one. Similarly, when an application malfunctions,
    a new container needs to be launched and the old one has to be discarded. To sum
    it up, containers are typically temporal in nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The need for a business continuity**: In the container landscape, the complete
    execution environment, including its data files, is usually bundled and encapsulated
    inside the container. For any reason, when a container gets discarded, the application
    data files also perish along with the container. However, in order to provide
    software applications without any interruption and disruption of service, these
    application data files must be preserved outside the container and passed on to
    the container on a need basis in order to ensure business continuity. This means
    that the resiliency and reliability of containers need to be guaranteed. Besides,
    some application data files, such as the log files, needs to be collected and
    accessed outside the container for various posterior analyses. The Docker technology
    addresses this file persistence issue very innovatively through a new building
    block called data volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Docker technology has three different ways of providing persistent storage:'
  prefs: []
  type: TYPE_NORMAL
- en: The first and recommended approach is to use volumes that are created using
    Docker's volume management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second method is to mount a directory from the Docker host to a specified
    location inside the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other alternative is to use a data-only container. The data-only container
    is a specially crafted container that is used to share data with one or more containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing host data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The avoidable common pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data volume is the fundamental building block of data sharing in the Docker
    environment. Before getting into the details of data sharing, it is imperative
    to get a good understanding of the data volume concept. Until now, all the files
    that we create in an image or a container is part and parcel of the union filesystem.
    The container's union filesystem perishes along with the container. In other words,
    when the container is removed, its filesystem is also automatically removed. However,
    the enterprise-grade applications must persist data and the container's filesystem
    will not render itself for such a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker ecosystem, however, elegantly addresses this issue with the data
    volume concept. Data volume is essentially a part of the Docker host filesystem
    and it simply gets mounted inside the container. Optionally, you can use other
    advanced filesystems such as Flocker and GlusterFS as data volumes through pluggable
    volume drivers. Since data volume is not a part of the container's filesystem,
    it has a life cycle independent of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'A data volume can be inscribed in a Docker image using the `VOLUME` instruction
    of the `Dockerfile`. Also, it can be prescribed during the launch of a container
    using the `-v` option of the `docker run` subcommand. Here, in the following example,
    the implication of the `VOLUME` instruction in the `Dockerfile` is illustrated
    in detail in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a very simple `Dockerfile` with the instruction of the base image (`ubuntu:16.04`)
    and the data volume (`/MountPointDemo`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image with the `mount-point-demo` name using the `docker build` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Having built the image, let''s quickly inspect the image for our data volume
    using the `docker inspect` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, in the preceding output, data volume is inscribed in the image itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s launch an interactive container using the `docker run` subcommand
    from the earlier crafted image, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the container''s prompt, let''s check the presence of data volume using
    the `ls -ld` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, data volume is part of the Docker host filesystem and
    it gets mounted, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we inspected the image to find out about the data volume declaration
    in the image. Now that we have launched the container, let''s inspect the container''s
    data volume using the `docker inspect` subcommand with the container ID as its
    argument in a different Terminal. We created a few containers previously and for
    this purpose, let''s take the `8d22f73b5b46` container ID directly from the container''s
    prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, here, data volume is mapped to a directory in the Docker host, and
    the directory is mounted in the read-write mode. This directory, also called as
    volume, is created by the Docker Engine automatically during the launch of the
    container. Since version 1.9 of Docker, the volumes are managed through a top-level
    volume management command, which we will dive and dig further down into tell all
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen the implication of the `VOLUME` instruction in the `Dockerfile`,
    and how Docker manages data volume. Like the `VOLUME` instruction of the `Dockerfile`,
    we can use the `-v <container mount point path>` option of the `docker run` subcommand,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Having launched the container, we encourage you to try the `ls -ld /MountPointDemo`
    and `mount` commands in the newly launched container, and then also, inspect the
    container, as shown in the preceding step 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the scenarios described here, the Docker Engine automatically creates
    the volume under the `/var/lib/docker/volumes/` directory and mounts it to the
    container. When a container is removed using the `docker rm` subcommand, the Docker
    Engine does not remove the volume that was automatically created during the launch
    of the container. This behavior is innately designed to preserve the state of
    the container''s application that was stored in the volume filesystem. If you
    want to remove the volume that was automatically created by the Docker Engine,
    you can do so while removing the container by providing a `-v` option to the `docker
    rm` subcommand, on an already stopped container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the container is still running, then you can remove the container as well
    as the autogenerated directory by adding a `-f` option to the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have taken you through the techniques and tips to autogenerate a directory
    in the Docker host and mount it to the data volume in the container. However,
    with the `-v` option of the `docker run` subcommand, a user-defined directory
    can be mounted to the data volume. In such cases, the Docker Engine will not autogenerate
    any directory.
  prefs: []
  type: TYPE_NORMAL
- en: The system generation of a directory has a caveat of directory leak. In other
    words, if you forget to delete the system-generated directories, you may face
    some unwanted issues. For further information, read the *Avoiding common pitfalls*
    section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The volume management command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker has introduced a top-level volume management command from version 1.9
    in order to manage the persistent filesystem effectively. The volume management
    command is capable of managing data volumes that are part of the Docker host.
    In addition to that, it also helps us to extend the Docker persistent capability
    using pluggable volume drivers (Flocker, GlusterFS, and so on). You can find the
    list of supported plugins at [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker volume` command supports four subcommands as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create`: This creates a new volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inspect`: This displays detailed information about one or more volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls`: This lists the volumes in the Docker host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm`: This removes a volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s quickly explore the volume management command through a few examples.
    You can create a volume using the `docker volume create` subcommand, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a volume by autogenerating a 64-hex digit
    string as the volume name. However, it is more effective to name the volume with
    a meaningful name for easy identification. You can name a volume using the `--name`
    option of the `docker volume create` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, that we have created two volumes with and without a volume name, let''s
    use the `docker volume ls` subcommand to display them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Having listed out the volumes, let''s run the `docker volume inspect` subcommand
    into the details of the volumes we have created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker volume rm` subcommand enables you to remove the volumes you don''t
    need anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are familiar with Docker volume management, let's dive deep into
    data sharing in the ensuing sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing host data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we described the steps to create a data volume in a Docker image using
    the `VOLUME` instruction in the `Dockerfile`. However, Docker does not provide
    any mechanism to mount the host directory or file during the build time in order
    to ensure the Docker images to be portable. The only provision Docker provides
    is to mount the host directory or file to a container''s data volume during the
    container''s launch. Docker exposes the host directory or file mounting facility
    through the `-v` option of the `docker run` subcommand. The `-v` option has five
    different formats, enumerated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v <container mount path>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v <host path>:<container mount path>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v <host path>:<container mount path>:<read write mode>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v <volume name>:<container mount path>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v <volume name>:<container mount path>:<read write mode>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<host path>` format is an absolute path in the Docker host, `<container
    mount path>` is an absolute path in the container filesystem, `<volume name>`
    is the name of the volume created using the `docker volume create` subcommand,
    and `<read write mode>` can be either the read-only (`ro`) or read-write (`rw`)
    mode. The first `-v <container mount path>` format has already been explained
    in the *Data volume* section in this chapter, as a method to create a mount point
    during the launch of the container launch. The second and third formats enable
    us to mount a file or directory from the Docker host to the container mount point.
    The fourth and fifth formats allow us to mount volumes created using the `docker
    volume create` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to dig deeper to gain a better understanding of the host's data
    sharing through a couple of examples. In the first example, we will demonstrate
    how to share a directory between the Docker host and the container, and in the
    second example, we will demonstrate file sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in the first example, we mount a directory from the Docker host to a
    container, perform a few basic file operations on the container, and verify these
    operations from the Docker host, as detailed in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s launch an interactive container with the `-v` option of the `docker
    run` subcommand to mount `/tmp/hostdir` of the Docker host directory to `/MountPoint`
    of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If `/tmp/hostdir` is not found on the Docker host, the Docker Engine will create
    the directory per se. However, the problem is that the system-generated directory
    cannot be deleted using the `-v` option of the `docker rm` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having successfully launched the container, we can check the presence of `/MountPoint`
    using the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can proceed to check the mount details using the `mount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are going to validate `/MountPoint`, change to the `/MountPoint` directory
    using the `cd` command, create a few files using the `touch` command, and list
    the files using the `ls` command, as shown in the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be worth the effort to verify the files in the `/tmp/hostdir` Docker
    host directory using the `ls` command on a new Terminal, as our container is running
    in an interactive mode on the existing Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the same set of files, as we saw in step 4\. However, you might
    have noticed the difference in the timestamp of the files. This time difference
    is due to the time zone difference between the Docker host and the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s run the `docker inspect` subcommand with the `4a018d99c133`
    container ID as an argument to see whether the directory mapping is set up between
    the Docker host and the container mount point, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, in the preceding output of the `docker inspect` subcommand, the
    `/tmp/hostdir` directory of the Docker host is mounted on the `/MountPoint` mount
    point of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second example, we will mount a file from the Docker host to a container,
    update the file from the container, and verify those operations from the Docker
    host, as detailed in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mount a file from the Docker host to the container, the file must
    preexist in the Docker host. Otherwise, the Docker Engine will create a new directory
    with the specified name and mount it as a directory. We can start by creating
    a file on the Docker host using the `touch` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch an interactive container with the `-v` option of the `docker run` subcommand
    to mount the `/tmp/hostfile.txt` Docker host file to the container as `/tmp/mntfile.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully launched the container, now let''s check the presence of
    `/mntfile.txt` using the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, proceed to check the mount details using the `mount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update some text to `/mntfile.txt` using the `echo` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, switch to a different Terminal in the Docker host, and print the
    `/tmp/hostfile.txt` Docker host file using the `cat` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the `docker inspect` subcommand with the `d23a15527eeb` container
    ID as it''s argument to see the file mapping between the Docker host and the container
    mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, it is evident that the `/tmp/hostfile.txt` file from
    the Docker host is mounted as `/mntfile.txt` inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: For the last example, we will create a Docker volume and mount a named data
    volume to a container. In this example, we are not going to run the verification
    steps as we did in the previous two examples. However, you are encouraged to run
    the verification steps we laid out in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a named data volume using the `docker volume create` subcommand, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, launch an interactive container with the `-v` option of the `docker run`
    subcommand to mount `namedvol` a named data value to `/MountPoint` of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: During the launch of the container, Docker Engine creates `namedvol` if it is
    not created already.
  prefs: []
  type: TYPE_NORMAL
- en: Having successfully launched the container, you can repeat the verification
    steps 2 to 6 of the first example and you will find the same output pattern in
    this example as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The practicality of host data sharing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous chapter, we launched an HTTP service in a Docker container.
    However, if you remember correctly, the log file for the HTTP service is still
    inside the container, and it cannot be accessed directly from the Docker host.
    Here, in this section, we elucidate the procedure of accessing the log files from
    the Docker host in a step-by-step manner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with launching an Apache2 HTTP service container by mounting the
    `/var/log/myhttpd` directory of the Docker host to the `/var/log/apache2` directory
    of the container, using the `-v` option of the `docker run` subcommand. In this
    example, we are leveraging the `apache2` image, which we had built in the previous
    chapter, by invoking the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you recall the `Dockerfile` in [Chapter 6](../Text/Ch06.xhtml), *Running
    Services in a Container*, the `APACHE_LOG_DIR` environment variable is set to
    the `/var/log/apache2` directory, using the `ENV` instruction. This will make
    the Apache2 HTTP service to route all log messages to the `/var/log/apache2` data
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the container is launched, we can change the directory to `/var/log/myhttpd`
    on the Docker host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps, a quick check of the files present in the `/var/log/myhttpd` directory
    is appropriate here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `access.log` file contains all the access requests handled by the
    Apache2 HTTP server. The `error.log` file is a very important log file, where
    our HTTP server records the errors it encounters while processing any HTTP requests.
    The `other_vhosts_access.log` file is the virtual host log, which will always
    be empty in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display the content of all the log files in the `/var/log/myhttpd` directory
    using the `tail` command with the `-f` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `tail -f` command will run continuously and display the content of the files,
    as soon as they get updated. Here, both `access.log` and `other_vhosts_access.log`
    are empty, and there are a few error messages on the `error.log` file. Apparently,
    these error logs are generated by the HTTP service running inside the container.
    The logs are then stocked in the Docker host directory, which is mounted during
    the launch of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we continue to run `tail -f *`, let''s connect to the HTTP service from
    a web browser running inside the container, and observe the log files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP service updates the `access.log` file, which we can manipulate from
    the host directory mounted through the `-v` option of the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how seamlessly the Docker Engine enables
    data sharing between the Docker host and the container. Although it is a very
    effective solution for most of the use cases, there are use cases wherein you
    will have to share data between one or more containers. The Docker's prescription
    to address this use case is to mount the data volume of one container to other
    containers using the `--volume-from` option of the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Data-only containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before Docker introduced the top-level volume management feature, the data-only
    container was the recommended approach to achieve data persistency. It is worth
    understanding data-only containers because you will find many implementations
    that are based on data-only containers. The prime responsibility of a data-only
    container is to preserve the data. Creating a data-only container is very similar
    to the method illustrated in the *Data volume* section. In addition, the containers
    are named explicitly for other containers to mount the data volume using the container''s
    name. Besides, the container''s data volumes are accessible from other containers
    even when the data-only containers are in the stopped state. The data-only containers
    can be created in two ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: During the launch of the container by configuring the data volume and the container's
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data volume can also be inscribed with `Dockerfile` during image-building, and
    later, the container can be named during the container's launch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we are launching a data-only container by configuring
    the container launch with the `-v` and `--name` options of the `docker run` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, the container is launched from the `busybox` image, which is widely used
    for its smaller footprint. Here, we choose to execute the `/bin/true` command
    because we don't intend to do any operations on the container. Therefore, we named
    the container `datavol` using the `--name` option and created a new `/DataMount`
    data volume using the `-v` option of the `docker run` subcommand. The `/bin/true`
    command exits immediately with the `0` exit status, which in turn will stop the
    container and continue to be in the stopped state.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting data volume from other containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Docker Engine provides a nifty interface to mount (share) the data volume
    from one container to another. Docker makes this interface available through the
    `--volumes-from` option of the `docker run` subcommand. The `--volumes-from` option
    takes a container name or container ID as its input and automatically mounts all
    the data volumes available on the specified container. Docker allows you to mount
    multiple containers with data volume using the `--volumes-from` option multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a practical example that demonstrates how to mount data volume from
    another container and showcases the data volume mount step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with launching an interactive Ubuntu container by mounting the data
    volume from the data-only container (`datavol`), which we launched in the previous
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now from the container''s prompt, let''s verify the data volume mounts using
    the `mount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we successfully mounted the data volume from the `datavol` data-only container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to inspect the data volume of this container from another Terminal
    using the `docker inspect` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the data volume from the `datavol` data-only container is mounted
    as if they were mounted directly on to this container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can mount a data volume from another container and also showcase the mount
    points. We can make the mounted data volume to work by sharing data between containers
    using the data volume, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reuse the container that we launched in the previous example and create
    a `/DataMount/testfile` file in the `/DataMount` data volume by writing some text
    to the file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Just spin off a container to display the text that we wrote in the previous
    step, using the `cat` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the typical output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the preceding `Data Sharing between Container` output of our newly
    containerized `cat` command is the text that we have written in `/DataMount/testfile`
    of the `datavol` container in step 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool, isn''t it? You can share data seamlessly between containers by sharing
    the data volumes. Here, in this example, we used data-only containers as the base
    container for data sharing. However, Docker allows us to share any type of data
    volumes and to mount data volumes one after another, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the `vol1` container, we mounted the data volume from the `datavol`
    container. Then, in the `vol2` container, we mounted the data volume from the
    `vol1` container, which is eventually from the `datavol` container.
  prefs: []
  type: TYPE_NORMAL
- en: The practicality of data sharing between containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, you learned the mechanism of accessing the log files
    of the Apache2 HTTP service from the Docker host. Although it was fairly convenient
    to share data by mounting the Docker host directory to a container, later we came
    to know that data can be shared between containers by just using data volumes.
    So here, we are bringing in a twist to the method of the Apache2 HTTP service
    log handling by sharing data between containers. To share log files between containers,
    we will spin off the following containers as enlisted in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a data-only container that will expose the data volume to other containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, an Apache2 HTTP service container leveraging the data volume of the data-only
    container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A container to view the log files generated by our Apache2 HTTP service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are running any HTTP service on the `80` port number of your Docker host
    machine, pick any other unused port number for the following example. If not,
    first stop the HTTP service, then proceed with the example in order to avoid any
    port conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll meticulously walk you through the steps to craft the respective
    images and launch the containers to view the log files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we begin with crafting a `Dockerfile` with the `/var/log/apache2` data
    volume using the `VOLUME` instruction. The `/var/log/apache2` data volume is a
    direct mapping to `APACHE_LOG_DIR`, the environment variable set in the `Dockerfile`
    in [Chapter 6](../Text/Ch06.xhtml), *Running Services in a Container*, using the
    `ENV` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Since this `Dockerfile` is crafted to launch data-only containers, the default
    execution command is set to `/bin/true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue to build a Docker image with the `apache2log` name from the
    preceding `Dockerfile` using `docker build`, as presented here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch a data-only container from the `apache2log` image using the `docker
    run` subcommand and name the resulting container `log_vol`, using the `--name`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Acting on the preceding command, the container will create a data volume in
    `/var/log/apache2` and move it to a stop state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, you can run the `docker ps` subcommand with the `-a` option to verify
    the container''s state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As per the output, the container exits with the `0` exit value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the Apache2 HTTP service using the `docker run` subcommand. Here, we
    are reusing the `apache2` image we crafted in [Chapter 6](../Text/Ch06.xhtml),
    *Running Services in a Container*. Besides, in this container, we will mount the
    `/var/log/apache2` data volume from `log_vol`, the data-only container that we
    launched in step 3, using the `--volumes-from` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With the successful launch of the Apache2 HTTP service with the `/var/log/apache2`
    data volume mounted from `log_vol`, we can access the log files using transient
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are listing the files stored by the Apache2 HTTP service, using a
    transient container. This transient container is spun off by mounting the `/var/log/apache2`
    data volume from `log_vol`, and the files in `/var/log/apache2` are listed using
    the `ls` command. Further, the `--rm` option of the `docker run` subcommand is
    used to remove the container once it is done executing the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the error log produced by the Apache2 HTTP service is accessed using
    the `tail` command, as highlighted in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding common pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have discussed how effectively data volumes can be used to share
    data between the Docker host and the containers as well as between containers.
    Data sharing using data volumes is turning out to be a very powerful and essential
    tool in the Docker paradigm. However, it does carry a few pitfalls that are to
    be carefully identified and eliminated. In this section, we make an attempt to
    list out a few common issues associated with data sharing and the ways and means
    to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Directory leaks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier in the *Data volume* section, you learned that the Docker Engine automatically
    creates directories based on the `VOLUME` instruction in the `Dockerfile` as well
    as the `-v` option of the `docker run` subcommand. We also understood that the
    Docker Engine does not automatically delete these autogenerated directories in
    order to preserve the state of the application(s) run inside the container. We
    can force Docker to remove these directories using the `-v` option of the `docker
    rm` subcommand. This process of manual deletion poses two major challenges enumerated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Undeleted directories:** There can be scenarios where you may intentionally
    or unintentionally choose not to remove the generated directory while removing
    the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third-party images:** Quite often, we leverage third-party Docker images
    that could have been built with the `VOLUME` instruction. Likewise, we might also
    have our own Docker images with `VOLUME` inscribed in it. When we launch containers
    using such Docker images, the Docker Engine will autogenerate the prescribed directories.
    Since we are not aware of the data volume creation, we may not call the `docker
    rm` subcommand with the `-v` option to delete the autogenerated directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previously mentioned scenarios, once the associated container is removed,
    there is no direct way to identify the directories whose containers were removed.
    Here are a few recommendations on how to avoid this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Always inspect the Docker images using the `docker inspect` subcommand and check
    whether any data volume is inscribed in the image or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always run the `docker rm` subcommand with the `-v` option to remove any data
    volume (directory) created for the container. Even if the data volume is shared
    by multiple containers, it is still safe to run the `docker rm` subcommand with
    the `-v` option because the directory associated with the data volume will be
    deleted only when the last container sharing that data volume is removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any reason, if you choose to preserve the autogenerated directory, you must
    keep a clear record so that you can remove them at a later point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an audit framework that will audit and find out the directories that
    do not have any container association.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The undesirable effect of data volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, Docker enables access for us to each data volume in a
    Docker image using the `VOLUME` instruction during the build time. Nevertheless,
    data volumes should never be used to store any data during the build time, otherwise
    it will result in an unwanted effect.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will demonstrate the undesirable effect of using data volume
    during the build by crafting a `Dockerfile`, and then showcase the implication
    by building this `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the details of `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the image using Ubuntu 16.04 as the base image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `/MountPointDemo` data volume using the `VOLUME` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed to build an image from this `Dockerfile` using the `docker build` subcommand,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output of the `docker build` subcommand, you would have noticed
    that the build fails in step 3 because it could not find the file created in step
    2\. Apparently, the file that was created in step 2 vanishes when it reaches step
    3\. This undesirable effect is due to the approach Docker uses to build its images.
    An understanding of the Docker image-building process will unravel the mystery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the build process, for every instruction in a `Dockerfile`, the following
    steps are followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new container by translating the `Dockerfile` instruction to an equivalent
    `docker run` subcommand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the newly-created container to an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 and 2 by treating the newly-created image as the base image for
    step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a container is committed, it saves the filesystem of the container and
    deliberately does not save the filesystem of the data volumes. Therefore, any
    data stored in the data volume will be lost in this process. So, never use a data
    volume as a storage during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For enterprise-scale distributed applications to be distinct in their operations
    and outputs, data is the most important instrument and ingredient. With IT containerization,
    the journey takes off in a brisk and bright fashion. IT as well as business software
    solutions are intelligently containerized through the smart leverage of the Docker
    Engine. However, the original instigation is the need for a faster and flawless
    realization of application-aware Docker containers, and hence, the data is tightly
    coupled with the application within the container. However, this closeness brings
    in some real risks. If the application collapses, then the data is also gone.
    Also, multiple applications might depend on the same data and hence, data has
    to be shared across.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed the capabilities of the Docker Engine in facilitating
    the seamless data sharing between the Docker host and container as well as between
    containers. The data volume is being prescribed as the foundational building block
    for enabling data sharing among the constituents of the growing Docker ecosystem.
    In the next chapter, we will explain the concept behind the container orchestration,
    and see how this complicated aspect gets simplified through a few automated tools.
    Orchestration is indispensable for realizing composite containers.
  prefs: []
  type: TYPE_NORMAL
