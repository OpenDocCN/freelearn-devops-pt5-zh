- en: Sharing Data with Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与容器共享数据
- en: '"Do one thing at a time and do it well," has been one of the successful mantras
    in the **Information Technology** (**IT**) sector for quite a long time now. This
    widely used tenet fits nicely to build and expose Docker containers too, and it
    is being prescribed as one of the best practices to avail the originally envisaged
    benefits of the Docker-inspired containerization paradigm. This means that, we
    must inscribe a single application along with its direct dependencies and libraries
    inside a Docker container in order to ensure the container''s independence, self-sufficiency,
    horizontal scalability, and maneuverability. Let''s see why containers are that
    important:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “一次只做一件事，并且做到最好”，这已经成为**信息技术**（**IT**）行业一个成功的座右铭，并且已经流行了很长时间。这一广泛使用的准则也非常适合构建和暴露Docker容器，并且被推荐作为获得Docker启发的容器化范式原本设想的好处的最佳实践之一。这意味着，我们必须将一个单一应用程序及其直接依赖和库写入一个Docker容器中，以确保容器的独立性、自给自足、横向可扩展性和机动性。让我们看看为什么容器如此重要：
- en: '**The temporal nature of containers**: The container typically lives as long
    as the application lives and vice versa. However, this has some negative implications
    for the application data. Applications naturally go through a variety of changes
    in order to accommodate both business as well as technical changes, even in their
    production environments. There are other causes, such as application malfunctions,
    version changes, and application maintenance, for software applications to be
    consistently and constantly updated and upgraded. In the case of a general-purpose
    computing model, even when an application dies for any reason, the persistent
    data associated with this application can be preserved in the filesystem. However,
    in the case of the container paradigm, the application upgrades are usually performed
    by systematically crafting a new container with the newer version of the application
    by simply discarding the old one. Similarly, when an application malfunctions,
    a new container needs to be launched and the old one has to be discarded. To sum
    it up, containers are typically temporal in nature.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器的时间性**：容器通常随着应用程序的生命周期而存在，反之亦然。然而，这对应用程序数据有一些负面影响。应用程序自然会经历各种变化，以适应业务和技术的变化，即使在生产环境中也是如此。还有其他原因，如应用程序故障、版本更替和应用程序维护，使得软件应用程序需要不断地更新和升级。在通用计算模型的情况下，即使应用程序因某种原因停止运行，与该应用程序相关的持久化数据仍然可以保存在文件系统中。然而，在容器范式下，应用程序的升级通常是通过系统地创建一个新的容器，其中包含更新版本的应用程序，并简单地丢弃旧的容器来完成的。同样，当应用程序发生故障时，需要启动一个新容器，并且必须丢弃旧的容器。总的来说，容器通常具有时间性。'
- en: '**The need for a business continuity**: In the container landscape, the complete
    execution environment, including its data files, is usually bundled and encapsulated
    inside the container. For any reason, when a container gets discarded, the application
    data files also perish along with the container. However, in order to provide
    software applications without any interruption and disruption of service, these
    application data files must be preserved outside the container and passed on to
    the container on a need basis in order to ensure business continuity. This means
    that the resiliency and reliability of containers need to be guaranteed. Besides,
    some application data files, such as the log files, needs to be collected and
    accessed outside the container for various posterior analyses. The Docker technology
    addresses this file persistence issue very innovatively through a new building
    block called data volume.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务连续性的需求**：在容器环境中，完整的执行环境，包括其数据文件，通常被打包并封装在容器内。由于任何原因，当容器被丢弃时，应用程序的数据文件也会随容器一起消失。然而，为了提供不中断和不中断的服务，这些应用程序数据文件必须保存在容器外部，并在需要时传递到容器内，以确保业务连续性。这意味着容器的弹性和可靠性需要得到保证。此外，一些应用程序数据文件，如日志文件，需要在容器外部收集并访问，以进行各种后续分析。Docker技术通过一种名为数据卷的新构件非常创新地解决了这个文件持久性问题。'
- en: 'The Docker technology has three different ways of providing persistent storage:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker技术提供了三种不同的持久存储方式：
- en: The first and recommended approach is to use volumes that are created using
    Docker's volume management.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个推荐的方法是使用通过Docker的卷管理创建的卷。
- en: The second method is to mount a directory from the Docker host to a specified
    location inside the container.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是将Docker主机的目录挂载到容器内的指定位置。
- en: The other alternative is to use a data-only container. The data-only container
    is a specially crafted container that is used to share data with one or more containers.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种选择是使用数据专用容器。数据专用容器是一种特别设计的容器，用于与一个或多个容器共享数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Data volume
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷
- en: Sharing host data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享主机数据
- en: Sharing data between containers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器间共享数据
- en: The avoidable common pitfalls
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可避免的常见陷阱
- en: Data volume
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据卷
- en: Data volume is the fundamental building block of data sharing in the Docker
    environment. Before getting into the details of data sharing, it is imperative
    to get a good understanding of the data volume concept. Until now, all the files
    that we create in an image or a container is part and parcel of the union filesystem.
    The container's union filesystem perishes along with the container. In other words,
    when the container is removed, its filesystem is also automatically removed. However,
    the enterprise-grade applications must persist data and the container's filesystem
    will not render itself for such a requirement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷是Docker环境中数据共享的基础构建块。在深入了解数据共享的细节之前，必须先理解数据卷的概念。到目前为止，我们在镜像或容器中创建的所有文件都是联合文件系统的一部分。容器的联合文件系统随着容器的消失而消失。换句话说，当容器被删除时，它的文件系统也会被自动删除。然而，企业级应用程序必须持久化数据，容器的文件系统无法满足这种需求。
- en: The Docker ecosystem, however, elegantly addresses this issue with the data
    volume concept. Data volume is essentially a part of the Docker host filesystem
    and it simply gets mounted inside the container. Optionally, you can use other
    advanced filesystems such as Flocker and GlusterFS as data volumes through pluggable
    volume drivers. Since data volume is not a part of the container's filesystem,
    it has a life cycle independent of the container.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker生态系统通过数据卷概念优雅地解决了这个问题。数据卷本质上是Docker主机文件系统的一部分，它会被挂载到容器内。你也可以通过可插拔的卷驱动程序使用其他高级文件系统，如Flocker和GlusterFS，作为数据卷。由于数据卷不是容器文件系统的一部分，它具有独立于容器的生命周期。
- en: 'A data volume can be inscribed in a Docker image using the `VOLUME` instruction
    of the `Dockerfile`. Also, it can be prescribed during the launch of a container
    using the `-v` option of the `docker run` subcommand. Here, in the following example,
    the implication of the `VOLUME` instruction in the `Dockerfile` is illustrated
    in detail in the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`Dockerfile`中的`VOLUME`指令将数据卷写入Docker镜像中。同时，也可以在启动容器时使用`docker run`子命令的`-v`选项指定数据卷。以下示例详细演示了`Dockerfile`中`VOLUME`指令的应用：
- en: 'Create a very simple `Dockerfile` with the instruction of the base image (`ubuntu:16.04`)
    and the data volume (`/MountPointDemo`):'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个非常简单的`Dockerfile`，包含基础镜像（`ubuntu:16.04`）和数据卷（`/MountPointDemo`）的指令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Build the image with the `mount-point-demo` name using the `docker build` subcommand:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`子命令，以`mount-point-demo`为名称构建镜像：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Having built the image, let''s quickly inspect the image for our data volume
    using the `docker inspect` subcommand:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完镜像后，让我们使用`docker inspect`子命令快速检查镜像中的数据卷：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Evidently, in the preceding output, data volume is inscribed in the image itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在前面的输出中，数据卷已经被记录在镜像本身中。
- en: 'Now, let''s launch an interactive container using the `docker run` subcommand
    from the earlier crafted image, as shown in the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`docker run`子命令从之前创建的镜像启动一个交互式容器，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the container''s prompt, let''s check the presence of data volume using
    the `ls -ld` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器提示符下，让我们使用`ls -ld`命令检查数据卷的存在：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As mentioned earlier, data volume is part of the Docker host filesystem and
    it gets mounted, as shown in the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据卷是Docker主机文件系统的一部分，它会被挂载，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this section, we inspected the image to find out about the data volume declaration
    in the image. Now that we have launched the container, let''s inspect the container''s
    data volume using the `docker inspect` subcommand with the container ID as its
    argument in a different Terminal. We created a few containers previously and for
    this purpose, let''s take the `8d22f73b5b46` container ID directly from the container''s
    prompt:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一节中，我们检查了镜像，以了解镜像中的数据卷声明。现在我们已经启动了容器，让我们使用`docker inspect`子命令并在不同的终端中提供容器ID作为参数，检查容器的数据卷。我们之前创建了一些容器，针对这个目的，我们直接从容器的提示符中获取`8d22f73b5b46`容器ID：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Apparently, here, data volume is mapped to a directory in the Docker host, and
    the directory is mounted in the read-write mode. This directory, also called as
    volume, is created by the Docker Engine automatically during the launch of the
    container. Since version 1.9 of Docker, the volumes are managed through a top-level
    volume management command, which we will dive and dig further down into tell all
    in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这里，数据卷被映射到Docker主机中的一个目录，并且该目录以读写模式挂载。这个目录，也称为卷，是Docker引擎在容器启动时自动创建的。从Docker
    1.9版本开始，卷通过顶级卷管理命令进行管理，我们将在下一节中进一步深入探讨。
- en: 'So far, we have seen the implication of the `VOLUME` instruction in the `Dockerfile`,
    and how Docker manages data volume. Like the `VOLUME` instruction of the `Dockerfile`,
    we can use the `-v <container mount point path>` option of the `docker run` subcommand,
    as shown in the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了`Dockerfile`中`VOLUME`指令的含义，以及Docker如何管理数据卷。像`Dockerfile`中的`VOLUME`指令一样，我们可以使用`docker
    run`子命令的`-v <容器挂载点路径>`选项，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Having launched the container, we encourage you to try the `ls -ld /MountPointDemo`
    and `mount` commands in the newly launched container, and then also, inspect the
    container, as shown in the preceding step 5.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器后，我们建议您在新启动的容器中尝试执行`ls -ld /MountPointDemo`和`mount`命令，然后按照第5步所示检查容器。
- en: 'In both the scenarios described here, the Docker Engine automatically creates
    the volume under the `/var/lib/docker/volumes/` directory and mounts it to the
    container. When a container is removed using the `docker rm` subcommand, the Docker
    Engine does not remove the volume that was automatically created during the launch
    of the container. This behavior is innately designed to preserve the state of
    the container''s application that was stored in the volume filesystem. If you
    want to remove the volume that was automatically created by the Docker Engine,
    you can do so while removing the container by providing a `-v` option to the `docker
    rm` subcommand, on an already stopped container:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里描述的两种情况中，Docker引擎会自动在`/var/lib/docker/volumes/`目录下创建卷，并将其挂载到容器。当使用`docker
    rm`子命令删除容器时，Docker引擎不会删除在容器启动时自动创建的卷。此行为是为了保持容器应用程序在卷文件系统中存储的状态。如果您想删除Docker引擎自动创建的卷，可以在删除容器时通过提供`-v`选项给`docker
    rm`子命令来实现，这适用于已停止的容器：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the container is still running, then you can remove the container as well
    as the autogenerated directory by adding a `-f` option to the previous command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器仍在运行，则可以通过在先前命令中添加`-f`选项来删除容器以及自动生成的目录：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have taken you through the techniques and tips to autogenerate a directory
    in the Docker host and mount it to the data volume in the container. However,
    with the `-v` option of the `docker run` subcommand, a user-defined directory
    can be mounted to the data volume. In such cases, the Docker Engine will not autogenerate
    any directory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向您介绍了在Docker主机中自动生成目录并将其挂载到容器的数据卷的技巧和提示。然而，使用`docker run`子命令的`-v`选项时，可以将用户定义的目录挂载到数据卷。在这种情况下，Docker引擎不会自动生成任何目录。
- en: The system generation of a directory has a caveat of directory leak. In other
    words, if you forget to delete the system-generated directories, you may face
    some unwanted issues. For further information, read the *Avoiding common pitfalls*
    section in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 系统生成目录存在一个潜在的目录泄漏问题。换句话说，如果忘记删除系统生成的目录，可能会遇到一些不必要的问题。有关更多信息，请阅读本章中的*避免常见陷阱*部分。
- en: The volume management command
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卷管理命令
- en: Docker has introduced a top-level volume management command from version 1.9
    in order to manage the persistent filesystem effectively. The volume management
    command is capable of managing data volumes that are part of the Docker host.
    In addition to that, it also helps us to extend the Docker persistent capability
    using pluggable volume drivers (Flocker, GlusterFS, and so on). You can find the
    list of supported plugins at [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从1.9版本开始，Docker引入了一个顶级卷管理命令，以便更有效地管理持久化文件系统。该卷管理命令能够管理Docker主机上的数据卷。除此之外，它还帮助我们通过可插拔的卷驱动程序（如Flocker、GlusterFS等）扩展Docker的持久化能力。你可以在[https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/)找到支持的插件列表。
- en: 'The `docker volume` command supports four subcommands as listed here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker volume`命令支持以下四个子命令：'
- en: '`create`: This creates a new volume'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：这将创建一个新的卷'
- en: '`inspect`: This displays detailed information about one or more volumes'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect`：这将显示一个或多个卷的详细信息'
- en: '`ls`: This lists the volumes in the Docker host'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls`：这将列出Docker主机中的卷'
- en: '`rm`: This removes a volume'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：这将删除一个卷'
- en: 'Let''s quickly explore the volume management command through a few examples.
    You can create a volume using the `docker volume create` subcommand, as shown
    here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些例子快速探索卷管理命令。你可以使用`docker volume create`子命令来创建一个卷，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding command will create a volume by autogenerating a 64-hex digit
    string as the volume name. However, it is more effective to name the volume with
    a meaningful name for easy identification. You can name a volume using the `--name`
    option of the `docker volume create` subcommand:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将通过自动生成一个64位十六进制数字字符串作为卷名称来创建一个卷。然而，使用一个有意义的名称来命名卷会更有效，便于识别。你可以使用`--name`选项通过`docker
    volume create`子命令来命名卷：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, that we have created two volumes with and without a volume name, let''s
    use the `docker volume ls` subcommand to display them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了两个卷，一个有卷名，一个没有卷名，让我们使用`docker volume ls`子命令来显示它们：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Having listed out the volumes, let''s run the `docker volume inspect` subcommand
    into the details of the volumes we have created earlier:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有卷后，让我们运行`docker volume inspect`子命令查看我们之前创建的卷的详细信息：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `docker volume rm` subcommand enables you to remove the volumes you don''t
    need anymore:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker volume rm`子命令允许你删除不再需要的卷：'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we are familiar with Docker volume management, let's dive deep into
    data sharing in the ensuing sections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Docker卷管理，让我们深入探讨接下来的数据共享部分。
- en: Sharing host data
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享主机数据
- en: 'Earlier, we described the steps to create a data volume in a Docker image using
    the `VOLUME` instruction in the `Dockerfile`. However, Docker does not provide
    any mechanism to mount the host directory or file during the build time in order
    to ensure the Docker images to be portable. The only provision Docker provides
    is to mount the host directory or file to a container''s data volume during the
    container''s launch. Docker exposes the host directory or file mounting facility
    through the `-v` option of the `docker run` subcommand. The `-v` option has five
    different formats, enumerated as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们描述了如何使用`Dockerfile`中的`VOLUME`指令在Docker镜像中创建数据卷。然而，为了确保Docker镜像的可移植性，Docker并没有提供在构建时挂载主机目录或文件的机制。Docker唯一提供的功能是在容器启动时将主机目录或文件挂载到容器的数据卷中。Docker通过`docker
    run`子命令的`-v`选项暴露了主机目录或文件挂载的功能。`-v`选项有五种不同的格式，如下所示：
- en: '`-v <container mount path>`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v <container mount path>`'
- en: '`-v <host path>:<container mount path>`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v <host path>:<container mount path>`'
- en: '`-v <host path>:<container mount path>:<read write mode>`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v <host path>:<container mount path>:<read write mode>`'
- en: '`-v <volume name>:<container mount path>`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v <volume name>:<container mount path>`'
- en: '`-v <volume name>:<container mount path>:<read write mode>`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v <volume name>:<container mount path>:<read write mode>`'
- en: The `<host path>` format is an absolute path in the Docker host, `<container
    mount path>` is an absolute path in the container filesystem, `<volume name>`
    is the name of the volume created using the `docker volume create` subcommand,
    and `<read write mode>` can be either the read-only (`ro`) or read-write (`rw`)
    mode. The first `-v <container mount path>` format has already been explained
    in the *Data volume* section in this chapter, as a method to create a mount point
    during the launch of the container launch. The second and third formats enable
    us to mount a file or directory from the Docker host to the container mount point.
    The fourth and fifth formats allow us to mount volumes created using the `docker
    volume create` subcommand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`<host path>`格式是Docker主机中的绝对路径，`<container mount path>`是容器文件系统中的绝对路径，`<volume
    name>`是使用`docker volume create`子命令创建的卷的名称，`<read write mode>`可以是只读（`ro`）或读写（`rw`）模式。第一个`-v
    <container mount path>`格式在本章的*数据卷*部分已解释过，作为启动容器时创建挂载点的方法。第二和第三个格式使我们能够将Docker主机中的文件或目录挂载到容器挂载点。第四和第五个格式使我们能够将使用`docker
    volume create`子命令创建的卷挂载到容器。'
- en: We would like to dig deeper to gain a better understanding of the host's data
    sharing through a couple of examples. In the first example, we will demonstrate
    how to share a directory between the Docker host and the container, and in the
    second example, we will demonstrate file sharing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过一些例子深入挖掘，进一步了解主机的数据共享。在第一个例子中，我们将演示如何在Docker主机和容器之间共享一个目录；在第二个例子中，我们将演示文件共享。
- en: 'Here, in the first example, we mount a directory from the Docker host to a
    container, perform a few basic file operations on the container, and verify these
    operations from the Docker host, as detailed in the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在第一个例子中，我们从Docker主机挂载一个目录到容器，执行一些基本的文件操作，并验证这些操作在Docker主机上，具体步骤如下所示：
- en: 'First, let''s launch an interactive container with the `-v` option of the `docker
    run` subcommand to mount `/tmp/hostdir` of the Docker host directory to `/MountPoint`
    of the container:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`docker run`子命令的`-v`选项启动一个交互式容器，将Docker主机的`/tmp/hostdir`目录挂载到容器的`/MountPoint`目录：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If `/tmp/hostdir` is not found on the Docker host, the Docker Engine will create
    the directory per se. However, the problem is that the system-generated directory
    cannot be deleted using the `-v` option of the `docker rm` subcommand.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Docker主机上找不到`/tmp/hostdir`，Docker引擎将会创建该目录。然而，问题是，系统生成的目录无法通过`docker rm`子命令的`-v`选项删除。
- en: 'Having successfully launched the container, we can check the presence of `/MountPoint`
    using the `ls` command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功启动容器后，我们可以使用`ls`命令检查`/MountPoint`的存在：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can proceed to check the mount details using the `mount` command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用`mount`命令检查挂载详细信息：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are going to validate `/MountPoint`, change to the `/MountPoint` directory
    using the `cd` command, create a few files using the `touch` command, and list
    the files using the `ls` command, as shown in the following script:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将验证`/MountPoint`，使用`cd`命令切换到`/MountPoint`目录，使用`touch`命令创建一些文件，并使用`ls`命令列出这些文件，具体操作如下脚本所示：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It might be worth the effort to verify the files in the `/tmp/hostdir` Docker
    host directory using the `ls` command on a new Terminal, as our container is running
    in an interactive mode on the existing Terminal:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的终端，您可能需要验证`/tmp/hostdir` Docker主机目录中的文件，使用`ls`命令查看，因为我们的容器是在现有终端的交互模式下运行的：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see the same set of files, as we saw in step 4\. However, you might
    have noticed the difference in the timestamp of the files. This time difference
    is due to the time zone difference between the Docker host and the container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到与第4步中相同的文件集。然而，您可能已经注意到文件时间戳的差异。这个时间差是由于Docker主机和容器之间的时区差异造成的。
- en: 'Finally, let''s run the `docker inspect` subcommand with the `4a018d99c133`
    container ID as an argument to see whether the directory mapping is set up between
    the Docker host and the container mount point, as shown in the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们运行`docker inspect`子命令，并将`4a018d99c133`容器ID作为参数，查看是否设置了Docker主机和容器挂载点之间的目录映射，具体操作如下命令所示：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Apparently, in the preceding output of the `docker inspect` subcommand, the
    `/tmp/hostdir` directory of the Docker host is mounted on the `/MountPoint` mount
    point of the container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在前面的`docker inspect`子命令输出中，Docker主机的`/tmp/hostdir`目录被挂载到容器的`/MountPoint`挂载点上。
- en: 'For the second example, we will mount a file from the Docker host to a container,
    update the file from the container, and verify those operations from the Docker
    host, as detailed in the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将从Docker主机挂载一个文件到容器，更新容器中的文件，并按照以下步骤从Docker主机验证这些操作：
- en: 'In order to mount a file from the Docker host to the container, the file must
    preexist in the Docker host. Otherwise, the Docker Engine will create a new directory
    with the specified name and mount it as a directory. We can start by creating
    a file on the Docker host using the `touch` command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将文件从Docker主机挂载到容器中，该文件必须先在Docker主机上存在。否则，Docker引擎会创建一个指定名称的新目录，并将其作为目录挂载。我们可以通过使用`touch`命令在Docker主机上创建一个文件来开始：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Launch an interactive container with the `-v` option of the `docker run` subcommand
    to mount the `/tmp/hostfile.txt` Docker host file to the container as `/tmp/mntfile.txt`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`子命令的`-v`选项启动一个交互式容器，将Docker主机上的`/tmp/hostfile.txt`文件挂载到容器的`/tmp/mntfile.txt`：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Having successfully launched the container, now let''s check the presence of
    `/mntfile.txt` using the `ls` command:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功启动容器后，现在让我们使用`ls`命令检查`/mntfile.txt`的存在：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, proceed to check the mount details using the `mount` command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`mount`命令继续检查挂载详细信息：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, update some text to `/mntfile.txt` using the `echo` command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`echo`命令将一些文本更新到`/mntfile.txt`：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Meanwhile, switch to a different Terminal in the Docker host, and print the
    `/tmp/hostfile.txt` Docker host file using the `cat` command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，切换到Docker主机的另一个终端，使用`cat`命令打印`/tmp/hostfile.txt`的内容：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, run the `docker inspect` subcommand with the `d23a15527eeb` container
    ID as it''s argument to see the file mapping between the Docker host and the container
    mount point:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`docker inspect`子命令，并以`d23a15527eeb`容器ID作为参数，查看Docker主机与容器挂载点之间的文件映射：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the preceding output, it is evident that the `/tmp/hostfile.txt` file from
    the Docker host is mounted as `/mntfile.txt` inside the container.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看出，Docker主机中的`/tmp/hostfile.txt`文件已作为`/mntfile.txt`挂载到容器内。
- en: For the last example, we will create a Docker volume and mount a named data
    volume to a container. In this example, we are not going to run the verification
    steps as we did in the previous two examples. However, you are encouraged to run
    the verification steps we laid out in the first example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个示例，我们将创建一个Docker卷并将命名数据卷挂载到容器中。在这个示例中，我们不会像前两个示例那样进行验证步骤。然而，建议你按照第一个示例中的验证步骤进行操作。
- en: 'Create a named data volume using the `docker volume create` subcommand, as
    shown here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker volume create`子命令创建一个命名数据卷，如下所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, launch an interactive container with the `-v` option of the `docker run`
    subcommand to mount `namedvol` a named data value to `/MountPoint` of the container:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`docker run`子命令的`-v`选项启动一个交互式容器，将名为`namedvol`的数据卷挂载到容器的`/MountPoint`：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: During the launch of the container, Docker Engine creates `namedvol` if it is
    not created already.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器启动过程中，若`namedvol`还未创建，Docker引擎会创建它。
- en: Having successfully launched the container, you can repeat the verification
    steps 2 to 6 of the first example and you will find the same output pattern in
    this example as well.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功启动容器后，你可以重复第一示例中第2到第6步的验证步骤，你会发现这个示例也会有相同的输出模式。
- en: The practicality of host data sharing
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机数据共享的实用性
- en: 'In the previous chapter, we launched an HTTP service in a Docker container.
    However, if you remember correctly, the log file for the HTTP service is still
    inside the container, and it cannot be accessed directly from the Docker host.
    Here, in this section, we elucidate the procedure of accessing the log files from
    the Docker host in a step-by-step manner:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在Docker容器中启动了一个HTTP服务。然而，如果你记得的话，HTTP服务的日志文件仍然在容器内部，无法直接从Docker主机访问。在本节中，我们将逐步阐明从Docker主机访问日志文件的过程：
- en: 'Let''s begin with launching an Apache2 HTTP service container by mounting the
    `/var/log/myhttpd` directory of the Docker host to the `/var/log/apache2` directory
    of the container, using the `-v` option of the `docker run` subcommand. In this
    example, we are leveraging the `apache2` image, which we had built in the previous
    chapter, by invoking the following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从启动一个Apache2 HTTP服务容器开始，通过使用`docker run`子命令的`-v`选项，将Docker主机上的`/var/log/myhttpd`目录挂载到容器的`/var/log/apache2`目录。在这个示例中，我们利用了在上一章中构建的`apache2`镜像，执行以下命令：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you recall the `Dockerfile` in [Chapter 6](../Text/Ch06.xhtml), *Running
    Services in a Container*, the `APACHE_LOG_DIR` environment variable is set to
    the `/var/log/apache2` directory, using the `ENV` instruction. This will make
    the Apache2 HTTP service to route all log messages to the `/var/log/apache2` data
    volume.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回忆起[第6章](../Text/Ch06.xhtml)中的`Dockerfile`，*在容器中运行服务*，`APACHE_LOG_DIR`环境变量通过`ENV`指令设置为`/var/log/apache2`目录。这将使得Apache2
    HTTP服务将所有日志信息路由到`/var/log/apache2`数据卷。
- en: 'Once the container is launched, we can change the directory to `/var/log/myhttpd`
    on the Docker host:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器启动，我们可以切换到Docker主机上的`/var/log/myhttpd`目录：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Perhaps, a quick check of the files present in the `/var/log/myhttpd` directory
    is appropriate here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或许，这里快速检查一下`/var/log/myhttpd`目录中的文件是合适的：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `access.log` file contains all the access requests handled by the
    Apache2 HTTP server. The `error.log` file is a very important log file, where
    our HTTP server records the errors it encounters while processing any HTTP requests.
    The `other_vhosts_access.log` file is the virtual host log, which will always
    be empty in our case.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`access.log`文件包含了所有由Apache2 HTTP服务器处理的访问请求。`error.log`文件是一个非常重要的日志文件，记录了我们的HTTP服务器在处理任何HTTP请求时遇到的错误。`other_vhosts_access.log`文件是虚拟主机日志，在我们的案例中，它将始终为空。
- en: 'We can display the content of all the log files in the `/var/log/myhttpd` directory
    using the `tail` command with the `-f` option:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用带有`-f`选项的`tail`命令来显示`/var/log/myhttpd`目录中所有日志文件的内容：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `tail -f` command will run continuously and display the content of the files,
    as soon as they get updated. Here, both `access.log` and `other_vhosts_access.log`
    are empty, and there are a few error messages on the `error.log` file. Apparently,
    these error logs are generated by the HTTP service running inside the container.
    The logs are then stocked in the Docker host directory, which is mounted during
    the launch of the container.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail -f`命令将持续运行，并显示文件的内容，一旦它们被更新。在这里，`access.log`和`other_vhosts_access.log`都为空，而`error.log`文件中有一些错误信息。显然，这些错误日志是由容器内运行的HTTP服务生成的。日志随后被存储在Docker主机目录中，该目录在容器启动时被挂载。'
- en: 'As we continue to run `tail -f *`, let''s connect to the HTTP service from
    a web browser running inside the container, and observe the log files:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续运行`tail -f *`时，让我们从容器内部的网页浏览器连接到HTTP服务，并观察日志文件：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The HTTP service updates the `access.log` file, which we can manipulate from
    the host directory mounted through the `-v` option of the `docker run` subcommand.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务会更新`access.log`文件，我们可以通过`docker run`子命令的`-v`选项从挂载的主机目录进行操作。
- en: Sharing data between containers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器之间共享数据
- en: In the previous section, you learned how seamlessly the Docker Engine enables
    data sharing between the Docker host and the container. Although it is a very
    effective solution for most of the use cases, there are use cases wherein you
    will have to share data between one or more containers. The Docker's prescription
    to address this use case is to mount the data volume of one container to other
    containers using the `--volume-from` option of the `docker run` subcommand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你学到了Docker引擎如何无缝地实现Docker主机和容器之间的数据共享。尽管这是大多数使用案例的非常有效的解决方案，但也有一些使用场景需要在一个或多个容器之间共享数据。为了解决这种情况，Docker提供的方案是使用`docker
    run`子命令的`--volume-from`选项，将一个容器的数据卷挂载到其他容器中。
- en: Data-only containers
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅数据容器
- en: 'Before Docker introduced the top-level volume management feature, the data-only
    container was the recommended approach to achieve data persistency. It is worth
    understanding data-only containers because you will find many implementations
    that are based on data-only containers. The prime responsibility of a data-only
    container is to preserve the data. Creating a data-only container is very similar
    to the method illustrated in the *Data volume* section. In addition, the containers
    are named explicitly for other containers to mount the data volume using the container''s
    name. Besides, the container''s data volumes are accessible from other containers
    even when the data-only containers are in the stopped state. The data-only containers
    can be created in two ways, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 引入顶层卷管理功能之前，数据专用容器是实现数据持久性的推荐方法。了解数据专用容器是值得的，因为你会发现许多基于数据专用容器的实现。数据专用容器的主要职责是保留数据。创建数据专用容器与*数据卷*部分中展示的方法非常相似。此外，容器会显式命名，方便其他容器通过容器名称挂载数据卷。而且，即使数据专用容器处于停止状态，容器的数据卷仍然可以被其他容器访问。数据专用容器可以通过两种方式创建，如下所示：
- en: During the launch of the container by configuring the data volume and the container's
    name
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动容器时，通过配置数据卷和容器的名称来实现。
- en: Data volume can also be inscribed with `Dockerfile` during image-building, and
    later, the container can be named during the container's launch
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷也可以在构建镜像时通过`Dockerfile`进行配置，之后容器启动时可以指定容器名称。
- en: 'In the following example, we are launching a data-only container by configuring
    the container launch with the `-v` and `--name` options of the `docker run` subcommand,
    as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过配置`docker run`子命令的`-v`和`--name`选项来启动数据专用容器，如下所示：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the container is launched from the `busybox` image, which is widely used
    for its smaller footprint. Here, we choose to execute the `/bin/true` command
    because we don't intend to do any operations on the container. Therefore, we named
    the container `datavol` using the `--name` option and created a new `/DataMount`
    data volume using the `-v` option of the `docker run` subcommand. The `/bin/true`
    command exits immediately with the `0` exit status, which in turn will stop the
    container and continue to be in the stopped state.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，容器是从`busybox`镜像启动的，该镜像因其较小的占用空间而广泛使用。在此，我们选择执行`/bin/true`命令，因为我们不打算在容器中进行任何操作。因此，我们使用`--name`选项将容器命名为`datavol`，并使用`docker
    run`子命令的`-v`选项创建了一个新的`/DataMount`数据卷。`/bin/true`命令立即以`0`退出状态退出，从而停止容器，并继续保持停止状态。
- en: Mounting data volume from other containers
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他容器挂载数据卷
- en: The Docker Engine provides a nifty interface to mount (share) the data volume
    from one container to another. Docker makes this interface available through the
    `--volumes-from` option of the `docker run` subcommand. The `--volumes-from` option
    takes a container name or container ID as its input and automatically mounts all
    the data volumes available on the specified container. Docker allows you to mount
    multiple containers with data volume using the `--volumes-from` option multiple
    times.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎提供了一个便捷的接口，用于将一个容器的数据卷挂载（共享）到另一个容器。Docker 通过`docker run`子命令的`--volumes-from`选项提供这个接口。`--volumes-from`选项接受容器名称或容器
    ID 作为输入，并自动挂载指定容器上的所有数据卷。Docker 允许你使用`--volumes-from`选项多次挂载多个容器的数据卷。
- en: 'Here is a practical example that demonstrates how to mount data volume from
    another container and showcases the data volume mount step by step:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实际示例，展示了如何从另一个容器挂载数据卷，并一步步演示数据卷挂载过程：
- en: 'We begin with launching an interactive Ubuntu container by mounting the data
    volume from the data-only container (`datavol`), which we launched in the previous
    section:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先启动一个交互式的 Ubuntu 容器，并从上节中启动的数据专用容器（`datavol`）挂载数据卷：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now from the container''s prompt, let''s verify the data volume mounts using
    the `mount` command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从容器的提示符开始，让我们使用`mount`命令验证数据卷挂载：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we successfully mounted the data volume from the `datavol` data-only container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们成功地从`datavol`数据专用容器挂载了数据卷。
- en: 'Next, we need to inspect the data volume of this container from another Terminal
    using the `docker inspect` subcommand:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`docker inspect`子命令，从另一个终端检查此容器的数据卷：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Evidently, the data volume from the `datavol` data-only container is mounted
    as if they were mounted directly on to this container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，来自`datavol`数据-only 容器的数据卷被挂载，就像它们直接挂载到此容器一样。
- en: 'We can mount a data volume from another container and also showcase the mount
    points. We can make the mounted data volume to work by sharing data between containers
    using the data volume, as demonstrated here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从另一个容器挂载数据卷，并展示挂载点。通过使用数据卷在容器之间共享数据，我们可以使挂载的数据显示工作，正如这里所示：
- en: 'Let''s reuse the container that we launched in the previous example and create
    a `/DataMount/testfile` file in the `/DataMount` data volume by writing some text
    to the file, as shown here:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重用在前一个示例中启动的容器，并通过向文件中写入一些文本，在`/DataMount`数据卷中创建`/DataMount/testfile`文件，如下所示：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Just spin off a container to display the text that we wrote in the previous
    step, using the `cat` command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需启动一个容器，使用`cat`命令显示我们在上一步中写入的文本：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is the typical output of the preceding command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令的典型输出：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Evidently, the preceding `Data Sharing between Container` output of our newly
    containerized `cat` command is the text that we have written in `/DataMount/testfile`
    of the `datavol` container in step 1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前述`容器之间的数据共享`输出来自我们新创建的容器化`cat`命令，它是我们在步骤1中写入`datavol`容器`/DataMount/testfile`的文本。
- en: 'Cool, isn''t it? You can share data seamlessly between containers by sharing
    the data volumes. Here, in this example, we used data-only containers as the base
    container for data sharing. However, Docker allows us to share any type of data
    volumes and to mount data volumes one after another, as depicted here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 酷吧？你可以通过共享数据卷无缝地在容器之间共享数据。在这个示例中，我们使用数据-only 容器作为数据共享的基础容器。然而，Docker 允许我们共享任何类型的数据卷，并将数据卷一个接一个地挂载，正如这里所示：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, in the `vol1` container, we mounted the data volume from the `datavol`
    container. Then, in the `vol2` container, we mounted the data volume from the
    `vol1` container, which is eventually from the `datavol` container.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vol1`容器中，我们从`datavol`容器挂载了数据卷。然后，在`vol2`容器中，我们从`vol1`容器挂载了数据卷，而该数据卷最终来自`datavol`容器。
- en: The practicality of data sharing between containers
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器之间数据共享的实用性
- en: 'Earlier in this chapter, you learned the mechanism of accessing the log files
    of the Apache2 HTTP service from the Docker host. Although it was fairly convenient
    to share data by mounting the Docker host directory to a container, later we came
    to know that data can be shared between containers by just using data volumes.
    So here, we are bringing in a twist to the method of the Apache2 HTTP service
    log handling by sharing data between containers. To share log files between containers,
    we will spin off the following containers as enlisted in the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你学习了如何从 Docker 主机访问 Apache2 HTTP 服务的日志文件。尽管通过挂载 Docker 主机目录到容器来共享数据非常方便，但后来我们了解到，容器之间可以通过仅使用数据卷来共享数据。因此，在这里，我们通过容器之间共享数据来改变
    Apache2 HTTP 服务日志处理的方法。为了在容器之间共享日志文件，我们将根据以下步骤启动以下容器：
- en: First, a data-only container that will expose the data volume to other containers.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个数据-only 容器，将数据卷暴露给其他容器。
- en: Then, an Apache2 HTTP service container leveraging the data volume of the data-only
    container.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个利用数据-only 容器数据卷的 Apache2 HTTP 服务容器。
- en: A container to view the log files generated by our Apache2 HTTP service.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于查看由 Apache2 HTTP 服务生成的日志文件的容器。
- en: If you are running any HTTP service on the `80` port number of your Docker host
    machine, pick any other unused port number for the following example. If not,
    first stop the HTTP service, then proceed with the example in order to avoid any
    port conflict.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Docker 主机的`80`端口运行任何 HTTP 服务，请为以下示例选择一个未使用的端口。如果没有，请首先停止 HTTP 服务，然后继续示例，以避免端口冲突。
- en: 'Now, we''ll meticulously walk you through the steps to craft the respective
    images and launch the containers to view the log files:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将细致地带你一步步完成制作相应镜像并启动容器以查看日志文件的过程：
- en: 'Here, we begin with crafting a `Dockerfile` with the `/var/log/apache2` data
    volume using the `VOLUME` instruction. The `/var/log/apache2` data volume is a
    direct mapping to `APACHE_LOG_DIR`, the environment variable set in the `Dockerfile`
    in [Chapter 6](../Text/Ch06.xhtml), *Running Services in a Container*, using the
    `ENV` instruction:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们开始使用 `VOLUME` 指令在 `Dockerfile` 中创建 `/var/log/apache2` 数据卷。这个 `/var/log/apache2`
    数据卷直接映射到 `APACHE_LOG_DIR`，这是在[第六章](../Text/Ch06.xhtml)中通过 `ENV` 指令设置的环境变量，*在容器中运行服务*：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Since this `Dockerfile` is crafted to launch data-only containers, the default
    execution command is set to `/bin/true`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个 `Dockerfile` 是为了启动仅数据容器而设计的，因此默认执行命令被设置为 `/bin/true`。
- en: 'We will continue to build a Docker image with the `apache2log` name from the
    preceding `Dockerfile` using `docker build`, as presented here:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用 `docker build` 从前面的 `Dockerfile` 构建一个名为 `apache2log` 的 Docker 镜像，如下所示：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Launch a data-only container from the `apache2log` image using the `docker
    run` subcommand and name the resulting container `log_vol`, using the `--name`
    option:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker run` 子命令从 `apache2log` 镜像启动一个仅数据容器，并使用 `--name` 选项将生成的容器命名为 `log_vol`：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Acting on the preceding command, the container will create a data volume in
    `/var/log/apache2` and move it to a stop state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述命令后，容器将在 `/var/log/apache2` 中创建一个数据卷，并将其移动到停止状态。
- en: 'Meanwhile, you can run the `docker ps` subcommand with the `-a` option to verify
    the container''s state:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此同时，您可以使用 `docker ps` 子命令并加上 `-a` 选项来验证容器的状态：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As per the output, the container exits with the `0` exit value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，容器以 `0` 的退出值退出。
- en: 'Launch the Apache2 HTTP service using the `docker run` subcommand. Here, we
    are reusing the `apache2` image we crafted in [Chapter 6](../Text/Ch06.xhtml),
    *Running Services in a Container*. Besides, in this container, we will mount the
    `/var/log/apache2` data volume from `log_vol`, the data-only container that we
    launched in step 3, using the `--volumes-from` option:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker run` 子命令启动 Apache2 HTTP 服务。在这里，我们将重用在[第六章](../Text/Ch06.xhtml)中构建的
    `apache2` 镜像，*在容器中运行服务*。此外，在这个容器中，我们将使用 `--volumes-from` 选项从第 3 步启动的仅数据容器 `log_vol`
    挂载 `/var/log/apache2` 数据卷：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the successful launch of the Apache2 HTTP service with the `/var/log/apache2`
    data volume mounted from `log_vol`, we can access the log files using transient
    containers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功启动带有从 `log_vol` 挂载的 `/var/log/apache2` 数据卷的 Apache2 HTTP 服务后，我们可以通过临时容器访问日志文件。
- en: 'Here, we are listing the files stored by the Apache2 HTTP service, using a
    transient container. This transient container is spun off by mounting the `/var/log/apache2`
    data volume from `log_vol`, and the files in `/var/log/apache2` are listed using
    the `ls` command. Further, the `--rm` option of the `docker run` subcommand is
    used to remove the container once it is done executing the `ls` command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们列出了由 Apache2 HTTP 服务存储的文件，使用了一个临时容器。这个临时容器通过挂载来自 `log_vol` 的 `/var/log/apache2`
    数据卷来启动，并且使用 `ls` 命令列出了 `/var/log/apache2` 中的文件。此外，`docker run` 子命令的 `--rm` 选项用于在执行完
    `ls` 命令后移除容器：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, the error log produced by the Apache2 HTTP service is accessed using
    the `tail` command, as highlighted in the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `tail` 命令访问 Apache2 HTTP 服务生成的错误日志，命令如下所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Avoiding common pitfalls
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免常见的陷阱
- en: Until now, we have discussed how effectively data volumes can be used to share
    data between the Docker host and the containers as well as between containers.
    Data sharing using data volumes is turning out to be a very powerful and essential
    tool in the Docker paradigm. However, it does carry a few pitfalls that are to
    be carefully identified and eliminated. In this section, we make an attempt to
    list out a few common issues associated with data sharing and the ways and means
    to overcome them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了数据卷如何有效地用于在 Docker 主机与容器之间、以及容器之间共享数据。使用数据卷进行数据共享正变得越来越强大且在 Docker
    模式中不可或缺。然而，它也带来了一些需要小心识别并消除的陷阱。在本节中，我们尝试列出一些与数据共享相关的常见问题，并提出解决方法。
- en: Directory leaks
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录泄漏
- en: 'Earlier in the *Data volume* section, you learned that the Docker Engine automatically
    creates directories based on the `VOLUME` instruction in the `Dockerfile` as well
    as the `-v` option of the `docker run` subcommand. We also understood that the
    Docker Engine does not automatically delete these autogenerated directories in
    order to preserve the state of the application(s) run inside the container. We
    can force Docker to remove these directories using the `-v` option of the `docker
    rm` subcommand. This process of manual deletion poses two major challenges enumerated
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在*数据卷*章节中，你已了解Docker引擎会根据`Dockerfile`中的`VOLUME`指令以及`docker run`子命令的`-v`选项自动创建目录。我们还明白，Docker引擎不会自动删除这些自动生成的目录，以保持容器中运行的应用程序的状态。我们可以使用`docker
    rm`子命令的`-v`选项强制Docker删除这些目录。手动删除过程面临两大挑战，分别如下：
- en: '**Undeleted directories:** There can be scenarios where you may intentionally
    or unintentionally choose not to remove the generated directory while removing
    the container.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未删除的目录：** 可能出现某些情况下，你可能有意或无意选择不删除生成的目录，即使在删除容器时。'
- en: '**Third-party images:** Quite often, we leverage third-party Docker images
    that could have been built with the `VOLUME` instruction. Likewise, we might also
    have our own Docker images with `VOLUME` inscribed in it. When we launch containers
    using such Docker images, the Docker Engine will autogenerate the prescribed directories.
    Since we are not aware of the data volume creation, we may not call the `docker
    rm` subcommand with the `-v` option to delete the autogenerated directory.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方镜像：** 我们经常利用可能已使用`VOLUME`指令构建的第三方Docker镜像。同样，我们也可能拥有自己带有`VOLUME`指令的Docker镜像。当我们使用这些Docker镜像启动容器时，Docker引擎会自动生成所需的目录。由于我们无法预知数据卷的创建，因此可能无法使用`docker
    rm`子命令的`-v`选项删除这些自动生成的目录。'
- en: 'In the previously mentioned scenarios, once the associated container is removed,
    there is no direct way to identify the directories whose containers were removed.
    Here are a few recommendations on how to avoid this pitfall:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述场景中，一旦关联的容器被删除，就没有直接方法来识别已删除容器的目录。以下是一些避免此问题的建议：
- en: Always inspect the Docker images using the `docker inspect` subcommand and check
    whether any data volume is inscribed in the image or not.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用`docker inspect`子命令检查Docker镜像，并检查镜像中是否包含任何数据卷。
- en: Always run the `docker rm` subcommand with the `-v` option to remove any data
    volume (directory) created for the container. Even if the data volume is shared
    by multiple containers, it is still safe to run the `docker rm` subcommand with
    the `-v` option because the directory associated with the data volume will be
    deleted only when the last container sharing that data volume is removed.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用`docker rm`子命令的`-v`选项删除为容器创建的任何数据卷（目录）。即使数据卷被多个容器共享，使用`docker rm`子命令的`-v`选项仍然是安全的，因为与数据卷关联的目录仅会在最后一个共享该数据卷的容器被删除时才会被删除。
- en: For any reason, if you choose to preserve the autogenerated directory, you must
    keep a clear record so that you can remove them at a later point.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出于某种原因，你选择保留自动生成的目录，你必须保持清晰的记录，以便稍后能够删除它们。
- en: Implement an audit framework that will audit and find out the directories that
    do not have any container association.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个审计框架，用于审计并找出与任何容器无关的目录。
- en: The undesirable effect of data volume
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据卷的副作用
- en: As mentioned earlier, Docker enables access for us to each data volume in a
    Docker image using the `VOLUME` instruction during the build time. Nevertheless,
    data volumes should never be used to store any data during the build time, otherwise
    it will result in an unwanted effect.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker通过在构建时使用`VOLUME`指令使我们能够访问Docker镜像中的每个数据卷。然而，数据卷不应在构建时用于存储任何数据，否则将导致不良效果。
- en: In this section, we will demonstrate the undesirable effect of using data volume
    during the build by crafting a `Dockerfile`, and then showcase the implication
    by building this `Dockerfile`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将通过编写一个`Dockerfile`展示在构建过程中使用数据卷的副作用，并通过构建此`Dockerfile`来展示其影响。
- en: 'The following are the details of `Dockerfile`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Dockerfile`的详细信息：
- en: 'Build the image using Ubuntu 16.04 as the base image:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ubuntu 16.04作为基础镜像构建镜像：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a `/MountPointDemo` data volume using the `VOLUME` instruction:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`VOLUME`指令创建`/MountPointDemo`数据卷：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RUN`指令在`/MountPointDemo`数据卷中创建一个文件：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Display the file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RUN`指令显示`/MountPointDemo`数据卷中的文件：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Proceed to build an image from this `Dockerfile` using the `docker build` subcommand,
    as shown here:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`子命令从这个`Dockerfile`构建镜像，如下所示：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding output of the `docker build` subcommand, you would have noticed
    that the build fails in step 3 because it could not find the file created in step
    2\. Apparently, the file that was created in step 2 vanishes when it reaches step
    3\. This undesirable effect is due to the approach Docker uses to build its images.
    An understanding of the Docker image-building process will unravel the mystery.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker build`子命令的前面输出中，你会注意到构建在第3步失败，因为它找不到第2步中创建的文件。显然，第2步中创建的文件在到达第3步时消失了。这个不希望发生的效果是由于Docker构建镜像的方式造成的。理解Docker的镜像构建过程可以揭开这个谜团。
- en: 'In the build process, for every instruction in a `Dockerfile`, the following
    steps are followed:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，对于`Dockerfile`中的每一条指令，遵循以下步骤：
- en: Create a new container by translating the `Dockerfile` instruction to an equivalent
    `docker run` subcommand.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Dockerfile`指令转换为等效的`docker run`子命令来创建一个新容器。
- en: Commit the newly-created container to an image.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的容器提交为镜像。
- en: Repeat steps 1 and 2 by treating the newly-created image as the base image for
    step 1.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第1步和第2步重复，处理新创建的镜像作为第1步的基础镜像。
- en: When a container is committed, it saves the filesystem of the container and
    deliberately does not save the filesystem of the data volumes. Therefore, any
    data stored in the data volume will be lost in this process. So, never use a data
    volume as a storage during the build process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个容器被提交时，它会保存容器的文件系统，并故意不保存数据卷的文件系统。因此，存储在数据卷中的任何数据将在此过程中丢失。所以，在构建过程中，绝对不要使用数据卷作为存储。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: For enterprise-scale distributed applications to be distinct in their operations
    and outputs, data is the most important instrument and ingredient. With IT containerization,
    the journey takes off in a brisk and bright fashion. IT as well as business software
    solutions are intelligently containerized through the smart leverage of the Docker
    Engine. However, the original instigation is the need for a faster and flawless
    realization of application-aware Docker containers, and hence, the data is tightly
    coupled with the application within the container. However, this closeness brings
    in some real risks. If the application collapses, then the data is also gone.
    Also, multiple applications might depend on the same data and hence, data has
    to be shared across.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业级分布式应用程序来说，数据是最重要的工具和组成部分，使得其操作和输出独具特色。借助IT容器化，整个过程以快速且明亮的方式开始。通过智能利用Docker引擎，IT和商业软件解决方案被高效容器化。然而，最初的动因是需要更快且无误地实现具备应用感知的Docker容器，因此数据与容器内的应用紧密耦合。然而，这种紧密关系也带来了实际的风险。如果应用崩溃，数据也会丢失。此外，多个应用可能依赖于相同的数据，因此数据必须在多个应用之间共享。
- en: In this chapter, we discussed the capabilities of the Docker Engine in facilitating
    the seamless data sharing between the Docker host and container as well as between
    containers. The data volume is being prescribed as the foundational building block
    for enabling data sharing among the constituents of the growing Docker ecosystem.
    In the next chapter, we will explain the concept behind the container orchestration,
    and see how this complicated aspect gets simplified through a few automated tools.
    Orchestration is indispensable for realizing composite containers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论了Docker引擎在促进Docker主机与容器之间以及容器之间无缝共享数据的能力。数据卷被规定为促进日益增长的Docker生态系统中各个组成部分之间共享数据的基础构建块。在下一章，我们将解释容器编排的概念，并看看如何通过一些自动化工具简化这一复杂的方面。编排对于实现复合容器是必不可少的。
