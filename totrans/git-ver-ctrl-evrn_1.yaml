- en: Chapter 1. Breathe Easy – Introduction to Version Control System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We might have wondered numerous times if there is a way we could travel back
    in time to change what had happened in life. Well, as fictional as it sounds,
    you are going to learn a method to perform this travel when it comes to digitized
    files! Yes, you read that right; this chapter is going to introduce you to a system
    that makes this possible. We will begin by giving you a solid conceptual understanding
    about version control with Git.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a version control system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do you need one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How did they evolve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is Git your best bet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter you would be able to visualize how you can better
    handle situations where frequent changes happen on different parts of your digitized
    files. So let's get started right away!
  prefs: []
  type: TYPE_NORMAL
- en: Do you need help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I learned to play computer games even before learning to switch a computer on
    or off, for which I sought an adult's help. The early computer games, which put
    us in awe even at that time, had a few frustrating moments when they wouldn't
    allow us to save our progress. Even if they had a save option it was a single
    save slot at a time, which meant you could only save your progress at the cost
    of your earlier save. This was a shame, because your previous save might have
    been at an exceptionally fun part of the game that you would like to preserve
    now and revisit later some day, or even worse, your present save might have been
    at an unwinnable situation that you want to undo.
  prefs: []
  type: TYPE_NORMAL
- en: Computer games have evolved from this state while our way of working with digitized
    files remains the same. Options like *undo* and *redo* help us momentarily when
    the file that we are working with is still open, but fail to go beyond that. You
    cannot just open a file and start undoing the changes that you have made before
    your last save to get back to an older state.
  prefs: []
  type: TYPE_NORMAL
- en: There are also several situations where we would like to maintain multiple versions
    of the same file. Even the most widely used way of maintaining multiple versions
    of a file by naming the new files sequentially, for example, `Inventory_product_2011-09-21.doc`,
    `System_requirement_specification_v6.xls`, and so on, become a pain as the number
    of versions increases because of the huge volume of the number of files that has
    to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you have experienced or thought about any of these situations and wondered
    whether there is a way to handle this better, you will be rejoicing at the end
    of this chapter. This is where a **version control system** (**VCS**) comes into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: What is a version control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system capable of recording the changes made to a file or a set of files over
    a time period in such a way that it allows us to get back in time from the future
    to recall a specific version of that file, is called a version control system.
  prefs: []
  type: TYPE_NORMAL
- en: To give you a more formal explanation, a version control system is a software
    package that when initiated will monitor your files for changes and allow you
    to tag the changes at different levels so that you can revisit those tagged stages
    whenever needed.
  prefs: []
  type: TYPE_NORMAL
- en: When installed and initiated, this version control system creates a local directory
    at the same place where your files reside, which it uses to manage the entire
    history of the changes made to your files.
  prefs: []
  type: TYPE_NORMAL
- en: Why you need a version control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try answering the following questions with regards to your present system setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Can you maintain multiple versions of the same file under the same name, thus
    avoiding cluttering of files with small differences in their names mentioning
    their versions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have any means of marking a specific portion of your content in the file/files
    that you might need in future before changing them for present needs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you satisfied with the existing scenario where your only failsafe plan for
    getting back your content is copying and pasting the file or group of files in
    a separate folder that contains the word "backup" in its name? And updating it
    regularly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your answer to any of these questions is a big*no*, then that's exactly the
    reason you would probably need a version control system and this book.
  prefs: []
  type: TYPE_NORMAL
- en: If your answers to these questions are *yes*, it means that you have probably
    managed to find roundabout ways to solve these issues. Simple measures could include
    creating a restoration point in latest releases of Windows, which internally stores
    versions of all documents such as your Word, Excel, or PowerPoint files present
    at that point in time as a part of creating your restoration point.
  prefs: []
  type: TYPE_NORMAL
- en: As varied as the potential solutions may be, allow me tell you that version
    control systems will amaze you with their power, simplicity, and ease of use.
    They will allow you to achieve much better results with less than half the time
    and effort that you would normally put into your present solutions.
  prefs: []
  type: TYPE_NORMAL
- en: By using a version control system you have the power to play with the flow of
    changes happening to your documents. Whenever you have to make considerable amount
    of changes to the existing content you can mark those changes as a stage (with
    a tag) that you can revisit later; this serves as a failsafe mechanism just in
    case things didn't go as per your plan and you want to revert the content of the
    document back to a particular older state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figures demonstrate the flow of content creation with and without
    a version control system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why you need a version control system](img/7522_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous figure shows you the flow of a content creation matrix at different
    times spread across sessions. As you can observe in a regular constructive context
    the flow is from *left to right*, meaning you progress with content creation one
    way when it comes to building content on different time periods. In this flow
    you cannot go back to a previous phase from where you can take a different direction
    altogether when compared to what you have already taken.
  prefs: []
  type: TYPE_NORMAL
- en: To explain it using our flow diagram, you cannot go back to any of the intermediate
    stages from the final stage to write an entirely different third paragraph to
    serve a new purpose without any data loss. (You cannot use the undo feature as
    the content was built across time periods, and you cannot undo something once
    you have saved and closed your file.)
  prefs: []
  type: TYPE_NORMAL
- en: Presently we achieve this using the "save as" option, giving the file a different
    name, deleting the third paragraph, and starting to write a new one.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when you use a version control system, it's a **multi-directional
    free flow context**. You mark each and every change you consider important as
    a new stage and proceed with your content creation. This allows you to get back
    to any earlier stages that you have created, without any data loss.
  prefs: []
  type: TYPE_NORMAL
- en: '![Why you need a version control system](img/7522_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the best part is you are not limited by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of hops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of stages between the hops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direction of the hop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means we can, without any concern, jump to and fro between and across stages
    in any direction without any data loss. Now doesn't that sound like the need of
    the hour?
  prefs: []
  type: TYPE_NORMAL
- en: Types of version control systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three types of version control systems available. These are classified
    based on their **mode of operation**:'
  prefs: []
  type: TYPE_NORMAL
- en: Local version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's quickly go through the history in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Local version control system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After understanding that maintaining multiple versions of files by just following
    a file naming convention is highly error prone, a **local version control system**
    was the first successful attempt to solve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Revision control system** (**RCS**) was one of the most popular version control
    systems in this cadre.'
  prefs: []
  type: TYPE_NORMAL
- en: This tool basically works by keeping patch sets (that is, the difference between
    the file's content at progressive stages) using a special format in the version
    tracker that is stored in your local hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: It can then recreate the file's contents exactly at any given point in time
    by adding up all the relevant patches in order and "checking it out" (reproducing
    the content to the user's workplace).
  prefs: []
  type: TYPE_NORMAL
- en: '![Local version control system](img/7522_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tidbits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Version tracker is nothing but a file with its own file format holding structured
    content format through which it can perform its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is put under RCS it creates a version tracker entry that will hold
    details such as RCS configuration for that particular file at the top followed
    by version number, date, time, author, state, branch, and a link to the next stage
    followed by contents of the file in a specially formatted manner. After this process
    your file is deleted!
  prefs: []
  type: TYPE_NORMAL
- en: Retrieval of the file, as stated previously, is done through reconstruction
    of patches.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized version control system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any other software package or concept, as the requirements kept evolving,
    users felt that local version control systems limited their activities.
  prefs: []
  type: TYPE_NORMAL
- en: People were not able to work collaboratively on the same project, as the files
    with their versions are stored in somebody's local computer and were not accessible
    to other people working on the same files.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you solve this problem?
  prefs: []
  type: TYPE_NORMAL
- en: It is solved by keeping the files in a common place (server) that everybody
    has access to from their local machines (clients). Hence, the birth of a **centralized
    version control system**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Centralized version control system](img/7522_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever people want to edit single or multiple files only the last version
    of the files are retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: This setup not only provides access to the files for people who require them
    but also offers visibility on what other people are working towards.
  prefs: []
  type: TYPE_NORMAL
- en: As the files are stored in one single location from which everybody needs to
    share the files, any changes made to the files are automatically shared with other
    individuals as well.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed version control system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you bet big time on one single unit, the probability of losing is also
    high. Yes, there is a high degree of risk involved in using a centralized version
    control system because the users only have the last version of files in their
    system for working purposes; there is a chance you might ultimately lose the entire
    history of your files if the server gets corrupt and if you don't have fail-safe
    procedures implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Now people get confused. You risk everything when you store your entire history
    in one single place using a centralized version control concept; on the contrary
    you lose the power to work collaboratively when you use local version control.
  prefs: []
  type: TYPE_NORMAL
- en: So what do you do?
  prefs: []
  type: TYPE_NORMAL
- en: Exactly! You combine the advantages of both and make a **hybrid system**. And
    that's one of the key reasons why **distributed version control systems** came
    into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Distributed version control system](img/7522_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Distributed version control systems have the advantages of local version control
    systems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making local changes without any concern of full time connectivity to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not relying on a single copy of files stored in the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are combined with the advantages of centralized version control systems,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reusability of work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative working, not relying on history stored on individual machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A distributed version control system is designed to act both ways. It stores
    the entire history of the file/files on each and every machine locally and also
    syncs the local changes made by the user back to the server whenever required
    so that the changes can be shared with others providing a collaborative working
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other advantages in terms of performance, ease of use, and
    administration. It's a general saying that "you name anything that a centralized
    version control system can perform; a distributed version control system can handle
    the same thing and perform much better".
  prefs: []
  type: TYPE_NORMAL
- en: Falling for Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We came across different types of version control systems in the previous section,
    from which we clearly understood that a distributed version control system is
    what will make our lives easy, safe, and secure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there are lots of distributed systems available in the market, so which
    one to choose?
  prefs: []
  type: TYPE_NORMAL
- en: Git is a relatively new software package (April 7, 2005 with its first prototype)
    that was designed from the ground up to avoid flaws that existed in many other
    version control systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linus Torvalds, the man who gave us the Linux kernel, is the proud initiator
    of this project as well. The very architecture of GIT is tailored for better speed,
    performance, flexibility, and usability. When I first heard the previous sentence
    I had the same thought that you have in mind right now: "It talks the talk; can
    it walk the walk?"'
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact there are several live case studies; I got convinced when
    I saw Git handling the complex Linux kernel source code so gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who don't have any idea about Linux kernel or why it's tagged
    complex, just think about approximately 9 million lines of content spread across
    25,000 files subjected to all kinds of content manipulation, travelling back and
    forth, numerous times every day by several hundred developers across the world.
    And still the response time of Git's operations are in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why they trust Git for such challenging tasks and how Git meets their expectations
    is through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Atomicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atomicity is nothing but a property of an operation that appears to occur at
    a single instant between its invocation and its response.
  prefs: []
  type: TYPE_NORMAL
- en: As an example let's take a banking system. When you transfer money from your
    account to another account, the operation is either completed fully or rejected
    meaning either the money gets debited from your account and gets credited to the
    recipient's account or the entire operation gets dropped and no money is debited
    from your account in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: These systems avoid partial completions such as the amount getting debited from
    your account but not getting credited to recipient's account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example would be a seat reservation system in which the following are
    the possible states:'
  prefs: []
  type: TYPE_NORMAL
- en: Both pay and reserve a seat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither pay nor reserve a seat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git creators understood the value of our data, and implemented the same when
    handling content with Git. It ensures there is no data loss or version mismatch
    happening due to partial operations, which increases reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter how good a car's interiors are, if it isn't quick enough, it isn't
    fit enough for racing against time. Git is proven to be manyfold faster than its
    competitors.
  prefs: []
  type: TYPE_NORMAL
- en: Even when handling several million files, an operation performed using Git takes
    only seconds to complete. One of the main reasons for this would be the way Git
    handles your files. Conceptually most other systems (CVS, Subversion, Perforce,
    Bazaar, and so on) look at your data as a set of files and changes made to each
    of them as the version proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a pictorial representation of how other systems handle files
    and their versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance](img/7522_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In contrast, Git sees a relation between your files and works upon it. It takes
    a **snapshot** of the entire set of files instead of storing the difference between
    versions of each file; this contributes to the lightning speed of Git in certain
    operations like reverting your file''s contents to earlier versions (which we
    will see in later chapters). Each time a version is created, a snapshot is taken.
    This doesn''t mean that Git stores multiple replicas of your files; if Git finds
    that there is no change in any of your files'' content, just a reference to that
    file that points to the previous snapshot is stored in the new snapshot, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance](img/7522_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The best part is that Git tries to occupy as little space (again, several times
    less when compared to other version control systems) as possible to maintain version
    histories of your files. A live case study in handling the source code of Mozilla
    Firefox published by Keith P. ([http://keithp.com/blogs/Repository_Formats_Matter/](http://keithp.com/blogs/Repository_Formats_Matter/))
    showed how effectively version control systems utilize space when it comes to
    maintaining the history of your files.
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla's CVS repository was 2.7 GB in size; when imported to Subversion the
    size grew to 8.2 GB, and when put under Git the size got shrunk to 450 MB. For
    a source code of size 350 MB it's fairly nice to have the whole project history
    (from 1998) with just 100 MB more space.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use Git, you can be sure that no one is tampering with your files'
    content. Everything that goes into Git is check-summed using an SHA-1 hash before
    it's stored, and after that it is referred to using that checksum.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means it''s impossible to change the contents of any file or directory
    without Git knowing about it. The SHA-1 hash used here is a collection of 40 hexadecimal
    characters (a-f and 0-9) which is generated based on the contents of a file or
    directory structure. The following is an example of a hash:'
  prefs: []
  type: TYPE_NORMAL
- en: 9e79e3e9dd9672b37ac9412e9a926714306551fe
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who would like to know more about it, you can hear from the
    very creator, Linus Torvalds, who gives a presentation at Google's tech talk event.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed problems faced in our daily lives when it comes
    to digitized files, followed by exactly addressing those issues and assuring a
    solution to those challenging problems with the help of a version control system.
  prefs: []
  type: TYPE_NORMAL
- en: We also quickly went through the evolution of version control systems and obtained
    a solid understanding of how a distributed version control system can make our
    lives easy.
  prefs: []
  type: TYPE_NORMAL
- en: Then we got introduced to the best-in-class distributed version control system,
    Git, and discussed a few reasons for such a claim with some interesting statistics
    and case studies. This was followed by a view on a few of its internals such as
    atomicity, performance, and security.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done enough ground work, we're ready to get our copy of Git and
    get it running in our system, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
