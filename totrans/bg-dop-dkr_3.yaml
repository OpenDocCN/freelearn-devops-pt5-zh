- en: Chapter 3. Orchestration and Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main motivation behind creating a cluster of Docker hosts is designing for
    high availability. Most, if not all, clustering and orchestration tools, such
    as Docker Swarm and Kubernetes, take advantage of clustering by creating a master-slave
    kind of relationship. This ensures that there is always a node to fall back to
    in case any one node goes down in the environment. While deploying a cluster to
    a cloud provider, there are a couple of technologies you can leverage to ensure
    that your environment is highly available, for example Consul, and also take advantage
    of the native fault-tolerant design of the cloud by deploying masters and nodes
    in separate availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: Lesson Objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain an overview of the Docker Swarm mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Docker engine to create a swarm of Docker engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage services and applications in a swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale services up and down to handle more requests on your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balance a Docker Swarm deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure Docker containers and deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running containers on our local environment is easy and does not require a lot
    of our effort; when it comes to the cloud, we need a different kind of mindset
    and tools to aid us in achieving this. Our environment should be **highly available,
    fault tolerant**, and **easily scalable**. This process of coordinating resources
    and/or containers, resulting in a consolidated workflow, is orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s get familiarized with some of the terms used when it comes to
    orchestration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-engine`: This refers to the Docker bundle or installation we currently
    have on our computers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-machine`: A tool that helps us install Docker on virtual hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Virtual hosts`: These are virtual servers that run under physical hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-swarm`: A clustering tool for Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker host`: A host or server that has Docker set up or installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node`: A Docker host that is connected to a swarm cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cluster`: A group of Docker hosts or nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Replica`: A duplicate or number of duplicates of an instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`: A defined operation to be run on nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`: A group of tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the most common terms throughout the lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-engine`: running Docker on our computers;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-machine`: A tool or CLI that helps us install Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Virtual hosts`: A host or server running on a physical host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-swarm:`A clustering tool for Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Docker host`: Any server or host running Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node`: This refers to any host bound to a swarm cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cluster`: A group of managed and controlled hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Replica`: A duplicate of other running hosts for various tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`: Operations like install, upgrade, or remove.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`: Multiple tasks define a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are at least conversant with the terms above, we are ready to implement
    a Docker Swarm orchestration flow using `docker-machine`.
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Swarm is a **clustering** tool for Docker containers. It allows you to
    establish and manage a cluster of Docker **nodes** as a single **virtual system**.
    This means we get to run Docker on multiple hosts on our computers.
  prefs: []
  type: TYPE_NORMAL
- en: We control the swarm cluster through a manager which primarily **handles** and
    **controls** containers. With the swarm manager, you can create a primary manager
    instance and multiple **replica** instances in case the primary fails. This means
    you can have more than one manager in a swarm!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A swarm is created from a manager node, and other Docker machines join the cluster,
    either as worker nodes or manager nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering is important because it creates a group of cooperating systems that
    provide redundancy, creating a fault-tolerant environment. For example, if one
    or more of the nodes goes down, Docker Swarm will fail over to another working
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Swarm manager** carries out the following roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts `docker` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executes commands against the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports high availability; deploys a primary and secondary instance which can
    take over in the event of the primary instance going down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm uses **scheduling** to optimize resources and ensure efficiency
    in the environment. It **assigns containers** to the most appropriate **nodes**.
    This means Docker Swarm will assign containers to the most healthy node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, a node is a **host running Docker**, not a **container.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm can be configured to use any of the following scheduling strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random**: Deploys a new container to a random node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spread**: Swarm deploys a new container to the node with the least number
    of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binpack**: The binpack strategy involves deploying a new container to the
    node with the highest number of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can download VirtualBox at: [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads):'
  prefs: []
  type: TYPE_NORMAL
- en: '![An Overview of Docker Swarm](img/image03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To simulate a Docker Swarm cluster, we need to install a hypervisor (a hypervisor
    type 2 is a virtual machine manager that is installed as a software application
    on an existing operating system) locally, in this case VirtualBox, that will allow
    us to create multiple hosts running Docker locally via `docker-machine` and then
    add them to the swarm cluster. While deploying to a cloud vendor, this is achieved
    using their compute service, for instance EC2 on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows operating systems, select your OS distribution and you should get
    a download immediately. Run the executable and install VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Engine to Create a Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create our swarm, let''s get a quick overview of the `docker-machine
    cli`. Typing `docker-machine` on your terminal should give you this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Docker Engine to Create a Swarm](img/image03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just below that, we have our list of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Docker Engine to Create a Swarm](img/image03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to always use the `help` option when you need to clarify something,
    that is, `docker-machine stop --help`
  prefs: []
  type: TYPE_NORMAL
- en: To create our first Docker Swarm cluster, we are going to use `docker-machine`
    to create our manager and worker nodes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the first machine, a quick overview of our objectives gives
    us the following: we are going to have four docker-machines, one manager, and
    three workers; they are all running on VirtualBox, thus there are four **virtual
    machines**.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Docker Machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command is used to create a new virtual Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This means our Docker host will be running on **VirtualBox**, but managed and
    controlled by `docker-machine`. The `--driver` option specifies the driver to
    create the machine with. In this case, our driver is **VirtualBox**.
  prefs: []
  type: TYPE_NORMAL
- en: Our command will be `docker-machine create --driver virtualbox manager1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We require the driver in the command because that is our host's foundation,
    meaning our `manager1` machine will be running on VirtualBox as a virtual host.
    There are multiple drivers available from different vendors, but this is the best
    one for demo purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Docker Machines](img/image03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing Created Machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command will provide a listing of all the Docker Machines currently on
    your host and more information such as the state, driver, and so on of the machine:
    `docker-machine ls`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing Created Machines](img/image03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listing our machine is very important as it gives us an update of our machine
    status. We don't really get notified of errors, which at times could build up
    to a fateful event. Before doing some work on a machine, this will give a brief
    overview. A more detailed check can be run through the `docker-machine status`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Worker Machine Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will follow the same process to create three worker machines for our swarm
    cluster, in other words, running `docker-machine create --driver virtualbox <machine_name>`
    three times, passing `worker1, worker2,` and `worker3` as the value for `<machine_name>`
    on each subsequent run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Worker Machine Creation](img/image03_07.jpg)![Worker Machine Creation](img/image03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the last worker node will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Worker Machine Creation](img/image03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After doing so, run `docker-machine ls` and if the creation was successful,
    you will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Worker Machine Creation](img/image03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naming the machines according to their purpose helps us avoid unexpected calls
    to the wrong hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our machines running, it''s time to create our swarm. This
    will be done through the manager node, `manager1`. The following are the steps
    we will take to achieve a full-fledged swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the manager node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the `manager1` node as the manager and advertise its address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the invite address for nodes to join the swarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be using `ssh` for our connection. `ssh` is a secure network protocol
    used to access or connect to hosts or servers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker Machines are controlled via the `docker-machine cli.` Docker Swarm runs
    as a service that bonds all the Docker Machines and unifies them under a manager
    machine, or node. This doesn't mean the machines in a swarm cluster are equal
    or similar in any way, they could all be running different services or operations,
    for example, a database host and a web server. Docker Swarm comes in to help orchestrate
    the hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is used to get the IP address of one or more Docker machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is used to get the IP address of one or more Docker machines.
    The `<machine_name>` is the name or names of the machines whose IP addresses we
    need. In our case, we will use it to get the IP address of the `manager1` node
    as we will need it when initializing swarm mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing our Swarm](img/image03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting to a Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command is used to log into a machine using `SSH:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful connection to our `manager1`, we should get an output that
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to a Machine](img/image03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `ssh protocol` on cloud vendors will require authentication and/or
    authorization through usernames and passwords or `ssh keys`. We will not be going
    deeper into this because this is a demo.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Swarm Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the command to initialize the swarm mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's run this command inside the manager node to initialize a swarm. The `advertise-addr`
    option is used to specify the address that will be advertised to other members
    of the swarm for API access and networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, its value is the `manager IP address` whose value we got from
    running the `docker-machine ip manager1` earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned earlier that Docker Swarm is a service that bonds and orchestrates
    all machines through a manager node. For this to happen, Docker Swarm lets us
    advertise the cluster through the address of the manager, by including `advertise-addr`
    in the `docker swarm init` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing Swarm Mode](img/image03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of running the command shows us that our node is now a manager!
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice we also have two commands: one should allow us to invite other nodes
    to the cluster and the other to add another manager to the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When designing for high availability, it is recommended to have more than one
    manager node that will take over in the case of a failure on the primary manager
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure you save two commands listed in the output as they will be useful in
    adding other hosts in the swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Workers to our Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command is used to add swarm workers`:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before we can add our workers to the swarm, we will need to connect to them,
    through `ssh.`
  prefs: []
  type: TYPE_NORMAL
- en: We achieve this by running `docker-machine ssh <node_name>` and then running
    the invite command we got from the `manager1 node.`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `docker-machine` command can be run from any directory and will always work
    with the created machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will exit the manager node, using the `exit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Workers to our Swarm](img/image03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we connect to a worker node via `ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Workers to our Swarm](img/image03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we add the node to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Workers to our Swarm](img/image03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing a Cluster's Status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use this command to view the status of our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this command to view the status of our cluster. This command is run
    on the manager node and displays all the nodes in our cluster and their status
    and availability. Running this on our manager node shows output similar to that
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a Cluster''s Status](img/image03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity 1 — Adding Nodes to a Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have a manager node and the node invite command.
  prefs: []
  type: TYPE_NORMAL
- en: To get you conversant with `ssh` and cluster management.
  prefs: []
  type: TYPE_NORMAL
- en: You have been asked to connect to at least two nodes and add them to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ssh` into your first node:![Activity 1 — Adding Nodes to a Cluster](img/image03_18.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the invite command on the node to join the cluster. Remember, we got this
    command when we first initialized our manager node:![Activity 1 — Adding Nodes
    to a Cluster](img/image03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the node, `ssh` into another, and run the command:![Activity 1 — Adding
    Nodes to a Cluster](img/image03_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Ssh` into the manager node to check the cluster status through `docker node
    ls:`![Activity 1 — Adding Nodes to a Cluster](img/image03_21.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing Services and Applications in a Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our cluster is ready, it's time to schedule some services on our cluster.
    As mentioned earlier, the role of the manager node is to accept Docker commands
    and apply them against the cluster. Therefore, we will create the services on
    the manager node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, there really isn't much one can do on worker nodes as they are
    fully under the control of the manager.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command is used to create a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We run this on the manager as earlier alluded to. We are going to be using the
    WordPress example we built in the previous lesson. Since we already have this
    image locally, there will be no hassle pulling it from the hub.
  prefs: []
  type: TYPE_NORMAL
- en: Our replica count is going to be three because we currently have three worker
    nodes; confirm your node number by running `docker node ls`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We do not create a replica count; this introduces the following topics.The
    `-p <host_port>:<container_port>` maps the container to be built on our computer''s
    defined port, against the container port. We do not need to have an equal number
    of replicas as our node number. Other nodes can handle different application layers,
    for example, the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Service](img/image03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We created a web, based on the WordPress image, and mapped the host port `80`
    to the container port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command is used to view the currently running services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command is used to view the currently running services and more information,
    such as the replicas, image, ports, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following output, we can see the service we just started and the associated
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing Services](img/image03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Service Status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command is used to know whether our services are operational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing the service listing will not provide us with all the information we
    need, such as what nodes our service is deployed on. However, we get to know whether
    our services are operational and the errors encountered, if any. When we run this
    on our manager, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service Status](img/image03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Viewing the status is very important. In a situation where we are running upgrades
    or updates on our nodes, running `docker ps` would inform us on the status of
    our nodes. In an ideal Docker Swarm setup, when a node goes down, the manager
    would reallocate traffic to the available nodes, thus it would be a little hard
    noticing downtime, unless monitoring is available. Before working with the nodes,
    always run this to check on the status of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: How Do We Know Our Site is Running?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can verify WordPress is running by opening any of the workers'' IP addresses
    on our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Do We Know Our Site is Running?](img/image03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a screenshot of how WordPress would appear on our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Do We Know Our Site is Running?](img/image03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Opening any of the IP addresses running the WordPress web service, including
    the manager node, will open the same address.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2 — Running Services on a Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have a manager node running.
  prefs: []
  type: TYPE_NORMAL
- en: To get you conversant with service management in a swarm.
  prefs: []
  type: TYPE_NORMAL
- en: You have been asked to add a new `postgres` service to the swarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new node and name it `dbworker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Activity 2 — Running Services on a Swarm](img/image03_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Add the new worker to the swarm:![Activity 2 — Running Services on a Swarm](img/image03_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new database service and name it `db`, using the postgres image as
    the base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a screenshot of the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Activity 2 — Running Services on a Swarm](img/image03_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Verify `postgres` is running through the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Map the `postgres` container running in `dbworker node` to your computer:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![Activity 2 — Running Services on a Swarm](img/image03_30.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Run `docker ps` to list running containers; this should have our `postgres`
    container and the status should be `UP`:![Activity 2 — Running Services on a Swarm](img/image03_31.jpg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit and stop the container through the following:![Activity 2 — Running Services
    on a Swarm](img/image03_32.jpg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling Services Up and Down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the number of requests coming into your application increases or decreases,
    there will be a need to scale the infrastructure. We have recently worked with
    node replicas running the same WordPress installation we made.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That is a very basic example of a production-level setup. Ideally, we would
    need a few more manager nodes and replicas, but since we are running a demo, this
    will be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling involves both the increase and decrease of resources depending on an
    application's traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Our Database Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will scale our database service as an example of how to scale services.
    In a real-world scenario, cloud services such as Google Cloud Platform and Amazon
    Web Services may have automatic scaling services defined, where a number of replicas
    are created and traffic is distributed across the replicas through a service known
    as **load balancing**. We will dig deeper into that in the next activity. First,
    we understand how scaling works from the basics. The command for scaling the database
    is in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To scale the service, pass in the service name we provided when creating the
    service and the number of replicas you want to increase it to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `--detach=false` allows us to view the replication progress.The command
    is `docker service scale <service_name>=<count>:`
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaling Our Database Service](img/image03_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output above, we can see that our `db` service has been replicated.
    We now have two database services running on the `dbworker` node.
  prefs: []
  type: TYPE_NORMAL
- en: How Does Swarm Know Where to Schedule a Service?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We covered scheduling modes earlier; they include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Random
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default scheduling strategy for Docker Swarm is `spread`, which assigns
    a new service to the node with the **least** resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't have extra unassigned nodes on the swarm, the service you want
    to scale will be replicated on the currently running nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The swarm manager will use the spread strategy and allocate according to resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then verify that the action was indeed successful using the `docker
    service ls` command and we can see that the number of replicas is two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Does Swarm Know Where to Schedule a Service?](img/image03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Scaling down is pretty similar to scaling up, only we pass a lower replica
    count than we had before. From the following output, we scale down to one replica
    and verify that the replica count is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Does Swarm Know Where to Schedule a Service?](img/image03_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How Does Swarm Load Balance Requests between Replicas?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A load balancer helps in handling and managing requests in an application. In
    cases where an application handles a lot of requests, which could be 1,000 in
    less than 5 minutes, we would need to have multiple replicas and a load balancer
    on our application, specifically the logical (backend) section. The load balancer
    helps distribute requests and prevent overloading of an instance, eventually leading
    to downtime.
  prefs: []
  type: TYPE_NORMAL
- en: When deploying to production on a cloud platform such as **Google Cloud Platform**
    or **Amazon Web Services**, you can make use of an external load balancer to route
    requests to your swarm hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm includes a built-in routing service that enables each node in the
    swarm to accept incoming connections to a published port, even if there is no
    service running on the node. `postgres` service uses port `5432` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3 — Scaling Services on a Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have a swarm with at least one manager, two services, and three worker
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: To get you conversant with scaling services and replicating nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You have been asked to scale the web service to four replicas and the database
    service to two replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Create three new worker nodes, two for the web service and one for the database
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the manager node and scale the web and database services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm the service replica count using docker service ls; the final result
    should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The WordPress web service should have two replica counts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Postgres database service should have four replica counts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this lesson, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Talked about orchestration and mentioned a few example tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed clustering and why it's important, especially in production-level
    setups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned about virtual hosts by running Docker Machines on VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walked through Docker Swarm and how to create and manage a cluster of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced example services including Wordpress running on our swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gained a high-level understanding of working with the `docker-machine cli`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talked about load balancing and how Docker Swarm manages this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations for getting to the finish line! Here's a recap of the knowledge
    we have gained through the lessons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we have covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Talked about DevOps and how Docker contributes to the workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understood how to template applications on Dockerfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built images and containers and pushed them to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed containers through `docker-compose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how we can orchestrate our applications through Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
