<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor178"/>10</h1>
<h1 id="_idParaDest-179"><a id="_idTextAnchor179"/>Managing Containers Using Ansible</h1>
<p>Since the introduction of containerization, organizations have been able to deploy applications faster and accelerate release cycles with frequent updates and deployments. However, containerizing applications involve more steps compared to traditional server-based deployments. For example, you need to ensure the packaged container image is working as per expectation, security standards are in place, volume mounting is working, secrets are safe inside, and more. When you have more frequent application releases, automating such container build and deployment tasks will help you implement better CI/CD workflows and save time on manual processes. </p>
<p>With the Ansible collections for container management, we can manage the entire life cycle of our containers. This includes building them, pushing them to the registry, scanning them for vulnerabilities, and deploying them.</p>
<p>In this chapter, we will cover the following topics: </p>
<ul>
<li>Managing the container host </li>
<li>Ansible, containers, and CI/CD</li>
<li>Managing containers using Ansible </li>
<li>Building container images using Ansible</li>
<li>Managing multi-container applications using Ansible</li>
</ul>
<p>First, you will learn how to use Ansible to deploy the container engine to the host machine and run containers inside it. Later, you will learn how to manage the container image build and manage it in the container registry.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor180"/>Technical requirements</h1>
<p>You will need the following technical requirements for this chapter: </p>
<ul>
<li>A Linux machine for the Ansible control node (with internet access)</li>
<li>A Linux machine for installing and configuring Docker</li>
<li>Access to a Docker container registry (<code>hub.docker.com</code>)</li>
<li>Basic knowledge about containers and container registries (Docker or Podman)</li>
</ul>
<p>All the Ansible code and playbooks, as well as the commands and snippets, for this chapter can be found in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-10">https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-10</a>.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor181"/>Managing the container host</h1>
<p>Various<a id="_idIndexMarker576"/> types of container software are available, such as <strong class="bold">Docker</strong> and <strong class="bold">Podman</strong>. In this chapter, we will be using Docker to explain and demonstrate container management <a id="_idIndexMarker577"/>using Ansible. We will be using Docker <strong class="bold">Community Edition</strong> (<strong class="bold">CE</strong>), which<a id="_idIndexMarker578"/> is free, though you can use Docker <strong class="bold">Enterprise Edition</strong> (<strong class="bold">EE</strong>) if needed. </p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor182"/>Ansible Docker prerequisites</h2>
<p>To use the <code>docker</code> library, which you can do using <code>Python pip</code> or standard packages managers such as <code>yum</code> (<code>yum install python-docker-py</code>) of <code>dnf</code> if available. If you are using the old version of Python (2.6), then you should install and use the old library called <code>docker-py</code>. </p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/>Installing Docker on the host using Ansible</h2>
<p>Installing Docker <a id="_idIndexMarker580"/>software on a host involves multiple steps and configurations. These steps can be completed manually or we can use the Ansible role available in Ansible Galaxy. We will be using the community Ansible role called <code>geerlingguy.docker</code> (<a href="https://github.com/geerlingguy/ansible-role-docker">https://github.com/geerlingguy/ansible-role-docker</a>), which was created by the well-known Ansible contributor <em class="italic">Jeff Geerling</em>.</p>
<p>We will also use <code>geerlingguy.pip</code> to install the Docker libraries (for example, <code>docker</code>) using Ansible.</p>
<p>Follow these steps to install the Docker software on a Linux machine:</p>
<ol>
<li>Update the inventory with <code>node1</code> under the <code>dockerhost</code> host group (<code>chapter-10/hosts</code>):</li>
</ol>
<div><div><img alt="Figure 10.1 – Configure Docker host in inventory " height="119" src="img/B18383_10_01.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Configure Docker host in inventory</p>
<ol>
<li value="2">Install <code>geerlingguy.docker</code> in the <code>roles</code> directory, as shown in the following <a id="_idIndexMarker581"/>screenshot:</li>
</ol>
<div><div><img alt="Figure 10.2 – Installing Docker role " height="272" src="img/B18383_10_02.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Installing Docker role</p>
<ol>
<li value="3">Create a playbook called <code>Chapter-10/deploy-docker.yaml</code> to install the role and libraries:</li>
</ol>
<div><div><img alt="Figure 10.3 – Using deploy-docker.yaml to install Docker on the host " height="440" src="img/B18383_10_03.jpg" width="1081"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Using deploy-docker.yaml to install Docker on the host</p>
<p>The <code>pip_install_packages</code> variable will be used by the <code>geerlingguy.pip</code> role to install the listed packages using <code>pip</code>.</p>
<ol>
<li value="4">Execute <a id="_idIndexMarker582"/>the playbook to deploy Docker on the host:</li>
</ol>
<div><div><img alt="Figure 10.4 – Execute the playbook to deploy Docker on the host " height="114" src="img/B18383_10_04.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Execute the playbook to deploy Docker on the host</p>
<ol>
<li value="5">Verify that it has been installed. Log into <code>node1</code> and check the details:</li>
</ol>
<div><div><img alt="Figure 10.5 – Verifying the Docker installation " height="512" src="img/B18383_10_05.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Verifying the Docker installation</p>
<p>With <a id="_idIndexMarker583"/>that, Docker has been installed and configured on the host, which means we can start running containers. </p>
<p>Next, you will learn about the capabilities of Ansible for managing containerized applications. </p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor184"/>Ansible, containers, and CI/CD</h1>
<p>Containerizing applications will give you more options for integrating, delivering, and deploying them<a id="_idIndexMarker584"/> since most of the tools support automated builds, tests, and executions. A typical containerized application workflow can be seen in the following diagram:</p>
<div><div><img alt="Figure 10.6 – Typical CI/CD tasks in a Docker-based deployment " height="630" src="img/B18383_10_06.jpg" width="1170"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Typical CI/CD tasks in a Docker-based deployment</p>
<p>Most of the<a id="_idIndexMarker585"/> tasks in the preceding diagram can be automated using Ansible as the Ansible collection for Docker and Podman contains several modules to support building, running, and managing containers on your container host. Either implement the entire workflow using Ansible or use Ansible with our favourite CI/CD tools and execute the tasks more flexibly. You will learn how to integrate Ansible with Jenkins in <em class="italic">Chapter 12</em>, <em class="italic">Integrating Ansible with Your Tools</em>.</p>
<p>In this next section, you will learn how to manage containers using Ansible and manage the container life cycle.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor185"/>Managing containers using Ansible </h1>
<p>The <a id="_idIndexMarker586"/>Ansible collection, <code>community.docker</code> (<a href="https://galaxy.ansible.com/community/docker">https://galaxy.ansible.com/community/docker</a>), contains more than 25 Ansible modules and ~10 plugins for connection, inventory, and more. These modules will help you manage containers, container images, images in the container registry, the Docker network, Docker volumes, Docker swarm, and other container-based operations.</p>
<p>If you are using Podman, then check out the <code>containers.podman</code> collection (<a href="https://galaxy.ansible.com/containers/podman">https://galaxy.ansible.com/containers/podman</a>) in<a id="_idIndexMarker587"/> Ansible Galaxy.</p>
<p>In the upcoming sections, you will learn how to build, start, and manage containers using Ansible.</p>
<p>Installing the Ansible Docker collection</p>
<p>Installing a <a id="_idIndexMarker588"/>collection is straightforward, as you learned in the previous chapters:</p>
<ol>
<li value="1">Update your <code>ansible.cfg</code> with the collection path:</li>
</ol>
<div><div><img alt="Figure 10.7 – ansible.cfg with the collection and role paths " height="272" src="img/B18383_10_07.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – ansible.cfg with the collection and role paths</p>
<ol>
<li value="2">Install the <code>community.docker</code> Ansible collection:</li>
</ol>
<div><div><img alt="Figure 10.8 – Installing community.docker collection " height="114" src="img/B18383_10_08.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Installing community.docker collection</p>
<ol>
<li value="3">Verify that the collection has been installed in the collection path, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.9 – Docker collection installed in the collection path " height="272" src="img/B18383_10_09.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Docker collection installed in the collection path</p>
<p>If you are<a id="_idIndexMarker589"/> using the Ansible community package, then there might be an old version of the <code>community.docker</code> collection in the default path. This is the reason we are installing the latest version of the collection on our project path (<code>COLLECTIONS_PATHS =</code>):</p>
<div><div><img alt="Figure 10.10 – Docker collection from the default Ansible installation " height="194" src="img/B18383_10_10.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Docker collection from the default Ansible installation</p>
<p>Once the collection is available to use, start using the Docker modules that have been installed. </p>
<p class="callout-heading">Installing an Ansible Collection on a Disconnected Ansible Control Node</p>
<p class="callout">If you are inside a restricted environment (disconnected or no internet), then follow an alternative method to install an Ansible collection and roles: <em class="italic">How to install an Ansible Collection on a disconnected Ansible control node</em> (<a href="https://www.techbeatly.com/how-to-install-an-ansible-collection-on-a-disconnected-ansible-control-node">https://www.techbeatly.com/how-to-install-an-ansible-collection-on-a-disconnected-ansible-control-node</a>).</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor186"/>Starting a Docker container using Ansible</h2>
<p>Use your <a id="_idIndexMarker590"/>own container images or use the existing container images from the public Docker registries such as Docker Hub (<code>https://hub.docker.com</code>), Quay.io (<a href="https://quay.io/repository">https://quay.io/repository</a>), and GitHub Container Registry (<a href="https://ghcr.io">https://ghcr.io</a>). It is also possible to use the container images from private repositories, but you will need to authenticate to the container registries (with a username, password, or tokens) to pull or push the container images. You will learn about registry authentication in the <em class="italic">Building container images using Ansible</em> section.</p>
<p>In this section, you<a id="_idIndexMarker591"/> will learn how to run a Docker container using Ansible. To make this demonstration simple, we will be using the default <code>nginx</code> (<a href="https://hub.docker.com/_/nginx">https://hub.docker.com/_/nginx</a>) container image, but always explore using other container images later:</p>
<ol>
<li value="1">Create a playbook called <code>Chapter-10/container-manage.yaml</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.11 – container-manage.yaml " height="378" src="img/B18383_10_11.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – container-manage.yaml</p>
<p class="callout-heading">Note</p>
<p class="callout">The variables can be configured in different variable files dynamically, such as <code>host_vars</code> or <code>group_vars</code>, or via external variables. The variables that have been used inside the playbook have been provided to demonstrate the use case’s execution.</p>
<ol>
<li value="2">Add a task to start a container using the variable details, as follows:</li>
</ol>
<div><div><img alt="Figure 10.12 – container-manage.yaml – part 2  " height="300" src="img/B18383_10_12.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – container-manage.yaml – part 2 </p>
<p>We will use the <code>container_action</code> variable later to control other actions for the container.</p>
<ol>
<li value="3">Add <a id="_idIndexMarker592"/>another <code>Chapter-10/container-manage.yaml</code> in the repository for the full playbook):</li>
</ol>
<div><div><img alt="Figure 10.13 – container-manage.yaml – using a second play to verify the application running inside the container " height="433" src="img/B18383_10_13.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – container-manage.yaml – using a second play to verify the application running inside the container</p>
<p>(Refer to <a href="B18383_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Ansible Automation – Introduction</em> to see a playbook with multiple plays.)</p>
<ol>
<li value="4">Execute the playbook with <code>NODES</code> set to <code>dockerhost</code>:</li>
</ol>
<div><div><img alt="Figure 10.14 – Execute the playbook on the Docker host " height="114" src="img/B18383_10_14.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Execute the playbook on the Docker host</p>
<ol>
<li value="5">Once<a id="_idIndexMarker593"/> the playbook has been successfully executed, verify the container from the Docker host (<code>node1</code>), as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.15 – An nginx container running on the Docker host " height="168" src="img/B18383_10_15.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – An nginx container running on the Docker host</p>
<p>Here, the <code>nginx</code> container is called <code>web</code> and is exposing the service on port <code>8080</code> of the Docker host.</p>
<ol>
<li value="6">Access the website running inside the <code>nginx</code> container. You need to remember to pass port <code>8080</code> since the Docker port is exposed on <code>8080</code>:</li>
</ol>
<div><div><img alt="Figure 10.16 – The nginx application available after using the curl command " height="378" src="img/B18383_10_16.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – The nginx application available after using the curl command</p>
<ol>
<li value="7">Access the website from a web browser, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.17 – The nginx web server running inside a Docker container deployed using Ansible " height="317" src="img/B18383_10_17.jpg" width="957"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – The nginx web server running inside a Docker container deployed using Ansible</p>
<p>Add<a id="_idIndexMarker594"/> more complex configurations to the container, such as different Docker networks, mounted volumes, and so on. Refer to the documentation at <a href="https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.xhtml">https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.xhtml</a> for various arguments and parameters.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor187"/>Stopping Docker containers using Ansible</h2>
<p>In the CI/CD process, when<a id="_idIndexMarker595"/> you build containers for testing, you also need to take care of the cleanup tasks. Once the tests have been completed, you need to stop the container and delete it as part of housekeeping. Use the same Ansible module, <code>community.docker.docker_container</code>, to handle the entire container life cycle, such as stopping, deleting, and more.</p>
<p>In this section, you will learn how to stop and remove the container we created in the previous exercise. Follow these steps:</p>
<ol>
<li value="1">Update the previous playbook, <code>Chapter-10/container-manage.yaml</code>, and add tasks to the first play, <code>Manage Docker containers</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.18 – Adding tasks to stop and remove the container " height="484" src="img/B18383_10_18.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Adding tasks to stop and remove the container</p>
<ol>
<li value="2">Execute<a id="_idIndexMarker596"/> the playbook and pass <code>container_action=stop</code> as an extra variable:</li>
</ol>
<div><div><img alt="Figure 10.19 - Execute the container-manage.yaml file to stop the container " height="114" src="img/B18383_10_19.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 - Execute the container-manage.yaml file to stop the container</p>
<ol>
<li value="3">On the container host (<code>node1</code>), verify whether any containers are running:</li>
</ol>
<div><div><img alt="Figure 10.20 – The nginx container has been stopped and removed " height="168" src="img/B18383_10_20.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – The nginx container has been stopped and removed</p>
<p>Add more tasks to the playbook, such as for verifying the ports, backing up some configurations from container volumes, and accessing API calls as part of testing, as needed. </p>
<p>In this section, you tested simple container executions using the public container image from Docker Registry. In the next section, you will learn how to build a custom container image with all <a id="_idIndexMarker597"/>the necessary dependencies using Ansible and run containers using custom images.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor188"/>Managing container images using Ansible</h1>
<p>As we<a id="_idIndexMarker598"/> learned from <em class="italic">Figure 10.6</em>, your integration stage will begin when the developers push the code or merge the branches in a Git repository. Call the container build commands directly from your CI/CD tools, such <a id="_idIndexMarker599"/>as <strong class="bold">Jenkins</strong> or <strong class="bold">GitHub Actions</strong>. However, commands<a id="_idIndexMarker600"/> and pipeline tasks are unpredictable, so you will not have much control over the output and results. This is where you can utilize Ansible playbooks as you have more flexibility and control over the build processes and outputs. </p>
<p>In the next few sections, you will learn how to create Docker container registry access, build container images using Ansible, and save the container images in the container registry.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor189"/>Configuring Docker Registry access</h2>
<p>Before<a id="_idIndexMarker601"/> pushing the latest images to the container registries, you need to log into the registry with your credentials. Access Docker Registry using a username and password, but it is a best <a id="_idIndexMarker602"/>practice to use <strong class="bold">Access Tokens</strong> instead of passwords. The following diagram shows how Ansible accesses the container registry to manage container images:</p>
<div><div><img alt="Figure 10.21 – Ansible to Container Registry access " height="540" src="img/B18383_10_21.jpg" width="1019"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Ansible to Container Registry access</p>
<p>For this <a id="_idIndexMarker603"/>demonstration, you will be using Docker Registry. Check out the documentation (refer to the <em class="italic">Container Registry Access Tokens</em> information box) for other registries. Follow these steps:</p>
<ol>
<li value="1">Log in to Docker Hub at <a href="http://hub.docker.com">hub.docker.com</a>.</li>
<li>At the top right, click on your profile name and select <strong class="bold">Account Settings</strong> from the menu.</li>
<li>Select the <strong class="bold">Security</strong> tab.</li>
<li>Click on the <strong class="bold">New Access Token</strong> button and enter a name for your token. After that, select the <strong class="bold">Read, Write, Delete</strong> permission under <strong class="bold">Access permissions</strong> and click <strong class="bold">Generate</strong>:</li>
</ol>
<div><div><img alt="Figure 10.22 – Creating a new access token in Docker Hub " height="475" src="img/B18383_10_22.jpg" width="1016"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Creating a new access token in Docker Hub</p>
<ol>
<li value="5">You will see the instructions and token text on the next screen. Remember to copy and<a id="_idIndexMarker604"/> keep the token safe as this token text will not be visible later. </li>
</ol>
<p class="callout-heading">Container Registry Access Tokens</p>
<p class="callout">To learn more about Access Tokens, please refer to <a href="https://docs.docker.com/docker-hub/access-tokens/">https://docs.docker.com/docker-hub/access-tokens/</a> (Docker Hub) and <a href="https://docs.quay.io/glossary/access-token.xhtml">https://docs.quay.io/glossary/access-token.xhtml</a> (Quay).</p>
<ol>
<li value="6">Create an Ansible Vault file to keep the Docker Registry credentials in, as follows:</li>
</ol>
<div><div><img alt="Figure 10.23 – Using an Ansible Vault file for your Docker Registry credentials " height="194" src="img/B18383_10_23.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – Using an Ansible Vault file for your Docker Registry credentials</p>
<ol>
<li value="7">Add your Docker username and Access Token value to the file and save it:</li>
</ol>
<div><div><img alt="Figure 10.24 – Adding your Docker username and password to the Ansible Vault file " height="168" src="img/B18383_10_24.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Adding your Docker username and password to the Ansible Vault file</p>
<p>These variables<a id="_idIndexMarker605"/> will be used to access Docker Registry in the next sections. It is possible to keep this sensitive information in environment variables or the built-in secret management features of your CI/CD software (such as credentials in Jenkins).</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor190"/>Building container images using Ansible</h2>
<p>As<a id="_idIndexMarker606"/> you may recall, you can use the existing available Docker container images from public registries such as Docker Hub or Quay. But for our application, we need to build container images and use them to deploy the application. </p>
<p>With the help of <code>community.docker.docker_image</code> and other modules, we can easily build container images and push those images to container registries.</p>
<p>Create applications or find sample applications on the internet and use them for practicing further. The following are some options:</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-petclinic">https://github.com/spring-projects/spring-petclinic</a></li>
<li><a href="https://github.com/docker/getting-started/tree/master/app">https://github.com/docker/getting-started/tree/master/app</a></li>
<li><a href="https://github.com/dockersamples/example-voting-app">https://github.com/dockersamples/example-voting-app</a></li>
<li><a href="https://github.com/dockersamples">https://github.com/dockersamples</a></li>
</ul>
<p>In this section, you will containerize a simple Node.js application (<a href="https://github.com/ginigangadharan/nodejs-todo-demo-app">https://github.com/ginigangadharan/nodejs-todo-demo-app</a>) using a Dockerfile. A Dockerfile (<a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a>) is a simple plain text file containing instructions for building the container image. After that, you will use Ansible<a id="_idIndexMarker607"/> to build the container image and push it to Docker Registry. The following diagram shows the steps involved:</p>
<div><div><img alt="Figure 10.25 – Building and managing a container image using Ansible " height="331" src="img/B18383_10_25.jpg" width="1154"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Building and managing a container image using Ansible</p>
<p class="callout-heading">Podman and Containerfiles</p>
<p class="callout">If you are using a different container engine, such as Podman, then check out the respective module documentation and use it accordingly. Podman modules for Ansible can be found at <a href="https://docs.ansible.com/ansible/latest/collections/containers/podman/index.xhtml">https://docs.ansible.com/ansible/latest/collections/containers/podman/index.xhtml</a>, while the Podman build documentation is available at <a href="https://docs.podman.io/en/latest/markdown/podman-build.1.xhtml">https://docs.podman.io/en/latest/markdown/podman-build.1.xhtml</a>. This will help you learn more about Containerfiles.</p>
<p>Access the repository and perform the following steps:</p>
<ol>
<li value="1">Verify the Dockerfile inside the application repository (<a href="https://github.com/ginigangadharan/nodejs-todo-demo-app">https://github.com/ginigangadharan/nodejs-todo-demo-app</a>):</li>
</ol>
<div><div><img alt="Figure 10.26 – Verifying the Dockerfile to build the container image  " height="300" src="img/B18383_10_26.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.26 – Verifying the Dockerfile to build the container image </p>
<p>The Dockerfile contains instructions for building the container image and exposing the application on port <code>3000</code>.</p>
<p>The <a id="_idIndexMarker608"/>repository also contains a simple <strong class="bold">ToDo</strong> application written in <strong class="bold">Node.js</strong> with supported files and directories:</p>
<div><div><img alt="Figure 10.27 – Application repository content " height="300" src="img/B18383_10_27.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.27 – Application repository content</p>
<ol>
<li value="2">Fork this repository and make changes as needed.</li>
<li>Create a playbook called <code>Chapter-10/container-build.yaml</code> and add the required variables to build the container image as follows:</li>
</ol>
<div><div><img alt="Figure 10.28 – Playbook to build the container image " height="535" src="img/B18383_10_28.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.28 – Playbook to build the container image</p>
<p>Using <a id="_idIndexMarker609"/>variables will help you dynamically pass the values to the same playbook for different image build tasks.</p>
<p class="callout-heading">Docker Registry URL</p>
<p class="callout">Note that <a href="https://index.docker.io/v1/">https://index.docker.io/v1/</a> is the default URL for the Docker Hub registry. If you are using a different registry or other private container registries, then find the correct registry URL and use it as <code>container_registry_url</code>.</p>
<p>Also check the included variable file <code>vars/docker-credential.yaml</code>, which contains the Docker Registry username and Access Token (refer to the <em class="italic">Configuring Docker Registry access</em> section in this chapter for more details).</p>
<ol>
<li value="4">Add a task that will create a temporary working directory on the host and check out the application repository. This is to avoid using the default directory names and overwriting issues when the same playbook executes in parallel. You also need to delete the directory at the end of the play as part of housekeeping:</li>
</ol>
<div><div><img alt="Figure 10.29 – Tasks to build the container image " height="618" src="img/B18383_10_29.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.29 – Tasks to build the container image</p>
<ol>
<li value="5">Add a task <a id="_idIndexMarker610"/>to delete the image if it already exists with the same name and tag before creating the new container image. Also add the task for building the container image by providing the working directory path – that is, <code>temp_location.path</code>:</li>
</ol>
<div><div><img alt="Figure 10.30 – Delete and create new container image " height="592" src="img/B18383_10_30.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.30 – Delete and create new container image</p>
<ol>
<li value="6">If you <a id="_idIndexMarker611"/>want to include tasks such as scanning the image, testing the vulnerabilities, and more, they can be included at this stage (or include this as part of the <code>post-build</code> stage in your CI/CD pipeline):</li>
</ol>
<div><div><img alt="Figure 10.31 – Include scanning or testing tasks " height="300" src="img/B18383_10_31.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.31 – Include scanning or testing tasks</p>
<ol>
<li value="7">Now, we need to authenticate to Docker Registry before pushing the image to the repository. Once authenticated, push the image to Docker Registry, as follows:</li>
</ol>
<div><div><img alt="Figure 10.32 – Authenticate to Docker Hub and push the image to the container registry " height="565" src="img/B18383_10_32.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.32 – Authenticate to Docker Hub and push the image to the container registry</p>
<ol>
<li value="8">Optionally, add <a id="_idIndexMarker612"/>the <code>latest</code> tag to the image that will be used when you don’t mention any tag while pulling the image: </li>
</ol>
<div><div><img alt="Figure 10.33 – Add the latest tag to the image and log out from Docker Hub " height="535" src="img/B18383_10_33.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.33 – Add the latest tag to the image and log out from Docker Hub</p>
<p>Also, notice the last task to log out from the container registry. For security reasons, always<a id="_idIndexMarker613"/> log out of Docker Registry once the image has been pushed (or pulled).</p>
<ol>
<li value="9">Finally, delete the temporary working directory as part of the cleanup process:</li>
</ol>
<div><div><img alt="Figure 10.34 – Delete the temporary working directory " height="270" src="img/B18383_10_34.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.34 – Delete the temporary working directory</p>
<ol>
<li value="10">Execute the playbooks and verify the result. Remember to include <code>--ask-vault-password</code> in the command since you have included the Docker credential using Ansible Vault:</li>
</ol>
<div><div><img alt="Figure 10.35 – Execute the playbook to build and push the container image " height="140" src="img/B18383_10_35.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.35 – Execute the playbook to build and push the container image</p>
<ol>
<li value="11">Now, verify the image from multiple places, such as from a Docker host and the Docker Registry GUI (Docker Hub: <a href="https://hub.docker.com/repositories">https://hub.docker.com/repositories</a>).</li>
<li>Check the image on the Docker host (<code>node1</code>):</li>
</ol>
<div><div><img alt="Figure 10.36 – Container image built using Ansible " height="184" src="img/B18383_10_36.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.36 – Container image built using Ansible</p>
<ol>
<li value="13">Also, verify the image in the Docker Hub GUI (<a href="https://hub.docker.com/repositories">https://hub.docker.com/repositories</a>), as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.37 – Docker image in Docker Hub " height="90" src="img/B18383_10_37.jpg" width="1086"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.37 – Docker image in Docker Hub</p>
<ol>
<li value="14">Click on<a id="_idIndexMarker614"/> the container image entry to view more details about the image:</li>
</ol>
<div><div><img alt="Figure 10.38 – Docker image details " height="550" src="img/B18383_10_38.jpg" width="1088"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.38 – Docker image details</p>
<p>Add more details to the image, such as <code>README</code> information about the container image, supported tags, documentation links, and so on.</p>
<p>With that, we have the latest container image ready with our application in the container registry. We can test it with the same <code>Chapter-10/container-manage.yaml</code> playbook. </p>
<p>Follow these steps to run container with new image:</p>
<ol>
<li value="1">Run a new container using the <code>Chapter-10/container-manage.yaml</code> playbook but pass appropriate extra variables such as <code>container_image</code>, <code>container_name</code>, <code>container_port</code>, and <code>container_expose_port</code>, as follows:</li>
</ol>
<div><div><img alt="Figure 10.39 – Run container with different image " height="140" src="img/B18383_10_39.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.39 – Run container with different image</p>
<ol>
<li value="2">Once <a id="_idIndexMarker615"/>the container has been created, verify it on the Docker host (<code>node1</code>), as follows:</li>
</ol>
<div><div><img alt="Figure 10.40 – The ToDo application container deployed using Ansible " height="149" src="img/B18383_10_40.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.40 – The ToDo application container deployed using Ansible</p>
<ol>
<li value="3">Verify the application from a web browser. Remember to add port <code>8081</code>, as shown in the following screenshot, since we used port <code>8081</code> while running the container:</li>
</ol>
<div><div><img alt="Figure 10.41 – Accessing the ToDo app from a web browser " height="243" src="img/B18383_10_41.jpg" width="1047"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.41 – Accessing the ToDo app from a web browser</p>
<ol>
<li value="4">Add some entries and test the application, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.42 – Testing the ToDo application with sample entries " height="341" src="img/B18383_10_42.jpg" width="1043"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.42 – Testing the ToDo application with sample entries</p>
<ol>
<li value="5">Stop the <a id="_idIndexMarker616"/>container as part of housekeeping using the same playbook but by passing the <code>container_action=stop</code> action:</li>
</ol>
<div><div><img alt="Figure 10.43 – Stop container using playbooks " height="168" src="img/B18383_10_43.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.43 – Stop container using playbooks</p>
<p class="callout-heading">Note </p>
<p class="callout">The data you have stored will be lost when you stop and kill the container as you did not mount any volumes for data persistence. Add more configurations and volume details to <code>Chapter-10/container-manage.yaml</code> and enhance your playbook.</p>
<p>In this section, you learned how to handle single containers and container images. But it is possible to handle any number of images and containers using Ansible based on your application stack. In the next section, you will learn how to handle multiple containers using Ansible.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor191"/>Managing multi-container applications using Ansible</h1>
<p>In this <a id="_idIndexMarker617"/>section, you will use the <a id="_idIndexMarker618"/>well-known <strong class="bold">Content Management System</strong> (<strong class="bold">CMS</strong>) application<a id="_idIndexMarker619"/> stack known as WordPress (<a href="https://wordpress.org">https://wordpress.org</a>). The WordPress <a id="_idIndexMarker620"/>application is based on multiple application stacks, including PHP, a web server, and a database. The WordPress application is available as a container image (<a href="https://hub.docker.com/_/wordpress">https://hub.docker.com/_/wordpress</a>). For the database, we will deploy another container using MariaDB (<a href="https://hub.docker.com/_/mariadb">https://hub.docker.com/_/mariadb</a>).</p>
<p>Please refer to the <code>Chapter-10/deploy-wordpress-on-docker.yaml</code> file to see the Ansible playbook for deploying the WordPress CMS using Ansible. Follow these steps:</p>
<ol>
<li value="1">We declared the essential parameters on top of the playbook, as shown in the following screenshot. Remember to store sensitive data such as database usernames and passwords using Ansible Vault (or Credential in Ansible Automation Controller) or other secret management services. These variables are then passed to the container as environment variables and Docker volumes will be created, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.44 – Deploying WordPress using Ansible " height="433" src="img/B18383_10_44.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.44 – Deploying WordPress using Ansible</p>
<ol>
<li value="2">There are two tasks, as shown in the following screenshot. The first task will deploy the MariaDB container, while the second task will deploy the WordPress container:</li>
</ol>
<div><div><img alt="Figure 10.45 – Ansible tasks for deploying the WordPress and MariaDB containers " height="883" src="img/B18383_10_45.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.45 – Ansible tasks for deploying the WordPress and MariaDB containers</p>
<ol>
<li value="3">Execute<a id="_idIndexMarker621"/> the playbook to deploy the WordPress stack with the MariaDB database on <code>node1</code>:</li>
</ol>
<div><div><img alt="Figure 10.46 – Deploy WordPress using Ansible " height="114" src="img/B18383_10_46.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.46 – Deploy WordPress using Ansible</p>
<ol>
<li value="4">On <code>node1</code>, verify the Docker containers and Docker volumes, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.47 – The WordPress and MariaDB containers running on the Docker host " height="378" src="img/B18383_10_47.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.47 – The WordPress and MariaDB containers running on the Docker host</p>
<ol>
<li value="5">Verify<a id="_idIndexMarker622"/> the WordPress application from a browser using port <code>8082</code>, which we have configured to expose. The initial configuration for WordPress will be visible, as shown in the following screenshot. Now, we can configure the WordPress CMS application (<a href="https://wordpress.org/support/article/how-to-install-wordpress/#setup-configuration-file">https://wordpress.org/support/article/how-to-install-wordpress/#setup-configuration-file</a>):</li>
</ol>
<div><div><img alt="Figure 10.48 – The initial WordPress configuration screen " height="832" src="img/B18383_10_48.jpg" width="1177"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.48 – The initial WordPress configuration screen</p>
<p>The playbook can<a id="_idIndexMarker623"/> be enhanced by configuring additional volumes and configurations; please refer to the WordPress installation documentation to implement more automation steps for such use cases (<a href="https://wordpress.org/support/article/how-to-install-wordpress/#setup-configuration-file">https://wordpress.org/support/article/how-to-install-wordpress/#setup-configuration-file</a>).</p>
<p>With that, you have learned that the entire container image life cycle can be automated using Ansible in different stages of your CI/CD pipelines. This will give you more control over building and testing compared to using the native container management features in the available CI/CD tools.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor192"/>Summary</h1>
<p>In this chapter, you learned how to install and configure Docker on a Linux machine using Ansible. Then, you learned how to pull an image from the container registry, and then start that container and stop it using Ansible modules. Finally, you learned how to use Ansible to build container images with a Dockerfile, as well as how to build application content and push a container image to the container registry. You also tested the newly built container images by running a container with Ansible modules. Knowing how to manage containers and container images using Ansible will help you implement better and more efficient CI/CD workflows and pipelines. Instead of struggling with the limited features in the CI/CD tools, utilize the flexibility of Ansible to add more validations, tests, and integrations to the container build process.</p>
<p>In the next chapter, you will learn how to manage containerized applications in Kubernetes and manage other Kubernetes resources and applications using Ansible.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor193"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">Container registry access tokens for Docker Hub</em>: <a href="https://docs.docker.com/docker-hub/access-tokens">https://docs.docker.com/docker-hub/access-tokens</a></li>
<li><em class="italic">Ansible docker-compose module</em>: <a href="https://docs.ansible.com/ansible/latest/collections/community/docker/docker_compose_module.xhtml">https://docs.ansible.com/ansible/latest/collections/community/docker/docker_compose_module.xhtml</a></li>
<li><em class="italic">Docker RUN and environment variables</em>: <a href="https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file">https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file</a></li>
<li><em class="italic">Dockerfile documentation</em>: <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
<li><em class="italic">Top 5 Free Resources to Learn Docker</em>: <a href="https://www.techbeatly.com/top-5-free-resources-to-learn-docker/">https://www.techbeatly.com/top-5-free-resources-to-learn-docker/</a></li>
</ul>
</div>
</div></body></html>