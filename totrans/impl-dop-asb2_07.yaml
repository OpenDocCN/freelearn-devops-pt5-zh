- en: Ansible Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern day encryption solutions have come a long way since the initial concepts
    of encryption were invented and implemented back in the early days of computer
    science. Encryption and security are both hotbed topics within modern mainstream
    news outlets, as notable security breaches have initiated a heightened awareness
    of security fallacies and there has been an increase in guarding of sensitive
    data. With applications and customer's sensitive data moving toward the cloud,
    the necessity for an increased level of control and security is now greater than
    ever.
  prefs: []
  type: TYPE_NORMAL
- en: Modern **Infrastructure as Code** (**IaC**) solutions have paved the way for
    configuration management solutions to be stored within modern source control solutions.
    Managing and tracking infrastructure changes via a source control solution is
    highly valuable as it provides the ability for teams to ensure that IaC solutions
    are tracked through version control, and revisions are notated and backed up.
    In addition to these value points storing Ansible playbook's and related automation
    version control ensures teams can collaborate to create useful automation, Configuration
    Management solutions, and deployment tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating playbook's and storing them within a modern source control solution
    makes a lot of sense and is a best practice. What does not make a lot of sense
    is storing sensitive data within source control. This is because it allows ANYONE
    with access to the source control solution to pry into potentially confidential
    information. Enter Ansible vault. It promises the ability to hide such sensitive
    data, to encrypt what is meant to be encrypted, and continues to allow playbook
    developers to store their playbooks in source control. Awesome right?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discover the Ansible vault. It provides us with a
    secure, easy-to-use solution to encrypt and store sensitive data within our playbook''s
    or in a variables vault file. Specifically, in this chapter, we will cover the
    following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible vault architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic vault usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How data can be encrypted with Ansible vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create, edit, and encrypt variable files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to decrypt files in a secure manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to embed encrypted data within a YAML playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a playbook and decrypting data on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips and tricks to best use Ansible vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Vault Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible vault is designed for playbook developers, system administrators, and
    related personnel to store sensitive data within a playbook, variable file, or
    directory structure. The encryption system employed by Ansible vault is based
    on the **Symmetrical Key Advanced Encryption System** or **AES Symmetrical Key**
    solution. The AES Symmetrical Key encryption provides us with an easy-to-use way
    of using the same key to encrypt data as well as decrypt data. The following diagram
    provides an illustration of **AES Symmetrical Key Encryption**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e2f1f6c-e41f-41e2-b20b-883dfb0b29b4.png)'
  prefs: []
  type: TYPE_IMG
- en: The Ansible vault solution has been designed to provide encryption services
    for any structured data file supported by Ansible. This means we can encrypt `group_vars/,
    AND host_vars/..` inventory variable directories. It also means we can encrypt
    variable files loaded within the `include_vars/vars_files`. As we can see from
    the preceding, the supported supported by Ansible's vault solution is vast. Basically
    in the end it means we can encrypt ANY and ALL data we want using the vault EXCEPT
    playbook's themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Version 2.3 of Ansible includes a feature that supports encrypting single variable
    values within an Ansible YAML file. This is accomplished using the `!vault` tag.
    The result of this special tag allows us to inform Ansible to decrypt the value
    when processing the facts of the file.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the ability to encrypt variables and variable files, the entire
    playbook can be encrypted. More so, Ansible also supports the encryption of binary
    files, data files, and much more. These files can then be decrypted on the fly
    using `copy_file`. In addition to the copy file option, there are many others
    that are supported by Ansible vault. In the next sections, we will look at some
    examples of how to encrypt, decrypt, and rekey vault files on the fly and how
    we can leverage Ansible's vault later in the chapter. Before we dig into that,
    let's take a look at how to use the basic implementation of the Ansible vault
    and how to encrypt, decrypt, and rekey vault files.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Vault Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible vault's most basic implementation is a simple AES Symmetric Key encryption
    solution (as we discussed earlier). The implementation of this is managed through
    the command-line interface, specifically the `ansible-vault` command. Using this
    command, we have the ability to encrypt, decrypt, rekey, and edit vault specific
    files. The syntax of each of these commands along with a description and example
    is provided next.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting an Ansible vault YAML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This command syntax allows us to encrypt the contents of a YAML file. Upon executing,
    it will prompt the user for the key they wish to use in order to encrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `my_vault.yml` file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order to encrypt the file, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command execution is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is encrypted, we can see the encryption via the `cat` command,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86931c42-81c4-4ca8-8f6a-0915ca447659.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This example shows a simple way to encrypt and decrypt data using Ansible vault.
    This tactic is useful from a command line and manual input perspective, but it
    adds a human element to our automation execution that we may not always want.
    Encrypting files can also be done via a single command-line entry, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see that Ansible vault has the option of taking in a
    password file. The `vault_pass.txt` is simply a flat text file that contains the
    Ansible vault password. This command-line instructs Ansible to use the password
    in the text file instead of prompting for a password. This option makes automating
    the vault a lot easier as there is no required human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: To decrypt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `decrypt` option of Ansible vault decrypts the contents of a previously
    encrypted YAML vault file. Upon executing it, Ansible vault will prompt the user
    for the vault password to decrypt the file. Once the password has been inputted,
    Ansible uses AES Symmetric Key encryption to decrypt the file (if the correct
    key was entered). Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with our encrypted file that we created in the previous
    section on encrypting using Ansible vault. A screenshot of the encrypted vault
    file is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d9ba786-67ee-4b23-bb4d-07561b6111b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, decrypt the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the execution of this command would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is decrypted, we can see the decrypted file as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3228a93f-5ea3-4e09-950c-7bd95ab3ece6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to the encryption mechanism we talked about earlier, we can also specify
    the vault key in the keyfile form on the command line. This will help us better
    automate things and remove the need for us to manually type the password. An example
    is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To rekey an Ansible vault file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changing the key that Ansible vault uses to encrypt/decrypt a vault file is
    a fairly simplistic task. It simply involves using the `rekey` operator within
    the Ansible vault command-line context. In the following example, the `rekey`
    command syntax is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running the previous command, we will be prompted for the existing key
    and a new key. The output (if the `rekey` was a success) should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfb00d6b-d17e-4c16-af3e-fb9dc56df8ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Editing in place
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ansible vault solution provides a handy way of editing vault encrypted
    information on the fly using the default system editor. Within the context of
    a Linux operating system, the default editor can be set on the command line using
    the following command syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we set the editor to be `vi`; however, you can set it
    to any editor of your preference [`nano`, `pico`, `vi`, `vim`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Usually on Linux systems, the default editor is usually set to `vi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the default editor in place, we can edit our Ansible vault
    data by issuing the `edit` command option in conjunction with the `ansible-vault`
    command. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Decrypting the vault when running a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting, decrypting, and rekeying Ansible vault data manually is one thing;
    using this information on the fly within the context of playbook execution is
    what we really want to achieve. In this section, we will cover how to decrypt
    the Ansible vault encrypted data within the context of playbook execution.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to automatically decrypt the vault data embedded within a
    playbook or variables file. The first is by storing the vault key within a flat
    text file and then passing this key file to the `ansible-playbook` command. The
    second is to use the `--ask-vault-pass` command-line option to prompt the user
    for the vault password. Let's take a look at how each of these options works.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically decrypting using password files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most desirable way to decrypt Ansible vaulted data is to do so without
    user intervention. This option opens the door for a more flexible automation approach
    (initiating it through Jenkins, CircleCI, Bamboo, or whatever). To implement this
    solution, the trick is to store the Ansible vault password within a password file.
    For example, if we were to have a `vars` file, we would encrypt it using the `encrypt`
    option and then store the key we used to encrypt it in the flat text file. Then,
    when running the `ansible-playbook` command, we could pass the `vault-password-file`
    directly. The syntax of this is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The password should be a string stored as a single line in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Manually decrypting vault data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The alternative approach to decrypting Ansible vaulted data would be to have
    Ansible prompt the user for the password upon executing the playbook. This can
    be accomplished in a simple manner as well. The following command syntax shows
    how to instruct Ansible to prompt the user for the vault password prior to executing
    a playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Real-world Ansible Vault Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible vault implementation is a really robust solution designed to provide
    security for sensitive information. The implementation (as you learned already)
    allows us to encrypt, decrypt, rekey, and edit private data with ease. As easy
    as the vault is to use, finding a maintainable way to utilize the Ansible vault
    is not always easily apparent. As such, within this section, we will discuss some
    tips and tricks that can make your Ansible vault experience a bit more enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible vault with roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible vault implementation is best leveraged in conjunction with roles.
    Roles (as we discussed earlier) allow us to modularize our playbooks and reuse
    functionality within them. The specific area of the roles implementation we are
    going to look at would be the vars folder. The vars folder is where we define
    our variables and data points that are then used by the tasks and plays.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with this tutorial, let''s start by creating an Ansible playbook with
    the following folder and file structure (the contents of the files can be blank
    for now, as we will fill in the details in just a moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f088786-a35a-48ac-ab46-9551d3790482.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, there are a few things that should become immediately apparent.
    The first is that the playbook we are creating is a simple vault test with a single
    role and a `sensitive_data` variable''s implementation. Also, as you may have
    guessed, we will be using the `sensitive_data.yml` file to store our super secret
    information. The contents of this file should reflect the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the provided file content, we have a simple vars file with
    a variable defined within, titled `secret_text`.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML syntax supports multi-line variable implementations. This is accomplished
    via the `|` or pipe character, which is provided at the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that sensitive data has been created, let''s encrypt our vars file using
    the Ansible vault encrypt command. This is accomplished via the following command-line
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the file is encrypted, we can create our role file, call it the `main.yml`
    file, and populate our role information. The contents of `main.yml` should look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create our `playbook.yml` file. These files are going to be
    really simple and only point to a single role (`vaulttest`). Let''s take a look
    at the contents of these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all our files created, let''s go ahead and `commit` our code
    to source control (if applicable) and test it out. The command to run the solution
    is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output you should see when running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16b8d073-ba3b-4b9e-a8fa-ba245ac6b060.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Ansible vault. You also learned how to encrypt
    files, decrypt them, rekey an encrypted file, edit them on the fly, and use the
    data within a playbook. Ansible vault provides us with a really simple way to
    encrypt and store encrypted data. As we saw through examples, the encrypting and
    decrypting of files within the ansible vault architecture does not need to be
    complex or complicated. The techniques we discussed within this chapter have wide
    applicable use within an IT operations- or DevOps-oriented organization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Ansible's wide arrange of module and
    libraries. This chapter will help us identify some of the more popular modules
    and libraries that Ansible provides to integrate it with other tools. Let's proceed.
  prefs: []
  type: TYPE_NORMAL
