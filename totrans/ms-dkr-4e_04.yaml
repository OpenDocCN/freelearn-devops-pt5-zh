- en: '*Chapter 4*'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been concentrating on how to build, store, and distribute our
    Docker images. Now we are going to look at how we can launch containers, and also
    how we can use the Docker command-line client to manage and interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: We will be revisiting the commands we used in [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, by going into a lot more detail, before delving deeper into
    the commands that are available. Once we are familiar with the container commands,
    we will look at Docker networks and Docker volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker container commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker networking and volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop Dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to use our local Docker installation. The
    screenshots in this chapter will be from my preferred operating system, macOS,
    but the Docker commands we will be running will work on all three of the operating
    systems on which we have installed Docker so far; however, some of the supporting
    commands, which will be few and far between, may only be applicable to macOS-
    and Linux-based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action:[https://bit.ly/3m1Wtk4](https://bit.ly/3m1Wtk4)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker container commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the more complex Docker commands, let's review and go into
    a little more detail on the commands we have used in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046), *Docker Overview*,
    we launched the most basic container of all, the `hello-world` container, using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you may recall, this command pulls a `1.84` KB image from the Docker Hub.
    You can find the Docker Hub page for the image at [https://hub.docker.com/images/hello-world/](https://hub.docker.com/images/hello-world/),
    and, as per the following `Dockerfile`, it runs an executable called `hello:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello` executable prints the `Hello from Docker!` text to the Terminal,
    and then the process exits. As you can see from the full message text in the following
    Terminal output, the `hello` binary also lets you know exactly what steps have
    just occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Running hello-world'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Running hello-world
  prefs: []
  type: TYPE_NORMAL
- en: 'As the process exits, our container also stops. This can be seen by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.2 – Listing our containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.02_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Listing our containers
  prefs: []
  type: TYPE_NORMAL
- en: You may notice in the Terminal output that I first ran `docker container ls`
    with and without the `-a` flag. This is shorthand for `--all`, as running it without
    the flag does not show any exited containers.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we didn't have to name our container. This is because
    it wasn't going to be around long enough for us to care what it was called. Docker
    automatically assigns names for containers, though, and in my case, you can see
    that it was called `awesome_jackson`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice throughout your use of Docker that it comes up with some really
    interesting names for your containers if you choose to let it generate them for
    you. It created the name from a wordlist for the left-hand word, and for the right-hand
    word, from the names of notable scientists and hackers. Although this is slightly
    off topic, the code to generate the names can be found in `names-generator.go`.
    Right at the end of the source code, it has the following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means there will never be a container called boring_wozniak (and quite
    rightly, too).
  prefs: []
  type: TYPE_NORMAL
- en: 'Information:'
  prefs: []
  type: TYPE_NORMAL
- en: Steve Wozniak is an inventor, electronics engineer, programmer, and entrepreneur
    who co-founded Apple Inc. with Steve Jobs. He is known as a pioneer of the personal
    computer revolution of the 70s and 80s, and is definitely not boring!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove the container with a status of `exited` by running the following
    command, making sure that you replace the name of the container with your own
    container name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, at the end of [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, we launched a container using the official NGINX image by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, this downloads the image and runs it, mapping port `8080`
    on our host machine to port `80` on the container, and calls it `nginx-test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Running an NGINX container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.03_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Running an NGINX container
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, running the Docker image `ls` shows us that we now have two
    images downloaded and also running. The following command shows us that we have
    a running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Terminal output shows that mine had been up for 5 minutes when
    I ran the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Viewing the running containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Viewing the running containers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from our `docker container run` command, we introduced three
    flags. One of them was `-d`, which is shorthand for `--detach`. If we hadn't added
    this flag, then our container would have executed in the foreground, which means
    that our Terminal would have been frozen until we passed the process an escape
    command by pressing *Ctrl + C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action by running the following command to launch a second
    NGINX container to run alongside the container we have already launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once launched, open a browser and enter `http://localhost:9090/`. As you load
    the page, you will notice that your page visit is printed to the screen. Hitting
    refresh in your browser will display more hits, until you press *Ctrl + C* back
    in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Viewing the output of running the container in the foreground'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Viewing the output of running the container in the foreground
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `docker container ls -a` shows that you have two containers, one of
    which has exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Listing the running containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Listing the running containers
  prefs: []
  type: TYPE_NORMAL
- en: So, what happened? When we removed the `detach` flag, Docker connected us to
    the NGINX process directly within the container, meaning that we had visibility
    of **stdin**, **stdout**, and **stderr** for that process. When we used *Ctrl
    + C*, we actually sent an instruction to the NGINX process to terminate it. As
    that was the process that was keeping our container running, the container exited
    immediately once there was no longer a running process.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard input** (**stdin**) is the handle that our process reads to get
    information from the end user. **Standard output** (**stdout**) is where the process
    writes normal information. **Standard error** (**stderr**) is where the process
    writes error messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you may have noticed when we launched the `nginx-foreground` container
    is that we gave it a different name using the `--name` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because you cannot have two containers with the same name, since Docker
    gives you the option of interacting with your containers using both the `CONTAINER
    ID or NAME` values. This is the reason the name generator function exists: to
    assign a random name to containers you do not wish to name yourself, and also
    to ensure that we never call Steve Wozniak boring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing to mention is that when we launched `nginx-foreground`, we
    asked Docker to map port `9090` to port `80` on the container. This was because
    we cannot assign more than one process to a port on a host machine, so if we attempted
    to launch our second container with the same port as the first, we would have
    received an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since we are running the container in the foreground, you may receive
    an error from the NGINX process, as it failed to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, you may also notice that we are mapping to port `80` on the container
    – why no error there?
  prefs: []
  type: TYPE_NORMAL
- en: Well, as explained in [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, the containers themselves are isolated resources, which means
    that we can launch as many containers as we like with port `80` remapped, and
    they will never clash with other containers; we only run into problems when we
    want to route to the exposed container port from our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Let's keep our NGINX container running for the next section, where we will explore
    more ways of interacting with the container.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with your containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, our containers have been running a single process. Docker provides
    you with a few tools that enable you to both fork additional processes and interact
    with them, and we will be covering those tools in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: attach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first way of interacting with your running container is to attach to the
    running process. We still have our `nginx-test` container running, so let''s connect
    to that by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening your browser and going to `http://localhost:8080/` will print the NGINX
    access logs to the screen, just like when we launched the `nginx-foreground` container.
    Pressing *Ctrl + C* will terminate the process and return your Terminal to normal.
    However, as before, we would have terminated the process that was keeping the
    container running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Attaching to our container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.07_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Attaching to our container
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start our container back up by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will start the container back up in the detached state, meaning that it
    is running in the background again, as this was the state that the container was
    originally launched in. Going to `http://localhost:8080/` will show you the NGINX
    welcome page again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reattach to our process, but this time with an additional option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Hitting the container''s URL a few times and then pressing *Ctrl + C* will
    detach us from the NGINX process, but this time, rather than terminating the NGINX
    process, it will just return us to our Terminal, leaving the container in a detached
    state that can be seen by running docker container ls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Disconnecting from our container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.08_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Disconnecting from our container
  prefs: []
  type: TYPE_NORMAL
- en: This is a great way of quickly attaching to a running container to debug issues
    while keeping the container's main process up and running.
  prefs: []
  type: TYPE_NORMAL
- en: exec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `attach` command is useful if you need to connect to the process your container
    is running, but what if you need something that is a little more interactive?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `exec` command. This spawns a second process within the container
    that you can interact with. For example, to see the contents of the `/etc/debian_version`
    file, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will spawn a second process, the `cat` command in this case, which prints
    the contents of `/etc/debianversion to stdout`. The second process will then terminate,
    leaving our container as it was before the `exec` command was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Executing a command against our container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.09_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Executing a command against our container
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take this one step further by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This time, we are forking a bash process and using the `-i` and `-t` flags to
    keep open console access to our container. The `-i` flag is shorthand for `--interactive`,
    which instructs Docker to keep `stdin` open so that we can send commands to the
    process. The `-t` flag is short for `–tty` and allocates a pseudo-TTY to the session.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Early user terminals connected to computers were called **teletypewriters**.
    While these devices are no longer used today, the acronym TTY has continued to
    be used to described text-only consoles in modern computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that you will be able to interact with the container as
    if you had a remote Terminal session, like SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Opening an interactive session to our container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Opening an interactive session to our container
  prefs: []
  type: TYPE_NORMAL
- en: While this is extremely useful, as you can interact with the container as if
    it were a virtual machine, I do not recommend making any changes to your containers
    as they are running using the pseudo-TTY. It is more than likely that those changes
    will not persist and will be lost when your container is removed. We will go into
    the thinking behind this in more detail in [*Chapter 15*](B15659_15_Final_JM_ePub.xhtml#_idTextAnchor823),
    *Docker Workflows*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the various methods you can connect to and interact
    with your containers, we are going to look at some of the tools provided by Docker
    that mean you shouldn't have to.
  prefs: []
  type: TYPE_NORMAL
- en: Logs and process information
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been attaching to either the process in our container, or to
    the container itself, in order to view information. Docker provides the commands
    that we are going to cover in this section that allow you to view information
    about your containers without having to use either the `attach` or `exec` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at how you c view the output being generated by the process
    within the container without having to run it in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `logs` command is pretty self-explanatory. It allows you to interact with
    the `stdout` stream of your containers, which Docker is keeping track of in the
    background. For example, to view the last entries written to `stdout` for our
    `nginx-test` container, you just need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Tailing the logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Tailing the logs
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the logs in real time, I simply need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` flag is shorthand for `--follow`. I can also, for example, view everything
    that has been logged since a certain time by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Checking the logs after a certain time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Checking the logs after a certain time
  prefs: []
  type: TYPE_NORMAL
- en: If you notice that the timestamp in the access log is different to that which
    you are searching for, that is due to the logs command that shows the timestamps
    of stdout as recorded by Docker, and not the time within the container. An example
    of this would be the hours' time difference between the host machine and the container
    due to **British Summer Time (BST)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, to save confusion, you can add `-t` to your `logs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-t` flag is short for `--timestamp`; this option prepends the time the
    output was captured by Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Viewing the logs and with the time the entry was logged'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Viewing the logs and with the time the entry was logged
  prefs: []
  type: TYPE_NORMAL
- en: Now what we have looked at the ways we can view the output of the processes
    running in our containers, let's examine how we get more detail on the process
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: top
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `top` command is quite a simple one; it lists the processes running within
    the container that you specify, and is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Running the top command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Running the top command
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the following Terminal output, we have two processes running,
    both of which are NGINX, which is to be expected.
  prefs: []
  type: TYPE_NORMAL
- en: stats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `stats` command provides real-time information on either the specified
    container or, if you don''t pass a `NAME` or `ID` container, on all running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Viewing the real-time stats of a single container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Viewing the real-time stats of a single container
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following Terminal output, we are given information
    on `CPU`, `RAM`, `NETWORK`, `DISK IO`, and `PIDS` for the specified container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Viewing the real-time stats of all running containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Viewing the real-time stats of all running containers
  prefs: []
  type: TYPE_NORMAL
- en: However, as you can see from the preceding output, if the container isn't running,
    there aren't any resources being utilized, so it doesn't really add any value,
    other than giving you a visual representation of how many containers you have
    running and where the resources are being used.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth pointing out that the information displayed by the `stats`
    command is real time only; Docker does not record the resource utilization and
    make it available in the same way that the `logs` command does. We will be looking
    at more long-term storage options for resource utilization in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Resource limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stats` command we ran showed us the resource utilization of our containers.
    By default, when launched, a container will be allowed to consume all the available
    resources on the host machine if it so requires. We can put limits on the resources
    our containers can consume. Let's start by updating the resource allowances of
    our nginx-test container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, we would have set the limits when we launched our container using
    the `run` command; for example, to halve the CPU priority and set a memory limit
    of `128M`, we would have used the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we didn''t launch our nginx-test container with any resource limits,
    meaning that we need to update our already running container. To do this, we can
    use the `update` command. Now, you may have thought that this should just entail
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But actually, running the preceding command will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what is the `memoryswap` limit currently set to? To find this out, we can
    use the `inspect` command to display all of the configuration data for our running
    container; just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are following along, then you will see that running the preceding command,
    there is a lot of configuration data that will be displayed, too much to display
    here. When I ran the command, a `199` `line JSON` array was returned. Let''s use
    the `grep` command to filter out just the lines that contain the word `memory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Everything is set to `0`, so how can `128M` be smaller than 0?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the context of the configuration of the resources, `0` is actually the default
    value and means that there are no limits. Notice the lack of `M` after each numerical
    value. This means that our `update` command should actually read as the preceding
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Paging** is a memory management scheme in which the kernel stores and retrieves,
    or swaps, data from secondary storage for use in the main memory. This allows
    processes to exceed the size of physical memory available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when you set `--memory` as part of the `run` command, Docker will
    set `--memory-swap size` to be twice that of `--memory`. If you run `docker container
    stats nginx-test` now, you should see our limits in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Using stats to view the limits'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Using stats to view the limits
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, re-running `docker container inspect nginx-test | grep -i memory` will
    show the changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that while we defined the values in MB, they are displayed here
    in bytes, so they are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The values when running `docker container inspect` are all shown in bytes rather
    than megabytes (MB).
  prefs: []
  type: TYPE_NORMAL
- en: Container states and miscellaneous commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the final part of this section, we are going to look at the various states
    your containers could be in, along with the few remaining commands we have yet
    to cover as part of the `docker container` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `docker container ls -a` should show something similar to the following
    Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Listing all of the containers, including those that have exited'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Listing all of the containers, including those that have exited
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have two containers; one has the status of `Up` and the
    other has `Exited`. Before we continue, let''s launch five more containers. To
    do this quickly, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Launching five containers quickly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Launching five containers quickly
  prefs: []
  type: TYPE_NORMAL
- en: 'When running `docker container ls -a`, you should see your five new containers,
    named `nginx1` through to `nginx5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Viewing our five new containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – Viewing our five new containers
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the additional containers up and running, let's look at how
    we can their states.
  prefs: []
  type: TYPE_NORMAL
- en: pause and unpause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at pausing `nginx1`. To do this, simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `docker container ls` will show that the container has a status of
    `Up`, but it also says `Paused`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Pausing a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.21_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – Pausing a container
  prefs: []
  type: TYPE_NORMAL
- en: Note that we didn't have to use the `-a` flag to see information about the container
    as the process has not been terminated; instead, it has been suspended using the
    `cgroups` freezer. With the `cgroups` freezer, the process is unaware it has been
    suspended, meaning that it can be resumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will have probably already guessed, you can resume a paused container
    using the `unpause` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command is useful if you need to freeze the state of a container; for example,
    maybe one of your containers is going haywire and you need to do some investigation
    later, but don't want it to have a negative impact on your other running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how you can properly stop and remove containers.
  prefs: []
  type: TYPE_NORMAL
- en: stop, start, restart, and kill
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next up, we have the `stop`, `start`, `restart`, and `kill` commands. We have
    already used the `start` command to resume a container with a status of `Exited`.
    The `stop` command works exactly the same way as when we used *Ctrl + C* to detach
    from your container running in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this, a request is sent to the process for it to terminate, called `SIGTERM`.
    If the process has not terminated itself within a grace period, then a kill signal,
    called `SIGKILL`, is sent. This will immediately terminate the process, not giving
    it any time to finish whatever is causing the delay; for example, committing the
    results of a database query to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this could be bad, Docker gives you the option of overriding the default
    grace period, which is 10 seconds, by using the `-t` flag; this is short for `--time`.
    For example, running the following command will wait up to 60 seconds before sending
    a `SIGKILL` command, in the event that it needs to be sent to kill the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start` command, as we have already seen, will start the process back up;
    however, unlike the `pause` and `unpause` commands, the process, in this case,
    starts from scratch using the flags that originally launched it, rather than starting
    from where it left off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `restart` command is a combination of the following two commands; it stops
    and then starts the `ID` or `NAME` container you pass it. Also, as with `stop`,
    you can pass the `-t` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you also have the option of sending a `SIGKILL` command immediately
    to the container by running the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There is one more thing need to cover, and that is removing the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Removing containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s check the status of containers we have been using by the `docker container
    ls -a` command. When I run the command, I can see that I have two containers with
    an `Exited` status and all of the others are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Viewing the state of all of our containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.22_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – Viewing the state of all of our containers
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the two exited containers, I can simply run the `prune` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When doing so, a warning pops up asking you to confirm whether you are really
    sure, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Pruning the containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.23_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.23 – Pruning the containers
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose which container you want to remove using the `rm` command, an
    example of which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative would be to string the `stop` and `rm` commands together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: However, given that you can use the `prune` command now, this is probably way
    too much effort, especially as you are trying to remove the containers and probably
    don't care too much how gracefully the process is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to remove the remainder of your containers using whichever method
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up this section of the chapter, we are going to look at a few
    more useful commands that can't be really grouped together.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the final part of this section, we are going to look at a few commands
    that you probably won''t use too much during your day-to-day use of Docker. The
    first of these is `create`. The `create` command is pretty similar to the `run`
    command, except that it does not start the container, but instead prepares and
    configures one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the status of your created container by running `docker container
    ls -a`, and then starting the container with `docker container start nginx-test`,
    before checking the status again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Creating and then running a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.24_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – Creating and then running a container
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command we are going to quickly look at is the `port` command; this
    displays the `port` number along with any port mappings for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We already know this, as it is what we configured. Also, the ports are listed
    in the `docker container ls` output.
  prefs: []
  type: TYPE_NORMAL
- en: The next command we are going to look at quickly is the `diff` command. This
    command prints a list of all of the files that have been added (`A`) or changed
    (`C`) since the container was started – so basically, a list of the differences
    in the filesystem between the original image we used to launch the container and
    what files are present now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run the command, let''s create a blank file within the `nginx-test`
    container using the `exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a file called `testing` in `/tmp`, we can view the differences
    between the original image and the running container using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a list of files. As you can see from the following list, our
    testing file is there, along with the files that were created when NGINX started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that once we stop and remove the container, these files
    will be lost. In the next section of this chapter, we will look at Docker volumes
    and learn how we can persist data. Before we move on though, let's get a copy
    of the file we just created using the `cp` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the command, we are providing the container name followed
    by `:` and the full path to the file we want to copy. What follows is the local
    path. Here, you can see that we are simply calling the file `testing` and it will
    be copied to the current folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Copying a file to a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.25_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – Copying a file to a container
  prefs: []
  type: TYPE_NORMAL
- en: 'As the file does not contain any data, lets add some and then copy it back
    to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the second command, we are swapping the paths around. This time,
    we are providing the path of the local file and the container name and path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Copying a file with contents to the container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.26_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – Copying a file with contents to the container
  prefs: []
  type: TYPE_NORMAL
- en: The other thing of note is that while we are overwriting an existing file, Docker
    did not warn us or give an option to back out of the command – it went ahead and
    overwrote the file immediately, so please be careful when using `docker container
    cp`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along, you should remove any running containers launched
    during this section using the command of your choice before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking and volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we are going to take a look at the basics of Docker networking and
    Docker volumes using the default drivers. Let's take a look at networking first.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been launching our containers on a single flat shared network.
    Although we have not talked about it yet, this means the containers we have been
    launching would have been able to communicate with each other without having to
    use any of the host networking.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than going into detail now, let's work through an example. We are going
    to be running a two-container application; the first container will be running
    Redis, and the second, our application, which uses the Redis container to store
    a system state.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Redis is an in-memory data structure store that can be used as a database, cache,
    or message broker. It supports different levels of on-disk persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we launch our application, let''s download the container images we will
    be using, and also create the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Pulling the images we need and creating the network'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.27_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – Pulling the images we need and creating the network
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our images pulled and our network created, we can launch our
    containers, starting with the Redis one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the `--network` flag to define the network that our
    container was launched in. Now that the Redis container is launched, we can launch
    the application container by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we launched the container on the `moby-counter` network. This time,
    we mapped port `8080` to port `80` on the container. Note that we did not need
    to worry about exposing any ports of the Redis container. That is because the
    Redis image comes with some defaults that expose the default port, which is `6379`
    for us. This can be seen by running `docker container ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Listing the containers needed for our application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.28_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – Listing the containers needed for our application
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains now is to access the application. To do this, open your browser
    and go to `http://localhost:8080/`. You should be greeted by a mostly blank page,
    with the message **Click to add logos…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Our application is ready to go'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.29_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – Our application is ready to go
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking anywhere on the page will add Docker logos, so click away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Adding some logos to the page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.30_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – Adding some logos to the page
  prefs: []
  type: TYPE_NORMAL
- en: So, what is happening? The application that is being served from the `moby-counter`
    container is making a connection to the `redis` container, and using the service
    to store the onscreen coordinates of each of the logos that you place on the screen
    by clicking.
  prefs: []
  type: TYPE_NORMAL
- en: 'How is the `moby-counter` application connecting to the `redis` container?
    Well, in the `server.js` file, the following default values are being set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the `moby-counter` application is looking to connect to a host
    called `redis` on port `6379`. Let''s try using the `exec` command to ping the
    `redis` container from the `moby-counter` application and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Pinging the redis container using the container name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.31_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.31 – Pinging the redis container using the container name
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `moby-counter` container resolves `redis` to the IP address
    of the `redis` container, which is `172.18.0.2`. You may be thinking that the
    application''s host file contains an entry for the `redis` container; let''s take
    a look using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the content of `/etc/hosts`, which, in my case, looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than the entry at the end, which is actually the IP address resolving
    to the hostname of the local container, `e7335ca1830d` is the ID of the container;
    there is no sign of an entry for `redis`. Next, let''s check `/etc/resolv.conf`
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns what we are looking for. As you can see, we are using a local
    `nameserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s perform a DNS lookup on `redis` against `127.0.0.11` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the IP address of the `redis` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a second network and launch another application container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the second application container up and running, let''s try
    pinging the `redis` container from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, I get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Isolating our applications in different networks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.32_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – Isolating our applications in different networks
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the `resolv.conf` file to see whether the same `nameserver` is
    being used already, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, the `nameserver` is indeed in use
    already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have launched the `moby-counter2` container in a different network to
    that where the container named `redis` is running, we cannot resolve the hostname
    of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it returns a bad address error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at launching a second Redis server in our second network. As we have
    already discussed, we cannot have two containers with the same name, so let's
    creatively name it `redis2`. As our application is configured to connect to a
    container that resolves to `redis`, does this mean we will have to make changes
    to our application container? No, Docker has you covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you cannot have two containers with the same name, as we have already
    discovered, our second network is running completely isolated from our first network,
    meaning that we can still use the DNS name of `redis`. To do this, we need to
    add the `-network-alias` flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have named the container `redis2`, but set `--network-alias`
    to be `redis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that when we perform the lookup, we see the correct IP address returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `redis` is actually an alias for `redis2.moby-counter2`, which
    then resolves to `172.19.0.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should have two applications running side by side in their own isolated
    networks on your local Docker host, accessible at `http://localhost:8080/` and
    `http://localhost:9090/`. Running `docker network ls` will display all of the
    networks configured on your Docker host, including the default networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Listing our networks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.33_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.33 – Listing our networks
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more information about the configuration of the networks by
    running the following `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command returns the following JSON array. It starts by
    giving us some general information on the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the configuration used by the IP Address Management system. It shows
    the subnet range and gateway IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows next is the remainder of the general configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have details pertaining to the containers, which are attached to the
    network. This is where we can find the IP address and MAC address of each container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the last bit of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it contains information on the network address being used in
    the IPAM section, along with details on each of the two containers running in
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`IPAM` has both `DNS` and `DHCP` services, so each service is notified of changes
    in the other. For example, `DHCP` assigns an address to `container2`. The `DNS`
    service is then updated to return the IP address assigned by `DHCP` whenever a
    lookup is made against `container2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we progress to the next section, we should remove one of the applications
    and associated networks. To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'These will remove the containers and network, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34 – Removing unused networks with the prune command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.34_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.34 – Removing unused networks with the prune command
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of this section, this is only the default network
    driver, meaning that we are restricted to our networks being available only on
    a single Docker host. In later chapters, we will look at how we can expand our
    Docker network across multiple hosts and even providers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics around Docker networking, let's take a look at how
    we can work with additional storage for our containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have been following along with the network example from the previous
    section, you should have two containers running, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Listing the running containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.35_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.35 – Listing the running containers
  prefs: []
  type: TYPE_NORMAL
- en: 'When you go to the application in a browser (at `http://localhost:8080/`),
    you will probably see that there already are Docker logos on screen. Let''s stop
    and then remove the Redis container and see what happens. To do this, run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have your browser open, you may notice that the Docker icons have faded
    into the background and there is an animated loader in the center of the screen.
    This is basically to show that the application is waiting for the connection to
    the Redis container to be re-established:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36 – The application can no longer connect to Redis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.36_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.36 – The application can no longer connect to Redis
  prefs: []
  type: TYPE_NORMAL
- en: 'Relaunch the Redis container using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This restores connectivity. However, when you start to interact with the application,
    your previous icons disappear and you are left with a clean slate. Quickly add
    some more logos to the screen, this time placed in a different pattern, as I have
    done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Adding more logos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.37_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – Adding more logos
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a pattern, let''s remove the Redis container again by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier in the chapter, losing the data in the container is
    to be expected. However, as we used the official Redis image, we haven't, in fact,
    lost any of our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile for the official Redis image that we used looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding steps prepare the container by adding a group and user, installing
    a few packages, and setting some environment variables. The following steps install
    the prerequisites needed to run Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Redis source code is downloaded and copied to the right place on the
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the source for Redis is in the image, the configuration is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Redis is compiled and tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build` directory is then removed and the packages that are no longer needed
    are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Redis is built and the packages and build artifacts tided up, a final
    test is run. If it fails here, the build will also fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything installed, the final set of image configuration can take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If you notice, during the last part of the file, there are the `VOLUME` and
    `WORKDIR` directives declared; this means that when our container was launched,
    Docker actually created a volume and then run `redis-server` from within the volume.
    We can see this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show at least two volumes, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Listing the volumes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.38_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – Listing the volumes
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the volume name is not very friendly at all. In fact, it is
    the unique ID of the volume. So how can we use the volume when we launch our Redis
    container? We know from the Dockerfile that the volume was mounted at `/data`
    within the container, so all we have to do is tell Docker which volume to use
    and where it should be mounted at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command, making sure you replace the volume ID
    with that of your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If your application page looks like it is still trying to reconnect to the Redis
    container once you have launched your Redis container, then you may need to refresh
    your browser. Failing that, restarting the application container by running `docker
    container restart moby-counter` and then refreshing your browser again should
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the contents of the volume by running the following command to
    attach the container and list the files in `/data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: You can also remove your running container and relaunch it, but this time using
    the ID of the second volume. As you can see from the application in your browser,
    the two different patterns you originally created are intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove the `Redis` container again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can override the volume with your own. To create a volume, we
    need to use the `volume` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, we will be able to use the `redis_data` volume to store our `Redis`
    by running the following command after removing the `redis` container, which is
    probably already running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then reuse the volume as needed. The following screen shows the volume
    being created, attached to a container that is then removed and finally reattached
    to a new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Creating a volume and attaching it to a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.39_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.39 – Creating a volume and attaching it to a container
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `network` command, we can view more information on the volume using
    the `inspect` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You can see that there is not much to a volume when using the local driver.
    One interesting thing to note is that the path to where the data is stored on
    the Docker host machine is `/var/lib/docker/volumes/redis_data/_data`. If you
    are using Docker for Mac or Docker for Windows, then this path will be your Docker
    host virtual machine, and not your local machine, meaning that you do not have
    direct access to the data inside the volume.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry though; we will be looking at Docker volumes and how you can interact
    with data in later chapters. Before we tidy up our containers, networks, and volume,
    if you are running Docker Desktop, then we should take a look at the Docker Desktop
    Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are running either Docker for Mac or Docker for Windows, then there
    is an option within the main menu to open a dashboard that will display information
    on your running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Opening the Docker Desktop Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.40_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.40 – Opening the Docker Desktop Dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Once open, you should see something like the following screen. As you can see,
    we have our `redis` and `moby-counter` containers listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Viewing the running containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.41_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.41 – Viewing the running containers
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting the `redis` container will take you to an overview screen that defaults
    to the `Logs` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42 – Overview screen of the Logs output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.42_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.42 – Overview screen of the Logs output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start at the top of the screen. To the right here, you can see four
    blue icons; these are as follows, from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connect to container**: This will open your default Terminal application
    and connect to the currently selected container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop the currently connected container**: When stopped, the icon will change
    to a **Start** icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the **Restart icon**. Clicking this will, well you guessed it
    right?! It will restart the currently selected container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final **Trash icon** will terminate the currently selected container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have the menu items on the left-hand side of the screen. We have already
    seen the **Logs** output; this is updated in real time and you also have the option
    of searching through the log output. Below that we have **Inspect**; this displays
    some basic information about the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43 – Getting information on the container using inspect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.43_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.43 – Getting information on the container using inspect
  prefs: []
  type: TYPE_NORMAL
- en: 'The final item is `Stats`; this – as you may have already figured out, gives
    us the same output as the `docker container stats redis` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44 – Viewing the real-time stats'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.44_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.44 – Viewing the real-time stats
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to the `moby-counter` container adds an additional icon to the start
    of the top menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45 – Viewing the additional icon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.45_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.45 – Viewing the additional icon
  prefs: []
  type: TYPE_NORMAL
- en: This will open your default browser and take you to the externally exposed port,
    which in this case is [http://localhost:8080](http://localhost:8080).
  prefs: []
  type: TYPE_NORMAL
- en: You have noticed that there are some features, such as the ability to create
    containers, in the dashboard. However, as new versions are released, I am sure
    that more management features will be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should tidy up. First of all, remove the two containers and network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can remove the volumes by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46 – Removing everything we have launched'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.46_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.46 – Removing everything we have launched
  prefs: []
  type: TYPE_NORMAL
- en: We are now back to having a clean slate, so we can progress to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at how you can use the Docker command-line client
    to both manage individual containers and launch multi-container applications in
    their own isolated Docker networks. We also discussed how we can persist data
    on the filesystem using Docker volumes. So far, in this and previous chapters,
    we have covered in detail the majority of the available commands that we will
    use in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the four main areas of using Docker locally, we can
    start to look at how to create more complex applications. In the next chapter,
    we will take a look at another core Docker tool, called **Docker Compose**.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which flag do you have to append to `docker container ls` to view all the containers,
    both running and stopped?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: the `-p 8080:80` flag will map port `80` on the container to
    port `8080` on the host.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between what happens when you use *Ctrl + C* to exit
    a container you have attached, compared to using the `attach` command with `--sig-proxy=false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: The `exec` command attaches you to the running process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flag would you use to add an alias to a container so that it responds
    to DNS requests, when you already have a container running with the same DNS name
    in another network?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command would you use to find out details on a Docker volume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names generator code: [https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `cgroups` freezer function: [https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx)t'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis: [https://redis.io/](https://redis.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
