- en: Creating Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods are equivalent to bricks we use to build houses. Both are uneventful and
    not much by themselves. Yet, they are fundamental building blocks without which
    we could not construct the solution we are set to build.
  prefs: []
  type: TYPE_NORMAL
- en: If you used Docker or Docker Swarm, you're probably used to thinking that a
    container is the smallest unit and that more complex patterns are built on top
    of it. With Kubernetes, the smallest unit is a Pod. A Pod is a way to represent
    a running process in a cluster. From Kubernetes' perspective, there's nothing
    smaller than a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: A Pod encapsulates one or more containers. It provides a unique network IP,
    it attaches storage resources, and it decides how containers should run. Everything
    in a Pod is tightly coupled.
  prefs: []
  type: TYPE_NORMAL
- en: We should clarify that containers in a Pod are not necessarily made by Docker.
    Other container runtimes are supported as well. Still, at the time of this writing,
    Docker is the most commonly used container runtime, and all our examples will
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter onward, we will break the publishing tradition of having a
    long explanation of concepts before diving into practical examples. Instead, we'll
    try to learn theory through practice. One step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We'll move straight into hands-on exercises. Since we cannot create Pods without
    a Kubernetes cluster, our first order of business is to create one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create a local Kubernetes cluster using Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands from this chapter are available in the [`03-pods.sh`](https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0)
    ([https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0](https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To simplify the process and save you from writing all the configuration files,
    we'll clone the GitHub repository [`vfarcic/k8s-specs`](https://github.com/vfarcic/k8s-specs)
    ([https://github.com/vfarcic/k8s-specs](https://github.com/vfarcic/k8s-specs)).
    It contains everything we'll need for this chapter, as well as for most of the
    others in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We cloned the repository and entered into the directory that was created.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run our first Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Quick and dirty way to run Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we can execute `docker run` to create containers, `kubectl` allows us
    to create Pods with a single command. For example, if we'd like to create a Pod
    with a Mongo database, the command is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that the output says that `deployment "db" was created`. Kubernetes
    runs more than a single Pod. It created a Deployment and a few other things. We
    won''t go into all the details just yet. What matters, for now, is that we created
    a Pod. We can confirm that by listing all the Pods in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see the name of the Pod, its readiness, the status, the number of times
    it restarted, and for how long it has existed (its age). If you were fast enough,
    or your network is slow, none of the pods might be ready. We expect to have one
    Pod, but there's zero running at the moment. Since the `mongo` image is relatively
    big, it might take a while until it is pulled from Docker Hub. After a while,
    we can retrieve the Pods one more time to confirm that the Pod with the Mongo
    database is running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, this time, the Pod is ready and we can start using the Mongo
    database.
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm that a container based on the `mongo` image is indeed running
    inside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We evaluated `minikube` variables so that our local Docker client is using
    Docker server running inside the VM. Further on, we listed all the containers
    based on the `mongo` image. The output is as follows (IDs are removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the container defined in the Pod is running.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf2002b0-d8e2-4f24-acde-fb22a9d8366e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: A Pod with a single container'
  prefs: []
  type: TYPE_NORMAL
- en: That was not the best way to run Pods so we'll delete the deployment which,
    in turn, will delete everything it envelops, including the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Why did I say that was not the best way to run Pods? We used the imperative
    way to tell Kubernetes what to do. Even though there are cases when that might
    be useful, most of the time we want to leverage the declarative approach. We want
    to have a way to define what we need in a file and pass that information to Kubernetes.
    That way, we can have a documented and repeatable process, that can (and should)
    be version controlled as well. Moreover, the `kubectl run` was reasonably simple.
    In real life, we need to declare much more than the name of the deployment and
    the image. Commands like `kubectl` can quickly become too long and, in many cases,
    very complicated. Instead, we'll write specifications in YAML format. Soon, we'll
    see how we can accomplish a similar result using declarative syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Pods through declarative syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though a Pod can contain any number of containers, the most common use
    case is to use the single-container-in-a-Pod model. In such a case, a Pod is a
    wrapper around one container. From Kubernetes' perspective, a Pod is the smallest
    unit. We cannot tell Kubernetes to run a container. Instead, we ask it to create
    a Pod that wraps around a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple Pod definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We're using `v1` of Kubernetes Pods API. Both `apiVersion` and `kind` are mandatory.
    That way, Kubernetes knows what we want to do (create a Pod) and which API version
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is `metadata`. It provides information that does not influence
    how the Pod behaves. We used `metadata` to define the name of the Pod (`db`) and
    a few labels. Later on, when we move into Controllers, labels will have a practical
    purpose. For now, they are purely informational.
  prefs: []
  type: TYPE_NORMAL
- en: The last section is the `spec` in which we defined a single container. As you
    might have guessed, we can have multiple containers defined as a Pod. Otherwise,
    the section would be written in singular (`container` without `s`). We'll explore
    multi-container Pods later.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the container is defined with the name (`db`), the image (`mongo`),
    the command that should be executed when the container starts (`mongod`), and,
    finally, the set of arguments. The arguments are defined as an array with, in
    this case, two elements (`--rest` and `--httpinterface`).
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into details of everything you can use to define a Pod. Throughout
    the book, you'll see quite a few other commonly (and not so commonly) used things
    we should define in Pods. Later on, when you decide to learn all the possible
    arguments you can apply, explore the official, and ever-changing, [`Pod v1 core`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core) 
                                                                                 
                                                                        ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core))
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the Pod defined in the `db.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that we did not need to specify `pod` in the command. The command
    will create the kind of resource defined in the `pod/db.yml` file. Later on, you'll
    see that a single YAML file can contain definitions of multiple resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Pods in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our Pod named `db` is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you might want to retrieve a bit more information by specifying
    `wide` output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we got two additional columns; the IP and the node.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to parse the output, using `json` format is probably the best
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The output is too big to be presented in the book, especially since we won't
    go through all the information provided through the `json` output format.
  prefs: []
  type: TYPE_NORMAL
- en: When we want more information than provided with the default output, but still
    in a format that is human-friendly, `yaml` output is probably the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the `json` output, we won't go into details of everything we got
    from Kubernetes. With time, you'll become familiar with all the information related
    to Pods. For now, we want to focus on the most important aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's introduce a new `kubectl` sub-command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` sub-command returned details of the specified resource. In this
    case, the resource is the Pod named `db`.
  prefs: []
  type: TYPE_NORMAL
- en: The output is too big for us to go into every detail. Besides, most of it should
    be self-explanatory if you're familiar with containers. Instead, we'll briefly
    comment on the last section called `events`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Pod was created and went through several stages as shown
    in the following sequence diagram. Even though the process was simple from a user's
    perspective, quite a few things happened in the background.
  prefs: []
  type: TYPE_NORMAL
- en: This might be a right moment to pause with our exercises, discuss some of the
    details of Kubernetes components, and try to get an understanding of how Pod scheduling
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Three major components were involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: The *API server* is the central component of a Kubernetes cluster and it runs
    on the master node. Since we are using Minikube, both master and worker nodes
    are baked into the same virtual machine. However, a more serious Kubernetes cluster
    should have the two separated on different hosts.
  prefs: []
  type: TYPE_NORMAL
- en: All other components interact with API server and keep watch for changes. Most
    of the coordination in Kubernetes consists of a component writing to the API Server
    resource that another component is watching. The second component will then react
    to changes almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The *scheduler* is also running on the master node. Its job is to watch for
    unassigned pods and assign them to a node which has available resources (CPU and
    memory) matching Pod requirements. Since we are running a single-node cluster,
    specifying resources would not provide much insight into their usage so we'll
    leave them for later.
  prefs: []
  type: TYPE_NORMAL
- en: '*Kubelet* runs on each node. Its primary function is to make sure that assigned
    pods are running on the node. It watches for any new Pod assignments for the node.
    If a Pod is assigned to the node Kubelet is running on, it will pull the Pod definition
    and use it to create containers through Docker or any other supported container
    engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of events that transpired with the `kubectl create -f pod/db.yml`
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes client (`kubectl`) sent a request to the API server requesting creation
    of a Pod defined in the `pod/db.yml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the scheduler is watching the API server for new events, it detected that
    there is an unassigned Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scheduler decided which node to assign the Pod to and sent that information
    to the API server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubelet is also watching the API server. It detected that the Pod was assigned
    to the node it is running on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubelet sent a request to Docker requesting the creation of the containers that
    form the Pod. In our case, the Pod defines a single container based on the `mongo`
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, Kubelet sent a request to the API server notifying it that the Pod
    was created successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process might not make much sense right now since we are running a single-node
    cluster. If we had more VMs, scheduling might have happened somewhere else, and
    the complexity of the process would be easier to grasp. We'll get there in due
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90442108-970e-42fb-95a8-5337d9c16567.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: Pod scheduling sequence'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, it is more useful to describe resources by referencing the file
    that defines them. That way there is no confusion nor need to remember the names
    of resources. We could have executed the command that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output should be the same since, in both cases, `kubectl` sent a request
    to Kubernetes API requesting information about the Pod named `db`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with Docker, we can execute a new process inside a running container
    inside a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We told Kubernetes that we'd like to execute a process inside the first container
    of the Pod `db`. Since our Pod defines only one container, this container and
    the first container are one and the same. The `--container` (or `-c`) argument
    can be set to specify which container should be used. That is particularly useful
    when running multiple containers in a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from using Pods as the reference, `kubectl exec` is almost the same as
    the `docker container exec` command. The significant difference is that `kubectl`
    allows us to execute a process in a container running in any node inside a cluster,
    while `docker container exec` is limited to containers running on a specific node.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of executing a new short-lived process inside a running container, we
    can enter into it. For example, we can make the execution interactive with `-i
    (stdin)` and `-t` (terminal) arguments and run `shell` inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We're inside the `sh` process inside the container. Since the container hosts
    a Mongo database, we can, for example, execute `db.stats()` to confirm that the
    database is indeed running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We used `mongo` client to execute `db.stats()` for the database `test` running
    on `localhost:27017`. Since we're not trying to learn Mongo (at least not in this
    book), the only purpose of this exercise was to prove that the database is up-and-running.
    Let's get out of the container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Logs should be shipped from containers to a central location. However, since
    we did not yet explore that subject, it would be useful to be able to see logs
    of a container in a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that outputs logs of the only container in the `db` Pod is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is too big and not that important in its entirety. One of the last
    line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the `-f` (or `--follow`) we can follow the logs in real-time. Just as with
    the `exec` sub-command, if a Pod defines multiple containers, we can specify which
    one to use with the `-c` argument.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when a container inside a Pod dies? Let's simulate a failure and
    observe what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We killed the main process of the container and listed all the Pods. The output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The container is running (`1/1`). Kubernetes guarantees that the containers
    inside a Pod are (almost) always running. Please note that the `RESTARTS` field
    now has the value of `1`. Every time a container fails, Kubernetes will restart
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cba91dd-bc5f-45b8-aec9-e1928cf54952.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: Pod with a failed container'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can delete a Pod if we don't need it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We removed the Pods defined in `db.yml` and retrieved the list of all the Pods
    in the cluster. The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The number of ready containers dropped to `0`, and the status of the `db` Pod
    is `terminating`.
  prefs: []
  type: TYPE_NORMAL
- en: When we sent the instruction to delete a Pod, Kubernetes tried to terminate
    it gracefully. The first thing it did was to send the `TERM` signal to all the
    main processes inside the containers that form the Pod. From there on, Kubernetes
    gives each container a period of thirty seconds so that the processes in those
    containers can shut down gracefully. Once the grace period expires, the `KILL`
    signal is sent to terminate all the main processes forcefully and, with them,
    all the containers. The default grace period can be changed through the `gracePeriodSeconds`
    value in YAML definition or `--grace-period` argument of the `kubectl delete`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we repeat the `get pods` command thirty seconds after we issued the `delete`
    instruction, the Pod should be removed from the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This time, the output is different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The only Pod we had in the system is no more.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple containers in a single Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods are designed to run multiple cooperative processes that should act as a
    cohesive unit. Those processes are wrapped in containers. All the containers that
    form a Pod are running on the same machine. A Pod cannot be split across multiple
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the processes (containers) inside a Pod share the same set of resources,
    and they can communicate with each other through `localhost`. One of those shared
    resources is storage. A volume defined in a Pod can be accessed by all the containers
    thus allowing them all to share the same data. We''ll explore storage in more
    depth later on. For now, let''s take a look at the `pod/go-demo-2.yml` specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The YAML file defines a Pod with two containers named `db` and `api`. The service
    inside the `vfarcic/go-demo-2` image uses environment variable `DB` to know where
    the database is. The value is `localhost` since all the containers in the same
    Pod are reachable through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a new Pod defined in the `go-demo-2.yml` file and retrieved its
    information from Kubernetes. The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the `READY` column that, this time, the Pod has two containers
    (`2/2`).
  prefs: []
  type: TYPE_NORMAL
- en: This might be an excellent opportunity to introduce formatting to retrieve specific
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to retrieve the names of the containers in a Pod. The
    first thing we'd have to do is get familiar with Kubernetes API. We can do that
    by going to [`Pod v1 core`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)
    ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core))
    documentation. While reading the documentation will become mandatory sooner or
    later, we'll use a simpler route and inspect the output from Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is too big to be presented in a book, so we''ll focus on the task
    at hand. We need to retrieve the names of the containers in the Pod. Therefore,
    the part of the output we''re looking for is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` command that would filter the output and retrieve only the names
    of the containers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We used `jsonpath` as the output format and specified that we want to retrieve
    names of all the `containers` from the `spec`. The ability to filter and format
    information might not look that important right now but, once we move into more
    complex scenarios, it will prove to be invaluable. That will become especially
    evident when we try to automate the processes and requests sent to Kubernetes
    API.
  prefs: []
  type: TYPE_NORMAL
- en: How would we execute a command inside the Pod? Unlike the previous examples
    that did a similar task, this time we have two containers in the Pod, so we need
    to be more specific.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The output should display the processes inside the `db` container. Namely, the
    `mongod` process.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about logs from a container? As you might have guessed, we cannot execute
    something like `kubectl logs go-demo-2` since the Pod hosts multiple containers.
    Instead, we need to be specific and name the container from which we want to see
    the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How about scaling? How would we, for example, scale the service so that there
    are two containers of the API and one container for the database?
  prefs: []
  type: TYPE_NORMAL
- en: One option could be to define two containers in the Pod. Let's take a look at
    a Pod definition that might accomplish what we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We defined two containers for the API and named them `api-1` and `api-2`. The
    only thing left is to create the Pod. But, we're not going to do that.
  prefs: []
  type: TYPE_NORMAL
- en: We should not think of Pods as resources that should do anything beyond a definition
    of the smallest unit in our cluster. A Pod is a collection of containers that
    share the same resources. Not much more. Everything else should be accomplished
    with higher-level constructs. We'll explore how to scale Pods without changing
    their definition in one of the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our original multi-container Pod that defined `api` and `db`
    containers. That was a terrible design choice since it tightly couples one with
    the other. As a result, when we explore how to scale Pods (not containers), both
    would need to match. If, for example, we scale the Pod to three, we'd have three
    APIs and three DBs. Instead, we should have defined two Pods, one for each container
    (`db` and `api`). That would give us enough flexibility to treat each independently
    from the other.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few other reasons not to put multiple containers in the same
    Pod. For now, just be patient. Most of the scenarios where you might think that
    multi-container Pod is a good solution will probably be solved through other resources.
  prefs: []
  type: TYPE_NORMAL
- en: A Pod is a collection of containers. However, that does not mean that multi-container
    Pods are common. They are rare. Most Pods you'll create will be single container
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Does that mean that multi-container Pods are useless? They're not. There are
    scenarios when having multiple containers in a Pod is a good idea. However, they
    are very specific and, in most cases, are based on one container that acts as
    the main service and the rest serving as side-cars. A frequent use case are multi-container
    Pods used for **continuous integration** (**CI**), **delivery** (**CD**), or **deployment**
    (**CDP**) processes. We'll explore them later. For now, we'll focus on single-container
    Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's remove the Pod before we move onto container health.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vfarcic/go-demo-2` Docker image is designed to fail on the first sign of
    trouble. In cases like that, there is no need for any health checks. When things
    go wrong, the main process stops, the container hosting it stops as well, and
    Kubernetes restarts the failed container. However, not all services are designed
    to fail fast. Even those that are might still benefit from additional health checks.
    For example, a back-end API can be up and running but, due to a memory leak, serve
    requests much slower than expected. Such a situation might benefit from a health
    check that would verify whether the service responds within, for example, two
    seconds. We can exploit Kubernetes liveness and readiness probes for that.
  prefs: []
  type: TYPE_NORMAL
- en: '`livenessProbe` can be used to confirm whether a container should be running.
    If the probe fails, Kubernetes will kill the container and apply restart policy
    which defaults to `Always`. `readinessProbe`, on the other hand, should be used
    as an indication that the service is ready to serve requests. When combined with
    `Services` construct, only containers with the `readinessProbe` state set to `Success`
    will receive requests. We''ll leave `readinessProbe` for later since it is directly
    tied to `Services`. Instead, we''ll explore `livenessProbe`. Both are defined
    in the same way so the experience with one of them can be easily applied to the
    other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an updated definition of the Pod we used thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Don't get confused by seeing two containers in this Pod. I stand by my words.
    Those two should be defined in separate Pods. However, since that would require
    knowledge we are yet to obtain, and `vfarcic/go-demo-2` doesn't work without a
    database, we'll have to stick with the example that specifies two containers.
    It won't take long until we break it into pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The additional definition is inside the `livenessProbe`.
  prefs: []
  type: TYPE_NORMAL
- en: We defined that the action should be `httpGet` followed with the `path` and
    the `port` of the service. Since `/this/path/does/not/exist` is true to itself,
    the probe will fail, thus showing us what happens when a container is unhealthy.
    The `host` is not specified since it defaults to the Pod IP.
  prefs: []
  type: TYPE_NORMAL
- en: Further down, we declared that the first execution of the probe should be delayed
    by five seconds (`initialDelaySeconds`), that requests should timeout after two
    seconds (`timeoutSeconds`), that the process should be repeated every five seconds
    (`periodSeconds`), and (`failureThreshold`) define how many attempts it must try
    before giving up.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the probe in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the Pod with the probe. Now we must wait until the probe fails a
    few times. A minute is more than enough. Once we''re done waiting, we can describe
    the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The bottom of the output contains events. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, once the container started, the probe was executed, and that
    it failed. As a result, the container was killed only to be created again. In
    the preceding output, we can see that the process was repeated three times (`3x
    over ...`).
  prefs: []
  type: TYPE_NORMAL
- en: Please visit [Probe v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core)
    ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core))
    if you'd like to learn all the available options.
  prefs: []
  type: TYPE_NORMAL
- en: Pods are (almost) useless (by themselves)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods are fundamental building blocks in Kubernetes. In most cases, you will
    not create Pods directly. Instead, you'll use higher level constructs like Controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Pods are disposable. They are not long lasting services. Even though Kubernetes
    is doing its best to ensure that the containers in a Pod are (almost) always up-and-running,
    the same cannot be said for Pods. If a Pod fails, gets destroyed, or gets evicted
    from a Node, it will not be rescheduled. At least, not without a Controller. Similarly,
    if a whole node is destroyed, all the Pods on it will cease to exist. Pods do
    not heal by themselves. Excluding some special cases, Pods are not meant to be
    created directly.
  prefs: []
  type: TYPE_NORMAL
- en: Do not create Pods by themselves. Let one of the controllers create Pods for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll remove the cluster and start the next chapter fresh.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Please take some time to get more familiar with Pods. They are the most basic
    and, arguably, the essential building block in Kubernetes. Since, by now, you
    have a solid understanding what the Pods are, a good next step might be to go
    through PodSpec v1 core ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core))
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69055cc6-8934-4c02-b717-ab650ec5dffc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: The components explored so far'
  prefs: []
  type: TYPE_NORMAL
