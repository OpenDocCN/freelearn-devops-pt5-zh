- en: Creating Pods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Pods
- en: Pods are equivalent to bricks we use to build houses. Both are uneventful and
    not much by themselves. Yet, they are fundamental building blocks without which
    we could not construct the solution we are set to build.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 就像我们用来建造房屋的砖块。它们本身并不显眼，单独看也不显得特别重要。然而，它们是基本的构建块，没有它们，我们无法构建我们设定的解决方案。
- en: If you used Docker or Docker Swarm, you're probably used to thinking that a
    container is the smallest unit and that more complex patterns are built on top
    of it. With Kubernetes, the smallest unit is a Pod. A Pod is a way to represent
    a running process in a cluster. From Kubernetes' perspective, there's nothing
    smaller than a Pod.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 Docker 或 Docker Swarm，你可能已经习惯了认为容器是最小的单位，复杂的模式是在它之上构建的。而在 Kubernetes
    中，最小的单位是 Pod。Pod 是表示集群中正在运行的进程的方式。从 Kubernetes 的角度来看，没有比 Pod 更小的单位。
- en: A Pod encapsulates one or more containers. It provides a unique network IP,
    it attaches storage resources, and it decides how containers should run. Everything
    in a Pod is tightly coupled.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Pod 封装了一个或多个容器。它提供了一个独特的网络 IP，附加了存储资源，并决定容器的运行方式。Pod 内的一切都是紧密耦合的。
- en: We should clarify that containers in a Pod are not necessarily made by Docker.
    Other container runtimes are supported as well. Still, at the time of this writing,
    Docker is the most commonly used container runtime, and all our examples will
    use it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要澄清，Pod 中的容器不一定是由 Docker 创建的。其他容器运行时也受到支持。然而，在撰写本书时，Docker 是最常用的容器运行时，我们的所有示例都会使用
    Docker。
- en: From this chapter onward, we will break the publishing tradition of having a
    long explanation of concepts before diving into practical examples. Instead, we'll
    try to learn theory through practice. One step at a time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将打破传统，避免在深入实践示例之前进行长篇的概念解释。相反，我们将通过实践来学习理论，一步一步来。
- en: We'll move straight into hands-on exercises. Since we cannot create Pods without
    a Kubernetes cluster, our first order of business is to create one.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入动手操作。由于没有 Kubernetes 集群，我们无法创建 Pods，因此我们的首要任务是先创建一个集群。
- en: Creating a Cluster
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建集群
- en: We'll create a local Kubernetes cluster using Minikube.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Minikube 创建一个本地的 Kubernetes 集群。
- en: All the commands from this chapter are available in the [`03-pods.sh`](https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0)
    ([https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0](https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0))
    Gist.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有命令都可以在 [`03-pods.sh`](https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0)
    ([https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0](https://gist.github.com/vfarcic/d860631d0dd3158c32740e9260c7add0))
    Gist 中找到。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the latter command is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 后者命令的输出如下：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To simplify the process and save you from writing all the configuration files,
    we'll clone the GitHub repository [`vfarcic/k8s-specs`](https://github.com/vfarcic/k8s-specs)
    ([https://github.com/vfarcic/k8s-specs](https://github.com/vfarcic/k8s-specs)).
    It contains everything we'll need for this chapter, as well as for most of the
    others in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化过程并免去你编写所有配置文件的麻烦，我们将克隆 GitHub 仓库 [`vfarcic/k8s-specs`](https://github.com/vfarcic/k8s-specs)
    ([https://github.com/vfarcic/k8s-specs](https://github.com/vfarcic/k8s-specs))。它包含了我们本章以及本书大多数其他章节所需的一切。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We cloned the repository and entered into the directory that was created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们克隆了仓库并进入了创建的目录。
- en: Now we can run our first Pod.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们的第一个 Pod。
- en: Quick and dirty way to run Pods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速而简便地运行 Pods
- en: Just as we can execute `docker run` to create containers, `kubectl` allows us
    to create Pods with a single command. For example, if we'd like to create a Pod
    with a Mongo database, the command is as follows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以执行 `docker run` 来创建容器一样，`kubectl` 也允许我们通过一个命令来创建 Pods。例如，如果我们想要创建一个包含
    Mongo 数据库的 Pod，命令如下：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You''ll notice that the output says that `deployment "db" was created`. Kubernetes
    runs more than a single Pod. It created a Deployment and a few other things. We
    won''t go into all the details just yet. What matters, for now, is that we created
    a Pod. We can confirm that by listing all the Pods in the cluster:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到输出中显示 `deployment "db" was created`。Kubernetes 运行的不仅仅是一个 Pod，它创建了一个 Deployment
    和一些其他的东西。我们暂时不会深入讨论所有细节。现在重要的是，我们已经创建了一个 Pod。我们可以通过列出集群中的所有 Pods 来确认这一点：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see the name of the Pod, its readiness, the status, the number of times
    it restarted, and for how long it has existed (its age). If you were fast enough,
    or your network is slow, none of the pods might be ready. We expect to have one
    Pod, but there's zero running at the moment. Since the `mongo` image is relatively
    big, it might take a while until it is pulled from Docker Hub. After a while,
    we can retrieve the Pods one more time to confirm that the Pod with the Mongo
    database is running.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Pod的名称、就绪状态、状态、重启次数以及存在时长（年龄）。如果你反应够快，或者你的网络较慢，可能没有Pod准备就绪。我们期望有一个Pod，但此时没有正在运行的Pod。由于`mongo`镜像相对较大，因此可能需要一些时间才能从Docker
    Hub拉取镜像。过了一段时间后，我们可以再次检索Pods，确认Mongo数据库的Pod是否正在运行。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that, this time, the Pod is ready and we can start using the Mongo
    database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这次Pod已就绪，我们可以开始使用Mongo数据库。
- en: We can confirm that a container based on the `mongo` image is indeed running
    inside the cluster.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认基于`mongo`镜像的容器确实正在集群中运行。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We evaluated `minikube` variables so that our local Docker client is using
    Docker server running inside the VM. Further on, we listed all the containers
    based on the `mongo` image. The output is as follows (IDs are removed for brevity):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估了`minikube`变量，以便我们的本地Docker客户端使用在虚拟机内运行的Docker服务器。接着，我们列出了所有基于`mongo`镜像的容器。输出如下（为了简洁起见，已删除ID）：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the container defined in the Pod is running.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Pod中定义的容器正在运行。
- en: '![](img/cf2002b0-d8e2-4f24-acde-fb22a9d8366e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf2002b0-d8e2-4f24-acde-fb22a9d8366e.png)'
- en: 'Figure 3-1: A Pod with a single container'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：一个包含单个容器的Pod
- en: That was not the best way to run Pods so we'll delete the deployment which,
    in turn, will delete everything it envelops, including the Pod.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是运行Pods的最佳方式，因此我们将删除部署，这样会删除它所包含的所有内容，包括Pod。
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why did I say that was not the best way to run Pods? We used the imperative
    way to tell Kubernetes what to do. Even though there are cases when that might
    be useful, most of the time we want to leverage the declarative approach. We want
    to have a way to define what we need in a file and pass that information to Kubernetes.
    That way, we can have a documented and repeatable process, that can (and should)
    be version controlled as well. Moreover, the `kubectl run` was reasonably simple.
    In real life, we need to declare much more than the name of the deployment and
    the image. Commands like `kubectl` can quickly become too long and, in many cases,
    very complicated. Instead, we'll write specifications in YAML format. Soon, we'll
    see how we can accomplish a similar result using declarative syntax.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我说那不是运行Pods的最佳方式？我们使用了命令式方式告诉Kubernetes该做什么。尽管在某些情况下这样做可能有用，但大多数时候我们希望利用声明式方法。我们希望能够在文件中定义我们需要的内容，并将这些信息传递给Kubernetes。这样，我们可以拥有一个有文档记录的、可重复的过程，并且（应该）可以进行版本控制。此外，`kubectl
    run`的命令相对简单。在实际应用中，我们需要声明的内容远比部署名称和镜像多。像`kubectl`这样的命令可能会迅速变得冗长，且在许多情况下非常复杂。相反，我们将以YAML格式编写规范。稍后，我们将看到如何使用声明式语法实现类似的结果。
- en: Defining Pods through declarative syntax
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过声明式语法定义Pods
- en: Even though a Pod can contain any number of containers, the most common use
    case is to use the single-container-in-a-Pod model. In such a case, a Pod is a
    wrapper around one container. From Kubernetes' perspective, a Pod is the smallest
    unit. We cannot tell Kubernetes to run a container. Instead, we ask it to create
    a Pod that wraps around a container.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个Pod可以包含任意数量的容器，但最常见的使用场景是使用单容器Pod模型。在这种情况下，Pod是围绕一个容器的封装。从Kubernetes的角度来看，Pod是最小的单元。我们不能告诉Kubernetes运行一个容器。相反，我们要求它创建一个封装容器的Pod。
- en: 'Let''s take a look at a simple Pod definition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的Pod定义：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're using `v1` of Kubernetes Pods API. Both `apiVersion` and `kind` are mandatory.
    That way, Kubernetes knows what we want to do (create a Pod) and which API version
    to use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`v1`版本的Kubernetes Pods API。`apiVersion`和`kind`都是必需的。通过这种方式，Kubernetes知道我们想做什么（创建一个Pod）以及使用哪个API版本。
- en: The next section is `metadata`. It provides information that does not influence
    how the Pod behaves. We used `metadata` to define the name of the Pod (`db`) and
    a few labels. Later on, when we move into Controllers, labels will have a practical
    purpose. For now, they are purely informational.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是`metadata`。它提供了不影响Pod行为的信息。我们使用`metadata`来定义Pod的名称（`db`）和一些标签。稍后，当我们学习控制器时，标签将有实际用途。目前，它们纯粹是信息性的。
- en: The last section is the `spec` in which we defined a single container. As you
    might have guessed, we can have multiple containers defined as a Pod. Otherwise,
    the section would be written in singular (`container` without `s`). We'll explore
    multi-container Pods later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`spec`，我们在其中定义了一个容器。正如你可能猜到的，我们可以将多个容器定义为一个Pod。否则，部分将以单数形式（`container`而非`containers`）书写。稍后我们将探讨多容器Pod。
- en: In our case, the container is defined with the name (`db`), the image (`mongo`),
    the command that should be executed when the container starts (`mongod`), and,
    finally, the set of arguments. The arguments are defined as an array with, in
    this case, two elements (`--rest` and `--httpinterface`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，容器定义了名称（`db`）、镜像（`mongo`）、容器启动时应执行的命令（`mongod`），以及最后的参数集。参数以数组形式定义，在这个例子中包含两个元素（`--rest`和`--httpinterface`）。
- en: We won't go into details of everything you can use to define a Pod. Throughout
    the book, you'll see quite a few other commonly (and not so commonly) used things
    we should define in Pods. Later on, when you decide to learn all the possible
    arguments you can apply, explore the official, and ever-changing, [`Pod v1 core`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core) 
                                                                                 
                                                                        ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core))
    documentation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨你可以用来定义Pod的所有内容。在本书中，你将看到很多其他常用（或不那么常用）的Pod定义项。稍后，当你决定学习所有可以应用的参数时，请查看官方的、不断变化的[`Pod
    v1 core`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)文档。
- en: Let's create the Pod defined in the `db.yml` file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建在`db.yml`文件中定义的Pod。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You'll notice that we did not need to specify `pod` in the command. The command
    will create the kind of resource defined in the `pod/db.yml` file. Later on, you'll
    see that a single YAML file can contain definitions of multiple resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在命令中并没有需要指定`pod`。该命令将创建在`pod/db.yml`文件中定义的资源类型。稍后，你会看到一个YAML文件可以包含多个资源的定义。
- en: 'Let''s take a look at the Pods in the cluster:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下集群中的Pods：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our Pod named `db` is up and running.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们名为`db`的Pod已经启动并运行。
- en: In some cases, you might want to retrieve a bit more information by specifying
    `wide` output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想通过指定`wide`输出获取更多信息。
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we got two additional columns; the IP and the node.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了两列额外的信息：IP和节点。
- en: If you'd like to parse the output, using `json` format is probably the best
    option.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想解析输出，使用`json`格式可能是最佳选择。
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output is too big to be presented in the book, especially since we won't
    go through all the information provided through the `json` output format.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数据太大，无法在书中呈现，尤其是因为我们不会详细介绍通过`json`输出格式提供的所有信息。
- en: When we want more information than provided with the default output, but still
    in a format that is human-friendly, `yaml` output is probably the best choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要比默认输出提供的更多信息，但仍希望以对人类友好的格式呈现时，`yaml`输出可能是最佳选择。
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just as with the `json` output, we won't go into details of everything we got
    from Kubernetes. With time, you'll become familiar with all the information related
    to Pods. For now, we want to focus on the most important aspects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`json`输出一样，我们不会深入讨论从Kubernetes获取的所有信息。随着时间的推移，你将熟悉与Pod相关的所有信息。目前，我们想集中精力关注最重要的方面。
- en: Let's introduce a new `kubectl` sub-command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个新的`kubectl`子命令。
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `describe` sub-command returned details of the specified resource. In this
    case, the resource is the Pod named `db`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`子命令返回了指定资源的详细信息。在这个例子中，资源是名为`db`的Pod。'
- en: The output is too big for us to go into every detail. Besides, most of it should
    be self-explanatory if you're familiar with containers. Instead, we'll briefly
    comment on the last section called `events`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出太大，无法逐一讲解每个细节。此外，如果你熟悉容器，大部分内容应该是显而易见的。我们将简要评论最后一部分，名为 `events`。
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that the Pod was created and went through several stages as shown
    in the following sequence diagram. Even though the process was simple from a user's
    perspective, quite a few things happened in the background.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 Pod 已创建并经历了多个阶段，如下图所示。尽管从用户的角度来看过程很简单，但在后台发生了许多事情。
- en: This might be a right moment to pause with our exercises, discuss some of the
    details of Kubernetes components, and try to get an understanding of how Pod scheduling
    works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是暂停练习、讨论 Kubernetes 组件的一些细节，并试图理解 Pod 调度是如何工作的好时机。
- en: Three major components were involved in the process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程涉及三个主要组件。
- en: The *API server* is the central component of a Kubernetes cluster and it runs
    on the master node. Since we are using Minikube, both master and worker nodes
    are baked into the same virtual machine. However, a more serious Kubernetes cluster
    should have the two separated on different hosts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*API 服务器* 是 Kubernetes 集群的核心组件，运行在主节点上。由于我们使用的是 Minikube，因此主节点和工作节点被打包在同一个虚拟机中。然而，更严肃的
    Kubernetes 集群应该将这两个节点分布在不同的主机上。'
- en: All other components interact with API server and keep watch for changes. Most
    of the coordination in Kubernetes consists of a component writing to the API Server
    resource that another component is watching. The second component will then react
    to changes almost immediately.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他组件与 API 服务器交互并保持监视变化。Kubernetes 中的大多数协调工作都涉及一个组件向 API 服务器资源写入，另一个组件在监视该资源。第二个组件将几乎立即对变化作出反应。
- en: The *scheduler* is also running on the master node. Its job is to watch for
    unassigned pods and assign them to a node which has available resources (CPU and
    memory) matching Pod requirements. Since we are running a single-node cluster,
    specifying resources would not provide much insight into their usage so we'll
    leave them for later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*调度器* 也在主节点上运行。它的任务是监视未分配的 Pod，并将它们分配到具有符合 Pod 要求的可用资源（CPU 和内存）的节点上。由于我们正在运行一个单节点集群，指定资源不会提供太多关于资源使用的见解，因此我们会留到稍后讨论。'
- en: '*Kubelet* runs on each node. Its primary function is to make sure that assigned
    pods are running on the node. It watches for any new Pod assignments for the node.
    If a Pod is assigned to the node Kubelet is running on, it will pull the Pod definition
    and use it to create containers through Docker or any other supported container
    engine.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubelet* 在每个节点上运行。它的主要功能是确保分配给该节点的 Pod 正在运行。它会监视该节点的任何新 Pod 分配。如果一个 Pod 被分配到
    Kubelet 正在运行的节点上，它将拉取 Pod 定义并使用它通过 Docker 或任何其他支持的容器引擎来创建容器。'
- en: 'The sequence of events that transpired with the `kubectl create -f pod/db.yml`
    command is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `kubectl create -f pod/db.yml` 命令后发生的事件顺序如下：
- en: Kubernetes client (`kubectl`) sent a request to the API server requesting creation
    of a Pod defined in the `pod/db.yml` file.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 客户端（`kubectl`）向 API 服务器发送请求，要求创建在 `pod/db.yml` 文件中定义的 Pod。
- en: Since the scheduler is watching the API server for new events, it detected that
    there is an unassigned Pod.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于调度器在监视 API 服务器的新事件，它检测到有一个未分配的 Pod。
- en: The scheduler decided which node to assign the Pod to and sent that information
    to the API server.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器决定将 Pod 分配给哪个节点，并将该信息发送到 API 服务器。
- en: Kubelet is also watching the API server. It detected that the Pod was assigned
    to the node it is running on.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubelet 也在监视 API 服务器。它检测到 Pod 被分配到它正在运行的节点上。
- en: Kubelet sent a request to Docker requesting the creation of the containers that
    form the Pod. In our case, the Pod defines a single container based on the `mongo`
    image.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubelet 向 Docker 发送请求，请求创建构成该 Pod 的容器。在我们的案例中，Pod 定义了一个基于 `mongo` 镜像的单一容器。
- en: Finally, Kubelet sent a request to the API server notifying it that the Pod
    was created successfully.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，Kubelet 向 API 服务器发送请求，通知它 Pod 已成功创建。
- en: The process might not make much sense right now since we are running a single-node
    cluster. If we had more VMs, scheduling might have happened somewhere else, and
    the complexity of the process would be easier to grasp. We'll get there in due
    time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程现在可能不太容易理解，因为我们正在运行一个单节点集群。如果我们有更多的虚拟机，调度可能会在其他地方发生，过程的复杂性也会更容易理解。我们会在适当的时候到达那里。
- en: '![](img/90442108-970e-42fb-95a8-5337d9c16567.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90442108-970e-42fb-95a8-5337d9c16567.png)'
- en: 'Figure 3-2: Pod scheduling sequence'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：Pod调度顺序
- en: 'In many cases, it is more useful to describe resources by referencing the file
    that defines them. That way there is no confusion nor need to remember the names
    of resources. We could have executed the command that follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，通过引用定义资源的文件来描述资源更加实用。这样就不会产生混淆，也不需要记住资源的名称。我们本可以执行以下命令：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output should be the same since, in both cases, `kubectl` sent a request
    to Kubernetes API requesting information about the Pod named `db`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是相同的，因为在两种情况下，`kubectl`都向Kubernetes API发送了请求，获取名为`db`的Pod的信息。
- en: Just as with Docker, we can execute a new process inside a running container
    inside a Pod.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Docker中一样，我们可以在Pod内的运行容器中执行一个新的进程。
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We told Kubernetes that we'd like to execute a process inside the first container
    of the Pod `db`. Since our Pod defines only one container, this container and
    the first container are one and the same. The `--container` (or `-c`) argument
    can be set to specify which container should be used. That is particularly useful
    when running multiple containers in a Pod.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Kubernetes我们想在`db` Pod的第一个容器内执行一个进程。由于我们的Pod只定义了一个容器，这个容器就是第一个容器。可以通过设置`--container`（或`-c`）参数来指定使用哪个容器。当Pod中运行多个容器时，这一点特别有用。
- en: Apart from using Pods as the reference, `kubectl exec` is almost the same as
    the `docker container exec` command. The significant difference is that `kubectl`
    allows us to execute a process in a container running in any node inside a cluster,
    while `docker container exec` is limited to containers running on a specific node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将Pod作为参考外，`kubectl exec`几乎与`docker container exec`命令相同。显著的区别是，`kubectl`允许我们在集群内的任何节点上的容器中执行进程，而`docker
    container exec`则仅限于在特定节点上的容器中执行。
- en: Instead of executing a new short-lived process inside a running container, we
    can enter into it. For example, we can make the execution interactive with `-i
    (stdin)` and `-t` (terminal) arguments and run `shell` inside a container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进入一个正在运行的容器，而不是在其中执行一个新的短时进程。例如，我们可以通过`-i (stdin)`和`-t`（终端）参数使执行变得交互式，并在容器内运行`shell`。
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We're inside the `sh` process inside the container. Since the container hosts
    a Mongo database, we can, for example, execute `db.stats()` to confirm that the
    database is indeed running.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在容器内的`sh`进程中。由于容器托管着一个Mongo数据库，我们可以例如执行`db.stats()`来确认数据库确实在运行。
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We used `mongo` client to execute `db.stats()` for the database `test` running
    on `localhost:27017`. Since we're not trying to learn Mongo (at least not in this
    book), the only purpose of this exercise was to prove that the database is up-and-running.
    Let's get out of the container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mongo`客户端执行`db.stats()`，用于检查在`localhost:27017`上运行的`test`数据库。由于我们不是在这本书中学习Mongo（至少不是现在），这个练习的唯一目的是证明数据库已经启动并在运行。接下来让我们退出容器。
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Logs should be shipped from containers to a central location. However, since
    we did not yet explore that subject, it would be useful to be able to see logs
    of a container in a Pod.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 日志应该从容器发送到一个中央位置。然而，由于我们尚未深入探讨这个话题，因此能够查看Pod中容器的日志会非常有用。
- en: 'The command that outputs logs of the only container in the `db` Pod is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出日志的命令如下，适用于`db` Pod中唯一的容器：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is too big and not that important in its entirety. One of the last
    line is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出太大且整个输出并不重要。最后一行之一如下所示：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the `-f` (or `--follow`) we can follow the logs in real-time. Just as with
    the `exec` sub-command, if a Pod defines multiple containers, we can specify which
    one to use with the `-c` argument.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-f`（或`--follow`）选项，我们可以实时跟踪日志。就像使用`exec`子命令一样，如果一个Pod定义了多个容器，我们可以通过`-c`参数指定使用哪个容器。
- en: What happens when a container inside a Pod dies? Let's simulate a failure and
    observe what happens.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod内的容器死掉时会发生什么？让我们模拟一个故障并观察发生的情况。
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We killed the main process of the container and listed all the Pods. The output
    is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终止了容器的主进程，并列出了所有的Pods。输出如下：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The container is running (`1/1`). Kubernetes guarantees that the containers
    inside a Pod are (almost) always running. Please note that the `RESTARTS` field
    now has the value of `1`. Every time a container fails, Kubernetes will restart
    it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器正在运行（`1/1`）。Kubernetes保证Pod内的容器（几乎）始终在运行。请注意，`RESTARTS`字段现在的值为`1`。每当一个容器失败时，Kubernetes会重新启动它：
- en: '![](img/6cba91dd-bc5f-45b8-aec9-e1928cf54952.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cba91dd-bc5f-45b8-aec9-e1928cf54952.png)'
- en: 'Figure 3-3: Pod with a failed container'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：容器失败的Pod
- en: Finally, we can delete a Pod if we don't need it anymore.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们不再需要Pod，可以将其删除。
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We removed the Pods defined in `db.yml` and retrieved the list of all the Pods
    in the cluster. The output of the latter command is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了在`db.yml`中定义的Pods，并检索了集群中所有Pod的列表。后者命令的输出如下：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The number of ready containers dropped to `0`, and the status of the `db` Pod
    is `terminating`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪容器的数量下降至`0`，`db` Pod的状态为`terminating`。
- en: When we sent the instruction to delete a Pod, Kubernetes tried to terminate
    it gracefully. The first thing it did was to send the `TERM` signal to all the
    main processes inside the containers that form the Pod. From there on, Kubernetes
    gives each container a period of thirty seconds so that the processes in those
    containers can shut down gracefully. Once the grace period expires, the `KILL`
    signal is sent to terminate all the main processes forcefully and, with them,
    all the containers. The default grace period can be changed through the `gracePeriodSeconds`
    value in YAML definition or `--grace-period` argument of the `kubectl delete`
    command.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送删除Pod的指令时，Kubernetes尝试优雅地终止它。首先，它会向所有Pod内容器中的主进程发送`TERM`信号。从那时起，Kubernetes为每个容器提供了30秒的时间，以便容器中的进程能够优雅地关闭。一旦宽限期到期，`KILL`信号会被发送以强制终止所有主进程，并与之一起终止所有容器。默认的宽限期可以通过YAML定义中的`gracePeriodSeconds`值或`kubectl
    delete`命令的`--grace-period`参数进行更改。
- en: 'If we repeat the `get pods` command thirty seconds after we issued the `delete`
    instruction, the Pod should be removed from the system:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在发出`delete`指令后的30秒重复执行`get pods`命令，Pod应该会从系统中移除：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This time, the output is different.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出结果不同。
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only Pod we had in the system is no more.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中唯一的Pod已不再存在。
- en: Running multiple containers in a single Pod
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单个Pod中运行多个容器
- en: Pods are designed to run multiple cooperative processes that should act as a
    cohesive unit. Those processes are wrapped in containers. All the containers that
    form a Pod are running on the same machine. A Pod cannot be split across multiple
    nodes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Pods旨在运行多个合作进程，这些进程应作为一个统一体进行操作。这些进程被封装在容器中。构成Pod的所有容器都运行在同一台机器上。Pod不能分布在多个节点上。
- en: 'All the processes (containers) inside a Pod share the same set of resources,
    and they can communicate with each other through `localhost`. One of those shared
    resources is storage. A volume defined in a Pod can be accessed by all the containers
    thus allowing them all to share the same data. We''ll explore storage in more
    depth later on. For now, let''s take a look at the `pod/go-demo-2.yml` specification:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Pod中的所有进程（容器）共享相同的资源集，它们可以通过`localhost`相互通信。共享资源之一是存储。在Pod中定义的卷可以被所有容器访问，从而使它们可以共享相同的数据。我们稍后将更深入地探讨存储内容。现在，让我们来看看`pod/go-demo-2.yml`的规范：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The YAML file defines a Pod with two containers named `db` and `api`. The service
    inside the `vfarcic/go-demo-2` image uses environment variable `DB` to know where
    the database is. The value is `localhost` since all the containers in the same
    Pod are reachable through it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件定义了一个包含名为`db`和`api`的两个容器的Pod。`vfarcic/go-demo-2`镜像中的服务使用环境变量`DB`来确定数据库的位置。该值为`localhost`，因为同一Pod中的所有容器都可以通过它访问。
- en: 'Let''s create the Pod:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建Pod：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We created a new Pod defined in the `go-demo-2.yml` file and retrieved its
    information from Kubernetes. The output of the latter command is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个在`go-demo-2.yml`文件中定义的新Pod，并从Kubernetes获取了其信息。后者命令的输出如下：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can see from the `READY` column that, this time, the Pod has two containers
    (`2/2`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从`READY`列可以看出，这次Pod有两个容器（`2/2`）。
- en: This might be an excellent opportunity to introduce formatting to retrieve specific
    information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个很好的机会来引入格式化，获取特定信息。
- en: Let's say that we want to retrieve the names of the containers in a Pod. The
    first thing we'd have to do is get familiar with Kubernetes API. We can do that
    by going to [`Pod v1 core`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)
    ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core))
    documentation. While reading the documentation will become mandatory sooner or
    later, we'll use a simpler route and inspect the output from Kubernetes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想获取Pod中容器的名称。首先，我们需要熟悉Kubernetes API。我们可以通过访问[`Pod v1 core`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)）文档来实现。虽然阅读文档迟早是必须的，但我们将采用更简单的方式，直接检查Kubernetes的输出。
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is too big to be presented in a book, so we''ll focus on the task
    at hand. We need to retrieve the names of the containers in the Pod. Therefore,
    the part of the output we''re looking for is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出过大，不适合在书中展示，所以我们将专注于当前任务。我们需要获取Pod中容器的名称。因此，我们需要关注输出中的以下部分：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `get` command that would filter the output and retrieve only the names
    of the containers is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用于筛选输出并仅获取容器名称的`get`命令如下：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We used `jsonpath` as the output format and specified that we want to retrieve
    names of all the `containers` from the `spec`. The ability to filter and format
    information might not look that important right now but, once we move into more
    complex scenarios, it will prove to be invaluable. That will become especially
    evident when we try to automate the processes and requests sent to Kubernetes
    API.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`jsonpath`作为输出格式，并指定要从`spec`中获取所有`containers`的名称。现在这种筛选和格式化信息的能力可能看起来不那么重要，但当我们进入更复杂的场景时，它将变得非常宝贵。尤其是在我们尝试自动化过程并向Kubernetes
    API发送请求时，这一点尤为明显。
- en: How would we execute a command inside the Pod? Unlike the previous examples
    that did a similar task, this time we have two containers in the Pod, so we need
    to be more specific.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Pod内执行命令呢？与之前做类似任务的例子不同，这次Pod中有两个容器，因此我们需要更具体地指定。
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The output should display the processes inside the `db` container. Namely, the
    `mongod` process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示`db`容器中的进程，即`mongod`进程。
- en: 'How about logs from a container? As you might have guessed, we cannot execute
    something like `kubectl logs go-demo-2` since the Pod hosts multiple containers.
    Instead, we need to be specific and name the container from which we want to see
    the logs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的日志怎么办？正如你可能猜到的，我们不能执行类似`kubectl logs go-demo-2`的命令，因为该Pod托管了多个容器。相反，我们需要更具体地指定想查看日志的容器名称：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How about scaling? How would we, for example, scale the service so that there
    are two containers of the API and one container for the database?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那如何进行扩展呢？例如，我们如何扩展服务，使得API有两个容器，数据库有一个容器？
- en: One option could be to define two containers in the Pod. Let's take a look at
    a Pod definition that might accomplish what we need.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是定义Pod中的两个容器。我们来看看一个可能完成所需任务的Pod定义。
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We defined two containers for the API and named them `api-1` and `api-2`. The
    only thing left is to create the Pod. But, we're not going to do that.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为API定义了两个容器，分别命名为`api-1`和`api-2`。剩下的就是创建Pod。但我们暂时不打算这么做。
- en: We should not think of Pods as resources that should do anything beyond a definition
    of the smallest unit in our cluster. A Pod is a collection of containers that
    share the same resources. Not much more. Everything else should be accomplished
    with higher-level constructs. We'll explore how to scale Pods without changing
    their definition in one of the next chapters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应将Pod视为资源，应该仅仅看作是我们集群中最小单元的定义。Pod是一个容器集合，共享相同的资源，仅此而已。其他的任务应通过更高层次的构造来完成。在接下来的章节中，我们将探索如何在不改变Pod定义的情况下进行扩展。
- en: Let's go back to our original multi-container Pod that defined `api` and `db`
    containers. That was a terrible design choice since it tightly couples one with
    the other. As a result, when we explore how to scale Pods (not containers), both
    would need to match. If, for example, we scale the Pod to three, we'd have three
    APIs and three DBs. Instead, we should have defined two Pods, one for each container
    (`db` and `api`). That would give us enough flexibility to treat each independently
    from the other.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到最初定义了 `api` 和 `db` 容器的多容器 Pod。这个设计选择非常糟糕，因为它将两者紧密耦合在一起。因此，当我们探讨如何扩展 Pods（而不是容器）时，两者都需要匹配。例如，如果我们将
    Pod 扩展到三个实例，我们将得到三个 API 和三个数据库。相反，我们应该定义两个 Pod，每个容器一个（`db` 和 `api`）。这样，我们就能灵活地独立处理每个容器。
- en: There are quite a few other reasons not to put multiple containers in the same
    Pod. For now, just be patient. Most of the scenarios where you might think that
    multi-container Pod is a good solution will probably be solved through other resources.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他原因不建议将多个容器放在同一个 Pod 中。现在，先耐心等待。大多数情况下，可能认为多容器 Pod 是解决方案的场景，最终将通过其他资源来解决。
- en: A Pod is a collection of containers. However, that does not mean that multi-container
    Pods are common. They are rare. Most Pods you'll create will be single container
    units.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是容器的集合。然而，这并不意味着多容器 Pod 是常见的。它们是非常罕见的。你创建的大多数 Pod 将是单容器的。
- en: Does that mean that multi-container Pods are useless? They're not. There are
    scenarios when having multiple containers in a Pod is a good idea. However, they
    are very specific and, in most cases, are based on one container that acts as
    the main service and the rest serving as side-cars. A frequent use case are multi-container
    Pods used for **continuous integration** (**CI**), **delivery** (**CD**), or **deployment**
    (**CDP**) processes. We'll explore them later. For now, we'll focus on single-container
    Pods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着多容器 Pod 是没有用的？并不是。实际上，在某些场景下，将多个容器放入同一个 Pod 是一个好主意。然而，这些场景非常特定，并且在大多数情况下是基于一个作为主服务的容器，其他容器作为
    side-car 服务。一个常见的用例是用于 **持续集成**（**CI**）、**持续交付**（**CD**）或 **持续部署**（**CDP**）的多容器
    Pod。我们稍后会探讨这些场景。现在，我们将重点关注单容器 Pod。
- en: Let's remove the Pod before we move onto container health.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讲解容器健康检查之前，让我们先移除 Pod。
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Monitoring health
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控健康状态
- en: The `vfarcic/go-demo-2` Docker image is designed to fail on the first sign of
    trouble. In cases like that, there is no need for any health checks. When things
    go wrong, the main process stops, the container hosting it stops as well, and
    Kubernetes restarts the failed container. However, not all services are designed
    to fail fast. Even those that are might still benefit from additional health checks.
    For example, a back-end API can be up and running but, due to a memory leak, serve
    requests much slower than expected. Such a situation might benefit from a health
    check that would verify whether the service responds within, for example, two
    seconds. We can exploit Kubernetes liveness and readiness probes for that.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`vfarcic/go-demo-2` Docker 镜像被设计为在出现问题的第一时间就失败。在这种情况下，不需要任何健康检查。当问题发生时，主进程停止，承载它的容器也停止，Kubernetes
    会重启该失败的容器。然而，并非所有服务都设计为快速失败。即使是设计为快速失败的服务，也可能仍然受益于额外的健康检查。例如，一个后端 API 可能在运行，但由于内存泄漏，响应请求的速度比预期慢。这样的情况可能需要一个健康检查，来验证服务是否在例如两秒钟内作出响应。我们可以利用
    Kubernetes 的 liveness 和 readiness 探针来实现这一点。'
- en: '`livenessProbe` can be used to confirm whether a container should be running.
    If the probe fails, Kubernetes will kill the container and apply restart policy
    which defaults to `Always`. `readinessProbe`, on the other hand, should be used
    as an indication that the service is ready to serve requests. When combined with
    `Services` construct, only containers with the `readinessProbe` state set to `Success`
    will receive requests. We''ll leave `readinessProbe` for later since it is directly
    tied to `Services`. Instead, we''ll explore `livenessProbe`. Both are defined
    in the same way so the experience with one of them can be easily applied to the
    other.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`livenessProbe` 可用于确认容器是否应继续运行。如果探针失败，Kubernetes 会终止该容器并应用重启策略，默认情况下为`Always`。另一方面，`readinessProbe`
    应该用作指示服务是否准备好接收请求的标志。与 `Services` 构造结合时，只有将 `readinessProbe` 状态设置为 `Success` 的容器才会接收请求。我们将稍后讨论
    `readinessProbe`，因为它与 `Services` 直接相关。相反，我们将先探讨 `livenessProbe`。两者的定义方式相同，因此对其中一个的经验可以轻松应用到另一个上。'
- en: 'Let''s take a look at an updated definition of the Pod we used thus far:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们迄今为止使用的 Pod 的更新定义：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Don't get confused by seeing two containers in this Pod. I stand by my words.
    Those two should be defined in separate Pods. However, since that would require
    knowledge we are yet to obtain, and `vfarcic/go-demo-2` doesn't work without a
    database, we'll have to stick with the example that specifies two containers.
    It won't take long until we break it into pieces.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为在这个Pod中看到两个容器而感到困惑。我坚持我的观点。这两个容器应该在不同的Pod中定义。然而，由于这需要我们尚未掌握的知识，而`vfarcic/go-demo-2`在没有数据库的情况下无法工作，我们必须坚持使用这个指定了两个容器的示例。很快我们就会将其拆解开来。
- en: The additional definition is inside the `livenessProbe`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的定义在`livenessProbe`内。
- en: We defined that the action should be `httpGet` followed with the `path` and
    the `port` of the service. Since `/this/path/does/not/exist` is true to itself,
    the probe will fail, thus showing us what happens when a container is unhealthy.
    The `host` is not specified since it defaults to the Pod IP.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了动作应该是`httpGet`，后面跟着服务的`path`和`port`。由于`/this/path/does/not/exist`对自身来说是正确的，探针将会失败，从而向我们展示容器不健康时会发生什么。`host`没有指定，因为它默认使用Pod
    IP。
- en: Further down, we declared that the first execution of the probe should be delayed
    by five seconds (`initialDelaySeconds`), that requests should timeout after two
    seconds (`timeoutSeconds`), that the process should be repeated every five seconds
    (`periodSeconds`), and (`failureThreshold`) define how many attempts it must try
    before giving up.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下方，我们声明了第一次执行探针时应该延迟五秒（`initialDelaySeconds`），请求在两秒后超时（`timeoutSeconds`），该过程应该每五秒重复一次（`periodSeconds`），并且（`failureThreshold`）定义了在放弃之前必须尝试多少次。
- en: Let's take a look at the probe in action.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下探针的实际运行情况。
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We created the Pod with the probe. Now we must wait until the probe fails a
    few times. A minute is more than enough. Once we''re done waiting, we can describe
    the Pod:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了带有探针的Pod。现在我们必须等待探针失败几次。一分钟就足够了。一旦等待完成，我们可以描述Pod：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The bottom of the output contains events. They are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的底部包含事件。它们如下所示：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can see that, once the container started, the probe was executed, and that
    it failed. As a result, the container was killed only to be created again. In
    the preceding output, we can see that the process was repeated three times (`3x
    over ...`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，一旦容器启动，探针就会执行，并且失败了。因此，容器被终止后又重新创建。在前面的输出中，我们可以看到这个过程重复了三次（`3x over ...`）。
- en: Please visit [Probe v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core)
    ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core))
    if you'd like to learn all the available options.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解所有可用的选项，请访问[Probe v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core)（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#probe-v1-core)）。
- en: Pods are (almost) useless (by themselves)
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod本身（几乎）没有用处。
- en: Pods are fundamental building blocks in Kubernetes. In most cases, you will
    not create Pods directly. Instead, you'll use higher level constructs like Controllers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes中的基本构建块。在大多数情况下，你不会直接创建Pod，而是使用更高层次的构建块，如控制器。
- en: Pods are disposable. They are not long lasting services. Even though Kubernetes
    is doing its best to ensure that the containers in a Pod are (almost) always up-and-running,
    the same cannot be said for Pods. If a Pod fails, gets destroyed, or gets evicted
    from a Node, it will not be rescheduled. At least, not without a Controller. Similarly,
    if a whole node is destroyed, all the Pods on it will cease to exist. Pods do
    not heal by themselves. Excluding some special cases, Pods are not meant to be
    created directly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是可消耗的，它们不是持久的服务。尽管Kubernetes尽力确保Pod中的容器（几乎）始终正常运行，但Pod本身却不能这样。如果Pod失败、被销毁或从节点中驱逐，它将不会重新调度，至少没有控制器的情况下是如此。类似地，如果整个节点被销毁，节点上的所有Pod将会消失。Pod不会自我修复。除了某些特殊情况，Pod并不是用来直接创建的。
- en: Do not create Pods by themselves. Let one of the controllers create Pods for
    you.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要自行创建Pod。让控制器为你创建Pod。
- en: What now?
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在怎么办？
- en: We'll remove the cluster and start the next chapter fresh.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除集群并重新开始下一章。
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Please take some time to get more familiar with Pods. They are the most basic
    and, arguably, the essential building block in Kubernetes. Since, by now, you
    have a solid understanding what the Pods are, a good next step might be to go
    through PodSpec v1 core ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core))
    documentation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请花些时间更好地熟悉 Pods。它们是 Kubernetes 中最基础、也可以说是最关键的构建模块。既然你现在已经对 Pods 有了扎实的理解，接下来的一个好步骤可能是阅读
    PodSpec v1 核心文档（[https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#pod-v1-core)）。
- en: '![](img/69055cc6-8934-4c02-b717-ab650ec5dffc.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69055cc6-8934-4c02-b717-ab650ec5dffc.png)'
- en: 'Figure 3-4: The components explored so far'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：至今为止探索的组件
