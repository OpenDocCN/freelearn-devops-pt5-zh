<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Kubernetes Overview</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we discussed container architecture, worked with Docker images and containers, took a look at different Docker registries, learned how to manage persistent storage for containers, and finally, learned how to build our own Docker image with Dockerfile. All these skills will be required in <a target="_blank" href="part0093.html#2OM4A0-78aafb146b304cdeb9b3261a70edabde" class="calibre8">Chapter 3</a>, <em class="calibre17">CRI-O Overview</em>, where we start working with Kubernetes. Kubernetes is an essential and critical OpenShift component. It all works like a snowball: Docker skills are required by Kubernetes, and Kubernetes skills are required by OpenShift.  </p>
<p class="calibre2">Container management in a distributed environment is difficult, but not with Kubernetes. This brief introduction to Kubernetes will give you an idea of what Kubernetes is and how it works. In this chapter, you will learn how to install and configure a Kubernetes cluster using a simplified method. We will also explain the container management <span class="calibre11">basics,</span> including some theories regarding pods, services, and routes. We will show you how to deploy an application in a Kubernetes cluster.</p>
<div class="packt_infobox">Since, in our lab environment, we have only one Kubernetes node, we are going to use the Kubernetes cluster and Minikube VM terms interchangeably in this chapter. </div>
<p class="calibre2">In this chapter, we will look at the following:</p>
<ul class="calibre9">
<li class="calibre10">Container management systems <span>overview</span></li>
<li class="calibre10">The difference between Kubernetes and Docker Swarm</li>
<li class="calibre10"><span>Kubernetes key concepts</span></li>
<li class="calibre10"><span>Kubernetes </span>installation and configuration</li>
<li class="calibre10">Working with kubectl </li>
<li class="calibre10"><span>Clearing the virtual </span>environment</li>
<li class="calibre10"><span>Kubernetes </span>limitations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we are going to use the following technologies and software:</p>
<ul class="calibre9">
<li class="calibre10">Minikube</li>
<li class="calibre10">Bash Shell</li>
<li class="calibre10">GitHub</li>
<li class="calibre10">Kubernetes</li>
<li class="calibre10">Docker</li>
<li class="calibre10">Firefox</li>
</ul>
<p class="calibre2">You will be required to install Minikube on your laptop or any other virtual environment you are going to use. All the instructions<span class="calibre11"> </span><span class="calibre11">for installing Minikube </span>can be found at <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/" class="calibre8">https://kubernetes.io/docs/tasks/tools/install-minikube/</a>.</p>
<p class="calibre2">All the code for this chapter is located on GitHub at <a href="https://github.com/PacktPublishing/Learn-OpenShift" class="calibre8">https://github.com/PacktPublishing/Learn-OpenShift</a>. </p>
<p class="calibre2"><span class="calibre11">Bash Shell will be used as a part of your virtual environment.</span></p>
<p class="calibre2">Firefox or any other browser can be used to navigate through Docker Hub. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Container management systems overview</h1>
                
            
            <article>
                
<p class="calibre2">Containers offer unmatched benefits in terms of density, deployment speed, and scalability in comparison to virtualization. But containers by themselves are not enough to match all the requirements of today's business, which expects the infrastructure to be adaptable to dynamic challenges. It is quite simple to start and manage a couple dozen containers, but things get complicated when the number climbs to hundreds, which is very common for large workloads. This is where <strong class="calibre4">Container Orchestration Engines</strong> (<strong class="calibre4">COE</strong>) come in. They bring true power to containers, offering various mechanisms to deploy, destroy, and scale multiple containers rapidly.</p>
<p class="calibre2">There are multiple container management solutions available, with the most popular being Kubernetes and Docker Swarm:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Kubernetes</strong>: First released in July 2015, Kubernetes comes directly from Borg—a cluster management and job scheduling system developed by Google. Kubernetes was also developed by Google engineers; in fact, many developers who previously worked on Borg later moved to working on Kubernetes. Like Docker, it is written in Go, the language also designed and implemented by Google in 2007. It'<span>s built around the concept of resources—complex API entities that serve as an interface to the underlying mechanisms and</span> serialized in YAML or JSON<span>. All software components run on two types of machine: masters and nodes. Masters perform management, dispatching, and synchronization functions, while nodes provide a runtime environment for running containers.</span></li>
<li class="calibre10"><strong class="calibre1">Docker Swarm</strong>: Docker Swarm is a native container orchestration solution provided by the Docker project. It has many features that Kubernetes provides, but does this using different mechanisms and can be used to quickly deploy a single service or even a stack of services on worker nodes. Swarm Cluster consists of two types of node: managers and workers. Managers control the placement of containers, which are referred to as <em class="calibre28">tasks</em> in Swarm terminology, and workers do the heavy lifting of running containers.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Kubernetes versus Docker Swarm</h1>
                
            
            <article>
                
<p class="calibre2">Kubernetes and Docker Swarm are the most commonly used orchestration frameworks. They provide a similar set of capabilities and essentially solve the same problem—management containers in an unsafe and highly dynamic environment. While some of their features overlap, there are also significant differences and the choice of system depends on many factors, such as the number of containers, availability requirements, and team expertise, to name a few.</p>
<p class="calibre2">The table provides an insight into the most important differences:</p>
<div class="title-page-name">
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Kubernetes</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Docker Swarm</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">A separate modular design project that has its own dependencies.</p>
</td>
<td class="calibre25">
<p class="calibre2">Native container orchestration solution available out of the box.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Relatively steep learning curve due to new concepts and complex architecture.</p>
</td>
<td class="calibre25">
<p class="calibre2">Easy to get started; uses familiar terminology; more lightweight.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">A pod is a minimal unit of deployment which represents a group of containers. Integration with other applications is accomplished via services that in this case represent a consistent <kbd class="calibre12">IP:port</kbd> pair.</p>
</td>
<td class="calibre25">
<p class="calibre2">Application deployed in containers as services across an entire cluster or a subset of workers using labels.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Auto-scaling is supported via deployments/replication controllers by specifying a desired number of pods. Dynamic auto-scaling that takes CPU utilization into account is provided by the <kbd class="calibre12">HorizontalPodAutoscaler</kbd> resource.</p>
</td>
<td class="calibre25">
<p class="calibre2">Auto-scaling is not supported out of the box; manual scaling is still possible.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">A persistence storage layer is separated into two components, PVs and PVCs, which are dynamically bound together on request and can be used to implement shared storage.</p>
</td>
<td class="calibre25">
<p class="calibre2">Storage volumes are mounted directly into containers.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">New masters can join an existing cluster, but promotion/demotion of a node is not supported.</p>
</td>
<td class="calibre25">
<p class="calibre2">Worker nodes can be easily promoted to managers and vice versa.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Services are assigned unique DNS names based on the projects they were created in and their names, so each service can reach any other in the same namespace by using its name without domains.</p>
</td>
<td class="calibre25">
<p class="calibre2">Each service is registered in an internal DNS with the name based solely on the name of the service itself.</p>
</td>
</tr>
</tbody>
</table>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Kubernetes key concepts</h1>
                
            
            <article>
                
<p class="calibre2">Like any complex system, a Kubernetes cluster can be viewed from multiple perspectives. From the infrastructure perspective, it comprises two sets of nodes; they can be bare-metal servers as well as VMs:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Masters</strong>:</li>
</ul>
<p class="calibre27">This type of node is responsible for cluster management, network allocation, quota enforcement, synchronization, and communication. Master nodes act as the main point of contact for clients—be it actual people or some external system. In the simplest setup, there can be only one master, but highly available clusters require at least two to prevent common fail situations. The most important service that masters run is the API.</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Nodes</strong>:</li>
</ul>
<p class="calibre27">Nodes do the actual work of hosting Docker containers. More specifically, nodes provide a runtime environment for running pods, which are described later in this book. These servers run the kubelet service to manage pods:</p>
<p class="cdpaligncenter"><img class="alignnone22" src="../images/00027.gif"/></p>
<div class="cdpaligncenter1"> Kubernetes architecture</div>
<p class="calibre2">Logically, the Kubernetes API provides a number of resources that allow you to use various mechanisms provided by Kubernetes while abstracting some low-level implementation details. These resources can be defined in either YAML or JSON format. Here are some of them:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Namespaces</strong>: These resources serve the purpose of separating organizational units of users and their projects in a multitenant environment. Moreover, they are used for more fine-grained access control and quota enforcement. Almost all Kubernetes resources, except Volumes and Namespaces themselves, are namespaced, which means their names must be unique in any given namespace.</li>
<li class="calibre20"><strong class="calibre1">Pods</strong>: Pods represent a collection of containers and each pod serves as a basic management unit in Kubernetes. All containers in a pod share the same storage volumes and network.</li>
<li class="calibre20"><strong class="calibre1">Services</strong>: They represent an interface between clients and the actual application running in pods. A service is an <kbd class="calibre12">IP:port</kbd> pair which forwards traffic to backend pods in a round-robin fashion. Having a consistent address and port saves clients having to keep up with any transient changes in the cluster.</li>
<li class="calibre20"><strong class="calibre1">Replication Controllers</strong> (<strong class="calibre1">RC</strong>): In a nutshell, these resources define how many pods must be replicated. Their definitions include pod templates that describe pods to be launched, and one of the parameters each RC contains is the number of replicas to be maintained. If for some reason one or more of the pods go down, Kubernetes will launch new ones to satisfy this number.</li>
<li class="calibre20"><strong class="calibre1">Persistent Volumes</strong> (<strong class="calibre1">PV</strong>): These resources abstract actual physical storage systems, be it NFS, iSCSI, or something else. Typically, they are created by a cluster administrator and can be mounted inside a pod using the PVC binding mechanism, which is mentioned later.</li>
<li class="calibre20"><strong class="calibre1">Persistent Volume Claims</strong> (<strong class="calibre1">PVC</strong>): PVC represents a request for storage resources. Pod definitions don't use PVs directly; instead, they rely on binding PVs to PVCs, performed by Kubernetes.</li>
<li class="calibre20"><strong class="calibre1">Secrets</strong>: Used for passing sensitive data such as keys, tokens, and passwords inside pods.</li>
<li class="calibre20"><strong class="calibre1">Labels</strong>: Labels provide a mechanism for scoping a set of resources using selectors. For example, services use selectors to specify what pods to forward incoming traffic to. When new pods are started with the same label, they are dynamically associated with the service that has their label specified as a selector in its definition.</li>
</ul>
<p class="calibre2">Here is a sample scenario with two teams residing in Denver and Phoenix, with separate namespaces. Selectors, labels, and a number of replicas are specified using the same notation as in actual YAML definitions of services, pods, and replication controllers, respectively:</p>
<p class="cdpaligncenter"><img class="alignnone23" src="../images/00028.jpeg"/></p>
<div class="cdpaligncenter1">Kubernetes resources</div>
<p class="calibre2">From a service point of view, Kubernetes can be represented as a set of interacting services:</p>
<ul class="calibre9">
<li class="calibre20">These services typically run on masters:
<ul class="calibre29">
<li class="calibre20"><kbd class="calibre12">etcd</kbd>: This is a distributed key-value configuration store that holds all metadata and  cluster resources. Due to its quorum model, you are advised to run an uneven number of etcd nodes, starting from three in a highly available setup.</li>
<li class="calibre20"><kbd class="calibre12">kube-apiserver</kbd>: Service that exposes the Kubernetes API to clients. Its stateless nature enables it to be deployed in a highly available configuration by scaling horizontally.</li>
<li class="calibre20"><kbd class="calibre12">kube-scheduler</kbd>: Component that governs the placement of newly created pods on nodes. This procedure takes into account such factors as hardware/policy limitations, data locality, and affinity rules. It is worth noting that from the cluster point of view, masters are no different from any other node and thus can be eligible for running pods, although best practices suggest not putting additional strain on master nodes and dedicating them only to management functions.</li>
<li class="calibre20"><kbd class="calibre12">kube-controller-manager</kbd>: The component that runs various controllers—some of them are replication controllers that maintain the required number of running pods, node controllers for discovering nodes that went down, a volume controller for binding PVs to PVCs, and an endpoints controller that binds services and pods together.</li>
<li class="calibre20"><kbd class="calibre12">cloud-controller-manager</kbd>: Service that provides integration with underlying cloud providers, such as DigitalOcean and Oracle Cloud Infrastructure.</li>
</ul>
</li>
</ul>
<ul class="calibre9">
<li class="calibre20">
<p class="calibre2">These services typically run on nodes:</p>
<ul class="calibre29">
<li class="calibre20"><strong class="calibre1">kubelet</strong>: This service uses a pod specification to manage its pods and conduct periodic health checks.</li>
<li class="calibre20"><strong class="calibre1">kubeproxy</strong>: This component implements service abstraction by providing TCP and UDP forwarding capabilities across a set of backend pods.</li>
<li class="calibre20"><strong class="calibre1">Container runtime environment</strong>: This component is represented in Kubernetes by an underlying container technology. At the time of writing, Kubernetes supports docker and rkt as runtimes:</li>
</ul>
</li>
</ul>
<p class="cdpaligncenter"><img class="alignnone24" src="../images/00029.gif"/></p>
<div class="cdpaligncenter1">Kubernetes services</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Kubernetes installation and configuration</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you will install Minikube—a simple single-node Kubernetes cluster. While not suitable for any production-grade workload, it is a useful tool to learn the basics of cluster management quickly. Although it supports several drivers for VM providers, in this tutorial we will use the KVM2 driver since KVM virtualization is available even in a base Linux environment.</p>
<p class="calibre2">The easiest method is to go to <a href="https://kubernetes.io/docs/getting-started-guides/minikube/" class="calibre8">https://kubernetes.io/docs/getting-started-guides/minikube/</a> and install Minikube on your favorite OS. Then go to <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" class="calibre8">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a> and install <kbd class="calibre12">kubectl</kbd>. <kbd class="calibre12">kubectl</kbd> is a CLI command to manage Kubernetes. Once you are done, it is time to start Minikube:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube start</strong><br class="title-page-name"/>Starting local Kubernetes v1.9.0 cluster...<br class="title-page-name"/>Starting VM...<br class="title-page-name"/>Downloading Minikube ISO<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>Kubectl is now configured to use the cluster.<br class="title-page-name"/>Loading cached images from config file.</pre>
<p class="calibre2">Once download and setup stages are complete, check your Kubernetes cluster status with the <kbd class="calibre12">minikube</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube status</strong><br class="title-page-name"/>minikube: Running<br class="title-page-name"/>cluster: Running<br class="title-page-name"/>kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.101</pre>
<p class="calibre2"><span class="calibre11">Check the Kubernetes cluster status with the <kbd class="calibre12">kubectl</kbd> command:</span></p>
<pre class="calibre18"><strong class="calibre1">$ kubectl cluster-info</strong><br class="title-page-name"/>Kubernetes master is running<strong class="calibre1"> at https://192.168.99.101:8443</strong></pre>
<p class="calibre2">We can also open a browser or use the curl command to verify the Kubernetes API:</p>
<pre class="calibre18"><strong class="calibre1">$ curl https://192.168.99.101:8443</strong><br class="title-page-name"/>{<br class="title-page-name"/>"kind": "Status",<br class="title-page-name"/>"apiVersion": "v1",<br class="title-page-name"/>"metadata": {<br class="title-page-name"/>},<br class="title-page-name"/>"status": "Failure",<br class="title-page-name"/>"message": "Unauthorized",<br class="title-page-name"/>"reason": "Unauthorized",<br class="title-page-name"/>"code": 401<br class="title-page-name"/>}</pre>
<p class="calibre2">There is a nice dashboard that comes with Kubernetes's nice-looking GUI, available on port <kbd class="calibre12">30000</kbd> via HTTP (for example, <kbd class="calibre12">http://192.168.99.100:30000/</kbd>). You can open your browser using the same IP we used for cluster verification:</p>
<p class="cdpaligncenter"><img class="alignnone25" src="../images/00030.jpeg"/></p>
<div class="cdpaligncenter2">Kubernetes GUI </div>
<p class="calibre2">At this moment, there is not much to look at, as our simple cluster has only one node, one service, and three default namespaces. This is one way to manage Kubernetes, but to be able to effectively use all its features and troubleshoot issues, you need to get comfortable with using CLI, which is what the next section is about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with kubectl</h1>
                
            
            <article>
                
<p class="calibre2">Kubectl is a command-line interface for managing a Kubernetes cluster and its resources. In this section, you will learn about the most common commands and their use cases.</p>
<p class="calibre2">The syntax for all the commands follows this convention:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl &lt;COMMAND&gt; &lt;RESOURCE_TYPE&gt; &lt;RESOURCE_NAME&gt; &lt;OPTIONS&gt;</strong></pre>
<p class="calibre2">Commands in angle brackets <kbd class="calibre12">&lt;&gt;</kbd> mean the following:</p>
<ul class="calibre9">
<li class="calibre20"><kbd class="calibre12">COMMAND</kbd>: An action to be executed against one or more resources.</li>
<li class="calibre20"><kbd class="calibre12">RESOURCE_TYPE</kbd>: The type of resource to be acted upon, for example, a pod or service.</li>
<li class="calibre20"><kbd class="calibre12">RESOURCE_NAME</kbd>: The name of the resource(s) to manage.</li>
<li class="calibre20"><kbd class="calibre12">OPTIONS</kbd>: Various flags used to modify the behavior of kubectl commands. They have higher priority than default values and environment variables, thus overriding them.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting help</h1>
                
            
            <article>
                
<p class="calibre2">kubectl has hundreds of different subcommands, options, and arguments. Luckily, kubectl has really good help options. <span class="calibre11">The first one is man pages. </span>If you are using macOS or Linux, you can run the <kbd class="calibre12">man-f kubectl</kbd> command to check kubectl-related man pages:</p>
<pre class="calibre18"><strong class="calibre1">$ man -f kubectl</strong><br class="title-page-name"/>kubectl(1) - kubectl controls the Kubernetes cluster manager<br class="title-page-name"/>kubectl-alpha(1), kubectl alpha(1) - Commands for features in alpha<br class="title-page-name"/>kubectl-alpha-diff(1), kubectl alpha diff(1) - Diff different versions of configurations<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">If for some reason you do not have man pages available on your system, you can just run the <kbd class="calibre12">kubectl</kbd> command without any options or arguments. It will show you a list of available subcommands:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl</strong><br class="title-page-name"/>kubectl controls the Kubernetes cluster manager.<br class="title-page-name"/>Find more information at https://github.com/kubernetes/kubernetes.<br class="title-page-name"/>Basic Commands (Beginner):<br class="title-page-name"/>  create Create a resource from a file or from stdin.<br class="title-page-name"/>  expose Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>Basic Commands (Intermediate):<br class="title-page-name"/> get Display one or many resources<br class="title-page-name"/> explain Documentation of resources<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>Use "kubectl &lt;command&gt; --help" for more information about a given command.<br class="title-page-name"/>Use "kubectl options" for a list of global command-line options (applies to all commands)</pre>
<p class="calibre2">The next step is to check the list of available resources by running <kbd class="calibre12">kubectl &lt;command&gt;</kbd> or <kbd class="calibre12"><span>kubectl &lt;command&gt; --help</span></kbd> commands, for example, <kbd class="calibre12">kubectl get</kbd>:</p>
<pre class="calibre18"><span><strong class="calibre1">$ kubectl get</strong><br class="title-page-name"/>  * all<br class="title-page-name"/>  * certificatesigningrequests (aka 'csr')<br class="title-page-name"/>  * clusterrolebindings<br class="title-page-name"/></span>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<span><br class="title-page-name"/>Use "kubectl explain &lt;resource&gt;" for a detailed description of that resource (e.g. kubectl explain pods).<br class="title-page-name"/>See 'kubectl get -h' for help and examples.<br class="title-page-name"/></span></pre>
<p class="calibre2">As you can see, you can also get <kbd class="calibre12">kubectl get</kbd> command examples by running <kbd class="calibre12">kubectl get -h</kbd> and a detailed resource explanation by running <kbd class="calibre12">kubectl explain pods</kbd>. The <kbd class="calibre12">kubectl</kbd> command is very easy to navigate and work with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the kubectl get command</h1>
                
            
            <article>
                
<p class="calibre2">The first essential command to run is <kbd class="calibre12">kubectl get nodes</kbd>. It gives us the number of Kubernetes nodes available:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get nodes</strong><br class="title-page-name"/>NAME      STATUS  ROLES   AGE   VERSION<br class="title-page-name"/>minikube   Ready   &lt;none&gt; 2h    v1.9.0</pre>
<p class="calibre2">In our case, the number of nodes will be equal to one, since we are using one VM for our practice. As we mentioned already, in order for different projects to coexist on the same or different nodes, namespaces are used. You may guess that the command we should use is <kbd class="calibre12">kubectl get namespaces</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get namespaces</strong><br class="title-page-name"/>NAME          STATUS   AGE<br class="title-page-name"/>default       Active   15h<br class="title-page-name"/>kube-public   Active   15h<br class="title-page-name"/>kube-system   Active   15h</pre>
<p class="calibre2">It shows you that three default namespaces are available when you install Kubernetes with Minikube:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<div class="cdpaligncenter2"><strong class="calibre1">Name       </strong>                          </div>
</td>
<td class="calibre25">
<div class="cdpaligncenter2"><strong class="calibre1">Description</strong></div>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">default</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">The namespace where all resources without other namespaces are placed. It is used when <span class="calibre11">the</span> name<span class="calibre11"> </span>of a namespace is not specified.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">kube-<span>public</span></kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">Used for resources that must be publicly available even to unauthenticated users.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">kube-system</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">As the name implies, it is used internally by Kubernetes itself for all system resources.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"><br class="calibre5"/>
The last main missing component here is pods; as previously mentioned, <span class="calibre11">pods represent a collection of containers and a pod is a basic management unit in Kubernetes. In our case, pods are Docker containers. We do not have any</span><span class="calibre11"> running pods yet, which can be easily verified by <kbd class="calibre12">kubectl get pods</kbd>:</span></p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>No resources found.</pre>
<p class="calibre2">It says <kbd class="calibre12">No resources found</kbd>, all because the pod is a Kubernetes resource, similar to other resources we are going to cover in this book.</p>
<div class="packt_tip"><span>Similarly to <kbd class="calibre26">kubectl get pods</kbd>, you can get the status of any other Kubernetes resource. We will discuss other Kubernetes resources later in this chapter.  </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running Kubernetes pods</h1>
                
            
            <article>
                
<p class="calibre2">As with Docker, we can run a Kubernetes pod with the <kbd class="calibre12">kubectl run</kbd> command. Let's start with a simple web server example:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl run httpd --image=httpd</strong></pre>
<p class="calibre2"><span class="calibre11">We can verify the result by getting a list of Kubernetes pods, by running the <kbd class="calibre12">kubectl get pods</kbd> command:</span></p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME                      READY    STATUS    RESTARTS    AGE<br class="title-page-name"/>httpd-8576c89d7-qjd62      1/1     Running    0          6m</pre>
<div class="packt_infobox">The first time you run this command, you will probably see that the Kubernetes pod status shows up as <kbd class="calibre26">ContainerCreating</kbd>. What is happening behind the scenes is that the Docker httpd image is being downloaded to Minikube VM. Be patient and give it some time to download the image. A few minutes later you should be able to see the container status is <kbd class="calibre26">Running</kbd>. <br class="title-page-name"/>
<br class="title-page-name"/>
The <kbd class="calibre26">kubectl run</kbd> command does more than just download an image and run a container out of it. We are going to cover this later in this chapter.<br class="title-page-name"/>
<br class="title-page-name"/>
The <kbd class="calibre26">8576c89d7-qjd62</kbd> part is generated automatically. We are going to discuss this later in this chapter.</div>
<p class="calibre2">Essentially, this pod is a Docker container inside our Minikube VM, and we can easily verify this. First, we need to ssh into Minikube VM with <kbd class="calibre12">minikube ssh</kbd>, and then run the <kbd class="calibre12">docker ps</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube ssh</strong><br class="title-page-name"/>$<br class="title-page-name"/><strong class="calibre1">$ docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br class="title-page-name"/>c52c95f4d241 httpd "httpd -g 'daemon ..." 12 minutes ago Up 12 minutes k8s_httpd-container_httpd_default_39531635-23f8-11e8-ab32-080027dcd199_0<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">We can try to kill this httpd Docker container, but Kubernetes will automatically spawn the new one:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm -f c52c95f4d241  </strong> </pre>
<p class="calibre2">Check the container status one more time:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br class="title-page-name"/>5e5460e360b6 httpd "httpd -g 'daemon ..." 5 seconds ago Up 5 seconds k8s_httpd-container_httpd_default_4f5e05df-2416-11e8-ab32-080027dcd199_0<br class="title-page-name"/><strong class="calibre1">$ exit</strong></pre>
<div class="packt_infobox"><span>Note that the </span>httpd<span> container is still up, but with another ID. The initial ID was <kbd class="calibre26">c52c95f4d241</kbd> and it became <kbd class="calibre26">5e5460e360b6</kbd> (you will have other IDs). That is one of the benefits of Kubernetes: if one container dies, Kubernetes will bring in a new one automatically. We are going to discuss this in detail later in this chapter.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Describing Kubernetes resources </h1>
                
            
            <article>
                
<p class="calibre2">We can quickly take a look at the internals of this pod by running the <kbd class="calibre12">kubectl describe</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl describe pod httpd-8576c89d7-qjd62</strong><br class="title-page-name"/>Name: httpd<br class="title-page-name"/>Namespace: default<br class="title-page-name"/>Node: minikube/192.168.99.101<br class="title-page-name"/>Start Time: Sat, 10 Mar 2018 00:01:33 -0700<br class="title-page-name"/>Annotations: &lt;none&gt;<br class="title-page-name"/>Status: Running<br class="title-page-name"/>IP: 172.17.0.4<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">It gives us enough information to efficiently locate the pod and do the proper troubleshooting when necessary. In our case, we can ssh to Minikube VM and run the curl command to check if the pod is running the web server properly. </p>
<div class="packt_infobox">You may need to use another IP address for the <kbd class="calibre26">curl</kbd> command; in our case it is <kbd class="calibre26">172.17.0.4</kbd>, derived from the <kbd class="calibre26">kubectl describe</kbd> command output.</div>
<pre class="calibre18"><strong class="calibre1">$ minikube ssh</strong><br class="title-page-name"/>$<br class="title-page-name"/><strong class="calibre1">$ curl 172.17.0.4</strong><br class="title-page-name"/>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<br class="title-page-name"/><strong class="calibre1">$ exit</strong></pre>
<div class="packt_infobox">Note that this pod is accessible only inside the Kubernetes cluster. That is the reason why we need to log in to Minikube VM. If we try to access this address from our local PC, it will not work. We are going to discuss this in the following sections.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Editing Kubernetes resources</h1>
                
            
            <article>
                
<p class="calibre2">We can also edit the properties of a running container with <kbd class="calibre12">kubectl edit pod httpd-8576c89d7-qjd62</kbd>. We are not going to change anything at this point, but you can try to change something before we delete the container. We are going to work with the edit command while working with OpenShift in further chapters.</p>
<div class="packt_tip">The <kbd class="calibre26">kubectl edit</kbd> command by default uses the vi editor. Learn how to use vi first if you are not familiar with this text editor, otherwise you might get into trouble. <br class="title-page-name"/>
<br class="title-page-name"/>
Another trick that you can do is to change the editor by running <kbd class="calibre26">export EDITOR=nano</kbd>, where nano is your favorite text editor.</div>
<p class="calibre2">Similarly, you can edit any other Kubernetes resources. We will discuss other Kubernetes resources later in this chapter.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exposing Kubernetes services</h1>
                
            
            <article>
                
<p class="calibre2">When we run a pod using the <kbd class="calibre12">kubectl run</kbd> command, this pod is accessible only inside Kubernetes. In most of cases, we would want this pod to be accessible from the outside as well. This is where the <kbd class="calibre12">kubectl expose</kbd> command comes in handy. Let's create the httpd pod one more time and then expose it to the outside world:</p>
<pre class="calibre18"><span><strong class="calibre1">$ kubectl run httpd --image=httpd</strong><br class="title-page-name"/></span><br class="title-page-name"/><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME READY STATUS RESTARTS AGE<br class="title-page-name"/>httpd-66c6df655-8h5f4 1/1 Running 0 27m</pre>
<p class="calibre2">Now let's use the <kbd class="calibre12">kubectl expose</kbd> command and expose the httpd web server to the outside of Kubernetes:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl expose pod httpd-66c6df655-8h5f4 --port=80 --name=httpd-exposed --type=NodePort</strong></pre>
<p class="calibre2">While using the <kbd class="calibre12">kubectl expose</kbd> command, we specify several options:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre12">port</kbd>: Pod (Docker container) port that we are going to expose to the outside of the Kubernetes cluster.</li>
<li class="calibre10"><kbd class="calibre12">name</kbd>: Kubernetes service name.</li>
<li class="calibre10"><kbd class="calibre12">type</kbd>: Kubernetes service type. NodePort uses Kubernetes Node IP.  </li>
</ul>
<p class="calibre2">The command to get a list of exposed Kubernetes services is <kbd class="calibre12">kubectl get services</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get services</strong><br class="title-page-name"/>NAME         TYPE     CLUSTER-IP   EXTERNAL-IP   PORT(S)      AGE<br class="title-page-name"/>kubernetes   ClusterIP 10.96.0.1    &lt;none&gt;     443/TCP         1d<br class="title-page-name"/>httpd-exposed NodePort 10.110.40.149&lt;none&gt;     80:31395/TCP    3s</pre>
<div class="packt_infobox">Note that port <kbd class="calibre26">80</kbd> was mapped to dynamic port <kbd class="calibre26">31395</kbd> on the Minikube VM. The port is dynamically chosen in the range <kbd class="calibre26">30000–32767</kbd>.<br class="title-page-name"/>
<br class="title-page-name"/>
<span>Also, there is a <kbd class="calibre26">ClusterIP</kbd> field with the IP address <kbd class="calibre26">10.110.40.149</kbd> allocated for the <kbd class="calibre26">httpd-expose</kbd> service. Do not pay attention to this at the moment; we are going to discuss this later in the book.</span></div>
<p class="calibre2">Finally, use <kbd class="calibre12">curl</kbd> to check if the httpd server is available from the outside of the Kubernetes cluster:</p>
<pre class="calibre18"><strong class="calibre1">$ curl 192.168.99.101:31395</strong><br class="title-page-name"/>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</pre>
<p class="calibre2">If you open this link in your web browser, you should see <kbd class="calibre12">It works!</kbd> on the web page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Kubernetes labels</h1>
                
            
            <article>
                
<p class="calibre2">When you have an application that consists of one pod and one service, there is no problem operating these resources. But when your application grows, or you have tens or hundreds of projects, pods, services and other Kubernetes resources, it will get harder to operate and effectively troubleshoot Kubernetes. This is where we can use the Kubernetes labels we mentioned earlier in this chapter. We are going to run a couple more Kubernetes pods using labels:</p>
<pre class="calibre18"><span><strong class="calibre1">$ kubectl run httpd1 --image=httpd --labels="app=httpd-demo1"</strong><br class="title-page-name"/><strong class="calibre1">$ kubectl run httpd2 --image=httpd --labels="app=httpd-demo2"</strong><br class="title-page-name"/></span></pre>
<p class="calibre2">Check the Kubernetes pods we have at the moment:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME READY STATUS RESTARTS AGE<br class="title-page-name"/>httpd-8576c89d7-qjd62 1/1 Running 0 17m<br class="title-page-name"/>httpd1-c9f7d7fd9-rn2nz 1/1 Running 0 21s<br class="title-page-name"/>httpd2-5b4ff5cf57-9llkn 1/1 Running 0 15s</pre>
<p class="calibre2">Now, imagine you have at least 10 or more pods. In order to efficiently filter out this output, we can use the <kbd class="calibre12">-l</kbd> option:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get pods -l="app=httpd-demo2"</strong><br class="title-page-name"/>NAME                   READY       STATUS      RESTARTS       AGE<br class="title-page-name"/>httpd2-5b4ff5cf57-9llkn 1/1         Running    0              2m</pre>
<div class="packt_infobox">Filtering out output with Kubernetes labels is not the only use case. Labels are also used alongside selectors. You can get more information on both topics using the Kubernetes official documentation at <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" class="calibre6">https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deleting Kubernetes resources</h1>
                
            
            <article>
                
<div class="title-page-name">
<p class="calibre2">If we've done something wrong with the pod, or it may have broken for some reason, there is a simple way to delete a pod using the <kbd class="calibre12">kubectl delete pod</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl delete pod httpd-8576c89d7-qjd62</strong><br class="title-page-name"/>pod "httpd-8576c89d7-qjd62" deleted<strong class="calibre1"> </strong></pre></div>
<p class="calibre2">We can delete all pods using the <kbd class="calibre12">--all</kbd> option:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl delete pod --all</strong><br class="title-page-name"/>pod "httpd-8576c89d7-qjd62" deleted<br class="title-page-name"/>pod "httpd1-c9f7d7fd9-rn2nz" deleted<br class="title-page-name"/>pod "httpd2-5b4ff5cf57-vlhb4" deleted</pre>
<div class="packt_infobox">Note that if you run <kbd class="calibre26">kubectl get pods</kbd>, you will see all the containers running again. The reason for this is that, when we run the <kbd class="calibre26">kubectl run</kbd> command, it creates several different Kubernetes resources, which we are going to discuss in the following section.</div>
<p class="calibre2">We can delete Kubernetes resources by running <kbd class="calibre12"><span>kubectl delete all</span></kbd> with the <kbd class="calibre12">-l</kbd> option:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl delete all -l app=httpd-demo1</strong><br class="title-page-name"/>deployment "httpd1" deleted<br class="title-page-name"/>pod "httpd1-c9f7d7fd9-d9w94" deleted<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME READY STATUS RESTARTS AGE<br class="title-page-name"/>httpd-8576c89d7-qjd62 1/1 Running 0 17m<br class="title-page-name"/>httpd2-5b4ff5cf57-9llkn 1/1 Running 0 15s</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">This command will delete all Kubernetes with a <kbd class="calibre12">httpd-demo1</kbd> label only. The other two pods will be still available.</p>
<p class="calibre2">Alternatively, we can delete all Kubernetes resources we have created so far by running the <kbd class="calibre12">kubectl delete all --all</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl delete all --all</strong><br class="title-page-name"/>deployment "httpd" deleted<br class="title-page-name"/>deployment "httpd2" deleted<br class="title-page-name"/>pod "httpd-8576c89d7-ktnwh" deleted<br class="title-page-name"/>pod "httpd2-5b4ff5cf57-t58nd" deleted<br class="title-page-name"/>service "kubernetes" deleted<br class="title-page-name"/>service "nginx-exposed" deleted</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Kubernetes advanced resources</h1>
                
            
            <article>
                
<p class="calibre2">When we create an application with the <kbd class="calibre12">kubectl run</kbd> command, it takes care of several things. Let's create an httpd pod by running this command one more time and take a deeper look at what actually happens behind the scenes:</p>
<pre class="calibre18"><strong class="calibre1"><span>$ kubectl run httpd1 --image=httpd</span></strong></pre>
<p class="calibre2">We can take a look at the series of events that took place during this process by running the <kbd class="calibre12">kubectl get events</kbd> command. It shows you what Kubernetes did behind the scenes to launch this application. You will see quite a long list, which may seem confusing at first glance, but we can narrow it down by using the following command: </p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 8</strong><br class="title-page-name"/>4s 4s ... kubelet, minikube pulling image "httpd"<br class="title-page-name"/>4s 4s ... replicaset-controller Created pod: httpd1-6d8bb9cdf9-thlkg<br class="title-page-name"/>4s 4s ... default-scheduler Successfully assigned httpd1-6d8bb9cdf9-thlkg to minikube<br class="title-page-name"/>4s 4s ... deployment-controller Scaled up replica set httpd1-6d8bb9cdf9 to 1<br class="title-page-name"/>4s 4s ... kubelet, minikube MountVolume.SetUp succeeded for volume "default-token-dpzmw"<br class="title-page-name"/>2s 2s ... kubelet, minikube Created container<br class="title-page-name"/>2s 2s ... kubelet, minikube Successfully pulled image "httpd"<br class="title-page-name"/>2s 2s ... kubelet, minikube Started container</pre>
<div class="packt_infobox">We are using the <kbd class="calibre26">kubectl get events</kbd> command with the <span><kbd class="calibre26">--sort-by=.metadata.creationTimestamp</kbd> option to sort our events by timestamp. If you execute this command without this option, events will be out of order.</span></div>
<p class="calibre2">We are mostly interested in the last two fields on every line. They are <kbd class="calibre12">SOURCE</kbd> and <kbd class="calibre12">MESSAGE</kbd> respectively. If we read from top to bottom in the series of events, we will see that one Kubernetes component tells the other component to create a pod with the name <kbd class="calibre12">httpd1-6d8bb9cdf9-thlkg</kbd> on Minikube VM, which finally happens. Let's describe some of those components:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre12">replicaset-controller</kbd>: Sometimes we need more than one <kbd class="calibre12">httpd</kbd> pod up and running to handle all the load for the application. ReplicaSet <span>makes sure that a certain number of pods are up and available.</span> <span>ReplicaSet is </span><span>controlled by the Deployment controller. </span></li>
<li class="calibre10"><kbd class="calibre12">default-scheduler</kbd>: Decides which node to run a specific pod on. In our case it is Minikube VM. </li>
<li class="calibre10"><kbd class="calibre12">deployment-controller</kbd>: Defines the desired state for a Kubernetes resource. In our case, it is a state of <kbd class="calibre12">httpd</kbd> pod. The <span>Deployment controller also instructs ReplicaSet to make sure that certain pods are running.  </span></li>
</ul>
<p class="calibre2">As already mentioned, the <kbd class="calibre12">kubectl run</kbd> command creates other Kubernetes resources including ReplicaSet and Deployment. We can verify that by running <kbd class="calibre12">kubectl get replicaset</kbd> and <span class="calibre11"><kbd class="calibre12">kubectl get deployment</kbd> respectively:</span></p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get deploy</strong><br class="title-page-name"/>NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE<br class="title-page-name"/>httpd1 1 1 1 1 38m<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ kubectl get rs</strong><br class="title-page-name"/>NAME DESIRED CURRENT READY AGE<br class="title-page-name"/>httpd1-6d8bb9cdf9 1 1 1 38m</pre>
<p class="calibre2">We mentioned that Deployment controller defines how many instances of <kbd class="calibre12">httpd</kbd> pods run. By default, this number is <kbd class="calibre12">1</kbd>. We can easily change this behavior and edit Deployment config with the <kbd class="calibre12">kubectl edit deploy httpd1</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl edit deploy httpd1<br class="title-page-name"/></strong>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>spec:<br class="title-page-name"/> replicas: 1 # change this value to 3<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Once you have changed the replica value to <kbd class="calibre12">3</kbd>, save <span class="calibre11">the changes </span>and exit edit mode. The Deployment controller will detect the changes in the config and instruct ReplicaSet to bring up two more <kbd class="calibre12">httpd</kbd> pods. Let's verify that:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME                    READY STATUS   RESTARTS      AGE<br class="title-page-name"/>httpd1-6d8bb9cdf9-hqks6  1/1   Running   0           5s<br class="title-page-name"/>httpd1-6d8bb9cdf9-thlkg  1/1   Running   0           48m<br class="title-page-name"/>httpd1-6d8bb9cdf9-xwmmz  1/1   Running   0           5s</pre>
<p class="calibre2">If we try to delete all the pods, ReplicaSet will run a new set of pods automatically. Let's see how it works one more time:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl delete pods --all</strong><br class="title-page-name"/>pod "httpd1-6d8bb9cdf9-hqks6" deleted<br class="title-page-name"/>pod "httpd1-6d8bb9cdf9-thlkg" deleted<br class="title-page-name"/>pod "httpd1-6d8bb9cdf9-xwmmz" deleted<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME READY STATUS RESTARTS AGE<br class="title-page-name"/>httpd1-6d8bb9cdf9-7nx7k 1/1 Running 0 16s<br class="title-page-name"/>httpd1-6d8bb9cdf9-gsxzp 1/1 Running 0 16s<br class="title-page-name"/>httpd1-6d8bb9cdf9-skdn9 1/1 Running 0 16s</pre>
<p class="calibre2">Delete all Kubernetes resources before we move on to the next section:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl delete all --all</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating kubernetes services using YAML and JSON files</h1>
                
            
            <article>
                
<p class="calibre2">You can also create Kubernetes resources manually using YAML and JSON files. Let's go ahead and create a simple pod running a<span class="calibre11"> </span>httpd<span class="calibre11"> </span>web server using the <kbd class="calibre12">kubectl create</kbd> command. We will have to create a YAML-formatted file:</p>
<pre class="calibre18"><strong class="calibre1">$ cat httpd-pod.yaml</strong><br class="title-page-name"/>apiVersion: v1<br class="title-page-name"/>kind: Pod<br class="title-page-name"/>metadata:<br class="title-page-name"/>  name: httpd<br class="title-page-name"/>  namespace: default<br class="title-page-name"/>spec:<br class="title-page-name"/>  containers:<br class="title-page-name"/>  - name: httpd-container<br class="title-page-name"/>    image: httpd<br class="title-page-name"/>    ports:<br class="title-page-name"/>    - containerPort: 80</pre>
<div class="packt_infobox">Reading YAML and JSON-formatted files is critical for Kubernetes and for later, in the OpenShift chapter. If you feel uncomfortable reading YAML or JSON files, read up on these subjects. Check the <em class="calibre28">Further reading</em> section for more information.</div>
<p class="calibre2">It may look a bit complicated and hard to understand, but as we move on in this book, you will see a lot of similarities between these YAML and JSON files. </p>
<div class="packt_tip">YAML configuration files are very structured and each resource is a set of keys and values. You can use the Kuberentes API documentation to find out what every parameter does: <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/" class="calibre6">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/</a>.</div>
<p class="calibre2">Create a pod using<span class="calibre11"> the </span><kbd class="calibre12">httpd-pod.yaml</kbd><span class="calibre11"> </span>file:</p>
<pre class="calibre18"><strong class="calibre1"><span>$ kubectl create -f </span>httpd</strong><span><strong class="calibre1">-pod.yaml</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ kubectl get all</strong><br class="title-page-name"/>NAME        READY       STATUS     RESTARTS     AGE<br class="title-page-name"/>po/httpd    1/1         Running       0         25s<br class="title-page-name"/><br class="title-page-name"/>NAME            TYPE     CLUSTER-IP    EXTERNAL-IP PORT(S) AGE<br class="title-page-name"/>svc/kubernetes ClusterIP 10.96.0.1     &lt;none&gt;     443/TCP  56s<br class="title-page-name"/></span></pre>
<p class="calibre2">This command creates a pod named <kbd class="calibre12">httpd</kbd>; it does not create anything else. In larger deployments with heavy automation involved, this is the way to deploy Kubernetes resources, but this, of course, requires better Kubernetes skills.</p>
<p class="calibre2">Similarly, we can create other Kubernetes resources, including ReplicaSet, Deployment, and others.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Clearing the virtual environment</h1>
                
            
            <article>
                
<p class="calibre2">Once you are done working with Kubernetes, you can easily stop the Minikube cluster by running the <kbd class="calibre12">minikube stop</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube stop</strong><br class="title-page-name"/>Stopping local Kubernetes cluster...<br class="title-page-name"/>Machine stopped.</pre>
<p class="calibre2">After that, you can delete the Minikube VM if you want by running the <kbd class="calibre12">minikube delete</kbd> <span class="calibre11">command:</span></p>
<pre class="calibre18"><strong class="calibre1">$ minikube delete</strong><br class="title-page-name"/>Deleting local Kubernetes cluster...<br class="title-page-name"/>Machine deleted.</pre>
<p class="calibre2">Verify that the Minikube cluster no longer exists:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube status</strong><br class="title-page-name"/>minikube:<br class="title-page-name"/>cluster:<br class="title-page-name"/>kubectl:</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Kubernetes limitations</h1>
                
            
            <article>
                
<p class="calibre2">Although it is a powerful orchestration engine, Kubernetes doesn't have the features that are commonly required by PaaS solutions such as OpenShift and others:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Security</strong>:</li>
</ul>
<p class="cdpalignleft1">Kubernetes namespaces are provided mainly for the purpose of resource quota enforcement for different groups of users, but they do not provide any security constraints or authentication. For example, every user from every namespace can see all other namespaces and their resources.</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Deployments</strong>:</li>
</ul>
<p class="calibre27">Kubernetes provides the means to create a deployment from an image with a single command, but doesn't create a service for external clients.</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">SCM integration</strong>:</li>
</ul>
<p class="calibre27">Kubernetes doesn't support integration with SCM via webhooks to facilitate deployment.</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Builds</strong>:</li>
</ul>
<p class="calibre27">Kubernetes doesn't provide advanced build modes such as <strong class="calibre4">Source-to-Image</strong> (<strong class="calibre4">S2I</strong>) and Custom Builder.</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Authentication</strong>:</li>
</ul>
<p class="calibre27">Support for advanced authentication schemes such as LDAP, Google, GitHub, Keystone, or Kerberos is achieved only through a webhook or authenticating proxy.</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">CI/CD</strong>:</li>
</ul>
<p class="calibre27">Kubernetes has no integrated application life cycle support, which makes it difficult to integrate it into a corporate software delivery framework.</p>
<p class="calibre2">All these limitations will be addressed in the OpenShift sections in subsequent chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we have briefly discussed Kubernetes concepts and the Kubernetes architecture, and the main difference between Kubernetes and Docker Swarm. We installed Kubernetes using Minikube, which is a very easy-to-use CLI tool with which to set up a Kubernetes lab environment. Then we used the <kbd class="calibre12">kubectl</kbd> command to perform various tasks such as running, editing, describing, and deleting Kubernetes pods and other Kubernetes resources. Finally, we finished by listing the main Kubernetes limitations, which we are going to address later in this book.  </p>
<p class="calibre2">In the next chapter, we are going to work with CRI-O, which is a universal container runtime interface that allows Kubernetes to provide support for different container platforms. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Questions</h1>
                
            
            <article>
                
<ol class="calibre13">
<li value="1" class="calibre10">What are the two Node types used by Kubernetes?:
<ol class="calibre14">
<li value="1" class="calibre10">Node</li>
<li value="2" class="calibre10">Minikube</li>
<li value="3" class="calibre10">Vagrant</li>
<li value="4" class="calibre10">Master</li>
</ol>
</li>
</ol>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Which container platforms are supported by Kuberntes? choose two:
<ol class="calibre14">
<li value="1" class="calibre10">Docker</li>
<li value="2" class="calibre10">OpenShift</li>
<li value="3" class="calibre10">Rkt</li>
<li value="4" class="calibre10">Minishift</li>
</ol>
</li>
<li value="3" class="calibre10">In Kubernetes, a pod is a minimal unit of deployment which represents a group of containers:
<ol class="calibre14">
<li value="1" class="calibre10">True</li>
<li value="2" class="calibre10">False</li>
</ol>
</li>
<li value="4" class="calibre10">What are the main two Kubernetes services running on a Kubernetes Node? choose two:
<ol class="calibre14">
<li value="1" class="calibre10">etcd</li>
<li value="2" class="calibre10">kubelet</li>
<li value="3" class="calibre10">kube-proxy</li>
<li value="4" class="calibre10">kube-node</li>
<li value="5" class="calibre10">kube-apiserver</li>
</ol>
</li>
<li value="5" class="calibre10">What are acceptable file formats for creating Kubernetes resources with the <kbd class="calibre12">kubectl create -f</kbd> command? choose two:
<ol class="calibre14">
<li value="1" class="calibre10">JSON</li>
<li value="2" class="calibre10">Jinja2</li>
<li value="3" class="calibre10">CSV</li>
<li value="4" class="calibre10">YANG</li>
<li value="5" class="calibre10">YAML</li>
</ol>
</li>
<li value="6" class="calibre10">Kubernetes has a built-in CI/CD toolset to improve corporate software delivery frameworks:
<ol class="calibre14">
<li value="1" class="calibre10">True</li>
<li value="2" class="calibre10">False</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Further reading</h1>
                
            
            <article>
                
<p class="calibre2">Since we are covering the very basics of Docker containers, you may be interested in diving into specific topics. Here's a list of links that may be helpful to look through to learn more about Docker and containers in general:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Kubernetes concepts</strong>: <a href="https://kubernetes.io/docs/concepts/" class="calibre8">https://kubernetes.io/docs/concepts/</a></li>
<li class="calibre10"><strong class="calibre1">Kubernetes CLI</strong>: <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl/" class="calibre8">https://kubernetes.io/docs/reference/generated/kubectl/kubectl/</a></li>
<li class="calibre10"><strong class="calibre1">Kubernetes installation</strong>:<a href="https://kubernetes.io/docs/setup/pick-right-solution/" class="calibre8"> https://kubernetes.io/docs/setup/pick-right-solution/</a></li>
<li class="calibre10"><strong class="calibre1">Kubernetes cheat sheet</strong>: <a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" class="calibre8">https://kubernetes.io/docs/reference/kubectl/cheatsheet/</a></li>
<li class="calibre10"><strong class="calibre1">Kubernetes API overview</strong>: <a href="https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/" class="calibre8">https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/</a></li>
<li class="calibre10"><strong class="calibre1">YAML wiki page</strong>:<a href="https://en.wikipedia.org/wiki/YAML" class="calibre8"> https://en.wikipedia.org/wiki/YAML</a></li>
<li class="calibre10"><strong class="calibre1">YAML syntax check</strong>: <a href="http://www.yamllint.com/" class="calibre8">http://www.yamllint.com/</a></li>
<li class="calibre10"><strong class="calibre1">JSON Wiki page</strong>:<a href="https://en.wikipedia.org/wiki/JSON" class="calibre8"> https://en.wikipedia.org/wiki/JSON</a></li>
<li class="calibre10"><strong class="calibre1">JSON syntax check</strong>: <a href="https://jsonlint.com/" class="calibre8">https://jsonlint.com/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>