<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Programming Workflows</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing a workflow condition</li><li class="listitem" style="list-style-type: disc">Writing a workflow validator</li><li class="listitem" style="list-style-type: disc">Writing a workflow post function</li><li class="listitem" style="list-style-type: disc">Editing an active workflow</li><li class="listitem" style="list-style-type: disc">Making issue editable/non-editable based on workflow status</li><li class="listitem" style="list-style-type: disc">Including/excluding resolutions for specific transitions</li><li class="listitem" style="list-style-type: disc">Permissions based on workflow status</li><li class="listitem" style="list-style-type: disc">Internationalization in workflow transitions</li><li class="listitem" style="list-style-type: disc">Getting available workflow actions programmatically</li><li class="listitem" style="list-style-type: disc">Programmatically progressing on workflows</li><li class="listitem" style="list-style-type: disc">Getting workflow history from database</li><li class="listitem" style="list-style-type: disc">Re-ordering workflow actions in JIRA</li><li class="listitem" style="list-style-type: disc">Creating common transitions in workflows</li><li class="listitem" style="list-style-type: disc">Jelly escalation</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Introduction</h1></div></div></div><a id="id622" class="indexterm"/><p>Workflows<a id="id623" class="indexterm"/> are one standout feature which help users to transform JIRA into a user-friendly system. It helps users to define a lifecycle for the issues, depending on the issue type, the purpose for which they are using JIRA, and so on. As the<a id="id624" class="indexterm"/> Atlassian documentation says at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+Workflow">http://confluence.atlassian.com/display/JIRA/Configuring+Workflow</a>:</p><div><blockquote class="blockquote"><p>A JIRA workflow<a id="id625" class="indexterm"/> is the set of steps and transitions an issue goes through during its lifecycle. Workflows typically represent business processes.</p></blockquote></div><a id="id626" class="indexterm"/><a id="id627" class="indexterm"/><p>JIRA uses Opensymphony's OSWorkflow<a id="id628" class="indexterm"/> which is highly configurable, and more importantly pluggable, to cater for the various requirements. JIRA uses three different plugin modules to add extra functionalities into its workflow, which we will see in detail through this chapter.</p><p>To make things easier, JIRA ships with a default workflow. We can't modify the default workflow, but can copy it into a new workflow and amend it to suit our needs. Before we go into the development aspect of a workflow, it makes sense to understand the various components of a workflow.</p><a id="id629" class="indexterm"/><p>The two most important components of a JIRA workflow are<a id="id630" class="indexterm"/>
<a id="id631" class="indexterm"/> <strong>Step</strong> and <strong>Transition</strong>. At any point of time, an<a id="id632" class="indexterm"/> <strong>Issue</strong> will be in a step. Each step in the workflow is linked to a workflow Status (<a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Defining+%27Status%27+Field+Values">http://confluence.atlassian.com/display/JIRA/Defining+%27Status%27+Field+Values</a>) and it is this status that you will see on the issue at every stage. A transition, on the other hand, is a link between two steps. It allows the user to move an issue from one step to another (which essentially moves the issue from one status to another).</p><p>Few key points to remember or understand about a workflow:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An <a id="id633" class="indexterm"/>issue can exist in only one step at any point in time</li><li class="listitem" style="list-style-type: disc">A<a id="id634" class="indexterm"/> status can be mapped to only one step in the workflow</li><li class="listitem" style="list-style-type: disc">A transition<a id="id635" class="indexterm"/> is always one-way. So if you need to go back to the previous step, you need a different transition</li><li class="listitem" style="list-style-type: disc">A transition can optionally specify a screen to be presented to the user with the right fields on it</li></ul></div><p>OSWorkflow<a id="id636" class="indexterm"/>, and hence JIRA, provides us with the option of adding various elements into a workflow transition which can be summarized as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Conditions</strong>: <a id="id637" class="indexterm"/>A set of conditions that need to be satisfied before the user can actually see the workflow action (transition) on the issue</li><li class="listitem" style="list-style-type: disc"><strong>Validators</strong>:<a id="id638" class="indexterm"/> A set of validators which can be used to validate the user input before moving to the destination step</li><li class="listitem" style="list-style-type: disc"><strong>Post Functions</strong>: <a id="id639" class="indexterm"/>A set of actions which will be performed after the issue is successfully moved to the destination step</li></ul></div><p>These three elements give us the flexibility of handling the various use cases when an issue is moved from one status to another. JIRA ships with a few built-in conditions, validators, and post functions. There are plugins out there which also provide a wide variety of useful workflow elements. And if you still don't find the one you are looking for, JIRA lets us write them as plugins. We will see how to do it in the various recipes in this chapter.</p><p>Hopefully, that gives you a fair idea about the various workflow elements. A lot more on JIRA workflows can be found in the<a id="id640" class="indexterm"/> JIRA documentation at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+Workflow">http://confluence.atlassian.com/display/JIRA/Configuring+Workflow</a>,</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Writing a workflow condition</h1></div></div></div><a id="id641" class="indexterm"/><p>What are workflow conditions? They determine whether a workflow action is available or not. Considering the importance of a workflow in installations and how there is a need to restrict the actions either to a set of people, roles, and so on, or based on some criteria (for example, the field is not empty!), writing workflow conditions is inevitable.</p><a id="id642" class="indexterm"/><a id="id643" class="indexterm"/><p>Workflow conditions are created with the help of the <code class="literal">workflow-condition</code> module. The following are the key attributes and elements supported. See <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Conditions">http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Conditions</a> for more details.</p><p><strong>Attributes</strong>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">key</code><a id="id644" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>This should be unique within the plugin.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">class</code></p>
</td><td style="text-align: left" valign="top">
<p>Class to provide contexts for rendered velocity templates. Must implement the <code class="literal">com.atlassian.jira.plugin.workflow.WorkflowPluginConditionFactory</code> interface.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">i18n-name-key</code></p>
</td><td style="text-align: left" valign="top">
<p>The localization key for the human-readable name of the plugin module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>Human-readable name of the workflow condition.</p>
</td></tr></tbody></table></div><p><strong>Elements</strong>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">description</code><a id="id645" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Description of the workflow condition.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">condition-class</code></p>
</td><td style="text-align: left" valign="top">
<p>Class to determine whether the user can see the workflow transition. Must implement <code class="literal">com.opensymphony.workflow.Condition</code>. Recommended to extend the <code class="literal">com.atlassian.jira.workflow.condition.AbstractJiraCondition</code> class.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">resource type="velocity"</code></p>
</td><td style="text-align: left" valign="top">
<p>Velocity templates for the workflow condition views.</p>
</td></tr></tbody></table></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec108"/>Getting ready</h2></div></div></div><p>As usual, create a skeleton plugin. Create an eclipse project using the skeleton plugin and we are good to go!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How to do it...</h2></div></div></div><a id="id646" class="indexterm"/><a id="id647" class="indexterm"/><p>In this recipe, let's assume we are going to develop a workflow condition that limits a transition only to the users belonging to a specific project role. The following are the steps to write our condition:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the inputs needed to configure the workflow condition.<p>We need to implement the <code class="literal">WorkflowPluginFactory</code> interface<a id="id648" class="indexterm"/>, which mainly exists to provide velocity parameters to the templates. It will be used to extract the input parameters that are used in defining the condition. To make it clear, the inputs here are not the inputs while performing the workflow action, but the inputs in defining the condition.</p><p>The condition factory class, <code class="literal">RoleConditionFactory</code> in this case, extends the <code class="literal">AbstractWorkflowPluginFactory</code>, which implements the <code class="literal">WorkflowPluginFactory</code> interface. There are three abstract methods that we should implement, that is, <code class="literal">getVelocityParamsForInput</code>, <code class="literal">getVelocityParamsForEdit</code>, and <code class="literal">getVelocityParamsForView</code>. All of them, as the name suggests, are used for populating the velocity parameters for the different scenarios.</p><p>In our example, we need to limit the workflow action to a certain project role, and so we need to select the project role while defining the condition. The three methods will be implemented as follows:</p><div><pre class="programlisting">private static final String ROLE_NAME = "role";
private static final String ROLES = "roles";
………….
@Override
protected void getVelocityParamsForEdit(Map&lt;String, Object&gt; velocityParams, AbstractDescriptor descriptor) {
    velocityParams.put(ROLE, getRole(descriptor));
    velocityParams.put(ROLES, getProjectRoles());
}

  @Override
  protected void getVelocityParamsForInput(Map&lt;String, Object&gt; velocityParams) {
    velocityParams.put(ROLES, getProjectRoles());
  }

  @Override
  protected void getVelocityParamsForView(Map&lt;String, Object&gt; velocityParams, AbstractDescriptor descriptor) {
    velocityParams.put(ROLE, getRole(descriptor));
  }</pre></div><a id="id649" class="indexterm"/><a id="id650" class="indexterm"/><p>Let's look at the methods in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForInput</code><a id="id651" class="indexterm"/>: This method defines the velocity parameters for input scenario, that is, when the user initially configures the workflow. In our example, we need to display all the project roles so that the user can select one to define the condition. The method <code class="literal">getProjectRoles</code> merely returns all the project roles and the collection of roles is then put into the velocity parameters with the key <code class="literal">ROLES</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForView</code><a id="id652" class="indexterm"/>: This method defines the velocity parameters for the view scenario, that is, how the user sees the condition after it is configured. In our example, we have defined a role and so we should display it to the user after retrieving it back from the workflow descriptor. If you have noticed, the descriptor, which is an instance of <code class="literal">AbstractDescriptor</code>, is available as an argument in the method. All we need is to extract the role from the descriptor, which can be done as follows:<div><pre class="programlisting">private ProjectRole getRole(AbstractDescriptor descriptor){
    if (!(descriptor instanceof ConditionDescriptor)) {
      throw new IllegalArgumentException("Descriptor must be a ConditionDescriptor.");
    }
    
    ConditionDescriptor functionDescriptor = (ConditionDescriptor) descriptor;
    
    String role = (String) functionDescriptor.getArgs().get(ROLE);
    if (role!=null &amp;&amp; role.trim().length()&gt;0)
      return getProjectRole(role);
    else 
      return null;
}</pre></div><a id="id653" class="indexterm"/><a id="id654" class="indexterm"/><p>Just check if the descriptor is a condition descriptor or not, and then extract the role as shown in the preceding snippet.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForEdit</code>: <a id="id655" class="indexterm"/>This method defines the velocity parameters for the edit scenario, that is, when the user modifies the existing condition. Here we need both the options and the selected value. Hence, we put both the project roles collection and the selected role on to the velocity parameters.</li></ul></div></li><li class="listitem">	The second step is to define the velocity templates for each of the three aforementioned scenarios: <strong>input</strong>, <strong>view</strong>, and <strong>edit</strong>. We can use the same template here for input and edit with a simple check to keep the old role selected for the edit scenario. Let us look at the templates:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">edit-roleCondition.vm</code><a id="id656" class="indexterm"/>: Displays all project roles and highlights the already-selected one in the edit mode. In the input mode, the same template is reused, but the selected role will be null and hence a null check is done:<div><pre class="programlisting">&lt;tr bgcolor="#ffffff"&gt;
    &lt;td align="right" valign="top" bgcolor="#fffff0"&gt;
        &lt;span class="label"&gt;Project Role:&lt;/span&gt;
    &lt;/td&gt;
    &lt;td bgcolor="#ffffff" nowrap&gt;
        &lt;select name="role" id="role"&gt;
        #foreach ($field in $roles)
          &lt;option value="${field.id}"
            #if ($role &amp;&amp; (${field.id}==${role.id}))
                SELECTED
            #end
            &gt;$field.name&lt;/option&gt;
        #end
        &lt;/select&gt;
        &lt;br&gt;&lt;font size="1"&gt;Select the role in which the user should be present!&lt;/font&gt;
    &lt;/td&gt;
           &lt;/tr&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">view-roleCondition.vm</code><a id="id657" class="indexterm"/>: Displays the selected role:<div><pre class="programlisting">#if ($role)
  User should have ${role.name} Role!
#else
  Role Not Defined
#end</pre></div></li></ul></div></li><li class="listitem">The third step is to write the actual condition. The condition class should extend the <code class="literal">AbstractJiraCondition</code> class<a id="id658" class="indexterm"/>. Here we need to implement the <code class="literal">passesCondition</code> method<a id="id659" class="indexterm"/>. In our case, we retrieve the project from the issue, check if the user has the appropriate project role, and return true if the user does:<div><pre class="programlisting">public boolean passesCondition(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
    Issue issue = getIssue(transientVars);
    User user = getCaller(transientVars, args);

    project project = issue.getProjectObject();
    String role = (String)args.get(ROLE);
    Long roleId = new Long(role);

    return projectRoleManager.isUserInProjectRole(user, projectRoleManager.getProjectRole(roleId), project);
}</pre></div><a id="id660" class="indexterm"/><p>The issue on which the condition is checked can be retrieved using the <code class="literal">getIssue</code> method<a id="id661" class="indexterm"/> implemented in the <code class="literal">AbstractJiraCondition</code> class. Similarly, the user can be retrieved using the <code class="literal">getCaller</code> method. In the preceding method, <code class="literal">projectRoleManager</code> is injected in the constructor, as we have seen before.</p></li><li class="listitem">We can see that the <code class="literal">ROLE</code> key is used to retrieve the project role ID from the <code class="literal">args</code> parameter in the <code class="literal">passesCondition</code> method. In order for the <code class="literal">ROLE</code> key to be available in the <code class="literal">args</code> map, we need to override the <code class="literal">getDescriptorParams</code> method<a id="id662" class="indexterm"/> in the condition factory class, <code class="literal">RoleConditionFactory</code> in this case. The <code class="literal">getDescriptorParams</code> method returns a map of sanitized parameters, which will be passed into workflow plugin instances from the values in an array form submitted by velocity, given a set of <code class="literal">name:value</code> parameters from the plugin configuration page (that is, the 'input-parameters' velocity template). In our case, the method is overridden as follows:<div><pre class="programlisting">public Map&lt;String, String&gt; getDescriptorParams(Map&lt;String, Object&gt; conditionParams) {
    if (conditionParams != null &amp;&amp; conditionParams.containsKey(ROLE))
        {
            return EasyMap.build(ROLE, extractSingleParam(conditionParams, ROLE));
        }
        // Create a 'hard coded' parameter
        return EasyMap.build();
  }</pre></div><a id="id663" class="indexterm"/><p>The method here builds a map of the <code class="literal">key:value</code> pair, where key is <code class="literal">ROLE</code> and the value is the role value entered in the input configuration page. The <code class="literal">extractSingleParam</code> method<a id="id664" class="indexterm"/> is implemented in the <code class="literal">AbstractWorkflowPluginFactory</code> class<a id="id665" class="indexterm"/>. The <code class="literal">extractMultipleParams</code> method<a id="id666" class="indexterm"/> can be used if there is more than one parameter to be extracted!</p></li><li class="listitem">All that is left now is to populate the <code class="literal">atlassian-plugin.xml</code> file with the aforementioned components. We use the <code class="literal">workflow-condition</code> module and it looks like the following block of code:<div><pre class="programlisting">&lt;workflow-condition key="role-condition" name="Role Based Condition"  class="com.jtricks.RoleConditionFactory"&gt;
    &lt;description&gt;Role Based Workflow Condition&lt;/description&gt;
    &lt;condition-class&gt;com.jtricks.RoleCondition&lt;/condition-class&gt;
    &lt;resource type="velocity" name="view"  location="templates/com/jtricks/view-roleCondition.vm"/&gt;
    &lt;resource type="velocity" name="input-parameters" location="templates/com/jtricks/edit-roleCondition.vm"/&gt;
    &lt;resource type="velocity" name="edit-parameters"  location="templates/com/jtricks/edit-roleCondition.vm"/&gt;
&lt;/workflow-condition&gt;</pre></div></li><li class="listitem">Package the plugin and deploy it!</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec110"/>How it works...</h2></div></div></div><a id="id667" class="indexterm"/><a id="id668" class="indexterm"/><p>After the plugin is deployed, we need to modify the workflow to include the condition. The following screenshot is how the condition looks when it is added initially. This, as you now know, is rendered using the input template:</p><div><img src="img/1803-04-01.jpg" alt="How it works..."/></div><p>After the condition is added (that is, after selecting the <strong>Developers</strong> role), the view is rendered using the view template and looks as shown in the following screenshot:</p><div><img src="img/1803-04-02.jpg" alt="How it works..."/></div><p>If you try to edit it, the screen will be rendered using the edit template, as shown in the following screenshot:</p><div><img src="img/1803-04-03.jpg" alt="How it works..."/></div><p>Note that the <strong>Developers</strong> role is already selected.</p><p>After the workflow is configured, when the user goes to an issue, he/she will be presented with the transition only if he/she is a member of the project role where the issue belongs. <a id="id669" class="indexterm"/>
<a id="id670" class="indexterm"/>It is while viewing the issue that the <code class="literal">passesCondition</code> method<a id="id671" class="indexterm"/> in the <code class="literal">condition</code> class is executed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec111"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a skeleton plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a>, <em>Plugin Development Process</em></li><li class="listitem" style="list-style-type: disc"><em>Deploying your plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Writing a workflow validator</h1></div></div></div><a id="id672" class="indexterm"/><p>Workflow validators are specific validators that check whether some pre-defined constraints are satisfied or not while progressing on a workflow. The constraints are configured in the workflow and the user will get an error if some of them are not satisfied. A typical example would be to check if a particular field is present or not before the issue is moved to a different status.</p><p>Workflow validators are created with the help of the <code class="literal">workflow- validator</code> module<a id="id673" class="indexterm"/>. The following are the key attributes and elements supported.</p><p><strong>Attributes</strong>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">key</code><a id="id674" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>This should be unique within the plugin.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">class</code></p>
</td><td style="text-align: left" valign="top">
<p>Class to provide contexts for rendered velocity templates. Must implement the <code class="literal">com.atlassian.jira.plugin.workflow.WorkflowPluginValidatorFactory</code> interface.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">i18n-name-key</code></p>
</td><td style="text-align: left" valign="top">
<p>The localization key for the human-readable name of the plugin module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>Human-readable name of the workflow validator.</p>
</td></tr></tbody></table></div><p><strong>Elements</strong>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">description</code></p>
</td><td style="text-align: left" valign="top">
<p>Description of the workflow validator.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">validator-class</code></p>
</td><td style="text-align: left" valign="top">
<p>Class which does the validation. Must implement <code class="literal">com.opensymphony.workflow.Validator</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">resource type="velocity"</code><a id="id675" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Velocity templates for the workflow validator views.</p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>See <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Validators">http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Validators</a> for more details.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec112"/>Getting ready</h2></div></div></div><a id="id676" class="indexterm"/><a id="id677" class="indexterm"/><p>As usual, create a skeleton plugin. Create an eclipse project using the skeleton plugin and we are good to go!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec113"/>How to do it...</h2></div></div></div><p>Let us consider writing a validator that checks whether a particular field has a value entered on the issue or not! We can do this using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the inputs needed to configure the workflow validator:<p>We need to implement the <code class="literal">WorkflowPluginValidatorFactory</code> interface<a id="id678" class="indexterm"/>, which mainly exists to provide velocity parameters to the templates. It will be used to extract the input parameters that are used in defining the validator. To make it clear, the inputs here are not the input while performing the workflow action, but the inputs in defining the validator.</p><p>The validator factory class, <code class="literal">FieldValidatorFactory</code> in this case, extends the <code class="literal">AbstractWorkflowPluginFactory</code> interface and implements the <code class="literal">WorkflowPluginValidatorFactory</code> interface. Just like conditions, there are three abstract methods that we should implement. They are <code class="literal">getVelocityParamsForInput</code>, <code class="literal">getVelocityParamsForEdit</code>, and <code class="literal">getVelocityParamsForView</code>. All of them, as the names suggest, are used for populating the velocity parameters in different scenarios.</p><p>In our example, we have a single input field, which is the name of a custom field. The three methods will be implemented as follows:</p><div><pre class="programlisting">@Override
protected void getVelocityParamsForEdit(Map velocityParams, AbstractDescriptor descriptor) {
  velocityParams.put(FIELD_NAME, getFieldName(descriptor));
  velocityParams.put(FIELDS, getCFFields());
}

@Override
protected void getVelocityParamsForInput(Map velocityParams) {
    velocityParams.put(FIELDS, getCFFields());
}

@Override
protected void getVelocityParamsForView(Map velocityParams, AbstractDescriptor descriptor) {
    velocityParams.put(FIELD_NAME, getFieldName(descriptor));
}</pre></div><a id="id679" class="indexterm"/><a id="id680" class="indexterm"/><p>You may have noticed that the methods look quite similar to the ones in a workflow condition, except for the business logic! Let us look at the methods in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForInput</code><a id="id681" class="indexterm"/>: This method defines the velocity parameters for input scenario, that is, when the user initially configures the workflow. In our example, we need to display all the custom fields, so that the user can select one to use in the validator. The method <code class="literal">getCFFields</code> returns all the custom fields and the collection of fields is then put into the velocity parameters with the key fields.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForView</code><a id="id682" class="indexterm"/>: This method defines the velocity parameters for the view scenario, that is, how the user sees the validator after it is configured. In our example, we have defined a field and so we should display it to the user after retrieving it back from the workflow descriptor. You may have noticed that the descriptor, which is an instance of <code class="literal">AbstractDescriptor</code>, is available as an argument in the method. All we need is to extract the field name from the descriptor, which can be done as follows:<div><pre class="programlisting">private String getFieldName(AbstractDescriptor descriptor){
  if (!(descriptor instanceof ValidatorDescriptor)) {
    throw new IllegalArgumentException('Descriptor must be a ValidatorDescriptor.');
  }
  
  ValidatorDescriptor validatorDescriptor = (ValidatorDescriptor) descriptor;

  String field = (String) validatorDescriptor.getArgs().get(FIELD_NAME);
  if (field != null &amp;&amp; field.trim().length() &gt; 0)
    return field;
  else
    return NOT_DEFINED;
}</pre></div></li></ul></div><a id="id683" class="indexterm"/><a id="id684" class="indexterm"/><p>Just check if the descriptor is a validator descriptor or not and then extract the field as shown in the preceding snippet.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForEdit</code><a id="id685" class="indexterm"/>: This method defines the velocity parameters for the edit scenario, that is, when the user modifies the existing validator. Here we need both the options and the selected value. Hence we put both the custom fields' collection and the field name onto the velocity parameters.</li></ul></div></li><li class="listitem">The second step is to define the velocity templates for each of the three aforementioned scenarios, namely, input, view, and edit. We can use the same template here for input and edit with a simple checking to keep the old field selected for the edit scenario. Let us look at the template:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">edit-fieldValidator.vm</code><a id="id686" class="indexterm"/>: Displays all custom fields and highlights the already selected one in edit mode. In input mode, the field variable will be null, and so nothing is pre-selected:<div><pre class="programlisting">&lt;tr bgcolor="#ffffff"&gt;
  &lt;td align="right" valign="top" bgcolor="#fffff0"&gt;
    &lt;span class="label"&gt;Custom Fields :&lt;/span&gt;
  &lt;/td&gt;
  &lt;td bgcolor="#ffffff" nowrap&gt;
    &lt;select name="field" id="field"&gt;
    #foreach ($cf in $fields)
      &lt;option value="$cf.name"
        #if ($cf.name.equals($field)) SELECTED #end
      &gt;$cf.name&lt;/option&gt;
    #end
    &lt;/select&gt;
    &lt;br&gt;&lt;font size="1"&gt;Select the Custom Field to be validated for NULL&lt;/font&gt;
  &lt;/td&gt;
&lt;/tr&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">view-fieldValidator.vm</code><a id="id687" class="indexterm"/>: Displays the selected field:<div><pre class="programlisting">#if ($field)
  Field '$field' is Required!
#end</pre></div></li></ul></div></li><li class="listitem"><a id="id688" class="indexterm"/><a id="id689" class="indexterm"/>The third step is to write the actual validator. The validator class should implement the <code class="literal">Validator</code> interface. All we need here is to implement the <code class="literal">validate</code> method. In our example, we retrieve the custom field value from the issue and throw an <code class="literal">InvalidInputException</code> if the value is null (empty):<div><pre class="programlisting">public void validate(Map transientVars, Map args, PropertySet ps) throws InvalidInputException, WorkflowException {
    Issue issue = (Issue) transientVars.get("issue");
    String field = (String) args.get(FIELD_NAME);  
    CustomField customField = customFieldManager.getCustomFieldObjectByName(field);

    if (customField!=null){
      //Check if the custom field value is NULL
      if (issue.getCustomFieldValue(customField) == null){
        throw new InvalidInputException("The field:"+field+" is
             required!"); }
    }
  }</pre></div><p>The issue on which the validation is done can be retrieved from the <code class="literal">transientVars</code> map. <code class="literal">customFieldManager</code> is injected in the constructor as usual.</p></li><li class="listitem">All that is left now is to populate the <code class="literal">atlassian-plugin.xml</code> file with these components. We use the <code class="literal">workflow-validator</code> module, and it looks like the following block of code:<div><pre class="programlisting">&lt;workflow-validator key="field-validator" name="Field Validator"  class="com.jtricks.FieldValidatorFactory"&gt;
    &lt;description&gt;Field Not Empty Workflow Validator&lt;/description&gt;

    &lt;validator-class&gt;com.jtricks.FieldValidator&lt;/validator-class&gt;

    &lt;resource type="velocity" name="view" location="templates/com/jtricks/view-fieldValidator.vm"/&gt;&lt;resource type="velocity" name="input-parameters" location="templates/com/jtricks/edit-fieldValidator.vm"/&gt;
    &lt;resource type="velocity" name="edit-parameters" location="templates/com/jtricks/edit-fieldValidator.vm"/&gt;
&lt;/workflow-validator&gt;</pre></div></li><li class="listitem">Package the plugin and deploy it!</li></ol></div><p>Note that we have stored the role name instead of the ID in the workflow, unlike what we did in the workflow condition. However, it is safe to use the ID because administrators can rename the roles, which would then need changes in the workflows.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec114"/>How it works...</h2></div></div></div><a id="id690" class="indexterm"/><a id="id691" class="indexterm"/><p>After the plugin is deployed, we need to modify the workflow to include the validator. The following screenshot is how the validator looks when it is added initially. This, as you now know, is rendered using the input template:</p><div><img src="img/1803-04-04.jpg" alt="How it works..."/></div><p>After the validator is added (after selecting the <strong>Test Number</strong> field), it is rendered using the view template and looks as follows:</p><div><img src="img/1803-04-05.jpg" alt="How it works..."/></div><p>If you try to edit it, the screen will be rendered using the edit template, as shown in the following screenshot:</p><div><img src="img/1803-04-06.jpg" alt="How it works..."/></div><a id="id692" class="indexterm"/><a id="id693" class="indexterm"/><p>Note that the <strong>Test Number</strong> field is already selected.</p><p>After the workflow is configured, when the user goes to an issue and tries to progress it, the validator will check if the <strong>Test Number</strong> field has a value or not. It is at this point that the <code class="literal">validate</code> method in the <code class="literal">FieldValidator</code> class is executed.</p><p>If the value is missing, you will see an error, as shown in the following screenshot:</p><div><img src="img/1803-04-07.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec115"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a skeleton plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a></li><li class="listitem" style="list-style-type: disc"><em>Deploying your plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Writing a workflow post function</h1></div></div></div><a id="id694" class="indexterm"/><p>Let us now look at workflow post functions. Workflow post functions are very effective and heavily used. They allow you to do a lot of things when you progress on the workflow on an issue. A lot of customizations and workarounds take this route!</p><p>Workflow post functions are created with the help of the <code class="literal">workflow-function</code> module. The following are the key attributes and elements supported.</p><p><strong>Attributes</strong>:<a id="id695" class="indexterm"/></p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">key</code></p>
</td><td style="text-align: left" valign="top">
<p>This should be unique within the plugin.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Class</code></p>
</td><td style="text-align: left" valign="top">
<p>Class to provide contexts for rendered velocity templates. Must implement the <code class="literal">com.atlassian.jira.plugin.workflow.WorkflowNoInputPluginFactory</code> interface if the function doesn't need input, or <code class="literal">com.atlassian.jira.plugin.workflow.WorkflowPluginFunctionFactory</code> if it needs input.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">i18n-name-key</code></p>
</td><td style="text-align: left" valign="top">
<p>The localization key for the human-readable name of the plugin module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>Human-readable name of the workflow function.</p>
</td></tr></tbody></table></div><p><strong>Elements</strong>:<a id="id696" class="indexterm"/></p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">description</code></p>
</td><td style="text-align: left" valign="top">
<p>Description of the workflow function.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">function-class</code></p>
</td><td style="text-align: left" valign="top">
<p>Class which does the validation. Must implement <code class="literal">com.opensymphony.workflow.FunctionProvider</code>. Recommended to extend <code class="literal">com.atlassian.jira.workflow.function.issue.AbstractJiraFunctionProvider</code>, as it already implements many useful methods.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">resource type="velocity"</code></p>
</td><td style="text-align: left" valign="top">
<p>Velocity templates for the workflow function views.</p>
</td></tr></tbody></table></div><a id="id697" class="indexterm"/><a id="id698" class="indexterm"/><p>There are three other elements that can be used with a post function. They are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">orderable</code> – <a id="id699" class="indexterm"/>(true/false) Specifies if this function can be re-ordered within the list of functions associated with a transition. The position within the list determines when the function actually executes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">unique</code> – <a id="id700" class="indexterm"/>(true/false) Specifies if this function is unique, that is, if it is possible to add multiple instances of this post function on a single transition.</li><li class="listitem" style="list-style-type: disc"><code class="literal">deletable</code> –<a id="id701" class="indexterm"/> (true/false) Specifies if this function can be removed from a transition.<div><div><h3 class="title"><a id="note13"/>Note</h3><p>See <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Functions">http://confluence.atlassian.com/display/JIRADEV/Workflow+Plugin+Modules#WorkflowPluginModules-Functions</a> for more details.</p></div></div></li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec116"/>Getting ready</h2></div></div></div><p>As usual, create a skeleton plugin. Create an eclipse project using the skeleton plugin and we are good to go!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec117"/>How to do it...</h2></div></div></div><a id="id702" class="indexterm"/><a id="id703" class="indexterm"/><p>Assume we have a user custom field and we want to set the current user or a specified user name on to the custom field when a particular transition happens. A typical use case for this will be to store the name of the user who last resolved an issue. The following are the steps to write a generic post function that sets the current username or a username provided by the user on a user custom field:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the inputs needed to configure the workflow post function:<p>As opposed to workflow conditions and validators, there are two interfaces available for a workflow post function factory class. If there are no inputs needed to configure the function, the factory class must implement <code class="literal">WorkflowNoInputPluginFactory</code>. An example will be to set the current user's name as the custom field value instead of the user configured name. If inputs are needed to configure the post function, the factory class must implement <code class="literal">WorkflowPluginFunctionFactory</code>. In our example, we take the username as the input.</p><p>Both the interfaces mainly exist to provide velocity parameters to the templates. They will be used to extract the input parameters that are used in defining the functions. To make it clear, the inputs here are not the input while performing the workflow action, but the inputs in defining the post function.</p><p>The function factory class, <code class="literal">SetUserCFFunctionFactory</code> in this case, extends the <code class="literal">AbstractWorkflowPluginFactory</code> and implements the <code class="literal">WorkflowPluginFunctionFactory</code> interface. Just like conditions, there are three abstract methods that we should implement, namely, <code class="literal">getVelocityParamsForInput</code>, <code class="literal">getVelocityParamsForEdit</code>, and <code class="literal">getVelocityParamsForView</code>. All of them, as the names suggest, are used for populating the velocity parameters for the different scenarios:</p><div><pre class="programlisting">@Override
protected void getVelocityParamsForEdit(Map velocityParams, AbstractDescriptor descriptor) {velocityParams.put(USER_NAME, getUserName(descriptor));
}

@Override
protected void getVelocityParamsForInput(Map velocityParams) {
    velocityParams.put(USER_NAME, CURRENT_USER); }

@Override
protected void getVelocityParamsForView(Map velocityParams, AbstractDescriptor descriptor) {
    velocityParams.put(USER_NAME, getUserName(descriptor));
}</pre></div><a id="id704" class="indexterm"/><a id="id705" class="indexterm"/><p>You may have noticed that the methods look very similar to the ones in workflow conditions or validators, except for the business logic! Let us look at the methods in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForInput</code> : <a id="id706" class="indexterm"/>This method defines the velocity parameters for input scenario, that is, when the user initially configures the workflow. In our example, we need to use a text field that captures the username to be added on the issue.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForView</code><a id="id707" class="indexterm"/>: This method defines the velocity parameters for the view scenario, that is, how the user sees the post function after it is configured. In our example, we have defined a field, and so we should display it to the user after retrieving it from the workflow descriptor. You may have noticed that the descriptor, which is an instance of <code class="literal">AbstractDescriptor</code>, is available as an argument in the method. All we need is to extract the username from the descriptor, which can be done as follows:<div><pre class="programlisting">private String getUserName(AbstractDescriptor descriptor){
    if (!(descriptor instanceof FunctionDescriptor)) {
      throw new IllegalArgumentException("Descriptor must be a FunctionDescriptor.");
    }

    FunctionDescriptor functionDescriptor = (FunctionDescriptor) descriptor;

    String user = (String) functionDescriptor.getArgs().get(USER_NAME);
    if (user!=null &amp;&amp; user.trim().length()&gt;0)return user;
    else 
      return CURRENT_USER;
} </pre></div><p>Just check if the descriptor is a validator descriptor or not, and then extract the field as shown in the preceding snippet.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">getVelocityParamsForEdit</code><a id="id708" class="indexterm"/>: This method defines the velocity parameters for the edit scenario, that is, when the user modifies the existing validator. Here we need both the options and the selected value. Hence, we put both the custom fields' collection and the field name on to the velocity parameters.</li></ul></div></li><li class="listitem">The second step is to define the velocity templates for each of the three scenarios: input, view, and edit. We can use the same template here for input and edit with a simple checking to keep the old field selected for the edit scenario. Let us look at the templates:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">edit-userCFFunction.vm</code>: Displays all custom fields and highlights the already selected one in the edit mode:<div><pre class="programlisting">&lt;tr bgcolor="#ffffff"&gt;
  &lt;td align="right" valign="top" bgcolor="#fffff0"&gt;
    &lt;span class="label"&gt;User Name :&lt;/span&gt;
  &lt;/td&gt;
  &lt;td bgcolor="#ffffff" nowrap&gt;
    &lt;input type="text" name="user" value="$user"/&gt;            &lt;br&gt;&lt;font size="1"&gt; Enter the userName to be set on the Test User CustomField &lt;/font&gt;
  &lt;/td&gt;
&lt;/tr&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">view-userCFFunction.vm</code> .displays the selected field:<div><pre class="programlisting">	#if ($user)
  The 'Test User' CF will be set with value : $user!
#end</pre></div></li></ul></div></li><li class="listitem"><a id="id709" class="indexterm"/><a id="id710" class="indexterm"/>The third step is to write the actual function. The function class must extend the <code class="literal">AbstractJiraFunctionProvider</code> interface. All we need here is to implement the <code class="literal">execute</code> method. In our example, we retrieve the username from the issue and set it on the <code class="literal">Test User</code> custom field:<div><pre class="programlisting">public void execute(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
    MutableIssue issue = getIssue(transientVars);
    User user = null;

    if (args.get("user") != null) {
      String userName = (String) args.get("user");
      if (userName.equals("Current User")){
        // Set the current user here!
        user = authContext.getUser();
      } else {
        user = userUtil.getUser(userName);
      }
    } else {
      // Set the current user here!
      user = authContext.getUser();
    }
    // Now set the user value to the custom field
    CustomField userField = customFieldManager.getCustomFieldObjectByName("Test User");
    if (userField != null) {
      try {
        setUserValue(issue, user, userField);
      } catch (FieldLayoutStorageException e) {
        System.out.println("Error while setting the user Field");
      }
    }
 }</pre></div><p>Like a validator, the issue on which the post function is executed can be retrieved using the <code class="literal">transientVars</code> map. The user can be retrieved from the <code class="literal">args</code> map.</p><p>Here the <code class="literal">setUserValue</code> method<a id="id711" class="indexterm"/> simply sets the username on the passed custom field, as shown in the following block of code:</p><div><pre class="programlisting">private void setUserValue(MutableIssue issue, User user, CustomField userField) throws FieldLayoutStorageException {
    issue.setCustomFieldValue(userField, user);
    Map modifiedFields = issue.getModifiedFields();
    FieldLayoutItem fieldLayoutItem = ComponentManager.getInstance().getFieldLayoutManager().getFieldLayout(issue).getFieldLayoutItem(userField);
    DefaultIssueChangeHolder issueChangeHolder = new DefaultIssueChangeHolder();
    final ModifiedValue modifiedValue = (ModifiedValue) modifiedFields.get(userField.getId());    userField.updateValue(fieldLayoutItem, issue, modifiedValue, issueChangeHolder);
}</pre></div></li><li class="listitem"><a id="id712" class="indexterm"/><a id="id713" class="indexterm"/>All that is left now is to populate the <code class="literal">atlassian-plugin.xml</code> file with these components. We use the <code class="literal">workflow-condition</code> module and it looks like the following block of code:<div><pre class="programlisting">&lt;workflow-function key="set-usercf" name="Set User CF Post Function" class="com.jtricks.SetUserCFFunctionFactory"&gt;
    &lt;description&gt;Set Defined User or Current User&lt;/description&gt;
    &lt;function-class&gt;com.jtricks.SetUserCFFunction&lt;/function-class&gt;
    &lt;orderable&gt;true&lt;/orderable&gt;
    &lt;unique&gt;false&lt;/unique&gt;
    &lt;deletable&gt;true&lt;/deletable&gt;

    &lt;resource type="velocity" name="view" location="templates/com/jtricks/view-userCFFunction.vm"/&gt;
    &lt;resource type="velocity" name="input-parameters"  location="templates/com/jtricks/edit-userCFFunction.vm"/&gt;
    &lt;resource type="velocity" name="edit-parameters" location="templates/com/jtricks/edit-userCFFunction.vm"/&gt;

&lt;/workflow-function&gt;</pre></div></li><li class="listitem">Package the plugin and deploy it!</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How it works...</h2></div></div></div><p>After the plugin is deployed, we need to modify the workflow to include the function. The following is where the function appears along with the built-in ones:</p><div><img src="img/1803-04-08.jpg" alt="How it works..."/></div><a id="id714" class="indexterm"/><a id="id715" class="indexterm"/><p>Clicking on our post function takes us to the configuration page, shown next. This, as you now know, is rendered using the input template:</p><div><img src="img/1803-04-09.jpg" alt="How it works..."/></div><p>After the function is added (after entering in the <strong>UserName</strong> field), it looks as follows:</p><div><img src="img/1803-04-10.jpg" alt="How it works..."/></div><a id="id716" class="indexterm"/><a id="id717" class="indexterm"/><p>If you try to edit, the screen will be rendered using the edit template, as shown in the following screenshot:</p><div><img src="img/1803-04-11.jpg" alt="How it works..."/></div><p>Note that the <strong>UserName</strong> field is already populated.</p><p>After the workflow is configured, when the user executes the workflow action, the <strong>Test User</strong> custom field is set with the value <strong>jobinkk</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec119"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a skeleton plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a></li><li class="listitem" style="list-style-type: disc"><em>Deploying your plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Editing an active workflow</h1></div></div></div><a id="id718" class="indexterm"/><p>We have seen how the workflow plays an important role in configuring our JIRA and how we can write plugins to add more workflow conditions, validators, and post functions. Once these plugins are added, we need to modify the workflow to include the newly created components at the appropriate transitions.</p><p>Modifying an inactive workflow or creating a new workflow is pretty easy. You can add the conditions/validators/post functions when you create the transition or just click on the transition to modify them. But to edit an active workflow, there are a few more steps involved which we will see in this recipe.</p><p>A workflow is active when it is being used in an active workflow scheme that is tied to a project. You can check whether a workflow is active by navigating to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec120"/>How to do it...</h2></div></div></div><a id="id719" class="indexterm"/><a id="id720" class="indexterm"/><p>The following are the steps to edit an active workflow:</p><div><ol class="orderedlist arabic"><li class="listitem">Login as a JIRA Administrator.</li><li class="listitem">Navigate to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</li><li class="listitem">Click on the <strong>Create a draft workflow</strong> link on the workflow you want to edit. The link can be found under the <strong>Operations</strong> column.</li><li class="listitem">Click on the <em>step</em> or <em>transition</em> that you want to modify.</li><li class="listitem">Make the changes. The changes won't be effective until the workflow is published.</li><li class="listitem">After all the changes are made, click on the <strong>publish this draft</strong> link at the top of the page if you are still viewing the modified workflow. You can also click on <strong>Publish</strong> under the <strong>Operations</strong> column while viewing all the workflows.</li><li class="listitem">Make a copy of the old workflow, when prompted, if you need a backup, and click on <strong>Publish</strong>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec121"/>How it works...</h2></div></div></div><p>After making changes on the draft and clicking on <strong>Publish</strong>, the new workflow will be active. However, there are some limitations to this procedure, which are detailed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can't delete an existing workflow step</li><li class="listitem" style="list-style-type: disc">You can't edit the status associated with an existing step</li><li class="listitem" style="list-style-type: disc">If an existing step has no outgoing transitions, you can't add any new outgoing transitions</li><li class="listitem" style="list-style-type: disc">You can't change the step IDs for any existing steps</li></ul></div><a id="id721" class="indexterm"/><a id="id722" class="indexterm"/><p>If you want to overcome these limitations, you need to copy the workflow, modify the copy, and make it active by migrating the projects on to the new workflow.</p><p>After the new workflow is active, any transitions on the issue will be based on the new workflow.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec122"/>There's more...</h2></div></div></div><p>If you want to modify an active workflow, thus overcoming some of the limitations aforementioned but don't want to go through the pain of migrating all the projects involved, you might want to look at modifying it directly in the JIRA database.</p><p>Note that we should be careful about the workflow changes when we do this. For example, if there are issues in a status that is removed in the modified workflow, those issues will be stuck at the removed status. The same can happen for the removed steps.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>Modifying workflows in JIRA database</h3></div></div></div><a id="id723" class="indexterm"/><a id="id724" class="indexterm"/><p>The following are the steps to modify the workflows in the database:</p><div><ol class="orderedlist arabic"><li class="listitem">Export the workflow that needs to be modified into XML. You can do it using the XML link under the <strong>Operations</strong> column of a workflow.</li><li class="listitem">Modify the XML to include your changes (or alternatively, make changes in a copy of the JIRA  workflow and export that as XML).</li><li class="listitem">Stop the JIRA instance.</li><li class="listitem">Connect to your JIRA database.</li><li class="listitem">Take a backup of the existing database. We can revert to this backup if anything goes wrong.</li><li class="listitem">Update the <code class="literal">JIRAWORKFLOWS</code> table to modify the <code class="literal">descriptor</code> column with the new XML file for the appropriate workflow. When the workflow XML is huge, it might be useful to rely on database-specific methods to update the table. For example, we can use Oracle XML database utilities (<a class="ulink" href="http://download.oracle.com/docs/cd/B12037_01/appdev.101/b10790/xdb01int.htm">http://download.oracle.com/docs/cd/B12037_01/appdev.101/b10790/xdb01int.htm</a>), if JIRA is connected to the Oracle database.</li><li class="listitem">Commit the changes and disconnect from the database.</li><li class="listitem">Start the JIRA instance.</li><li class="listitem"><a id="id725" class="indexterm"/><a id="id726" class="indexterm"/>Re-index JIRA.</li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Making an issue editable/non-editable based on workflow status</h1></div></div></div><p>We know that the edit permission on an issue is controlled through the <strong>Edit Issue</strong> <strong>Permission</strong><a id="id727" class="indexterm"/>. This is used within the permissions schemes tied to a project and it blocks/allows editing of the issue, irrespective of which status it is in! But many a times the need arises to block an issue being edited at a specific status. An example would be to prevent editing on a closed issue.</p><p>We will have a quick look at how to achieve this using workflow properties.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec123"/>How to do it...</h2></div></div></div><a id="id728" class="indexterm"/><a id="id729" class="indexterm"/><a id="id730" class="indexterm"/><a id="id731" class="indexterm"/><p>We can make an issue editable or non-editable using the <code class="literal">jira.issue.editable</code> workflow property. The following is the step-by-step procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Login as a JIRA Administrator.</li><li class="listitem">Navigate to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</li><li class="listitem">Create a draft of the workflow, if it is active. Navigate to the <em>step</em> which needs to be modified.</li><li class="listitem">Click on the <strong>View step's properties</strong> link.</li><li class="listitem">Enter <strong>jira.issue.editable</strong> into the <strong>Property Key</strong> field.</li><li class="listitem">Enter <strong>false</strong> in the <strong>Property Value</strong> field, if you want to prevent editing on the issue after this transition is performed. Use <strong>true</strong> as the value, if you want to make it as editable.</li><li class="listitem">Go back and publish the workflow if it was active. If not, associate the workflow with the appropriate schemes.</li></ol></div><p>Note that the property is added on a workflow <em>step</em> and not a <em>transition</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec124"/>How it works...</h2></div></div></div><a id="id732" class="indexterm"/><a id="id733" class="indexterm"/><a id="id734" class="indexterm"/><a id="id735" class="indexterm"/><p>When an issue is viewed, the edit operation is available only if you have the edit permission and the workflow manager passes the issue as editable. The workflow manager retrieves the list of properties added onto the issue's current status (that is, the step linked to the status) and checks the value of the <code class="literal">jira.issue.editable</code> property to see if it set to <code class="literal">false</code> or not before passing the issue as editable.</p><p>The properties against an issue workflow step are retrieved as follows:</p><div><pre class="programlisting">JiraWorkflow workflow = workflowManager.getWorkflow(issue);
StepDescriptor currentStep = workflow.getLinkedStep(ManagerFactory.getConstantsManager().getStatus(status));
Map properties = currentStep.getMetaAttributes();</pre></div><p>The <code class="literal">jira.issue.editable</code> property value is retrieved as <code class="literal">properties.get(JiraWorkflow.JIRA_META_ATTRIBUTE_EDIT_ALLOWED)</code>, where <code class="literal">JiraWorkflow.JIRA_META_ATTRIBUTE_EDIT_ALLOWED = "jira.issue.editable"</code>.</p><p>The same approach can be used to retrieve any other property added on a workflow step.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec125"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Permissions based on workflow status</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Including/excluding resolutions for specific transitions</h1></div></div></div><a id="id736" class="indexterm"/><a id="id737" class="indexterm"/><a id="id738" class="indexterm"/><a id="id739" class="indexterm"/><a id="id740" class="indexterm"/><a id="id741" class="indexterm"/><p>If you haven't noticed already, resolutions in JIRA are global. If you have a resolution <strong>Resolved</strong>, it appears whenever the resolution field is added on a transition screen. This might not make sense in some cases. For example, it doesn't make sense to add the resolution <strong>Resolved</strong> when you are rejecting an issue.</p><p>Let us see how we can pick and choose resolutions based on workflow transitions.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec126"/>How to do it...</h2></div></div></div><p>We can include/exclude specific resolutions on workflow transitions using the <a id="id742" class="indexterm"/>
<a id="id743" class="indexterm"/>
<code class="literal">jira.field.resolution.include</code> and <code class="literal">jira.field.resolution.exclude</code> properties. The following is the step-by-step procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Login as a JIRA Administrator</li><li class="listitem">Navigate to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</li><li class="listitem">Create a draft of the workflow, if it is active. Navigate to the transition which needs to be modified.</li><li class="listitem">Click on the <strong>View properties of this transition</strong> link.</li><li class="listitem">Enter <strong>jira.field.resolution.include</strong> or <strong>jira.field.resolution.exclude</strong> into the <strong>Property Key</strong> field, depending on whether you want to include or exclude a specific resolution.</li><li class="listitem">Enter the comma-separated list of resolution IDs that you want to include/exclude, under the <strong>Property Value</strong> field. The resolution ID can be obtained by navigating to <strong>Administration</strong> | <strong>Issue</strong> <strong>Settings</strong> | <strong>Resolutions</strong>, and hovering over the <strong>Edit</strong> link:<a id="id744" class="indexterm"/><a id="id745" class="indexterm"/><a id="id746" class="indexterm"/><a id="id747" class="indexterm"/><a id="id748" class="indexterm"/><a id="id749" class="indexterm"/><div><img src="img/1803-04-12.jpg" alt="How to do it..."/></div><p>You can also find the resolution ID by querying the <code class="literal">resolutions</code> table in the database.</p></li><li class="listitem">Click on <strong>Add</strong>.</li><li class="listitem">Go back and publish the workflow if it was active. If not, associate the workflow with the appropriate schemes.</li></ol></div><p>Note that the property is added on a workflow <em>transition</em> and not a <em>step</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec127"/>How it works...</h2></div></div></div><p>When the <code class="literal">jira.field.resolution.exclude</code> property<a id="id750" class="indexterm"/> is added, all the resolutions whose IDs are entered as a comma-separated values under the <code class="literal">Property Value</code> field are excluded from the screen during that transition.</p><p>On the other hand, if <code class="literal">jira.field.resolution.include</code><a id="id751" class="indexterm"/> is added, only the resolutions whose IDs are entered as a comma-separated values under the <code class="literal">Property Value</code> field are <a id="id752" class="indexterm"/>
<a id="id753" class="indexterm"/>
<a id="id754" class="indexterm"/>
<a id="id755" class="indexterm"/>
<a id="id756" class="indexterm"/>
<a id="id757" class="indexterm"/>shown in the screen.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Permissions based on workflow status</h1></div></div></div><a id="id758" class="indexterm"/><a id="id759" class="indexterm"/><p>We have seen how to restrict editing on an issue based on the workflow status. JIRA gives us an even bigger set of options to restrict many of these operations (such as edit, comment, and so on) on the issue or its subtasks, depending on the issue status.</p><p>Let us see this in detail.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec128"/>How to do it...</h2></div></div></div><p>This is done in a similar way to making an issue editable/non-editable. Here, also, we add a property on the concerned workflow step. The following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Log in as a JIRA Administrator</li><li class="listitem">Navigate to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</li><li class="listitem">Create a draft of the workflow, if it is active. Navigate to the step which needs to be modified.</li><li class="listitem">Click on the <strong>View step's properties</strong> link.</li><li class="listitem">Enter the permission property into the <strong>Property Key</strong> field. The property is of the form – <code class="literal">jira.permission.[subtasks.]{permission}.{type}[.suffix]</code> where:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">subtasks</code> – This is optional. If included, the permission is applied on the issue's subtasks. If not, the permission is applied on the actual issue.</li><li class="listitem" style="list-style-type: disc"><code class="literal">permission</code> – A short name specified in the <code class="literal">Permissions</code> (<a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/security/Permissions.html">http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/security/Permissions.html</a>) class.<p>The following are the permitted values, as of JIRA 4.2: <code class="literal">admin</code>, <code class="literal">use</code>, <code class="literal">sysadmin</code>, <code class="literal">project</code>, <code class="literal">browse</code>, <code class="literal">create</code>, <code class="literal">edit</code>, <code class="literal">scheduleissue</code>, <code class="literal">assign</code>, <code class="literal">assignable</code>, <code class="literal">attach</code>, <code class="literal">resolve</code>, <code class="literal">close</code>, <code class="literal">comment</code>, <code class="literal">delete</code>, <code class="literal">work</code>, <code class="literal">worklogdeleteall</code>, <code class="literal">worklogdeleteown</code>, <code class="literal">worklogeditall</code>, <code class="literal">worklogeditown</code>, <code class="literal">link</code>, <code class="literal">sharefilters</code>, <code class="literal">groupsubscriptions</code>, <code class="literal">move</code>, <code class="literal">setsecurity</code>, <code class="literal">pickusers</code>, <code class="literal">viewversioncontrol</code>, <code class="literal">modifyreporter</code>, <code class="literal">viewvotersandwatchers</code>, <code class="literal">managewatcherlist</code>, <code class="literal">bulkchange</code>, <code class="literal">commenteditall</code>, <code class="literal">commenteditown</code>, <code class="literal">commentdeleteall</code>, <code class="literal">commentdeleteown</code>, <code class="literal">attachdeleteall</code>, <code class="literal">attachdeleteown</code>.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code> – Type of permission granted/denied. The values can be <code class="literal">group</code>, <code class="literal">user</code>, <code class="literal">assignee</code>, <code class="literal">reporter</code>, <code class="literal">lead</code>, <code class="literal">userCF</code>, <code class="literal">projectrole</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">suffix</code> – An optional suffix to make the property unique when you have the same type added more than once! <code class="literal">jira.permission.edit.group.1</code>, <code class="literal">jira.permission.edit.group.2</code>, and so on. This is because of the OSWorkflow restriction that the property value should be unique.</li></ul></div></li><li class="listitem"><a id="id760" class="indexterm"/><a id="id761" class="indexterm"/>Enter the appropriate value in the <strong>Property Value</strong> field. If the type is group, enter a group. If it is a user, enter a username, and so on.<p>It might be useful to give a few examples here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.comment.group=some-group</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.comment=denied</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.edit.group.1=some-group-one</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.edit.group.2=some-group-two</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.modifyreporter.user=username</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.delete.projectrole=10000</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jira.permission.subtasks.delete.projectrole=10000</code></li></ul></div><p>You can even use the value as 'denied' when the type is not used. For example, <code class="literal">jira.permission.comment=denied</code> means the comment feature is disabled at this state.</p></li><li class="listitem">Go back and publish the workflow, if it was active. If not, associate the workflow with the appropriate schemes.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec129"/>How it works...</h2></div></div></div><a id="id762" class="indexterm"/><a id="id763" class="indexterm"/><p>When a particular permission property is tied to a workflow status, JIRA looks at it and enforces it. It is to be noted that workflow permissions can only restrict permissions set in the permission scheme, not grant permissions.</p><p>For example, if you have the edit permission restricted to <code class="literal">jira-administrators</code> in the permission scheme, adding <code class="literal">jira.permission.edit.group=jira-users</code> wouldn't grant the permission to <code class="literal">jira-users</code>.</p><p>But instead, if you had both of these groups with the edit permission, only <code class="literal">jira-users</code> will be allowed to edit, as defined in the workflow permission.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec130"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Making an issue editable/non-editable based on workflow status</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Internationalization in workflow transitions</h1></div></div></div><a id="id764" class="indexterm"/><a id="id765" class="indexterm"/><p>If your JIRA instance is used by people around the world speaking different languages, it is likely that you use internationalization to convert JIRA into their own language. But things like the workflow action name, button name, and so on are configured in the workflows and not as i18n properties. And therefore, they are limited to a single language.</p><p>This is where workflow properties come to our rescue, again!</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec131"/>How to do it...</h2></div></div></div><p>We can modify the workflow action submit button name or the action name using the properties <code class="literal">jira.i18n.submit</code> or <code class="literal">jira.i18n.title</code> respectively. The following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the jar file <code class="literal">atlassian-jira/WEB-INF/lib/language_&lt;language code&gt;_&lt;country code&gt;.jar</code>. From JIRA 4.3, the jar filename is of the form <code class="literal">jira-lang-&lt;language code&gt;_&lt;country code&gt;-&lt;jira version&gt;.jar</code>.</li><li class="listitem">Edit the file <code class="literal">\com\atlassian\jira\web\action\JiraWebActionSupport_&lt;language code&gt;_&lt;country code&gt;.properties</code> inside the jar. You can use a utility such as 7zip to edit the file inside the jar. Alternatively, you can extract the jar, modify the file, and archive it again!</li><li class="listitem">Add your i18n property and its value: <code class="literal">my.submit.button=My Submit Button in English</code>.</li><li class="listitem">Update the file and restart JIRA to pick up the new property.</li><li class="listitem">Log in as a JIRA Administrator.</li><li class="listitem">Navigate to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</li><li class="listitem">Create a draft of the workflow, if it is active. Navigate to the transition which needs to be modified.</li><li class="listitem">Click on the <strong>View properties of this transition</strong> link.</li><li class="listitem">Enter <strong>jira.i18n.submit</strong> or <strong>jira.i18n.title</strong> into the <strong>Property Key</strong> field, depending on whether you want to modify submit button name or action name. Let us consider the example of the Submit button</li><li class="listitem">Enter i18n key that we used in the property file, under the <strong>Property Value</strong> field. In our example, the key is <strong>my.submit.button</strong>.</li><li class="listitem">Click on <strong>Add</strong>.</li><li class="listitem">Go back and publish the workflow, if it was active. If not, associate the workflow with the appropriate schemes.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec132"/>How it works...</h2></div></div></div><a id="id766" class="indexterm"/><a id="id767" class="indexterm"/><p>Once the workflow is published, JIRA will populate the submit button name from the i18n property file the next time the transition happens. In our example, the transition screen will look like the following screenshot:</p><div><img src="img/1803-04-13.jpg" alt="How it works..."/></div><p>As you can see, the button name is changed to <strong>My Submit Button in English</strong>. All you need <a id="id768" class="indexterm"/>
<a id="id769" class="indexterm"/>to do now is modify the other language jars to include the proper translations!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec133"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Internationalization in v2 plugins</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Obtaining available workflow actions programmatically</h1></div></div></div><a id="id770" class="indexterm"/><a id="id771" class="indexterm"/><p>Often in our programs, we may come across the need to retrieve the current workflow actions, available on the issue. Let us have a look at how to do this using the JIRA API.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec134"/>How to do it...</h2></div></div></div><p>Follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Retrieve the JIRA workflow object associated with the issue:<div><pre class="programlisting">JiraWorkflow workFlow = componentManager.getWorkflowManager().getWorkflow(issue);</pre></div><p>Here, issue is the current issue, which is an instance of <code class="literal">com.atlassian.jira.issue.Issue</code> class.</p></li><li class="listitem">Get the issue status and use it to retrieve the current workflow step linked to the issue:<div><pre class="programlisting">GenericValue status = issue.getStatusObject().getGenericValue();
com.opensymphony.workflow.loader.StepDescriptor currentStep = workFlow.getLinkedStep(status);</pre></div></li><li class="listitem">Retrieve the set of available actions from the current step:<div><pre class="programlisting">List&lt;ActionDescriptor&gt; actions = currentStep.getActions();</pre></div><p>Here, <code class="literal">actions</code> is a list of <code class="literal">com.opensymphony.workflow.loader.ActionDescriptor</code>.</p></li><li class="listitem">Iterate on the <code class="literal">ActionDescriptors</code> and get the details for each action, depending on the requirement! The name of the available action can be printed as follows:<div><pre class="programlisting">for (ActionDescriptor action : actions) {
    System.out.println("Action: "+action.getName())
 }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec135"/>How it works...</h2></div></div></div><p><strong>WorkflowManager</strong><a id="id772" class="indexterm"/> is used to perform a lot of operations related to workflows such as creating/updating/deleting a workflow, copying it, creating a draft, and so on. Here we use it to retrieve the workflow object, based on the issue selected. Please check the API (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowManager.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowManager.html</a>) for a full list of available operations using <code class="literal">WorkflowManager</code>.</p><a id="id773" class="indexterm"/><a id="id774" class="indexterm"/><p>Once we retrieve the JIRA workflow, we get the current step using the status. As you have seen before in this chapter, a workflow <em>status</em> is linked to one and only one workflow <em>step</em>. Once we get the <em>step</em>, we can get a load of information from it, including the available actions from that <em>step</em>.</p><p>Jolly good?</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec136"/>There's more...</h2></div></div></div><p>There's more to it…</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Getting the Action IDs, given name</h3></div></div></div><a id="id775" class="indexterm"/><p>The same method can be used to retrieve the action ID, given an action name. Remember, it is the action ID that we use while programmatically progressing on the workflows.</p><p>Once the action name is available, you can easily retrieve the action ID by iterating on the list of actions, as shown in the following lines of code:</p><div><pre class="programlisting">private int getActionIdForTransition(List&lt;ActionDescriptor&gt; actions, String actionName) {
  for (ActionDescriptor action : actions) {
    if (action.getName().equals(actionName)) {
               return action.getId();
          }
  }
  return -1; // Handle invalid action
}</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Programmatically progressing on workflows</h1></div></div></div><a id="id776" class="indexterm"/><a id="id777" class="indexterm"/><p>Another operation that we perform normally on workflows is to programmatically transit the issues through its workflows. Let us have a look at how to do this using the JIRA API.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec137"/>How to do it...</h2></div></div></div><p>Since JIRA 4.1, transitioning issues is done using the <code class="literal">IssueService</code> (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/issue/IssueService.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/issue/IssueService.html</a>). Here's is how you do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Get the <code class="literal">IssueService</code> object either by injecting it in the constructor or as follows:<div><pre class="programlisting">IssueService issueService = ComponentManager.getInstance().getIssueService();</pre></div></li><li class="listitem">Find out the action ID for the action to be executed. You can either get it by looking at the workflows (the number within brackets alongside the transition name), if you know it is not going to change or retrieve it using the action name (refer to the previous recipe).</li><li class="listitem">Populate the <code class="literal">IssueInputParameters</code> if you want to modify anything on the issue such as assignee, reporter, resolution, and so on! It represents an issue builder and is used to provide parameters that can be used to update the issue during the transition:<div><pre class="programlisting">IssueInputParameters issueInputParameters = new IssueInputParametersImpl();
issueInputParameters.setAssigneeId("someotherguy");
issueInputParameters.setResolutionId("10000");</pre></div></li><li class="listitem">A full list of supported fields can be found at <a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/IssueInputParameters.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/IssueInputParameters.html</a>.</li><li class="listitem">Validate the transition:<div><pre class="programlisting">TransitionValidationResult transitionValidationResult = issueService.validateTransition(user, 12345L, 10000L, issueInputParameters);</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">User</code> – The current user or the user who will be performing the transition</li><li class="listitem" style="list-style-type: disc"><code class="literal">12345L</code> – The issue ID</li><li class="listitem" style="list-style-type: disc"><code class="literal">10000L</code> – The action ID</li><li class="listitem" style="list-style-type: disc"><code class="literal">issueInputParameters</code> – The parameters we populated in the previous step</li></ul></div></li><li class="listitem">If <code class="literal">transitionValidationResult</code> is valid, invoke the transition operation. Handle it if it is not valid. Make sure you use the same user.<div><pre class="programlisting">if (transitionValidationResult.isValid()){
        IssueResult transitionResult = issueService.transition(user, transitionValidationResult);
        if (!transitionResult.isValid()){
            // Do something
        }
}</pre></div><p>We need to do a final check on the result as well to see if it is valid!</p></li><li class="listitem">That will transit the issue to the appropriate state.</li></ol></div><p>Prior to <code class="literal">IssueService</code>, the transition was done using <code class="literal">WorkflowTransitionUtil</code> (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowTransitionUtil.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/workflow/WorkflowTransitionUtil.html</a>). It is still supported, but <code class="literal">IssueService</code> is recommended.</p><a id="id778" class="indexterm"/><a id="id779" class="indexterm"/><p>The following is how the transitioning is done using <code class="literal">WorkflowTransitionUtil</code>:</p><p>Get the <code class="literal">WorkflowTransitionUtil</code> object:</p><div><pre class="programlisting">WorkflowTransitionUtil workflowTransitionUtil = (WorkflowTransitionUtil) JiraUtils .loadComponent(WorkflowTransitionUtilImpl.class);</pre></div><p>Create a map of parameters that need to be updated on the issue:</p><div><pre class="programlisting">Map paramMap = EasyMap.build(); 
paramMap.put(IssueFieldConstants.RESOLUTION, "10000");  paramMap.put(IssueFieldConstants.COMMENT, comment);</pre></div><p>Populate the <code class="literal">workflowTransitionUtil</code> with the details:</p><div><pre class="programlisting">workflowTransitionUtil.setParams(paramMap);  workflowTransitionUtil.setIssue(12345L);  workflowTransitionUtil.setUsername(user);  workflowTransitionUtil.setAction(10000L);</pre></div><p>Validate the transition:</p><div><pre class="programlisting">ErrorCollection c1 = workflowTransitionUtil.validate();</pre></div><p>If there is no error, progress with the workflow. Handle the errors, if any:</p><div><pre class="programlisting">ErrorCollection c2 = workflowTransitionUtil.progress();</pre></div><p>And we should have the issue in its new status! Check the error collection to handle errors, if any.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec138"/>How it works...</h2></div></div></div><a id="id780" class="indexterm"/><a id="id781" class="indexterm"/><p>Once the action ID is correct and the parameters are validated properly, <code class="literal">IssueService</code> or <code class="literal">WorkflowTransitionUtil</code> will do the background work of transitioning the issues.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Obtaining workflow history from the database</h1></div></div></div><p>JIRA captures changes on an issue in its "change history". It is pretty easy to find them by going to the change history tab on the view issue page.</p><p>But often, we would like to find out specific details about the various workflow statuses that an issue has gone through in its lifecycle. Going through the change history and identifying the status changes is a painful task when there are tens of hundreds of changes on an issue. People normally write plugins to get around this or go directly to the database.</p><p>Even when it is achieved using plugins, the background logic is to look at the tables in the database. In this recipe, we will look at the tables involved and writing the SQL query to extract workflow changes for a given issue.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec139"/>Getting ready</h2></div></div></div><a id="id782" class="indexterm"/><a id="id783" class="indexterm"/><a id="id784" class="indexterm"/><p>Make sure you have an SQL client installed and configured that will help you to connect to the JIRA database.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec140"/>How to do it...</h2></div></div></div><p>Follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Connect to the JIRA database.</li><li class="listitem">Find out the <code class="literal">id</code> of the issue for which you want to extract the workflow changes. If you don't have the ID in hand, you can get it from the database using the issue key as follows:<div><pre class="programlisting">
<strong>select id from jiraissue where pkey = "JIRA-123"</strong>
</pre></div><p>Where <code class="literal">JIRA-123</code> is the issue key.</p></li><li class="listitem">Extract all the change groups created for the issue. Every set of changes made on an issue during a single operation (for example, edit, workflow transition, and so on) are grouped in to a single <code class="literal">changegroup</code> by JIRA. It is on the <code class="literal">changegroup</code> record that JIRA stores the associated <code class="literal">issueid</code> and the <code class="literal">created</code> date (date when the change was made):<div><pre class="programlisting">
<strong>select id from changegroup where issueid = '10010'</strong>
</pre></div><p>Where <code class="literal">10010</code> is the <code class="literal">issue</code> <code class="literal">id</code>, the ID we extracted in the previous step.</p><p>While extracting the change groups, we can even mention the created date if you want to see only changes on a specific date! Use the author field to restrict this to changes made by a user.</p></li><li class="listitem">Extract <code class="literal">status</code> changes for the group/groups selected:<div><pre class="programlisting">
<strong>select oldstring, newstring from changeitem where fieldtype = "jira" and field = "status" and groupid in ( 10000, 10010 )</strong>
</pre></div><p>Here the <code class="literal">groupid</code> <code class="literal">10000</code>, <code class="literal">10010</code>, and so on are IDs extracted in the previous step. Here, <code class="literal">oldstring</code> is the original value on the issue and <code class="literal">newstring</code> is the updated value.</p><p>Include <code class="literal">oldvalue</code> and <code class="literal">newvalue</code>, if you want to get the status IDs as well.</p></li></ol></div><a id="id785" class="indexterm"/><a id="id786" class="indexterm"/><a id="id787" class="indexterm"/><p>You can write it in a single query, as shown next, or modify it to include more details. But hopefully, this gives you a starting point!</p><div><pre class="programlisting">
<strong>select oldstring, newstring from changeitem where fieldtype = "jira" and field = "status" and groupid in ( select id from changegroup where issueid = '10010');</strong>
</pre></div><p>Another example to extract the details along with the created date is to use inner join as follows:</p><div><pre class="programlisting">
<strong>select ci.oldstring, ci.newstring, cg.created from changeitem ci inner join changegroup cg on ci.groupid = cg.id where ci.fieldtype = "jira" and ci.field = "status" and cg.issueid = '10010';</strong>
</pre></div><p>Over to you DBAs now!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec141"/>How it works...</h2></div></div></div><p>As mentioned, the changes at any single operation on an issue are stored as a <code class="literal">changegroup</code> record in the JIRA database. The main three columns <code class="literal">issueid</code>, <code class="literal">author</code>, and <code class="literal">created</code> are all parts of this table.</p><p>The actual changes are stored in the <code class="literal">changeitem</code> table with its foreign key <code class="literal">groupid</code> pointing to the <code class="literal">changegroup</code> record.</p><p>In our case, we are looking specifically at the workflow statuses, and hence we query for records that have the <code class="literal">fieldtype</code> value of <code class="literal">jira</code> and <code class="literal">field</code> of <code class="literal">status</code>.</p><p>The output of the query (that uses an inner join) is as follows:</p><div><img src="img/1803-04-14.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec142"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Retrieving workflow details from a table</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Re-ordering workflow actions in JIRA</h1></div></div></div><p>On a JIRA workflow, the available actions that appear in the <strong>View Issue</strong> page are normally ordered in the sequence those transitions were created. This works fine most of the time, but in some cases, we will want to change the order in which it appears on the issue screen!</p><p>To achieve this logical ordering of workflow actions on the <strong>View Issue</strong> page, JIRA provides us with a workflow property named <code class="literal">opsbar-sequence</code>. Let us see how we modify the ordering using this property instead of tampering with the workflow.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec143"/>How to do it...</h2></div></div></div><a id="id788" class="indexterm"/><a id="id789" class="indexterm"/><p>Follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Log in as a JIRA Administrator</li><li class="listitem">Navigate to <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Workflows</strong>.</li><li class="listitem">Create a draft of the workflow, if it is active. Navigate to the transition which needs to be modified.</li><li class="listitem">Click on the <strong>View properties of this transition</strong> link.</li><li class="listitem">Enter <strong>opsbar-sequence</strong> into the <strong>Property Key</strong> field.</li><li class="listitem">Enter the <strong>sequence</strong> value under the <strong>Property Value</strong> field. This value should be relative to the values entered in the other transitions.</li><li class="listitem">Click on <strong>Add</strong>.</li><li class="listitem">Go back and publish the workflow, if it was active. If not, associate the workflow with the appropriate schemes.</li></ol></div><p>Note that the property is added on a workflow <em>transition</em> and not a <em>step</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec144"/>How it works...</h2></div></div></div><p>Let us consider the following example where the <strong>Reject this</strong> workflow action appears first:</p><div><img src="img/1803-04-15.jpg" alt="How it works..."/></div><p>Normally, people would want to see this as the last option because it is most likely the least used operation.</p><a id="id790" class="indexterm"/><a id="id791" class="indexterm"/><p>As there are four operations here, we can order them as shown in the following table with the sequence values against them:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Workflow action</p>
</th><th style="text-align: left" valign="bottom">
<p>Sequence</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><strong>Start Progress</strong></p>
</td><td style="text-align: left" valign="top">
<p>10</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><strong>Resolve Issue</strong></p>
</td><td style="text-align: left" valign="top">
<p>20</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><strong>Close Issue</strong></p>
</td><td style="text-align: left" valign="top">
<p>30</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><strong>Reject this</strong></p>
</td><td style="text-align: left" valign="top">
<p>40</p>
</td></tr></tbody></table></div><p>Note that the sequence numbers can even be 1, 2, 3, and 4. There are no restrictions on how and where the numbers should start. It is advised to keep 10, 20, and so on so that we can insert new transitions in between, if required in future.</p><p>After we modify the workflow using the property and the aforementioned sequence numbers, as we saw in the previous section, the actions are ordered as follows:</p><div><img src="img/1803-04-16.jpg" alt="How it works..."/></div><a id="id792" class="indexterm"/><a id="id793" class="indexterm"/><p>Remember, the order of the workflow actions is changed only in the <strong>View Issue</strong> page and not in the <strong>View Workflow Steps</strong> page, where you modify the workflow steps.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Creating common transitions in workflows</h1></div></div></div><a id="id794" class="indexterm"/><a id="id795" class="indexterm"/><a id="id796" class="indexterm"/><p>Configuring workflows can be a painful thing. Especially when there are similar transitions used in 10 different places and those get changed every now and then. The change might be the simplest thing possible, such as editing just the name of the transition, but we end up modifying it in 10 places.</p><p>This is where OSWorkflow's common actions come to our rescue. A little bit on the theory can be read at <a class="ulink" href="http://www.opensymphony.com/osworkflow/3.3%20Common%20and%20Global%20Actions.html">http://www.opensymphony.com/osworkflow/3.3%20Common%20and%20Global%20Actions.html</a>.</p><p>JIRA already makes use of common actions in its default workflow. We can't modify the default workflow, but if we make a copy of it and rename the <strong>Resolve</strong> transition to <strong>New Resolve</strong>, it appears as shown in the following screenshot:</p><div><img src="img/1803-04-17.jpg" alt="Creating common transitions in workflows"/></div><p>Note that the transition is renamed at all the three places where it appears!</p><p>In this recipe, let us look at adding a new common transition.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec145"/>How to do it...</h2></div></div></div><a id="id797" class="indexterm"/><a id="id798" class="indexterm"/><a id="id799" class="indexterm"/><p>There are two ways of adding common transitions.</p><div><ol class="orderedlist arabic"><li class="listitem">Copy the JIRA default workflow and modify it to suit our needs.</li><li class="listitem">Create workflow using XML.</li></ol></div><p>The first one is useful only if our workflow needs are limited, that is, only if we can live by modifying the existing transitions.</p><p>If we need to configure a bigger workflow with new common transitions, we need to take the XML route. Let us see the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To make things easier, export the existing workflow that needs to be modified into an XML. You can do this using the XML link on the view workflows page. You could create a workflow XML from scratch, but that needs lot of effort and knowledge of OSWorkflow. In this case, we export the standard JIRA workflow.</li><li class="listitem">Identify the <code class="literal">common-actions</code> section in the workflow XML. It comes in the starting immediately after <code class="literal">initial-actions</code>.</li><li class="listitem">Add our new <code class="literal">common-action</code>. There are a few things that we need to notice here. The action ID should be a unique ID within the XML. You will find examples of all this in the standard workflow XML or you can read more about them in the OSWorkflow documentation.<p>The following is how a simple action looks:</p><div><pre class="programlisting">&lt;action id="6" name="Start Again"&gt;
  &lt;meta name="jira.description"&gt;Testing Common Actions&lt;/meta&gt; 
  &lt;results&gt;
    &lt;unconditional-result old-status="Finished" status="Open" step="1"&gt;
       &lt;post-functions&gt;
         &lt;function type="class"&gt;
           &lt;arg name="class.name"&gt;com.atlassian.jira.workflow.function.issue.UpdateIssueStatusFunction&lt;/arg&gt;
         &lt;/function&gt;
         &lt;function type="class"&gt;
           &lt;arg name="class.name"&gt;com.atlassian.jira.workflow.function.misc.CreateCommentFunction&lt;/arg&gt;
         &lt;/function&gt;
         &lt;function type="class"&gt;
           &lt;arg name="class.name"&gt;com.atlassian.jira.workflow.function.issue.GenerateChangeHistoryFunction&lt;/arg&gt;
         &lt;/function&gt;
         &lt;function type="class"&gt;
           &lt;arg name="class.name"&gt;com.atlassian.jira.workflow.function.issue.IssueReindexFunction&lt;/arg&gt;
         &lt;/function&gt;
         &lt;function type="class"&gt;
           &lt;arg name="class.name"&gt;com.atlassian.jira.workflow.function.event.FireIssueEventFunction&lt;/arg&gt;
            &lt;arg name="eventTypeId"&gt;13&lt;/arg&gt;
          &lt;/function&gt;
       &lt;/post-functions&gt;
    &lt;/unconditional-result&gt;
  &lt;/results&gt;
&lt;/action&gt;</pre></div></li><li class="listitem"><a id="id800" class="indexterm"/><a id="id801" class="indexterm"/><a id="id802" class="indexterm"/>Make sure you modify the name, description, status, step, eventTypeId, and the post functions. Here we used <code class="literal">Finished</code> as the <code class="literal">old-status</code> as it is used in the other common actions in the JIRA standard workflow. You can also add new meta attributes, conditions, validators, and so on, but it probably is a good idea to start simple and modify everything else in the JIRA UI once it is imported to JIRA.</li><li class="listitem">Include the common action in the other steps, wherever required:<div><pre class="programlisting">&lt;step id="1" name="Open"&gt;
  &lt;meta name="jira.status.id"&gt;1&lt;/meta&gt;
  &lt;actions&gt;
    &lt;common-action id=".." /&gt;
    .....................
    &lt;common-action id="6" /&gt;
    &lt;action id=" .....
    .......................
    &lt;/action&gt;
  &lt;/actions&gt;
&lt;/step&gt;</pre></div><p>Note that the ID here should be the action ID of the <code class="literal">common-action</code> we added in the previous steps. Also, the <code class="literal">common-actions</code> should appear before the <code class="literal">action</code> elements in the <em>step</em> in order to comply with the OSWorkflow syntax.</p></li><li class="listitem">Import the modified XML as a workflow to JIRA. You can do this using the <strong>Import a Workflow from XML</strong> link. Check out <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+Workflow#ConfiguringWorkflow-UsingXMLtocreateaworkflow">http://confluence.atlassian.com/display/JIRA/Configuring+Workflow#ConfiguringWorkflow-UsingXMLtocreateaworkflow</a> for details.</li><li class="listitem">The workflow is now ready to use.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec146"/>How i works...</h2></div></div></div><a id="id803" class="indexterm"/><a id="id804" class="indexterm"/><a id="id805" class="indexterm"/><p> JIRA workflows are fundamentally using OpenSymphony's OSWorkflow, as we saw in <a class="link" href="ch02.html" title="Chapter 2. Understanding Plugin Framework">Chapter 2</a>, <em>Understanding Plugin Framework</em>. OSWorkflow gives us the flexibility to add common actions by modifying the workflow XML. We have used this feature by modifying the existing workflow XML and importing it back in to JIRA.</p><p>The following screenshot is how the updated workflow looks:</p><div><img src="img/1803-04-18.jpg" alt="How i works..."/></div><a id="id806" class="indexterm"/><a id="id807" class="indexterm"/><a id="id808" class="indexterm"/><p>Note that the new transition <strong>Start Again</strong> is added to all the steps other than the last one. Suppose we want to modify the name to <strong>Start Again &amp; Again</strong>, it can be done just by editing one of these transitions. The modified workflow looks as follows:</p><div><img src="img/1803-04-19.jpg" alt="How i works..."/></div><a id="id809" class="indexterm"/><a id="id810" class="indexterm"/><a id="id811" class="indexterm"/><p>We can similarly modify any attributes on the transition, and it will be reflected in all the places where the transition is used.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Jelly escalation</h1></div></div></div><a id="id812" class="indexterm"/><p>Before winding up this chapter, let us have a quick look at how we can use one of the useful features of JIRA to escalate inactive issues by transitioning them to a pre-defined workflow status.</p><a id="id813" class="indexterm"/><p><strong>Jelly Service</strong> is a built-in service in JIRA using which we can run useful Jelly scripts at regular intervals. Atlassian explains in its documentation at<a class="ulink" href="http:// http://confluence.atlassian.com/display/JIRA/Jelly+Escalation"> http://confluence.atlassian.com/display/JIRA/Jelly+Escalation</a> about running a Jelly script to move issues that were not updated in the last seven days to an inactive status.</p><p>Let us have a look at this recipe at how to modify the script and transition issues in to different workflow statuses.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec147"/>Getting ready</h2></div></div></div><a id="id814" class="indexterm"/><a id="id815" class="indexterm"/><p>Make sure Jelly is turned on in your JIRA instance. It is disabled by default due to security concerns. You can turn it ON by setting the <code class="literal">jira.jelly.on</code> property<a id="id816" class="indexterm"/> to <code class="literal">true</code>.</p><p>You can set the property by adding <code class="literal">-Djira.jelly.on=true</code> into the <code class="literal">JAVA_OPTS</code> variable. Adding this variable depends on the server and operating system.</p><p>For example, the property can be set on the Tomcat server in Windows by adding it into <code class="literal">setenv.bat</code> under the <code class="literal">/bin</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec148"/>How to do it...</h2></div></div></div><p>The following are the steps to close issues that have been inactive for the last 15 days:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a filter that displays issues that are not updated for the last 15 days. You can do this by executing the following JQL query:<div><pre class="programlisting">updated &lt;= -15d</pre></div><p>Save the filter with some name and make a note of the filter ID.</p><div><img src="img/1803-04-20.jpg" alt="How to do it..."/></div></li><li class="listitem">You can find the filter ID by hovering over the <strong>Edit</strong> link, as shown. The URL will be like <code class="literal">http://localhost:8080/secure/EditFilter!default.jspa?atl_token=084b891405e500819d6443d8378ed37a5bbe4c72&amp;filterId=10010&amp;returnUrl=ManageFilters.jspa</code> where <code class="literal">filterId</code> is <code class="literal">10010</code>.<p>Modify the Jelly script provided by Atlassian in order to include the new filter ID, workflow step name, username, and password. Also modify the comment accordingly.</p><p>Here is the modified script:</p><div><pre class="programlisting">&lt;JiraJelly    &gt;
&lt;jira:Login username="jobinkk" password="[password here]"&gt;    &lt;log:warn&gt;Running Inactivate issues service&lt;/log:warn&gt;
    &lt;!-- Properties for the script --&gt;
    &lt;core:set var="comment"&gt;Closing out this issue since it has been inactive for 15 days!&lt;/core:set&gt;
    &lt;core:set var="workflowStep" value="Close Issue" /&gt;
    &lt;core:set var="workflowUser" value="jobinkk" /&gt;
    &lt;core:set var="filter15Days" value="10010" /&gt;

    &lt;!-- Run the SearchRequestFilter --&gt;
    &lt;jira:RunSearchRequest filterid="${filter15Days}" var="issues" /&gt;
   
    &lt;core:forEach var="issue" items="${issues}"&gt;
    &lt;log:warn&gt;Inactivating issue ${issue.key}&lt;/log:warn&gt;

     &lt;jira:TransitionWorkflow key="${issue.key}" user="${workflowUser}" workflowAction="${workflowStep}" comment="${comment}"/&gt;   &lt;/core:forEach&gt;
&lt;/jira:Login&gt;
&lt;/JiraJelly&gt;</pre></div></li><li class="listitem">Save the script and put it under some location in the server where JIRA is running.</li><li class="listitem">Go to <strong>Administration</strong> | <strong>System</strong> | <strong>Services</strong> <strong>in</strong> <strong>JIRA</strong>.</li><li class="listitem">Add the escalation service:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: Escalation Task</li><li class="listitem" style="list-style-type: disc"><strong>Class</strong>: Click on <strong>Built-in services</strong> and select <strong>Run Jelly Script</strong>. The class will be selected as <code class="literal">com.atlassian.jira.jelly.service.JellyService</code></li><li class="listitem" style="list-style-type: disc"><strong>Delay</strong>: Select a suitable delay, in minutes.</li><li class="listitem" style="list-style-type: disc">Click on <strong>Add Service</strong></li></ul></div></li><li class="listitem"><a id="id817" class="indexterm"/><a id="id818" class="indexterm"/>On the <strong>Add Service</strong> page, enter the following details:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Input File</strong>: Path to the script file we saved in the server</li><li class="listitem" style="list-style-type: disc"><strong>Output File</strong>: Path to an output log file.</li><li class="listitem" style="list-style-type: disc"><strong>Delay</strong>: Modify if required.</li></ul></div></li></ol></div><p>The script will now run the configured delay.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec149"/>How it works...</h2></div></div></div><p>JIRA has its own API for the <strong>Jelly Scripting</strong><a id="id819" class="indexterm"/>. As you can see from the script, following are the steps executed:</p><div><ol class="orderedlist arabic"><li class="listitem">The script runs the search request on the filter we saved in the first step using the <code class="literal">RunSearchRequest</code> method<a id="id820" class="indexterm"/>. It then stores the retrieved results in variable issues.</li><li class="listitem">Script then iterates on the issues and transitions each of them in the workflow using the <code class="literal">TransitionWorkflow</code> method<a id="id821" class="indexterm"/>. It makes use of the key from the issue, the workflow user we configured, and the workflow action. It also adds the comment we entered in the script.<p>Note that the workflow action should be available on the issue from its current status. If it is not, the transition will not work. For example, Close workflow action will throw an error if attempted on an issue that is already Closed.</p></li></ol></div><a id="id822" class="indexterm"/><a id="id823" class="indexterm"/><p>We can modify the script to transition the issue to any workflow status based on any filter criteria.</p><p>A lot of other useful things about Jelly Scripting can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Jelly+Tags">http://confluence.atlassian.com/display/JIRA/Jelly+Tags</a>.</p></div></div></body></html>