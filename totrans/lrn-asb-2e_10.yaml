- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Out a Cloud Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have launched servers in Microsoft Azure, we will start looking
    at launching services within **Amazon Web** **Services** (**AWS**).
  prefs: []
  type: TYPE_NORMAL
- en: Before we launch virtual machine instances, we must create a network to host
    them. This is called a **virtual private cloud** (**VPC**) and there are a few
    different elements we will need to bring together in a playbook to create one,
    which we will then be able to use for our instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive an introduction to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover what it is we are trying to achieve and why
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a VPC, subnets, and routes (networking and routing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create security groups (firewall)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at more advanced Ansible techniques as we launch and manage more
    dynamic resources with complex dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon VPC overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an access key and secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Ansible ready for targeting AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will use AWS; you will need administrator access to create the
    roles needed to allow Ansible to interact with your account. As with other chapters,
    you can find the complete playbooks in the `Chapter10` folder in the accompanying
    GitHub repository at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS has been around since 2002; it started by offering a few services that
    were not linked in any way. It progressed in this form until early 2006 when it
    was relaunched. The relaunched AWS brought together three services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elastic Compute Cloud** (**Amazon EC2**): This is the AWS compute
    service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Simple Storage Service** (**Amazon S3**): Amazon’s scalable object
    storage service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Simple Queue Service** (**Amazon SQS**): This service provides a message
    queue, primarily for web applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since 2006, it has grown from three unique services to over 160, covering over
    15 primary areas such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking and content delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning analytics security, identity, and compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet of things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At its earnings call in October 2023, it was revealed that AWS had USD 23.06
    billion in revenue in the third quarter of 2023, good for a service that initially
    offered to share idle compute time.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, AWS spans 32 geographic regions, which host a total
    of 102 availability zones ([https://aws.amazon.com/about-aws/global-infrastructure/](https://aws.amazon.com/about-aws/global-infrastructure/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what makes AWS so successful? Not only its coverage but its approach to
    putting out its services. Andy Jassy, AWS CEO, has been quoted as saying:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Our mission is to enable any developer or any company to be able to build
    all their technology applications on top of our infrastructure technology platform*.”
  prefs: []
  type: TYPE_NORMAL
- en: As an individual, you have access to the same APIs, services, regions, tools,
    and pricing models as large multi-national companies and Amazon themselves, as
    they consume their services. This gives you the freedom to start small and scale
    massively. For example, Amazon EC2 instances start from around USD 4.50 per month
    for a t2.nano (1 vCPU and 0.5G) all the way up to over USD 19,000 per month for
    an x1e.32xlarge (128 vCPU, 3,904 GB RAM, and two 1920 GB SSD storage); as you
    can see, there are instance types for every workload imaginable.
  prefs: []
  type: TYPE_NORMAL
- en: Both instances and most services are billed under pay-as-you-go, from per-second
    billing for EC2 instances to pay per GB per month for the storage you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon VPC overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to be concentrating on launching an **Amazon Virtual
    Private Cloud** (**Amazon VPC**); this is the networking layer that will host
    the computing and other Amazon services that we will be launching in [*Chapter
    11*](B21620_11.xhtml#_idTextAnchor501), *Highly Available* *Cloud Deployments*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to be launching our VPC into the **EU-West #1 (Ireland)** region;
    we will be spanning all three availability zones for our **EC2** instances and
    also the **Application Elastic Load Balancer**. We will, again, be using the three
    availability zones for our **Amazon Relational Database Service** (**RDS**) instance
    and also two zones for the **Amazon Elastic File System** (**Amazon** **EFS**)
    volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This all means our Ansible playbook needs to create/configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One Amazon VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three subnets for EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three subnets for Amazon RDS instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three subnets for Amazon EFS volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three subnets for the Application Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One internet gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also need to configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One route to allow access through the internet gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group that allows everyone to access port `80` (HTTP) and `443`
    (HTTPS) on the Application Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group that allows trusted source access to port `22` (SSH) on the
    EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group that allows access to port `80` (HTTP) from the Application
    Load Balancer to the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group that allows access to port `3306` (MySQL) on the Amazon RDS
    instances from the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group that allows access to port `2049` (NFS) on the Amazon EFS
    volumes from the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will give us our primary network, allowing restrictive access to everything
    but the Application Load Balancer, which we want to be publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating an Ansible playbook that deploys the network, we need to get
    an AWS API access key and secret.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an access key and secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is more than possible to create an access key and secret key for your AWS
    user to give Ansible full access to your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, we are going to look at creating a user for Ansible, which
    only has permission to access the parts of AWS we know that Ansible will need
    to interact with for the tasks we are covering in this chapter. We will be giving
    Ansible full access to the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon EC2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon RDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon EFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS console, which can be found at [https://console.aws.amazon.com/](https://console.aws.amazon.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once logged in, click on `IAM` into the search box and then click on the **IAM
    “Manage access to AWS** **resources”** result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **IAM** page, click **User Groups** in the left-hand side menu; we will
    create a group with the permissions assigned to it, and then we will create a
    user and add it to our group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once on the `Ansible`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in the **Attach permissions policies – Optional** section, select **AmazonEC2FullAccess**,
    **AmazonVPCFullAccess**, **AmazonRDSFullAccess**, and **AmazonElasticFileSystemFullAccess**;
    once all four have been selected, click on the **Create Group** button at the
    bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our Ansible group, click **Users** in the left-hand side menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once on the `LearnAnsible` in here
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **Provide user access to the AWS Management Console – optional** option
    unchecked, as we will create a programmatic user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Ansible` group we created earlier ticked, and then click **Next**,
    which will take you to the **Review and** **Create** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have reviewed the details, you need to click the `LearnAnsible` user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to get an access key for our user. To get this, click on the
    `LearnAnsible` user and select the **Security credentials** tab; from there, scroll
    down to **Access Keys** and click the **Create access** **key** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the list of `For use with Learn Ansible` for the description tag value and
    then click **Create** **access key**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Retrieve access keys** page is the only time you get access to the Secret
    access key, so I recommend downloading the CSV file. Once downloaded, click on
    **Done**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The CSV file you have just downloaded contains credentials allowing whoever
    has them to launch resources in your AWS account; please do not share them and
    keep them safe, as they could be misused, resulting in a huge and unexpected AWS
    bill should they fall into the wrong hands.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an access key ID and secret access key for a user with the
    permissions, we need to launch our VPC using Ansible; we can start getting Ansible
    ready and reviewing the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ansible ready for targeting AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first need to discuss how to pass our access key ID and secret access key
    to Ansible safely and securely. As I will share the final playbooks in a public
    repository on GitHub, I want to keep my AWS keys private from the world as that
    could get expensive! Typically, if it were a private repository, I would use Ansible
    Vault or some other secret management to encrypt the keys and include them with
    other potentially sensitive data, such as deployment keys.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I don’t want to include any encrypted information in the repository,
    as it would mean that people would need to unencrypt it, edit the values, and
    then re-encrypt it. Luckily, the AWS modules allow you to set two environment
    variables on your Ansible controller; those variables will then be read as part
    of the playbook execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the variables, run the following commands to make sure that you replace
    the content with your access key and secret after `=` (the information listed
    as follows is just placeholder values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once set, you can view the contents by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can securely pass our credentials to Ansible, we can install the
    Python modules needed by the AWS Ansible modules to interact with the AWS API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You must set the environment variables for each terminal session, as they will
    be lost each time you close your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Python modules, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the basics configured, we can review our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the start of the chapter, we are going to be using some more
    advanced techniques when it comes to deploying resources in AWS where possible;
    I have tried to allow the resources to be deployed as dynamically as possible,
    a lot of which comes down to how we define our variables, which is where we are
    going to start our playbook review.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the variables we define can be found in `group_vars/common.yml`, and
    as you can see from the following, they start by looking a lot like the variables
    we described in [*Chapter 9*](B21620_09.xhtml#_idTextAnchor411), *Moving to* *the
    Cloud*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have the same `debug_output` feature flag and selection of
    variables used to describe our app and the AWS region in which it will be launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have the resource names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too out of the ordinary so far, but here we will find our first difference
    in approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, that doesn’t look too dissimilar to what we did for Microsoft
    Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you might have noticed that there are no IP address CIDR ranges listed
    for the subnets, just some details about the subnets, including a dictionary of
    roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will look at why the subnet’s CIDR ranges are missing when we get to the
    tasks that create the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the variables for creating the security groups; in total, we
    will be configuring four security groups, so in the interest of space, I will
    only be showing one of the small groups here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'See the GitHub repo for the full configuration for the four security groups;
    there is only one thing at this point to highlight, and that is this: where we
    reference `{{ ec2_group_id | default('''') }}`, we are setting a default value
    of nothing (which is the `''''` part). We will discuss why we are doing this when
    we cover the security role.'
  prefs: []
  type: TYPE_NORMAL
- en: The final set of variables is the dictionary (`playbook_dict`) and a variable,
    which sets the value of `region` using `app.region`; again, see the GitHub if
    you want to see all the contents.
  prefs: []
  type: TYPE_NORMAL
- en: The VPC role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get to the exciting tasks, we need to create the VPC. The task in
    `roles/vpc/tasks/main.yml` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The task is pretty much as you would expect, apart from the tags being set
    a little more in line than those we defined in [*Chapter 9*](B21620_09.xhtml#_idTextAnchor411),
    *Moving to the Cloud*. There is also a debug statement that prints the results
    of creating the VPC if you set `debug_output` to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From now on, it is safe to assume that all registered output will be followed
    by an `ansible.builtin.debug` task. Now that we have our VPC launched, we can
    start putting things inside it, beginning with the subnets, where things get more
    interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The subnets role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the AWS overview, there are 32 geographic regions and, at the
    time of writing, 102 Availability Zones. AWS differs from Microsoft Azure in that
    you need a subnet per Availability Zone rather than a single subnet spanning all
    the availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: The `eu-west-1` region, which is the region we will target, is made up of three
    availability zones, and we have subnets for four different roles, meaning that
    we need 12 subnets in total, but our playbook could easily be targeting a region
    that only has two availability zones, or in some cases, even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our first task is to get information on the availability zones in our target
    region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know some information on the region, we can use that information
    and create our subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This task is quite different from the ones we have been using so far in the
    book, so let’s take a deeper dive into what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using a loop to automate the creation of multiple subnets. Each
    iteration of the loop processes one subnet from the `vpc.subnets` list, which,
    as we have already seen, contains the configuration details for each subnet.
  prefs: []
  type: TYPE_NORMAL
- en: As the loop runs, it assigns the current subnet’s details to the `subnet_item`
    variable and its index in the list to `subnet_index`. These variables are then
    utilized to customize the creation process for each subnet.
  prefs: []
  type: TYPE_NORMAL
- en: The task includes and executes the steps defined in `create_subnet.yml` (which
    we will cover next) for each subnet, using the specific details of that subnet
    (such as its name and role).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we still haven’t passed in any CIDR ranges for the
    subnets; this is all handled within the `create_subnet.yml` task, which we loop
    over for each of our four subnet types; this is also where a second loop happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Please stick with me, as this is where it gets a little confusing; for each
    of the four loops we are enacting from our main loop, we are taking the information
    on the availability zones and then looping over them, creating a subnet per availability
    zone for the role we are currently looping over.
  prefs: []
  type: TYPE_NORMAL
- en: So, what about the CIDR range for the subnet?
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed something where you would expect to see the CIDR range;
    we have this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following components in the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vpc_output.vpc.cidr_block`: This is the CIDR block of the VPC, within which
    the subnets will be created. For our example, it’s `10.0.0.0/22`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vpc.subnet_size`: This specifies the size of each subnet. We are using `/27`,
    representing a subnet with 32 IP addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`az_zones_from_main.availability_zones|length`: This is the total number of
    availability zones available. The region we are targeting has `3` availability
    zones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`az_loop_index`: This is the current index in the loop over the availability
    zones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subnet_index`: This is the index of the current subnet being processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that for our expression, we will get the following results. The
    first subnet, which is labeled `az1`) will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`az_loop_index = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subnet_index = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the formula would be `0+(0*3)=0`, meaning that we would get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With `vpc_output.vpc.cidr_block` being `10.0.0.0/22`, we could get the first
    `/27`, which would be `10.0.0.0/27`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second availability zone (`az2`), the loop would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`az_loop_index = 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subnet_index = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1+(0*3)=1` means we would get `10.0.0.32/27` since the next subnet block starts
    immediately after the previous one at the next 32 IP address interval.'
  prefs: []
  type: TYPE_NORMAL
- en: The third Availability Zone (`az3`) would be `2+(0*3)=2`, and the CIDR block
    would be `10.0.0.64/27`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next subnet role, which is the RDS role, would give the following for `az1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`az_loop_index = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subnet_index = 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The formula would be `0+(1*3)=3`, giving us a CIDR block `10.0.0.96/27`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern would follow the sequence, where the next subnet for RDS `az2`
    would be at `10.0.0.128/27`, and for `az3`, it would be at `10.0.0.160/27`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: This expression ensures that each subnet created within the VPC is assigned
    a unique and non-overlapping CIDR block, segmented adequately according to the
    defined subnet size, and distributed across different availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this approach not only simplifies the management of subnet creation but
    also ensures efficiency when it comes to writing the role, as it means that we
    don’t have to hardcode tasks to consider changes between regions or the number
    of subnets we are defining in our variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining tasks in the role build a list of the subnet IDs for each of
    the roles we have defined. An example of one of these tasks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This gets information on the three subnets assigned the `subnet_role_compute`
    role. A few more of these data-gathering tasks can be found in the repo; these
    cover the `subnet_role_database`, `subnet_role_storage`, and `subnet_role_public`
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the final task in the role prints the subnet IDs that we have gathered
    using the previous set of tasks; this looks slightly different to the debug statements
    we have been using in the playbook so far, as we are using the `msg` function
    rather than the `var` one when calling the `ansible.builtin.debug` module.
  prefs: []
  type: TYPE_NORMAL
- en: The gateway role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The gateway role is relatively simple compared to the previous one. In comparison,
    it deploys an internet gateway. Then, it creates a route to send all traffic destined
    for the internet (represented by using `0.0.0.0/0`, the CIDR notation for all
    network traffic) to our newly launched internet gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task that creates the internet gateway looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the rest of the tasks, a debug task follows this, and then the task
    that creates the route table, which is then associated with our newly created
    internet gateway and also the computing and public subnets that we defined and
    gathered the information for in the subnet’s role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then do a debug task that completes this role, and we then move on to the
    final role of the playbook: the security group’s role.'
  prefs: []
  type: TYPE_NORMAL
- en: The security group’s role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this role, in my opinion, is not as complicated as the subnet’s role,
    we have built a little more logic into the task than some of the more straightforward
    tasks in the book that we have run so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, earlier in the chapter, when we covered the variables being
    used by the playbook, we gave the following example of the security groups being
    deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding rule, as per `rule_desc`, opens up port `3306` for any devices
    that have the EC2 security group attached to them, which, as we will see in [*Chapter
    11*](B21620_11.xhtml#_idTextAnchor501), *Highly Available Cloud Deployments*,
    will be the EC2 instances that will be running our workload.
  prefs: []
  type: TYPE_NORMAL
- en: You may think to yourself, *“Now that makes sense.”* However, this is a little
    bit of a flaw in the logic we must work around. `ec2_group_id` is referencing
    a group ID, which, at the time we first run our playbook, doesn’t exist. So, how
    can we create the groups and populate them with rules that reference groups that
    don’t yet exist?
  prefs: []
  type: TYPE_NORMAL
- en: As we have already seen, looping over the resources defined in our variables
    is more efficient. It reduces the hard-coded logic at the role level, making the
    role more re-useable between projects and playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the logic of creating the groups, we need to gather one bit
    of information: the public IP address of the resource running Ansible. To do this,
    we call the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we set a fact called `your_public_ip`, which we can reference in our rules
    where needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have that snippet of information, we can return to the question
    of how we can reference the IDs of resources that have yet to be launched.
  prefs: []
  type: TYPE_NORMAL
- en: To create the security groups, we will be using the `amazon.aws.ec2_security_group`
    module. The module has a flag called `purge_rules`, set to `true` by default;
    in this default state, when our playbook finds and needs to update an existing
    security group, it will drop all the rules in the group and then add just the
    ones defined in the playbook to maintain a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is a valid use case, in our example, disabling this functionality
    by setting `purge_rules` to `false` will allow us to create some unpopulated security
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will loop through and create the base, unpopulated security groups if they
    don’t exist, and if they do already exist, no changes will be made to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we have our groups created, or if they already exist, we have
    the information we need to dynamically define some facts based on the output of
    the previous tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This task uses the `ansible.builtin.set_fact` module, allowing the creation
    or update of new variables during runtime. This task aims to extract the unique
    ID of each security group created in the first task and assign it to a specific
    variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two expressions we use to do this. The first is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used to create the dynamic set of variables based on the loop created
    by the second expression. A breakdown of this first expression follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base_security_groups_output.results`: This refers to the list of results from
    the previous task that created the security groups. Each result in this list contains
    data about one of the security groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectattr(''item.name'', ''equalto'', item.name)`: The `selectattr` filter
    is used to search through the list of results. It looks for results where the
    name attribute of the item (each security group) is equal to the current `item.name`
    in the loop. In other words, it filters the results to find the specific security
    group we’re currently interested in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map(attribute=''group_id'')`: The `map` filter is then used to transform the
    filtered list of results. It extracts only the `group_id` attribute from each
    result, which is the ID of the security group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first`: Since the previous step can still return a list (albeit with a single
    element), the `first` filter takes only the first element from this list, which
    should be the unique ID of the security group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of this expression is the ID of the security group that matches the
    current item in the loop, and it’s assigned to a variable named according to `item.id_var_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second expression, which is in the `when` condition, runs as part of the
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression determines whether the task should be executed for a particular
    item in the loop. It follows a similar logic to the first expression:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts with the same filtering process to find the security group that matches
    the current `item.name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After extracting the `group_id`, it ensures the output is treated as a list
    using the `list` filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length > 0`: This part checks whether the length of the list (the number of
    items in it) is greater than `0`. This means at least one security group with
    the specified name must exist. If the list is empty, no matching security group
    is found, and the task will be skipped for the current item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In theory, we should have now populated the variables that contain the security
    group IDs, meaning that we can now add the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will loop over the already created groups and populate the rules for each
    one, using the group IDs from the variables we dynamically defined in the previous
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Running the playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we worked our way through the playbook code; before you
    run the playbook, you must set the `AWS_ACCESS_KEY` and `AWS_SECRET_KEY` environment
    variables on your terminal session by running the following, making sure to update
    any values to those that you made a note of when you created the Ansible user
    in the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the environment variables set, you can run the playbook running the now
    very familiar following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once completed, you should see something like the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Running the playbook in a terminal](img/B21620_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Running the playbook in a terminal
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to the VPC and viewing the resource map in [http://console.aws.amazon.com/](http://console.aws.amazon.com/)
    should display something like the following resource map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Viewing the resource map](img/B21620_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Viewing the resource map
  prefs: []
  type: TYPE_NORMAL
- en: 'By going to **Security Groups**, you should also see the groups that we created
    listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Reviewing the security groups](img/B21620_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Reviewing the security groups
  prefs: []
  type: TYPE_NORMAL
- en: 'I have included a second playbook in the repo, which destroys all of the resources
    created by running the `site.yml` playbook called `destroy.yml`. You can run it
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I am not going to cover the contents of the playbook here, but if you review
    the code, you will notice that, in essence, it runs the same tasks in the role
    we have covered in this chapter in reverse order, setting the state to `absent`
    rather than `present`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken our next step in using Ansible to launch resources
    in a public cloud. We have laid the groundwork for automating quite a complex
    environment by creating a VPC, setting up the subnets we need for our application,
    provisioning an internet gateway, and setting our instances to route their outgoing
    traffic through it.
  prefs: []
  type: TYPE_NORMAL
- en: We have configured four security groups, with three containing dynamic content,
    to secure the services launching into our VPC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on the foundations laid in this chapter and
    launch a more complex set of services alongside the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Details of the AWS Q3 2023 earnings** **call**: [https://www.cnbc.com/2023/10/26/aws-q3-earnings-report-2023.html](https://www.cnbc.com/2023/10/26/aws-q3-earnings-report-2023.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
