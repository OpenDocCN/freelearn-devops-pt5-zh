- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter of *Mastering Git* presents a collection of generic and Git-specific
    version control recommendations and best practices. You have encountered many
    of these recommendations already in the earlier chapters; they are here as a summary
    and as a reminder. For details and the reasoning behind each best practice, refer
    to the specific chapters.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover the issues of managing the working directory, creating
    commits and series of commits (pull requests), submitting changes for inclusion,
    and the peer review of changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to separate projects into repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What types of data to store in a repository and which files Git should ignore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to check before creating a new commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a good commit and a good commit series (or, in other words, how
    to create a good pull request)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose an effective branching strategy, and how to name branches and
    tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to review changes and how to respond to the review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When starting a project, you should choose and clearly define a project governance
    model (who manages work, who integrates changes, and who is responsible for what).
    You should decide about the license and the copyright of the code: whether it
    is work for hire and whether contributions require a copyright assignment, a contributor
    agreement, a contributor license agreement, or simply a digital certificate of
    origin.'
  prefs: []
  type: TYPE_NORMAL
- en: Dividing work into repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In centralized version control systems, often everything is put under the same
    project tree. With distributed version control systems such as Git, it very much
    depends on the nature of the project. Often, it is better to split separate projects
    into separate repositories, but if those projects are tightly coupled together
    it might be better to use a **monorepo** – all projects in a single large repository.
  prefs: []
  type: TYPE_NORMAL
- en: If some part of the code is needed by multiple separate projects, consider extracting
    it into its own project and then incorporating it as a submodule or subtree, grouping
    concepts into a superproject. See [*Chapter 11*](B21194_11.xhtml#_idTextAnchor270),
    *Managing Subprojects*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the collaboration workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to make decisions on the collaboration structure, whether your project
    will use a dispersed contributor model, a “blessed” repository model, or a central
    repository, and so on (as found in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development* *with Git*).
  prefs: []
  type: TYPE_NORMAL
- en: This often requires setting up an access control mechanism and deciding on the
    permission structure; see [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349)*, Git
    Administration*, for details on how one can set up this.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to decide on the branching patterns to use. See [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*, for examples of the most common patterns. You
    need to decide how to integrate changes, and how to isolate independent work.
    Those branching patterns are often grouped together into a single named branching
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: This decision about branching doesn’t need to be cast in stone. As your project
    and your team experience grow, you might want to consider changing the branching
    model, for example, from the trunk-based workflow to a plain branch-per-feature
    model, a GitHub flow, or any of the other derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: The decisions about licensing, the collaboration structure, and the branching
    model should all be stated explicitly in the developer documentation (at a minimum
    in the `README` and `LICENSE`/`COPYRIGHT` files, and perhaps also in `CodingGuidelines`
    and `CodeOfConduct`). You need to remember that if the way in which the project
    is developed changes, this documentation needs to be updated to reflect the changes.
    This can happen, for example, because the project has grown beyond its initial
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing which files to keep under version control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, you should not include any of the **generated files** in the
    version control system (though there are some very rare exceptions). You should
    track only the sources (the original resources); Git works best if these sources
    are plain text files, but it also works well with binary files.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid accidentally including unwanted files in a repository, you should use
    the `.gitignore` file in the project tree; those specific to the developer (for
    example, backup files created by the editor one uses or the operating system-specific
    helper files) should go into their per-user `core.excludesFile` (which, in modern
    Git, is the `~/.config/git/ignore` file), or into a local configuration of the
    specific clone of the repository, that is, `.git/info/excludes`. See [*Chapter
    3*](B21194_03_split_000.xhtml#_idTextAnchor049), *Managing Your* *Worktrees*,
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: A good start for ignore patterns is the [https://gitignore.io](https://gitignore.io)
    site with its `.gitignore` templates for various operating systems, IDEs, and
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Another suggestion is to not add to Git the configuration files that might change
    from environment to environment (for example, those that are different for MS
    Windows and Linux).
  prefs: []
  type: TYPE_NORMAL
- en: Working on a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some guidelines on how to create changes and develop new revisions.
    These guidelines can be used either for your work on your own project, or to help
    contribute your code to a project maintained by somebody else.
  prefs: []
  type: TYPE_NORMAL
- en: Different projects can use different development workflows; therefore, some
    of the recommendations presented here might not make sense depending on the given
    workflow in use.
  prefs: []
  type: TYPE_NORMAL
- en: Working on a topic branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Branching in Git has two functions ([*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*): as a mediator for the code contributed by developers
    keeping to the **specified level of code stability and maturity** (long-running
    public branches), providing the road to integration and deployment, and as a **sandbox
    for the development of a new idea** (short-lived private branches).'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to sandbox changes is why it is considered a good practice to create
    a separate branch for each new task you work on. Such a branch is called a topic
    branch or a feature branch. Using separate branches makes it possible to switch
    between tasks easily, and to keep disparate pieces of work in progress from interfering
    with each other. On the other hand, if such branches are long-lived, it would
    go against **c****ontinuous integration** (**CI**) practices, reduce changeset
    visibility, and lead to more difficult integration because of larger divergence.
  prefs: []
  type: TYPE_NORMAL
- en: You should choose short and descriptive names for branches. There are different
    naming conventions for topic branches; the convention your project uses should
    be specified in the developer documentation. In general, branches are usually
    named with a summary of a topic they host, usually in all-lowercase and with the
    spaces between words replaced by hyphens or underscores (see the `git-check-ref-format`
    manpage to know what is forbidden in branch names). Branch names can include slashes
    (be hierarchical).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an issue tracker, then a branch that fixes a bug or implements
    an issue can have its name prefixed with the identifier (the number) of the ticket
    describing the issue, for example, `1234-doc_spellcheck`. On the other hand, the
    maintainer, while gathering submissions from other developers, could put these
    submissions in topic branches named after the initials of the developer and the
    name of the topic, for example, `ad/whitespace-cleanup` (this is an example of
    a **hierarchical** **branch name**).
  prefs: []
  type: TYPE_NORMAL
- en: It is considered a good practice to delete your topic branch from your local
    repository, and also from the upstream repository after you are done with the
    branch in question, to reduce clutter.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to base your work on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, you are usually working on some specific issue at a given time,
    be it a bug fix, an enhancement, a correction to some topic, or a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Where to start your work on a given topic, and what branch to base your work
    on, both depend on the branching workflow chosen for the project (see [*Chapter
    8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching Techniques*,for
    a selection of branching workflows). This decision also depends on the type of
    work you do.
  prefs: []
  type: TYPE_NORMAL
- en: For a topic branch workflow (or a branch-per-feature workflow), you would want
    to base your work on the oldest and most stable long-running branch that your
    change is relevant to, and for which you plan to merge your changes into. This
    is because, as described in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*, you should **never merge** a **less stable branch
    into** a **more stable branch**. The reason behind this best practice rule is
    to avoid destabilizing the branch as merging carries over all the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of changes require a different long-lived branch to be used
    as a base for a topic branch with those changes, or to put those changes onto.
    In general, to help developers working on a project, this information should be
    described in the developer documentation; not everybody needs to be knowledgeable
    about the branching workflow used by the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes what is usually used as a base branch, depending on
    the purpose of the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bugfix**: In this case, the topic branch (the bugfix branch) should be based
    on the oldest and the most stable branch in which the bug is present. This means,
    in general, starting with the maintenance branch. If the bug is not present in
    the maintenance branch, then base the bugfix branch on the stable branch. For
    a bug that is not present in the stable branch, find the topic branch that introduced
    it and base your work on top of that topic branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New feature**: In this case, the topic branch (the feature branch) should
    be based on the stable branch, if possible. If the new feature depends on some
    topic that is not ready for the stable branch, then base your work on that topic
    (from a topic branch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corrections and enhancements to a topic that didn’t get merged into the stable
    branch should be based on the tip of the topic branch being corrected. If the
    topic in question is not considered published, it’s alright to make changes to
    the steps of the topic, squashing minor corrections in the series (see the section
    about rewriting history in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247)*,
    Keeping* *History Clean*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the project you are contributing to is large enough to have dedicated maintainers
    for selected parts (subsystems) of the system, you first need to decide which
    repository and fork (sometimes named “a tree”) to base your work on.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting changes into logically separate steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless your work is really simple and can be done in a single step (a single
    commit)—as is the case with many bugfixes—you should make separate commits for
    logically separate changes, one commit per single step. Those commits should be
    ordered logically.
  prefs: []
  type: TYPE_NORMAL
- en: Following good practice for commit messages (with an explanation of what you
    have done—see the next section) could help in deciding when to commit. If your
    description gets too long and you begin to see that you have two independent changes
    squashed together, that’s a sign that you probably need to split your commit into
    finer-grained pieces and use smaller steps.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, however, that it is a matter of balance between the project conventions
    and the development workflow chosen. Changes should, at a minimum, stand on their
    own. At each step (at each commit) of the implementation of a feature, the code
    compiles and the program passes the test suite. You should `git bisect` (which
    is described in [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring* *Project
    History*).
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don’t necessarily need to come up with the perfect sequence of
    steps from the start. If you notice that you have entangled the work directory’s
    state, you can make use of the staging area, using an interactive add to disentangle
    it (this is described in [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028)*, Developing
    with Git,* and [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049)*, Managing
    Your* *Worktrees*). You can also use an interactive rebase or a similar technique,
    as shown in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247)*, Keeping
    History Clean*, to curate commits into an easy-to-read (and easy-to-bisect) history
    before publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should remember that a commit is a place to record your result (or a particular
    step towards the result), not a place to save the temporary state of your work.
    If you need to temporarily save the current state before going back to it, use
    **git stash**.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a good commit message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good commit message should include an explanation for the change with sufficient
    detail so that other developers on the team (including reviewers and the maintainer)
    can judge whether it is a good idea to include the change in the codebase. This
    good-or-not decision should not require them to read the actual changes to find
    out what the commit intends to do.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the commit message should be a short, terse description (from
    around 50 to 72 characters) with a summary of the changes. It should be separated
    by an empty line from the rest of the commit message, if there is one. This is
    partly because, in many places, such as in the `git log --oneline` command output,
    in a graphical history viewer such as `gitk`, and in the instruction sheet of
    `git rebase --interactive`, you will see only this one line of the commit message
    and have to decide the action with respect to that commit on the basis of this
    one line. If you have trouble with coming up with a good summary of changes, this
    might mean that these changes need to be split into smaller steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various conventions for this summary line of changes. One convention
    is to prefix the first summary line with **area:**, which is an identifier for
    the general area of the code being modified: the name of the subsystem, of an
    affected subdirectory, or a filename of a file being changed. If the development
    is managed via an issue tracker, this summary line can start with something like
    the **[#1234]** prefix, where **1234** is the identifier of an issue or task implemented
    in the commit. In general, when not sure about what information to include in
    the commit message, refer to the development documentation or fall back to the
    current convention used by other commits in the history.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are using agile development methods, you can look for especially good
    commit messages during retrospectives and add them as examples to the developer
    documentation for the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all but trivial changes, there should be a longer meaningful description,
    the body of the commit message. There is something that people coming from other
    version control systems might need to unlearn: namely, not writing a commit message
    at all or writing it all on one long line. Note that Git will not allow the creation
    of a commit with an empty commit message unless forced to with `--allow-empty`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The commit message should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the rationale for the commit, explaining the problem that the commit
    tries to solve – the *why*, in other words. It should include a description of
    what is wrong with the current code or the current behavior of the project without
    the change. This should be self-contained, but it can refer to other sources including
    the issue tracker (the bug tracker) or other external documents such as articles,
    wikis, or **Common Vulnerabilities and** **Exposures** (**CVEs**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a quick summary. In most cases, it should also explain the *how* and
    justify the way the commit solves the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe why you think the result with the change is better; this part of the
    description does not need to explain what the code does, as that is largely a
    task for the code comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there was more than one possible solution, include a description of the alternative
    solutions that were considered but ultimately discarded, perhaps with links to
    the discussion or review(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s a good idea to try to make sure that your explanation of the changes can
    be understood without access to any external resources (that is, without accessing
    the issue tracker, the internet, or a mailing list archive). Instead of just referring
    to the discussion, or in addition to giving a URL or an issue number, write a
    summary of the relevant points in the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: One of the possible recommendations when writing a commit message is to describe
    changes in the imperative mood, for example, **make foo do bar**, as if you are
    giving orders to the codebase to change its behavior, instead of writing **This
    commit makes...** or **[I]** **changed ...**.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `commit.template` and commit message hooks can help in following these
    practices. see[*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320), *Customizing
    and Extending Git*, for details (and [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349),
    *Git Administration*, for a description of the way to enforce this recommendation).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing changes for submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the topic branch was started a long time ago, consider rebasing the branch
    to be submitted on top of the current tip of the base branch. This should make
    it easier to integrate changes in the future. If your topic branch was based on
    the development version, or on the other in-flight topic branch (perhaps because
    it depended on some specific feature), and the branch it was based on got merged
    into a stable line of development, you should rebase your changes on top of the
    stable integration branch instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebasing is also a chance for a final clean-up of the history; the chance to
    make submitted changes easier to review. Simply run an interactive rebase with
    `git rebase --interactive`, or a patch management tool if you prefer (see [*Chapter
    10*](B21194_10_split_000.xhtml#_idTextAnchor247), *Keeping History Clean*). One
    caveat: **do not rewrite the** **published history**.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider testing that your changes merge cleanly, and fix it if they don’t (if
    possible). Make sure that they apply or merge cleanly into the appropriate integration
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: Take a last look at your commits to be submitted. Make sure that your changes
    do not add the commented-out (or the ifdef-ed-out) code, nor any extra files not
    related to the purpose of the patch (for example, changes in an upcoming feature).
    Review your commit series before submission to ensure accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exact details on how to submit changes for merging depends, of course, on
    the development workflow that the project is using. Various classes of possible
    workflows are described in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative
    Development* *with Git.*
  prefs: []
  type: TYPE_NORMAL
- en: Submitting and describing changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the project has a dedicated maintainer or, at least someone responsible for
    merging the proposed changes into the official version, you also need to describe
    the submitted changes as a whole (in addition to describing each commit in the
    series). This can be done in the form of a cover letter for the patch series while
    sending changes as patches via email. It can also be done with comments in the
    pull request while using the collocated contributor repositories model, or it
    can be the description in an email with a pull request, which already includes
    the URL and the branch in your public repository with changes (generated with
    `git request-pull`).
  prefs: []
  type: TYPE_NORMAL
- en: This cover letter or pull request should include a description of the purpose
    of the patch series or the pull request. Consider also providing an overview of
    why the work is taking place (with any relevant links and a summary of the discussion).
    Be explicit in stating that it is a work in progress in the description of changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the dispersed contributor model, where changes are submitted for review as
    patches or patch series, usually to a mailing list, you should use Git-based tools
    such as `git format-patch` and, if possible, `git send-email`. Multiple related
    patches should be grouped together, for example, in their own email thread. The
    convention is to send them as replies to an additional cover letter message, which
    should describe the feature as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: If the changes are sent to the mailing list, it is a common convention to prefix
    your subject line with `[PATCH]` or `[PATCH m/n]` (where `m` is the patch number
    in the series of the `n` patches). This lets people easily distinguish patch submissions
    from other emails. This part can be done with `git format-patch`. What you need
    to decide yourself is whether to use additional markers after `PATCH` to mark
    the nature of the series, for example, `PATCH/RFC`. (**RFC** here means **Request
    For Comments**, i.e., an idea for a feature with an example of its implementation.
    Such a patch series should only be examined if the idea is worthy; it is not ready
    to be applied/merged yet and is provided only for discussion among the developers.)
  prefs: []
  type: TYPE_NORMAL
- en: In the collocated contributor repositories model, where all the developers use
    the same Git hosting website or software (for example, GitHub, Bitbucket, GitLab,
    or a private instance of it), you would push changes to your own public repository,
    a fork of the official version. Then, you would create a merge request or pull
    request, usually via the web interface of the hosting service, again describing
    the changes as a whole there.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of using the central repository (perhaps in a shared maintenance
    model), you would push changes to a separate and possibly new branch in the integration
    repository, and then send an announcement to the maintainer so that they can find
    the changes to merge. The details of this step depend on the exact setup; sending
    announcements might be done via email, some kind of internal messaging mechanism,
    or even via tickets (or the comments in the tickets).
  prefs: []
  type: TYPE_NORMAL
- en: The development documentation might include rules specifying where to send announcements
    and/or changes. It is considered a courtesy to notify the people who are involved
    in the area of code you are changing about the new changes (you can use `git blame`
    and `git shortlog` to identify these
  prefs: []
  type: TYPE_NORMAL
- en: people; see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project
    History*). These people are important; they can write comments about the change
    and help review it.
  prefs: []
  type: TYPE_NORMAL
- en: Crediting people and signing your work
  prefs: []
  type: TYPE_NORMAL
- en: 'Some open source projects, in order to improve the tracking provenance of the
    code, use the sign-off procedure borrowed from the Linux kernel called **Digital
    Certificate of Origin**. The sign-off is a simple line at the end of the commit
    message, like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signed-off-by: Random** **Developer <rdeveloper@company.com>**'
  prefs: []
  type: TYPE_NORMAL
- en: By adding this line, you certify that the contribution is either created as
    a whole or in part by you, or is based on previous work, or was provided directly
    to you, and that everybody in the chain has the right to submit it under the appropriate
    license. If your work is based on work by somebody else, or if you are just passing
    somebody’s work, then there can be multiple sign-off lines forming a chain of
    provenance.
  prefs: []
  type: TYPE_NORMAL
- en: In order to credit people who helped with creating the commit, you can append
    to the commit message other trailers, such as **Reported-by:**, **Reviewed-by:**,
    **Acked-by:** (this one states that it was liked by the person responsible for
    the area covered by the change), or **Tested-by:**.
  prefs: []
  type: TYPE_NORMAL
- en: The art of the change review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Completing a peer review of changes is time-consuming (although so is using
    version control), but the benefits are huge: better code quality, a reduction
    in the time needed for quality assurance testing, transfer of knowledge, and so
    on. The change can be reviewed by a peer developer, reviewed by a community (requiring
    consensus), or reviewed by the maintainer or one of their lieutenants.'
  prefs: []
  type: TYPE_NORMAL
- en: Before beginning the code review process, you should read through the description
    of the proposed changes to discover why the change was proposed and decide whether
    you are the correct person to perform the review (that is one of the reasons why
    good commit messages are so important). You need to understand the problem that
    the change tries to solve. You should familiarize yourself with the context of
    the issue, and with the code in the area of changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to reproduce the state before the change and check whether
    the program works as described (for example, that the bug in a bugfix can be reproduced).
    Then, you need to check out the topic branch with the proposed changes and verify
    that the result works correctly. If it works, review the proposed changes, creating
    a comprehensive list of everything wrong (though if there are errors early in
    the process, it might be unnecessary to go deeper), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Are the commit messages descriptive enough? Is the code easily understood?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the contribution architected correctly? is it architecturally sound?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the code comply with the project’s coding standards and with the agreed-upon
    coding conventions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the changes limited to the scope described in the commit message?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the code follow the industry’s best practices? Is it safe and efficient?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there any redundant or duplicate code? Is the code as modular as possible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the code introduce any regressions in the test suite? If it is a new feature,
    does the change include the tests for the new feature, both positive and negative?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the new code performing the way it did before the change (within the project’s
    tolerances)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are all the words spelled correctly, and does the new version follow the formatting
    guidelines for the content?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is only one possible proposal for such a code review checklist. Depending
    on the specifics of the project, there might be more questions that need to be
    asked as a part of the review; make the team write their own checklist. You can
    find good examples online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Divide the problems that you have found during reviews into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrong problem**: This feature does not lie within the scope of the project.
    It is sometimes used for a bug that cannot be reproduced. Is the idea behind the
    contribution sound? If so, eject the changes with or without prejudice and do
    not continue the analysis for the review.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Does not work**: This does not compile, introduces a regression, doesn’t
    pass the test suite, doesn’t fix the bug, and so on. These problems absolutely
    must be fixed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fails best practices**: This does not follow the industry guidelines or the
    project’s coding conventions. Is the contribution polished? These are pretty important
    to fix, but there might be some nuances as to why it is written the way it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Does not match** **reviewer preferences**. In this case, you should suggest
    modifications, or alternatively ask for clarification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minor problems, for example, typos or spelling errors, can be fixed immediately
    by the reviewer. If the exact problem repeats itself, however, consider asking
    the original author for a fix and resubmission; this is done to spread knowledge.
    You should not be making any substantive edits in the review process (barring
    extenuating circumstances).
  prefs: []
  type: TYPE_NORMAL
- en: Ask, don’t tell. Explain your reasoning about why the code should be changed.
    Offer ways to improve the code. Distinguish between facts and opinions.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to reviews and comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changes are not always accepted on the first try. You can and will get suggestions
    for improvement (and other comments) from the maintainer, the code reviewer, and
    other developers. You might even get these comments in the patch form or a fixup
    commit form.
  prefs: []
  type: TYPE_NORMAL
- en: First, consider leading your response with an expression of appreciation for
    the commenter having taken the time to perform a review. If anything in the review
    is unclear, do ask for clarification; if there is a lack of understanding between
    you and the reviewer, offer clarification.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is often to polish and refine the changes. Then, you should resubmit
    them (perhaps, marking them as **v2**). You should respond to the review for each
    commit and for the whole series.
  prefs: []
  type: TYPE_NORMAL
- en: If you are responding to comments in a pull request, reply in the same way.
    In the case of patch submissions via email, you can put the comments for a new
    version (with a response to the review or a description of the difference from
    the previous attempt), either between three dashes `diffstat`, or at the top of
    an email separated from what is to be in the commit message by a “scissors” line,
    for example, `git` `format-patch --notes`.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the project’s governance structure, you will likely have to wait
    for the changes to be considered good and ready for inclusion. This can be the
    decision of a benevolent dictator for life in open source projects, or the decision
    of the team leader, a committee, or a consensus. It is considered a good practice
    to summarize the discussion while submitting a final version of a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Note that changes that have been accepted might nevertheless go through a few
    more stages before finally graduating to the stable branch and being present in
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Other recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will find the best practices and recommendations that do
    not fit cleanly into one of the areas described so far, namely starting a project,
    working on a project, and integrating changes.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t panic, recovery is almost always possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As long as you have committed your work and stored your changes in the repository,
    it will not be lost. It could only perhaps be misplaced. Git also tries to preserve
    your current uncommitted (unsaved) work, but it cannot distinguish for example
    between the accidental and the conscious removal of all the changes to the working
    directory with `git reset --hard`. Therefore, make sure to commit or stash your
    current work before trying to recover lost commits.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the reflog (both for the specific branch and for the `HEAD` ref),
    it is easy to undo most operations. Then, there is the list of stashed changes
    (see [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049), *Managing Your*
    *Worktrees*), where your changes might be hiding. And there is `git fsck` as the
    last resort. See [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349), *Git Administration*,
    for some further information about data recovery.
  prefs: []
  type: TYPE_NORMAL
- en: If the problem is that you have made a mess of the working directory, stop and
    think. Do not drop your changes needlessly. With the help of interactive add,
    interactive reset (the `--patch` option), and interactive checkout (the same),
    you can usually disentangle the mess.
  prefs: []
  type: TYPE_NORMAL
- en: Running `git status` and carefully reading its output helps in many cases where
    you are stuck after doing some lesser-known `git` operation.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a problem with a rebase or merge, and you cannot pass the responsibility
    to another developer, there is always the third-party `git-imerge` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t change the published history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have made your changes public, you should ideally consider those revisions
    to be etched in stone, immutable, and unchanging. If you find problems with commits,
    create a fix (perhaps by undoing the effect of the changes with `git revert`).
    This is all described in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*: that is, unless it is stated explicitly in the development
    documentation that these specific branches can be rewritten or redone; but it
    is nevertheless better to avoid creating such branches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some rare cases, you might really need to change the history: remove a file,
    clean up an unencrypted stored password, remove accidentally added large files,
    and so on. If you need to do it, notify all the developers of the fact.'
  prefs: []
  type: TYPE_NORMAL
- en: Numbering and tagging releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you release a new version of your project, mark the version to be released
    with a signed tag. This ensures the integrity of the just-created revision.
  prefs: []
  type: TYPE_NORMAL
- en: There are various conventions for naming the release tags and using release
    numbering. One of the more common ones is tagging releases by using, for example,
    `1.0.2` or `v1.0.2` as a tag name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If the integrity of the project is important, consider using signed merges for
    integration (that is, merging signed tags). See [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git*, and for signed pushes, see [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349),*Git
    Administration*.
  prefs: []
  type: TYPE_NORMAL
- en: There are different conventions for naming releases. For example, with time-based
    releases, there is the convention of naming releases after dates, such as `2015.04`
    (or `15.04`). Then, there is the common convention of `MAJOR.MINOR.PATCH` numbering,
    where `PATCH` increases when you are making backward-compatible bug fixes, `MINOR`
    is increased when adding functionality that is backward compatible, and the `MAJOR`
    version is increased when making incompatible API changes. Even when not using
    full semantic versioning, it is common to add a third number for maintenance releases,
    for example, `v1.0` and `v1.0.3`.
  prefs: []
  type: TYPE_NORMAL
- en: Automate where possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should not only have the coding standards written down in the development
    documentation; you also need to enforce them. Following these standards can be
    facilitated with client-side hooks ([*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and Extending Git*) and enforced with server-side hooks ([*Chapter
    14*](B21194_14.xhtml#_idTextAnchor349),*Git Administration*).
  prefs: []
  type: TYPE_NORMAL
- en: Hooks can also help by automatically managing tickets in the issue tracker and
    selecting an operation based on given triggers (patterns) in the commit message.
    Hooks can also be used to protect against rewriting the history.
  prefs: []
  type: TYPE_NORMAL
- en: Consider using third-party solutions, such as Gitolite or GitLab, to enforce
    rules for access control. If you need to do a code review, use appropriate tools
    such as Gerrit or the pull requests of GitHub, Bitbucket, or GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These recommendations, based on the best practices of using Git as a version
    control system, can really help your development and your team. You have learned
    the steps along the road, starting from an idea, going all the way, and ending
    with the changes being integrated into the project. These checklists should help
    you develop better code.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Emma Jane Hogbin Westby: *Git for Teams* (2015), O’Reilly Media'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Git* *Branching* [https://learngitbranching.js.org/](https://learngitbranching.js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conventional Commits: A specification for adding human and machine-readable
    meaning to commit* *messages* [https://www.conventionalcommits.org/](https://www.conventionalcommits.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Commitizen - a release management tool designed for* *teams* [https://commitizen-tools.github.io/commitizen/](https://commitizen-tools.github.io/commitizen/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sage Sharp: *The Gentle Art Of Patch Review* (2014) [https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/](https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dangit,* *Git!?!* [https://dangitgit.com/en](https://dangitgit.com/en)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Julia Evans: *Oh shit, git!* Zine [https://wizardzines.com/zines/oh-shit-git/](https://wizardzines.com/zines/oh-shit-git/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Semantic Versioning* *2.0.0* [https://semver.org/](https://semver.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
