- en: Git Providers, Integrations, and Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an organization at GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a repository at GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding templates for issues and pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GitHub API key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GitHub to authenticate at Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering Jenkins builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jenkinsfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to host your own Git installation and maintain a central server
    for your organization. If you are a small company or an open source project, maintaining
    such an infrastructure can be a burden. But today, there exists a number of Git
    providers who can lift the burden.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub is the best-known Git provider with 40 million users. Many high-profiled
    open source projects are hosted by GitHub. Once you have created an account at
    GitHub, you can explore the 85 million Git repositories currently hosted.
  prefs: []
  type: TYPE_NORMAL
- en: In modern software development, **continuous integration** (**CI**) is popular.
    The idea is that changes from developers are merged into the code base as soon
    as possible. Git's **pull requests** (**PRs**) are a way of doing so. Of course,
    GitHub provides a UI to create PRs and let's collaborators do code reviews. Part
    of a CI policy is also to run all tests automatically. Software like Jenkins can
    be configured to build and test for every commit.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an organization at GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you have a commercial product or an open source project, there is likely
    a company or a group of people behind it. GitHub supports such a structure by
    allowing users to create an organization.
  prefs: []
  type: TYPE_NORMAL
- en: An organization can have repositories associated and it has members. The advantage
    of using an organization is that members might come and go (developers will get
    a new job, and leave), but the repositories will be associated with the organization
    so there will be no need to transfer ownership of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: As a user, you can be a member of multiple organizations. It is common to be
    a member of your employer's organization but also of a number of organizations
    behind open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a user account at GitHub. For this recipe, we will use the GitHub
    user `johndoepackt`. Any user can create an organization.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a GitHub account, it is time to create one. Once you have
    created your account and signed in, you are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an organization is a function under Settings. So, you need to find
    Settings in your GitHub account, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf88d2b4-db69-488f-89d5-d3f270f3462b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One menu item in Settings is Organizations. You can create an organization
    in two different ways. You can either turn your user into an organization or create
    a separate organization. We will create an organization and not turn the user
    into an organization, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/613d523d-0aff-479b-b6a5-0e77edd1fb88.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the organization is created, you can invite users to become members. It
    is also possible to add outside or external collaborators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations at GitHub are a layer on top of Git. They can be seen as a way
    to provide access control to associated repositories.
  prefs: []
  type: TYPE_NORMAL
- en: When GitHub users explore the repositories associated with your organizations,
    they will be subject to the privileges you have set up. This means that you are
    in charge of what you allow others to see.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a paying customer at GitHub, your organization can have private repositories.
    A private repository is only accessible by members of the organization. A company
    can have open source projects or examples as public repositories. But, by using
    a private repository, it is possible to have some company secrets.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each organization has a number of settings that you can tweak. In order to increase
    the security of your organization, you can require that members have to use two-factor
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: You also have access to an audit log for your organization. In many cases, you
    will have to ensure who did what. The audit log can also reveal if someone has
    gained access to your organization and tried to tamper with it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub organizations are a well-documented feature of GitHub. The documentation
    is located at [https://help.github.com/categories/setting-up-and-managing-organizations-and-teams/](https://help.github.com/categories/setting-up-and-managing-organizations-and-teams/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository at GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Git is all about repositories. GitHub provides a UI for creating repositories.
    The UI makes it easier for new Git users to get started. And for obvious reasons,
    GitHub does not give you access to their server directly.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we created an organization at GitHub. In this recipe,
    we will create a repository within the organization. As an individual user (not
    an organization), you can create repositories too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You begin by logging in at GitHub. Before creating the repository, you have
    to make two decisions. First, what should the repository's name be? Second, should
    the repository be public or private?
  prefs: []
  type: TYPE_NORMAL
- en: Private repositories are only visible for members of the organization. But in
    order to create private repositories, you must be a paying customer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are going to create a repository for the organization, you will have
    to switch from your ordinary user to your organization. It''s a dropdown with
    the title Switch dashboard context. Once you have switched context, your screen
    will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0f7c508-0ece-475c-ad6b-69926ffce962.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you are ready to create the repository. You will have to set the name,
    a Description (optional), and decide whether the repository is Public or Private.
    Moreover, GitHub can create `.gitignore`, `LICENSE`, and a simple `README.md`
    for you. Often you will know the main programming language, and a `.gitignore`
    based on best practices can be generated. In the following screenshot, you can
    see all the fields with values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5eaebe29-d75b-4ea5-bf43-73e145a865c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the repository is created, you can clone it on your computer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The screens you went through in the recipe are *Creating a repository at GitHub*
    server. In essence, it is simply creating a directory and running `git init`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the extra files (`.gitignore`, `LICENSE`, and `README.md`) is fairly
    simple too. Setting up a good `.gitignore` takes time, but you get a good starting
    point with the generated one.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub also sets up access control for your repository. Only members of the
    organization have write permissions; that is, they have the rights to commit.
    In the settings of the repository, you can define more precise access control
    under the menu item Collaborators & teams. A team is a group of GitHub users who
    work together. In your company, you might have iOS, Android, and DevOps teams.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a repository at GitHub, code reviews are an integral part of pull requests.
    Let''s update `README.md` and perform a code review at GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now go to GitHub, find your repository and create a pull request. You
    can invite your collaborators to review your changes before they are merged, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f2403ac-af3d-4031-9b13-f3913ab12e48.png)'
  prefs: []
  type: TYPE_IMG
- en: When we created the repository, we had the option to create it as a private
    one. Private repositories are only available for paying customers. From a Git
    perspective, there is no difference between public and private repositories. The
    major difference is who can view a repository. As you might imagine, public repositories
    can be viewed by everybody. You don't even have to log in to GitHub to view a
    public repository. These repositories are ideal for open source projects—and if
    you read GitHub's terms closely, you will see that a public repository is meant
    to be open source.
  prefs: []
  type: TYPE_NORMAL
- en: Private repositories can only be viewed by the users you have given access to.
    Typically, every member of your organization can view private repositories. In
    other words, private repositories are ideal for internal projects or proprietary
    software. Today, many companies are mixing public and private repositories while
    their software developers can fluently move between repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Adding templates for issues and pull requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml), *Enhancing Your
    Daily Work with Git Hooks, Aliases, and Scripts*, we showed how to add templates
    for commits.  A commit template helps the developer to include the relevant information
    in the commit message. At GitHub, users will create issues and pull requests.
    It is up to the issue or pull request creator to write a meaningful description.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explain to you how to add templates for issues and pull requests.
    The purpose is to help people to remember to include enough context for you to
    quickly understand what the issue or pull request is about.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue to use the repository `nomen-rescio` that we created in a previous
    recipe. GitHub is using **Markdown** as a markup language everywhere. Markdown
    is developer friendly since it is plain text with some special conversions for
    typesetting bold, bullet lists, and so on. Going through Markdown might be a complete
    book on its own.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, you will need to find Settings for your repository. There is a big Set
    up templates button which is what you are looking for. You can choose to use one
    of the precanned templates, but we will create a custom one, as shown in the next
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/332195f3-6fd1-4ba3-a646-f101b2a965c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You save the template by clicking on Commit changes. When a user is creating
    an issue, your template will be shown. The user can choose to delete all your
    text but most users will read it before doing so; note the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ef16abf-bd1d-423e-a8c4-9ccc5c8a90e9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your templates live in the repository itself. Actually, you find them in the
    directory `.github`. If you prefer, you can edit a template in your favorite editor
    and commit changes just like any other file.
  prefs: []
  type: TYPE_NORMAL
- en: The directory `ISSUE_TEMPLATE` contains the templates for issues is the file.
    Similar, if you create a file under the directory `PULL_REQUEST_TEMPLATE`, you
    will have a template for pull requests. With multiple templates, the user will
    be asked to choose which template is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub API key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all the work we have performed at GitHub has been manual. Programmers
    like to automate processes, and performing GitHub work is no exception to that
    rule. With the next recipe, we will show you how you can automate tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To automate GitHub tasks you need to be able to access GitHub. Instead of logging
    in using a user name and password, you can use an API key or personal access token.
    Such a token should not be shared, and you need to keep it secret at all times.
  prefs: []
  type: TYPE_NORMAL
- en: So, this recipe begins with generating an access token and shows you a simple
    Python script. The Python script will find all your repositories, and find all
    the pull requests for each repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to generate the personal access token. You will have to drill
    down in the menu system: Settings, Developer settings, and finally, Person access
    token. We will give our token the name `basic-query` since we plan only to do
    that. You can specify what the token has access to. Our token will only need access
    to repository actions, as indicated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2772c873-f590-432f-8746-ee788cc6a08e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you generate the token, it will displayed. You will only see it once at
    GitHub, so it is important to copy it to your computer. In the following screenshot,
    you can see the page with the generated token (except we have added a rectangle
    since we need to keep it a secret):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cfe13a2d-f11c-461b-a03d-9a3a048a7ddb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As already mentioned, we will use Python. You need to install the small library
    PyGitHub. Using Pip, the installation is easy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to run the Python script that will fetch the repositories
    and the pull requests. The script is just iterating over repositories and pull
    requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The token gives you access to GitHub but only the parts that were specified
    when you created the token. Behind the scenes, the methods of PyGitHub are implemented
    as HTTP calls to GitHub's API.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the call `get_repos` is an HTTP GET of `/user/repos`. The HTTP
    request will return the result as JSON. PyGitHub is parsing the JSON result and
    populating Python objects so the result is more natural for a Python developer.
  prefs: []
  type: TYPE_NORMAL
- en: Python is not the only programming language. You can find libraries for almost
    any known language.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can go beyond the simple scripts and develop a full-blown GitHub
    client. We will leave that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete API documentation for PyGitHub can be found at [http://pygithub.readthedocs.io/en/latest/reference.html](http://pygithub.readthedocs.io/en/latest/reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub to authenticate at Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is the most popular continuous integration software and it allows users
    to continuously build, test, and release any kind of software. It is extremely
    flexible and configurable in every aspect, including the way users are able to
    log in and authorize. GitHub is able to act as an OAuth provider, which is very
    convenient since it makes a lot of sense to map the users working on a project
    with the relative area of the CI system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to demonstrate the procedure, we will need a Jenkins instance. Every
    company will have a different setup so, in order to make things more predictable,
    we will work with a local version of Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jenkins is a Java app but still, the easiest way to get a running ephemeral
    instance of Jenkins for our example is by using Docker. With Docker installed
    and running on your machine, simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This instance of Jenkins won't leave behind any traces of itself once the docker
    container is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logs will start appearing on your console and they will contain the password
    for the first login. Look for something that appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point you can point your browser to `http://localhost:8080/` and you
    will be prompted for your password, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b34e77c7-c424-4e3e-8b8b-f91ea5e2d8df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, you will be prompted to install plugins. For this example, let''s
    just install the suggested plugins as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec328140-0764-46ea-8b48-e19f841e49c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will be prompted to create an admin user, but, since this is an ephemeral
    image, you can just continue by clicking Continue as admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7591874-d9bb-4e45-b05a-87b9d4b9ee51.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, you will be asked to set up the Instance Configuration. Just keep the
    default value and click Save and Finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, Jenkins is ready to be used. Just click on Start using Jenkins,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb5ccf16-e5f4-4300-a40d-cfd41cf6b552.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will now see the Welcome to Jenkins! homepage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96d02e42-61b3-43f1-a5c5-c84df8c2017b.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to authenticate to Jenkins using GitHub, you will have to install
    the GitHub Authentication Plugin. To do this, click on Manage Jenkins on the panel
    on the left and on the new page click on Manage Plugins, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ddbc1fc-69d3-4378-a7f5-53b7be64800b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can navigate to the Available tab and type `github auth` in the search
    box , as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b541849b-9f58-4a8e-ab44-b51e86a70f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now install the plugin by checking the box on the left and clicking
    on Install without restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the plugin is installed you can go back to the Jenkins homepage by clicking
    on the Jenkins logo in the top-left corner and, once again, clicking on Manage
    Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time we will proceed by clicking on Configure Global Security, as shown
    in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4224b1c-0d05-408c-b817-ebef1fbde4d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now head over to GitHub and, as shown in the next screenshot, register a new
    application by navigating to [https://github.com/settings/applications/new](https://github.com/settings/applications/new):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c7343b9-4334-48a3-b6d7-f3b5f2b5a125.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you will need to fill in an arbitrary Application name and the Authorization
    callback URL as shown. Once you register the application you will be able to see
    your Client ID and Client Secret. These will be needed in Jenkins in order to
    fill in the relative fields in the Global Security Settings.
  prefs: []
  type: TYPE_NORMAL
- en: Once you submit the form you will be able to log in to Jenkins using your GitHub
    credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authentication needs to solve the question, Who is the person trying to access
    the service?. There are many ways to do it: login and password, tokens, and so
    on. OAuth is another way to answer that question. OAuth stands for Open Authentication
    and it is an open standard for access delegation. It allows users to have access
    to websites (such as our Jenkins instance) without having to provide them, and
    therefore trust them, with a password.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub has the ability to act as an OAuth provider, which means that other websites
    can be configured to accept the credentials provided by GitHub to let users access
    their services.
  prefs: []
  type: TYPE_NORMAL
- en: This means that whenever a user tries to access a Jenkins instance configured
    to accept GitHub OAuth, he will be redirected to GitHub itself to authenticate
    and, subsequently, GitHub will redirect the user to the Jenkins instance with
    an attached identity token.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authentication is only half of the equation. Identifying a user is, of course,
    important, but what we do with that information is critical as well. Here is where
    authorization comes into play, which, keeping the question analogy, aims to answer
    the question: Given that the person trying to access the service is X, what is
    he allowed and not allowed to do?'
  prefs: []
  type: TYPE_NORMAL
- en: The way we configured the Jenkins instance, anybody able to log in will be able
    to do anything. This might not be the desired behavior, which leads to another
    section of the Global Security page in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: You will find a section called Authorization, which provides many options. One
    is the GitHub Committer Authorization Strategy, which determines if a user is
    allowed to see a specific Jenkins job–but only if he's allowed to access the relative
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation of the GitHub OAuth Plugin is available at [https://wiki.jenkins.io/display/JENKINS/GitHub+OAuth+Plugin](https://wiki.jenkins.io/display/JENKINS/GitHub+OAuth+Plugin).
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Jenkins builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a Jenkins job, how will Jenkins know when it's time to build
    a specific branch or pull request? Jenkins offers many ways to do this, from continuously
    building based on a timer, to polling the Git repository to see if anything changed.
    Both of these options are not very efficient, but luckily GitHub allows for a
    better solution.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub has the concept of Webhooks, which means that it can be configured to
    contact a server, such as our Jenkins instance, when something important happens.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to achieve the goal, but in this recipe we will focus on
    one approach, which is going to be helpful especially in an enterprise environment
    where a GitHub organization is used, containing several repositories. Managing
    a single job or more per repository can quickly become a repetitive chore and
    that is where the **GitHub Branch Source** plugin comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to need a Jenkins instance so the same preparatory steps as the
    previous recipe are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if the Jenkins instance is not reachable from the internet, a
    reverse proxy will be needed in order for GitHub to send notifications to the
    Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub Branch Source plugin comes preinstalled with the default installation,
    but if your setup does not already have the plugin, you can easily install it
    as we did in the previous recipe. Go to the Jenkins home page and proceed to Manage
    Jenkins, Manage Plugins, click on the Available tab and look for GitHub Branch
    Source. Install the plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go back to the Jenkins homepage and click on Create New Jobs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/424c5a74-f3bd-43b9-a794-bf5127c127de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose a job name and select GitHub Organization before clicking OK. The following
    configuration page can look a bit daunting, so let''s break it down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31013018-1169-47ff-ac05-57ec0aa70bec.png)'
  prefs: []
  type: TYPE_IMG
- en: The only section that really needs to be taken care of is Projects. The first
    thing to set is the GitHub credentials. This will allow Jenkins to automatically
    set up webhooks for us. Credentials in Jenkins are treated with security in mind
    and are properly encrypted, so don't be afraid to save them here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to specify the Owner, which is simply the name of the GitHub
    organization we want to keep under control. The following section describes the
    behaviors, which are completely fine in their default form. They will allow building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PRs coming from the repo itself
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PRs coming from forks, but from trusted users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That is it! Now Jenkins will be able to automatically build any branch or PR
    as long as the code contains a Jenkinsfile. Jenkinsfiles are going to be treated
    in the next recipe, so stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub Branch Souce plugin will allow Jenkins to periodically scan the whole
    specified GitHub organization, and for every repository it will check all the
    branches and PRs, and if they contain a file called `Jenkinsfile` they will be
    automatically built following the directives contained in the Jenkinsfile itself.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a powerful paradigm and it allows to keep under version control
    not only the code of the project but also the instructions on how to build, test,
    and even release it in the same code base.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The job configuration page will allow changing many different behaviors. What
    if, for example, we don't want to build all branches, but only the ones whose
    name matches a regular expression? The solution is just a few clicks away! There
    are so many possibilities and the Jenkins developers keep adding new ones, so
    it's worth taking a look periodically at what's available.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation for the GitHub Branch Source plugin is available at [https://go.cloudbees.com/docs/cloudbees-documentation/cje-user-guide/index.html#github-branch-source](https://go.cloudbees.com/docs/cloudbees-documentation/cje-user-guide/index.html#github-branch-source).
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkinsfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jenkinsfiles are a relatively new feature in the Jenkins world and they come
    in two varieties and syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groovy DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Groovy DSL is very flexible and powerful, but it also facilitates some anti-patterns,
    so in this recipe we're going to focus on the declarative-style Jenkinsfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a GitHub repository containing a codebase that can be built and
    tested. Given the sheer number of possible programming languages and build systems
    available, we will choose an arbitrary Java project using the popular Maven build
    system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It will be sufficient to add a file called `Jenkinsfile` with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jenkinsfile describes both how to build and test the software and the environment
    in which to run such an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`agent any` specifies that this build can be run on any available executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tools {}` section specifies the programs needed to run our build. In this
    case, Maven and the **Java Development Kit** (**JDK**) are needed and the versions
    are specified as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stages {}` and `stage() {}` allow splitting the run into well-defined sections
    which will allow better analysis of build results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each stage needs to contain a `steps {}` section that will describe exactly
    which operations to perform. In this case, in the *Initialize* stage, we are simply
    running a shell script that echoes a couple of environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Build stage actually runs Maven and, if the build succeeds, it will analyze
    the results of the unit tests contained in an XML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jenkinsfiles are a huge topic that would be able to fill a book on its own,
    so the examples provided have only scratched the surface of what is possible.
    To give some examples, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Run steps in parallel on different machines to save build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and deploy build artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run complete releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for some user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much much more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax for declarative Jenkinsfiles can be found at [https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/).
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that plugins are able to contribute all kinds of steps and tools, so
    be sure to check the documentation of the plugin you are planning to use!
  prefs: []
  type: TYPE_NORMAL
