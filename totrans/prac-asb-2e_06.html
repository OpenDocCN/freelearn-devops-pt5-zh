<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-93"><a id="_idTextAnchor318"/>6</h1>
<h1 id="_idParaDest-94"><a id="_idTextAnchor319"/>Creating and Consuming Collections</h1>
<p>If you were familiar with Ansible releases before 2.9, so far, much of this book will have looked very familiar to you. If you’re a newcomer to the world of Ansible automation, then, of course, all of this will look new and shiny. Regardless of your experience with Ansible to date, no book on this would be complete without an in-depth look at collections. Collections are the solution to the problems that started to manifest as a result of Ansible’s own popularity and success, and they are now at the heart of every modern Ansible installation. Whether you realized it or not, you’ve been working with them throughout this book so far, and they are here to stay, so it benefits us to take a deep dive into them.</p>
<p>In this chapter, we will explore collections in depth, looking in more detail at the problem that they solve and how they came about, before taking a more technical look at their structure and makeup. We will conclude the chapter with a hands-on example of creating your own collection so that you have a solid understanding of how they are created, built, maintained, and used. As a result, you will be able to work with this powerful new addition to Ansible with ease and take advantage of collections in your own automation solutions.</p>
<p>Specifically, in this chapter, we will cover the following topics:</p>
<ul>
<li><a id="_idTextAnchor320"/>An introduction to Ansible collections</li>
<li>Understanding fully qualified collection names</li>
<li>Managing collections on your control node</li>
<li>Updating your Ansible collections and core installation</li>
<li>Creating your own collections</li>
</ul>
<h1 id="_idParaDest-95"><a id="_idTextAnchor321"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as detailed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and are using the most recent version available – the examples in this chapter were tested with Ansible 8.0 and <code>ansible-core</code> 2.15. This chapter also assumes that you have at least one additional host to test against, and this should be Linux-based. Although we will give specific examples of hostnames in this chapter, you are free to substitute them with your own hostnames and/or IP addresses, and details of how to do this will be provided in the appropriate places.</p>
<p>The code bundle for this chapter is available here: https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter 6<a id="_idTextAnchor322"/></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor323"/>Introduction to Ansible collections</h1>
<p>Although we’ve mentioned some of this earlier in this book, our goal is for this to be a complete one-stop source of information for collections – thus, if you’ve skipped directly to this chapter, don’t worry – we’ve got you covered. Let’s start with some history as this is important to understand the intention behind collections.</p>
<p>With <a id="_idIndexMarker422"/>Ansible releases prior to 2.9, everything was managed in one huge monolithic code base. While the core Ansible team owned this code base, the modules that really form the lifeblood of Ansible (after all, they are what enable it to automate so many disparate systems with ease) were not. Let’s say a network device vendor wanted to release a new module. Perhaps they added a new feature or fixed a bug in a prior release. They would have to make these changes, test them, and then submit them as a pull request to the main Ansible repository – not only is this a significant undertaking, depending on the number<a id="_idIndexMarker423"/> of <strong class="bold">Pull Requests</strong> (<strong class="bold">PRs</strong>) and amount of code to be merged, but it can also take a long time, slowing down release cycles.</p>
<p>At this point, the owners of the repository would have to merge the code, test it themselves, and perform a release. This way of working was fine in the early days of Ansible, but as its adoption got greater, it became impossible to scale in this manner. Imagine that a large enterprise user of Ansible has a problem with an Ansible module and they need a fix now, or perhaps the vendor has an exciting new launch coming up and they want Ansible support from day one. Neither of these was possible with this way of working. Coupled with the fact that Ansible 2.8 had thousands of modules, the task of managing Ansible code became an unenviable task.</p>
<p>This assumes, of course, that code was eligible to be integrated into the main code base. If something was confidential in nature, or needed distributing in a hurry to fix a problem, then there was no easy way to integrate it into the Ansible installation (to be clear, there were methods, but they were not as simple and straightforward as collections have made this process).</p>
<p>It was out of these needs that <a id="_idIndexMarker424"/>collections were born. In brief, collections empower individual teams and vendors to develop, test, and release contributions to Ansible at their own pace, and independent of the release cycle of the core Ansible code. To be specific, collections provide a mechanism to package and distribute the following:</p>
<ul>
<li>Roles</li>
<li>Plugins</li>
<li>Modules</li>
<li>Playbooks</li>
<li>Documentation</li>
</ul>
<p>As with all aspects of Ansible, the design of collections is simple and easy to work with. A <a id="_idIndexMarker425"/>collection is simply a set of directories containing the files that contain the required functionality. These are then packaged up into a gzipped tarball (a well-known and understood file format) for easy distribution. Collections can be installed and managed locally (as we shall see later, in the <em class="italic">Managing collections on your control node</em> section) and via Ansible<a id="_idIndexMarker426"/> Galaxy (<a href="https://galaxy.ansible.com">https://galaxy.ansible.com</a>).</p>
<p>Anyone familiar with Ansible from its pre-collection days will know that roles were distributed via Ansible Galaxy and were easy to manage using the <code>ansible-galaxy</code> command-line utility. Thus, a valid question might be, if you develop your own role, should you distribute it as a role, or a role contained within a collection? After all, both are currently viable solutions, and both can be distributed via Ansible Galaxy. Although both routes are entirely possible at this time, it is the opinion of the author that, in time, roles will be distributed as collections, as these offer much greater scope for expansion – for example, if you need to develop a plugin to extend the capabilities of your role, then you can add this to the collection you have already created. On the other hand, distributing the role as is would necessitate a later migration to a collection, and thus, you future-proof your code by packaging it as a collection in the first place.</p>
<p>It is very easy for developers, vendors, and enterprises to build their Ansible functionality into collections for packaging and distribution. They can then contribute this back to the community if they so desire (and in the spirit of open source software, this is certainly the goal), but if they contain confidential information, they are just as easy to host and maintain in an internal repository.</p>
<p>With this introduction complete, you have gained a good idea of what a collection is and its intended purpose. We will now proceed in the next section of this chapter to begin a look at the practical aspects of creating and consuming collections to further your understanding.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor324"/>Understanding fully qualified collection names</h1>
<p>Before collections existed, every module that was created and contributed to Ansible had to have a unique name. Thus, it was very common to see modules named like this (both were taken from the Ansible 2.8 release):</p>
<ul>
<li><code>ios_bgp</code></li>
<li><code>eos_bgp</code></li>
<li><code>fortios_router_bgp</code></li>
</ul>
<p>All three of these modules are to modify<a id="_idIndexMarker427"/> the <code>bgp</code> to do the following:</p>
<ul>
<li>Ensure their names are unique</li>
<li>Ensure Ansible coders can understand what their code does</li>
</ul>
<p>Collections <a id="_idIndexMarker428"/>remove the need for unique module names, so it is now possible for contributors to create modules with names that overlap. This is valuable because it removes the need for such long and verbose module names, but it creates the risk of unexpected code behavior. For example, we often use the <code>debug</code> module to understand what our playbook code does and print something out during the execution. It would be entirely possible for us to create our own collection with a module called <code>debug</code>, which does something slightly (or entirely) different. Imagine the confusion that would result if your playbook performed differently on different control nodes, or didn’t work at all.</p>
<p>It is for this reason that throughout this book, in earlier versions of Ansible code, you would be used to seeing code like<a id="_idTextAnchor325"/> this:</p>
<pre class="source-code">
  - name: Print some debug output
    debug:
      msg: "Hello World!"</pre> <p>This still works in Ansible today (you are welcome to test this!), and support for short-form module names has been retained for backward compatibility so that any legacy code that you have can be run. While this is valuable in empowering users to upgrade their Ansible code at their own pace without needing multiple versions of Ansible on the control node, the risk of unexpected behavior due to a module name clash is not insignificant, so it is important to start using fully qualified collection names as soon as possible.</p>
<p>For example, in place of the previously provided example code, we would now write the following:</p>
<pre class="source-code">
  - name: Print some debug output
    ansible.builtin.debug:
      msg: "Hello World!"</pre> <p>The functionality of this code is identical, but the risk of module name clash is now removed because the fully qualified collection name has been specified.</p>
<p>What is a <strong class="bold">Fully Qualified Collection Name</strong> (<strong class="bold">FQCN</strong>) though? The best way to explain this is to break it down<a id="_idIndexMarker429"/> into its component parts, which look like this:</p>
<pre class="source-code">
&lt;namespace&gt;.&lt;collection_name&gt;.&lt;module_name&gt;</pre> <p>Let’s start with the namespace – this is a unique namespace used to identify the developer of the collections. This might be your name if you are an individual developer, or the name of a company if you are contributing to a vendor. All namespaces must be unique, and this is reasonable as a limitation – when you look on Ansible Galaxy, you want to know that modules with the <code>cisco</code> namespace are all managed by Cisco, and thus, you can be certain of who owns and manages the code. Similarly, the <code>ansible</code> namespace (from which we make use of <code>ansible.builtin.debug</code>) is owned and managed by the Ansible project itself.</p>
<p>Now, it’s also safe to assume that each namespace will have one or more collections. It makes sense for collections to be divided up by functionality; otherwise, we head back to the problems of monolithic code base management we discussed earlier in this chapter. For example, within the <code>cisco</code> namespace, there is an <code>ios</code> collection to manage Cisco IOS devices and a separate <code>asa</code> collection to manage their <code>asa</code>, but I could not put it in the <code>cisco</code> namespace on Ansible Galaxy.</p>
<p>The third and final part of the <a id="_idIndexMarker431"/>FQCN is the module name itself. This serves the same function as it always has in Ansible and must be unique within a collection. We have already used modules a number of times in this book, and we will continue to do so; thus, we will assume here that you are happy with the concept of an Ansible module.</p>
<p>Putting this all together, whereas in Ansible 2.8 (or earlier) you would have used the <code>ios_bgp</code> module for BGP configuration on a Cisco IOS device, the FQCN for this module is now <code>cisco.ios.ios_bgp</code>. A valid question you may be asking about this FQCN is, why, given the unique namespace and collection name within it, is the module still called <code>ios_bgp</code> and not simply <code>bgp</code>? The answer lies in backward compatibility – Ansible 8.0 still supports playbooks written for 2.8 and earlier and, as such, still supports module names that are not fully qualified. Thus, if Cisco changed the module name to <code>bgp</code>, they would break backward compatibility.</p>
<p>Despite this backward compatibility functionality, it is important to start making friends with FQCNs as soon as possible. Module names must be unique within a collection, but that is the only limitation. There is nothing to stop me from creating my own module called <code>ios_bgp</code>, in my own <code>ios</code> collection, and calling it something like <code>practicalansible.ios.ios_bgp</code>. In this instance, you could not guarantee which module you were calling if you only specified the module by the name <code>ios_bgp</code> in your playbooks and roles, and as such, it is vital to use FQCNs to make sure you don’t come across any unexpected or erroneous behavior.</p>
<p>Although these concepts relating to <a id="_idIndexMarker432"/>FQCNs are simple, they are foundational knowledge, and we will rely on this understanding as we proceed through this chapter, so it is important that we get them out of the way early on. Now that we’ve achieved this, we’ll look in the next section at how to manage collections on your control node.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor326"/>Managing collections on your control node</h1>
<p>As we discussed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, when you install Ansible, it actually installs a<a id="_idIndexMarker433"/> set of collections, providing equivalent functionality to the latest 2.x release so that backward compatibility is maintained (alongside <code>ansible-core</code>, of course). This process is invisible to the user, and this accompanying collection set also gets updated as you update your Ansible installation.</p>
<p>Given this, you could be forgiven for wondering why you need to learn about managing collections at all – after all, Ansible comes with a huge set by default, and the collections get updated as you update your installation. Yet this is the beauty of collections – if they do exactly what you need to do, then you need to take further action. In contrast, if you actually do need to extend the functionality of your Ansible control node, you can do just that – the power lies in the choice and flexibility, just as it always has with Ansible.</p>
<p>To help us understand the management of our collections, let’s start by looking at the locations in which they get installed. Like everything in Ansible, the paths in which collections get installed are configurable, and you can install collections wherever you like (provided you’ve set the correct setting of course).</p>
<p>If we log into our demo node, where I installed Ansible under my local user account using <code>pip3</code>, I can query the Ansible collection paths as follows:</p>
<pre class="console">
$ ansible-config dump | grep COLLECTIONS_PATHS
COLLECTIONS_PATHS(default) = ['/home/james/.ansible/col<a id="_idTextAnchor327"/>lections', '/usr/share/ansible/collections']</pre> <p>What you can see here is that the <code>COLLECTIONS_PATHS</code> environment variable is not set (denoted by <code>(default)</code> displayed in the output), and thus, it has defaulted to two known locations:</p>
<ul>
<li><code>~/.</code><code>ansible/collections</code></li>
<li><code>/</code><code>usr/share/ansible/collections</code></li>
</ul>
<p>The <a id="_idIndexMarker434"/>collections paths are searched in the order specified, so the location under my home directory will be searched prior to the path under <code>/usr/share</code>. You can set the location for your collections by setting the environment variable we just queried previously, or you can create an entry in your <code>ansible.cfg</code> file in the <code>[default]</code> section, using the <code>collections_paths</code> key. Please refer to this link for more information: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths">https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths</a>.</p>
<p>On my demo node, I have not performed any work on collections so far, and as a result, if I try to list the previous paths, I will find that neither of them exists. Nonetheless, let’s try and install the <code>gns3</code> collection from user <code>davidban77</code> and see what happens (<a href="https://galaxy.ansible.com/davidban77/gns3">https://galaxy.ansible.com/davidban77/gns3</a>):</p>
<pre class="console">
$ ansible-galaxy collection install davidban77.gns3
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/davidban77-gns3-1.5.0.tar.gz to /home/james/.ansible/tmp/ansible-local-919n6_zrnbj/tmpgf0fuin6/davidban77-gns3-1.5.0-hlfzoaen
Installing 'davidban77.gns3:1.5.0' to '/home/james/.ansible/collections/ansible_collections/davidban77/gns3'
davidban77.gns3:1.5.0 was installed successfully</pre> <p>Here, we can see that the collection was installed successfully, and the <code>ansible-galaxy</code> tool even tells us helpfully where it was installed. However, note that it was installed only for my local user account, so if another user on this box wants to make use of this collection, they must install their own copy. This is fine, but it risks creating issues further down the road if they install a different version (which might happen because they install the same collection but later on, after an update has been made).</p>
<p>However, we can get around this. The first way is to install the collection(s) you need centrally so that all users can access them. We know that, by default, the <code>COLLECTIONS_PATHS</code> variable will search <code>/usr/share/ansible/collections</code>, and this will be accessible to all users, so any collections that need to be available globally can be installed here. The path won’t exist by default, but<a id="_idIndexMarker435"/> you can easily create it and install the collection here by running the following commands:</p>
<pre class="console">
$ sudo mkdir -p /usr/share/ansible/collections
$ sudo chmod a+w /usr/share/ansible/collections/
$ ansible-galaxy collection install -p /usr/share/ansible/collections davidban77.gns3
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/davidban77-gns3-1.5.0.tar.gz to /home/james/.ansible/tmp/ansible-local-1036ifclq7yb/tmpi34u42w5/davidban77-gns3-1.5.0-nvsahsw0
Installing 'davidban77.gns3:1.5.0' to '/usr/share/ansible/collections/ansible_collections/davidban77/gns3'
davidban77.gns3:1.5.0 was installed successfully</pre> <p>Note that the <code>chmod</code> command used is a blunt-force method to grant all users access to install collections in this shared directory. It is recommended that you set up suitable access controls to this directory as is appropriate for your environment, but as this will differ in every scenario, this is left as an exercise for you to complete.</p>
<p>What you will notice now is that we added the <code>-p</code> flag to the command we ran before, telling <code>ansible-galaxy</code> to install our collection in a different location than the default (which is the first entry in the <code>COLLECTIONS_PATHS</code> variable). As such, we have successfully installed the collection in a central location for all users to work with.</p>
<p>We can validate this using the following command (output truncated for readability):</p>
<pre class="console">
$ ansible-galaxy collection list
# /home/james/.local/lib/python3.10/site-packages/ansible_collections
Collection                    Version
----------------------------- -------
amazon.aws                    5.4.0
ansible.netcommon             4.1.0
…
# /usr/share/ansible/collections/ansible_collections
Collection      Version
--------------- -------
davidban77.gns3 1.5.0
# /home/james/.ansible/collections/ansible_collections
Collection      Version
--------------- -------
davidban77.gns3 1.5.0</pre> <p>Note how the <a id="_idIndexMarker436"/>output of this command lists the collections in each of its known locations, which includes all paths listed by the <code>COLLECTIONS_PATHS</code> variable, and also the install location of Ansible (which is included first and is implicit in the configuration – you do not need to specify this).</p>
<p>There is no uninstall option when it comes to collections, but the beauty of Ansible has always been in its simplicity, and collections, like roles, are simply a set of directories and files in a known structure (there’ll be more on this later in the chapter). As a result, if we wanted to uninstall the centrally available <code>davidban77.gns3</code> collection, you would simply run the following:</p>
<pre class="console">
$ rm -rf /usr/share/ansible/collections/ansible_collections/davidban77/gns3/</pre> <p>If you rerun the collection listing, you’ll see that this collection no longer appears in the output. What happens if you want to install a specific version of a collection though? Well, say you wanted to install the <code>1.4.0</code> release of the collection we’ve been testing with – you would simply run this command to install it:</p>
<pre class="console">
$ ansible-galaxy collection install davidban77.gns3:1.4.0
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/davidban77-gns3-1.4.0.tar.gz to /home/james/.ansible/tmp/ansible-local-1081bdunqhfz/tmp41a0hc0l/davidban77-gns3-1.4.0-cg29hr0y
Installing 'davidban77.gns3:1.4.0' to '/home/james/.ansible/collections/ansible_collections/davidban77/gns3'
davidban77.gns3:1.4.0 was installed successfully</pre> <p>Here, we have <a id="_idIndexMarker437"/>successfully installed version <code>1.4.0</code> of this collection, and it has overwritten version <code>1.5.0</code>, which we installed earlier. Upgrading collections is as simple as either specifying the latest version in place of the earlier one we used previously, or forcing a reinstallation (which, by its very nature, installs the latest version of the collection):</p>
<pre class="console">
$ ansible-galaxy collection install --force davidban77.gns3
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/davidban77-gns3-1.5.0.tar.gz to /home/james/.ansible/tmp/ansible-local-11688lrshtvg/tmpzaaelkpw/davidban77-gns3-1.5.0-3moa8p5j
Installing 'davidban77.gns3:1.5.0' to '/home/james/.ansible/collections/ansible_collections/davidban77/gns3'
davidban77.gns3:1.5.0 was installed successfully</pre> <p>You can<a id="_idIndexMarker438"/> even specify version ranges – if, for example, we’ve established we need to use a version of this collection newer than the <code>1.2.0</code> release, but older than the <code>1.5.0</code> release, we can run the following:</p>
<pre class="console">
$ ansible-galaxy collection install 'davidban77.gns3:&gt;1.2.0,&lt;1.5.0'
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/davidban77-gns3-1.4.0.tar.gz to /home/james/.ansible/tmp/ansible-local-1210j61dbhwq/tmpznhg7oik/davidban77-gns3-1.4.0-u800o2wa
Installing 'davidban77.gns3:1.4.0' to '/home/james/.ansible/collections/ansible_collections/davidban77/gns3'
davidban77.gns3:1.4.0 was installed successfully</pre> <p>Here, the latest version within the range we specified has been installed – a very useful and powerful feature to maintain dependencies.</p>
<p>This discussion on installing and maintaining collection versions brings us neatly back to our original concern – how to ensure users are all installing the correct version of collections required (or sanctioned) for playbook development. We’ve established that you can install collections centrally, and this is certainly one viable route. However, this method breaks down as soon as someone starts developing and/or running playbooks on another machine. It is clear then that a different method will be required.</p>
<p>Thankfully, the <code>ansible-galaxy</code> command also supports working with requirements files – these are simply a list of the required collections (and versions) that you need to have installed, and as they are simple text files, they can be committed to source control along with all your other automation code. Then, all the people involved in your playbook need to do is run a single command to install the required collection, and they can then proceed with development and/or running the playbooks with the confidence that they have the correct collections installed, and with the correct versions. Let’s add one more collection to the previous example and create a file called <code>requirements.yml</code> with the following content:</p>
<pre class="source-code">
---
collections:
- name: davidban77.gns3
  version: '&gt;1.2.0,&lt;1.5.0'
- marmorag.ansodium</pre> <p>In this file, we <a id="_idIndexMarker439"/>state that we need the <code>davidban77.gns3</code> collection with the version constraints we tested earlier, and also the <code>marmorag.ansodium</code> collection. You can see that we omitted the <code>name:</code> key with the second collection – this is only required if you specify additional parameters such as <code>version:</code>; thus, a useful shorthand if you don’t need this is to simply create a list of collection names. Once you have this file, you can ensure the collections meet the stated requirements by running the following:</p>
<pre class="console">
$ ansible-galaxy collection install -r requirements.yml
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/marmorag-ansodium-1.0.2.tar.gz to /home/james/.ansible/tmp/ansible-local-1242d4dc7w5j/tmp0rltoudk/marmorag-ansodium-1.0.2-q01qc8if
'davidban77.gns3:1.4.0' is already installed, skipping.
Installing 'marmorag.ansodium:1.0.2' to '/home/james/.ansible/collections/ansible_collections/m<a id="_idTextAnchor328"/>armorag/ansodium'
marmorag.ansodium:1.0.2 was installed successfully</pre> <p>Here, you can see that the requirements for the <code>davidban77.gns3</code> collection were already met, so no further action was taken. However, the <code>marmorag.ansodium</code> collection, which we didn’t previously install, now gets installed.</p>
<p>As a side note, all the <a id="_idIndexMarker440"/>collections we are working from here are publicly available at <a href="https://galaxy.ansible.com">https://galaxy.ansible.com</a> – however, it is important to note that you can also specify your own server or even a local tarball to install collections with, and we shall see examples of the latter in action later in the chapter.</p>
<p>That concludes our look at managing collections on your control node, and armed with this information, you should be able to set up a consistent environment for all your automation needs. In the next section, we will look at a subtle variation on this theme – how to update the collections that were installed at the time you installed the Ansible package.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor329"/>Updating your Ansible collections and core installation</h1>
<p>You may very well be asking <a id="_idIndexMarker441"/>what happens to the collections you installed at the time of installing Ansible – how do you maintain or upgrade them? Naturally, one way is to wait for the next release of the <code>ansible</code> package, and then upgrade it with <code>pip</code> – however, this is a brute-force method and may not provide you with the results you are looking for. Let’s take a more fine-grained approach.</p>
<p>Let’s say you want to get access to the latest features in the <code>amazon.aws</code> collection, which is bundled with the <code>ansible</code> package when you install it – you would simply install it (again!) as follows:</p>
<pre class="console">
$ ansible-galaxy collection install amazon.aws
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/amazon-aws-6.1.0.tar.gz to /home/james/.ansible/tmp/ansible-local-12589si7_q1d/tmpytach2d5/amazon-aws-6.1.0-mihyh1f0
Installing 'amazon.aws:6.1.0' to '/home/james/.ansible/collections/ansible_collections/amazon/aws'
amazon.aws:6.1.0 was installed successfully</pre> <p>Now, if you query the <a id="_idIndexMarker442"/>installed collections, you will see the following:</p>
<pre class="console">
$ ansible-galaxy collection list
# /home/james/.local/lib/python3.10/site-packages/ansible_collections
Collection                    Version
----------------------------- -------
amazon.aws                    5.4.0
…
# /home/james/.ansible/collections/ansible_collections
Collection        Version
----------------- -------
amazon.aws        6.1.0</pre> <p>Thus, you can see that the original version of the collection has been retained, but the newer version has been installed in our local collections directory (as specified by <code>COLLECTIONS_PATHS</code>). Ansible will use manually installed collections in locations specified by this variable in precedence over the originally installed collections, so this way, it is easy to upgrade collections that are bundled with the Ansible package. If you feel at all nervous about which collection is used, there is a handy <code>lookup</code> plugin that you can use to query the version of a collection being used by Ansible. Consider the following code:</p>
<pre class="source-code">
---
- name: Play to check collection version
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Get the version of the amazon.aws collection
      ansible.builtin.debug:
        msg: "amazon.a<a id="_idTextAnchor330"/>ws version {{ lookup('community.general.collection_version', 'amazon.aws') }}"</pre> <p>Most of this code should now be <a id="_idIndexMarker443"/>familiar to you. All we do here is use a <code>lookup</code> plugin called <code>community.general.collection_version</code>, passing it the value of the collection name we want to query (in our case, <code>amazon.aws</code>). If we run this, it will kindly reassure us that we’re on the version we just installed:</p>
<pre class="console">
$ ansible-playbook check-collection-version.yml
PLAY [Play to check collection version] ****************************************************************************************************************************************
TASK [Get the version of the amazon.aws collection] ****************************************************************************************************************************
ok: [localhost] =&gt; {
    "msg": "amazon.aws version 6.1.0"
}
PLAY RECAP *********************************************************************************************************************************************************************
localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0     rescued=0    ignored=0</pre> <p>If we downgrade the <a id="_idIndexMarker444"/>collection to an older version than that installed with the <code>ansible</code> package (an unlikely scenario, but just for example), we can see then that Ansible faithfully adheres to its path search order and does not default to the <code>amazon.aws</code> collection that was installed as part of the Ansible installation, even though this version is newer:</p>
<pre class="console">
$ ansible-galaxy collection install amazon.aws:5.0.0
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Downloading https://galaxy.ansible.com/download/amazon-aws-5.0.0.tar.gz to /home/james/.ansible/tmp/ansible-local-1291avom1yll/tmpn2juwhhj/amazon-aws-5.0.0-nzac4kq1
Installing 'amazon.aws:5.0.0' to '/home/james/.ansible/collections/ansible_collections/amazon/aws'
amazon.aws:5.0.0 was installed successfully
james@controlnode:~/Practical-Ansible-Second-Edition/Chapter 6$ ansible-playbook check-collection-version.yml
PLAY [Play to check collection version] ****************************************************************************************************************************************
TASK [Get the version of the amazon.aws collection] ****************************************************************************************************************************
ok: [localhost] =&gt; {
    "msg": "amazon.aws version 5.0.0"
}
PLAY RECAP *********************************************************************************************************************************************************************
localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>Although simple, this<a id="_idIndexMarker445"/> management of collections installed at the time of installing Ansible is fundamental to maintaining your control nodes, and as such, it is important that we cover it. Now that you’ve learned all about collections, what they are, why they are important, and how to administer them, let’s create our very own collection to work with in the next section.</p>
<h1 id="_idParaDest-100">Creati<a id="_idTextAnchor331"/>ng your own collections</h1>
<p>We have learned a great deal about<a id="_idIndexMarker446"/> collections and how to manage and maintain them. Let’s now complete your knowledge on this topic by creating your own one from scratch, thus giving you a full overview of how they are put together and how they work.</p>
<p>As with roles (see <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks and Roles</em>), collections are simply an organized set of files within directories. Although you can look up all these directories and create them by hand, we can also get the <code>ansible-galaxy</code> utility to create a blank template for us to work with.</p>
<p>Let’s start with the fundamentals. We know that we need both a namespace and a collection name. If we publish on the Ansible Galaxy website, then the namespace will be our GitHub handle, as Ansible Galaxy takes this and uses it as your namespace. In our case, we won’t be publishing to Ansible Galaxy, so I’ll choose the namespace <code>practicalansible</code>, but feel free to substitute this with your GitHub handle in all the following example code and commands if you want to publish your work.</p>
<p>Once we’ve decided on the namespace, the next step is a collection name. Normally, this would be used to indicate what a collection is for, and here, we will use this to amalgamate examples found elsewhere in this book, so we’ll simply call the collection <code>examples</code>.</p>
<p>We’ll create an <a id="_idIndexMarker447"/>empty directory to work in to separate this from the rest of our code, and then we’ll create the skeleton directory structure as follows:</p>
<pre class="console">
$ mkdir collection-development
$ cd collection-development/
$ ansible-galaxy collection init practicalansible.examples
- Collection practicalansible.examples was created successfully
If we examine this directory structure, we can see that it looks as follows:
$ tree
.
└── practicalansible
    └── examples
        ├── README.md
        ├── docs
        ├── galaxy.yml
        ├── meta
        │   └── runtime.yml
        ├── plugins
        │   └── README.md
        └── roles
6 directories, 4 files</pre> <p>Here, you can see the following:</p>
<ul>
<li>The top-level directory is the namespace we chose.</li>
<li>The next-level directory is the collection name.</li>
<li>Under these top-level directories, we have the following:<ul><li>A <code>README.md</code> file (mandatory documentation if you submit to Ansible Galaxy, and advisable in just about every scenario)</li><li>A <code>galaxy.yml</code> file that will contain important metadata about the role, such as tags, a license, and a documentation page so that your entry on Ansible Galaxy is populated correctly</li></ul></li>
<li>We then have a <code>docs/</code> directory – this should be used for all documentation and will be referenced by the <code>ansible-doc</code> command, so it should be populated according to best practices.</li>
<li>There is also a <code>meta/</code> directory – this is prepopulated with a <code>runtime.yml</code> file that is used for submissions to Ansible Galaxy and contains important information about the minimum version of <code>ansible-core</code> required, as well as other artifacts related to deprecation and code upgrade.</li>
<li>Last but by no means least, we have the <code>plugins/</code> and <code>roles/</code> directories, and this is where the code that you are going to distribute will be placed.</li>
</ul>
<p>Not created <a id="_idIndexMarker448"/>in the skeleton directory structure are two directories called <code>playbooks/</code> and <code>tests/</code>. The <code>playbooks/</code> directory is used to distribute playbooks with the collection (yes, you can even do this!), which you can run directly from the command line (provided you’re using <code>ansible-core</code> 2.11 or newer) or via the <code>import_playbook</code> statement within a playbook.</p>
<p>The <code>tests/</code> directory is used to contain automated tests for your code, to be run by the <code>ansible-test</code> tool. We won’t focus on these in this book, but if you’d like to learn more about this topic, this is a great place to start: <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml</a>.</p>
<p>As not <a id="_idIndexMarker449"/>everyone will be able to (or want to) submit to Ansible Galaxy, our focus in this chapter will be on the use of collections to distribute and use code such as modules and roles. Let’s get started on this.</p>
<p>Throughout the book so far, you have already seen many examples of running modules from collections – this is the most common use case for most users, so we will start here.</p>
<p>In <a href="B20846_05.xhtml#_idTextAnchor279"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating and Consuming</em>, we created a simple module to test called <code>remotecopy</code>. We know that collections are the standard way to distribute these, so let’s integrate this into our new collection. We do this by creating a directory called <code>modules/</code> under the <code>plugins/</code> directory and then copying our code there. The end results should look like this:</p>
<pre class="console">
$ mkdir plugins/modules
$ cp ~/Practical-Ansible-Second-Edition/Chapter\ 5/testplaybook/library/remote_filecopy.py plugins/modules/
$ tree
.
├── README.md
├── docs
├── galaxy.yml
├── meta
│   └── runtime.yml
├── plugins
│   ├── README.md
│   └── modules
│       └── remote_filecopy.py
└── roles
5 directories, 5 files</pre> <p>Note that we didn’t change the code at all in the module from that used in <a href="B20846_05.xhtml#_idTextAnchor279"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating and Consuming</em>. No modifications to your code are necessary to work with collections – it’s simply a matter of making sure you put your files in the correct <a id="_idIndexMarker450"/>subdirectory. With that done, we can now package up our collection for testing. This is done by changing to the root directory of the collection itself and then issuing the <code>ansible-galaxy collection </code><code>build</code> command:</p>
<pre class="console">
$ cd ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-development/practicalansible/examples/
$ ansible-galaxy collection build
Created collection for practicalansible.examples at /home/james/Practical-Ansible-Second-Edition/Chapter 6/collection-development/practicalansible/examples/practicalansible-examples-1.0.0.tar.gz</pre> <p>Note that Ansible has appended a version number of <code>1.0.0</code> to the filename – this was obtained from the <code>galaxy.yml</code> file and is the default value. We’ll edit this in a future example, but for now, it serves our purpose.</p>
<p>With the collection built, it’s time to test it. First of all, we need to create an empty directory to work in. Once we’re in there, we can use the <code>ansible-galaxy</code> command to install our new collection:</p>
<pre class="console">
$ mkdir ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-test/
$ cd ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-test/
$ ansible-galaxy collection install ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-development/practicalansible/examples/practicalansible-examples-1.0.0.tar.gz
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Installing 'practicalansible.examples:1.0.0' to '/home/james/.ansible/collections/ansible_collections/practicalansible/examples'
practicalansible.examples:1.0.0 was installed successfully</pre> <p>Congratulations! You’ve just created and installed your very first collection! From here, we need to create a playbook to test it out. We will create this in the same way we did before, making sure to use <a id="_idIndexMarker451"/>the FQCN of our newly built and installed collection:</p>
<pre class="source-code">
---
- name: Playbook to test custom module
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Test the custom module
      practicalansible.examples.remote_filecopy:
        source: /tmp/foo
        dest: /tmp/bar
      register: testresult
    - name: Print the test result data
      ansible.builtin.debug:
        var: testresult</pre> <p>Now, we will run the <a id="_idIndexMarker452"/>playbook in the normal manner – again, no other special commands or configurations are required, even though we’ve just built and installed our own collection:</p>
<pre class="console">
$ ansible-playbook collection-test1.yml
PLAY [Playbook to test custom module] ******************************************
TASK [Test the custom module] **************************************************
changed: [localhost]
TASK [Print the test result data] **********************************************
ok: [localhost] =&gt; {
    "testresult": {
        "changed": true,
        "failed": false
    }
}
PLAY RECAP *********************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0     rescued=0    ignored=0</pre> <p>We can see that our<a id="_idIndexMarker453"/> module works perfectly, and thus, you can feel accomplished that you have just successfully built, installed, and integrated your first collection using code we already provided in the book.</p>
<p>You can also query the documentation that was built into this module in the normal manner:</p>
<pre class="console">
$ ansible-doc practicalansible.examples.remote_filecopy
&gt; PRACTICALANSIBLE.EXAMPLES.REMOTE_FILECOPY    (/home/james/.ansible/collections/ansible_collections/practicalansible/examples/plugins/modules/remote_filecopy.py)
        The remote_copy module copies a file on the remote host from a given source to a provided destination.
ADDED IN: version 2.15 of practicalansible.examples
OPTIONS (= is mandatory):
= dest
        Path to the destination on the remote host for the copy
= source
        Path to a file on the source file on the remote host
…</pre> <p>Of course, we’ve built our<a id="_idIndexMarker454"/> first collection but also written a separate playbook as a test harness for it. In many cases, you wouldn’t just write a simple test harness as we have here – you would write a playbook to solve an actual use case, or even provide some example code to show how the collection can be used. Let’s do this now by adding<a id="_idTextAnchor332"/> our playbook to the collection:</p>
<pre class="console">
$ cd ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-development/practicalansible/examples/
$ mkdir playbooks/
$ cp ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-test/collection-test1.yml playbooks/collection_test1.yml
$ sed -i 's/version: .*$/version: 1.1.0/g' galaxy.yml
$ tree
.
├── README.md
├── docs
├── galaxy.yml
├── meta
│   └── runtime.yml
├── playbooks
│   └── collection_test1.yml
├── plugins
│   ├── README.md
│   └── modules
│       └── remote_filecopy.py
└── roles
6 directories, 6 files</pre> <p>Although we don’t modify the playbook code, our playbook has a hardcoded <code>hosts</code> line in the play definition set to <code>localhost</code> – you’d probably never do this in a real collection, and the Ansible documentation itself recommends using a variable to define the hosts so that users<a id="_idIndexMarker455"/> can specify their own pattern here. We’re just distributing example code via the collection though, so in our case, we can justify this decision.</p>
<p>While not<a id="_idIndexMarker456"/> changing the playbook file contents, we change the filename as part of the <code>cp</code> command. This is done because Ansible does not support the use of hyphens (<code>-</code>) in filenames when you refer to objects in a collection – an important point that might trip you up later! Also, note here that we’ve used the <code>sed</code> command to change the version number in the <code>galaxy.yml</code> file to make it easy to read the code in the book, but you are welcome to edit it with your favorite text editor. With this done, we can repackage the collection in the same manner as we did before:</p>
<pre class="console">
$ ansible-galaxy collection build
Created collection for practicalansible.examples at /home/james/Practical-Ansible-Second-Edition/Chapter 6/collection-development/practicalansible/examples/practicalansible-examples-1.1.0.tar.gz
Now that we've built the new tarball, we can install it as follows:
$ ansible-galaxy collection install practicalansible-examples-1.1.0.tar.gz
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Installing 'practicalansible.examples:1.1.0' to '/home/james/.ansible/collections/ansible_collections/practicalansible/examples'
practicalansible.examples:1.1.0 was installed successfully</pre> <p>You can now run the<a id="_idIndexMarker457"/> playbook from the command line by simply providing the fully qualified playbook name:</p>
<pre class="console">
$ ansible-playbook practicalansible.examples.collection_test1
[WARNING]: running playbook inside collection practicalansible.examples
PLAY [Playbook to test custom module] ******************************************
TASK [Test the custom module] **************************************************
changed: [localhost]
TASK [Print the test result data] **********************************************
ok: [localhost] =&gt; {
    "testresult": {
        "changed": true,
        "failed": false
    }
}
PLAY RECAP *********************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0     rescued=0    ignored=0</pre> <p>You have now <a id="_idIndexMarker458"/>successfully added a playbook to your collection, bumped up the version number, and upgraded your local installation. You’ve even run the playbook from the collection directly rather than from a local file, as we have throughout all other examples in the book. We hope you feel a sense of accomplishment at this point! Let’s now extend our collection with another example – integrating a plugin. Once again, we’ll make use of code provided elsewhere in this book – specifically, <a href="B20846_07.xhtml#_idTextAnchor343"><em class="italic">Chapter 7</em></a>, <em class="italic">Creating and </em><em class="italic">Consuming</em><em class="italic"> Plugins</em>.</p>
<p>To do this, we need to copy the code we need into our collection. While you would expect plugins to go under the <code>plugins/</code> directory, they must actually be placed under a subdirectory within this, named by the plugin type. We will copy over a <code>lookup</code> plugin, so we <a id="_idIndexMarker459"/>must create a directory called <code>lookup/</code> before we can copy the plugin code to it:</p>
<pre class="console">
$ cd ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-development/practicalansible/examples/
$ mkdir plugins/lookup
$ cp ~/Practical-Ansible-Second-Edition/Chapter\ 7/lookup_plugins/firstchar.py plugins/lookup/
$ sed -i 's/version: .*$/version: 1.2.0/g' galaxy.yml
$ tree
.
├── README.md
├── docs
├── galaxy.yml
├── meta
│   └── runtime.yml
├── playbooks
│   └── collection_test1.yml
├── plugins
│   ├── README.md
│   ├── lookup
│   │  <a id="_idTextAnchor333"/>     └── firstchar.py
│   └── modules
│       └── remote_filecopy.py
└── roles
7 directories, 7 files</pre> <p>Once again, we haven’t modified the plugin code at all – we have just placed it into our directory structure. Again, we’ve bumped up the version number of the collection using <code>sed</code> to edit the <code>galaxy.yml</code> file in place. With this done, we can build and install the new version of the collection in<a id="_idIndexMarker460"/> the normal manner:</p>
<pre class="console">
$ ansible-galaxy collection build
Created collection for practicalansible.examples at /home/james/Practical-Ansible-Second-Edition/Chapter 6/collection-development/practicalansible/examples/practicalansible-examples-1.2.0.tar.gz
$ ansible-galaxy collection install practicalansible-examples-1.2.0.tar.gz
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Installing 'practicalansible.examples:1.2.0' to '/home/james/.ansible/collections/ansible_collections/practicalansible/examples'
practicalansible.examples:1.2.0 was installed successfully</pre> <p>With that completed, it is once again time to test our newly enhanced collection via a playbook. This time, we won’t build the playbook into the collection – we’ll simply create it and run it from the test directory we created earlier. The playbook code should look like the following – again, you should find it unchanged from <a href="B20846_07.xhtml#_idTextAnchor343"><em class="italic">Chapter 7</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Plugins</em>, except that we’ve put the FQCN of the <code>lookup</code> plugin into the playbook rather than the short form name you might otherwise use:</p>
<pre class="source-code">
---
- name: Play to demonstrate our custom lookup plugin
  hosts: localhost
  gather_facts: false
  tasks:
    - name: make a statement
      ansible.builtin.debug:
        msg: "{{ lookup('practicalansible.examples.firstchar', 'testdoc.txt')}}"</pre> <p>Remember to also create a file called <code>testdoc.txt</code> in the same directory as the playbook for the <code>lookup</code> plugin to reference – our example contains the following:</p>
<pre class="console">
$ cat testdoc.txt
I can Ansible!</pre> <p>Finally, run the playbook in the <a id="_idIndexMarker461"/>normal manner, and you should find that the plugin works as desired:</p>
<pre class="console">
$ ansible-playbook collection-test2.yml
PLAY [Play to demonstrate our custom lookup plugin] ****************************
TASK [make a statement] ********************************************************
ok: [localhost] =&gt; {
    "msg": "73"
}
PLAY RECAP *********************************************************************
localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>As you can see, our <code>lookup</code> plugin works perfectly as part of our newly expanded collection. To round off our look at building our own collection, we will expand it further still by adding a role to it.</p>
<p>To provide a little background, <code>ansible-galaxy</code> (both the tool and the Ansible Galaxy website) were originally envisaged to be used to manage, distribute, and install roles. Given that the processes for managing collections, and that their purpose as reusable Ansible code artifacts is very similar to the original roles for which they were designed, it makes perfect sense to use the same tooling for collection management.</p>
<p>At the time of writing, the <a id="_idIndexMarker462"/>Galaxy tools and website support both roles and collections and are likely to for the foreseeable future. However, collections provide a number of advantages, including the option to package multiple roles in a single collection, and you also can use them to distribute any plugins (or even modules) that might be needed for the roles.</p>
<p>The process to migrate a role to a collection is incredibly easy, and if you have a simple role that only includes objects such as tasks, files, templates, handlers, and variables, then you can copy the code over as is (to the correct place, naturally) without any modifications. However, special care needs to be taken if you included plugins with your role previously, as these will need to be moved aside from the role and integrated into the collection itself at the top level (in exactly the same way as we integrated our demo <code>lookup</code> plugin a little earlier in this section).</p>
<p>To extend our example, we’ll <a id="_idIndexMarker463"/>take one of the roles that we demonstrated in <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks and Roles</em>, to show how it can be integrated and tested. As before, we need to change to our collection directory and copy the role over (retaining its directory structure) into a <code>roles/</code> directory within the collection. You can do this as follows:</p>
<pre class="console">
$ cd ~/Practical-Ansible-Second-Edition/Chapter\ 6/collection-development/practicalansible/examples/
$ cp -r ~/Practical-Ansible-Second-Edition/Chapter\ 4/role-example1/roles/installapache/ roles/
$ sed -i 's/version: .*$/version: 1.3.0/g' galaxy.yml
$ tree
.
├── README.md
├── docs
├── galaxy.yml
├── meta
│   └── runtime.yml
├── playbooks
│   └── collection_test1.yml
├── plugins
│   ├── README.md
│   ├── lookup
│   │   ├── firstchar.py
│   │   └── firstchar.pyc
│   └── modules
│       └── remote_filecopy.py
└── roles
    └── installapache
        └── tasks
            ├── fedora.yml
            ├── main.yml
            └── ubuntu.yml
9 directories, 11 files</pre> <p>As you can see, the role is now copied into place and retains the same structure as before, under the <code>roles/</code> subdirectory within the collection. With this complete, we can now build the new <a id="_idIndexMarker464"/>collection (we have incremented the version number again) and install it:</p>
<pre class="console">
$ ansible-galaxy collection build
Created collection for practicalansible.examples at /home/james/Practical-Ansible-Second-Edition/Chapter 6/collection-development/practicalansible/examples/practicalansible-examples-1.3.0.tar.gz
$ ansible-galaxy collection install practicalansible-examples-1.3.0.tar.gz
Starting galaxy collection install process
Process install dependency map
Starting collection install process
Installing 'practicalansible.examples:1.3.0' to '/home/james/.ansible/collections/ansible_collections/practicalansible/examples'
practicalansible.examples:1.3.0 was installed successfully</pre> <p>With the newly updated role in place, all that remains to do is test it. We will borrow the same playbook we used to test it before, with a small modification to call the role from the collection:</p>
<pre class="source-code">
---
- name: Install Apache using a role
  hosts: frontends
  become: true
  roles:
    - practicalansible.examples.installapache</pre> <p>As this is a role to<a id="_idIndexMarker465"/> install Apache on external nodes, we will need to copy over the inventory we used before – if you use the GitHub repository that accompanies this book, that has been done for you. All that remains is to run the code, which should return something like this:</p>
<pre class="console">
$ ansible-playbook -i hosts collection-test3.yml
PLAY [Install Apache using a role] *********************************************
TASK [Gathering Facts] *********************************************************
ok: [web01.example.org]
ok: [web02.example.org]
TASK [practicalansible.examples.installapache : Install Apache using yum] ******
skipping: [web01.example.org]
skipping: [web02.example.org]
TASK [practicalansible.examples.installapache : Start the Apache server] *******
skipping: [web01.example.org]
skipping: [web02.example.org]
TASK [practicalansible.examples.installapache : Install Apache using apt] ******
ok: [web01.example.org]
ok: [web02.example.org]
TASK [practicalansible.examples.installapache : Start the Apache server] *******
ok: [web01.example.org]
ok: [web02.example.org]
PLAY RECAP *********************************************************************
web01.example.org          : ok=3    changed=0    unreachable=0    failed=0    skipped=2    rescued=0    ignored=0
web02.example.org          : ok=3    changed=0    unreachable=0    failed=0    skipped=2    rescued=0    ignored=0</pre> <p>No changes will be <a id="_idIndexMarker466"/>made if you ran this role previously as part of <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks and Roles</em>, but you can clearly see from the preceding that we successfully call the role from the collection and it works perfectly.</p>
<p>With that, we have successfully integrated a plugin, a module, a playbook, and a role into a collection, taking you through the entire process of building and adding to your own collection. That wraps up our look at collections in depth, but I hope that this has given you enough information to proceed with your own testing and developmen<a id="_idTextAnchor334"/>t, ultimately building your own collections.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor335"/>Summary</h1>
<p>Collections are now a vitally important part of Ansible’s overall architecture, and they provide an easy and effective mechanism for all code to be distributed and managed on control nodes everywhere. Learning about collections is vital to your understanding of the architecture of any modern version of Ansible, and armed with this information, you can manage, build, and maintain collections on your control nodes, even contributing them back to the community if you so desire.</p>
<p>In this chapter, you learned about the history of collections, how they came about, and why they are so important to Ansible. You then learned how to reference objects from within collections using FQCNs, before moving on to learning about the installation and management of collections on your control node. Finally, we looked at the process involved in building, installing, and testing your own collection, such that you can progress to contributing collections to the wider Ansible community if you so desire.</p>
<p>In the next chapter, we will learn how to consume and create our very own plugins, providing you with the skills you need to expand the capabilities of Ansible to suit your own bespoke <a id="_idTextAnchor336"/>e<a id="_idTextAnchor337"/>nvironments and contribute to the community.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor338"/>Questions</h1>
<ol>
<li>Collections are an optional feature of Ansible versions later than 2.9:<ol><li>True</li><li>False</li></ol></li>
<li>What does the acronym FQCN stand for?<ol><li>Fully Qualified Collection Namespace</li><li>Fully Qualified Control Node</li><li>Fully Qualified Collection Name</li><li>Fully Qualified Control Name</li></ol></li>
<li>Collections are installed and managed with which command?<ol><li><code>ansible-galaxy</code></li><li><code><a id="_idTextAnchor339"/></code><code>a<a id="_idTextAnchor340"/>nsible-collection</code></li><li><code>ansible</code></li><li><code>collection-manager</code></li></ol></li>
</ol>
<h1 id="_idParaDest-103"><a id="_idTextAnchor341"/>Further reading</h1>
<p><code>ansible-gal<a id="_idTextAnchor342"/>axy</code> and its documentation can be found here: <a href="https://galaxy.ansible.com/docs/">https://galaxy.ansible.com/docs/</a></p>
</div>
</div></body></html>