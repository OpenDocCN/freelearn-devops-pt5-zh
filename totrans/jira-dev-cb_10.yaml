- en: Chapter 10. Dealing with a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending JIRA DB with custom schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing DB entities from plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting plugin information in JIRA DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Active Objects to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing JIRA configuration properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting database connection for JDBC calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating a custom field from one type to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving issue information from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving custom field details from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving permissions on issues from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving workflow details from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating issue status in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving users and groups from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with Change history in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen in [Chapter 2](ch02.html "Chapter 2. Understanding Plugin
    Framework"), *Understanding* *Plugin* *Framework*, that JIRA uses the Ofbiz suite's
    Entity Engine module to deal with database operations.
  prefs: []
  type: TYPE_NORMAL
- en: OfBiz stands for Open For Business and the OfBiz Entity Engine is a set of tools
    and patterns used to model and manage entity-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: As per the definition from the standard entity-relationship modeling concepts
    of RDBMS, an entity is a piece of data defined by a set of fields and a set of
    relations to other entities.
  prefs: []
  type: TYPE_NORMAL
- en: In JIRA, these entities are defined in two files, `entitygroup.xml` and `entitymodel.xml`,
    both residing in the `WEB-INF/classes/entitydefs` folder. `entitygroup.xml` stores
    the entity names for a previously-defined group. If you look at the file, you
    will see that, the default group in JIRA is named `default`; you will find the
    same defined in the entity configuration file, which we will see in a moment.
    `entitymodel.xml` holds the actual entity definitions, details of which we will
    see in the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entity configuration is defined in `entityengine.xml`, residing in the
    `WEB-INF/classes` folder. It is in this file that the `datasource`, transaction
    factory, and so on, are defined. The content of this file varies based on the
    database that we use and the application server. For example, the `datasource`
    definition will be as follows, when the database is MySQL and application server
    is `tomcat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: More about connecting to various other databases can be read at [http://confluence.atlassian.com/display/JIRA/Connecting+JIRA+to+a+Database](http://confluence.atlassian.com/display/JIRA/Connecting+JIRA+to+a+Database).
  prefs: []
  type: TYPE_NORMAL
- en: 'For other application servers, the `jndi-server` attribute in the `jndi-jdbc`
    element varies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Orion format: <jndi-jdbc jndi-server-name="default" jndi-name="jdbc/JiraDS"/>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JBoss format: <jndi-jdbc jndi-server-name="default" jndi-name="java:/JiraDS"/>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weblogic format: <jndi-jdbc jndi-server-name="default" jndi-name="JiraDS"/>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `transaction-factory` tag is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The entity definition XMLs are referenced in the file using the `entity-group-reader`
    and `entity-model-reader` attributes that point to `entitygroup.xml` and `entitymodel.xml`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The delegator element is also defined in this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The field type mapping XMLs for different databases are also defined in this
    file. An example of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Read more about configuring `entityengine.xml` at [http://www.atlassian.com/software/jira/docs/latest/entityengine.html](http://www.atlassian.com/software/jira/docs/latest/entityengine.html)
    and about entity modeling concepts at [http://ofbiz.apache.org/docs/entity.html](http://ofbiz.apache.org/docs/entity.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, *Extending* *JIRA* *DB* *with* *custom* *schema*, we will also
    see glimpses of the JIRA database architecture, which is also explained in detail
    at [http://confluence.atlassian.com/display/JIRADEV/Database+Schema](http://confluence.atlassian.com/display/JIRADEV/Database+Schema).
  prefs: []
  type: TYPE_NORMAL
- en: Extending JIRA DB with custom schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know that JIRA scheme definitions are maintained in `WEB-INF/classes/entitydefs/entitygroup.xml`
    and `entitymodel.xml`, let us have a look at extending the existing scheme definitions.
    How would you extend the JIRA scheme if you want to add one or two custom tables
    into JIRA? Is it just about creating the new tables in our database? We will see
    that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA uses the schema definitions entered in the `WEB-INF/classes/entitydefs/entitygroup.xml`
    and `entitymodel.xml` files. It makes use of these files not only to validate
    and create the schema but also during import and export of the JIRA Data backup.
    JIRA also uses these entity definitions to read and write to a database, using
    OfBizDelegator ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html)),
    details of which we will see in the upcoming recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The following are quick steps to add a new table into the JIRA schema. Let us
    assume we are adding a table to hold the details of an employee.
  prefs: []
  type: TYPE_NORMAL
- en: Identify an entity name for the table. This could be the same as the table name
    or different from it. This name will be used in the XML backups and also by the
    OfBizDelegator to read or write data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, let us choose `Employee` as the entity name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `WEB-INF/classes/entitydefs/entitygroup.xml` file to include the
    new entity group definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `group` attribute refers to the group name the delegator is associated
    with. You can find it in the `WEB-INF/classes/entityengine.xml`, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `entity` attribute holds the name of the entity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `WEB-INF/classes/entitydefs/entitymodel.xml` file to include the
    new entity definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `entity-name` attribute holds the name of the entity we have used
    in *Step* *2\.* The `table-name` holds the name of the table; it is optional and
    will be derived from `entity-name`, if not present. `package-name` can be used
    if you want to organize and structure the entities' definitions into different
    packages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `entity` element contains one field element for each column in the table
    that needs to be created. The `field` element has a `name` attribute that holds
    the name of the field. If the column name of the field is different, the `col-name`
    attribute can be used, as in the case with employee address. If `col-name` is
    missing, the name of the field is used. The next important attribute is `type`.
    In our example, `id` is `numeric` whereas `name` and `address` are `long-varchar`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These type definitions of a field are mapped to the appropriate column type
    for each database type. The `field-type` mappings are stored under `WEB-INF/classes/entitydefs/`
    and is declared in `entityengine.xml`, as shown next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you look inside `fieldtype-oracle10g.xml`, you will notice that `numeric`
    is mapped to `NUMBER(18,0)` and `long-varchar` is mapped to `VARCHAR2(255)`. You
    can find out the various mappings and even the related Java data type from the
    same file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `prim-key` element is used to define the primary key constraint for the
    table, as shown previously. In our case, `id` is the primary key. It is mandatory
    to name the primary key as `id` for all the new tables we are creating.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `index` element creates a DB index for the field specified for that table.
    We can specify the index name and the group of the fields that needs to be indexed
    underneath it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also define the relationship between entities using the element `relation`
    as shown next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding a relationship between the `Employee` entity and `Company`
    entity by saying an employee can have only one company. In the above case, `Employee`
    should have a field `company` that points to the `id` field of a company's record.
    In other words, the `company` field in an employee's record will be the foreign
    key to the company's record.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More details of entity definition can be found at [http://ofbiz.apache.org/docs/entity.html#Entity_Modeling](http://ofbiz.apache.org/docs/entity.html#Entity_Modeling).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Restart JIRA after the changes are made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When JIRA is restarted with the previous changes, you will notice that a warning
    message appear in the logs during startup, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once JIRA recognizes that there is no table corresponding to the new entity
    name **employee** in the database; it will create one, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even the index information is stored, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to add a new column to an existing table, you can add a field definition,
    as we saw earlier and, on restarting JIRA, the table will be updated to include
    the column.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice an error message in the JIRA logs if the database has a table,
    or a column in the table, that doesn't have a valid entity or field definition
    in the `entitymodel.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Care must be taken to update the `entitygroup.xml` and `entitymodel.xml` files
    when JIRA is upgraded or else the changes will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing DB entities from plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how the various entities in the JIRA database are defined and how
    we can introduce new entities. In this recipe, we will see how we can read and
    write data from the database using these entity definitions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA exposes the OfBizDelegator ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html))
    component, which is a wrapper around `org.ofbiz.core.entity.DelegatorInterface`,
    to communicate with its database using the Ofbiz layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get hold of an instance of `OfBizDelegator` by injecting it in the
    constructor or from `ComponentManager`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reading from a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can read from the database using the various methods exposed via the above
    delegator class. For example, all the records in the employee table we defined
    in the previous recipe can be read as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `findAll` method takes the entity name (not the table name) and returns
    a list of `GenericValue` objects, each representing a row in the table. The individual
    fields can be read from the object using the name of the field (not `col-name`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The data type to which the field should be converted can be found from the `field-type`
    mapping XML we saw in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read data from a database, when certain conditions are satisfied, using
    the `findByAnd` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return all the records where company name is `J-Tricks`. You can
    enforce more complex conditions using the `findByCondition` method and select
    only the interested fields, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we find all employee records with ID greater than `15000` and we retrieve
    only the ID and name of the employees.
  prefs: []
  type: TYPE_NORMAL
- en: '`findListIteratorByCondition` ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html#findListIteratorByCondition%28java.lang.String,%20org.ofbiz.core.entity.EntityCondition,%20org.ofbiz.core.entity.EntityCondition,%20java.util.Collection,%20java.util.List,%20org.ofbiz.core.entity.EntityFindOptions%29](http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html#findListIteratorByCondition%28java.lang.String,%20org.ofbiz.core.entity.EntityCondition,%20org.ofbiz.core.entity.EntityCondition,%20java.util.Collection,%20java.util.List,%20org.ofbiz.core.entity.EntityFindOptions%29))'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method can be used to add more options like the `orderBy` clause, `EntityFindOptions`,
    `where` conditions, `having` conditions, and so on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we search for all records with the ID greater than `15000`. We don't have
    a `having` condition in this case and, so, we will leave it null. The next two
    arguments specify that only the `name` field needs to be selected and the records
    should be ordered by the `name` field. The last argument specifies the `EntityFindOptions`.
    Here, we define the EntityFindOptions with four arguments including `TYPE_SCROLL_INSENSTITVE`
    and `CONCUR_READ_ONLY`. The first true is for `specifyTypeAndConcur` and the last
    true is for distinct select.
  prefs: []
  type: TYPE_NORMAL
- en: If `specifyTypeAndConcur` is true, the following two parameters will be used
    to specify `resultSetType` and `resultSetConcurrency`. If false, the default values
    of the JDBC driver will be used. In the above case, `specifyTypeAndConcur` is
    true and, hence, `resultSetType` is taken as `TYPE_SCROLL_INSENSITIVE` and `resultSetConcurrency`
    is taken as `CONCUR_READ_ONLY`. More about this and the possible values can be
    found at [http://download.oracle.com/javase/tutorial/jdbc/basics/retrieving.html](http://download.oracle.com/javase/tutorial/jdbc/basics/retrieving.html).
  prefs: []
  type: TYPE_NORMAL
- en: As discussed before, the last true in the `EntityFindOptions` constructor is
    for selecting distinct values. Apparently, this is the only way to do a distinct
    select using Entity Engine. You will find more information about this in the entity
    engine cookbook at [http://www.opensourcestrategies.com/ofbiz/ofbiz_entity_cookbook.txt](http://www.opensourcestrategies.com/ofbiz/ofbiz_entity_cookbook.txt).
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to close the iterator, as shown in the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a new record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a new record in a table using OfBizDelegator is pretty easy, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you don't provide the ID, as it is automatically generated. Also,
    the missing fields in the map will be set to `null`. Data for all the mandatory
    fields should be provided so as to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing a record is done by retrieving the record, modifying the values, and
    using the `store()` method. For example, we can retrieve a record with ID `12000`
    and modify it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: More useful methods can be found in the Java docs at [http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html).
  prefs: []
  type: TYPE_NORMAL
- en: Persisting plugin information in JIRA DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing plugins, we come across many scenarios where we need to store
    specific information about the plugins, be it configuration detail or metadata
    for entities. How can we do this without creating a custom schema and going through
    the pain of editing entity definitions? In this recipe, we will how we can make
    use of JIRA's existing framework to store information specific to the plugins
    we develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'JIRA uses Open symphony''s `PropertySet` framework to store properties in the
    database. These properties are a set of key/value pairs and are stored against
    any entity that the user wants. The key of the property is always a String value;
    the value can be: String, Long, Date, Boolean, or Double. We have already seen
    how JIRA uses it in [Chapter 2](ch02.html "Chapter 2. Understanding Plugin Framework"),
    *Understanding* *Plugin* *Framework*. In this recipe, we will see we can use `PropertySet`
    to store our custom data.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that we need to store a Boolean value in the database as part of our
    plugin''s configuration and read it later; here are the steps to follow to do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get an instance of `PropertySet`, using `PropertiesManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From JIRA 4.3 onwards, the `PropertiesManager.getInstance()` method is deprecated.
    Instead, you can inject the `PropertiesManager` into the constructor, using dependency
    injection, or retrieve it from `ComponentManager`, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Persist the Boolean property using the `setBoolean` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, String, Long, Double, and Date values can be stored using the respective
    methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The property that is stored can be retrieved at any point, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, how do we store a more complex structure, such as a property, to an
    existing entity? Let us say we want to store the address of a user. JIRA stores
    the user information against the entity `OSUser`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the ID of the user entity we are going to store the address against.
    For example, if there is a user `jobinkk`, we can find the ID of the user from
    the `OSUser` entity that corresponds to the `userbase` table in JIRA. Let us assume
    the ID is `10032`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get an instance of `PropertySet`, using `PropertySetManager`, by passing the
    details of the entity we got:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a map with the entity name, that is, `OSUser`, and the ID of
    the user, that is, `10032`. We also pass the delegator name as defined in the
    `entityengine.xml`, under the `WEB-INF/classes` folder, which is the default in
    this case. We then retrieve the `PropertySet` instance from `PropertySetManager`,
    using `ofbiz` as the key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The values can be set as before, depending on the type of the field. In this
    case, we will have more than one key for state, country, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will then be stored in the appropriate tables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can retrieve these values later by creating the `PropertySet` in a similar
    manner and using the getter methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a property is set using `PropertySet` instantiated from `PropertiesManager`
    as we did in the case of the Boolean values, it gets stored in the **propertyentry**
    table with the `ENTITY_NAME` as **jira.properties** and `ENTITY_ID` as **1**.
    It will also have a unique ID, which will then be used to store the value in the
    **propertynumber**, **propertystring**, **propertytext**, or **propertydate**
    tables, depending on the data type we used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the **propertyentry** table is populated with values, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first one is the Boolean property we added whereas the second and third
    are the user properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean values get stored as numbers (`0` or `1`) and hence, the **propertyentry**
    table stores the **propertytype** as **1**, which denotes a number value. There
    is a corresponding entry in the **propertynumber** table, with ID **11303**, for
    the Boolean property, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our example, the **Boolean** is set to **true** and, hence, the **propertynumber**
    stores the value **1**. If set to `false`, it will store **0**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of address, the entity is **OSUser** and it has an **entityId**
    of **10032**. We have seen two rows with IDs **11304** and **11305**, each with
    **propertytype** as **5**, which denotes String values. Because they are String
    values, they are stored in the **propertystring** table, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hopefully, this gives a fair idea about how we can store attributes against
    an existing entity record.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about the usage of `propertySet` is that we don't need to create
    an extra scheme or entity definition and these properties are exported in the
    backup XML when JIRA data is exported. So, all configurations stored like this
    will be retained when the data is imported back into another JIRA instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using active objects to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Active objects represent a technology recently used by JIRA to allow per-plugin
    storage. This gives the plugin developers a real protected database where they
    can store the data belonging to their plugin and which other plugins won't be
    able to access. In this recipe, we will see how we can store an address entity
    in the database using active objects.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about active objects at [http://java.net/projects/activeobjects/pages/Home](http://java.net/projects/activeobjects/pages/Home).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to understand it better, let us look at the simple ''address entity''
    example that we used in the previous recipe. This will also help in an easy comparison
    with `PropertySet`, if desired Follow the ensuing steps to use active objects
    in the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the active objects dependency in `pom.xml`. Add the appropriate `ao`
    version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the active objects plugin artifacts, under the `maven-jira-plugin`
    configuration, in the `pom.xml` file as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the active objects plugin module to the Atlassian plugin descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the module has a unique key and it points to an entity we are
    going to define later, `AddressEntity` in this case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Include a component-import plugin to register `ActiveObjects` as a component
    in the `atlassian-plugin.xml` previous with the above module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the entity to be used for data storage. The entity should be an interface
    and should extend the `net.java.ao.Entity` interface. All we need to do in this
    entity interface is to define getter and setter methods for the data that we need
    to store for this entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, we need to store the name, city and country as part of the address
    entity. In this case, the `AddressEntity` interface will look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By doing this, we have setup the entity to facilitate the storage of all the
    three attributes. We can now create, modify, or delete the data using the `ActiveObjects`
    component. The component can be instantiated by injecting it into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A new row can be added to the database using the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Details can be read either using the `id`, which is the primary key, or by
    querying the data using a `net.java.ao.Query` object. Using ID is as simple as
    is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Query` object can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are querying for all records with a given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get hold of an entity by either means, we can edit the contents simply
    by using the setter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Deleting is even simpler!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, that gives a fair introduction to active objects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behind the scenes, separate tables are created in the JIRA database for every
    entity that we add. The active objects service interacts with these tables to
    do the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see the database, a table of the name `AO_{SOME_HEX}_MY_OBJECT` is created
    for every entity named `MyObject` belonging to a plugin with key `com.example.ao.myplugin`,
    where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AO` is a common prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOME_HEX` is a set of the first six characters of the hexadecimal value of
    the hash of the plugin key `com.example.ao.myplugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MY_OBJECT` is the upper-case translation of the entity class name `MyObject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every attribute with getter method, `getSomeAttribute` defined in the entity
    interface, a column is created in the table with the name `SOME_ATTRIBUTE` using
    the Java Beans naming convention—separating the two words by an underscore and
    keeping them both in upper case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our **AddressEntity** example, we have the following table, **ao_d6b86e_address_entity**,
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And, for our example, the data is stored as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-10-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing JIRA configuration properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use `PropertySet` to store details of plugins in the previous
    recipes. In this recipe, we will see how we can access the JIRA configuration
    properties using `PropertySet`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lot of global configurations settings in JIRA which are configured
    using Administration menus. More on the various options can be read at [http://confluence.atlassian.com/display/JIRA/Configuring+Global+Settings](http://confluence.atlassian.com/display/JIRA/Configuring+Global+Settings).
    Where does JIRA store this information and how do we access it?
  prefs: []
  type: TYPE_NORMAL
- en: All these configuration properties, such as, settings under **General** **Configuration**,
    **Base** **URL**, **Attachments** **path**, **license** **info**, and more, are
    stored in the `propertyset` tables we saw earlier. They are stored against a virtual
    entity, `jira.properties`. This is the same virtual entity that is used when the
    `PropertySet` is retrieved using `PropertiesManager`, as we saw while persisting
    plugin information.
  prefs: []
  type: TYPE_NORMAL
- en: Here, all the property key entries are stored in the `propertyentry` table,
    with `jira.properties` as the entity name and `entityid` as `1`. The `propertytype`
    for each property varies, depending on what is stored against it. For example,
    `jira.option.allowattachments` is a flag and hence is stored in the `propertynumber`
    table, with a value of either `0` or `1`. In this case, the `propertytype` is
    `1`, denoting the number `value`. `jira.path.index`, on the other hand, stores
    a String that holds the index path and will have `5` as `propertytype`. Here the
    value is stored in `propertystring` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the properties can be accessed using the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see only String properties and their values, you can get it
    using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to search for a specific property, you can do that using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that the appropriate property table should be used, `propertynumber` in
    this case!
  prefs: []
  type: TYPE_NORMAL
- en: 'The same things can be achieved in a plugin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the `PropertySet` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As said before, from JIRA 4.3, the `PropertiesManager.getInstance()` method
    has been deprecated. Instead, you can inject the `PropertiesManager` in the constructor
    using dependency injection or retrieve it from `ComponentManager`, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All property keys can be retrieved as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, all the properties of a specific type can be accessed as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The value of a particular key can be accessed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting database connection for JDBC calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not always feasible to use **OfBizDelegator** to get all the details that
    we need. What if we need to execute a complex query in the database via JDBC?
    In this recipe, we will see how we can retrieve the database connection that is
    defined in `entityengine.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The database connection lookup is pretty simple if you are familiar with JDBC.
    Follow these quick steps to retrieve a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `javax.naming.InitialContext` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the database information from the entity configurations using `EntityConfigUtil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `defaultDS` is the name of the data source defined in `entityengine.xml`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Retrieve the `jndi-name` string from the `DataSourceInfo` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `jndi-name` to look up the `javax.sql.DataSource` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `java.sql.Connection` object from the DataSource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you get the connection, it is similar to any other JDBC calls. Create your
    statements or prepare statements and execute them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As I write this, JIRA 4.3 is being released, and getting a connection is going
    to be much simpler. Just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Simple, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: '`DataSourceInfo` can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Over to you, to write the JDBC calls wisely!
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a custom field from one type to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom fields in JIRA are of different types—text fields, select lists, number
    fields, and so on. We might come across scenarios where we need to change the
    type of a field but without losing all the data we have entered until then! Is
    possible to do that? It is, to a certain extent. In this recipe, we will see how
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: The type of a field can only be changed via the database, as the UI doesn't
    support that. But, it won't be possible with all the field types. For example,
    it isn't possible to convert a text field to a number field because all the values
    that the field already has may not be number fields. However, the reverse is possible,
    because all number values can be treated as text values. Similarly, you can convert
    a select field to a text field but you cannot convert a multi-select field to
    a text field because a multi-select has multiple values, each with a separate
    row in the `customfieldvalue` table.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first step is to identify whether the conversion is feasible, by looking
    at the source and target types. If it is feasible, we can go on and modify the
    type, as described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to modify the type of custom field if the source
    and target types satisfy the condition we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the JIRA instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the JIRA DB as the JIRA user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the custom field key in the `customfield` table by executing the SQL
    script as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the type of the custom field named **'Old** **Number** **Value'** is changed
    to text field. Make sure that the custom field name is unique; if not, use custom
    field ID in the `where` condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the searcher key similarly, with an appropriate searcher. In the previous
    case, we need to modify the searcher value to text searcher, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit the changes and disconnect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do a complete reindexing of the JIRA instance by going to **Administration**
    | **System** | **Indexing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The custom field should now be modified to a text field from the old number
    field. Add or update values and search them to verify the change.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving issue information from a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information about an issue is scattered around in multiple tables in the JIRA
    database. However, a good starting point is the `jiraissue` table, which is where
    the issue record is stored. It has foreign keys referencing other tables and,
    at the same time, the issue ID is referenced in few other tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram captures the important tables that the `jiraissue` table
    has a parent relationship with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving issue information from a Database](img/1803-10-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, critical information about an issue, such as, the project, issue
    type, status, priority, resolution, security level, workflow, and so on, are all
    stored in the respective tables but are referenced from the `jiraissue` table,
    using a foreign key. The foreign key points to the ID of the other tables in all
    cases, but there are no foreign key constraints enforced on any of these tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following diagram shows the tables that the `jiraissue` table
    has a child relationship with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving issue information from a Database](img/1803-10-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the tables `customfieldvalue`, `changegroup`, `jiraaction`, `label`, `worklog`,
    `fileattachment`, `issuelink`, `trackback_ping`, and so on, have a foreign key
    with the name `issueid` or `issue` (or source or destination) pointing to the
    relevant issue's ID.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to access some of the issue's information
    with the help of the previous diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When there is a parent-child relationship between tables, we can do a join
    operation to get most of the information we are looking for. For example, all
    the issues along with their project names can be retrieved by the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here we do an inner join on the condition that the project's ID is the same
    as the project column value in the `jiraissue` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, all the comments on an issue can be retrieved by the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we retrieve the comments on issues with their author and created
    date. The same approach can be used with all tables in the previous diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing version and component information on an issue is slightly different.
    Even though you see the `fixfor` and `component` columns in the `jiraissue` table,
    they are not used anymore!
  prefs: []
  type: TYPE_NORMAL
- en: Each issue can have multiple versions or components and hence there is a `join`
    table between the `jiraissue` and `version`/`component` tables, called `nodeassociation`.
    The `source_node_entity` will be the `ISSUE` and the `source_node_id` represents
    the issue ID. The `sink_node_entity` will be **Component** or **Version**, in
    this case, and `sink_node_id` will hold the ID of the respective component or
    version.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third column, `association_type`, which will be `IssueFixVersion`,
    `IssueVersion`, or `IssueComponent` for fixes for versions, affected versions
    or components respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the components of an issue as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, `DEMO-123` is the issue. We can also retrieve the affected versions and
    fix versions in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving custom field details from a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have seen how to retrieve the standard fields of
    an issue from the database. In this recipe, we will see how to retrieve the custom
    field details of an issue.
  prefs: []
  type: TYPE_NORMAL
- en: All the custom fields in JIRA are stored in the `customfield` table, as we have
    seen while modifying the custom field types. Some of these custom fields, such
    as, select fields, multi-select fields, and so on, can have different options
    configured and they can be found in the `customfieldoption` table.
  prefs: []
  type: TYPE_NORMAL
- en: For each custom field, there can be a set of contexts configured. These contexts
    specify the projects or a list of issue types the field is associated with. For
    each such context, an entry is made in the `fieldconfigscheme` with a unique ID.
    For each `fieldconfigscheme`, there will be entries in the `configurationcontext`
    and `fieldconfigschemeissuetype` tables, `configurationcontext` holding the projects
    the field is associated with in the relevant context, and `fieldconfigschemeissuetype`
    holding the issue types the field is associated with! For fields, such as Select
    and Multi Select, there can be different options configured for different contexts
    and this can be found from the `customfieldoption` table, using the `customfildconfig`
    column, which points to the respective row in the `fieldconfigscheme` table.
  prefs: []
  type: TYPE_NORMAL
- en: There must always be a record in `configurationcontext` and `fieldconfigschemeissuetype`
    for each configuration scheme. If the scheme isn't restricted to any projects
    or issue types, the `project` and `issuetype` columns of the respective tables
    should be `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: For individual issues, the value(s) of the custom fields are stored in the `customfieldvalue`
    table with a reference to the `jiraissue` and `customfield` tables. For multi-value
    fields, such as multiple select, multiple checkboxes, and so on, there will be
    multiple entries in the `customfieldvalue` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We capture this information in a simple diagram like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving custom field details from a database](img/1803-10-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a custom field is added, the details of the field can be retrieved from
    the `customfield` table with this simple query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a field with multiple options, such as the select field, the options
    can be retrieved using a simple join, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The various field configurations can be retrieved from the `fieldconfigscheme`
    table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, `12345` is the unique ID for the custom field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projects associated with a custom field can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When the project is `NULL`, the field is global and hence available for all
    projects!
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the issue types associated with the field can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving permissions on issues from a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA is quite powerful in enforcing permissions on issues. There are quite a
    lot of configuration options in controlling who can do what. All these revolve
    around two different schemes in JIRA, **Permission** **Scheme** and **Issue**
    **Security** **Scheme**.
  prefs: []
  type: TYPE_NORMAL
- en: Permission Scheme enforces project-level security whereas Issue Security Scheme
    enforces issue-level security. It is possible for you to grant access to view
    issues in a project and yet hide some of those issues from the user. However,
    the reverse is not possible, that is, one cannot grant access to certain selected
    issues when the user originally didn't have access to view the issues in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various tables involved in storing permission information in the JIRA database,
    along with the relations between them, can be depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving permissions on issues from a database](img/1803-10-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see here, both the Permission Schemes and Issue Security Schemes
    are related to a project via the `nodeassociation` table. Here, the **SOURCE_NODE_ENTITY**
    is **Project** and the corresponding **SOURCE_NODE_ID** holds the ID of the project.
    The **SINK_NODE_ENTITY** is `PermissionScheme` or `IssueSecurityScheme` depending
    on the scheme type. **SINK_NODE_ID** will point to the appropriate scheme. The
    **ASSOCIATION_TYPE** is `ProjectSheme`, in both the cases.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the permission schemes, there are multiple permissions predefined,
    such as, **Administer** **Project**, **Browse** **Project**, **Create** **Issues**,
    and so on. For each of these permissions, the `perm_type` and `perm_parameter`
    hold the type of the entity and its value that has the relevant permission. For
    example, the `perm_type` could be group, user, project role, and so on, and `perm_parameter`
    will be the group name, username, or the project role , respectively. Multiple
    permission types can be granted a single permission.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, issue security scheme holds a number of security levels that are
    stored in the `schemeissuesecuritylevels` table. Each of these security levels
    can have different entities in them, which are also defined using `type` and `parameter`
    values; in this case, the column names are `sec_type` and `sec_parameter`.
  prefs: []
  type: TYPE_NORMAL
- en: The Permission Scheme is enforced on an issue based on the project it resides
    in, whereas the security scheme is enforced by looking at the security level the
    issue is assigned. The security column in the `jiraissue` table holds this information.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how we can retrieve some of this information from an issue, based
    on the previous diagram.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is fairly easy to find out the Permission Scheme associated with a project
    with the help of the `nodeassociation` table, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, Issue Security Scheme can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The permissions parameters associated with a specific permission in a permission
    scheme, with an `id` value 9, can be easily retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sp.permission = 23` denotes `PROJECT_ADMIN` permission. The different
    permission types can be found in `com.atlassian.jira.security.Permissions` class.
    Here, the `perm_type` denotes whether the permission is granted to a group, user,
    or role; `perm_parameter` holds the name of the respective group, user, or role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, queries can be written to retrieve information on the issue security
    schemes. For example, the security levels and the security type and parameters
    for each level in a issue security scheme can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Writing more complex queries is outside the scope of the book but, hopefully,
    the previous schema diagram and the sample SQL diagrams give enough information
    to start with!
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving workflow details from a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other major information that people normally look for in the database is about
    workflows. What is the current status of an issue? How does one find out which
    workflow an issue is associated with? Where is the workflow XML stored in the
    database? In this recipe, we will take a quick tour of the tables related to workflows.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA workflows, as we have seen in the previous chapters, have statuses, steps,
    and transitions. There is always a one-to-one mapping between status and step
    and they are always kept in sync. Then, there are transitions which will move
    the issue from one step to another and, hence, from one status to another.
  prefs: []
  type: TYPE_NORMAL
- en: The workflows themselves are stored as XML files in the `jiraworkflows` table.
    JIRA processes these XMLs using the OSWorkflow APIs to retrieve the necessary
    information for each transition, step, and so on. Any draft workflows are stored
    in the `jiradraftworkflows` table.
  prefs: []
  type: TYPE_NORMAL
- en: The `jiraissue` table holds the ID of its current status and the status details
    are stored in the `issuestatus` table. We can use the status ID in the `jiraissue`
    table to retrieve the corresponding details from the `issuestatus` table.
  prefs: []
  type: TYPE_NORMAL
- en: '`jiraissue` also has another column, `workflow_id`, which points to the workflow
    the issue is associated with and the current step in the workflow the issue is
    in. The first bit of information, that is, the workflow an issue is associated
    with, is stored in the `os_wfentry` table. Here, the `workflow_id` will point
    to the ID column of the `os_wfentry` table. The second bit of information, that
    is, the current step associated with an issue, is stored in the `os_currentstep`
    table. Here, the `workflow_id` points to the `entry_id` column in the `os_currentstep`
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for every issue, there is an entry in the `os_wfentry` and `os_currentstep`
    tables. And the relations are: `jiraissue.WORKFLOW_ID == OS_WFENTRY.ID` and `jiraissue.WORKFLOW_ID
    == OS_CURRENTSTEP.ENTRY_ID`.'
  prefs: []
  type: TYPE_NORMAL
- en: There is another table `os_history` step, which holds all the history information
    of the steps an issue has gone through. Here, again, the `workflow_id` points
    to the `entry_id` column in the `os_historystep` table. From this table, we can
    retrieve information on how long an issue remained in a particular step or status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema diagram captures the important relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving workflow details from a database](img/1803-10-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The status of an issue, `DEMO-123`, can be retrieved by a simple query, as
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the workflow associated with an issue can be retrieved, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve the workflow XML for an issue using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The current step associated with an issue can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The history of workflow status (step) changes can be retrieved from the `os_historystep`,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Updating issue status in a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will quickly see how to update the status of an issue in
    the JIRA database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go through the previous recipe to understand the workflow related tables in
    JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the follow steps to update the status of an issue in JIRA:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the JIRA server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to JIRA database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `issuestatus` field in `jiraissue` table with the status you need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the `step_id` in the `os_currentstep` table with the step ID linked to
    the status you used in the previous step. The `step_id` can be found in the workflow
    XML alongside the step name within brackets, as shown in the following screenshot:![How
    to do it...](img/1803-10-14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, the status **Closed** in the JIRA default workflow is linked
    to the **Closed** step with an `id` value 6\. Now, the `step_id` can be updated
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we modify the `step_id` in `os_currentstep` where the `entry_id` is the
    same as the `workflow_id` in the `jiraissue` table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is very important as the step and status should always be in sync. Updating
    the status alone will change it on the issue but will prevent further workflow
    actions on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add entries in the `os_historystep` field if you want to keep track of the status
    changes. This is entirely optional. Leaving it out won't cause any issues except
    that the records won't be available for reporting at a later stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `os_currentstep_prev` and `os_historystep_prev` tables accordingly.
    These tables hold the ID of the previous record. This is again optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the changes and start JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do a full re-index by going to **Administration** | **System** | **Indexing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieving users and groups from a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When external user management is not turned **ON**, we can find all the information
    about JIRA users and their groups from the database by running a few simple SQL
    queries. In this recipe, we will see the various tables involved.
  prefs: []
  type: TYPE_NORMAL
- en: In versions prior to JIRA 4.3, user information is stored in the `userbase`
    table, the group information is stored in the `groupbase` table, and the details
    of which users belong to which groups are stored in the `membershipbase` table.
  prefs: []
  type: TYPE_NORMAL
- en: In those versions, user properties are stored using `PropertySet`, as we have
    seen earlier in one of the recipes (where we added an address against a user).
    There will be an entry for the user in the `propertyentry` table with the `entity_name`
    as `OSUser` and `entity_id` as the ID of the user in the `userbase` table. Examples
    of properties stored are full name and e-mail address and they are stored as String
    values in the `propertystring` table.
  prefs: []
  type: TYPE_NORMAL
- en: There is another table, `userassociation`, that holds the information about
    watching an issue and voting on an issue. In this table, the `source_name` column
    holds the unique username and `sink_node_id` holds the ID of the issue. `sink_node_entity`
    has the value `Issue` and `association_type` has values `WatchIssue` or `VoteIssue`,
    depending on the operation.
  prefs: []
  type: TYPE_NORMAL
- en: From version 4.3 onwards, JIRA uses **Embedded** **Crowd** as its user management
    framework. Here, the users are stored in the `cwd_user` table, groups in the `cwd_group`
    table, and the membership details in the `cwd_membership` table. It is possible
    to have group-user membership or group-group membership in versions 4.3+, and
    this information is also stored in the `cwd_membership` table. Also, as opposed
    to the previous versions, there are separate tables for storing attributes—`cwd_user_attributes`
    to store user attributes and `cwd_group_attributes` to store group attributes.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA versions 4.3+ also have the concept of user directories. A JIRA instance
    can have multiple directories and different directories can have the same name
    in it. The directory details are stored in the `cwd_directory` table and its attributes
    in the `cwd_directory_attribute` table. There are references in the `cwd_user`
    table and the `cwd_group` table, both with name `directory_id`, and pointing to
    the appropriate directory ID. The `cwd_directory_operation` table stores the available
    operations on a directory, based on user permissions.
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple users with the same name in different directories, JIRA
    will only recognize the user in the highest-priority directory. The priority is
    stored in the `directory_position` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table relations prior to 4.3 are too simple to draw ER diagrams from, hence
    we will draw one for 4.3+ versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving users and groups from a database](img/1803-10-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Watches and votes in JIRA versions 4.3+ work in the same way as in the previous
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the simple layout of table structure, it is quite easy to list the users,
    groups or their relationships by directly accessing the database. For example,
    prior to version 4.3, we can find all users in a group by simply running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In versions 4.3+, we can do the same, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here, we consider the directory as well, because we can have the same users
    and groups in different directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to version 4.3, the properties like full name and e-mail are stored and
    accessed from `propertystring` table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In versions 4.3+, these attributes are part of the `cwd_user` table, but there
    can be other attributes stored in the `cwd_user_attributes` table, such as, last
    login time, invalid password attempts, and so on, which are accessed as shown
    in the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In all the versions, users watching an issue can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, all the issues watched by a user can be retrieved as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: It is the same for votes, except that the association type will be `VoteIssue`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Change history in a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wind up this chapter, let us touch up on the change history tables
    as well. Change histories on issues hold important information on what was changed
    and when. It is sometimes very useful for reporting and, sometimes, we find ourselves
    manually adding change histories in the database to keep record of the changes
    we made via SQL - for example, updating the status of an issue via SQL as we saw
    earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A set of changes happening on an issue at a single point of time are grouped
    together to form a change group. There is an entry for each such change group
    in the `changegroup` table, with the information about the issue on which the
    change is made, the user who makes the change, and the time at which the changes
    happened.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is an entry for each of those individual changes in the `changeitem`
    table, all pointing to the respective `changegroup`. The `changeitem` table holds
    information on what was actually changed—the old value and the new value. There
    can be both numerical and textual representation in some cases like status where
    there is a human-readable text (`status` `name`) as well as a unique ID (`status_id`).
    They are stored in `oldvalue` and `oldstring`, and `newvalue` and `newstring`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us have a look at both retrieving change histories and adding them. For
    a given issue, we can find out the all changes that happened on it using a simple
    join, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: It is quite easy to modify this to filter out changes made by a user or during
    a particular period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us quickly have a look at adding a new change on an issue via the
    database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the JIRA server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the JIRA database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entry in the `changegroup` table, with the correct ID of the issue,
    author name, and created time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the ID value (`12345)` is larger than the `max(ID)` in the table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Insert a change item for this change group. Let us consider the status change
    we made in the earlier recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `groupid` here is same as the ID attribute in *Step* *3*. The
    third column holds the field type, which could be JIRA or custom. For all the
    standard JIRA fields, such as, `summary`, `status`, and so on, the field type
    is JIRA. For custom fields, we use the field type as `custom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For fields such as `status`, there is a textual representation (the name) and
    there is a unique ID; hence, both `oldvalue` and `oldstring` columns are populated.
    The same is the case with the `newvalue` and `newstring` columns. For fields such
    as `Summary`, only the `oldstring` and `newstring` columns needs to be populated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, also make sure the `id(11111)` is larger than `max(id)` in the table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update the `sequence_value_item` table to hold a higher value in the `seq_id`
    column for the `ChangeGroup` and `ChangeItem` entities. In the previous case,
    we can give a value `12346` for `ChangeGroup` and `11112` for `ChangeItem`. Ofbiz
    normally allocates IDs in batches of ten, so the `SEQ_ID` is the next available
    ID, rounded up to the nearest value **10**, though adding 1 should be enough.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This step is required whenever a row is inserted into any of the JIRA tables.
    The `seq_id` value in the `sequence_value_item` table should be updated for the
    entity where the new row is added. The new sequence value should be atleast one
    more than the `max(id)` of the entity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Commit the changes and start JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-index the JIRA instance by going to **Administration** | **System** | **Indexing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
