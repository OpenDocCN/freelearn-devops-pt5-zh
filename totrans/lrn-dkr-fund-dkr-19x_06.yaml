- en: Creating and Managing Container Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理容器镜像
- en: In the previous chapter, we learned what containers are and how to run, stop,
    remove, list, and inspect them. We extracted the logging information of some containers,
    ran other processes inside an already running container, and finally, we dived
    deep into the anatomy of containers. Whenever we ran a container, we created it
    using a container image. In this chapter, we will be familiarizing ourselves with
    these container images. We will learn in detail what they are, how to create them,
    and how to distribute them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了容器是什么，以及如何运行、停止、删除、列出和检查它们。我们提取了部分容器的日志信息，在已运行的容器内运行了其他进程，最后深入了解了容器的结构。每当我们运行容器时，都会使用容器镜像创建它。在本章中，我们将熟悉这些容器镜像。我们将详细了解它们是什么，如何创建它们以及如何分发它们。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are images?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: Creating images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镜像
- en: 'Lift and shift: Containerizing a legacy app'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升与迁移：将遗留应用程序容器化
- en: Sharing or shipping images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享或传输镜像
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够执行以下操作：
- en: Name three of the most important characteristics of a container image.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举出容器镜像的三个最重要特点。
- en: Create a custom image by interactively changing the container layer and committing
    it.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交互式更改容器层并提交来创建自定义镜像。
- en: Author a simple `Dockerfile` to generate a custom image.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的 `Dockerfile` 以生成自定义镜像。
- en: Export an existing image using `docker image save` and import it into another
    Docker host using `docker image load`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker image save` 导出现有镜像，并使用 `docker image load` 将其导入到另一个 Docker 主机中。
- en: Write a two-step Dockerfile that minimizes the size of the resulting image by
    only including the resulting artifacts in the final image.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个两步的 Dockerfile，通过仅在最终镜像中包含生成的产物来最小化结果镜像的大小。
- en: What are images?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: In Linux, everything is a file. The whole operating system is basically a filesystem
    with files and folders stored on the local disk. This is an important fact to
    remember when looking at what container images are. As we will see, an image is
    basically a big tarball containing a filesystem. More specifically, it contains
    a layered filesystem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，一切都是文件。整个操作系统基本上是一个包含文件和文件夹的文件系统，存储在本地磁盘上。记住这一点对于理解容器镜像的概念非常重要。正如我们将看到的，镜像基本上是一个包含文件系统的大
    tar 包。更具体地说，它包含了一个分层的文件系统。
- en: The layered filesystem
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层文件系统
- en: 'Container images are templates from which containers are created. These images are
    not made up of just one monolithic block but are composed of many layers. The
    first layer in the image is also called the base layer. We can see this in the
    following graphic:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是用于创建容器的模板。这些镜像并非由一个单一的整体块组成，而是由许多层构成。镜像中的第一层也称为基础层。我们可以在以下图示中看到这一点：
- en: '![](img/f648f501-f54d-4794-ae3f-c17ec8f78b6c.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f648f501-f54d-4794-ae3f-c17ec8f78b6c.png)'
- en: The image as a stack of layers
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像作为一层一层的堆栈
- en: Each individual layer contains files and folders. Each layer only contains the
    changes to the filesystem with respect to the underlying layers. Docker uses a
    Union filesystem—as discussed in [Chapter 3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering
    Containers — *to create a virtual filesystem out of the set of layers. A storage
    driver handles the details regarding the way these layers interact with each other.
    Different storage drivers are available that have advantages and disadvantages
    in different situations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的层包含文件和文件夹。每一层只包含相对于底层的文件系统的变化。Docker 使用联合文件系统——如[第 3 章](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml)《掌握容器》中所讨论的——通过将这些层结合起来，创建了一个虚拟文件系统。存储驱动程序处理这些层如何相互作用的详细信息。在不同的情况下，存在具有不同优缺点的存储驱动程序。
- en: The layers of a container image are all immutable. Immutable means that once
    generated, the layer cannot ever be changed. The only possible operation affecting
    the layer is its physical deletion. This immutability of layers is important because
    it opens up a tremendous amount of opportunities, as we will see.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的各个层都是不可变的。不可变意味着一旦生成，该层就永远不能改变。影响该层的唯一操作是物理删除它。层的不可变性非常重要，因为它为我们提供了巨大的机会，正如我们将看到的那样。
- en: 'In the following screenshot, we can see what a custom image for a web application,
    using Nginx as a web server, could look like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到一个用于 Web 应用程序的自定义镜像，使用 Nginx 作为 Web 服务器，可能是这样的：
- en: '![](img/48c83b9e-fef1-45d9-a084-c1076f3e396d.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48c83b9e-fef1-45d9-a084-c1076f3e396d.png)'
- en: A sample custom image based on Alpine and Nginx
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Alpine 和 Nginx 的示例自定义镜像
- en: Our base layer here consists of the **Alpine Linux** distribution. Then, on
    top of that, we have an **Add Nginx** layer where Nginx is added on top of Alpine.
    Finally, the third layer contains all the files that make up the web application,
    such as HTML, CSS, and JavaScript files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础层由**Alpine Linux**发行版组成。然后，在它之上，我们有一个**Add Nginx**层，Nginx 被添加到 Alpine 上。最后，第三层包含构成
    Web 应用程序的所有文件，如 HTML、CSS 和 JavaScript 文件。
- en: As has been said previously, each image starts with a base image. Typically,
    this base image is one of the official images found on Docker Hub, such as a Linux
    distro, Alpine, Ubuntu, or CentOS. However, it is also possible to create an image
    from scratch.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个镜像都以一个基础镜像开始。通常，这个基础镜像是 Docker Hub 上找到的官方镜像之一，如 Linux 发行版、Alpine、Ubuntu
    或 CentOS。然而，也可以从头开始创建一个镜像。
- en: Docker Hub is a public registry for container images. It is a central hub ideally
    suited for sharing public container images.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是一个公开的容器镜像注册中心。它是一个理想的中心平台，非常适合共享公共容器镜像。
- en: Each layer only contains the delta of changes in regard to the previous set
    of layers. The content of each layer is mapped to a special folder on the host
    system, which is usually a subfolder of `/var/lib/docker/`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层只包含与上一层相比的差异。每一层的内容都映射到主机系统上的一个特殊文件夹，通常是`/var/lib/docker/`的子文件夹。
- en: Since layers are immutable, they can be cached without ever becoming stale.
    This is a big advantage, as we will see.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于层是不可变的，它们可以被缓存且永不失效。这是一个很大的优势，正如我们将看到的那样。
- en: The writable container layer
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可写容器层
- en: 'As we have discussed, a container image is made of a stack of immutable or
    read-only layers. When the Docker Engine creates a container from such an image,
    it adds a writable container layer on top of this stack of immutable layers. Our
    stack now looks as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，容器镜像由一系列不可变或只读层组成。当 Docker 引擎从这样的镜像创建容器时，它会在这些不可变层的堆栈上添加一个可写的容器层。我们的堆栈现在看起来如下：
- en: '![](img/35fc8834-7fa6-42ad-bdd6-7979a1878438.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35fc8834-7fa6-42ad-bdd6-7979a1878438.png)'
- en: The writable container layer
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可写容器层
- en: 'The **Container Layer** is marked as read/write. Another advantage of the immutability
    of image layers is that they can be shared among many containers created from
    this image. All that is needed is a thin, writable container layer for each container,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器层**被标记为可读写。镜像层的不可变性带来的另一个好处是，它们可以在许多从该镜像创建的容器之间共享。所需的只是每个容器的一个薄的、可写的容器层，如下图所示：'
- en: '![](img/0e32cfeb-d02b-4397-8ead-f1e066194ef3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e32cfeb-d02b-4397-8ead-f1e066194ef3.png)'
- en: Multiple containers sharing the same image layers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多个容器共享相同的镜像层
- en: This technique, of course, results in a tremendous reduction in the resources
    that are consumed. Furthermore, this helps to decrease the loading time of a container
    since only a thin container layer has to be created once the image layers have
    been loaded into memory, which only happens for the first container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种技术极大地减少了资源消耗。此外，它还帮助减少了容器的加载时间，因为一旦镜像层加载到内存中（这只会发生在第一个容器上），只需创建一个薄的容器层即可。
- en: Copy-on-write
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写时复制
- en: 'Docker uses the copy-on-write technique when dealing with images. Copy-on-write
    is a strategy for sharing and copying files for maximum efficiency. If a layer
    uses a file or folder that is available in one of the low-lying layers, then it
    just uses it. If, on the other hand, a layer wants to modify, say, a file from
    a low-lying layer, then it first copies this file up to the target layer and then
    modifies it. In the following screenshot, we can see a glimpse of what this means:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在处理镜像时使用了写时复制技术。写时复制是一种共享和复制文件的策略，以最大化效率。如果某一层使用了低层中可用的文件或文件夹，那么它就直接使用这个文件。如果，另一方面，一层想要修改一个来自低层的文件，它会先将该文件复制到目标层，并进行修改。在以下截图中，我们可以看到这一过程的简要示意：
- en: '![](img/7129ffa2-5290-455b-847a-1ae41c2aee0f.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7129ffa2-5290-455b-847a-1ae41c2aee0f.png)'
- en: Docker image using copy-on-write
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用写时复制的 Docker 镜像
- en: The second layer wants to modify **File 2**, which is present in the **Base
    Layer**. Thus, it copies it up and then modifies it. Now, let's say that we're sitting in
    the top layer of the preceding screenshot. This layer will use **File 1** from
    the **Base Layer** and **File 2** and **File 3** from the second layer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层想要修改**文件2**，该文件存在于**基础层**中。因此，它将文件复制上来并进行修改。现在，假设我们位于前面截图的最上层。这个层将使用**基础层**中的**文件1**和第二层中的**文件2**和**文件3**。
- en: Graph drivers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形驱动程序
- en: Graph drivers are what enable the Union filesystem. Graph drivers are also called
    storage drivers and are used when dealing with layered container images. A graph
    driver consolidates multiple image layers into a root filesystem for the mount
    namespace of the container. Or, put differently, the driver controls how images
    and containers are stored and managed on the Docker host.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图形驱动程序使联合文件系统成为可能。图形驱动程序也被称为存储驱动程序，通常用于处理分层的容器镜像。图形驱动程序将多个镜像层合并成容器挂载命名空间的根文件系统。换句话说，驱动程序控制着如何在Docker主机上存储和管理镜像及容器。
- en: Docker supports several different graph drivers using a pluggable architecture.
    The preferred driver is `overlay2`, followed by `overlay`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持使用可插拔架构的多种不同图形驱动程序。首选驱动程序是`overlay2`，其次是`overlay`。
- en: Creating images
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建镜像
- en: There are three ways to create a new container image on your system. The first
    one is by interactively building a container that contains all the additions and
    changes one desires, and then committing those changes into a new image. The second,
    and most important, way is to use a `Dockerfile` to describe what's in the new
    image, and then build the image using that `Dockerfile` as a manifest. Finally,
    the third way of creating an image is by importing it into the system from a tarball.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式可以在系统上创建一个新的容器镜像。第一种是通过交互式构建一个容器，该容器包含所有所需的附加内容和更改，然后将这些更改提交到一个新镜像中。第二种，也是最重要的方式，是使用`Dockerfile`来描述新镜像中的内容，然后使用该`Dockerfile`作为清单来构建镜像。最后，第三种方式是通过从tarball导入镜像到系统中。
- en: Now, let's look at these three ways in detail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看这三种方式。
- en: Interactive image creation
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式镜像创建
- en: The first way we can create a custom image is by interactively building a container.
    That is, we start with a base image that we want to use as a template and run
    a container of it interactively. Let's say that this is the Alpine image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义镜像的第一种方式是通过交互式构建容器。也就是说，我们从一个基础镜像开始，作为模板来使用，并交互式地运行它的容器。假设这就是Alpine镜像。
- en: 'To interactively create an image follow along:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随步骤交互式创建镜像：
- en: 'The command to run the container would be as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行容器的命令如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command runs a container based on the `alpine:3.10` image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令基于`alpine:3.10`镜像运行一个容器。
- en: We run the container interactively with an attached **teletypewriter** (**TTY**)
    using the `-it` parameter, name it `sample` with the `--name` parameter, and—finally—run
    a shell inside the container using `/bin/sh`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`-it`参数与附加的**电传打字机**（**TTY**）交互式运行容器，使用`--name`参数命名为`sample`，最后在容器内使用`/bin/sh`运行一个shell。
- en: 'In the Terminal window where you run the preceding command, you should see
    something similar to this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令的终端窗口中，你应该会看到类似这样的内容：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, the `alpine` container does not have the `ping` tool installed.
    Let's assume we want to create a new custom image that has `ping` installed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`alpine`容器并未安装`ping`工具。假设我们想要创建一个包含`ping`工具的自定义新镜像。
- en: 'Inside the container, we can then run the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内，我们可以运行以下命令：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This uses the `apk` Alpine package manager to install the `iputils` library,
    of which `ping` is a part. The output of the preceding command should look approximately
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`apk`Alpine包管理器安装`iputils`库，其中`ping`是其一部分。上面命令的输出应该大致如下所示：
- en: '![](img/7095041c-9ad2-4bfc-bc0e-940fd1351b23.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7095041c-9ad2-4bfc-bc0e-940fd1351b23.png)'
- en: Installing `ping` on Alpine
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Alpine上安装`ping`
- en: 'Now, we can indeed use `ping`, as the following code snippet shows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们确实可以使用`ping`，如下所示的代码片段：
- en: '![](img/914c8ee9-964b-49b0-afe2-e1b0dd28d57b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/914c8ee9-964b-49b0-afe2-e1b0dd28d57b.png)'
- en: Using ping from within the container
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内使用ping
- en: Once we have finished our customization, we can quit the container by typing `exit` at
    the prompt.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成自定义工作，可以在提示符下输入`exit`退出容器。
- en: 'If we now list all containers with the `ls -a` Docker container, we can see
    that our sample container has a status of `Exited`, but still exists on the system,
    as shown in the following code block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在列出所有容器，并使用`ls -a` Docker 容器命令，我们可以看到我们的示例容器的状态是`Exited`，但仍然存在于系统中，如下所示：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to see what has changed in our container in relation to the base
    image, we can use the `docker container diff` command, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想查看相对于基础镜像，我们的容器发生了哪些变化，可以使用`docker container diff`命令，如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should present a list of all modifications done on the filesystem
    of the container, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该呈现对容器文件系统所做的所有修改的列表，如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have shortened the preceding output for better readability. In the list, `A` stands
    for *added*, and `C` stands for *changed*. If we had any deleted files, then those
    would be prefixed with a **`D`**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地阅读，我们已将前面的输出缩短。在列表中，`A`代表*添加*，`C`代表*更改*。如果我们有任何删除的文件，它们将以**`D`**为前缀。
- en: 'We can now use the `docker container commit` command to persist our modifications
    and create a new image from them, like this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`docker container commit`命令来持久化我们的修改，并从中创建一个新镜像，如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the preceding command, we have specified that the new image will be called `my-alpine`.
    The output generated by the preceding command corresponds to the ID of the newly
    generated image.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的命令，我们已指定新镜像的名称为`my-alpine`。前面命令生成的输出对应的是新生成的镜像的 ID。
- en: 'We can verify this by listing all images on our system, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过列出系统上所有的镜像来验证这一点，如下所示：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see this image ID (shortened) as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个镜像的 ID（简化版），如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the image named `my-alpine` has the expected ID of `44bca4141130` and
    automatically got a `latest` tag assigned. This happens since we did not explicitly
    define a tag ourselves. In this case, Docker always defaults to the `latest` tag.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到名为`my-alpine`的镜像具有预期的 ID `44bca4141130`，并且自动分配了`latest`标签。因为我们没有显式定义标签，所以
    Docker 会默认使用`latest`标签。
- en: 'If we want to see how our custom image has been built, we can use the `history `command
    as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想查看我们的自定义镜像是如何构建的，可以使用`history`命令，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will print a list of the layers our image consists of, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出我们镜像所包含的所有层的列表，如下所示：
- en: '![](img/c399a38d-20a1-48b9-8210-4831f035b78e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c399a38d-20a1-48b9-8210-4831f035b78e.png)'
- en: History of the my-alpine Docker image
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: my-alpine Docker 镜像的历史
- en: The first layer in the preceding output is the one that we just created by adding
    the `iputils` package.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出的第一层就是我们刚刚通过添加`iputils`包创建的那一层。
- en: Using Dockerfiles
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfiles
- en: 'Manually creating custom images, as shown in the previous section of this chapter,
    is very helpful when doing exploration, creating prototypes, or authoring feasibility
    studies. But it has a serious drawback: it is a manual process and thus is not
    repeatable or scalable. It is also as error-prone as any other task executed manually
    by humans. There must be a better way.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建自定义镜像，如本章前面部分所示，在进行探索、创建原型或撰写可行性研究时非常有帮助。但它有一个严重的缺点：这是一个手动过程，因此不可重复或不可扩展。它也和任何其他由人类手动执行的任务一样容易出错。必须有更好的方法。
- en: This is where the so-called `Dockerfile` comes into play. A `Dockerfile` is
    a text file that is usually literally called `Dockerfile`. It contains instructions
    on how to build a custom container image. It is a declarative way of building
    images.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的`Dockerfile`的作用。`Dockerfile`是一个文本文件，通常被称为`Dockerfile`。它包含了如何构建自定义容器镜像的指令。这是一种声明式的构建镜像方式。
- en: '**De****clarative versus imperative**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明式与命令式**：'
- en: In computer science, in general, and with Docker specifically, one often uses
    a declarative way of defining a task. One describes the expected outcome and lets
    the system figure out how to achieve this goal, rather than giving step-by-step
    instructions to the system on how to achieve this desired outcome. The latter
    is an imperative approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，一般而言，特别是在 Docker 中，通常使用声明式方式来定义任务。我们描述预期的结果，并让系统决定如何实现这一目标，而不是给系统提供一步步的指令来达到这一目标。后者是一种命令式方法。
- en: 'Let''s look at a sample `Dockerfile`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例`Dockerfile`，如下所示：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a `Dockerfile` as it is used to containerize a Python 2.7 application.
    As we can see, the file has six lines, each starting with a keyword such as `FROM`, `RUN`,
    or `COPY`. It is a convention to write the keywords in all caps, but that is not
    a must.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `Dockerfile`，用于将一个 Python 2.7 应用程序容器化。如我们所见，文件有六行，每行以关键字如 `FROM`、`RUN`
    或 `COPY` 开头。尽管按惯例将关键字写成大写字母，但这并不是强制要求。
- en: 'Each line of the `Dockerfile` results in a layer in the resulting image. In
    the following screenshot, the image is drawn upside down compared to the previous
    illustrations in this chapter, showing an image as a stack of layers. Here, the
    **Base Layer** is shown on top. Don''t let yourself be confused by this. In reality,
    the base layer is always the lowest layer in the stack:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行 `Dockerfile` 都会生成一个最终镜像中的层。在下图中，镜像与本章前面的插图不同，显示为从下到上的一堆层。这里，**基础层** 显示在顶部。不要让自己被这个搞混，实际上基础层总是堆叠中的最低层：
- en: '![](img/3f4c11dd-4fed-478b-b229-cdc834633c62.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f4c11dd-4fed-478b-b229-cdc834633c62.png)'
- en: The relation of Dockerfile and layers in an image
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 和镜像中的层的关系
- en: Now, let's look at the individual keywords in more detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看各个关键字。
- en: The FROM keyword
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FROM` 关键字'
- en: 'Every `Dockerfile` starts with the `FROM` keyword. With it, we define which
    base image we want to start building our custom image from. If we want to build
    starting with CentOS 7, for example, we would have the following line in the `Dockerfile`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Dockerfile` 都以 `FROM` 关键字开始。通过它，我们定义了从哪个基础镜像开始构建我们的自定义镜像。例如，如果我们想从 CentOS
    7 开始构建，我们会在 `Dockerfile` 中写下如下内容：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On Docker Hub, there are curated or official images for all major Linux distros,
    as well as for all important development frameworks or languages, such as Python,
    Node.js, Ruby, Go, and many more. Depending on our needs, we should select the
    most appropriate base image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Hub 上，有适用于所有主要 Linux 发行版的官方或精选镜像，也有许多重要的开发框架或语言的镜像，如 Python、Node.js、Ruby、Go
    等等。根据我们的需求，我们应该选择最合适的基础镜像。
- en: For example, if I want to containerize a Python 3.7 application, I might want
    to select the relevant official `python:3.7` image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，如果我想将一个 Python 3.7 应用程序容器化，我可能会选择相关的官方 `python:3.7` 镜像。
- en: 'If we really want to start from scratch, we can also use the following statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想从零开始，我们也可以使用以下语句：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is useful in the context of building super-minimal images that only—for
    example—contain a single binary: the actual statically linked executable, such
    as `Hello-World`. The `scratch` image is literally an empty base image.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建超简 minimal 镜像时非常有用，这些镜像只包含——例如——一个二进制文件：实际的静态链接可执行文件，如 `Hello-World`。`scratch`
    镜像字面上就是一个空的基础镜像。
- en: '`FROM scratch` is a `no-op` in the `Dockerfile`, and as such does not generate
    a layer in the resulting container image.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM scratch` 在 `Dockerfile` 中是一个“空操作”，因此不会在最终的容器镜像中生成层。'
- en: The RUN keyword
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RUN` 关键字'
- en: 'The next important keyword is `RUN`. The argument for `RUN` is any valid Linux
    command, such as the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的关键字是`RUN`。`RUN`的参数是任何有效的 Linux 命令，例如以下内容：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command is using the `yum` CentOS package manager to install
    the `wget` package into the running container. This assumes that our base image
    is CentOS or **Red Hat Enterprise Linux** (**RHEL**). If we had Ubuntu as our
    base image, then the command would look similar to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用 `yum` CentOS 包管理器将 `wget` 包安装到运行中的容器中。这假设我们的基础镜像是 CentOS 或 **Red Hat
    Enterprise Linux**（**RHEL**）。如果我们的基础镜像是 Ubuntu，那么命令看起来会类似于以下内容：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It would look like this because Ubuntu uses `apt-get` as a package manager.
    Similarly, we could define a line with `RUN`, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的，因为 Ubuntu 使用 `apt-get` 作为包管理器。类似地，我们也可以定义一行使用 `RUN`，如下所示：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could also do this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这么做：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the former creates an `/app` folder in the container and navigates to
    it, and the latter untars a file to a given location. It is completely fine, and even recommended,
    for you to format a Linux command using more than one physical line, such as this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前者在容器中创建一个`/app`文件夹并切换到该目录，后者则将一个文件解压到指定位置。完全可以，而且建议将 Linux 命令格式化为多行，例如这样：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we use more than one line, we need to put a backslash (`\`) at the end of
    the lines to indicate to the shell that the command continues on the next line.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用多行命令，我们需要在行尾加上反斜杠（`\`），以指示命令在下一行继续。
- en: Try to find out what the preceding command does.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出前面的命令是做什么的。
- en: The COPY and ADD keywords
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`COPY` 和 `ADD` 关键字'
- en: The `COPY` and `ADD` keywords are very important since, in the end, we want to
    add some content to an existing base image to make it a custom image. Most of
    the time, these are a few source files of—say—a web application, or a few binaries
    of a compiled application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`和`ADD`关键字非常重要，因为最终我们希望向现有的基础镜像中添加一些内容，使其成为一个自定义镜像。大多数时候，这些内容可能是一个网页应用程序的源文件，或者是一个已编译应用程序的几个二进制文件。'
- en: These two keywords are used to copy files and folders from the host into the
    image that we're building. The two keywords are very similar, with the exception
    that the `ADD` keyword also lets us copy and unpack TAR files, as well as providing
    a URL as a source for the files and folders to copy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个关键字用于将文件和文件夹从主机复制到我们正在构建的镜像中。这两个关键字非常相似，唯一的区别是，`ADD`关键字还允许我们复制并解压TAR文件，并且可以提供一个URL作为要复制的文件和文件夹的来源。
- en: 'Let''s look at a few examples of how these two keywords can be used, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些如何使用这两个关键字的示例，具体如下：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding lines of code, the following applies:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，以下内容适用：
- en: The first line copies all files and folders from the current directory recursively
    to the `app` folder inside the container image.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将当前目录中的所有文件和文件夹递归地复制到容器镜像中的`app`文件夹。
- en: The second line copies everything in the `web` subfolder to the target folder, `/app/web`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行将`web`子文件夹中的所有内容复制到目标文件夹`/app/web`。
- en: The third line copies a single file, `sample.txt`, into the target folder, `/data`,
    and at the same time, renames it to `my-sample.txt`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行将一个单独的文件`sample.txt`复制到目标文件夹`/data`，并同时将其重命名为`my-sample.txt`。
- en: The fourth statement unpacks the `sample.tar `file into the target folder, `/app/bin`
    .
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四条语句将`sample.tar`文件解压到目标文件夹`/app/bin`。
- en: Finally, the last statement copies the remote file, `sample.txt`, into the target
    file, `/data`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一条语句将远程文件`sample.txt`复制到目标文件`/data`。
- en: 'Wildcards are allowed in the source path. For example, the following statement
    copies all files starting with `sample` to the `mydir` folder inside the image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 源路径中允许使用通配符。例如，以下语句将所有以`sample`开头的文件复制到镜像内部的`mydir`文件夹：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From a security perspective, it is important to know that, by default, all
    files and folders inside the image will have a **user ID** (**UID**) and a **group
    ID** (**GID**) of `0`. The good thing is that for both `ADD` and `COPY`, we can
    change the ownership that the files will have inside the image using the optional `--chown` flag,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，默认情况下，镜像内部的所有文件和文件夹将具有**用户ID**（**UID**）和**组ID**（**GID**）为`0`。幸运的是，对于`ADD`和`COPY`，我们可以使用可选的`--chown`标志来更改文件在镜像内的所有权，具体如下：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding statement will copy all files starting with the name `web` and
    put them into the `/app/data` folder in the image, and at the same time assign
    user `11` and group `22` to these files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将复制所有以`web`开头的文件，并将它们放入镜像中的`/app/data`文件夹，同时将用户`11`和组`22`赋给这些文件。
- en: Instead of numbers, one could also use names for the user and group, but then
    these entities would have to be already defined in the root filesystem of the
    image at `/etc/passwd` and `/etc/group` respectively; otherwise, the build of
    the image would fail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字，还可以使用用户名和组名，但这些实体必须已经在镜像的根文件系统中的`/etc/passwd`和`/etc/group`中定义；否则，镜像的构建会失败。
- en: The WORKDIR keyword
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WORKDIR`关键字'
- en: 'The `WORKDIR` keyword defines the working directory or context that is used
    when a container is run from our custom image. So, if I want to set the context
    to the `/app/bin` folder inside the image, my expression in the `Dockerfile` would
    have to look as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`关键字定义了在从我们自定义的镜像运行容器时使用的工作目录或上下文。所以，如果我想将上下文设置为镜像内部的`/app/bin`文件夹，我在`Dockerfile`中的表达式应该如下所示：'
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All activity that happens inside the image after the preceding line will use
    this directory as the working directory. It is very important to note that the
    following two snippets from a `Dockerfile` are not the same:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行之后发生的所有活动都将使用这个目录作为工作目录。需要特别注意的是，以下两个`Dockerfile`的代码片段并不相同：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compare the preceding code with the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码与以下代码进行比较：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The former will create the file in the root of the image filesystem, while the
    latter will create the file at the expected location in the `/app/bin` folder.
    Only the `WORKDIR` keyword sets the context across the layers of the image. The `cd` command
    alone is not persisted across layers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前者将在镜像文件系统的根目录下创建文件，而后者将在 `/app/bin` 文件夹的预期位置创建文件。只有 `WORKDIR` 关键字在镜像的各个层之间设置了上下文。单独使用
    `cd` 命令不会在层之间保持。
- en: The CMD and ENTRYPOINT keywords
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD 和 ENTRYPOINT 关键字
- en: The `CMD` and `ENTRYPOINT` keywords are special. While all other keywords defined for
    a `Dockerfile` are executed at the time the image is built by the Docker builder,
    these two are actually definitions of what will happen when a container is started
    from the image we define. When the container runtime starts a container, it needs
    to know what the process or application will be that has to run inside that container.
    That is exactly what `CMD` and `ENTRYPOINT` are used for—to tell Docker what the
    start process is and how to start that process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 和 `ENTRYPOINT` 关键字是特殊的。虽然所有其他为 `Dockerfile` 定义的关键字在 Docker 构建器构建镜像时被执行，但这两个实际上是定义当从我们定义的镜像启动容器时会发生什么。当容器运行时启动容器时，它需要知道容器内部将要运行的进程或应用程序。这正是
    `CMD` 和 `ENTRYPOINT` 的作用——告诉 Docker 启动过程是什么，以及如何启动该过程。'
- en: Now, the differences between `CMD` and `ENTRYPOINT` are subtle, and honestly,
    most users don't fully understand them or use them in the intended way. Luckily,
    in most cases, this is not a problem and the container will run anyway; it's just
    the handling of it that is not as straightforward as it could be.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`CMD` 和 `ENTRYPOINT` 之间的区别是微妙的，老实说，大多数用户并没有完全理解它们，也没有按照预期的方式使用它们。幸运的是，在大多数情况下，这不是问题，容器还是会正常运行；只是处理方式没有预期的那样直观。
- en: 'To better understand how to use the two keywords, let''s analyze what a typical
    Linux command or expression looks like. Let''s take the `ping` utility as an example,
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用这两个关键字，我们来分析一下典型的 Linux 命令或表达式是什么样的。我们以 `ping` 工具为例，如下所示：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding expression, `ping` is the command and `-c 3 8.8.8.8` are the
    parameters to this command. Let''s look at another expression here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，`ping` 是命令，`-c 3 8.8.8.8` 是该命令的参数。我们来看看另一个表达式：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, in the preceding expression, `wget` is the command and `-O - http://example.com/downloads/script.sh `are
    the parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，在前面的表达式中，`wget` 是命令，`-O - http://example.com/downloads/script.sh` 是参数。
- en: 'Now that we have dealt with this, we can get back to `CMD` and `ENTRYPOINT`. `ENTRYPOINT` is
    used to define the command of the expression, while `CMD` is used to define the
    parameters for the command. Thus, a `Dockerfile` using Alpine as the base image
    and defining `ping` as the process to run in the container could look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经处理了这个问题，我们可以回到 `CMD` 和 `ENTRYPOINT`。`ENTRYPOINT` 用于定义表达式中的命令，而 `CMD` 用于定义命令的参数。因此，使用
    Alpine 作为基础镜像并将 `ping` 定义为容器中运行的进程的 `Dockerfile` 可能如下所示：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For both `ENTRYPOINT` and `CMD`, the values are formatted as a JSON array of
    strings, where the individual items correspond to the tokens of the expression
    that are separated by whitespace. This is the preferred way of defining `CMD` and `ENTRYPOINT`.
    It is also called the *exec* form.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ENTRYPOINT` 和 `CMD`，它们的值格式化为字符串的 JSON 数组，其中每个项对应于表达式中由空格分隔的令牌。这是定义 `CMD`
    和 `ENTRYPOINT` 的首选方式，也称为 *exec* 形式。
- en: 'Alternatively, one can also use what''s called the shell form, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，也可以使用所谓的 shell 形式，如下所示：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now build an image called `pinger` from the preceding `Dockerfile`,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从前面的 `Dockerfile` 构建一个名为 `pinger` 的镜像，操作如下：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we can run a container from the `pinger` image we just created, like
    this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从刚刚创建的 `pinger` 镜像运行一个容器，像这样：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The beauty of this is that I can now override the `CMD` part that I have defined
    in the `Dockerfile` (remember, it was `["-c", "3","8.8.8.8"]`) when I create a
    new container by adding the new values at the end of the `docker container run` expression,
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，我现在可以在创建新容器时，通过在 `docker container run` 表达式的末尾添加新值来覆盖我在 `Dockerfile`
    中定义的 `CMD` 部分（记得它是 `["-c", "3","8.8.8.8"]`），像这样：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will now cause the container to ping the loopback for 5 seconds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就会导致容器进行 5 秒钟的回环 ping 操作。
- en: 'If we want to override what''s defined in the `ENTRYPOINT` in the `Dockerfile`,
    we need to use the `--entrypoint` parameter in the `docker container run` expression.
    Let''s say we want to execute a shell in the container instead of the `ping` command.
    We could do so by using the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要覆盖在`Dockerfile`中定义的`ENTRYPOINT`，我们需要在`docker container run`表达式中使用`--entrypoint`参数。假设我们想要在容器中执行一个shell，而不是`ping`命令。我们可以通过以下命令来实现：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will then find ourselves inside the container. Type `exit` to leave the container.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就会进入容器内部。输入`exit`可以退出容器。
- en: 'As I already mentioned, we do not necessarily have to follow best practices
    and define the command through `ENTRYPOINT` and the parameters through `CMD`;
    we can instead enter the whole expression as a value of `CMD` and it will work,
    as shown in the following code block:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们不一定非要遵循最佳实践，通过`ENTRYPOINT`定义命令，并通过`CMD`定义参数；我们可以直接将整个表达式作为`CMD`的值，这样也能工作，具体示例如下所示：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, I have even used the shell form to define the `CMD`. But what does really
    happen in this situation where `ENTRYPOINT` is undefined? If you leave `ENTRYPOINT` undefined,
    then it will have the default value of `/bin/sh -c`, and whatever the value of `CMD`
    is will be passed as a string to the shell command. The preceding definition would
    thereby result in entering the following code to run the process inside the container:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我甚至使用了shell形式来定义`CMD`。但在这种`ENTRYPOINT`未定义的情况下，究竟发生了什么呢？如果你将`ENTRYPOINT`保持为空，它将默认值为`/bin/sh
    -c`，并且`CMD`的值将作为字符串传递给shell命令。上述定义将导致进入以下代码来在容器中运行进程：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Consequently, `/bin/sh` is the main process running inside the container, and
    it will start a new child process to run the `wget` utility.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`/bin/sh`是容器内部运行的主要进程，它将启动一个新的子进程来运行`wget`工具。
- en: A complex Dockerfile
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个复杂的Dockerfile
- en: 'We have discussed the most important keywords commonly used in Dockerfiles.
    Let''s look at a realistic, and somewhat complex example of a `Dockerfile`. The
    interested reader might note that it looks very similar to the first `Dockerfile`
    that we presented in this chapter. Here is the content:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Dockerfile中常用的最重要的关键字。接下来，让我们看一个现实的、稍微复杂一些的`Dockerfile`示例。感兴趣的读者可能会注意到，它与我们在本章中介绍的第一个`Dockerfile`非常相似。下面是内容：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: OK; so, what is happening here? Evidently, this is a `Dockerfile` that is used
    to build an image for a Node.js application; we can deduce this from the fact
    that the `node:12.5-stretch` base image is used. Then, the second line is an instruction
    to create an `/app` folder in the filesystem of the image. The third line defines
    the working directory or context in the image to be this new `/app` folder. Then,
    on line four, we copy a `package.json` file into the `/app` folder inside the
    image. After this, on line five, we execute the `npm install` command inside the
    container; remember, our context is the `/app` folder, and thus, `npm` will find
    the `package.json` file there that we copied on line four.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么这里到底发生了什么？显然，这是一个用于为Node.js应用程序构建镜像的`Dockerfile`；我们可以从使用`node:12.5-stretch`基础镜像这一事实推测出来。然后，第二行是一个指令，要求在镜像的文件系统中创建一个`/app`文件夹。第三行定义了镜像中的工作目录或上下文为这个新的`/app`文件夹。接着，在第四行，我们将`package.json`文件复制到镜像内部的`/app`文件夹中。之后，在第五行，我们在容器内执行`npm
    install`命令；记住，我们的上下文是`/app`文件夹，因此，`npm`会在那里找到我们在第四行复制的`package.json`文件。
- en: After all the Node.js dependencies are installed, we copy the rest of the application
    files from the current folder of the host into the `/app` folder of the image.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装完所有的Node.js依赖项后，我们将把主机当前文件夹中的其余应用程序文件复制到镜像的`/app`文件夹中。
- en: Finally, on the last two lines, we define what the startup command will be when
    a container is run from this image. In our case, it is `npm start`, which will
    start the Node.js application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后两行中，我们定义了从此镜像运行容器时启动的命令。在我们的例子中，是`npm start`，它将启动Node.js应用程序。
- en: Building an image
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Let''s look at a concrete example and build a simple Docker image, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个具体的例子，并构建一个简单的Docker镜像，如下所示：
- en: 'In your home directory, create a `fod `folder (short for **Fundamentals of
    Docker**) with a  `ch04` subfolder in it, and navigate to this folder, like this:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主目录中，创建一个`fod`文件夹（**Fundamentals of Docker**的缩写），并在其中创建一个`ch04`子文件夹，然后导航到这个文件夹，方法如下：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding folder, create a `sample1` subfolder and navigate to it, like
    this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的文件夹中，创建一个`sample1`子文件夹并导航到其中，如下所示：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use your favorite editor to create a file called `Dockerfile` inside this sample
    folder, with the following content:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器，在此示例文件夹内创建一个名为`Dockerfile`的文件，文件内容如下：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 4\. Save the file and exit your editor.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 保存文件并退出编辑器。
- en: '5\. Back in the Terminal window, we can now build a new container image using
    the preceding `Dockerfile` as a manifest or construction plan, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 返回终端窗口，我们现在可以使用前面的`Dockerfile`作为清单或构建计划来构建一个新的容器镜像，如下所示：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Please note that there is a period at the end of the preceding command. This
    command means that the Docker builder is creating a new image called `my-centos` using
    the `Dockerfile` that is present in the current directory. Here, the period at
    the end of the command stands for *current directory*. We could also write the
    preceding command as follows, with the same result:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前一个命令的末尾有一个句号。这个命令意味着Docker构建器正在使用当前目录中的`Dockerfile`创建一个名为`my-centos`的新镜像。这里命令末尾的句号代表*当前目录*。我们也可以按照以下方式编写前面的命令，结果是一样的：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But we can omit the `-f ` parameter, since the builder assumes that the `Dockerfile`
    is literally called `Dockerfile`. We only ever need the `-f` parameter if our
    `Dockerfile` has a different name or is not located in the current directory.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以省略`-f`参数，因为构建器默认认为`Dockerfile`的文件名就是`Dockerfile`。只有在`Dockerfile`有不同名称或不在当前目录时，我们才需要`-f`参数。
- en: 'The preceding command gives us this (shortened) output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会输出以下（简化版）结果：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s analyze this output, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析以下输出：
- en: 'First, we have the following line:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们看到以下一行：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing the builder does is package the files in the current build context,
    excluding the files and folder mentioned in the `.dockerignore` file (if present),
    and sends the resulting `.tar` file to the `Docker daemon`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器首先会打包当前构建上下文中的文件，排除在`.dockerignore`文件中（如果存在）提到的文件和文件夹，然后将生成的`.tar`文件发送到`Docker
    daemon`。
- en: 'Next, we have the following lines:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看到以下几行：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first line tells us which step of the `Dockerfile` the builder is currently
    executing. Here, we only have two statements in the `Dockerfile`, and we are on
    S*tep 1* of *2*. We can also see what the content of that section is. Here, it
    is the declaration of the base image, on top of which we want to build our custom
    image. What the builder then does is pull this image from Docker Hub, if it is
    not already available in the local cache. The last line of the preceding code
    snippet indicates which ID the just-built image layer gets assigned by the builder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉我们构建器当前正在执行`Dockerfile`中的哪个步骤。在这里，我们的`Dockerfile`只有两个语句，我们处于*步骤 1*中的*2*。我们还可以看到该部分的内容。在这里，它是基础镜像的声明，我们想在其上构建自定义镜像。构建器接下来会从Docker
    Hub拉取这个镜像，如果它在本地缓存中不存在的话。前一段代码的最后一行表示刚构建的镜像层被分配了哪个ID。
- en: 'Now, follow the next step. I have shortened it even more than the preceding
    one to concentrate on the essential part:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照下一个步骤操作。我已经将其简化得比前一个步骤更为简洁，以便集中于核心部分：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, again, the first line indicates to us that we are in S*tep 2* of *2*.
    It also shows us the respective entry from the `Dockerfile`. On line two, we can
    see `Running in bb726903820c`, which tells us that the builder has created a container
    with ID `bb726903820c`, inside which it executes the `RUN `command.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行再次告诉我们我们处于*步骤 2*中的*2*。它还显示了`Dockerfile`中的相应条目。在第二行，我们可以看到`Running in
    bb726903820c`，这告诉我们构建器已经创建了一个ID为`bb726903820c`的容器，并在其中执行`RUN`命令。
- en: We have omitted the output of the `yum install -y wget `command in the snippet
    since it is not important in this section. When the command is finished, the builder
    stops the container, commits it to a new layer, and then removes the container.
    The new layer has ID `bc070cc81b87`, in this particular case.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码片段中省略了`yum install -y wget`命令的输出，因为在这一部分不重要。当该命令完成时，构建器停止容器，将其提交为新的一层，然后移除该容器。在这个特定的例子中，新层的ID是`bc070cc81b87`。
- en: 'At the very end of the output, we encounter the following two lines:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出的最后，我们看到以下两行：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This tells us that the resulting custom image has been given the ID `bc070cc81b87`,
    and has been tagged with the name `my-centos:latest`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，生成的自定义镜像被分配了ID `bc070cc81b87`，并且被标记为`my-centos:latest`。
- en: 'So, how does the builder work, exactly? It starts with the base image. From
    this base image, once downloaded into the local cache, the builder creates a container
    and runs the first statement of the `Dockerfile` inside this container. Then,
    it stops the container and persists the changes made in the container into a new
    image layer. The builder then creates a new container from the base image and the
    new layer and runs the second statement inside this new container. Once again,
    the result is committed to a new layer. This process is repeated until the very
    last statement in the `Dockerfile` is encountered. After having committed the
    last layer of the new image, the builder creates an ID for this image and tags
    the image with the name we provided in the `build `command, as shown in the following
    screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，构建器究竟是如何工作的呢？它从基础镜像开始。一旦将此基础镜像下载到本地缓存，构建器会创建一个容器，并在这个容器中运行`Dockerfile`的第一条指令。然后，它停止容器并将容器中所做的更改保存为新的镜像层。接着，构建器从基础镜像和新层创建一个新容器，并在这个新容器中运行第二条指令。结果再次提交为新的层。这个过程会一直重复，直到遇到`Dockerfile`中的最后一条指令。完成最后一层新镜像的提交后，构建器为此镜像创建一个ID，并用我们在`build`命令中提供的名称为镜像打标签，如下截图所示：
- en: '![](img/13c9e699-35e5-40dc-b064-d64472d15f03.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13c9e699-35e5-40dc-b064-d64472d15f03.png)'
- en: The image build process visualized
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建过程可视化
- en: Now that we have analyzed how the build process of a Docker image works and
    what steps are involved, let's talk about how to further improve this by introducing
    multi-step builds.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了Docker镜像的构建过程以及涉及的步骤，接下来让我们谈谈如何通过引入多步骤构建进一步优化这个过程。
- en: Multi-step builds
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多步骤构建
- en: 'To demonstrate why a `Dockerfile` with multiple build steps is useful, let''s
    make an example `Dockerfile`. Let''s take a Hello World application written in
    C. Here is the code found inside the `hello.c` file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示为什么使用多个构建步骤的`Dockerfile`很有用，让我们做一个示例`Dockerfile`。我们以一个用C语言编写的Hello World应用程序为例。这里是`hello.c`文件中的代码：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Follow along to experience the advantages of a multi-step build:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随学习，体验多步骤构建的优势：
- en: 'To containerize this application we first write a `Dockerfile` with the following
    content:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了容器化这个应用程序，我们首先编写一个`Dockerfile`，其内容如下：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, let''s build this image:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建这个镜像：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This gives us a fairly long output since the builder has to install the Alpine
    **Software Development Kit** (**SDK**), which, among other tools, contains the
    C++ compiler we need to build the application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给我们一个相当长的输出，因为构建器需要安装Alpine **软件开发工具包**（**SDK**），该工具包包含了我们需要的C++编译器，用于构建应用程序。
- en: 'Once the build is done, we can list the image and see its size shown, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以列出镜像并查看其大小，如下所示：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With a size of 176 MB, the resulting image is way too big. In the end, it is
    just a Hello World application. The reason for it being so big is that the image
    not only contains the Hello World binary but also all the tools to compile and
    link the application from the source code. But this is really not desirable when
    running the application, say, in production. Ideally, we only want to have the
    resulting binary in the image and not a whole SDK.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 结果镜像的大小为176MB，实在是太大了。最终，它只是一个Hello World应用程序。之所以这么大，是因为镜像不仅包含了Hello World二进制文件，还包含了所有用于从源代码编译和链接应用程序的工具。但在生产环境中运行应用程序时，这显然是不理想的。理想情况下，我们只希望镜像中包含最终的二进制文件，而不是完整的SDK。
- en: 'It is precisely for this reason that we should define Dockerfiles as multi-stage.
    We have some stages that are used to build the final artifacts, and then a final
    stage, where we use the minimal necessary base image and copy the artifacts into
    it. This results in very small Docker images. Have a look at this revised `Dockerfile`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为如此，我们应该将Dockerfile定义为多阶段的。我们有一些阶段用于构建最终的构件，然后是一个最终阶段，在这个阶段中，我们使用最小的基础镜像并将构件复制进去。这样会得到非常小的Docker镜像。看看这个修改过的`Dockerfile`：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we have the first stage with a `build` alias that is used to compile
    the application, and then the second stage uses the same `alpine:3.7` base image
    but does not install the SDK, and only copies the binary from the `build` stage,
    using the `--from` parameter, into this final image:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有第一阶段，使用`build`别名来编译应用程序，然后第二阶段使用相同的`alpine:3.7`基础镜像，但不安装SDK，仅使用`--from`参数将`build`阶段的二进制文件复制到这个最终镜像中：
- en: 'Let''s build the image again, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次构建这个镜像，如下所示：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we compare the sizes of the images, we get the following output:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们比较镜像的大小时，得到以下输出：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have been able to reduce the size from 176 MB down to 4 MB. This is a reduction
    in size by a factor of 40\. A smaller image has many advantages, such as a smaller
    attack surface area for hackers, reduced memory and disk consumption, faster startup
    times of the corresponding containers, and a reduction of the bandwidth needed
    to download the image from a registry, such as Docker Hub.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功将镜像大小从176 MB减少到4 MB，缩小了40倍。较小的镜像有很多优势，比如较小的攻击面，减少内存和磁盘占用，容器启动时间更快，以及减少从镜像仓库（如Docker
    Hub）下载镜像所需的带宽。
- en: Dockerfile best practices
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile最佳实践
- en: 'There are a few recommended best practices to consider when authoring a `Dockerfile`,
    which are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`Dockerfile`时，有一些推荐的最佳实践需要考虑，具体如下：
- en: First and foremost, we need to consider that containers are meant to be ephemeral.
    By ephemeral, we mean that a container can be stopped and destroyed, and a new
    one built and put in place with an absolute minimum of setup and configuration.
    That means that we should try hard to keep the time that is needed to initialize
    the application running inside the container at a minimum, as well as the time
    needed to terminate or clean up the application.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑到容器是暂时性的。所谓暂时性，意味着容器可以停止并销毁，之后可以构建并部署一个新的容器，几乎不需要任何设置和配置。这意味着我们应该尽力保持初始化容器内应用程序的时间最短，同时减少终止或清理应用程序所需的时间。
- en: The next best practice tells us that we should order the individual commands
    in the `Dockerfile` so that we leverage caching as much as possible. Building
    a layer of an image can take a considerable amount of time—sometimes many seconds,
    or even minutes. While developing an application, we will have to build the container
    image for our application multiple times. We want to keep the build times at a
    minimum.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的最佳实践告诉我们，我们应该按照顺序排列`Dockerfile`中的各个命令，以尽可能地利用缓存。构建镜像的一层可能需要相当长的时间——有时需要几秒钟，甚至几分钟。在开发应用程序时，我们需要多次构建应用程序的容器镜像。我们希望将构建时间保持在最短。
- en: 'When we''re rebuilding a previously built image, the only layers that are rebuilt
    are the ones that have changed, but if one layer needs to be rebuilt, all subsequent
    layers also need to be rebuilt. This is very important to remember. Consider the
    following example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新构建一个之前构建的镜像时，只有已更改的层会被重新构建，但如果一层需要重新构建，那么所有后续的层也需要重新构建。记住这一点非常重要。考虑以下示例：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this example, the `npm install` command on line five of the `Dockerfile`
    usually takes the longest. A classical Node.js application has many external dependencies,
    and those are all downloaded and installed in this step. This can take minutes
    until it is done. Therefore, we want to avoid running `npm install `each time
    we rebuild the image, but a developer changes their source code all the time during
    the development of an application. That means that line four, the result of the `COPY `command,
    changes every time, and thus this layer has to be rebuilt. But as we discussed
    previously, that also means that all subsequent layers have to be rebuilt, which—in
    this case—includes the `npm install` command. To avoid this, we can slightly modify
    the `Dockerfile` and have the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Dockerfile`第五行的`npm install`命令通常需要最长时间。一个典型的Node.js应用程序有许多外部依赖项，而这些依赖项都会在此步骤中下载和安装。这可能需要几分钟才能完成。因此，我们希望避免在每次重建镜像时都执行`npm
    install`，但开发人员在应用程序开发过程中会不断更改源代码。这意味着第四行的`COPY`命令的结果每次都会发生变化，因此这一层必须被重新构建。但正如我们之前讨论的，这也意味着所有后续的层必须重新构建，这在这个案例中包括`npm
    install`命令。为了避免这种情况，我们可以稍微修改`Dockerfile`，并如下所示：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What we have done here is, on line four, we only copied the single file that
    the `npm install` command needs as a source, which is the `package.json `file.
    This file rarely changes in a typical development process. As a consequence, the `npm
    install `command also has to be executed only when the `package.json` file changes.
    All the remaining, frequently changed content is added to the image after the `npm
    install` command.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是，在第四行，只复制了`npm install`命令所需的单个文件，即`package.json`文件。这个文件在典型的开发过程中很少发生变化。因此，`npm
    install`命令也只在`package.json`文件发生变化时执行。所有其他经常变化的内容是在`npm install`命令执行后才加入镜像的。
- en: A further best practice is to keep the number of layers that make up your image
    relatively small. The more layers an image has, the more the graph driver needs
    to work to consolidate the layers into a single root filesystem for the corresponding
    container. Of course, this takes time, and thus the fewer layers an image has,
    the faster the startup time for the container can be.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个最佳实践是保持镜像的层数尽可能少。镜像的层数越多，图形驱动程序需要花费更多的时间将这些层合并为对应容器的单一根文件系统。当然，这需要时间，因此镜像的层数越少，容器启动的时间可能会越快。
- en: 'But how can we keep our number of layers low? Remember that in a `Dockerfile`,
    each line that starts with a keyword such as `FROM`, `COPY`, or `RUN` creates
    a new layer. The easiest way to reduce the number of layers is to combine multiple
    individual `RUN` commands into a single one. For example, say that we had the
    following in a `Dockerfile`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*我们如何保持层数较少*呢？记住，在`Dockerfile`中，每一行以`FROM`、`COPY`或`RUN`等关键字开头都会创建一个新的层。减少层数的最简单方法是将多个单独的`RUN`命令合并为一个。例如，假设我们在`Dockerfile`中有如下内容：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We could combine these into a single concatenated expression, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些命令合并成一个单一的连接表达式，如下所示：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The former will generate three layers in the resulting image, while the latter
    only creates a single layer.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前者会在生成的镜像中创建三个层，而后者只会创建一个层。
- en: 'The next three best practices all result in smaller images. Why is this important?
    Smaller images reduce the time and bandwidth needed to download the image from
    a registry. They also reduce the amount of disk space needed to store a copy locally
    on the Docker host and the memory needed to load the image. Finally, smaller images
    also mean a smaller attack surface for hackers. Here are the best practices mentioned:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个最佳实践都能生成更小的镜像。为什么这很重要？较小的镜像减少了从注册表下载镜像所需的时间和带宽。它们还减少了在 Docker 主机上存储镜像副本所需的磁盘空间，以及加载镜像所需的内存。最后，较小的镜像也意味着更小的攻击面，降低了黑客攻击的风险。以下是提到的最佳实践：
- en: The first best practice that helps to reduce the image size is to use a `.dockerignore` file.
    We want to avoid copying unnecessary files and folders into an image, to keep
    it as lean as possible. A `.dockerignore` file works in exactly the same way as
    a `.gitignore` file, for those who are familiar with Git. In a `.dockerignore` file,
    we can configure patterns to exclude certain files or folders from being included
    in the context when building the image.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个有助于*减少*镜像大小的最佳实践是使用`.dockerignore`文件。我们希望避免将不必要的文件和文件夹复制到镜像中，以保持其尽可能精简。`.dockerignore`文件的工作原理与`.gitignore`文件完全相同，对于熟悉
    Git 的人来说也是如此。在`.dockerignore`文件中，我们可以配置模式，排除某些文件或文件夹在构建镜像时被包含在上下文中。
- en: The next best practice is to avoid installing unnecessary packages into the
    filesystem of the image. Once again, this is to keep the image as lean as possible.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个最佳实践是避免将不必要的包安装到镜像的文件系统中。同样，这是为了保持镜像尽可能精简。
- en: Last but not least, it is recommended that you use multi-stage builds so that
    the resulting image is as small as possible and only contains the absolute minimum
    needed to run your application or application service.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，建议使用多阶段构建，以确保生成的镜像尽可能小，并且仅包含运行应用程序或应用服务所需的最基本内容。
- en: Saving and loading images
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载镜像
- en: 'The third way to create a new container image is by importing or loading it
    from a file. A container image is nothing more than a tarball. To demonstrate
    this, we can use the `docker image save ` command to export an existing image
    to a tarball, like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新容器镜像的第三种方法是通过从文件中导入或加载镜像。容器镜像不过是一个 tarball。为了演示这一点，我们可以使用`docker image save`命令将现有镜像导出为
    tarball，像这样：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding command takes our `my-alpine` image that we previously built and
    exports it into a file called  `./backup/my-alpine.tar`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将我们之前构建的`my-alpine`镜像导出到名为`./backup/my-alpine.tar`的文件中。
- en: 'If, on the other hand, we have an existing tarball and want to import it as
    an image into our system, we can use the `docker image load` command, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手头有一个现有的 tarball，并且想将其作为镜像导入到我们的系统中，我们可以使用`docker image load`命令，如下所示：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the next section, we will discuss how we can create Docker images for existing
    legacy applications, and thus run them in a container, and profit from this.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论如何为现有的遗留应用程序创建 Docker 镜像，从而在容器中运行它们，并从中获益。
- en: 'Lift and shift: Containerizing a legacy app'
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升并迁移：将遗留应用容器化
- en: We can't always start from scratch and develop a brand new application. More
    often than not, we find ourselves with a huge portfolio of traditional applications
    that are up and running in production and provide mission-critical value to the
    company or the customers of the company. Often, those applications are organically
    grown and very complex. Documentation is sparse, and nobody really wants to touch
    such an application. Often, the saying *Never touch a running system* applies.
    Yet, market needs change, and with that arises the need to update or rewrite those
    apps. Often, a complete rewrite is not possible due to the lack of resources and
    time, or due to the excessive cost. What are we going to do about those applications?
    Could we possibly Dockerize them and profit from benefits introduced by containers?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是能从零开始，开发一个全新的应用程序。更常见的是，我们会发现自己拥有一大堆传统的应用程序，这些应用程序已经在生产环境中运行，并为公司或公司客户提供了至关重要的价值。通常，这些应用程序是自然发展起来的，结构复杂。文档稀缺，而且没有人愿意去接触这些应用程序。通常，“*永远不要触碰正在运行的系统*”这句话是适用的。然而，市场需求发生变化，随之而来的是更新或重写这些应用程序的需求。由于资源和时间的限制，或者由于过高的成本，完全重写往往是不可能的。那么，我们该如何处理这些应用程序呢？我们是否可以将它们容器化，并从容器带来的好处中获益？
- en: It turns out we can. In 2017, Docker introduced a program called **Modernize
    Traditional Apps** (**MTA**) to their enterprise customers, which in essence promised
    to help those customers to take their existing or traditional Java and .NET applications
    and containerize them, without the need to change a single line of code. The focus
    of MTA was on Java and .NET applications since those made up the lion's share
    of the traditional applications in a typical enterprise. But the same is possible
    for any application that was written in—say—C, C++, Python, Node.js, Ruby, PHP,
    or Go, to just name a few other languages and platforms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明我们
- en: Let's imagine such a legacy application for a moment. Assume we have an old
    Java application written 10 years ago, and continuously updated during the following
    5 years. The application is based on Java SE 6, which came out in December 2006\.
    It uses environment variables and property files for configuration. Secrets such
    as username and passwords used in the database connection strings are pulled from
    a secrets keystore, such as HashiCorp's Vault.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时想象一下这样的传统应用程序。假设我们有一个10年前写的旧Java应用程序，并且在接下来的5年里持续更新。这个应用程序基于Java SE 6，后者是在2006年12月发布的。它使用环境变量和属性文件进行配置。像数据库连接字符串中使用的用户名和密码等敏感信息会从一个密钥库中提取出来，比如HashiCorp的Vault。
- en: Analysis of external dependencies
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部依赖分析
- en: One of the first steps in the modernization process is to discover and list
    all external dependencies of the legacy application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化过程的第一步之一是发现并列出该传统应用程序的所有外部依赖项。
- en: 'We need to ask ourselves questions like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要问自己以下问题：
- en: Does it use a database? If yes, which one? What does the connection string look
    like?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用数据库吗？如果是，使用的是哪个数据库？连接字符串是什么样的？
- en: Does it use external APIs such as credit card approval or geo-mapping APIs?
    What are the API keys and key secrets?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否使用外部API，如信用卡批准或地理定位API？API密钥和密钥秘密是什么？
- en: Is it consuming from or publishing to an **Enterprise Service Bus** (**ESB**)?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是从**企业服务总线**（**ESB**）中消费数据还是发布数据？
- en: These are just a few possible dependencies that come to mind. Many more exist.
    These are the seams of the application to the outer world, and we need to be aware
    of them and create an inventory.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是脑海中浮现出来的一些可能的依赖项。实际上还有更多。这些是应用程序与外界的接口，我们需要关注它们并创建一个清单。
- en: Source code and build instructions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码和构建指令
- en: The next step is to locate all the source code and other assets, such as images
    and CSS and HTML files that are part of the application. Ideally, they should
    be located in a single folder. This folder will be the root of our project and
    can have as many subfolders as needed. This project root folder will be the context
    during the build of the container image we want to create for our legacy application.
    Remember, the Docker builder only includes files in the build that are part of
    that context; in our case, that is the root project folder.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到所有源代码和其他资产，例如作为应用程序一部分的图像、CSS 和 HTML 文件。理想情况下，这些文件应该位于一个文件夹中。这个文件夹将是我们项目的根目录，并且可以根据需要包含多个子文件夹。这个项目根文件夹将是我们要为传统应用程序创建容器镜像时的上下文。记住，Docker
    构建器仅包括该上下文中包含的文件；在我们的案例中，这就是根项目文件夹。
- en: There is, though, an option to download or copy files during the build from
    different locations, using the `COPY` or `ADD` commands. Please refer to the online
    documentation for the exact details on how to use these two commands. This option
    is useful if the sources for your legacy application cannot be easily contained
    in a single, local folder.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一个选项是在构建过程中从不同位置下载或复制文件，使用`COPY`或`ADD`命令。有关如何使用这两个命令的确切细节，请参考在线文档。如果你的传统应用程序源无法轻易地包含在单一的本地文件夹中，这个选项非常有用。
- en: Once we are aware of all the parts that are contributing to the final application,
    we need to investigate how the application is built and packaged. In our case,
    this is most probably done by using Maven. Maven is the most popular build automation
    tool for Java, and has been—and still is—used in most enterprises that are developing
    Java applications. In the case of a legacy .NET application, it is most probably
    done by using the MSBuild tool; and in the case of a C/C++ application, Make would
    most likely be used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了所有构成最终应用程序的部分，我们需要研究应用程序是如何构建和打包的。在我们的案例中，这很可能是通过使用 Maven 完成的。Maven 是最流行的
    Java 构建自动化工具，并且已经——并且仍然——在大多数开发 Java 应用程序的企业中使用。对于传统的 .NET 应用程序，它很可能是通过使用 MSBuild
    工具完成的；对于 C/C++ 应用程序，最有可能使用 Make 工具。
- en: Once again, let's extend our inventory and write down the exact build commands
    used. We will need this information later on when authoring the `Dockerfile`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要扩展我们的清单并记录下使用的精确构建命令。我们在编写`Dockerfile`时稍后将需要这些信息。
- en: Configuration
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: Applications need to be configured. Information provided during configuration
    can be—for example— the type of application logging to use, connection strings
    to databases, hostnames to services such as ESBs or URIs to external APIs, to
    name just a few.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要配置。在配置过程中提供的信息可以是——例如——应用程序日志记录类型、数据库的连接字符串、指向 ESB 或外部 API 的主机名或 URI 等。
- en: 'We can differentiate a few types of configurations, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分几种类型的配置，如下所示：
- en: '**Build time**: This is the information needed during the build of the application
    and/or its Docker image. It needs to be available when we create the Docker images.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时间**：这是在构建应用程序和/或其 Docker 镜像时所需的信息。它需要在我们创建 Docker 镜像时可用。'
- en: '**Environment**: This is configuration information that varies with the environment
    in which the application is running—for example, DEVELOPMENT versus STAGING or
    PRODUCTION. This kind of configuration is applied to the application when a container
    with the app starts—for example, in production.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：这是与应用程序运行环境相关的配置信息——例如，开发环境（DEVELOPMENT）与预发布（STAGING）或生产环境（PRODUCTION）。这种配置会在容器启动时应用到应用程序，例如在生产环境中。'
- en: '**Runtime**: This is information that the application retrieves during runtime,
    such as secrets to access an external API.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：这是应用程序在运行时获取的信息，例如访问外部 API 所需的密钥。'
- en: Secrets
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥
- en: Every mission-critical enterprise application needs to deal with secrets in
    some form or another. The most familiar secrets are part of the connection information
    needed to access databases that are used to persist the data produced by or used
    by the application. Other secrets include the credentials needed to access external
    APIs, such as a credit score lookup API. It is important to note that, here, we
    are talking about secrets that have to be provided by the application itself to
    the service providers the application uses or depends on, and not secrets provided
    by the users of the application. The actor here is our application, which needs
    to be authenticated and authorized by external authorities and service providers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键业务应用程序都需要以某种形式处理机密。最常见的机密是用于访问数据库的连接信息，这些数据库用于持久化应用程序生产或使用的数据。其他机密包括访问外部API所需的凭据，比如信用评分查询API。需要注意的是，这里所说的机密是指应用程序必须提供给其使用或依赖的服务提供商的机密，而不是应用程序用户提供的机密。这里的主体是我们的应用程序，它需要通过外部授权机构和服务提供商进行身份验证和授权。
- en: There are various ways traditional applications got their secrets. The worst
    and most insecure way of providing secrets is by hardcoding them or reading them
    from configuration files or environment variables, where they are available in
    cleartext. A much better way is to read the secrets during runtime from a special
    secrets store that persists the secrets encrypted and provides them to the application
    over a secure connection, such as **Transport Layer Security** (**TLS**).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序获取机密的方式有很多种。最差也是最不安全的方式是将机密硬编码在代码中，或者从配置文件或环境变量中读取，这些机密通常以明文形式存在。更好的方式是通过运行时从一个特殊的机密存储中读取机密，该存储以加密方式持久化机密，并通过安全连接（如**传输层安全性**（**TLS**））将其提供给应用程序。
- en: Once again, we need to create an inventory of all secrets that our application
    uses and the way it procures them. Is it through environment variable or configuration
    files, or is it by accessing an external keystore, such as HashiCorp's Vault?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次创建一个清单，列出应用程序使用的所有机密以及它们的获取方式。是通过环境变量或配置文件，还是通过访问外部密钥库，比如HashiCorp的Vault？
- en: Authoring the Dockerfile
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Dockerfile
- en: 'Once we have a complete inventory of all the items discussed in the previous
    few sections, we are ready to author our `Dockerfile`. But I want to warn you:
    don''t expect this to be a one-shot-and-go task. You may need several iterations
    until you have crafted your final `Dockerfile`. The `Dockerfile` may be rather
    long and ugly-looking, but that''s not a problem, as long as we get a working
    Docker image. We can always fine-tune the `Dockerfile` once we have a working
    version.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了前几个部分讨论的所有项目的清单，我们就可以开始编写我们的`Dockerfile`了。但我要提醒你：不要期望这是一项一次完成的任务。你可能需要几次迭代，直到你制作出最终的`Dockerfile`。`Dockerfile`可能会相当长，而且看起来很不优雅，但这不是问题，只要我们得到一个有效的Docker镜像。我们可以在得到一个有效版本后随时对`Dockerfile`进行微调。
- en: The base image
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础镜像
- en: Let's start by identifying the base image we want to use and build our image
    from. Is there an official Java image available that is compatible with our requirements?
    Remember that our imaginary application is based on Java SE 6\. If such a base
    image is available, then let's use that one. Otherwise, we want to start with
    a Linux distro such as Red Hat, Oracle, or Ubuntu. In the latter case, we will
    use the appropriate package manager of the distro (`yum`, `apt`, or another) to
    install the desired versions of Java and Maven. For this, we use the `RUN` keyword
    in the `Dockerfile`. Remember, `RUN` gives us the possibility to execute any valid
    Linux command in the image during the build process.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从确定要使用的基础镜像开始，并以此为基础构建我们的镜像。是否有一个符合我们要求的官方Java镜像？记住，我们的假设应用程序基于Java SE 6。如果有这样的基础镜像，那就使用它。否则，我们希望从一个Linux发行版开始，如Red
    Hat、Oracle或Ubuntu。在后一种情况下，我们将使用相应的发行版包管理器（`yum`、`apt`或其他）来安装所需版本的Java和Maven。为此，我们在`Dockerfile`中使用`RUN`关键字。记住，`RUN`允许我们在构建过程中执行镜像中的任何有效Linux命令。
- en: Assembling the sources
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇总源代码
- en: 'In this step, we make sure all source files and other artifacts needed to successfully
    build the application are part of the image. Here, we mainly use the two keywords
    of the `Dockerfile`: `COPY` and `ADD`. Initially, the structure of the source
    inside the image should look exactly the same as on the host, to avoid any build
    problems. Ideally, you would have a single `COPY` command that copies all of the
    root project folder from the host into the image. The corresponding `Dockerfile`
    snippet could then look as simple as this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们确保所有源文件和其他构建应用程序所需的工件都包含在镜像中。在这里，我们主要使用`Dockerfile`中的两个关键字：`COPY`和`ADD`。最初，镜像内部的源结构应该与主机上的完全相同，以避免任何构建问题。理想情况下，你应该使用一个`COPY`命令，将主机上根项目文件夹的所有内容复制到镜像中。相应的`Dockerfile`片段可能会像这样简单：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Don't forget to also provide a `.dockerignore` file located in the project root
    folder, which lists all the files and (sub-) folders of the project root folder
    that should not be part of the build context.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了提供一个位于项目根文件夹的`.dockerignore`文件，列出所有不应成为构建上下文一部分的文件和（子）文件夹。
- en: 'As mentioned earlier, you can also use the `ADD` keyword to download sources
    and other artifacts into the Docker image that are not located in the build context
    but somewhere reachable by a URI, as shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你也可以使用`ADD`关键字将源文件和其他工件下载到 Docker 镜像中，这些文件不在构建上下文中，而是位于通过 URI 可访问的位置，如下所示：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This would create a `foobar` folder in the image's working folder and copy all
    the contents from the URI.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在镜像的工作目录中创建一个`foobar`文件夹，并将所有来自 URI 的内容复制过来。
- en: Building the application
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: 'In this step, we make sure to create the final artifacts that make up our executable
    legacy application. Often, this is a JAR or WAR file, with or without some satellite
    JARs. This part of the `Dockerfile` should exactly mimic the way you traditionally
    used to build an application before containerizing them. Thus, if using Maven
    as the build automation tool, the corresponding snippet of the `Dockerfile` could
    look as simple as this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们确保创建最终的工件，这些工件构成了我们的可执行遗留应用程序。通常，这可能是一个 JAR 或 WAR 文件，可能带有或不带有一些附加的 JAR
    文件。`Dockerfile`的这一部分应该完全模拟你在容器化之前传统构建应用程序的方式。因此，如果使用 Maven 作为构建自动化工具，则`Dockerfile`的相应片段可能会像这样简单：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this step, we may also want to list the environment variables the application
    uses, and provide sensible defaults. But never provide default values for environment
    variables that provide secrets to the application such as the database connection
    string! Use the `ENV` keyword to define your variables, like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们还可能需要列出应用程序使用的环境变量，并提供合理的默认值。但永远不要为提供机密信息的环境变量（例如数据库连接字符串）提供默认值！使用`ENV`关键字来定义变量，如下所示：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, declare all ports that the application is listening on and that need
    to be accessible from outside of the container via the `EXPOSE` keyword, like
    this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，声明应用程序监听的所有端口，并通过`EXPOSE`关键字使这些端口能够从容器外部访问，如下所示：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Defining the start command
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义启动命令
- en: 'Usually, a Java application is started with a command such as `java -jar <main
    application jar>` if it is a standalone application. If it is a WAR file, then
    the start command may look a bit different. We can thus either define the `ENTRYPOINT`
    or the `CMD` to use this command. Thus, the final statement in our `Dockerfile`
    could look like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果是独立的 Java 应用程序，它会通过类似`java -jar <main application jar>`的命令启动。如果是 WAR 文件，则启动命令可能会有所不同。因此，我们可以定义`ENTRYPOINT`或`CMD`来使用这个命令。因此，我们的`Dockerfile`中的最终语句可能是这样的：
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Often, though, this is too simplistic, and we need to execute a few pre-run
    tasks. In this case, we can craft a script file that contains the series of commands
    that need to be executed to prepare the environment and run the application. Such
    a file is often called `docker-entrypoint.sh`, but you are free to name it however
    you want. Make sure the file is executable— for example, with the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方式通常过于简单，我们需要执行一些预运行任务。在这种情况下，我们可以编写一个脚本文件，包含需要执行的命令序列，用于准备环境并运行应用程序。这样的文件通常叫做`docker-entrypoint.sh`，但你可以根据需要命名它。确保该文件是可执行的——例如，可以使用以下命令：
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The last line of the `Dockerfile` would then look like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的最后一行将会是这样的：'
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that you have been given hints on how to containerize a legacy application,
    it is time to recap and ask ourselves: *Is it really worth the whole effort?*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了如何容器化一个遗留应用程序，是时候回顾一下并问问自己：*这真的值得付出这么多努力吗？*
- en: Why bother?
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要费心呢？
- en: 'At this point, I can see you scratching your head and asking yourself: *Why
    bother?* Why should you take on all this seemingly huge effort just to containerize
    a legacy application? What are the benefits?'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我能看到你在挠头并自问：*为什么要费这个劲？* 为什么要花这么大的力气仅仅是为了将一个传统应用容器化？这样做有什么好处？
- en: 'It turns out that the **return on investment** (**ROI**) is huge. Enterprise
    customers of Docker have publicly disclosed at conferences such as DockerCon 2018
    and 2019 that they are seeing these two main benefits of Dockerizing traditional
    applications:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，**投资回报率**（**ROI**）非常高。Docker 的企业客户曾在 DockerCon 2018 和 2019 等会议上公开披露，他们在将传统应用容器化时，获得了两个主要的好处：
- en: More than a 50% saving in maintenance costs.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护成本节省超过 50%。
- en: Up to a 90% reduction in the time between the deployments of new releases.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署新版本之间的时间减少高达 90%。
- en: The costs saved by reducing the maintenance overhead can be directly reinvested
    and used to develop new features and products. The time saved during new releases
    of traditional applications makes a business more agile and able to react to changing
    customer or market needs more quickly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少维护开销所节省的成本可以直接再投资，用于开发新功能和新产品。在发布传统应用的新版本时节省的时间使企业变得更加灵活，能够更快地应对客户或市场需求的变化。
- en: Now that we have discussed at length how to build Docker images, it is time
    to learn how we can ship those images through the various stages of the software
    delivery pipeline.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经详细讨论了如何构建 Docker 镜像，现在是时候学习如何通过软件交付流水线的各个阶段将这些镜像发布出去。
- en: Sharing or shipping images
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享或发布镜像
- en: To be able to ship our custom image to other environments, we need to first
    give it a globally unique name. This action is often called *tagging* an image.
    We then need to publish the image to a central location from which other interested
    or entitled parties can pull it. These central locations are called *image registries*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将我们的自定义镜像发布到其他环境中，我们需要首先给它一个全球唯一的名称。这个操作通常叫做 *标记* 镜像。然后，我们需要将镜像发布到一个中央位置，其他有兴趣或有权限的方可以从这个位置拉取它。这个中央位置称为
    *镜像注册表*。
- en: Tagging an image
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记镜像
- en: 'Each image has a so-called *tag*. A tag is often used to version images, but
    it has a broader reach than just being a version number. If we do not explicitly
    specify a tag when working with images, then Docker automatically assumes we''re
    referring to the `latest` tag. This is relevant when pulling an image from Docker
    Hub, as in the following example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都有一个所谓的 *标签*。标签通常用来标记镜像的版本，但它的作用远不止是作为版本号。如果我们在操作镜像时没有明确指定标签，那么 Docker 会默认认为我们指的是
    `latest` 标签。这在从 Docker Hub 拉取镜像时是有意义的，下面是一个示例：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding command will pull the `alpine:latest` image from Docker Hub.
    If we want to explicitly specify a tag, we do so like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将从 Docker Hub 拉取 `alpine:latest` 镜像。如果我们想明确指定标签，可以这样做：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This will now pull the `alpine `image that has been tagged with `3.5`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拉取被标记为 `3.5` 的 `alpine` 镜像。
- en: Image namespaces
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像命名空间
- en: So far, we have been pulling various images and haven't been worrying so much
    about where those images originated from. Your Docker environment is configured
    so that, by default, all images are pulled from Docker Hub. We also only pulled
    so-called official images from Docker Hub, such as `alpine` or `busybox`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在拉取各种镜像，并没有太过担心这些镜像的来源。你的 Docker 环境已配置好，默认情况下，所有镜像都从 Docker Hub 拉取。我们也只从
    Docker Hub 拉取所谓的官方镜像，如 `alpine` 或 `busybox`。
- en: 'Now, it is time to widen our horizon a bit and learn about how images are namespaced.
    The most generic way to define an image is by its fully qualified name, which
    looks as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候拓宽我们的视野，了解一下镜像是如何命名空间的。定义镜像最通用的方式是使用其完全限定名称，格式如下：
- en: '[PRE68]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s look at this in a bit more detail:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看：
- en: '`<registry URL>`: This is the URL to the registry from which we want to pull
    the image. By default, this is `docker.io`. More generally, this could be `https://registry.acme.com`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<registry URL>`：这是我们希望从中拉取镜像的注册表 URL。默认情况下，这是 `docker.io`。更广泛地说，它可以是 `https://registry.acme.com`。'
- en: 'Other than Docker Hub, there are quite a few public registries out there that
    you could pull images from. The following is a list of some of them, in no particular
    order:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Docker Hub，还有很多公共注册表你可以从中拉取镜像。以下是其中一些的列表，顺序不分先后：
- en: Google, at [https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
  id: totrans-335
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google，地址：[https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
- en: Amazon AWS **Amazon Elastic Container Registry** (**ECR**), at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊 AWS **Amazon Elastic Container Registry** (**ECR**)，网址为 [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
- en: Microsoft Azure, at [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 Azure，网址为 [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
- en: Red Hat, at [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat，网址为 [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
- en: Artifactory, at [https://jfrog.com/integration/artifactory-docker-registry/](https://jfrog.com/integration/artifactory-docker-registry/)
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifactory，网址为 [https://jfrog.com/integration/artifactory-docker-registry/](https://jfrog.com/integration/artifactory-docker-registry/)
- en: '`<User or Org>`: This is the private Docker ID of either an individual or an
    organization defined on Docker Hub—or any other registry, for that matter—such
    as `microsoft` or `oracle`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<User or Org>`：这是 Docker Hub 上定义的个人或组织的私有 Docker ID——或者说任何其他注册表中的 ID——例如 `microsoft`
    或 `oracle`。'
- en: '`<name>`: This is the name of the image, which is often also called a repository.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<name>`：这是镜像的名称，通常也被称为仓库。'
- en: '`<tag>`: This is the tag of the image.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tag>`：这是镜像的标签。'
- en: 'Let''s look at an example, as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，如下所示：
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we have an image, `web-app`, that is tagged with version `1.0` and belongs
    to the `engineering` organization on the private registry at `https://registry.acme.com`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为 `web-app` 的镜像，标记为版本 `1.0`，并且属于 `engineering` 组织，托管在 `https://registry.acme.com`
    的私有注册表中。
- en: 'Now, there are some special conventions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一些特殊约定：
- en: If we omit the registry URL, then Docker Hub is automatically taken.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了注册表 URL，则默认使用 Docker Hub。
- en: If we omit the tag, then `latest` is taken.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们省略标签，则默认使用 `latest`。
- en: If it is an official image on Docker Hub, then no user or organization namespace
    is needed.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是 Docker Hub 上的官方镜像，则不需要用户或组织命名空间。
- en: 'Here are a few samples in tabular form:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些以表格形式呈现的示例：
- en: '| **Image** | **Description** |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **镜像** | **描述** |'
- en: '| `alpine` | Official alpine image on Docker Hub with the latest tag. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `alpine` | Docker Hub 上官方的 `alpine` 镜像，标签为 `latest`。 |'
- en: '| `ubuntu:19.04` | Official `ubuntu` image on Docker Hub with the `19.04` tag
    or version. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `ubuntu:19.04` | Docker Hub 上官方的 `ubuntu` 镜像，标签为 `19.04` 或版本号为 `19.04`。 |'
- en: '| `microsoft/nanoserver` | `nanoserver` image of Microsoft on Docker Hub with
    the `latest` tag. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `microsoft/nanoserver` | Docker Hub 上微软的 `nanoserver` 镜像，标签为 `latest`。 |'
- en: '| `acme/web-api:12.0` | `web-api` image version `12.0` associated with the `acme` org.
    The image is on Docker Hub. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `acme/web-api:12.0` | `web-api` 镜像版本 `12.0`，关联到 `acme` 组织。该镜像托管在 Docker Hub
    上。 |'
- en: '| `gcr.io/gnschenker/sample-app:1.1` | `sample-app` image with the `1.1` tag belonging
    to an individual with the `gnschenker` ID on Google''s container registry. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `gcr.io/gnschenker/sample-app:1.1` | 属于个人 `gnschenker` 的 `sample-app` 镜像，标签为
    `1.1`，托管在 Google 的容器注册表中。 |'
- en: Now that we know how the fully qualified name of a Docker image is defined and
    what its parts are, let's talk about some special images we can find on Docker
    Hub.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 Docker 镜像的完整名称是如何定义的，以及它的各个部分，那么让我们来讨论一下在 Docker Hub 上可以找到的一些特殊镜像。
- en: Official images
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 官方镜像
- en: In the preceding table, we mentioned *official image* a few times. This needs an
    explanation. Images are stored in repositories on the Docker Hub registry. Official
    repositories are a set of repositories hosted on Docker Hub that are curated by
    individuals or organizations that are also responsible for the software packaged
    inside the image. Let's look at an example of what that means. There is an official
    organization behind the Ubuntu Linux distro. This team also provides official
    versions of Docker images that contain their Ubuntu distros.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，我们提到了 *官方镜像*。这需要进一步解释。镜像存储在 Docker Hub 注册表中的仓库中。官方仓库是由个人或组织策划的仓库集合，这些个人或组织对镜像中的软件也负有责任。我们来看一个例子。Ubuntu
    Linux 发行版背后有一个官方组织。这个团队还提供包含其 Ubuntu 发行版的 Docker 镜像的官方版本。
- en: Official images are meant to provide essential base OS repositories, images
    for popular programming language runtimes, frequently used data storage, and other
    important services.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 官方镜像旨在提供基本的操作系统镜像、流行编程语言运行时的镜像、常用的数据存储和其他重要服务的镜像。
- en: Docker sponsors a team whose task it is to review and publish all those curated
    images in public repositories on Docker Hub. Furthermore, Docker scans all official
    images for vulnerabilities.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 支持一个团队，负责审查并发布所有在 Docker Hub 公共仓库中的精选镜像。此外，Docker 会对所有官方镜像进行漏洞扫描。
- en: Pushing images to a registry
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送镜像到注册表
- en: Creating custom images is all well and good, but at some point, we want to actually
    share or ship our images to a target environment, such as a test, **quality assurance**
    (**QA**), or production system. For this, we typically use a container registry.
    One of the most popular and public registries out there is Docker Hub. It is configured
    as a default registry in your Docker environment, and it is the registry from
    which we have pulled all our images so far.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义镜像是好事，但在某个时候，我们希望将镜像共享或推送到目标环境，例如测试、**质量保证**（**QA**）或生产系统。为此，我们通常使用容器注册表。其中最受欢迎的公共注册表之一是
    Docker Hub。它在你的 Docker 环境中被配置为默认注册表，也是我们迄今为止从中拉取所有镜像的注册表。
- en: On a registry, one can usually create personal or organizational accounts. For
    example, my personal account at Docker Hub is `gnschenker`. Personal accounts
    are good for personal use. If we want to use the registry professionally, then
    we'll probably want to create an organizational account, such as `acme`, on Docker
    Hub. The advantage of the latter is that organizations can have multiple teams.
    Teams can have differing permissions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册表上，通常可以创建个人账户或组织账户。例如，我在 Docker Hub 上的个人账户是 `gnschenker`。个人账户适用于个人使用。如果我们希望专业地使用注册表，那么我们可能会希望在
    Docker Hub 上创建一个组织账户，如 `acme`。后者的优势在于，组织可以拥有多个团队，团队之间可以拥有不同的权限。
- en: 'To be able to push an image to my personal account on Docker Hub, I need to
    tag it accordingly:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要将镜像推送到我的个人账户上，我需要相应地为其打标签：
- en: 'Let''s say I want to push the latest version of Alpine to my account and give
    it a tag of `1.0`. I can do this in the following way:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我想将 Alpine 的最新版本推送到我的账户，并给它打上 `1.0` 标签。我可以通过以下方式进行：
- en: '[PRE70]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, to be able to push the image, I have to log in to my account, as follows:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了能够推送镜像，我必须先登录到我的账户，如下所示：
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After a successful login, I can then push the image, like this:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功登录后，我可以像这样推送镜像：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'I will see something similar to this in the Terminal:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我会看到类似这样的内容：
- en: '[PRE73]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For each image that we push to Docker Hub, we automatically create a repository.
    A repository can be private or public. Everyone can pull an image from a public
    repository. From a private repository, an image can only be pulled if one is logged
    in to the registry and has the necessary permissions configured.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个我们推送到 Docker Hub 的镜像，我们都会自动创建一个仓库。一个仓库可以是私有的，也可以是公开的。任何人都可以从公开仓库拉取镜像。而从私有仓库拉取镜像，必须先登录到注册表，并且配置好必要的权限。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed in detail what container images are and how
    we can build and ship them. As we have seen, there are three different ways that
    an image can be created—either manually, automatically, or by importing a tarball
    into the system. We also learned some of the best practices commonly used when
    building custom images.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了容器镜像是什么以及如何构建和推送它们。如我们所见，创建镜像有三种不同的方式——手动创建、自动创建，或者通过将 tarball 导入系统来创建。我们还了解了一些在构建自定义镜像时常用的最佳实践。
- en: In the next chapter, we're going to introduce Docker volumes that can be used
    to persist the state of a container. We'll also show how to define individual
    environment variables for the application running inside the container, as well
    as how to use files containing whole sets of configuration settings.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍可以用于持久化容器状态的 Docker 卷。我们还将展示如何为容器内运行的应用定义单独的环境变量，以及如何使用包含完整配置设置的文件。
- en: Questions
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题，以评估你的学习进展：
- en: How would you create a Dockerfile that inherits from Ubuntu version `19.04`,
    and that installs `ping` and runs `ping` when a container starts? The default
    address to `ping` will be `127.0.0.1`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个继承自 Ubuntu 版本 `19.04` 的 Dockerfile，并在容器启动时安装 `ping` 并运行 `ping` 呢？`ping`
    的默认地址将是 `127.0.0.1`。
- en: How would you create a new container image that uses `alpine:latest` and installs `curl`?
    Name the new image `my-alpine:1.0`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个新的容器镜像，使用 `alpine:latest` 并安装 `curl`？将新镜像命名为 `my-alpine:1.0`。
- en: Create a `Dockerfile` that uses multiple steps to create an image of a Hello
    World app of minimal size, written in C or Go.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Dockerfile`，该文件使用多个步骤创建一个最小大小的 Hello World 应用镜像，该应用用 C 或 Go 编写。
- en: Name three essential characteristics of a Docker container image.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举 Docker 容器镜像的三个基本特征。
- en: You want to push an image named `foo:1.0` to your `jdoe` personal account on
    Docker Hub. Which of the following is the right solution?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想将一个名为 `foo:1.0` 的镜像推送到 Docker Hub 上的 `jdoe` 个人账户。以下哪种方案是正确的？
- en: A. `$ docker container push foo:1.0` B. `$ docker image tag foo:1.0 jdoe/foo:1.0`
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: A. `$ docker container push foo:1.0` B. `$ docker image tag foo:1.0 jdoe/foo:1.0`
- en: '`$ docker image push jdoe/foo:1.0` C. `$ docker login -u jdoe -p <your password>`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image push jdoe/foo:1.0` C. `$ docker login -u jdoe -p <your password>`'
- en: '`$ docker image tag foo:1.0 jdoe/foo:1.0`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image tag foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker image push jdoe/foo:1.0` D. `$ docker login -u jdoe -p <your password>`'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image push jdoe/foo:1.0` D. `$ docker login -u jdoe -p <your password>`'
- en: '`$ docker container tag foo:1.0 jdoe/foo:1.0`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker container tag foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker container push jdoe/foo:1.0` E. `$ docker login -u jdoe -p <your
    password>`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker container push jdoe/foo:1.0` E. `$ docker login -u jdoe -p <your
    password>`'
- en: '`$ docker image push foo:1.0 jdoe/foo:1.0`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image push foo:1.0 jdoe/foo:1.0`'
- en: Further reading
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following list of references gives you some material that dives more deeply
    into the topic of authoring and building container images:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参考文献列表为你提供了深入了解容器镜像编写与构建的相关材料：
- en: Best practices for writing Dockerfiles, at[http://dockr.ly/22WiJiO](http://dockr.ly/22WiJiO)
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Dockerfile 的最佳实践，参见[http://dockr.ly/22WiJiO](http://dockr.ly/22WiJiO)
- en: Using multi-stage builds, at[http://dockr.ly/2ewcUY3](http://dockr.ly/2ewcUY3)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段构建，参见[http://dockr.ly/2ewcUY3](http://dockr.ly/2ewcUY3)
- en: About storage drivers, at[http://dockr.ly/1TuWndC](http://dockr.ly/1TuWndC)
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于存储驱动程序，参见[http://dockr.ly/1TuWndC](http://dockr.ly/1TuWndC)
- en: Graphdriver plugins, at[http://dockr.ly/2eIVCab](http://dockr.ly/2eIVCab)
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形驱动插件，参见[http://dockr.ly/2eIVCab](http://dockr.ly/2eIVCab)
- en: User-guided caching in Docker for Mac, at[http://dockr.ly/2xKafPf](http://dockr.ly/2xKafPf)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker for Mac 的用户引导缓存，参见[http://dockr.ly/2xKafPf](http://dockr.ly/2xKafPf)
