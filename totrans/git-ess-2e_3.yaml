- en: Git Fundamentals - Working Remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned a lot about Git; we learned how it works
    internally and how to manage a local repository, but now it's time to learn how
    to share our goodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we finally start to work in a distributed manner, using remote
    servers as a contact point for different developers. These are the main topics
    we will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with remotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning a remote repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with online hosting services, such as GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we said before, Git is a distributed version control system: this chapter
    concerns the *distributed* part.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with remotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a tool for versioning files, as you know, but it has been built with
    collaboration in mind. In 2005, Linus Torvalds had the need for a light and efficient
    tool to share the Linux kernel code, allowing him and hundreds of other people
    to work on it without going crazy; the pragmatism that guided its development
    gave us a very robust layer for sharing data among computers, without the need
    of a central server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, a Git **remote** is another "place" that has the same repository
    you have on your computer. As shown in the following image, you can think of it
    as different copies of the same repository that can exchange data between themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e86549ee-2280-4e74-9f98-ee6f972e265f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, a remote Git repository is just a remote copy of the same Git repository
    we created locally; if you have access to that remote via common protocols such
    as SSH, the custom `git://` protocol, or other protocols, you can keep in sync
    your modification with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even another folder in your computer can act as a remote: for Git, the filesystem
    is a *communication protocol* like any other, and you are allowed to use it if
    you like.'
  prefs: []
  type: TYPE_NORMAL
- en: This is what we will do to grasp the basic concepts about remotes.
  prefs: []
  type: TYPE_NORMAL
- en: Clone a local repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder on your disk to clone our `grocery` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then clone the `grocery` repository using the git clone command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Done.
  prefs: []
  type: TYPE_NORMAL
- en: The dot `.` argument at the end of the command means *clone the repository in
    the current folder*, while the `~/grocery` argument is actually the path where
    Git has to look for the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go directly to the point with a `git log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, other than the green `master` branch label, we have some red
    `origin/<branch>` labels on our log output.
  prefs: []
  type: TYPE_NORMAL
- en: The origin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the *origin*?
  prefs: []
  type: TYPE_NORMAL
- en: 'Git uses origin as the default name of a remote. Like with `master` for branches,
    `origin` is just a convention: you can call remotes whatever you want.'
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing to note here is that Git, thanks to the `--all` option
    in the `git log` command, shows us that there are some more branches in the remote
    repository, but as you can see, they do not appear in the locally cloned one.
    In the cloned repository, there is only `master`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But don''t worry: a local branch in which to work locally can be created by
    simply checking it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Look at the message, Git says that a *local branch has been set up to track
    the remote* one; this means that, from now on, Git will actively track differences
    between the local branch and the remote one, notifying you of differences while
    giving you output messages (for example, while using the `git status` command).
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, if you do a commit in this branch, you can send it to the
    remote and it will be part of the remote `origin/berries`.
  prefs: []
  type: TYPE_NORMAL
- en: This seems obvious, but, in Git, you can pair branches as you want; for example,
    you can track a remote `origin/foo` branch by a local `bar` branch, if you like.
    Alternatively, you can have local branches that simply don't exist on the remote.
    Later, we will look at how to work with remote branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the log again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now a green `berries` label appears, just near the red `origin/berries` one;
    this makes us aware that the local `berries` branch and remote `origin/berries`
    branch point to the same commit.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if I do a new commit?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your name and email address were configured automatically based on your *username*
    and *hostname*. Please check that they are accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can suppress this message by setting them explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, you may fix the identity used for this commit with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous chapter, Git warns me about author and email; this time I
    will go with the suggested ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s see what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Nice! The local `berries` branch moved forward, while `origin/berries` is still
    in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing local commits with git push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may already know, Git works locally; there's no need for a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you do a commit, it is available only locally; if you want to share
    it with a remote counterpart, you have to send it in some manner.
  prefs: []
  type: TYPE_NORMAL
- en: In Git, this is called **push**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will try to push the modifications in the `berries` branch to the `origin`;
    the command is `git push`, followed by the name of the remote and the target branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Wow! There is a lot of things in this output message. Basically, Git informed
    us about the operations it does before and during the sending of commits to the
    remote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, as Git will send only the objects it knows are not present in the
    remote to the remote (three, in this case: a commit, a tree, and a blob), it will
    not send unreachable commits, nor other related unreachable objects (such as trees,
    blobs, or annotated that tighten only with unreachable commits).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Git tells us where it is sending objects, the destination, which in
    this case is just another folder on my computer: `To C:/Users/san/Google Drive/Packt/PortableGit/home/grocery`.
    It then tells the commit hash remote where the `origin/berries` originally was
    and the hash of the new tip commit, that is the same as the one in the local `berries`
    branch, `ef6c382..ab9f231`. Lastly, it gives the name of the two branches, the
    local and the remote branches, `berries -> berries`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we obviously want to see if, in the remote repository, there is a new
    commit in the `berries` branch; so, open the `grocery` folder in a new console
    and do `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Yes, wonderful!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just a little warning: usually, a remote repository copy is managed as a **bare
    repository**; in [Chapter 4](406afcc0-b4a9-45b3-b238-a4d52873c9df.xhtml), *Git
    Fundamentals - Niche Concepts, Configurations, and Commands*, we will spend some
    words on it. As you normally won''t work directly on it, a bare repository contains
    only the `.git` folder; it doesn''t have a checked out working tree nor a HEAD
    reference. Instead, we use a normal repository as a remote. This is not a problem;
    you have just to remember one thing: you cannot push changes to the actual checked
    out remote branch.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, in that `grocery` repository, we are actually on the `master` branch,
    and in the `grocery-cloned` repository, we push the `berries` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is quite simple to understand: by pushing to a remote checked
    out branch, you will affect the work in progress on that repository, maybe destroying
    ongoing changes, and this is not fair.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting remote commits with git pull
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to experiment the inverse: retrieving updates from the remote
    repository and applying them to our local copy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, make a new commit in the `grocery` repository, and then, we will download
    it into the `grocery-cloned` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I firstly need to create a new line, because due to the previous *grape rebase*,
    we ended having the `shoppinList.txt` file with no new line at the end, as `echo
    "" >> <file>` usually does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: OK, now back to the `grocery-cloned` repository.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve objects from a remote with `git pull`.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, `git pull` is a *super command*; in fact, it is basically the sum
    of two other Git commands, `git fetch` and `git merge`. While obtaining objects
    from a remote, Git won't force you to merge them into a local branch; this can
    seem a little bit confusing at first, as in other versioning systems, such as
    Subversion, this is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, Git is more conservative: it could happen that someone pushed a commit
    or more on top of a branch, but you realized those commits are not good for you,
    or simply they are just wrong. So, using `git fetch`, you can get and inspect
    them before applying them on your local branch with a `git merge`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try `git pull` for now, then we will try to use `git fetch` and `git merge`
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `grocery-cloned` repository, switch to the `master` branch,
    and do a `git pull`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Git says that our branch is up-to-date with `'origin/master'`, but this is not
    true, as we just did a new commit there. This is because, for Git, the only way
    to know if we are updated in respect a remote repository is to perform a `git
    fetch`, and we didn't. Later we will see this more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, go with `git pull`: the command wants you to specify the name of the
    remote you want to pull from, which is `origin` in this case, and then the branch
    you want to merge into your local one, which is `master`, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Good! Git tells us that there are three new objects to fetch; after it has obtained
    them, it performs a merge on top of the local `master` branch, and in this case,
    it performs a fast-forward merge.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, now I want you to try doing these steps in a separate manner; create the
    umpteenth new commit in the `grocery` repository, the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now perform a `git fetch` on `grocery-cloned` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Git found new objects on the remote, and it downloaded them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can do a `git fetch` in whatever branch you are in, as it simply
    downloads remote objects; it won't merge them. Instead, while doing a `git pull`,
    you have to be sure to be in the right local target branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do a `git status` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: OK, as you can see, when there is a remote, `git status` informs you even on
    the state of the *synchronization* between your local repository and the remote
    one; here it tells us we are behind the remote because it has because it has one commit
    more than us in the `master` branch, and that commit can be fast-forwarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s sync with a `git merge`; to merge a remote branch, we have to specify,
    other than the branch name, even the remote one, as we did in the `git pull` command
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That's all!
  prefs: []
  type: TYPE_NORMAL
- en: This is basically what you need to know to work with remotes. Note that, if
    some changes on the remote are in conflict with the local ones, you will have
    to solve them as we did in the previous merge examples.
  prefs: []
  type: TYPE_NORMAL
- en: How Git keeps track of remotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git stores remote branch labels in a similar way to how it stores the local
    branches ones; it uses a subfolder in `refs` for the scope, with the symbolic
    name we used for the remote, in this case `origin`, the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The command to deal with remotes is `git remote`; you can add, remove, rename,
    list, and do a lot of other things with them; there's no room here to see all
    the options. Please refer to the Git guide if you need to know more about the
    `git remote` command.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will play a little bit with a remote on a public server; we will use
    free GitHub hosting for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a public server on GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start working with a public hosted remote, we have to get one. Today, it
    is not difficult to achieve; the world has plenty of free online services offering
    room for Git repositories. One of the most commonly used is **GitHub**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new GitHub account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub offers unlimited free public repositories, so we can make use of it without
    investing a penny. In GitHub, you have to pay only if you need private repositories;
    for example, to store closed source code you base your business on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new account is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://github.com](https://github.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sign up, filling the textboxes, as per the following image, and provide a username,
    a password, and your email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88f28145-6321-46de-a694-06d66c0b087b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When done, we are ready to create a brand new repository in which to push our
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0e47506-62c7-4fc3-8433-322436fbf9c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the Repositories tab, click the green New button, and choose a name for
    your repository, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/290ff070-b9e4-4385-8fc0-ac91f4953974.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of learning, I will create a simple repository for my personal
    recipes, written using the **markdown markup language** ([http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06dd1613-78b2-49db-b3aa-9c19dd509dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, you can write a description for your repository; this is useful for allowing
    people that come to visit your profile to better understand what your project
    is intended for. We create our repository as public because private repositories
    have a cost, as we said before, and then we initialize it with a `README` file;
    choosing this, GitHub makes a first commit for us, initializing the repository
    that now is ready to be cloned.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a remote repository, it's time to *hook* it locally. For this,
    Git provides the `git clone` command, as we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this command is quite simple; in this case, all we need to know is the
    URL of the repository to clone. The URL is provided by GitHub on the right down
    part of the repository home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ff5ab15-8bf0-43da-863e-5d64b80fbe74.png)'
  prefs: []
  type: TYPE_IMG
- en: To copy the URL, you can simply click the clipboard button at the right of the
    textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try to follow these steps together:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to a local root folder for the repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Bash shell within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `git clone https://github.com/fsantacroce/Cookbook.git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Obviously, the URL of your repository will be different; as you can see, GitHub
    URLs are composed as follows: `https://github.com/<Username>/<RepositoryName>.git`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At this point, Git creates a new `Cookbook` folder containing the downloaded
    copy of our repository; inside, we will find a `README.md` file, a classical one
    for a GitHub repository. In that file, you can describe your repository using
    the common markdown markup language to users who will chance upon it.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading modifications to remotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s try to edit the `README.md` file and upload modifications to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `README.md` file using your preferred editor, adding, for example,
    a new sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to the index and then commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put your commit on the remote repository using the `git push` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But firstly, set the user and email this time, so Git will not output the message
    we have seen in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to type `git push` and press `ENTER`, without specifying anything
    else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in my Windows 10 workstation, this window appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81e9d578-11b8-4fbc-b3c4-29c0eadd2ad8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the **Git Credential Manager**; it allows you to set credentials on
    your Windows machine. If you are on Linux or macOS, the situation may be different,
    but the underlying concept is the same: we have to give Git the credentials in
    order to access the remote GitHub repository; they will then be stored to our
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input your credentials, and then press the Login button; after that, Git continues
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git push` command allows you to *upload* local work to a configured remote
    location; in this case, a remote GitHub repository, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4855a7b-154d-4736-99c2-65139bc5ec6c.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a few more things we need know about pushing; we can begin to understand
    the message Git gave us just after we ran the `git push` command.
  prefs: []
  type: TYPE_NORMAL
- en: What do I send to the remote when I push?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you give a `git push` without specifying anything else, Git sends all the
    **new commits** and all the related objects you did locally in your current branch
    to the remote; for *new commits*, it mean that we will send only local commits
    that have not been uploaded yet.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a new branch to the remote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, we can create and push a new branch to the remote to make our work
    public and visible to other collaborators; for instance, I will create a new branch
    for a new recipe, then I will push to the remote GitHub server. Follow these simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new branch, for instance `Risotti`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to it a new file, for example, `Risotto-alla-Milanese.md`, and commit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Push the branch to the remote using `git push -u origin Risotti`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before continuing, we have to examine in depth some things that happened after
    this `git push` command.
  prefs: []
  type: TYPE_NORMAL
- en: The origin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `git push -u origin Risotti` command, we told Git to upload our `Risotti`
    branch (and the commits within it) to the `origin`; with the `-u` option, we set
    the local branches to track the remote one.
  prefs: []
  type: TYPE_NORMAL
- en: We know that `origin` is the default remote of a repository, just as `master`
    is the default branch name; when you clone a repository from a remote, that remote
    becomes your `origin` alias. When you tell Git to push or pull something, you
    often have to tell it the remote you want to use; using the alias `origin`, you
    say to Git you want to use your default remote.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see remotes actually configured in your repository, you can
    type a simple `git remote` command, followed by `-v` (`--verbose`) to get some
    more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the details, you will see the full URL of the remote and discover that Git
    stores two different URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch URL, which is where we take updates from others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Push URL, which is where we send out updates to others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows us to push and pull changes from different remotes, if you like,
    and underlines how Git can be considered a peer-to-peer versioning system.
  prefs: []
  type: TYPE_NORMAL
- en: You can add, update, and delete remotes using the `git remote` command.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `-u` option, we told Git to **track** the remote branch. Tracking
    a remote branch is *the way to tie your local branch with the remote one*; please
    note that this behavior is not automatic, you have to set it if you want it. When
    a local branch tracks a remote branch, you actually have a local and a remote
    branch that can be kept easily in sync (please note that a local branch can track
    only one remote branch). This is very useful when you need to collaborate with
    some remote coworkers at the same branch, allowing all of them to keep their work
    in sync with other people's changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the way our repository is now configured, try to type
    `git remote show origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Pasta` **,** `Risotti`, and `master` branches are all tracked.
  prefs: []
  type: TYPE_NORMAL
- en: 'You see also that your local branches are configured to push and pull to remote
    branches with the same name, but remember: it is not mandatory to have local and
    remote branches with the same name; the local branch, `foo`, can track the remote
    branch, `bar`, and vice versa; there''s no restrictions.'
  prefs: []
  type: TYPE_NORMAL
- en: Going backward – publishing a local repository to GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commonly, you will find yourself needing to put your local repository on a shared
    place where someone else can look at your work; in this section, we will learn
    how to achieve this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local repository to publish, following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to our local repositories folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `HelloWorld` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In it place a new repository, as we did in first chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `README.md` file and commit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the GitHub repository as we did previously; this time leave it
    empty. Don''t initialize it with a readme file; we already have one in our local
    repository. The following is a screenshot taken directly from the GitHub repository
    creation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abda2e4b-32cb-466c-8579-d53ae9113ba7.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we are ready to publish our local repository on GitHub or, even
    better, to add a remote to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a remote to a local repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To publish our `HelloWorld` repository, we simply have to add its first remote;
    adding a remote is quite simple: `git remote add origin <remote-repository-url>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is the full command we have to type in the Bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Adding a remote, like adding or modifying other configuration parameters, simply
    consists of editing some text files in the `.git` folder, so it is blazing fast.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a local branch to a remote repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After that, push your local changes to the remote using `git push -u origin
    master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That's all!
  prefs: []
  type: TYPE_NORMAL
- en: Social coding - collaborating using GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitHub''s trademark is the concept of so-called **social coding**; from its
    first steps, GitHub made it easy to share code, track other people''s work, and
    collaborate using two basic concepts: **forks** and **pull requests**. In this
    section, I will illustrate them in brief.'
  prefs: []
  type: TYPE_NORMAL
- en: Forking a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forking is a common concept for a developer; if you have already used a GNU-Linux
    based distribution, you know that there are some forefathers, such as Debian,
    and some derived distro, such as Ubuntu, also commonly called *forks* of the original
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GitHub things are similar. At some point, you find an interesting open-source
    project you want to modify slight to perfectly fit your needs; at the same time,
    you want to benefit from bug fixes and new features from the original project,
    keeping your work in touch. The right thing to do in this situation is to *fork*
    the project. But first, remember: **fork is not a Git term**, but GitHub terminology.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you fork on GitHub, what you get *is essentially a server-side clone of
    the repository* on your GitHub account; if you clone your forked repository locally,
    in the remote list, you will find an `origin` that points to your account repository,
    while the original repository will assume the *upstream* alias (you have to add
    it manually anyway):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f40a810c-1bc9-47bb-a10e-590a4e3e615d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To better understand this feature, go to your GitHub account and try to fork
    a common GitHub repository called `Spoon-Knife`, made by GitHub mascot user `octocat`;
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your GitHub account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for `spoon-knife` using the search textbox located up on the left of the
    page:![](img/903d4a2e-a861-4b04-b755-1e5b69a212ad.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the first result, octocat/Spoon-Knife repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fork the repository using the Fork button at the right of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be37c6fd-ee2d-40c1-88d6-2a044217d435.png)'
  prefs: []
  type: TYPE_IMG
- en: After a funny photocopy animation, you will get a brand-new Spoon-Knife repository
    in your GitHub account:![](img/d6a1bfda-c56b-43ce-9b96-1c2e38833649.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can clone that repository locally, as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `upstream` remote is not present, you have to add it manually;
    to add it, use the `git remote add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can keep your local repository in sync with the changes in your remote,
    the `origin`, and you can also get those ones coming from the `upstream` remote,
    the original repository you forked. At this point. you are probably wondering
    how to deal with two different remotes; well, it is easy: simply pull from the
    `upstream` remote and merge those modifications in your local repository, then
    push them into your `origin` remote in a bundle with your changes. If someone
    else clones your repository, he or she will receive your work merged with the
    work done by someone else on the original repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Submitting pull requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you created a fork of a repository, it is because you are not a direct contributor
    of the original project, or simply you don't want to make a mess in other people's
    work before becoming familiar with the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, at a certain point, you realize your work can be useful even for the
    original project: you realize a better implementation of a previous piece of code,
    you add a missing feature, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: So, you find yourself needing to notify the original author that you did something
    interesting, asking him if he wants to take a look and, maybe, integrate your
    work. This is the moment when **pull requests** come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pull request is a way to tell the original author *Hey! I did something interesting
    using your original code, do you want to take a look and integrate my work, if
    you find it good enough?* This is not only a technical way to achieve the purpose
    of integrating work, but it is even a powerful practice for promoting **code reviews**
    (and then the so-called *social coding*) as recommended by *eXtreme Programming*
    fellows (for more information, visit: [http://en.wikipedia.org/wiki/Extreme_programming](http://en.wikipedia.org/wiki/Extreme_programming)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason to use a pull request is that **you cannot push directly** to
    the `upstream` remote **if you are not a contributor** of the original project:
    pull requests are the only way. In small scenarios (such as a team of two or three
    developers that works in the same room) probably the *fork and pull* model represents
    an overhead, so it is more common to directly share the original repository with
    all the contributors, skipping the fork and pull ceremony.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pull request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a pull request, you have to go on your GitHub account and make it
    directly from your forked account; but first, you have to know that **pull requests
    can be made only from separated branches**. At this point of the book, you are
    probably used to creating a new branch for a new feature or refactor purpose,
    so this is nothing new, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an attempt, let''s create a local `TeaSpoon` branch in our repository,
    commit a new file, and push it to our GitHub account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at your account, you will find a surprise: in your `Spoon-Knife`
    repository, there is now a New pull request button made for the purpose of starting
    a pull request, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0306886-7497-4f8e-a786-d28985c538ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking that button makes GitHub open a new page; you now have to select the
    branch you want to compare to the original repository; look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75b3eb4c-4364-41cf-9086-a633ecb5206d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the branches combo (1), select TeaSpoon branch (2), and then GitHub will
    show you something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/032e325b-307a-4a93-a6bd-6a3d7e8fa421.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a report, where you can see what you are going to propose: a commit
    containing a new file.'
  prefs: []
  type: TYPE_NORMAL
- en: But let me analyze the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top left corner of the preceding screenshot, you will find what branches
    GitHub is about to compare for you; take a look at details in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9a033e7-155d-4c5f-bbf3-11e61eccd837.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that you are about to compare your local `TeaSpoon` branch with
    the original `master` branch of the `octocat` user. At the end of the page, you
    can see all the different details (files added, removed, changed, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99b0ef05-12dd-4830-b66d-a5241e17aabc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can click on the green Create pull request button; the window in the
    following screenshot will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5347094-ea35-4be5-a770-bf2922665f1d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the central part of the page, you can describe the work you did in your branch.
    A green Able to merge text on the top left informs you that these two branches
    can be automatically merged (there are no unresolved conflicts; that is always
    good if you want to see your work considered).
  prefs: []
  type: TYPE_NORMAL
- en: 'And now the last step: click the Create pull request button to send your request
    to the original author, letting him get your work and analyze it before accepting
    the pull request.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, a new conversation begins, where you and the project collaborators
    can start to discuss your work; during this period, you and other collaborators
    can change the code to better fit common needs, until an original repository collaborator
    decides to accept your request or discard it, closing the pull request.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finally got in touch with the Git ability to manage multiple
    remote copies of repositories. This gives you a wide range of possibilities to
    better organize your collaboration workflow inside your team. In the next chapter,
    you will learn some advanced techniques using well-known and niche commands. This
    will make you a more secure and proficient Git user, allowing you to resolve some
    common issues that occur in a developer's life with ease.
  prefs: []
  type: TYPE_NORMAL
