<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Infrastructure as Code with Terraform</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText"><span>In <a href="8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml">Chapter 3</a>, <em>Treating Your Infrastructure as Code</em>, we familiarized ourselves with AWS CloudFormation and Ansible. We created a CloudFormation template to create an EC2 environment and deployed a HelloWorld web application on it. Taking a step further in the world of automation, we then introduced the <strong>Ansible </strong>configuration management tool. We learnt about how Ansible takes care of application deployment and orchestration so that CloudFormation templates remain neat and confined until provisioning. This approach is well accepted by the tech giants as far as the AWS cloud is concerned, but when we talk about heterogeneous environments where we have multiple cloud platforms such as AWS, Azure, Google cloud, OpenStack, and VMware then CloudFormation service, as it is a AWS-native service, is not applicable.</span></p>
<p class="MsoBodyText"><span>Hence, we need an alternative solution that will </span><span>not only </span><span>help us to provision compute services but also other cloud native services without much effort. Obviously, this is possible using complex, unmanageable scripts in imperative way, but we'd end up making the environments even more complex. We need a solution that will keep the heterogeneous environment simple and manageable, with a declarative approach that follows the recommended guidelines regarding using <strong>Infrastructure as Code</strong> (<strong>IaC</strong>). This solution is <strong>Terraform</strong></span><span>, </span><span>a tool for building, changing, and versioning infrastructure safely and efficiently. </span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is Terraform?</li>
<li>Creating a Terraform repository</li>
<li>Integrating AWS, Terraform, and Ansible</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The technical requirements are as follows:</p>
<ul>
<li class="MsoBodyText">AWS Console</li>
<li class="MsoBodyText">Git</li>
<li class="MsoBodyText">GitHub</li>
<li class="MsoBodyText">Terraform</li>
<li class="MsoBodyText">Ansible</li>
</ul>
<p>The following websites provide further information about Terraform:</p>
<ul>
<li class="MsoBodyText">Terraform official website for product information: <a href="https://terraform.io" target="_blank">https://terraform.io</a></li>
<li class="MsoBodyText">Terraform supported provide details: <a href="https://www.terraform.io/docs/providers/" target="_blank">https://www.terraform.io/docs/providers/</a></li>
<li class="MsoBodyText">HashiCorp configuration language details: <a href="https://github.com/hashicorp/hcl" target="_blank">https://github.com/hashicorp/hcl</a></li>
<li class="MsoBodyText">GitHub link for Terraform template for the first project: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf" target="_blank">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf</a></li>
<li class="MsoBodyText">GitHub link for Terraform template for the second project: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf" target="_blank">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf</a></li>
<li class="MsoBodyText">Github link for Terraform template for the third project: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf" target="_blank">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf</a></li>
<li class="MsoBodyText">Github link for Terraform template for the fourth project: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf" target="_blank">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Terraform?</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Terraform is an open-source, IaC software that was released in July 2014 by a company named <strong>HashiCorp</strong>. This is the same company that produced tools including Vagrant, Packer, and Vault. Terraform was released under the <strong>Mozilla Public License</strong> (<strong>MPL</strong>) version 2.0. The source code for Terraform is available on GitHub at <a href="https://github.com/hashicorp/terraform">https://github.com/hashicorp/terraform</a>. Anyone can use this source code and contribute to Terraform's development.</p>
<p class="MsoBodyText">Terraform allow users to define a datacenter infrastructure in a high-level configuration language called <strong>HashiCorp Configuration Language</strong> (<strong>HCL</strong>). HashiCorp also provide the Enterprise version of Terraform, which comes with added support. There are lot of features available with Terraform, which makes it a perfect high-level infrastructure orchestration tool. It has the following features:</p>
<ul>
<li class="mce-root"><span>It has very easy and minimal installation steps.</span></li>
<li>It has a declarative approach to write Terraform templates.</li>
<li>It is available as both open-source and Enterprise offerings.</li>
<li>It has idempotency, which means the Terraform templates provide the same result every time you apply them in your environment.</li>
<li>It is a perfect match for almost all majorly available cloud platforms such as AWS, Azure, GCP, OpenStack, DigitalOcean, and so on. Refer to <a href="https://www.terraform.io/docs/providers/">https://www.terraform.io/docs/providers/</a> for more details.</li>
</ul>
<p><strong>However, Terraform is not<em>:</em></strong></p>
<ul>
<li><span>A configuration management tool like Puppet, Chef, Ansible, or SaltStack. You can install some lightweight programs or software to ship some important configuration files inside your instances, but when it comes to the deployment and orchestration of more complex applications, you need to use configuration tools like those listed in the preceding section.</span></li>
<li>A low-level tool like Boto for AWS.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Terraform</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">In this book, we will focus on open-source Terraform. We will be demonstrating the complete Terraform setup on the CentOS 7.x machine that we used in the previous chapters. HashiCorp does not provide native packages for operating systems, so Terraform is distributed as a single binary, packaged inside a ZIP archive.</p>
<p class="MsoBodyText">Let's set up Terraform on our CentOS server. Follow these steps:</p>
<ol>
<li>We have to download the Terraform binaries from the official website: <a href="https://www.terraform.io/downloads.html">https://www.terraform.io/downloads.html</a>. In our case, we will be using Linux 64-bit:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/07cd1d07-a578-4c7d-bc18-36f0e93c6fff.png"/></p>
<ol start="2">
<li class="MsoBodyText">
<p>Unzip the extracted Terraform <kbd>.zip</kbd> file. You need to install the unzip package if it is not already <span>present</span>:</p>
</li>
</ol>
<pre style="padding-left: 90px"><strong>$ yum -y install unzip</strong><br/><strong>$ echo $PATH</strong><br/><strong>$ unzip terraform_0.11.8_linux_amd64.zip -d /usr/bin/</strong></pre>
<p class="MsoBodyText" style="padding-left: 60px">This will extract the Terraform binary to the <kbd>/usr/bin</kbd>, which is available in the <span class="packt_screen">PATH</span> environment variable for your Linux systems.</p>
<ol start="3">
<li class="MsoBodyText">
<p>Finally, check the installed version of Terraform. The latest version of Terraform software available at the time of writing is the following:</p>
</li>
</ol>
<pre style="padding-left: 90px"><strong>$ terraform -v</strong><br/><strong>Terraform v0.11.8</strong></pre>
<p class="MsoBodyText" style="padding-left: 60px">As you can observe, setting up Terraform takes just a matter of minutes and it has very lightweight binaries. We are now all set to use the Terraform environment for AWS service provisioning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terraform and AWS for automated provisioning</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">As mentioned previously, Terraform supports multiple providers such as AWS, Azure, and GCP for high level infrastructure orchestration. In this book, we will use only the AWS platform. As we saw at in <a href="1abe175d-50df-434d-bc0a-097397a39cee.xhtml">Chapter 2</a>, <em>Deploying Your First Web Application</em>, we can deploy compute services or any AWS service using two modes:</p>
<ul>
<li class="mce-root"><span>AWS Management Console</span></li>
<li>AWS <strong>Command Line Interface</strong> (<strong>CLI</strong>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment using AWS Management Console</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Here, we will focus on deploying the AWS compute service as we did previously. Deploying AWS instances using the AWS Management Console is fairly simple. Follow the steps below:</p>
<ol>
<li class="mce-root"><span>Log in into your AWS Management Console at</span> <a href="https://console.aws.amazon.com" target="_blank">https://console.aws.amazon.com</a> <span>or use your IAM user account to log in . We created an IAM user account in</span> <a href="1abe175d-50df-434d-bc0a-097397a39cee.xhtml">Chapter 2</a><span>,</span> <em>Deploying Your First Web Application</em><span> at</span> <kbd>https://AWS-account-ID-or-alias.signin.aws.amazon.com/console</kbd><span>.</span></li>
<li>Select the <span class="packt_screen">Services</span> tab, followed by <span class="packt_screen">EC2</span> from the <span class="packt_screen">Compute</span> section, and click on the <span class="packt_screen">Launch Instance</span> button.</li>
<li>On the next screen, search for and select <strong>Amazon Machine Image</strong> (<strong>AMI</strong>). In this book, we are using <kbd>ami-cfe4b2b0</kbd>, which is Amazon Linux AMI.</li>
<li>Select the <kbd>t2.micro</kbd> type from the <span class="packt_screen">Choose an Instance Type</span> step and click on the <span class="packt_screen">Next: Configure Instance Details</span> button.</li>
<li>Accept the default settings and click the <span class="packt_screen">Next: Add Storage</span> button.</li>
<li>Again, accept the default setting for storage and click on the <span class="packt_screen">Next: Add tags</span> button followed by the <span class="packt_screen">Next: Configure Security Group</span> button.</li>
</ol>
<ol start="7">
<li>Here, select the security group you created in <a href="1abe175d-50df-434d-bc0a-097397a39cee.xhtml">Chapter 2</a>, <em>Deploying Your First Web Application</em>, which in my case is <kbd>sg-01864b4c</kbd>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/84638492-0f99-42cc-9943-fea369e16fc2.png"/></p>
<ol start="8">
<li class="MsoBodyText">Now, click on the <span class="packt_screen">Review and Launch</span> button. Ignore any warnings that appear and press the <span class="packt_screen">Launch</span> button.</li>
<li class="MsoBodyText">Select the key-pair, which in my case is <kbd>EffectiveDevOpsAWS</kbd>. Click the <span class="packt_screen">Launch Instances</span> button.</li>
</ol>
<p class="MsoBodyText">Within a few minutes, your AWS instance will be up and running. Once the server is up, log in to the server from your local instance, which is CentOS in my case. Proceed with the following process to deploy the Hello World application manually and verify it locally or from the browser:</p>
<pre><strong>$ ssh -i ~/.ssh/EffectiveDevOpsAWS.pem ec2-user@34.201.116.2 </strong>(replace this IP with your AWS public IP)<br/><strong>$ sudo yum install --enablerepo=epel -y nodejs</strong><br/><strong>$ sudo wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.js -O /home/ec2-user/helloworld.js</strong><br/><strong>$ sudo wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.conf -O /etc/init/helloworld.conf</strong><br/><strong>$ sudo start helloworld</strong><br/><strong><br/>$ curl http://34.201.116.2:3000/</strong><br/><strong>Hello World</strong></pre>
<div class="MsoBodyText packt_infobox">Remember to terminate the instance from the AWS Management Console once you are done with the test.</div>
<p class="MsoBodyText">The termination process is also very straightforward. Select the created instance, click the <span class="packt_screen">Actions</span> drop-down, followed by the <span class="packt_screen">Instance State</span> option and then click <span class="packt_screen">Terminate,</span> as shown in the following screenshot:</p>
<p class="MsoBodyText CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-524 image-border" src="assets/6d672c5a-97c1-4aa0-8b97-bc792a0d98b5.png" style="width:113.58em;height:58.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment using AWS CLI</h1>
                </header>
            
            <article>
                
<p>The steps for creating an instance and deploying the Hello World web application using AWS CLI have already been demonstrated in <a href="1abe175d-50df-434d-bc0a-097397a39cee.xhtml">Chapter 2</a>, <em>Deploying Your First Web Application</em>. You need to make sure to install the <kbd>awscli</kbd> utility before proceeding further. Here is a quick overview for deploying the Hello World web application using AWS CLI:</p>
<pre><strong>$ aws ec2 run-instances \</strong><br/><strong>    --instance-type t2.micro \</strong><br/><strong>    --key-name EffectiveDevOpsAWS \</strong><br/><strong>    --security-group-ids sg-01864b4c \</strong><br/><strong>    --image-id ami-cfe4b2b0</strong><br/><br/><strong>$ aws ec2 describe-instances \</strong><br/><strong>    --instance-ids i-0eb05adae2bb760c6 \</strong><br/><strong>    --query "Reservations[*].Instances[*].PublicDnsName"</strong></pre>
<p>Make sure to replace <kbd>i-0eb05adae2bb760c6</kbd> with the AWS instance ID that you created in the previous command.</p>
<pre><strong>$ ssh -i ~/.ssh/EffectiveDevOpsAWS.pem ec2-user@ec2-18-234-227-160.compute-1.amazonaws.com</strong><br/><strong>$ sudo yum install --enablerepo=epel -y nodejs</strong><br/><strong>$ sudo wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.js -O /home/ec2-user/helloworld.js</strong><br/><strong>$ sudo wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.conf -O /etc/init/helloworld.conf</strong><br/><strong>$ sudo start helloworld</strong><br/><strong><br/>$ curl http://ec2-18-234-227-160.compute-1.amazonaws.com:3000/</strong><br/> <strong>Hello World</strong></pre>
<div class="packt_infobox">Remember to terminate the instance using <kbd>aws ec2 terminate-instances --instance-ids &lt;AWS INSTANCE ID&gt;</kbd> once you are done with the testing.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our Terraform repository</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">We have now looked at two modes for creating AWS EC2 instances: using AWS Management Console and using AWS CLI. These can be automated using the AWS cloud native service called <strong>CloudFormation template</strong>, as we saw in <a href="8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml">Chapter 3</a>, <em>Treating Your Infrastructure as Code. </em>This is only applicable for use with the AWS cloud. In this chapter, we will achieve the same results of provisioning AWS instances using Terraform. Refer to <a href="https://www.terraform.io/intro/vs/cloudformation.html">https://www.terraform.io/intro/vs/cloudformation.html</a> to understand the differences between Terraform and CloudFormation.</p>
<p class="MsoBodyText">Let's create a dedicated repository in our GitHub account and start our journey with Terraform. Once you've logged in to GitHub, create a new repository for the Terraform templates by following the steps below:</p>
<ol>
<li class="mce-root"><span>In your browser, open</span> <span><a href="https://github.com/new" target="_blank">https://github.com/new</a></span><span>.</span></li>
<li><span>Call the new repository <kbd>EffectiveDevOpsTerraform</kbd> as shown in the following screenshot:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b675f6aa-9701-4ca5-ae8d-de5df2f827e5.png"/></p>
<ol start="3">
<li>Check the <span class="packt_screen">Initialize this repository with a README</span> checkbox.</li>
<li><span>Finally, click the <span class="packt_screen">Create repository</span> button.</span></li>
<li>Once your repository is created, you will want to clone it to your system. To do this, you need to have Git installed. If you don't have Git yet, search on Google for instructions on how to install it for your operating system. For CentOS, you just need to run <kbd>yum -y install git</kbd> as the Git package is part of the Linux distribution now:</li>
</ol>
<pre style="padding-left: 90px"><strong>$ git clone https://github.com/&lt;your_github_username&gt;/EffectiveDevOpsTerraform</strong></pre>
<p class="MsoBodyText" style="padding-left: 60px">Now that the repository is cloned, it's time to start developing Terraform templates. Go into the <kbd>EffectiveDevOpsTerraform</kbd> repository and create a directory called <kbd>firstproject</kbd>:</p>
<pre class="MsoBodyText" style="padding-left: 90px"><strong>$ cd EffectiveDevOpsTerraform</strong><br/><strong>$ mkdir firstproject</strong><br/><strong>$ cd firstproject</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First Terraform template for AWS instance provisioning</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Terraform is used to create, manage, and update infrastructure resources such as virtual machines, cloud instances, physical machines, containers, and much more. Almost any infrastructure type can be represented as a resource in Terraform. We are going to create a resource in the next step. Before that, we need to understand <em>Terraform providers,</em> which are responsible for understanding API interactions and exposing resources. A provider could be IaaS (such as AWS, GCP, and so on), PaaS (such as Heroku) or SaaS (such as DNSimple). The provider is the first section with which we have to start our Terraform templates. Before using Terraform to create an instance, we need to configure the AWS provider. This is the first piece of code that we are going to write in our template.</p>
<p class="MsoBodyText">Templates are written in a special language called HCL. More details about HCL can be found at <a href="https://github.com/hashicorp/hcl">https://github.com/hashicorp/hcl</a>. You can also write your templates in JSON, but we will be using HCL here. Terraform template files must have the extension <kbd>.tf</kbd>, which stands for <strong>Terraform file</strong>. Let's create our first template, <kbd>ec2.tf</kbd>:</p>
<pre>provider "aws" {<br/>access_key = "&lt;YOUR AWS ACCESS KEY&gt;"<br/>secret_key = "&lt;YOUR AWS SECRET KEY&gt;"<br/>region = "us-east-1"<br/>}</pre>
<p class="MsoBodyText">Visit <a href="https://www.terraform.io/docs/providers/aws/index.html">https://www.terraform.io/docs/providers/aws/index.html</a> to explore more options about the AWS provider.</p>
<p class="MsoBodyText">This type of declaration for providers in Terraform is called <em>configuring providers using static credentials. </em>It is not a secure way of declaring providers; there are other options in Terraform, such as environment variables, Terraform variable files, AWS native credential files (<kbd>~/.aws/credentials</kbd>), and so on, for storing providers with sensitive information.</p>
<div class="MsoBodyText packt_tip">Do not push your AWS access key or your secret key on GitHub or any other public website. Doing so will allow hackers to hack your AWS account.</div>
<p class="MsoBodyText">Before moving on, we need to install the plugin or reinitialize the plugins that are related to AWS for Terraform. We don't need to do much here; the configured file with the <kbd>provider</kbd> plugins will perform this task for us. </p>
<p>Run the following command:</p>
<pre class="MsoBodyText"><strong>$ terraform init</strong></pre>
<p class="mce-root">The output of the preceding command is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/447b2674-ac14-4a99-9492-8cd881d34792.png"/></p>
<p class="MsoBodyText">The next step is to configure our infrastructure. This is where we start developing the <kbd>ec2.ft</kbd> file with Terraform resources. Resources are components of your infrastructure. They can be as complex as a complete virtual server that has multiple other services, or as simple as a DNS record. Each resource belongs to a provider and the type of the resource is suffixed with the provider name. The configuration of a resource, <span>which is called a </span><span><kbd>resource</kbd> block</span><span>, takes the following form:</span></p>
<pre class="MsoBodyText">resource "provider-name_resource-type" "resource-name" {<br/>parameter_name = “parameter_value”<br/>parameter_name = “parameter_value”<br/>.<br/>.<br/>}</pre>
<p class="MsoBodyText">In our case, we have to create an EC2 instance. The <kbd>aws_instance</kbd> resource in Terraform is responsible for this job. To create an instance, we need to set at least two parameters: <kbd>ami</kbd> and <kbd>instance_type</kbd>. These two parameters are required, whereas the others are optional. In order to get a list and a description of all the <kbd>aws_instance</kbd> resource parameters, check out the following website: <a href="https://www.terraform.io/docs/providers/aws/r/instance.html">https://www.</a><a href="https://www.terraform.io/docs/providers/aws/r/instance.html">terraform.io/docs/providers/aws/r/instance.html</a>.</p>
<p class="MsoBodyText">In our case we will create an instance with the same details with which we created and tested the instance using the AWS Management Console and the AWS CLI utility. We have <kbd>ami-cfe4b2b0</kbd> as AMI and <kbd>t2.micro</kbd> as our instance type. <kbd>EffectiveDevOpsAWS</kbd> is the key name that we created in the past and <kbd>sg-01864b4c</kbd> is our security group. We are also tagging the instance with the name <kbd>helloworld</kbd> for easy recognition. It's worth mentioning that like any other scripting or automation language, you can put <em>comments</em> in the Terraform template with the <kbd>#</kbd> sign. Our complete file should now look as follows:</p>
<pre class="MsoBodyText"># Provider Configuration for AWS<br/>provider "aws" {<br/>access_key = “&lt;YOUR AWS ACCESS KEY&gt;"<br/>secret_key = "&lt;YOUR AWS SECRET KEY&gt;"<br/>region = "us-east-1"<br/>}<br/><br/># Resource Configuration for AWS<br/>resource "aws_instance" "myserver" {<br/>ami = "ami-cfe4b2b0"<br/>instance_type = "t2.micro"<br/>key_name = "EffectiveDevOpsAWS"<br/>vpc_security_group_ids = ["sg-01864b4c"]<br/>tags {</pre>
<pre class="MsoBodyText">Name = "helloworld"<br/>}<br/>}</pre>
<p class="MsoBodyText">The created file should look like the file at the following website:  <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/firstproject/ec2.tf</a>.</p>
<p class="MsoBodyText">Let's validate the Terraform template first to ensure that the template doesn't have any syntax errors. Terraform has a dedicated <kbd>terraform validate</kbd> <span>utility, </span>which checks the syntax of the Terraform template and provides us with the outputs if there are any syntax errors that need our attention:</p>
<pre class="MsoBodyText"><strong>$ terraform validate</strong></pre>
<p class="MsoBodyText">As there are no outputs, this signifies that our Terraform template is free from syntax errors. It's time to perform a dry run to see what this template will execute. This is just a smoke test to find out which changes or implementations will be performed by the template we have created. This step in Terraform is known as <strong>plan</strong>:</p>
<pre><strong>[root@yogeshraheja firstproject]# terraform plan</strong><br/><strong>Refreshing Terraform state in-memory prior to plan...</strong><br/><strong>The refreshed state will be used to calculate this plan, but will not be</strong><br/><strong>persisted to local or remote state storage.</strong><br/><br/><br/><strong>------------------------------------------------------------------------</strong><br/><br/><strong>An execution plan has been generated and is shown below.</strong><br/><strong>Resource actions are indicated with the following symbols:</strong><br/><strong>  + create</strong><br/><br/><strong>Terraform will perform the following actions:</strong><br/><br/><strong>  + aws_instance.myserver</strong><br/><strong>      id: &lt;computed&gt;</strong><br/><strong>      ami: "ami-cfe4b2b0"</strong><br/><strong>      arn: &lt;computed&gt;</strong><br/><strong>      associate_public_ip_address: &lt;computed&gt;</strong><br/><strong>      availability_zone: &lt;computed&gt;</strong><br/><strong>      cpu_core_count: &lt;computed&gt;</strong><br/><strong>      cpu_threads_per_core: &lt;computed&gt;</strong><br/><strong>      ebs_block_device.#: &lt;computed&gt;</strong><br/><strong>      ephemeral_block_device.#: &lt;computed&gt;</strong><br/><strong>      get_password_data: "false"</strong><br/><strong>      instance_state: &lt;computed&gt;</strong><br/><strong>      instance_type: "t2.micro"</strong><br/><strong>      ipv6_address_count: &lt;computed&gt;</strong><br/><strong>      ipv6_addresses.#: &lt;computed&gt;</strong><br/><strong>      key_name: "EffectiveDevOpsAWS"</strong><br/><strong>      network_interface.#: &lt;computed&gt;</strong><br/><strong>      network_interface_id: &lt;computed&gt;</strong><br/><strong>      password_data: &lt;computed&gt;</strong><br/><strong>      placement_group: &lt;computed&gt;</strong><br/><strong>      primary_network_interface_id: &lt;computed&gt;</strong><br/><strong>      private_dns: &lt;computed&gt;</strong><br/><strong>      private_ip: &lt;computed&gt;</strong><br/><strong>      public_dns: &lt;computed&gt;</strong><br/><strong>      public_ip: &lt;computed&gt;</strong><br/><strong>      root_block_device.#: &lt;computed&gt;</strong><br/><strong>      security_groups.#: &lt;computed&gt;</strong><br/><strong>      source_dest_check: "true"</strong><br/><strong>      subnet_id: &lt;computed&gt;</strong><br/><strong>      tags.%: "1"</strong><br/><strong>      tags.Name: "helloworld"</strong><br/><strong>      tenancy: &lt;computed&gt;</strong><br/><strong>      volume_tags.%: &lt;computed&gt;</strong><br/><strong>      vpc_security_group_ids.#: "1"</strong><br/><strong>      vpc_security_group_ids.1524136243: "sg-01864b4c"</strong><br/><br/><br/><strong>Plan: 1 to add, 0 to change, 0 to destroy.</strong><br/><br/><strong>------------------------------------------------------------------------</strong></pre>
<p class="MsoBodyText">Here, we didn't specify an <kbd>-out</kbd> parameter to save this plan, so Terraform can't guarantee that these actions <span>exactly</span><span> </span><span>will be performed if</span> <kbd>terraform apply</kbd> <span>is subsequently run:</span></p>
<pre class="MsoBodyText"><strong>[root@yogeshraheja firstproject]#</strong></pre>
<p class="MsoBodyText">Our plan stage indicates the same parameters that we want in the real execution while creating our instance. Again, don't get confused with the <kbd>&lt;computed&gt;</kbd> parameters, this just signifies that their value will be assigned when the resources are created</p>
<p class="MsoBodyText">Let's now execute our plan for real and look at how a Terraform template can be used to create an AWS instance with the defined resource parameters. Terraform does this using the <kbd>terraform apply</kbd> utility and you can think of this stage as <strong>apply</strong>. Once you execute <kbd>terraform apply</kbd>, it will ask for your approval by default for confirmation. Type <kbd>yes</kbd> to start the resource creation.</p>
<p class="MsoBodyText">In case you want to skip this interactive approval of the plan before applying it, use the <kbd>--auto-approve</kbd> option with the <kbd>terraform apply</kbd> command:</p>
<pre class="MsoBodyText"><strong>[root@yogeshraheja firstproject]# terraform apply<br/><br/>An execution plan has been generated and is shown below.<br/>Resource actions are indicated with the following symbols:<br/>  + create<br/><br/>Terraform will perform the following actions:<br/><br/>  + aws_instance.myserver<br/>      id: &lt;computed&gt;<br/>      ami: "ami-cfe4b2b0"<br/>      arn: &lt;computed&gt;<br/>      associate_public_ip_address: &lt;computed&gt;<br/>      availability_zone: &lt;computed&gt;<br/>      cpu_core_count: &lt;computed&gt;<br/>      cpu_threads_per_core: &lt;computed&gt;<br/>      ebs_block_device.#: &lt;computed&gt;<br/>      ephemeral_block_device.#: &lt;computed&gt;<br/>      get_password_data: "false"<br/>      instance_state: &lt;computed&gt;<br/>      instance_type: "t2.micro"<br/>      ipv6_address_count: &lt;computed&gt;<br/>      ipv6_addresses.#: &lt;computed&gt;<br/>      key_name: "EffectiveDevOpsAWS"<br/>      network_interface.#: &lt;computed&gt;<br/>      network_interface_id: &lt;computed&gt;<br/>      password_data: &lt;computed&gt;<br/>      placement_group: &lt;computed&gt;<br/>      primary_network_interface_id: &lt;computed&gt;<br/>      private_dns: &lt;computed&gt;<br/>      private_ip: &lt;computed&gt;<br/>      public_dns: &lt;computed&gt;<br/>      public_ip: &lt;computed&gt;<br/>      root_block_device.#: &lt;computed&gt;<br/>      security_groups.#: &lt;computed&gt;<br/>      source_dest_check: "true"<br/>      subnet_id: &lt;computed&gt;<br/>      tags.%: "1"<br/>      tags.Name: "helloworld"<br/>      tenancy: &lt;computed&gt;<br/>      volume_tags.%: &lt;computed&gt;<br/>      vpc_security_group_ids.#: "1"<br/>      vpc_security_group_ids.1524136243: "sg-01864b4c"<br/><br/><br/>Plan: 1 to add, 0 to change, 0 to destroy.<br/><br/>Do you want to perform these actions?<br/>  Terraform will perform the actions described above.<br/>  Only 'yes' will be accepted to approve.<br/><br/>  Enter a value: yes<br/><br/>aws_instance.myserver: Creating...<br/>  ami: "" =&gt; "ami-cfe4b2b0"<br/>  arn: "" =&gt; "&lt;computed&gt;"<br/>  associate_public_ip_address: "" =&gt; "&lt;computed&gt;"<br/>  availability_zone: "" =&gt; "&lt;computed&gt;"<br/>  cpu_core_count: "" =&gt; "&lt;computed&gt;"<br/>  cpu_threads_per_core: "" =&gt; "&lt;computed&gt;"<br/>  ebs_block_device.#: "" =&gt; "&lt;computed&gt;"<br/>  ephemeral_block_device.#: "" =&gt; "&lt;computed&gt;"<br/>  get_password_data: "" =&gt; "false"<br/>  instance_state: "" =&gt; "&lt;computed&gt;"<br/>  instance_type: "" =&gt; "t2.micro"<br/>  ipv6_address_count: "" =&gt; "&lt;computed&gt;"<br/>  ipv6_addresses.#: "" =&gt; "&lt;computed&gt;"<br/>  key_name: "" =&gt; "EffectiveDevOpsAWS"<br/>  network_interface.#: "" =&gt; "&lt;computed&gt;"<br/>  network_interface_id: "" =&gt; "&lt;computed&gt;"<br/>  password_data: "" =&gt; "&lt;computed&gt;"<br/>  placement_group: "" =&gt; "&lt;computed&gt;"<br/>  primary_network_interface_id: "" =&gt; "&lt;computed&gt;"<br/>  private_dns: "" =&gt; "&lt;computed&gt;"<br/>  private_ip: "" =&gt; "&lt;computed&gt;"<br/>  public_dns: "" =&gt; "&lt;computed&gt;"<br/>  public_ip: "" =&gt; "&lt;computed&gt;"<br/>  root_block_device.#: "" =&gt; "&lt;computed&gt;"<br/>  security_groups.#: "" =&gt; "&lt;computed&gt;"<br/>  source_dest_check: "" =&gt; "true"<br/>  subnet_id: "" =&gt; "&lt;computed&gt;"<br/>  tags.%: "" =&gt; "1"<br/>  tags.Name: "" =&gt; "helloworld"<br/>  tenancy: "" =&gt; "&lt;computed&gt;"<br/>  volume_tags.%: "" =&gt; "&lt;computed&gt;"<br/>  vpc_security_group_ids.#: "" =&gt; "1"<br/>  vpc_security_group_ids.1524136243: "" =&gt; "sg-01864b4c"<br/>aws_instance.myserver: Still creating... (10s elapsed)<br/>aws_instance.myserver: Still creating... (20s elapsed)<br/>aws_instance.myserver: Creation complete after 22s (ID: i-dd8834ca)<br/><br/>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.<br/>[root@yogeshraheja firstproject]#<br/></strong></pre>
<p class="MsoBodyText">Let's confirm the newly created instance from our AWS console to ensure the <kbd>helloworld</kbd> instance has been created by the Terraform template:</p>
<p class="MsoBodyText CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-527 image-border" src="assets/e9a87db7-d720-4773-97d0-ce44f3339c76.png" style="width:113.25em;height:35.50em;"/></p>
<p class="MsoBodyText">Terraform didn't simply create an instance and forget about it. In fact, Terraform actually saves everything it knows about the resources (in our case, the instance) to a special file, which is known as the <strong>state file</strong> in Terraform. In this file, Terraform stores the state of all the resources it has created. It is saved to the same directory where the Terraform template is present and with the <kbd>.tfstate</kbd> extension. The format of the state file is a simple JSON format:</p>
<pre class="MsoBodyText"><strong>[root@yogeshraheja firstproject]# cat terraform.tfstate</strong><br/><strong>{</strong><br/><strong>    "version": 3,</strong><br/><strong>    "terraform_version": "0.11.8",</strong><br/><strong>    "serial": 1,</strong><br/><strong>    "lineage": "9158b0ed-754a-e01e-094e-6b0827347950",</strong><br/><strong>    "modules": [</strong><br/><strong>        {</strong><br/><strong>            "path": [</strong><br/><strong>                "root"</strong><br/><strong>            ],</strong><br/><strong>            "outputs": {},</strong><br/><strong>            "resources": {</strong><br/><strong>                "aws_instance.myserver": {</strong><br/><strong>                    "type": "aws_instance",</strong><br/><strong>                    "depends_on": [],</strong><br/><strong>                    "primary": {</strong><br/><strong>                        "id": "i-dd8834ca",</strong><br/><strong>                        "attributes": {</strong><br/><strong>                            "ami": "ami-cfe4b2b0",</strong><br/><strong>                            "arn": "arn:aws:ec2:us-east-1:094507990803:instance/i-dd8834ca",</strong><br/><strong>                            "associate_public_ip_address": "true",</strong><br/><strong>                            "availability_zone": "us-east-1b",</strong><br/><strong>                            "cpu_core_count": "1",</strong><br/><strong>                            "cpu_threads_per_core": "1",</strong><br/><strong>                            "credit_specification.#": "1",</strong><br/><strong>                            "credit_specification.0.cpu_credits": "standard",</strong><br/><strong>                            "disable_api_termination": "false",</strong><br/><strong>                            "ebs_block_device.#": "0",</strong><br/><strong>                            "ebs_optimized": "false",</strong><br/><strong>                            "ephemeral_block_device.#": "0",</strong><br/><strong>                            "get_password_data": "false",</strong><br/><strong>                            "iam_instance_profile": "",</strong><br/><strong>                            "id": "i-dd8834ca",</strong><br/><strong>                            "instance_state": "running",</strong><br/><strong>                            "instance_type": "t2.micro",</strong><br/><strong>                            "ipv6_addresses.#": "0",</strong><br/><strong>                            "key_name": "EffectiveDevOpsAWS",</strong><br/><strong>                            "monitoring": "false",</strong><br/><strong>                            "network_interface.#": "0",</strong><br/><strong>                            "network_interface_id": "eni-b0683ee7",</strong><br/><strong>                            "password_data": "",</strong><br/><strong>                            "placement_group": "",</strong><br/><strong>                            "primary_network_interface_id": "eni-b0683ee7",</strong><br/><strong>                            "private_dns": "ip-172-31-74-203.ec2.internal",</strong><br/><strong>                            "private_ip": "172.31.74.203",</strong><br/><strong>                            "public_dns": "ec2-52-70-251-228.compute-1.amazonaws.com",</strong><br/><strong>                            "public_ip": "52.70.251.228",</strong><br/><strong>                            "root_block_device.#": "1",</strong><br/><strong>                            "root_block_device.0.delete_on_termination": "true",</strong><br/><strong>                            "root_block_device.0.iops": "100",</strong><br/><strong>                            "root_block_device.0.volume_id": "vol-024f64aa1bb805237",</strong><br/><strong>                            "root_block_device.0.volume_size": "8",</strong><br/><strong>                            "root_block_device.0.volume_type": "gp2",</strong><br/><strong>                            "security_groups.#": "1",</strong><br/><strong>                            "security_groups.2004290681": "HelloWorld",</strong><br/><strong>                            "source_dest_check": "true",</strong><br/><strong>                            "subnet_id": "subnet-658b6149",</strong><br/><strong>                            "tags.%": "1",</strong><br/><strong>                            "tags.Name": "helloworld",</strong><br/><strong>                            "tenancy": "default",</strong><br/><strong>                            "volume_tags.%": "0",</strong><br/><strong>                            "vpc_security_group_ids.#": "1",</strong><br/><strong>                            "vpc_security_group_ids.1524136243": "sg-01864b4c"</strong><br/><strong>                        },</strong><br/><strong>                        "meta": {</strong><br/><strong>                            "e2bfb730-ecaa-11e6-8f88-34363bc7c4c0": {</strong><br/><strong>                                "create": 600000000000,</strong><br/><strong>                                "delete": 1200000000000,</strong><br/><strong>                                "update": 600000000000</strong><br/><strong>                            },</strong><br/><strong>                            "schema_version": "1"</strong><br/><strong>                        },</strong><br/><strong>                        "tainted": false</strong><br/><strong>                    },</strong><br/><strong>                    "deposed": [],</strong><br/><strong>                    "provider": "provider.aws"</strong><br/><strong>                }</strong><br/><strong>            },</strong><br/><strong>            "depends_on": []</strong><br/><strong>        }</strong><br/><strong>    ]</strong><br/><strong>}</strong><br/><strong>[root@yogeshraheja firstproject]#</strong></pre>
<p class="MsoBodyText">The special part about Terraform is that you can read this JSON output <span>in a human-readable format </span><span>using the</span> <kbd>terraform show</kbd> <span>command:</span></p>
<pre><strong>[root@yogeshraheja firstproject]# terraform show</strong><br/><strong>aws_instance.myserver:</strong><br/><strong>  id = i-dd8834ca</strong><br/><strong>  ami = ami-cfe4b2b0</strong><br/><strong>  arn = arn:aws:ec2:us-east-1:094507990803:instance/i-dd8834ca</strong><br/><strong>  associate_public_ip_address = true</strong><br/><strong>  availability_zone = us-east-1b</strong><br/><strong>  cpu_core_count = 1</strong><br/><strong>  cpu_threads_per_core = 1</strong><br/><strong>  credit_specification.# = 1</strong><br/><strong>  credit_specification.0.cpu_credits = standard</strong><br/><strong>  disable_api_termination = false</strong><br/><strong>  ebs_block_device.# = 0</strong><br/><strong>  ebs_optimized = false</strong><br/><strong>  ephemeral_block_device.# = 0</strong><br/><strong>  get_password_data = false</strong><br/><strong>  iam_instance_profile =</strong><br/><strong>  instance_state = running</strong><br/><strong>  instance_type = t2.micro</strong><br/><strong>  ipv6_addresses.# = 0</strong><br/><strong>  key_name = EffectiveDevOpsAWS</strong><br/><strong>  monitoring = false</strong><br/><strong>  network_interface.# = 0</strong><br/><strong>  network_interface_id = eni-b0683ee7</strong><br/><strong>  password_data =</strong><br/><strong>  placement_group =</strong><br/><strong>  primary_network_interface_id = eni-b0683ee7</strong><br/><strong>  private_dns = ip-172-31-74-203.ec2.internal</strong><br/><strong>  private_ip = 172.31.74.203</strong><br/><strong>  public_dns = ec2-52-70-251-228.compute-1.amazonaws.com</strong><br/><strong>  public_ip = 52.70.251.228</strong><br/><strong>  root_block_device.# = 1</strong><br/><strong>  root_block_device.0.delete_on_termination = true</strong><br/><strong>  root_block_device.0.iops = 100</strong><br/><strong>  root_block_device.0.volume_id = vol-024f64aa1bb805237</strong><br/><strong>  root_block_device.0.volume_size = 8</strong><br/><strong>  root_block_device.0.volume_type = gp2</strong><br/><strong>  security_groups.# = 1</strong><br/><strong>  security_groups.2004290681 = HelloWorld</strong><br/><strong>  source_dest_check = true</strong><br/><strong>  subnet_id = subnet-658b6149</strong><br/><strong>  tags.% = 1</strong><br/><strong>  tags.Name = helloworld</strong><br/><strong>  tenancy = default</strong><br/><strong>  volume_tags.% = 0</strong><br/><strong>  vpc_security_group_ids.# = 1</strong><br/><strong>  vpc_security_group_ids.1524136243 = sg-01864b4c</strong><br/><br/><strong>[root@yogeshraheja firstproject]#</strong></pre>
<p>Up to here, we have created a Terraform template, validated it to ensure there are no syntax errors, performed a smoke test in the form of <kbd>terraform plan</kbd>, and then finally applied our Terraform template using <kbd>terraform apply</kbd> to create resources.</p>
<p>The question remaining is <em>how can we delete or destroy all of the resources that are created by the Terraform template?</em> Do we need to find and delete resources one after another? The answer is No, this will also be taken care of by Terraform. By referring to the state file Terraform created during the <strong>apply</strong> phase, any resources that have been created by Terraform can be destroyed using the simple <kbd>terraform destroy</kbd> <span>command</span> from the <kbd>template</kbd> directory:</p>
<pre class="MsoBodyText"><strong>[root@yogeshraheja firstproject]# terraform destroy</strong><br/><strong>aws_instance.myserver: Refreshing state... (ID: i-dd8834ca)</strong><br/><br/><strong>An execution plan has been generated and is shown below.</strong><br/><strong>Resource actions are indicated with the following symbols:</strong><br/><strong>  - destroy</strong><br/><br/><strong>Terraform will perform the following actions:</strong><br/><br/><strong>  - aws_instance.myserver</strong><br/><br/><br/><strong>Plan: 0 to add, 0 to change, 1 to destroy.</strong><br/><br/><strong>Do you really want to destroy all resources?</strong><br/><strong>  Terraform will destroy all your managed infrastructure, as shown above.</strong><br/><strong>  There is no undo. Only 'yes' will be accepted to confirm.</strong><br/><br/><strong>  Enter a value: yes</strong><br/><br/><strong>aws_instance.myserver: Destroying... (ID: i-dd8834ca)</strong><br/><strong>aws_instance.myserver: Still destroying... (ID: i-dd8834ca, 10s elapsed)</strong><br/><strong>aws_instance.myserver: Still destroying... (ID: i-dd8834ca, 20s elapsed)</strong><br/><strong>aws_instance.myserver: Still destroying... (ID: i-dd8834ca, 30s elapsed)</strong><br/><strong>aws_instance.myserver: Still destroying... (ID: i-dd8834ca, 40s elapsed)</strong><br/><strong>aws_instance.myserver: Still destroying... (ID: i-dd8834ca, 50s elapsed)</strong><br/><strong>aws_instance.myserver: Destruction complete after 1m0s</strong><br/><br/><strong>Destroy complete! Resources: 1 destroyed.</strong><br/><strong>[root@yogeshraheja firstproject]#</strong></pre>
<p class="MsoBodyText">Check your AWS console to ensure that the instance is in a terminated state. </p>
<div class="MsoBodyText packt_tip">Check the <kbd>terraform show</kbd> command now. It should be empty as none of your resources will be available.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A second Terraform template for deploying a Hello World application</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Go into the <span class="packt_screen">EffectiveDevOpsTerraform</span> repository and create a directory called <kbd>second project</kbd>:</p>
<pre class="MsoBodyText"><strong>$ mkdir secondproject</strong><br/><strong>$ cd secondproject</strong></pre>
<p class="MsoBodyText">Now that we have created our EC2 instance with the Terraform template in the previous section, we are ready to extend the provisioning of our Hello World web application. We are going to use <strong>Terraform Provisioner</strong> to recreate the Hello World stack that we previously made using the <kbd>UserDatablock</kbd> field of CloudFormation in <a href="1abe175d-50df-434d-bc0a-097397a39cee.xhtml">Chapter 2</a>, <em>Deploying Your First Web Application</em> and using Ansible roles in <a href="8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml">Chapter 3</a>, <em>Treating Your Infrastructure as Code</em>. If you recall, the <kbd>UserData</kbd> field looked roughly like this:</p>
<pre class="MsoBodyText"><strong>yum install --enablerepo=epel -y nodejs</strong><br/><strong>wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.js -O /home/ec2-user/helloworld.js</strong><br/><strong>wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.conf -O /etc/init/helloworld.conf</strong><br/><strong>start helloworld</strong></pre>
<p class="MsoBodyText">You will observe that there are three different types of operations for the deployment of our Hello World web application. First, we prepare the system to run our application. To do this, in our example, we are simply installing the Node.js package. Next, we copy the different resources that are needed to run the application. In our case, these resources include the JavaScript code and the upstart configuration. Finally, we start the service.</p>
<p class="MsoBodyText">In order to deploy our Hello World web application, we need to introduce <strong>Terraform Provisioner</strong>. Provisioners in Terraform are configuration blocks available for several resources that allow you to perform actions after the resource has been created. It is mostly used for EC2 instances. Provisioners are primarily used as <strong>post build steps</strong> to install lightweight applications or configuration management agents such as <strong>Puppet agents</strong> or <strong>chef-clients</strong>. They can even be used to run configuration management tools such as<strong> playbooks</strong>, <strong>Puppet modules</strong>, <strong>Chef cookbooks,</strong> or <strong>Salt formulas</strong>. In the next section, we’ll look at a few examples of how to use Terraform with Ansible.</p>
<p class="MsoBodyText">Let's create the <kbd>helloworldec2.tf</kbd> Terraform template to create the instance and then introduce the <kbd>provisioner</kbd> block with <kbd>remote-exec</kbd> to establish a connection with the newly created instance and download and deploy Hello World application on top of it. Our completed Terraform template should look like this:</p>
<pre class="MsoBodyText"># Provider Configuration for AWS<br/>provider "aws" {<br/>  access_key = "&lt;YOUR AWS ACCESS KEY&gt;"<br/>  secret_key = "&lt;YOUR AWS SECRET KEY&gt;"<br/>  region = "us-east-1"<br/>}<br/><br/># Resource Configuration for AWS<br/>resource "aws_instance" "myserver" {<br/>  ami = "ami-cfe4b2b0"<br/>  instance_type = "t2.micro"<br/>  key_name = "EffectiveDevOpsAWS"<br/>  vpc_security_group_ids = ["sg-01864b4c"]<br/><br/>  tags {<br/>    Name = "helloworld"<br/>  }<br/><br/># Helloworld Appication code<br/>  provisioner "remote-exec" {<br/>    connection {<br/>      user = "ec2-user"<br/>      private_key = "${file("/root/.ssh/EffectiveDevOpsAWS.pem")}"<br/>    }<br/>    inline = [<br/>      "sudo yum install --enablerepo=epel -y nodejs",<br/>      "sudo wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.js -O /home/ec2-user/helloworld.js",<br/>      "sudo wget https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter02/helloworld.conf -O /etc/init/helloworld.conf",<br/>      "sudo start helloworld",<br/>    ]<br/>  }<br/>}</pre>
<p class="MsoBodyText">The created file should look like the file at: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/secondproject/helloworldec2.tf</a>.</p>
<p class="MsoBodyText">As we are creating the Terraform template inside a new directory, <kbd>secondproject</kbd>, we need to install the plugin or reinitialize the plugins that are related to AWS for Terraform. The configured file with the <kbd>provider</kbd> section will perform this task for us:</p>
<pre class="MsoBodyText"><strong>$ terraform init</strong></pre>
<p class="MsoBodyText">Now, it's time to validate the Terraform template file to ensure that it doesn't have any syntax errors. Upon successful verification, run the <kbd>plan</kbd> command followed by the complete execution of the template using the <kbd>terraform apply</kbd> command:</p>
<pre class="MsoBodyText"><strong>$ terraform validate</strong><br/><strong>$ terraform plan</strong><br/><strong>$ terraform apply</strong></pre>
<p>We will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/74a89c11-cd79-4b49-bf46-d247fa6002c7.png"/></p>
<p class="MsoBodyText">Our Terraform template has been executed successfully. We have provisioned our EC2 instance and deployed our Hello World web application. Let's find the public IP of the instance by executing the <kbd>terraform show</kbd> command followed by the <kbd>curl</kbd> command to ensure the application has deployed correctly:</p>
<pre class="MsoBodyText"><strong>$ terraform show | grep -i public_ip</strong><br/><strong>$ curl &lt;PUBLIC_IP&gt;:3000</strong></pre>
<p class="mce-root">The output of running the preceding commands is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f4fd6d3b-0d69-4e9a-8008-6d611ecf636e.png" style="width:45.33em;height:9.33em;"/></p>
<p class="MsoBodyText">Let's verify the application outputs from our browser as well, as shown in the following screenshot:</p>
<p class="MsoBodyText CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-530 image-border" src="assets/3cad4e6c-7026-47ad-a64f-ec111e1b909f.png" style="width:38.00em;height:7.17em;"/></p>
<p class="MsoBodyText CDPAlignLeft CDPAlign">We have now successfully deployed our Hello World web application using the power of Terraform. Once you've tested it, make sure to remove all of the created resources before you proceed to the next section. Execute the <kbd>terraform destroy</kbd> command, which will take care of removing all of the created resources by referring to the Terraform state file.</p>
<p>Run the following command:</p>
<pre class="MsoBodyText"><strong>$ terraform destroy</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating AWS, Terraform, and Ansible</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">In the previous sections, we looked at how to provision a vanilla instance using Terraform. We then learnt how to provision a vanilla EC2 instance and execute <strong>post builds</strong> using the Terraform <kbd>remote-exec</kbd> provisioner. Now, we'll look at how Terraform can be integrated with Ansible to perform configuration management tasks. We will consider two different scenarios. In scenario one, we will provision an EC2 instance and run Ansible using <strong>push</strong> mode, which is the primary way that we can use Ansible to perform automation. In scenario two, we will provision an EC2 instance and run Ansible in <strong>pull</strong> mode using the <kbd>ansible pull</kbd> approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terraform with Ansible using a push-based approach</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Go into the <kbd>EffectiveDevOpsTerraform</kbd> repository and create a directory called <kbd>thirdproject</kbd>:</p>
<pre class="MsoBodyText"><strong>$ mkdir thirdproject</strong><br/><strong>$ cd thirdproject</strong></pre>
<p class="MsoBodyText">In this example, we will use the recommended practices to create Terraform templates. We will remove our AWS <kbd>access_key</kbd> and our AWS <kbd>secret_key</kbd> from our Terraform template first. We have AWS CLI installed on our system, which means that we have already configured this system to talk to our AWS account. If we don't already have AWS CLI installed, we will use the <kbd>aws configure</kbd> to install it. This will create a <kbd>credentials</kbd> file inside the <kbd>/root/.aws</kbd> directory, which will contain our AWS access and secret keys. We will take the advantage of this file for our Terraform template and use the same credentials to build resources on our AWS account:</p>
<pre class="MsoBodyText"><strong>[root@yogeshraheja thirdproject]# cat /root/.aws/credentials</strong><br/><strong>[default]</strong><br/><strong>aws_access_key_id = &lt;YOUR AWS SECRET KEY&gt;</strong><br/><strong>aws_secret_access_key = &lt;YOUR AWS SECRET KEY&gt;</strong><br/><strong>[root@yogeshraheja thirdproject]#</strong></pre>
<p class="MsoBodyText">It's now time to start writing our <kbd>helloworldansible.tf</kbd> Terraform template. In this case, we will provision an EC2 instance and wait for the SSH services to appear by verifying the connection using the <kbd>remote-exec</kbd> provisioner. We will then use the <kbd>local-exec</kbd> provisioner to create the inventory with the new IP and run the Ansible playbooks on it using the primary push model by executing <kbd>ansible-playbook</kbd> locally from the system.</p>
<div class="packt_infobox">Inside provisioners (and only inside provisioners), we can use a special keyword, <span class="packt_screen">self</span>, to access the attributes of a resource being provisioned.</div>
<p>We are also using another block in our code, which is called the <kbd>output</kbd> block. Outputs allow you to return data from the Terraform template after it was applied, using the Terraform <kbd>output</kbd> command:</p>
<pre class="MsoBodyText"># Provider Configuration for AWS<br/>provider "aws" {<br/>  region = "us-east-1"<br/>}<br/><br/># Resource Configuration for AWS<br/>resource "aws_instance" "myserver" {<br/>  ami = "ami-cfe4b2b0"<br/>  instance_type = "t2.micro"<br/>  key_name = "EffectiveDevOpsAWS"<br/>  vpc_security_group_ids = ["sg-01864b4c"]<br/><br/>  tags {<br/>    Name = "helloworld"<br/>  }<br/><br/># Provisioner for applying Ansible playbook<br/>  provisioner "remote-exec" {<br/>    connection {<br/>      user = "ec2-user"<br/>      private_key = "${file("/root/.ssh/EffectiveDevOpsAWS.pem")}"<br/>    }<br/>  }<br/>  <br/>  provisioner "local-exec" {<br/>    command = "sudo echo '${self.public_ip}' &gt; ./myinventory",<br/>  }<br/><br/>  provisioner "local-exec" {<br/>    command = "sudo ansible-playbook -i myinventory --private-key=/root/.ssh/EffectiveDevOpsAWS.pem helloworld.yml",<br/>  } <br/>}<br/><br/># IP address of newly created EC2 instance<br/>output "myserver" {<br/> value = "${aws_instance.myserver.public_ip}"<br/>}</pre>
<p class="MsoBodyText">The created file should look like the file at: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/thirdproject/helloworldansible.tf</a>.</p>
<p class="MsoBodyText">We will call the <kbd>helloworld</kbd> role in our <kbd>helloworld.yml</kbd> Ansible playbook to deploy the Hello World web application:</p>
<pre class="MsoBodyText">---<br/>- hosts: all<br/>  become: yes<br/>  roles:<br/>    - helloworld</pre>
<p class="MsoBodyText">The Ansible configuration file <kbd>ansible.cfg</kbd> should look like as follows. It should be pointing to the <kbd>myinventory</kbd> file that is present in our <kbd>thirdproject</kbd> directory structure:</p>
<pre class="MsoBodyText">[defaults]<br/>inventory = $PWD/myinventory<br/>roles_path = ./roles<br/>remote_user = ec2-user<br/>become = True<br/>become_method = sudo<br/>become_user = root<br/>nocows = 1<br/>host_key_checking = False</pre>
<p class="MsoBodyText">The complete project should look like the file at: <a href="https://github.com/yogeshraheja/EffectiveDevOpsTerraform/tree/master/thirdproject" target="_blank">https://github.com/yogeshraheja/EffectiveDevOpsTerraform/tree/master/thirdproject</a>.</p>
<p class="MsoBodyText">As we have created a new directory, <kbd>thirdproject</kbd>, we again need to install the plugin or reinitialize the plugins that are related to AWS for Terraform. The configured file with the <kbd>provider</kbd> section will perform this task for us:</p>
<pre class="MsoBodyText"><strong>$ terraform init</strong></pre>
<p class="MsoBodyText">It's now time to validate the Terraform template file to ensure that it doesn't have any syntax errors. Upon successful verification, execute the plan followed by the real run using <kbd>terraform apply</kbd>:</p>
<pre class="MsoBodyText"><strong>$ terraform validate</strong><br/><strong>$ terraform plan</strong><br/><strong>$ terraform apply</strong></pre>
<p class="MsoBodyText CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-531 image-border" src="assets/6be50f8a-b01b-465e-af98-7a1e7dd6ef3d.png" style="width:112.25em;height:60.58em;"/></p>
<p class="MsoBodyText">The outputs are clearly showing the logs for Ansible playbook and returning the <kbd>output</kbd> block with the public IP. Let's use this public IP to verify the application deployment:</p>
<pre class="MsoBodyText"><strong>$ curl 54.85.107.87:3000</strong></pre>
<p class="mce-root">The output of running the preceding command is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4984bbc-16e4-45eb-947a-cb4cbf246809.png"/></p>
<p class="MsoBodyText">Let's verify the application outputs from the browser, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e2f9158-9806-45fd-bfef-2c74ddcd9c5b.png"/></p>
<p class="MsoBodyText">Upon successful deployment, execute <kbd>terraform destroy</kbd> to clean up the created resources:</p>
<pre class="MsoBodyText"><strong>$ terraform destroy</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terraform with Ansible using the pull-based approach</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Go into the <kbd>EffectiveDevOpsTerraform</kbd> repository and create a directory called <kbd>fourthproject</kbd>:</p>
<pre class="MsoBodyText"><strong>$ mkdir fourthproject</strong><br/><strong>$ cd fourthproject</strong></pre>
<p class="MsoBodyText">Again, we will follow the best practices for Terraform templates here and use the <kbd>credentials</kbd> file located in the <kbd>/root/.aws</kbd> directory, which contains our AWS access and secret keys. In this case, we will use Ansible in the inverted form: the <em>Ansible pull-based approach</em>. To use Ansible in this inverted approach, we have to make sure to install Ansible on the provisioned EC2 instance and run <kbd>ansible-pull</kbd> by referring to the Ansible code that is present at the source code repository.</p>
<p class="MsoBodyText">In our case we will be using the same Ansible code that we created in <a href="8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml">Chapter 3</a>, <em>Treating Your Infrastructure as</em> <em>Code</em>, which is present at <a href="https://github.com/yogeshraheja/ansible">https://github.com/yogeshraheja/ansible</a>. In our <kbd>helloworldansiblepull.tf</kbd> Terraform template, we will be using a <kbd>remote-exec</kbd> Terraform provisioner to establish a connection with the newly created instance. We will use the <kbd>inline</kbd> attribute to execute multiple commands remotely on the newly created EC2 installation. Our Terraform template should look as follows:</p>
<pre class="MsoBodyText"># Provider Configuration for AWS<br/>provider "aws" {<br/>  region = "us-east-1"<br/>}<br/><br/># Resource Configuration for AWS<br/>resource "aws_instance" "myserver" {<br/>  ami = "ami-cfe4b2b0"<br/>  instance_type = "t2.micro"<br/>  key_name = "EffectiveDevOpsAWS"<br/>  vpc_security_group_ids = ["sg-01864b4c"]<br/><br/>  tags {<br/>    Name = "helloworld"<br/>  }<br/><br/># Provisioner for applying Ansible playbook in Pull mode<br/>  provisioner "remote-exec" {<br/>    connection {<br/>      user = "ec2-user"<br/>      private_key = "${file("/root/.ssh/EffectiveDevOpsAWS.pem")}"<br/>    }<br/>    inline = [<br/>      "sudo yum install --enablerepo=epel -y ansible git",<br/>      "sudo ansible-pull -U https://github.com/yogeshraheja/ansible helloworld.yml -i localhost",<br/>    ]<br/>  }<br/>  <br/>}<br/><br/># IP address of newly created EC2 instance<br/>output "myserver" {<br/> value = "${aws_instance.myserver.public_ip}"<br/>}</pre>
<p class="MsoBodyText">The created file should look like the file at: <a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf">https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf</a><a href="https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTerraform/master/fourthproject/helloworldansiblepull.tf" target="_blank">.</a></p>
<p class="MsoBodyText">As we have again created a new directory, <kbd>fourthproject</kbd>, we need to install the plugin or reinitialize the plugins related to AWS for Terraform. The configured file with the <kbd>provider</kbd> section will perform this task for us.</p>
<pre class="MsoBodyText"><strong>$ terraform init</strong></pre>
<p class="MsoBodyText">It's now time to validate the Terraform template file to ensure that it doesn't have any syntax errors. Upon successful verification, execute the plan followed by the real run using <kbd>terraform apply</kbd>:</p>
<pre><strong>$ terraform validate</strong><br/><strong>$ terraform plan</strong><br/><strong>$ terraform apply</strong></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1f84de9-d412-4c1d-96cf-c1c1a2c0d646.png"/></p>
<p class="MsoBodyText">As expected, the Ansible code is running locally on the newly created EC2 instance. The <kbd>output</kbd> block configured in the Terraform template has also returned the expected value of the public IP. Let's verify the outputs using the <kbd>curl</kbd> command:</p>
<pre class="MsoBodyText"><strong>$ curl 18.212.64.84:3000/</strong></pre>
<p class="mce-root">The output of running the preceding command is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b18915c9-d5e4-47bd-bb8a-c9024d7053a2.png"/></p>
<p class="MsoBodyText">Finally, verify the outputs from the browser, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c1610102-16ba-4ec7-a870-85205f19eb08.png" style="width:22.50em;height:5.42em;"/></p>
<p class="MsoBodyText">Great—the application is deployed and verified. Once you are done, don't forget to destroy the resource using the following command, to avoid unwanted AWS bills:</p>
<pre class="MsoBodyText"><strong>$ terraform destroy</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">In this chapter, we learned how to efficiently manage infrastructure using Terraform templates. First, we learned about how Terraform can be used to provision an EC2 instance in just a few lines. We then looked at how to create Terraform templates using Terraform provisioners to deploy lightweight applications. We then extended the Terraform templates with Ansible, which allowed us to orchestrate the different steps to deploy our web application. Finally, we looked at how Terraform can be integrated with Ansible in a pull-based approach, which usually makes more sense when managing sizable infrastructures, as we observed in <a href="8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml" target="_blank">Chapter 3</a>, <em>Treating Your Infrastructure as Code</em>.</p>
<p class="MsoBodyText"><span>We now have a good production environment ready to host any application. We have seen how to architect it using CloudFormation, Ansible, and Terraform. In</span> <a href="" target="_blank"><span>Chapter 5</span></a><span>, <em>Adding Continuous Integration and Continuous Deployment</em>, we will continue to use CloudFormation and Ansible, but in the context of software delivery, as we will learn how to put in place continuous integration testing and continuous deployment.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="MsoBodyText">What is Terraform and how it is different from other configuration management tools?</li>
<li>How do you install Terraform on a Linux-based operating system?</li>
<li class="MsoBodyText">How do you provision your first AWS instance using a Terraform template?</li>
<li>How do you write a Terraform template to integrate Ansible with a pull-based approach?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="MsoBodyText">Read the following articles for more information:</p>
<ul>
<li class="MsoBodyText"><strong>Terraform reference</strong> at <a href="https://terraform.io" target="_blank">https://terraform.io</a></li>
<li class="MsoBodyText"><strong>Terraform GitHub reference</strong> at <a href="https://github.com/hashicorp/terraform" target="_blank">https://github.com/hashicorp/terraform</a></li>
</ul>


            </article>

            
        </section>
    </body></html>