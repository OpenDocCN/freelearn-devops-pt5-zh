- en: Running Docker Containers
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to the Docker command line. We have run some containers
    in the previous chapters, but we did not go into detail regarding the arguments
    and options used.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about different Docker objects, such as images,
    containers, and volumes, and their associated actions. Not all objects will have
    the same features and, consequently, they will not have the same actions and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that image building is based on container execution. Each layer is
    the result of executing commands on a container that is automatically "committed"
    in a Docker node's filesystem. All these layers, when grouped together, constitute
    an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Docker command line in depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Docker objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting host resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting containers into images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and filtering information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by looking at how to work with the Docker command line.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Docker container concepts. We'll provide
    some labs at the end of this chapter that will help you understand and learn about
    the concepts covered. These labs can be run on your laptop or PC using the provided
    Vagrant standalone environment or any Docker host of your own that you've deployed.
    Additional information can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '"[https://bit.ly/32AEGHU](https://bit.ly/32AEGHU)"'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Docker command line in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the previous chapters, Docker is a client-server application.
    Previous versions of the software installed both components at the same time,
    but the newer versions allow us to just install the client for using remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the various Docker daemon options and arguments in [Chapter
    1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures and Applications
    with Docker*. In this chapter, we are going to review the Docker client command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the Docker command line on either Linux or Windows, we are always
    referencing the Docker client and, usually, the binary or executable program is
    `/usr/bin/docker` or `C:\ProgramData\Docker` on Linux and Windows, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Docker's command-line usage format is `docker [OPTIONS] COMMAND`. Various options
    are used to define the daemon we will connect to and how this communication will
    be created. Debugging and the level of logging are managed at this point too.
    Some of these options can be set using Docker client configuration in each user'
    s `config.json` file under their `home` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client configuration file, `config.json`, will manage filtering options,
    which we will learn about at the end of this chapter. It also stores login access
    to registries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment variables can also be used to configure Docker client behavior.
    Here is a list of the most frequently used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DOCKER_CONFIG`: This will set the Docker client''s config file path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOCKER_CERT_PATH`: This sets the path for client-server certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOCKER_HOST`: We can use remote Docker engines. By default, we will use the
    local Docker daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOCKER_TLS`: This option enables TLS communication (requires certificates
    to work).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOCKER_TLS_VERIFY`: This option will not validate remote daemon certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOCKER_CONTENT_TRUST`: We will use this option to use content trust features
    (image immutability and ownership).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker commands will always require a Docker daemon and they will be executed
    against **objects*****.*** These are internal resources managed by Docker, distributed
    on categories with different features and properties. We'll look at this in more
    detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: All Docker objects have their own IDs. Names are tags associated with these
    IDs and therefore, in some cases, we will be able to have many names for an object.
    The object ID will uniquely identify each object and thus, Docker can show or
    manage information regarding that object without using its category. We recommend
    using categories that are always on the Docker command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the commands that will be common to all objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ls` or `list` | This will show a list of all objects in that category. The
    output may be different, depending on which objects are queried, but we will usually
    obtain object names and their IDs.We will use the `--all` or `-a` modifiers to
    show all the objects from a selected category because, in some cases, the output
    will only show a subset. For example, if we list container objects, by default,
    we will just get running containers. Dead (exited) containers will not be shown
    unless you use the `--all` command modifier. Filtering will allow us to retrieve
    only a subset of objects. We will use the `--filter` or `-f` arguments for this.
    Each object category will have its own keys for easy filtering. We will learn
    how to filter information later in this chapter.Formatting is also very important.
    We will use the `--format` option to format the output''s information. The usual
    formats are `table` and `json` for obtaining table-like information and JSON formats,
    respectively. We can customize and sort obtained information. All filters should
    be constructed using the Go templates format.Formatting output is an art! We will
    see many options later in this chapter. A good starting point will always be to
    use `--format=''{{json .}}''` to review which JSON keys can be used for formatting.
    We can avoid a full command''s output using `--quiet` or `-q`. This parameter
    will show only listed object IDs in that category. This is very useful for concatenating
    or piping output to other commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `rm` or `remove` | This action will remove defined objects. We can remove
    them using their IDs or their names. Once deleted, they cannot be recovered.To
    avoid confirmation of object deletion, we will use the `--force` argument. |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | All objects can be created and removed, but each object will have
    its own arguments. Therefore, we will learn about each object''s arguments in
    different chapters. We will start with container arguments in the next section.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `inspect` | To review object-defined properties, we will use the `inspect`
    action. By default, the object description will be shown in JSON format.We can
    also use `--format` to format its output. In this case, we can format the output
    of the object''s description. This is very useful for getting just a few required
    values, as shown in the following example:`**$ docker image inspect nginx:alpine
    --format "{{ json .Config.Cmd }}"**``**["nginx","-g","daemon off;"]**` |'
  prefs: []
  type: TYPE_TB
- en: The Docker client was programmed in Go and it contains many Go template formatting
    and filtering options.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we use `docker ps`, we are actually executing `docker container ls`***.***
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce the different resources or objects we
    have available in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Docker objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define the different categories of objects that are available for a
    standalone Docker daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**: These are the basis for creating containers. In [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*, we learned the concept of multi-layered templates for
    providing a root filesystem for the container''s main process and all the meta-information
    required to execute it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: As we learned in [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml),
    *Modern Infrastructures and Applications with Docker*, a container is a compound
    of isolated namespaces, resources, and files for a process (or multiple processes).
    This process will run inside a wrapped environment as if it was alone in its own
    system, sharing the host kernel and its resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volumes**: Volumes are used to bypass copy-on-write containers'' filesystems.
    As a result, we will be able to store data out of containers, avoiding their life
    cycle. We will learn more about volumes in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networks**: Containers run on their own network namespace, but they need
    to reach real infrastructure networks. They will use host physical interfaces
    in bridge mode, creating virtual interfaces for each container interface. We will
    learn more about this working model and many other options in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins**: Docker plugins extend engine functionality using processes that
    will run alongside a Docker daemon. They will share information and configuration
    with the daemon to provide new features. There are three different kinds of plugins:
    authorization, volume, and network plugins. The Docker client command line provides
    the interface for installing and managing plugins. Their configurations will be
    deployed under the `/usr/lib/docker/plugins` or `/etc/docker/plugins` directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These objects are available in a standalone Docker Daemon, but there are other
    objects when the host participates in a distributed Docker Swarm cluster. We will
    talk about these in the orchestration chapters, but we will provide a brief synopsis
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swarm**: This object provides cluster properties. It allows us to create
    new clusters and join or leave previously created ones. It also maintains cluster
    security by managing certificate authority or locking access to cluster certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nodes**: Nodes are hosts that are part of the cluster. We can update node
    roles within the cluster and remove them when needed. We can also modify which
    nodes will run the defined workloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**:Docker Swarm will not manage containers. The minimum scheduling
    unit in Docker Swarm is the service. They will create tasks, and those will be
    represented by containers. In Docker Swarm, we deploy services by declaring their
    state and the number of tasks required to be healthy. We will be able to create
    services, update their properties (replicas, images used for containers, and so
    on), or remove them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stacks**: When we talk about deploying workloads on Swarm, we usually use
    stacks, which are multi-service applications. We will define all the components
    required by an application to run. These components will be services and all their
    volumes, networks, and so on, as well as their interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm objects have all the actions described previously. However, we can also
    use the `update` action to set and change object properties. This action is only
    available using Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to run containers securely using the
    command line described.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are just processes that run in an isolated manner on the Docker host.
    All the features or properties required for the process to run may be tweaked
    on container creation.
  prefs: []
  type: TYPE_NORMAL
- en: Main container actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containers can be created, executed, and stopped when required. The following
    table will introduce the main container actions for this workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `create` | Because containers are Docker objects, we can create them. When
    we create a container, we configure how this container will work, without starting
    it. This stage will prepare a container and we can review its static configuration
    using `inspect`. Any dynamic configuration will not be present because the container
    is not running yet. |'
  prefs: []
  type: TYPE_TB
- en: '| `start` | Once the container has been created, it can be started using `start`.
    This means that the container-defined process will be executed with the configured
    isolation (memory, CPU, networking, and so on) and the external resources that
    are required. Once the container is started, we will be able to list it or review
    its state. |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | This action will create and then start a container. This is how we
    usually launch a container. There are some command aliases for many objects and
    actions; for example, `docker run`. We recommend using full sentences, including
    the object in which you are executing the action. A Docker container started with
    either `docker container run` or `docker run` will run in the foreground. Your
    Terminal, by default, will be attached to the container''s output. To avoid this
    behavior, we must use `--detach` or `-d` to launch the container in the background,
    detached from the current Terminal. |'
  prefs: []
  type: TYPE_TB
- en: '| `pause/unpause` | We can freeze the container''s process using cgroups in
    Linux. The process will stay suspended until it is unfrozen. |'
  prefs: []
  type: TYPE_TB
- en: '| `stop` | Stopping a container will follow the next workflow described. First,
    the main process will receive a `SIGTERM` signal. This will try to shut down and
    terminate the process normally. By default, the Docker daemon will wait 10 seconds
    before sending a second signal. Then, the daemon will send a `SIGKILL` signal
    to kill the process completely. Therefore, the daemon will first try to terminate
    the container''s main process gracefully and will kill it if it was not stopped.
    We can configure what signal to send to stop a container using `--stop-signal`.
    It defaults to `SIGTERM`, as mentioned previously.Also, we can change the number
    of seconds to wait (10 seconds by default) before sending the second `SIGKILL`
    signal using the `--time` argument. This can be configured on container creation
    or execution using `--stop-timeout` when it is already running. |'
  prefs: []
  type: TYPE_TB
- en: '| `kill` | As we mentioned earlier, when we run `docker container stop`, Docker
    daemon will first try to stop it gracefully. There are some cases where we want
    to kill the main process completely without waiting. In these cases, we can use
    `docker container kill` to stop the container immediately. A signal that''s been
    sent can be changed using `-s` and, by default, a `SIGKILL` signal will be sent.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `restart` | The `restart` action will stop and start a container. This means
    that previously learned procedures will be taken and the Docker container''s `stop`
    and `start` operations will be executed. Therefore, the previously described arguments
    will also be valid. |'
  prefs: []
  type: TYPE_TB
- en: '| `rm` | Containers are not ephemeral, as we have learned in previous chapters.
    They will remain in our system until someone deletes them. We will use `docker
    container rm`to remove them.Running containers cannot be removed unless we use
    the `--force/-f` argument. It is recommended to stop containers in production
    before deleting them to avoid removing an important one by mistake. |'
  prefs: []
  type: TYPE_TB
- en: '| `prune` | This command will remove all stopped containers. They can be forced
    using `--force`, and we can limit containers to be removed using filters with
    the `--filter` argument. |'
  prefs: []
  type: TYPE_TB
- en: '| `rename` | With this action, we change the container name. |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | Using the `update` action, we can change the container''s host
    resource limits and its restart policy. |'
  prefs: []
  type: TYPE_TB
- en: Only containers using Hyper-V isolation can be paused on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all containers will be executed using non-limited resources. They
    will not run isolated unless we limit their access to host resources. To limit
    the number of resources available for a container, we must specify its thresholds
    during creation. We will use the same arguments for `docker container create`
    or `docker container run`. We will review how to manage container resources in
    the *Limiting host resources* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `--rm` option to remove a container after its execution. It will
    also remove all unnamed volumes created during its lifetime. These volumes are
    defined ephemerally to override copy-on-write filesystems. We must remove them
    manually or use the `-v` argument with the `docker container rm` action.
  prefs: []
  type: TYPE_NORMAL
- en: Container network properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containers run in their own network namespace. They will get their own IP addresses
    and network resources. By default, a Docker daemon will use bridge networking,
    and containers will get their own name resolution configuration by copying the
    host values. We can change this behavior on container creation and execution.
    Let''s review some options we can use to configure networking within containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--name` | We can provide a name for each container. If we do not specify
    any container name, a random one will be generated. This way, we can manage containers
    using this defined name. It will be used as a hostname by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `--add-host` | Using this parameter, we are allowed to add hosts and their
    IP addresses. We will use `host:ip` formatted entries. |'
  prefs: []
  type: TYPE_TB
- en: '| `--dns` | This option will allow us to avoid default DNS resolution. Every
    time a name cannot be resolved by the embedded DNS server, a query is forwarded
    to the defined external DNS servers (copied from hosts by default). |'
  prefs: []
  type: TYPE_TB
- en: '| `--dns-option` | This will add container-related options to an embedded DNS
    server. |'
  prefs: []
  type: TYPE_TB
- en: 'Each bridge network will be provided with internal name resolution using the
    Docker-embedded DNS server, on `127.0.0.11`. There is only one exception: the
    default bridge interface. In this case, we will need to use `--link` to allow
    access to a deployed container from another one on a bridge interface according
    to its name.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--dns-search` | This option sets the search domain names for name resolutions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--domainname` | This option sets the domain name for the container. |'
  prefs: []
  type: TYPE_TB
- en: '| `--ip`and`--ip6` | Sometimes, we need to specify a container IP address,
    either for IPv4 or IPv6\. We will just pass version 4 or version 6 addresses as
    arguments on container creation or execution. Internal IPAM will assign internal
    IP addresses from the bridged network interface range. |'
  prefs: []
  type: TYPE_TB
- en: '| `--hostname` | We can set an internal container hostname. It defaults to
    the container ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `--link` | We can add internal name resolution to other containers using
    `CONTAINER_NAME:DNS_ALIAS`. These added linked names will be accessible to other
    containers using their names or IP addresses (this is the default option). |'
  prefs: []
  type: TYPE_TB
- en: '| `--mac-address` | This option allows us to set a container MAC address. |'
  prefs: []
  type: TYPE_TB
- en: '| `--network` | We can choose what type of network connectivity we will provide
    to containers. By default, all the containers will run on the default bridged
    network. In this chapter, we will just use the default networking mode, but there
    are other options as well, which we will learn about in the following chapters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--network-alias` | This option helps us specify an alias for the container
    on a network. We will have more name resolutions for a container IP. |'
  prefs: []
  type: TYPE_TB
- en: 'We need to define a restart policy to manage the container''s life. We require
    containers to stop/die and start fast. Resilience is the new key to an application''s
    availability. We can manage this container''s behavior with the `--restart` parameter.
    There are four options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`no`: This is the default option. The container will remain stopped if it died
    or it was stopped manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failure`: This option will restart the container only if it died because
    of the main process''s failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`: We don''t care whether someone stopped the container or whether it
    died by itself. We require the container to be running; therefore, Docker daemon
    will always try to restart it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless-stopped`: This option will not restart the container if we have executed
    a Docker `stop` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options are very important as they manage what a Docker daemon has to
    do with the containers when the Daemon is restarted; for example, when we have
    to reboot the host.
  prefs: []
  type: TYPE_NORMAL
- en: Container behavior definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows some options that can be used to overwrite image
    predefined values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--entrypoint` | We can overwrite a defined entry point on container creation
    or execution. Don''t rely on your security for this feature. Anyone can change
    your entry point for any other binary or script included in your image. |'
  prefs: []
  type: TYPE_TB
- en: '| `--env` or `-e` or `--env-file` | We can overwrite variables defined within
    the base image or add new ones for new containers. |'
  prefs: []
  type: TYPE_TB
- en: '| `--expose` | We can expose new ports for containers. These ports will be
    internally available. They are not published. |'
  prefs: []
  type: TYPE_TB
- en: '| `--health-cmd,``--health-interval,``--health-retries,``--health-start-period,``--health-timeout`
    | All these options will overwrite health check base image values. |'
  prefs: []
  type: TYPE_TB
- en: '| `--no-healthcheck` | This option disables the image-defined health check.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--label` or `-l` or `--label-file` | This option allows labels to be added
    upon container creation or execution. These labels will help us filter or find
    information pertaining to processes. There are some labels that are automatically
    added by the Docker daemon or orchestrators to identify grouped objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `--user` or `-u` | This option overwrites the image-defined user. |'
  prefs: []
  type: TYPE_TB
- en: '| `--volume` or `-v` | This option uses a defined volume or host path mounted
    inside the container. This option is very important because ephemeral volumes
    (also referenced as unnamed volumes) that are used to bypass copy-on-write filesystems
    will be created under `/var/lib/docker/volumes` (or the equivalent path on MS
    Windows hosts). They are identified by a random ID. Volumes will not follow the
    container''s life cycle and must be removed manually unless we use the `-v` argument
    with the `docker container rm` action. |'
  prefs: []
  type: TYPE_TB
- en: Arguments passed on container creation will be added to the image-defined entry
    point as arguments. Therefore, image-defined CMD values will be overwritten with
    arguments passed upon container execution. Other arguments such as `--user`, `--env`,
    `--entrypoint`, or `--health-cmd`, `--health-timeout`, and so on will overwrite
    image-defined values, modifying the image's process behavior. Notice that the
    argument syntax is related to the image's defined keys.
  prefs: []
  type: TYPE_NORMAL
- en: Once a container has been created and executed, by default, the Terminal will
    be attached to its standard and error outputs. We will get all the main process
    errors and output. We can also launch containers interactively using the `--interactive`
    or `-i` options. We usually allocate a pseudo-Terminal using `--tty` or `-t` in
    order to have a fully functional Terminal attached to the main process.
  prefs: []
  type: TYPE_NORMAL
- en: Executing containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple example will help us understand this behavior. We will launch a small
    web server using an `nginx:alpine` image. In this case, we are using the official
    `nginx` image from the `docker.io` registry tagged `alpine`, which is the smallest
    one based on Alpine Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output may vary if the image was already on your Docker host. All the object
    IDs will be different on your system as they are created automatically for you.
  prefs: []
  type: TYPE_NORMAL
- en: We can exit from running the container's standard output by executing either
    the `exit` command or the *Ctrl + C* keyboard combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are stuck on this Terminal because we started a container with Nginx as
    the main process. What happened? Well, we are attached to the container''s main
    process. If we issue a *Ctrl* + *C* sequence, since we are attached to that process,
    we will send an interruption to the container''s main process and `nginx` will
    die. However, if we open another Terminal and list the running containers, it
    will be listed as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since we have not set a name for our container, we get a random one; in this
    case, `gallant_lederberg`.
  prefs: []
  type: TYPE_NORMAL
- en: All names will be created using random combinations of names and adjectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also inspect this running container to get its current IP address. To
    access its information, we can use either its ID or name. We will obtain all object
    information managed by the Docker daemon. We will now take a look at the `NetworkSettings`
    section from the `docker container inspect` command''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows that the container was created and that it is running on
    our system with an IP of `172.17.0.2`. We have not exposed its service to the
    world, although we did notice its port and protocol (`80`/`tcp`) on the `docker
    container ls` output earlier. The people who created the `nginx:alpine` image
    declared this port to access the container''s main process. We are not going to
    continue reviewing the networking aspects of this container here as we have a
    complete chapter on networking, that is, [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*. Just be aware that we have a running `nginx`
    process in our system that is not accessible for users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have not changed any of the parameters from the original image, so we are
    using image creator options and declared values. For example, `nginx` is running
    as root inside the container. Container port `80` is not accessible from outside
    the bridged network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already learned that there are some parameters that allow container
    interaction, so let''s start a simple `busybox` to access the previous container''s
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the running `nginx` container''s output, we will read a few lines. These
    are `nginx` logfile lines because the main `nginx` process is redirected to standard
    output. In fact, both error and access logs are redirected to the container''s
    output. If we go back to the first Terminal, this is what we get from running
    the `nginx` container''s standard output and error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `busybox` container's IP (running from the second Terminal)
    is shown on `nginx` requests.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that running two containers together on the same network subnet
    will have unlimited access. This happens because we don't have any rules to disallow
    this interaction. Both containers use the default bridge network, which is why
    they run in the same network.
  prefs: []
  type: TYPE_NORMAL
- en: If we exit the `busybox` container using a simple `exit` command line on the
    container's shell, we will exit the main process (shell) and consequently, the
    container will die.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list non-running containers by using `--all` or `-a` because, by default,
    `docker container ls` will only show running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we can review running and stopped containers. We will
    stop the `gallant_lederberg` container (ID: `f84f6733537c`). Remember that executing
    `docker container stop` will first try to issue a graceful stop before killing
    the main process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The container is stopped immediately. Now, let''s run another container that
    is not so easy to stop. We can run a `busybox` image executing an infinite ping
    to `www.google.com`, for example, and review what happens when we try to stop
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have changed the `busybox` image-defined CMD with the passed argument, `ping
    www.google.com`. As a result, we will get an infinite ping output. To stop this
    container and review how much time it takes to die, we can send a `stop` command
    from another Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We added `time` before the Docker command to review how many seconds the container
    took to stop. As we expected, the ping had to be killed and, as a result, the
    `stop` command took more than the default 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We launched a named container using the `--name` argument. To ensure the uniqueness
    of containers, once a container is created with a name, it is not possible to
    create another one with the same name. When we get into the orchestration chapters
    of this book, we will learn how orchestrators manage the naming of containers.
    To deploy another ping container, in this case, we will need to remove the first
    ping container using `docker container rm ping`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how to launch a container using the `docker container run` command
    and how to stop it. Let''s now review container creation to understand the container''s
    life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We obtained the container's identification, but it is not running. We can verify
    this situation by executing `docker container ls --filter name=webserver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we filter using all containers, including those that are not running, we
    can see that the container was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the container has been created, we can start it using `docker container
    start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The container was started, but we are not attached to its main process's input/output.
    Container creation is different from running a container. As we will learn, Docker
    Swarm services and Kubernetes pods will create container configurations and they
    will also start a defined number of replicas. This is different from starting
    a single container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `STATUS` column shows that the container is now running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can add attachments to the container's input/output by adding the `--attach`
    argument to the `docker container run` action. This way, we will run the container
    interactively. Remember that your interaction with the container's main process
    will depend on the parameters that are passed when it was created. We can also
    use `--interactive` as the `start` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Container security options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of options for container creation and execution related
    to its security. Let''s review the most important ones with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--cap-add or --cap-drop` | Remember that not all system calls are available
    inside containers. We can add or drop default ones using this option. For example,
    if a container needs some special networking features for creating interfaces
    or allowing ports under 1024, we will add `NET_ADMIN` capability. |'
  prefs: []
  type: TYPE_TB
- en: '| `--disable-content-trust` | We use this option to disable any content trust
    verification (check image origin or ownership, for example). This is not recommended
    in production environments. |'
  prefs: []
  type: TYPE_TB
- en: '| `--isolation` | This option is only used on MS Windows containers. Allowed
    values are `process` or `hyper-v`. We will choose which isolation will be used
    in our container. Remember that they have different features, as we learned in
    [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*. |'
  prefs: []
  type: TYPE_TB
- en: '| `--privileged` | Privileged containers will run with all capabilities and
    without any resource limitations. Be careful with these kinds of containers and
    always try to establish what capabilities are required by your application instead
    of using the privileged mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `--read-only` | We can run containers using a read-only root filesystem.
    This is a very good practice in general but we must ensure that all the required
    container storage will use volumes. |'
  prefs: []
  type: TYPE_TB
- en: '| `--security-opt` | We will be able to change container options when changing
    default security behavior; for example, using a different seccomp profile or specifying
    that the container will run unconfined. Custom SELinux policies will also use
    this parameter to inform SELinux of non-default values. |'
  prefs: []
  type: TYPE_TB
- en: All the security options described here must be used with care. It is very important
    to understand what capabilities or requirements the applications have instead
    of using default or insecure configurations.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that executing containers using privileged
    mode will bypass all resource restrictions. Be sure that the `--privileged` option
    is only used in specific situations where you really understand the implications
    of running a container with all capabilities and without any resource limits.
    Users allowed to execute privileged containers can run processes without CPU or
    memory limits and can modify important system files.
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to review the application requirements before executing the privileged
    containers. Only use them under very clear circumstances and watch out for any
    suspicious behavior on those containers.
  prefs: []
  type: TYPE_NORMAL
- en: Executing containers in read-only mode is very useful. We can ensure that the
    applications will not change during their lifetime. Of course, using read-only
    mode depends on your application, but it is good to take some time to analyze
    the process and try to make it work with a read-only filesystem. We will separate
    writable directories into ephemeral volumes to store process data. This is a very
    good practice for improving security easily.
  prefs: []
  type: TYPE_NORMAL
- en: Using host namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following options are not directly related to security, but they are very
    important. These are related to container isolation and must be managed with care
    because any misuse may cause significant security problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--ipc``--pid``--uts` | We can share host namespaces if needed. For example,
    if we are executing a monitoring application inside a container and we need to
    be able to watch for host processes, we will include a host `pid` namespace using
    `--pid host`. Take care of these options as this container will be able to manage
    host processes if we also use extra capabilities or privileged mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `--network` | We have mentioned this option before, but not in this context.
    We can use a host network. In this case, we will use the host''s network inside
    a container. Therefore, all host interfaces will be available inside the container.
    Other containers'' interfaces will also be included. |'
  prefs: []
  type: TYPE_TB
- en: '| `--userns` | In the first chapter, we talked about user namespaces inside
    containers. We learned about process isolation when we introduced the main container''s
    concepts. This option will allow us to implement an isolated user namespace inside
    a container. We must first prepare user mappings and then we will set which one
    to use on container creation or execution. |'
  prefs: []
  type: TYPE_TB
- en: 'We can easily verify some of the options mentioned in our Docker host. For
    example, we can run a container using the host network mode and retrieve the container''s
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can launch another container using the same image but with a host network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All host interfaces are available inside this small busybox container. This
    is very useful for monitoring host resources. This can help us solve host network
    problems without installing any software, especially in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to interact with running containers,
    execute new processes inside them, and copy content to or from them.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can interact with running or stopped containers. We need to interact with
    containers to run some processes within them, review some of their files, or retrieve
    the main process output. These are the main actions we will use to interact with
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `attach` | Using `attach`, we will be able to connect to the main process''s
    `STDIN/STDOUT/STDERR`. In other terms, we will be attached to this process to
    interact with it. Be careful because sending a signal with your keyboard may interrupt
    the process and container''s life (we can omit this behavior using `--sig-proxy
    false`). We can only attach to running containers. |'
  prefs: []
  type: TYPE_TB
- en: '| `cp` | This action will allow us to send /receive content to/from the container''s
    filesystem. It acts as a normal copy but we can maintain file ownership using
    `--archive`. We will just use the source path and destination and we will use
    the `<container>:</path_to_file>` notation to reference files inside containers.
    Containers can be stopped when we copy files to/from the Docker host. |'
  prefs: []
  type: TYPE_TB
- en: '| `exec` | Using `exec`, we will be able to execute a command inside the container''s
    isolation. This new command inherits all main process namespaces. As a result,
    the new command seems to be running inside the container because they share namespaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `logs` | We can review all the container''s output by accessing the container''s
    `STDERR` and `STDOUT`. Logging can be improved using logging drivers to extend
    its functionality; for example, sending these logs to an external host or logging
    backend. Logging is fundamental when we execute background containers or services.
    The only way to know what is happening inside a container is by supervising its
    log. |'
  prefs: []
  type: TYPE_TB
- en: Once attached to a container, we can detach using the *Ctrl* + *P* + *Q* keyboard
    sequence, but we can change this keyboard combination using the `--detach-keys`
    option while attaching, and when creating or starting a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now take a quick look at our running containers (if you do not have
    any, run one container, as described in the previous section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we execute `ps -ef` inside the container using `docker exec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We executed the command inside the container's isolation using the main process
    declared user (`root`, in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to execute an interactive command – a shell, for example – we can
    do so by specifying `--interactive` (or `-i`) and allocating a pseudo-tty using
    `--tty` (or `-t`). We can set environment variables for this new process with
    `--env` or change the execution user using `--user`. If we need to execute the
    new command with special privileges inside a container, we can also use `--privileged`.
    This can be very useful in debugging on test environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can copy a file located in the host `/tmp` directory, for example, inside
    our container using `docker container cp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, logging is an important aspect of managing containers.
    We can use `docker container logs` on running or stopped containers. These are
    very useful options to improve the manner in which logs are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--follow` or `-f` | With this option, we can obtain the online output of
    a running container. The output will be updated with every new entry. |'
  prefs: []
  type: TYPE_TB
- en: '| `--tail` | With this option, we can specify how many previous lines we want
    to show. By default, all the lines will be shown. |'
  prefs: []
  type: TYPE_TB
- en: '| `--since` or `--until` | Both of these options are very useful for showing
    logging only from or before a timestamp or relative period of time (30 minutes
    or 30 m, for example). |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s review some of the `docker container logs` arguments in the previously
    executed web server container. In the following example, we will retrieve all
    the lines from the `webserver` container''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will review how to avoid host problems by limiting container
    access to host resources.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting host resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen some options for limiting the container''s resource consumption.
    We will be able to limit access to CPU, memory, and block devices. There are two
    types of limits when we focus on memory resources: soft and hard limits.'
  prefs: []
  type: TYPE_NORMAL
- en: Soft limits will represent a reservation of resources. This means that a container
    could consume more memory than declared, but this value will be reserved.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a hard limit will ensure that no more than the declared value
    will be consumed. In fact, the container will die if this limit is surpassed.
    An **out-of-memory** (also known as **OOM**) killer will kill the main process
    to prevent host problems.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, by default, if you do not specify any limits, containers will
    be able to consume all your host resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many options available to ensure limited access to resources. We
    can modify default cgroups settings automatically with these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--cpu-period`and`--cpu-quota` | CFS is the Linux kernel CPU scheduler and,
    with these parameters, we modify the scheduler period. Both must be configured
    in microseconds and will modify the CPU limits. |'
  prefs: []
  type: TYPE_TB
- en: '| `--cpu-shares` | This parameter manages the weights for the container''s
    main process. By default, it will start with a value of 1024 and we can set the
    proportion of CPU cycles by increasing or decreasing this value. This is a soft
    limit, which means that the Docker daemon will not prevent container scheduling
    on Docker Swarm. |'
  prefs: []
  type: TYPE_TB
- en: '| `--cpus`or `-c` | This option helps us set the amount of available CPU resources
    that will be provided to a container process. It is related to the number of CPUs
    available in the host. For example, in a host with three CPUs, using a value of
    `--cpus=1.5` will guarantee half of the CPU resources for this container. |'
  prefs: []
  type: TYPE_TB
- en: '| `--cpuset-cpus` | This CPU setting is simpler than CPU shares or setting
    how many CPUs to use. We will just specify a comma-separated list of host CPUs
    where the container can run (we will start at 0 when writing a CPU range). |'
  prefs: []
  type: TYPE_TB
- en: '| `--memory`or `-m` | This will set the maximum amount of memory available
    for a container''s process. This is a threshold and the Docker daemon will not
    allow the container to surpass this limit. Whenever this limit is surpassed, the
    kernel will kill the container''s main process. We will obtain an out-of-memory
    error. This procedure is known as `oom-killer`. We can disable `oom-killer` using
    `--oom-kill-disable`. This can be dangerous and you must be careful with this
    option as containers could take all the host memory resources. |'
  prefs: []
  type: TYPE_TB
- en: '| `--memory-reservation` | With this parameter, we will configure a reservation
    of memory for our processes. It should be set to a lower value than the previously
    mentioned `--memory` threshold value. |'
  prefs: []
  type: TYPE_TB
- en: '| `--blkio-weight`and`--blkio-weight-device` | The first argument will manage
    how much total block direct I/O bandwidth will be available for a container, while
    the second one will manage how much bandwidth will be available for a specific
    block device. By default, all containers run with the same bandwidth. This value
    is 500, and we can increase or decrease this value so that it''s between 10 and
    1,000\. |'
  prefs: []
  type: TYPE_TB
- en: Many of the features we will use to isolate access to resources require that
    the host kernel supports Linux capabilities. We can review all disabled capabilities
    using `docker system info`, looking for any `WARNING` messages.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we need to update the container limits, we can use the `docker container
    update` action, which allows us to change memory, CPU, and block device usage
    limits on containers.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few actions that will help us in reviewing the container's resource
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `docker container stats` to retrieve container usage metrics. By
    default, only CPU usage percentage, memory usage and its limit, network and block
    I/O, and the number of processes inside containers will be shown. We can format
    its output using the `--format` parameter, with common Go language format patterns.
    We will usually use a table format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can specify a container's name or ID to only show its statistics. It is important
    to know that `docker stats` is a stream-like command. This means that it will
    be continuously refreshing content with new data unless we use the `--no-stream`
    argument to obtain static output on a single page.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the amount of data shown, sometimes, values are truncated. This
    can happen in many other objects' actions. To avoid the truncation of important
    data, we can use `--no-trunc` any time we need to retrieve all column data.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `docker container top` will show us information in a top-like
    format regarding all the container''s internal processes. Using our web server
    from the previous examples, we can execute `docker container top webserver` to
    obtain the `nginx` main process and its child''s states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can add swap access using `--memory-swap` and `--memory-swappiness` but this
    is not recommended. Swapping could decrease application performance and it really
    breaks the logic of distributed microservices. Orchestration will allow us to
    run different components on different nodes, depending on their requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review actions related to images. With these, we
    will be able to create an image from a container, as we learned in *[Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    Building Docker Images*.
  prefs: []
  type: TYPE_NORMAL
- en: Converting containers into images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned about three different methods for building images, and all
    of them use containers in some shape or form. Let''s review the container actions
    that can be used to create images:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `commit` | `docker commit` will allow us to create an image from a container.
    We will add a container''s layer as a new image layer. As a result, we obtain
    a new image. We will set a new image name (although we learned that we can change
    image names whenever we need to) with its tag. The container will be paused during
    the commit to avoid file changes during its execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `export` | This action will create a `.tar` file containing the container''s
    filesystem (including data from all of its layers). By default, this command will
    stream binary content to `STDOUT`, but we can use `--output` or `-o` to define
    a file for this content. |'
  prefs: []
  type: TYPE_TB
- en: When we need to know about the changes we made to the original image layers,
    we can use `docker container diff`. This will show a list of all the files that
    have been modified or created on the container's layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the container web server from the previous examples, we can observe all
    the changes that were made during its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This list shows added files, marked as `A`, as well as changed files and directories,
    marked with `C`. Notice that every time we add a file to a directory, the directory
    is also changed.
  prefs: []
  type: TYPE_NORMAL
- en: We will usually deploy tens, hundreds, or even thousands of containers within
    Docker hosts. It is important to be able to retrieve information about them in
    order to manage their properties and states. In the next section, we will review
    some of the options available to format and filter information in container environments.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and filtering information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Formatting and filtering the output of any command is always useful. In Docker
    commands with long lists or outputs, it is really necessary. Let's begin with
    formatting some command output.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all actions that represent or show any kind of information can be formatted.
    Docker uses Go templates to modify the output format. It is very useful to be
    able to format output for our specific needs. We will use the table format here.
    Each column will represent a specified key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will consider a brief example output listing all the deployed containers
    in a host using `docker container ls` with the table format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have used `--no-trunc` to disable the truncation of printed values. Without
    using this option, all long strings will be truncated and will only show a few
    characters. Usually, they will be enough to identify a value, but sometimes, we
    need the entire string; for example, to review the container's main executed command.
  prefs: []
  type: TYPE_NORMAL
- en: It is very useful to know what keys can be queried for formatting. To obtain
    all allowed keys for formatting, we will use `--format='{{json .}}'`. This will
    show all the columns or keys for a specified action (for example, try `docker
    container ls --all --format='{{json .}}'`). The output will be shown in unformatted
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The unformatted JSON output is not easy to read. We can use **jq** ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)),
    which is a command-line JSON processor for better reading. Using jq, we will obtain
    more prettily formatted JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of customized options for formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `json` | As we have seen, this option will format the output as a single-line
    JSON string. For example, we can use `--format=''{{json .Config}}''` with `docker
    inspect` output for a container to obtain all its configuration keys and values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `table` | The table format option is not available in all outputs, but it
    will work pretty well on lists. |'
  prefs: []
  type: TYPE_TB
- en: '| `join/split` | With these options, we will be able to join or split key outputs;
    for example, `''{{json .Mounts}}''` or `''{{split .Image ":"}}''`. |'
  prefs: []
  type: TYPE_TB
- en: '| `lower/upper/title` | These options allow us to change strings to lowercase,
    uppercase, or just capitalize the first character; for example, `''{{title .Name}}''`
    will show all names with a capitalized first character. |'
  prefs: []
  type: TYPE_TB
- en: '| `range` | This option will help us format list/array values. You have to
    use `''{{range <JSON keys> }}{{end}}''` to correctly manage the listed values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `println` | This option will print each queried value in a new line. It is
    very interesting for formatting range values. |'
  prefs: []
  type: TYPE_TB
- en: The `--pretty` option is available for inspecting some objects. It is very useful
    but, as we mentioned previously, it is not available for all objects. For example,
    you can use it to inspect services, which we will learn about in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting will help us to obtain only required pieces of information, but it
    will not be easy when we have to manage a lot of items. We will filter the information
    using the `--filter` option to retrieve only specific objects matching some keys
    and values. Not all keys will be available for filtering. We will use keys with
    their values for filters and we can use as many filter options as required. If
    we add more than one filter with the same key, they will be used as `OR`. But
    if we use different keys, this will be an `AND` filter. We will use "equal" (using
    `=`) or "different" (using `<>` ) to compare key values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Container objects can be filtered by means of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID or name**: With these options, we can find containers by their IDs or
    names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Label**: This case is special as we can express the query using a key to
    match all the containers with that label or key-value format, in order to find
    a specific value for that key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exited**: We will use this option with an exited integer when using `--all`
    to filter containers stopped with errors, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status**: We use this option to filter by container state (`created`, `restarting`,
    `running`, `removing`, `paused`, `exited` or `dead`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ancestor**: This is very important because it will allow us to filter by
    image name and tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Before/since**: This filter allows us to specify dates, for example, to find
    a container running for a long time or filter by its creation date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume/network**: This option allows us to filter which containers are using
    a volume or network. It is useful for removing old resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish or expose**: These options filter which containers are publishing
    or exposing specified ports. We can use a range of ports and protocols (`<startport-endport>`/`[<proto>]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health**: This filter allows us to search containers by their health check
    status (healthy, unhealthy, starting, or none).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is-task**: This option is very interesting because it allows us to filter
    containers created by tasks when using Docker Swarm orchestration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that `--format` is used for filtering on the `docker <object> inspect`
    command. We can only query specific object keys and subkeys. For example, using
    `--format='{{json .Config}}'` will just show keys and values under the `Config`
    key***.***
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review how to use host attached devices as if they
    were inside containers.
  prefs: []
  type: TYPE_NORMAL
- en: Managing devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can provide access to host devices inside containers. We use the `--device`
    argument with `docker container create` or `docker container run` for this. We
    will be able to use hardware devices connected directly to a host, such as serial
    controllers, block storage, or audio devices.
  prefs: []
  type: TYPE_NORMAL
- en: By default, devices will have read and write permissions. To be able to manipulate
    special devices, the `mknod` permission is also added by default. We can override
    these default settings using `r`, `w`, and `m` in the command line as modifiers
    of the `--device` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can mount our `lvm` mapped block device to a defined directory;
    notice that the mounting capability must be added. In this example, we added `SYS_ADMIN`
    capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we are using our host sound device inside a container.
    Adding these devices to containers will allow us to run some applications with
    sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have learned that not just files or directories can be accessed inside
    containers. We can use special devices as if they were directly attached to containers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter labs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the labs in this chapter, we will run containers and interact with them.
    We will also review some examples, limiting their resources and formatting and
    filtering the command output.
  prefs: []
  type: TYPE_NORMAL
- en: To run these labs, deploy `environments/standalone-environment` from this book's
    GitHub repository ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment` folder to start your virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `standalone-environment`, wait until it is running. We can
    check the statuses of our nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now connect to the `standalone` node using `vagrant ssh standalone`.
    This process may vary if you''ve already deployed a `standalone` virtual node
    before and you just started it using `vagrant up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are reusing your `standalone-environment`, this means Docker Engine
    is installed. If you started a new instance, please execute the `/vagrant/install_requirements.sh`
    script so that you have all the required tools (Docker Engine and docker-compose):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are ready to start the labs.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Docker command-line object options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker command line will allow us to interact with Docker daemons. We will
    use Docker objects or resources with their allowed actions. In the following screenshot,
    we can easily review this behavior in the Docker `help` command''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6824a64-9226-4ae4-ac05-f40a7896651d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Objects will appear in the first part, after common options. At the bottom,
    we will have all the options allowed. As we mentioned in this chapter, not all
    objects have the same actions. This chapter is dedicated to containers. So, let''s
    review what actions are allowed with containers (the output is truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We should use `--help` with each kind of object to review what actions are available
    for them. If we have not set any `DOCKER_HOST` variable (nor using `-H` ), we
    will interact with the local Docker daemon. We will use these arguments in the
    command line to connect to remote daemons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, there are many well-known Docker command-line aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run`: `docker container run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker ps`: `docker container ls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker rm`: `docker container rm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker start/stop`: `docker container start/stop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker port`: `docker container port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker rmi`: `docker image rm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to use long command-line terms as they actually indicate an
    object and action. This will avoid confusion or the misspelling of commands.
  prefs: []
  type: TYPE_NORMAL
- en: Executing containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a long lab in which we are going to review many actions and options
    available to containers. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute an interactive container based on an Alpine image in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will review and rename the container `myalpineshell`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use `-l` or `--last` to obtain the latest container that was executed on
    our Docker host. Notice that we will use `-q` in the following code to obtain
    the container's ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we rename the previously launched container using its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we review the latest container again, we will see that we have a different
    name. Notice that the container is running (the output will show different dates
    for you):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We attach our Terminal to the running `myalpineshell` container and we create
    an empty file named `TESTFILE` under the `/tmp` directory. Then, we `exit` from
    the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we review the container''s status again, we will find that it has stopped,
    but that it exited correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The container now shows an `Exited (0)` status. The Alpine image's main process
    is a shell. Its CMD is `/bin/sh`. We exited by issuing the `exit` command. Therefore,
    the exit status was `0`. No problem was identified during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to force a failure status by executing, for example, a command
    that doesn''t exist in the image. We will execute the `curl` command on a new
    container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `curl` binary does not exist, we cannot even execute the desired command.
    As a result, the container was created but not executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will execute `ls -l /tmp/TESTFILE` on a new container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `/tmp/TESTFILE` file does not exist in this new container.
    We only created it in the `myalpineshell` container. In fact, the file is still
    there. Notice that this time, the container was executed and that the exit status
    shows an error code. This is the exit code of the execution of the `ls` command
    against a non-existent file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rename the last executed container again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the `/tmp/TESTFILE` file on our own host filesystem and
    copy it to the `secondshell` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to copy files from one container to another using `docker
    container cp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start the `secondshell` container again and observe the new results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The file now exists inside the `secondshell` container and, as a result, the
    execution exited correctly. We can notice this new result in the `STATUS` column
    (`Exited (0)`). We have manipulated a dead container by copying a file inside
    it. Therefore, containers are still present in our host system until we remove
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will remove the `secondshell` container and try to filter the container
    list''s output. We will search for the `secondshell` and `myalpineshell` containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we only get the `myalpineshell` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this lab, we will start the `myalpineshell` container once more using
    `docker container start -a -i` to attach our Terminal to the started container.
    Then, we will send the container to the background using the *Ctrl* + *P* + *Q*
    escape sequence. Finally, we will attach a second shell to the container using
    the `docker container exec` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can observe that exiting from the newly executed shell process does not
    kill the `myalpineshell` container. Both processes share the same namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Limiting container resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we are going to use the `frjaraur/stress-ng:alpine` image from
    Docker Hub. This image is based on Alpine Linux with the `stress-ng` packages
    installed. It is small and will help us stress our containers.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with testing memory limits. In this lab, we will use two Terminals
    on the same host. On the first Terminal, we will launch `docker container stats`.
    Keep this running during all these labs because, in this Terminal, we are going
    to observe different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second Terminal, we will launch two containers that will try to consume
    2 GB of memory. We will use `--vm 2 --vm-bytes 1024M` to create two processes
    with 1,024 MB of memory in each:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to launch a container with a memory reservation. This means that
    the Docker daemon will reserve at least that amount of memory for this container.
    Remember that this is not a limit; it is a reservation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will launch a limited container. Only 250 MB of memory will be allowed,
    although the container will try to consume 2 GB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first Terminal, we have `docker container stats` running to review our
    container''s resource consumption. We will have something like this (IDs and usage
    will vary):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you obtain a warning message about limiting resources, this is normal. The
    `WARNING: Your kernel does not support swap limit capabilities or the cgroup is
    not mounted. Memory limited without swap.` message indicates that your operating
    system will not limit `swap` for containers. It comes disabled by default on Debian/Ubuntu.'
  prefs: []
  type: TYPE_NORMAL
- en: We can observe that the non-limited container is taking more than the specified
    memory. In the second case, the container was limited to 250 MB, although the
    process could consume more, it was limited and it will not get more than this
    memory. It is confined to 250 MB, as we can observe in the `MEM USAGE/LIMIT MEM`
    column. It could reach 100% of its confined memory, but it cannot surpass that
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `2GBreserved` and `2GBlimited` containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will limit the CPU consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will launch three containers with different CPU limitations and process
    requirements. The first container is limited to one CPU, but with two CPU requirements.
    This is not a genuine requirement, but the process will try to use two CPUs if
    they are present in this system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The second container is limited to two CPUs with a requirement of two CPUs.
    It will try to use both during execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The third container is limited to four CPUs with two CPUs required. In this
    case, the processes could consume four CPUs, but as they will just use two CPUs,
    they will not have a real limitation unless we try to use more than four CPUs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we observe the Docker container''s stats output, we can confirm the expected
    results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have reviewed how we can limit the container's resources. We tested
    CPU and memory usage with `docker container stats`, pushing them to their defined
    limits.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's review formatting and filtering with some labs.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and filtering container list output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lab, we will review the `docker container ls` output. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch a number of containers. For this example, we will run three `nginx:alpine`
    instances with sequence names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list the running containers using the `docker container ls` default
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want to be able to review the current status of the containers, we
    can format the output so that it includes label information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s filter just the development containers (`stage=development`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s kill just those development containers using the list output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Only `web1`, labeled as `production`, is still running as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and formatting are very useful. Practice these methods because they
    are important for the Docker Certified Associate exam.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to the Docker command line and running containers.
    We found a powerful command line that allowed us to create containers from image
    artifacts, share them between hosts, and execute the already built application
    components.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to interact with different Docker objects, as well as what kind
    of objects are available in standalone Docker host environments and what objects
    are available in orchestrated environments.
  prefs: []
  type: TYPE_NORMAL
- en: We then reviewed how containers can be created, executed, paused/unpaused, and
    stopped or killed. They will stay in our Docker host until they are removed from
    the system. We also learned how to manipulate the container's execution behavior
    and how they exist within the network. To improve security, we introduced a number
    of options and we also learned how executing containers in read-only mode can
    be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the container's resources is necessary for production. By default,
    they will be able to consume all the host's resources, which can be very dangerous.
    We learned how to avoid this situation using soft and hard limits to ensure that
    our applications will run on a host with enough resources and does not disturb
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and filtering specific information is needed while deploying applications
    on dynamic environments. We learned how format and filter actions will help us
    retrieve specific information.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter by learning how to use a host's devices as if they
    were attached directly to containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at container persistency and their networking
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following options is not available for containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `build` b) `update` c) `destroy` d) `create`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following sentences is false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) A container's life is managed using `start` and `stop` commands
  prefs: []
  type: TYPE_NORMAL
- en: b) Containers always stop after 10 seconds
  prefs: []
  type: TYPE_NORMAL
- en: c) Containers can be created and then started
  prefs: []
  type: TYPE_NORMAL
- en: d) Volumes created during the container's lifetime must be deleted by hand unless
    we use the `-v` option when deleting the container
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following sentences is true in relation to `docker kill`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) It will kill all container processes
  prefs: []
  type: TYPE_NORMAL
- en: b) It will send a `SIGKILL` signal to the container's main process
  prefs: []
  type: TYPE_NORMAL
- en: c) It will remove the container once it is killed
  prefs: []
  type: TYPE_NORMAL
- en: d) It will wait 10 seconds by default before really killing the container
  prefs: []
  type: TYPE_NORMAL
- en: We executed a container named `webserver`. Which of the following sentences
    is false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) It can be removed using `docker container rm --force` b) We can update its
    image using `docker container update` c) We can rename the `webserver` container
    to `websrv` using `docker container rename` d) We can view the container's output
    using `docker container logs`
  prefs: []
  type: TYPE_NORMAL
- en: We have executed the `docker container run --name app1 --user 1000 --memory
    100m --privileged alpine touch /testfile` command. Which of the following sentences
    are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `/testfile` was created as root because the container was executed with all
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: b) The container will not be able to consume more than 100 m of host memory.
  prefs: []
  type: TYPE_NORMAL
- en: c) `/testfile` was not created because we used a user with an ID of `1000` and
    it will not be able to write on `/`, the root directory.
  prefs: []
  type: TYPE_NORMAL
- en: d) We used `--privileged`. This option will disable all root capabilities inside
    the container and, as a result, the file can't be created.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following links to find out more about the topics that were covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker command-line reference: [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory limits behavior: [https://medium.com/faun/understanding-docker-container-memory-limit-behavior-41add155236c](https://medium.com/faun/understanding-docker-container-memory-limit-behavior-41add155236c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
