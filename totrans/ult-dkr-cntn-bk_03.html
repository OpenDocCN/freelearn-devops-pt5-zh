<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor057"/>3</h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor058"/>Mastering Containers</h1>
<p>In the previous chapter, you learned how to optimally prepare your working environment for the productive and frictionless use of Docker. In this chapter, we are going to get our hands dirty and learn about everything that is important to know when working with containers.</p>
<p>Here are the topics we’re going to cover in this chapter:</p>
<ul>
<li>Running the first container</li>
<li>Starting, stopping, and removing containers</li>
<li>Inspecting containers</li>
<li>Exec into a running container</li>
<li>Attaching to a running container</li>
<li>Retrieving container logs</li>
<li>The anatomy of containers</li>
</ul>
<p>After finishing this chapter, you will be able to do the following things:</p>
<ul>
<li>Run, stop, and delete a container based on an existing image, such as Nginx, BusyBox, or Alpine</li>
<li>List all containers on the system</li>
<li>Inspect the metadata of a running or stopped container</li>
<li>Retrieve the logs produced by an application running inside a container</li>
<li>Run a process such as <code>/bin/sh</code> in an already-running container</li>
<li>Attach a terminal to an already-running container</li>
<li>Explain in your own words, to an interested layman, the underpinnings of a container</li>
</ul>
<h1 id="_idParaDest-62"><a id="_idTextAnchor059"/>Technical requirements</h1>
<p>For this chapter, you should have Docker Desktop installed on your Linux workstation, macOS, or Windows PC. If you are on an older version of Windows or are using Windows 10 Home Edition, then you should have Docker Toolbox installed and ready to use. On macOS, use the Terminal application, and on Windows, use the PowerShell console or Git Bash to try out the commands you will be learning.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor060"/>Running the first container</h1>
<p>Before we<a id="_idIndexMarker143"/> start, we want to make sure that Docker is installed correctly on your system and ready to accept your commands. Open a new terminal window and type in the following command (note: do not type the <code>$</code> sign, as it is a placeholder for your prompt):</p>
<pre class="source-code">
$ docker version</pre> <p>If everything works correctly, you should see the version of the Docker client and server installed on your laptop output in the terminal. At the time of writing, it looks like this:</p>
<div><div><img alt="Figure 3.1 – Output of the docker version command" height="635" src="img/B19199_03_01.jpg" width="657"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Output of the docker version command</p>
<p>As you can see, I have<a id="_idIndexMarker144"/> version <code>20.10.20</code> installed on my MacBook Air M1 laptop.</p>
<p>If this doesn’t work for you, then something with your installation is not right. Please make sure that you have followed the instructions in the previous chapter on how to install Docker Desktop on your system.</p>
<p>So, you’re ready to see some action. Please type the following command into your terminal window and hit the <em class="italic">Return</em> key:</p>
<pre class="source-code">
$ docker container run alpine echo "Hello World"</pre> <p>When you run the preceding command the first time, you should see an output in your terminal window like this:</p>
<div><div><img alt="Figure 3.2 – Running an Alpine container for the first time" height="153" src="img/B19199_03_02.jpg" width="979"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Running an Alpine container for the first time</p>
<p>Now that was easy! Let’s try to run the very same command again:</p>
<pre class="source-code">
$ docker container run alpine echo "Hello World"</pre> <p>The second, third, or nth time you run the preceding command, you should see only this output in your terminal:</p>
<pre class="source-code">
Hello World</pre> <p>Try to reason why <a id="_idIndexMarker145"/>the first time you run a command you see a different output than all of the subsequent times. But don’t worry if you can’t figure it out; we will explain the reasons in detail in the following sections of this chapter.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor061"/>Starting, stopping, and removing containers</h1>
<p>You <a id="_idIndexMarker146"/>successfully<a id="_idIndexMarker147"/> ran a container in the previous section. Now, we <a id="_idIndexMarker148"/>want to investigate in detail what exactly happened and why. Let’s look again at the command we used:</p>
<pre class="source-code">
$ docker container run alpine echo "Hello World"</pre> <p>This command contains multiple parts. First and foremost, we have the word <code>docker</code>. This is the name of the <a id="_idIndexMarker149"/>Docker <code>container</code>, which indicates the context we are working with, such as <code>container</code>, <code>image</code>, or <code>volume</code>. As we want to run a container, our context is <code>container</code>. Next is the actual command we want to execute in the given context, which is <code>run</code>.</p>
<p>Let me recap – so far, we have <code>docker container run</code>, which means, “hey Docker, we want to run a container.”</p>
<p>Now we also need to tell Docker which container to run. In this case, this is the so-called <code>alpine</code> container.</p>
<p class="callout-heading">Alpine Linux</p>
<p class="callout"><code>alpine</code> is a minimal Docker image based on Alpine Linux with a complete package index and is only about 5 MB in size. It is an official image supported by the Alpine open source project and Docker.</p>
<p>Finally, we need to define what kind of process or task will be executed inside the container when it is running. In our case, this is the last part of the command, <code>echo "</code><code>Hello World"</code>.</p>
<p>The following figure may help you to get a better idea of the whole thing:</p>
<div><div><img alt="Figure 3.3 – docker run command explained" height="147" src="img/B19199_03_03.jpg" width="541"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – docker run command explained</p>
<p>Now that<a id="_idIndexMarker150"/> we<a id="_idIndexMarker151"/> have <a id="_idIndexMarker152"/>understood the various parts of a command to run a container, let’s try to run another container with a different process executed inside it. Type the following command into your terminal:</p>
<pre class="source-code">
$ docker container run centos ping -c 5 127.0.0.1</pre> <p>You should see output in your terminal window similar to the following:</p>
<div><div><img alt="Figure 3.4 – Running the ping command inside a CentOS container" height="480" src="img/B19199_03_04.jpg" width="1367"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Running the ping command inside a CentOS container</p>
<p>What changed is that this time, the container image we’re using is <code>centos</code> and the process we’re executing inside the <code>centos</code> container is <code>ping -c 5 127.0.0.1</code>, which pings <a id="_idIndexMarker153"/>the <a id="_idIndexMarker154"/>loopback IP address (<code>127.0.0.1</code>) five <a id="_idIndexMarker155"/>times until it stops.</p>
<p class="callout-heading">CentOS</p>
<p class="callout"><code>centos</code> is the official Docker image for CentOS Linux, which is a community-supported distribution derived from sources<a id="_idIndexMarker156"/> freely provided to the public by Red Hat for <strong class="bold">Red Hat Enterprise </strong><strong class="bold">Linux</strong> (<strong class="bold">RHEL</strong>).</p>
<p>Let’s analyze the output in detail. The first line is as follows:</p>
<pre class="source-code">
Unable to find image 'centos:latest' locally</pre> <p>This tells us that Docker didn’t find an image named <code>centos:latest</code> in the local cache of the system. So, Docker knows that it has to pull the image from some registry where container images are stored. By default, your Docker environment is configured so that images are pulled from Docker Hub at <code>docker.io</code>. This is expressed by the second line, as follows:</p>
<pre class="source-code">
latest: Pulling from library/centos</pre> <p>The next three lines of output are as follows:</p>
<pre class="source-code">
52f9ef134af7: Pull completeDigest: sha256:a27fd8080b517143cbbbab9dfb7c8571c4...
Status: Downloaded newer image for centos:latest</pre>
<p>This tells us that Docker has successfully pulled the <code>centos:latest</code> image from Docker Hub. All of the subsequent lines of the output are generated by the process we ran inside the container, which is the <code>ping</code> tool in this case. If you have been attentive so far, then you might have noticed the <code>latest</code> keyword occurring a few times. Each image has a version (also called <code>tag</code>), and if we don’t specify a version explicitly, then Docker automatically assumes it is <code>latest</code>.</p>
<p>If we run the <a id="_idIndexMarker157"/>preceding<a id="_idIndexMarker158"/> container again on our <a id="_idIndexMarker159"/>system, the first five lines of the output will be missing since, this time, Docker will find the container image cached locally and hence won’t have to download it first. Try it out and verify what I just told you.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor062"/>Running a random trivia question container</h1>
<p>For the subsequent<a id="_idIndexMarker160"/> sections of this chapter, we need a container that runs continuously in the background and produces some interesting output. That’s why we have chosen an algorithm that produces random trivia questions. The API that produces free random trivia can be found at <a href="http://jservice.io/">http://jservice.io/</a>.</p>
<p>Now, the goal is to have a process running inside a container that produces a new random trivia question every 5 seconds and outputs the question to <code>STDOUT</code>. The following script will do exactly that:</p>
<pre class="source-code">
while :do
    curl -s http://jservice.io/api/random | jq '.[0].question'
    sleep 5
done</pre>
<p>If you are using PowerShell, the preceding command can be translated to the following:</p>
<pre class="source-code">
while ($true) {  Invoke-WebRequest -Uri "http://jservice.io/api/random" -Method GET -UseBasicParsing |
  Select-Object -ExpandProperty Content |
  ConvertFrom-Json |
  Select-Object -ExpandProperty 0 |
  Select-Object -ExpandProperty question
  Start-Sleep -Seconds 5
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">The <code>ConvertFrom-Json</code> cmdlet requires that the <code>Microsoft.PowerShell.Utility</code> module be imported. If it’s not already imported, you’ll need to run <code>Import-Module Microsoft.PowerShell.Utility</code> before running the script.</p>
<p>Try it in a<a id="_idIndexMarker161"/> terminal window. Stop the script by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. The output should look similar to this:</p>
<div><div><img alt="Figure 3.5 – Output random trivia" height="213" src="img/B19199_03_05.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Output random trivia</p>
<p>Each response is a different trivia question. You may need to install <code>jq</code> first on your Linux, macOS, or Windows computer. <code>jq</code> is a handy tool often used to nicely filter and format JSON output, which increases its readability on screen. Use your package manager to install <code>jq</code> if needed. On Windows, using Chocolatey, the command would be as follows:</p>
<pre class="source-code">
$ choco install jq</pre> <p>And on a Mac using Homebrew, you would type the following:</p>
<pre class="source-code">
$ brew install jq</pre> <p>Now, let’s run this logic in an <code>alpine</code> container. Since this is not just a simple command, we want to wrap the preceding script in a script file and execute that one. To make things simpler, I have created a Docker image called <code>fundamentalsofdocker/trivia</code> that contains all of the necessary logic so that we can just use it here. Later on, once we have introduced Docker images, we will analyze this container image further. For the moment, let’s just use it as is. Execute the following command to run the container as a background service. In Linux, a background service is also <a id="_idIndexMarker162"/>called <a id="_idIndexMarker163"/>a daemon:</p>
<pre class="source-code">
$ docker container run --detach \    --name trivia fundamentalsofdocker/trivia:ed2</pre>
<p class="callout-heading">Important note</p>
<p class="callout">We are using the <code>\</code> character to allow line breaks in a single logical command that does not fit on a single line. This is a feature of the shell script we use. In PowerShell, use the backtick (<code>`</code>) instead.</p>
<p class="callout">Also note that on <code>zsh</code>, you may have to press <em class="italic">Shift</em> + <em class="italic">Enter</em> instead of only <em class="italic">Enter</em> after the <code>\</code> character to start a new line. Otherwise, you will get an error.</p>
<p>In the preceding expression, we have used two new command-line parameters, <code>--detach</code> and <code>--name</code>. Now, <code>--detach</code> tells Docker to run the process in the container as a Linux daemon.</p>
<p>The <code>--name</code> parameter, in turn, can be used to give the container an explicit name. In the preceding sample, the name we chose is <code>trivia</code>. If we don’t specify an explicit container name when we run a container, then Docker will automatically assign the container a random but unique name. This name will be composed of the name of a famous scientist and an adjective. Such names could be <code>boring_borg</code> or <code>angry_goldberg</code>. They’re quite humorous, the Docker engineers, aren’t they?</p>
<p>Finally, the container we’re running is derived from the <code>fundamentalsofdocker/trivia:ed2</code> image. Note how we are also using a tag, <code>ed2</code>, for the container. This tag just tells us that this image was originally created for the second edition of this book.</p>
<p>One important takeaway is that the container name has to be unique on the system. Let’s make sure that the trivia container is up and running:</p>
<pre class="source-code">
$ docker container ls -l</pre> <p>This should give us something like this:</p>
<div><div><img alt="Figure 3.6 – Details of the last run container" height="57" src="img/B19199_03_06.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Details of the last run container</p>
<p>An important part of the preceding output is the <code>STATUS</code> column, which in this case is <code>Up 6 minutes</code>. That is, the container has been up and running for 6 minutes now.</p>
<p>Don’t worry if the previous Docker command is not yet familiar to you; we will come back to it in the next section.</p>
<p>To complete this section, let’s stop and remove the <code>trivia</code> container with the following command:</p>
<pre class="source-code">
$ docker rm --force trivia</pre> <p>The preceding<a id="_idIndexMarker164"/> command, while forcefully removing the <code>trivia</code> container from our system, will just output the name of the container, <code>trivia</code>, in the output.</p>
<p>Now, it is time to learn how to list containers running or dangling on our system.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor063"/>Listing containers</h1>
<p>As we continue <a id="_idIndexMarker165"/>to run containers over time, we get a lot of them in our system. To find out what is currently running on our host, we can use the <code>container ls</code> command, as follows:</p>
<pre class="source-code">
$ docker container ls</pre> <p>This will list all currently running containers. Such a list might look similar to this:</p>
<div><div><img alt="Figure 3.7 – List of all running containers on the system" height="125" src="img/B19199_03_07.jpg" width="1266"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – List of all running containers on the system</p>
<p>By default, Docker <a id="_idIndexMarker166"/>outputs seven columns with the following meanings:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Column</p>
</td>
<td class="No-Table-Style">
<p>Description</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Container ID</code></p>
</td>
<td class="No-Table-Style">
<p>This is a short version of the unique ID of the container. It is an SHA-256, where Secure Hash Algorithm 256-bit (SHA-256) is a widely used cryptographic hash function that takes an input and generates a fixed-size (256-bit) output, known as a hash. The full ID is 64 characters long.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Image</code></p>
</td>
<td class="No-Table-Style">
<p>This is the name of the container image from which this container is instantiated.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Command</code></p>
</td>
<td class="No-Table-Style">
<p>This is the command that is used to run the main process in the container.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Created</code></p>
</td>
<td class="No-Table-Style">
<p>This is the date and time when the container was created.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Status</code></p>
</td>
<td class="No-Table-Style">
<p>This is the status of the container (created, restarting, running, removing, paused, exited, or dead).</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Ports</code></p>
</td>
<td class="No-Table-Style">
<p>This is the list of container ports that have been mapped to the host.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Names</code></p>
</td>
<td class="No-Table-Style">
<p>This is the name assigned to this container (note: multiple names for the same container are possible).</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Description of the columns of the docker container ls command</p>
<p>If we want to list not just the currently running containers but all containers that are defined on our system, then we can use the <code>-a</code> or <code>--all</code> command-line parameter, as follows:</p>
<pre class="source-code">
$ docker container ls --all</pre> <p>This will list containers in any state, such as <code>created</code>, <code>running</code>, or <code>exited</code>.</p>
<p>Sometimes, we want to just list the IDs of all containers. For this, we have the <code>-q</code> or <code>--</code><code>quiet</code> parameter:</p>
<pre class="source-code">
$ docker container ls --quiet</pre> <p>You might wonder when this is useful. I will show you a command where it is very helpful right here:</p>
<pre class="source-code">
$ docker container rm --force $(docker container ls --all --quiet)</pre> <p>Lean back and take a deep breath. Then, try to find out what the preceding command does. Don’t read any further until you find the answer or give up.</p>
<p>Here is the solution: the preceding command forcefully deletes all containers that are currently defined on the system, including the stopped ones. The <code>rm</code> command stands for “remove,” and it will be explained soon.</p>
<p>In the previous section, we used the <code>-l</code> parameter in the list command, that is, <code>docker container ls -l</code>. Try to use the <code>docker help</code> command to find out what the <code>-l</code> parameter stands for. You can invoke help for the list command as follows:</p>
<pre class="source-code">
$ docker container ls --help</pre> <p>Now that you<a id="_idIndexMarker167"/> know how to list created, running, or stopped containers on your system, let’s learn how to stop and restart containers.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor064"/>Stopping and starting containers</h1>
<p>Sometimes, we <a id="_idIndexMarker168"/>want<a id="_idIndexMarker169"/> to (temporarily) stop a running container. Let’s try this out with the trivia container we used previously:</p>
<ol>
<li>Run the container again with this command:<pre class="console">
$ docker container run -d --name trivia fundamentalsofdocker/trivia:ed2</pre></li> <li>Now, if we want to stop this container, then we can do so by issuing this command:<pre class="console">
$ docker container stop trivia</pre></li> </ol>
<p>When you try to stop the trivia container, you will probably notice that it takes a while until this command is executed. To be precise, it takes about 10 seconds. <em class="italic">Why is this </em><em class="italic">the case?</em></p>
<p>Docker sends a Linux <code>SIGTERM</code> signal to the main process running inside the container. If the process doesn’t react to this signal and terminate itself, Docker waits for 10 seconds and then sends <code>SIGKILL</code>, which will kill the process forcefully and terminate the container.</p>
<p>In the preceding command, we have used the name of the container to specify which container we want to stop. But we could have also used the container ID instead.</p>
<p>How do we get the ID of a container? There are several ways of doing so. The manual approach is to list all running containers and find the one that we’re looking for in the list. From there, we copy its ID. A more automated way is to use some shell scripting and environment <a id="_idIndexMarker170"/>variables. If, for example, we want to get the ID of the trivia <a id="_idIndexMarker171"/>container, we can use this expression:</p>
<pre class="source-code">
$ export CONTAINER_ID=$(docker container ls -a | grep trivia | awk '{print $1}')</pre> <p>The equivalent command in PowerShell would look like this:</p>
<pre class="source-code">
$ CONTAINER_ID = docker container ls -a | Select-String "trivia" | Select-Object -ExpandProperty Line | ForEach-Object { $_ -split ' ' } | Select-Object -First 1$ Write-Output $CONTAINER_ID</pre>
<p class="callout-heading">Note</p>
<p class="callout">We are using the <code>-a</code> (or <code>--all</code>) parameter with the <code>docker container ls</code> command to list all containers, even the stopped ones. This is necessary in this case since we stopped the trivia container a moment ago.</p>
<p>Now, instead of using the container name, we can use the <code>$CONTAINER_ID</code> variable in our expression:</p>
<pre class="source-code">
$ docker container stop $CONTAINER_ID</pre> <p>Once we have stopped the container, its status changes to <code>Exited</code>.</p>
<p>If a container is stopped, it can be started again using the <code>docker container start</code> command. Let’s do this with our <code>trivia</code> container. It is good to have it running again, as we’ll need it in the subsequent sections of this chapter:</p>
<pre class="source-code">
$ docker container start $CONTAINER_ID</pre> <p>We can also start it by using the name of the container:</p>
<pre class="source-code">
$ docker container start trivia</pre> <p>It is now time<a id="_idIndexMarker172"/> to<a id="_idIndexMarker173"/> discuss what to do with stopped containers that we don’t need anymore.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor065"/>Removing containers</h1>
<p>When we <a id="_idIndexMarker174"/>run the <code>docker container ls -a</code> command, we can see quite a few containers that are in the <code>Exited</code> status. If we don’t need these containers anymore, then it is a good thing to remove them from memory; otherwise, they unnecessarily occupy precious resources. The command to remove a container is as follows:</p>
<pre class="source-code">
$ docker container rm &lt;container ID&gt;</pre> <p>Here, <code>&lt;container ID&gt;</code> stands for the ID of the container – a SHA-256 code – that we want to remove. Another way to remove a container is the following:</p>
<pre class="source-code">
$ docker container rm &lt;container name&gt;</pre> <p>Here, we use the name of the container.</p>
<p class="callout-heading">Challenge</p>
<p class="callout">Try to remove one of your exited containers using its ID.</p>
<p>Sometimes, removing a container will not work as it is still running. If we want to force a removal, no matter what the condition of the container currently is, we can use the <code>-f</code> or <code>--force</code> command-line parameter:</p>
<pre class="source-code">
$ docker container rm &lt;container ID&gt; --force</pre> <p>Now that we have learned how to remove containers from our system, let’s learn how to inspect <a id="_idIndexMarker175"/>containers present in the system.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor066"/>Inspecting containers</h1>
<p>Containers are runtime <a id="_idIndexMarker176"/>instances of an image and have a lot of associated data that characterizes their behavior. To get more information about a specific container, we can use<a id="_idIndexMarker177"/> the <code>inspect</code> command. As usual, we have to provide either the container ID or the name to identify the container for which we want to obtain the data. So, let’s inspect our sample container. First, if it is not already running, we have to run it:</p>
<pre class="source-code">
$ docker container run --name trivia fundamentalsofdocker/ trivia:ed2</pre> <p>Then, use this command to inspect it:</p>
<pre class="source-code">
$ docker container inspect trivia</pre> <p>The response is a big JSON object full of details. It looks similar to this:</p>
<div><div><img alt="Figure 3.8 – Inspecting the trivia container" height="692" src="img/B19199_03_08.jpg" width="1192"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Inspecting the trivia container</p>
<p>Note that the preceding screenshot only shows the first part of a much longer output.</p>
<p>Please take a moment to analyze what you have. You should see information such as the following:</p>
<ul>
<li>The ID of the container</li>
<li>The creation date and time of the container</li>
<li>From which image the container is built</li>
</ul>
<p>Many sections of the output, such as <code>Mounts</code> and <code>NetworkSettings</code>, don’t make much sense right now, but we will discuss those in the upcoming chapters of this book. The data you’re seeing here is also named the <em class="italic">metadata</em> of a container. We will be using the <code>inspect</code> command quite often in the remainder of this book as a source of information.</p>
<p>Sometimes, we need just a tiny bit of the overall information, and to achieve this, we can use either the <code>grep</code> tool or a filter. The former method does not always result in the expected answer, so let’s look into the latter approach:</p>
<pre class="source-code">
$ docker container inspect -f "{{json .State}}" trivia \    | jq .</pre>
<p>The <code>-f</code> or <code>--filter</code> parameter is used to define the <code>"{{json .State}}"</code> filter. The filter <a id="_idIndexMarker178"/>expression itself uses the Go template syntax. In this example, we only want to see the state part of the whole output in JSON format. To nicely format the output, we pipe the result into the <code>jq</code> tool:</p>
<div><div><img alt="Figure 3.9 – The state node of the inspect output" height="320" src="img/B19199_03_09.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – The state node of the inspect output</p>
<p>After we have learned how to retrieve loads of important and useful meta information about a container, we want to investigate how we can execute it in a running container.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor067"/>Exec into a running container</h1>
<p>Sometimes, we <a id="_idIndexMarker179"/>want to run another process inside an already-running container. A typical reason could be to try to debug a misbehaving container. How can we do this? First, we need to know either the ID or the name of the container, and then we can define which process we want to run and how we want it to run. Once again, we use our currently running <code>trivia</code> container and we run a shell interactively inside it with the following command:</p>
<pre class="source-code">
$ docker container exec -i -t trivia /bin/sh</pre> <p>The <code>-i</code> (or <code>--interactive</code>) flag signifies that we want to run the additional process interactively, and <code>-t</code> (or <code>--tty</code>) tells Docker that we want it to provide us with a TTY (a terminal emulator) for the command. Finally, the process we run inside the container is <code>/bin/sh</code>.</p>
<p>If we execute the preceding command in our terminal, then we will be presented with a new prompt, <code>/app #</code>. We’re now in a Bourne shell inside the trivia container. We can easily prove that by, for example, executing the <code>ps</code> command, which will list all running processes in the context:</p>
<pre class="source-code">
/app # ps</pre> <p>The result should look somewhat similar to this:</p>
<div><div><img alt="Figure 3.10 – Executing into the running trivia container" height="241" src="img/B19199_03_10.jpg" width="1325"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Executing into the running trivia container</p>
<p>We can clearly see that the process with PID <code>1</code> is the command that we have defined to run inside the trivia container. The process with PID <code>1</code> is also named the main process.</p>
<p>Exit the container by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em>. We cannot only execute additional processes interactively in a container. Please consider the following command:</p>
<pre class="source-code">
$ docker container exec trivia ps</pre> <p>The output evidently looks very similar to the preceding output:</p>
<div><div><img alt="Figure 3.11 – List of processes running inside the trivia container" height="152" src="img/B19199_03_11.jpg" width="1194"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – List of processes running inside the trivia container</p>
<p>The difference is that we did not use an extra process to run a shell but executed the <code>ps</code> command directly. We can even run processes as a daemon using the <code>-d</code> flag and define environment variables valid inside the container, using the <code>-e</code> or <code>--env</code> flag variables, as follows:</p>
<ol>
<li>Run the following command to start a shell inside a trivia container and define an environment variable named <code>MY_VAR</code> that is valid inside this container:<pre class="console">
$ docker container exec -it \    -e MY_VAR="Hello World" \    trivia /bin/sh</pre></li> <li>You’ll find<a id="_idIndexMarker180"/> yourself inside the <code>trivia</code> container. Output the content of the <code>MY_VAR</code> environment variable, as follows:<pre class="console">
/app # echo $MY_VAR</pre></li> <li>You should see this output in the terminal:<pre class="console">
Hello World</pre></li> </ol>
<div><div><img alt="Figure 3.12 – Running a trivia container and defining an environment variable" height="183" src="img/B19199_03_12.jpg" width="1142"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Running a trivia container and defining an environment variable</p>
<ol>
<li value="4">To exit the trivia container, press <em class="italic"> Ctrl</em> + <em class="italic">D</em>:<pre class="console">
/app # &lt;CTRL-d&gt;</pre></li> </ol>
<p>Great, we have learned how to execute into a running container and run additional processes. But there is another important way to work with a running container.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor068"/>Attaching to a running container</h1>
<p>We can use<a id="_idIndexMarker181"/> the <code>attach</code> command <a id="_idIndexMarker182"/>to attach our terminal’s standard input, output, or error (or any combination of the three) to a running container using the ID or name of the container. Let’s do this for our trivia container:</p>
<ol>
<li>Open a new terminal window.</li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">You may want to use another terminal than the integrated terminal of VS Code for this exercise, as it seems to cause problems with the key combinations that we are going to use. On Mac, use the Terminal app, as an example.</p>
<ol>
<li value="2">Run a new instance of the <code>trivia</code> Docker image in interactive mode:<pre class="console">
$ docker container run -it \    --name trivia2 fundamentalsofdocker/trivia:ed2</pre></li> <li>Open yet another terminal window and use this command to attach it to the container:<pre class="console">
$ docker container attach trivia2</pre></li> </ol>
<p>In this case, we will see, every 5 seconds or so, a new quote appearing in the output.</p>
<ol>
<li value="4">To quit the container without stopping or killing it, we can use the <em class="italic">Ctrl + P</em><code> + </code><em class="italic">Ctrl</em> + <em class="italic">Q</em> key combination. This detaches us from the container while leaving it running in the background.</li>
<li>Stop and remove the container forcefully:<pre class="console">
$ docker container rm --force trivia2</pre></li> </ol>
<p>Let’s run another container, this time, an Nginx web server:</p>
<ol>
<li>Run the Nginx web server as follows:<pre class="console">
$ docker run -d --name nginx -p 8080:80 nginx:alpine</pre></li> </ol>
<p class="callout-heading">Tip</p>
<p class="callout">Here, we run the Alpine version of Nginx as a daemon in a container named <code>nginx</code>. The <code>-p 8080:80</code> command-line parameter opens port <code>8080</code> on the host (that is, the user’s machine) for access to the Nginx web server running inside the container. Don’t worry about the syntax here as we will explain this feature in more detail in <a href="B19199_10.xhtml#_idTextAnchor218"><em class="italic">Chapter 10</em></a>, <em class="italic">Using </em><em class="italic">Single-Host Networking</em>.</p>
<p class="callout">On Windows, you’ll need to approve a prompt that Windows Firewall will pop up. You have to allow Docker Desktop on the firewall.</p>
<ol>
<li value="2">Let’s see <a id="_idIndexMarker183"/>whether we can access Nginx using the <code>curl</code> tool by running this command:<pre class="console">
$ curl -4 localhost:8080</pre></li> </ol>
<p>If all works correctly, you should be greeted by the welcome page of Nginx:</p>
<div><div><img alt="Figure 3.13 – Welcome message of the Nginx web server" height="725" src="img/B19199_03_13.jpg" width="1102"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Welcome message of the Nginx web server</p>
<ol>
<li value="3">Now, let’s attach our terminal to the Nginx container to observe what’s happening:<pre class="console">
$ docker container attach nginx</pre></li> <li>Once you are attached to the container, you will not see anything at first. But now, open another terminal, and in this new terminal window, repeat the <code>curl</code> command a few times, for example, using the following script:<pre class="console">
$ for n in {1..10} do; curl -4 localhost:8080 done;</pre></li> </ol>
<p>Or, in PowerShell, use the following:</p>
<pre class="console">
PS&gt; 1..10 | ForEach-Object {C:\ProgramData\chocolatey\bin\curl.exe -4 localhost:8080}</pre> <p>You should<a id="_idIndexMarker184"/> see the logging output of Nginx, which looks similar to this:</p>
<div><div><img alt="Figure 3.14 – Output of Nginx" height="397" src="img/B19199_03_14.jpg" width="1315"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Output of Nginx</p>
<ol>
<li value="5">Quit the container by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. This will detach your terminal and, at the same time, stop the Nginx container.</li>
<li>To clean up, remove the Nginx container with the following command:<pre class="console">
$ docker container rm nginx</pre></li> </ol>
<p>In the next section, we’re going to learn how to work with container logs.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor069"/>Retrieving container logs</h1>
<p>It is a best<a id="_idIndexMarker185"/> practice for any good application to generate some logging information that developers and operators alike can use to find out what the application is doing at a given time, and whether there are any problems to help to pinpoint the root cause of the issue.</p>
<p>When running inside a container, the application should preferably output the log items to <code>STDOUT</code> and <code>STDERR</code> and not into a file. If the logging output is directed to <code>STDOUT</code> and <code>STDERR</code>, then Docker can collect this information and keep it ready for consumption by a user or any other external system:</p>
<ol>
<li>Run a trivia container in <code>detach</code> mode:<pre class="console">
$ docker container run --detach \    --name trivia fundamentalsofdocker/trivia:ed2</pre></li> </ol>
<p>Let it run for a minute or so so that it has time to generate a few trivia questions.</p>
<ol>
<li value="2">To access the logs of a given container, we can use the <code>docker container logs</code> command. If, for example, we want to retrieve the logs of our <code>trivia</code> container, we can use the following expression:<pre class="console">
$ docker container logs trivia</pre></li> </ol>
<p>This will retrieve the whole log produced by the application from the very beginning of its existence.</p>
<p class="callout-heading">Note</p>
<p class="callout">Stop, wait a second – this is not quite true, what I just said. By default, Docker uses the so-called <code>json-file</code> logging driver. This driver stores logging information in a file. If there is a file rolling policy defined, then <code>docker container logs</code> only retrieves what is in the currently active log file and not what is in previous rolled files that might still be available on the host.</p>
<ol>
<li value="3">If we want to only get a few of the latest entries, we can use the <code>-t</code> or <code>--tail</code> parameter, as follows:<pre class="console">
$ docker container logs --tail 5 trivia</pre></li> </ol>
<p>This will retrieve only the last five items that the process running inside the container produced.</p>
<ol>
<li value="4">Sometimes, we want to follow the log that is produced by a container. This is possible when using the <code>-f</code> or <code>--follow</code> parameter. The following expression will output the last five log items and then follow the log as it is produced by the containerized process:<pre class="console">
$ docker container logs --tail 5 --follow trivia</pre></li> <li>Press <em class="italic">Ctrl + C</em> to stop following the logs.</li>
<li>Clean up your environment and remove the trivia container with the following:<pre class="console">
$ docker container rm --force trivia</pre></li> </ol>
<p>Often, using the <a id="_idIndexMarker186"/>default mechanism for container logging is not enough. We need a different way of logging. This is discussed in the following section.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor070"/>Logging drivers</h2>
<p>Docker includes <a id="_idIndexMarker187"/>multiple logging mechanisms to help us to get information from running containers. These mechanisms are named logging drivers. Which logging driver is used can be configured at the Docker daemon level. The default logging driver is <code>json-file</code>. Some of the drivers that are currently supported natively are as follows:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Driver</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>none</code></p>
</td>
<td class="No-Table-Style">
<p>No log output for the specific container is produced.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>json-file</code></p>
</td>
<td class="No-Table-Style">
<p>This is the default driver. The logging information is stored in files, formatted as JSON.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>journald</code></p>
</td>
<td class="No-Table-Style">
<p>If the <code>journald</code> daemon is running on the host machine, we can use this driver. It forwards logging to the <code>journald</code> daemon.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>syslog</code></p>
</td>
<td class="No-Table-Style">
<p>If the <code>syslog</code> daemon is running on the host machine, we can configure this driver, which will forward the log messages to the <code>syslog</code> daemon.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>gelf</code></p>
</td>
<td class="No-Table-Style">
<p>When using this driver, log messages are written to a <strong class="bold">Graylog Extended Log Format (GELF)</strong> endpoint. Popular examples of such endpoints are Graylog and Logstash.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>fluentd</code></p>
</td>
<td class="No-Table-Style">
<p>Assuming that the <code>fluentd</code> daemon is installed on the host system, this driver writes log messages to it.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>awslogs</code></p>
</td>
<td class="No-Table-Style">
<p>The <code>awslogs</code> logging driver for Docker is a logging driver that allows Docker to send log data to Amazon CloudWatch Logs.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>splunk</code></p>
</td>
<td class="No-Table-Style">
<p>The Splunk logging driver for Docker allows Docker to send log data to Splunk, a popular platform for log management and analysis.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2 – List of logging drivers</p>
<p class="callout-heading">Note</p>
<p class="callout">If you change the logging driver, please be aware that the <code>docker container logs</code> command<a id="_idIndexMarker188"/> is only available for the <code>json-file</code> and <code>journald</code> drivers. Docker 20.10 and up introduce <em class="italic">dual logging</em>, which uses a local buffer that allows you to use the <code>docker container logs</code> command for any logging driver.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor071"/>Using a container-specific logging driver</h2>
<p>The logging driver<a id="_idIndexMarker189"/> can be set globally in the Docker daemon configuration file. But we can also define the logging driver on a container-by-container basis. In the following example, we run a <code>busybox</code> container and use the <code>--logdriver</code> parameter to configure the <code>none</code> logging driver:</p>
<ol>
<li>Run an instance of the <code>busybox</code> Docker image and execute a simple script in it outputting a <code>Hello</code> message three times:<pre class="console">
$ docker container run --name test -it \    --log-driver none \    busybox sh -c 'for N in 1 2 3; do echo "Hello $N"; done'</pre></li> </ol>
<p>We should see the following:</p>
<pre class="console">
Hello 1Hello 2
Hello 3</pre>
<ol>
<li value="2">Now, let’s try to get the logs of the preceding container:<pre class="console">
$ docker container logs test</pre></li> </ol>
<p>The output is as follows:</p>
<pre class="console">
Error response from daemon: configured logging driver does not support reading</pre> <p>This is to be expected since the <code>none</code> driver does not produce any logging output.</p>
<ol>
<li value="3">Let’s<a id="_idIndexMarker190"/> clean up and remove the <code>test</code> container:<pre class="console">
$ docker container rm test</pre></li> </ol>
<p>To end this section about logging, we want to discuss a somewhat advanced topic, namely, how to change the default logging driver.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor072"/>Advanced topic – changing the default logging driver</h2>
<p>Let’s change <a id="_idIndexMarker191"/>the default logging driver of a Linux host. The easiest way to do this is on a real Linux host. For this purpose, we’re going to use Vagrant with an Ubuntu image. Vagrant is an open source tool developed by HashiCorp that is often used to build and maintain portable virtual software development environments. Please follow these instructions:</p>
<ol>
<li>Open a new terminal window.</li>
<li>If you haven’t done so before, on your Mac and Windows machine, you may need to install a hypervisor such as VirtualBox first. If you’re using a Pro version of Windows, you can also use Hyper-V instead:<ul><li>To install VirtualBox on a Mac with an Intel CPU, use Homebrew as follows:<pre class="console">
<code>$ brew install --cask virtualbox</code></pre></li><li>On Windows, with Chocolatey, use the following:<pre class="console"><code>$ choco install -y virtualbox</code></pre></li></ul></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">On a Mac with an M1/M2 CPU, at the time of writing, you need to install the developer preview of VirtualBox. Please follow the instructions here: <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>.</p>
<ol>
<li value="3">Install Vagrant <a id="_idIndexMarker192"/>on your computer using your package manager, such as Chocolatey on Windows or Homebrew on Mac. On my MacBook Air M1, the command looks like this:<pre class="console">
$ brew install --cask vagrant</pre></li> </ol>
<p>On a Windows machine, the corresponding command would be the following:</p>
<pre class="console">
$ choco install -y vagrant</pre> <ol>
<li value="4">Once successfully installed, make sure Vagrant is available with the following command:<pre class="console">
$ vagrant –version</pre></li> </ol>
<p>At the time of writing, Vagrant replies with the following:</p>
<pre class="console">
Vagrant 2.3.2</pre> <ol>
<li value="5">In your terminal, execute the following command to initialize an Ubuntu 22.04 VM with Vagrant:<pre class="console">
$ vagrant init bento/ubuntu-22.04</pre></li> </ol>
<p>Here is the generated output:</p>
<div><div><img alt="Figure 3.15 – Initializing a Vagrant VM based on Ubuntu 22.04" height="152" src="img/B19199_03_15.jpg" width="1137"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Initializing a Vagrant VM based on Ubuntu 22.04</p>
<p>Vagrant will create a file called <code>Vagrantfile</code> in the current folder. Optionally, you can use your editor to analyze the content of this file.</p>
<p class="callout-heading">Note</p>
<p class="callout">On a Mac with an M1/M2 CPU, at the time of writing, the <code>bento/ubuntu-22.4</code> image does not work. An alternative that seems to work is <code>illker/ubuntu-2004</code>.</p>
<ol>
<li value="6">Now, start this VM using Vagrant:<pre class="console">
$ vagrant up</pre></li> <li>Connect<a id="_idIndexMarker193"/> from your laptop to the VM using Secure Shell (<code>ssh</code>):<pre class="console">
$ vagrant ssh</pre></li> </ol>
<p>After this, you will find yourself inside the VM and can start working with Docker inside this VM.</p>
<ol>
<li value="8">Once inside the Ubuntu VM, we want to edit the Docker daemon configuration file and trigger the Docker daemon to reload the configuration file thereafter:<ol><li>Navigate to the <code>/</code><code>etc/docker</code> folder:</li></ol><pre class="console">
<code>$ cd /etc/docker</code></pre><ol><li value="2">Run <code>vi</code> as follows:</li></ol><pre class="console"><code>$ vi daemon.json</code></pre><ol><li value="3">Enter the following content:</li></ol><pre class="console">{    "Log-driver": "json-log",    "log-opts": {        "max-size": "10m",        "max-file": 3    }}</pre><ol><li value="4">The preceding definition tells the Docker daemon to use the <code>json-log</code> driver with a maximum log file size of 10 MB before it is rolled, and the maximum number of log files that can be present on the system is three before the oldest file gets purged.</li><li>Save and exit <code>vi</code> by first pressing <em class="italic">Esc</em>, then typing <code>:w:q</code> (which means <em class="italic">write and quit</em>), and finally hitting the <em class="italic">Enter</em> key.</li><li>Now, we<a id="_idIndexMarker194"/> must send a <code>SIGHUP</code> signal to the Docker daemon so that it picks up the changes in the configuration file:</li></ol><pre class="console"><code>$ sudo kill -SIGHUP $(pidof dockerd)</code></pre><ol><li value="7">Note that the preceding command only reloads the config file and does not restart the daemon.</li></ol></li> <li>Test your configuration by running a few containers and analyzing the log output.</li>
<li>Clean up your system once you are done experimenting with the following:<pre class="console">
$ vagrant destroy [name|id]</pre></li> </ol>
<p>Great! The previous section was an advanced topic and showed how you can change the log driver on a system level. Let’s now talk a bit about the anatomy of containers.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor073"/>The anatomy of containers</h1>
<p>Many people wrongly <a id="_idIndexMarker195"/>compare containers to VMs. However, this is a questionable comparison. Containers are not just lightweight VMs. OK then, what is the correct description of a container?</p>
<p>Containers are specially encapsulated and secured processes running on the host system. Containers leverage a lot of features and primitives available on the Linux operating system. The most important <a id="_idIndexMarker196"/>ones are <strong class="bold">namespaces</strong> and <strong class="bold">control groups</strong> (<strong class="bold">cgroups</strong> for short). All <a id="_idIndexMarker197"/>processes running in containers only share the same Linux kernel of the underlying host operating system. This is fundamentally different from VMs, as each VM contains its own full-blown operating system.</p>
<p>The startup times of a typical container can be measured in milliseconds, while a VM normally needs several seconds to minutes to start up. VMs are meant to be long-living. It is a primary goal of each operations engineer to maximize the uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They come and go relatively quickly.</p>
<p>Let’s first get a high-level overview of the architecture that enables us to run containers.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor074"/>Architecture</h2>
<p>Here, we<a id="_idIndexMarker198"/> have an<a id="_idIndexMarker199"/> architectural diagram of how this all fits together:</p>
<div><div><img alt="Figure 3.16 – High-level architecture of Docker" height="782" src="img/B19199_03_16.jpg" width="1262"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – High-level architecture of Docker</p>
<p>In the lower part of the preceding diagram, we have the Linux operating system with its cgroups, namespaces, and layer capabilities as well as other operating system functionality that we do not need to explicitly mention here. Then, there is an intermediary layer composed of <code>containerd</code> and <code>runc</code>. On top of all that now sits the Docker engine. The Docker engine offers a RESTful interface to the outside world that can be <a id="_idIndexMarker200"/>accessed by any tool, such as the<a id="_idIndexMarker201"/> Docker CLI, Docker Desktop, or Kubernetes, to name just a few.</p>
<p>Let’s now describe the main building blocks in a bit more detail.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor075"/>Namespaces</h2>
<p>Linux <a id="_idIndexMarker202"/>namespaces<a id="_idIndexMarker203"/> were around for years before they were leveraged by Docker for their containers. A <strong class="bold">namespace</strong> is an abstraction of global resources such as filesystems, network access, and process trees (also named PID namespaces) or the system group IDs and user IDs. A Linux system is initialized with a single instance of each namespace type. After initialization, additional namespaces can be created or joined.</p>
<p>The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version 3.8, user namespaces were introduced, and with this, namespaces were ready to be used by containers.</p>
<p>If we wrap a running process, say, in a filesystem namespace, then this provides the illusion that the process owns its own complete filesystem. This, of course, is not true; it is only a virtual filesystem. From the perspective of the host, the contained process gets a shielded<a id="_idIndexMarker204"/> subsection<a id="_idIndexMarker205"/> of the overall filesystem. It is like a filesystem in a filesystem:</p>
<div><div><img alt="Figure 3.17 – Namespaces explained" height="361" src="img/B19199_03_17.jpg" width="552"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Namespaces explained</p>
<p>The same applies to all of the other global resources for which namespaces exist. The user ID namespace is another example. Now that we have a user namespace, we can define a <code>jdoe</code> user many times on the system as long as it is living in its own namespace.</p>
<p>The PID namespace is what keeps processes in one container from seeing or interacting with processes in another container. A process might have the apparent PID 1 inside a container, but if we examine it from the host system, it will have an ordinary PID, say, <code>334</code>:</p>
<div><div><img alt="Figure 3.18 – Process tree on a Docker host" height="893" src="img/B19199_03_18_new.jpg" width="1275"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Process tree on a Docker host</p>
<p>In each namespace, we can run one-to-many processes. That is important when we talk about <a id="_idIndexMarker206"/>containers, which<a id="_idIndexMarker207"/> we already experienced when we executed another process in an already-running container.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor076"/>Control groups</h2>
<p>Linux cgroups are <a id="_idIndexMarker208"/>used to limit, manage, and isolate the<a id="_idIndexMarker209"/> resource usage of collections of processes running on a system. Resources are the CPU time, system memory, network bandwidth, or combinations of these resources.</p>
<p>Engineers at Google originally implemented this feature in 2006. The cgroups functionality was merged into the Linux kernel mainline in kernel version 2.6.24, which was released in January 2008.</p>
<p>Using cgroups, administrators can limit the resources that containers can consume. With this, we can avoid, for example, the classic noisy neighbor problem, where a rogue process running in a container consumes all the CPU time or reserves massive amounts of RAM and, as such, starves all the other processes running on the host, whether they’re containerized <a id="_idIndexMarker210"/>or <a id="_idIndexMarker211"/>not.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor077"/>Union filesystem</h2>
<p><strong class="bold">Union filesystem</strong> (<strong class="bold">unionfs</strong>) forms<a id="_idIndexMarker212"/> the backbone of<a id="_idIndexMarker213"/> what is known as container images. We will discuss container images in detail in the next chapter. Currently, we want to just understand what unionfs is and how it works a bit better. unionfs is mainly used on Linux and allows files and directories of distinct filesystems to be overlaid to form a single coherent filesystem. In this context, the individual filesystems are called branches. Contents of directories that have the same path within the merged branches will be seen together in a single merged directory, within the new virtual filesystem. When merging branches, the priority between the branches is specified. In that way, when two branches contain the same file, the one with the higher priority is seen in the final filesystem.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor078"/>Container plumbing</h2>
<p>The foundation on <a id="_idIndexMarker214"/>top of which Docker Engine is built comprises two components, <code>runc</code> and <code>containerd</code>.</p>
<p>Originally, Docker was built in a monolithic way and contained all of the functionality necessary to run containers. Over time, this became too rigid, and Docker started to break out parts of the functionality into their own components. Two important components are <code>runc</code> and <code>containerd</code>.</p>
<h3>runc</h3>
<p>runc is <a id="_idIndexMarker215"/>a lightweight, portable <a id="_idIndexMarker216"/>container runtime. It provides full support for Linux namespaces as well as native support for all security features available on Linux, such as SELinux, AppArmor, seccomp, and cgroups.</p>
<p>runC is a tool for spawning and running containers according to the <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>) specification. It is <a id="_idIndexMarker217"/>a formally specified configuration format, governed by the <strong class="bold">Open Container Project</strong> (<strong class="bold">OCP</strong>) under the auspices of the<a id="_idIndexMarker218"/> Linux Foundation.</p>
<h3>containerd</h3>
<p>runC is a low-level <a id="_idIndexMarker219"/>implementation of a container runtime; containerd <a id="_idIndexMarker220"/>builds on top of it and adds higher-level features, such as image transfer and storage, container execution, and supervision as well as network and storage attachments. With this, it manages the complete life cycle of containers. containerd is the reference implementation of the OCI specifications and is by far the most popular and widely used container runtime.</p>
<p>Containerd was donated to and accepted by the CNCF in 2017. There are alternative implementations of the OCI specification. Some of them are <code>rkt</code> by CoreOS, CRI-O by Red Hat, and LXD by Linux Containers. However, containerd is currently by far the most popular container <a id="_idIndexMarker221"/>runtime and is the default <a id="_idIndexMarker222"/>runtime of Kubernetes 1.8 or later and the Docker platform.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor079"/>Summary</h1>
<p>In this chapter, you learned how to work with containers that are based on existing images. We showed how to run, stop, start, and remove a container. Then, we inspected the metadata of a container, extracted its logs, and learned how to run an arbitrary process in an already-running container. Last but not least, we dug a bit deeper and investigated how containers work and what features of the underlying Linux operating system they leverage.</p>
<p>In the next chapter, you’re going to learn what container images are and how we can build and share our own custom images. We’ll also be discussing the best practices commonly used when building custom images, such as minimizing their size and leveraging the image cache. Stay tuned!</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor080"/>Further reading</h1>
<p>The following articles give you some more information related to the topics we discussed in this chapter:</p>
<ul>
<li>Get started with containers at <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></li>
<li>Get an overview of Docker container commands at <a href="http://dockr.ly/2iLBV2I">http://dockr.ly/2iLBV2I</a></li>
<li>Learn about isolating containers with a user namespace at <a href="http://dockr.ly/2gmyKdf">http://dockr.ly/2gmyKdf</a></li>
<li>Learn about limiting a container’s resources at <a href="http://dockr.ly/2wqN5Nn">http://dockr.ly/2wqN5Nn</a></li>
</ul>
<h1 id="_idParaDest-84"><a id="_idTextAnchor081"/>Questions</h1>
<p>To assess your learning progress, please answer the following questions:</p>
<ol>
<li>Which two important concepts of Linux are enabling factors for containers?</li>
<li>What are the possible states a container can be in?</li>
<li>Which command helps us to find out which containers are currently running on our Docker host?</li>
<li>Which command is used to list only the IDs of all containers?</li>
</ol>
<h1 id="_idParaDest-85"><a id="_idTextAnchor082"/>Answers</h1>
<p>Here are some sample answers to the questions presented in this chapter:</p>
<ol>
<li>Linux had to first introduce <strong class="bold">namespaces</strong> and <strong class="bold">cgroups</strong> to make containers possible. Containers use those two concepts extensively. Namespaces are used to encapsulate and thus protect resources defined and/or running inside a container. cgroups are used to limit the resources processes running inside a container can use, such as memory, bandwidth, or CPU.</li>
<li>The possible states of a Docker container are as follows:<ul><li><code>created</code>: A container that has been created but not started</li><li><code>restarting</code>: A container that is in the process of being restarted</li><li><code>running</code>: A currently running container</li><li><code>paused</code>: A container whose processes have been paused</li><li><code>exited</code>: A container that ran and completed</li><li><code>dead</code>: A container that Docker Engine tried and failed to stop</li></ul></li>
<li>We can use the following (or the old, shorter version, <code>docker ps</code>):<pre class="console">
$ docker container ls</pre></li> </ol>
<p>This is used to list all containers that are currently running on our Docker host. Note that this will <em class="italic">not</em> list the stopped containers, for which you need the extra <code>--all</code> (or <code>-a</code>) parameter.</p>
<ol>
<li value="4">To list all container IDs, running or stopped, we can use the following:<pre class="console">
$ docker container ls -a -q</pre></li> </ol>
<p>Here, <code>-q</code> stands for output ID only, and <code>-a</code> tells Docker that we want to see all containers, including stopped ones.</p>
</div>
</div></body></html>