- en: Chapter 4. Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learned how to launch individual Docker hosts locally using Docker
    for Mac, Docker for Windows, and Docker Machine for remote hosts, as well as using
    Docker locally on Linux. Individual Docker hosts are great for local development,
    or launching a few test instances however as you start moving towards production
    you need fewer single points of failure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to get a little more adventurous and create a
    cluster of Docker hosts. Docker ships a tool called Swarm, when deployed it acts
    as a scheduler between your Docker client and the Docker host, deciding where
    to launch containers based on scheduling rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually launching a Docker Swarm cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Docker for Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Docker for Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And also how to launch containers within our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Swarm manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of [Chapter 3](ch03.html "Chapter 3. Docker in the Cloud"), *Docker
    in the Cloud* we looked at using a Docker Machine to launch a Docker host in Digital
    Ocean. We are going to start with Digital Ocean again, but this time we are going
    to launch three hosts and then create a Docker Swarm cluster on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with we need to launch the hosts and to do this, run the following
    commands, remembering to replace the Digital Ocean API access token with your
    own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once launched, running `docker-machine ls` should show you a list of your images.
    Also, this should be reflected in your Digital Ocean control panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Swarm manually](img/B06455_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have our Docker hosts and we need to assign a role to each of the nodes
    within the cluster. Docker Swarm has two node roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manager**: A manager is a node which dispatches tasks to the workers, all
    your interaction with the Swarm cluster will be targeted against a manager node.
    You can have more than one Manger node, however in this example we will be using
    just one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker**: Worker nodes accept the tasks dispatched by the Manager node(s),
    these are where all your services are launched. We will go in to services in more
    detail once we have our cluster configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our cluster, **swarm01** will be the manager node with **swarm02** and **swarm03**
    being our two worker nodes. We are going to use the `docker-machine ssh` command
    to execute commands directly on our three nodes, starting with configuring our
    manager node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note, the commands in the walk through will only work with Mac and Linux,
    commands to run on Windows will be covered at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we initialize the manager node, we need to capture the IP address of
    `swarm01` as a command-line variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the IP address, run the following command to check if it is
    correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And then to configure the manager node, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then receive confirmation that `swarm01` is now a manager along with
    instructions on what to run to add a worker to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Swarm manually](img/B06455_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You don't have to a make a note of the instructions as we will be running the
    command in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our two workers, we need to capture the join token in a similar way
    we captured the IP address of our manager node using the `$managerIP` variable;
    to do this, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you `echo` the variable out to check that it is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to add our two worker nodes into the cluster by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Swarm manually](img/B06455_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect your local Docker client to the manager node using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And then running a `docker-machine ls` again shows. As you can see from the
    list of hosts, `swarm01` is now active but there is nothing in the **SWARM** column;
    why is that?
  prefs: []
  type: TYPE_NORMAL
- en: Confusingly, there are two different types of Docker Swarm cluster, there is
    the Legacy Docker Swarm which was managed by Docker Machine, and then there is
    the new Docker Swarm mode which is managed by the Docker Engine itself.
  prefs: []
  type: TYPE_NORMAL
- en: We have a launched a Docker Swarm Mode cluster. This is now the preferred way
    of launching Swarm, the legacy Docker Swarm is slowly being retired.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of the nodes within our Swarm cluster, we need to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a Swarm manually](img/B06455_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For information on each node you can run the following command (the `--pretty`
    flag renders the JSON output from the Docker API):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You are given a wealth of information about the host, including the fact that
    it is a manager and it has been launched in Digital Ocean. Running the same command;
    but for a worker node shows similar information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, as the node is not a manager that section is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at launching services into our cluster, we should look at how
    to launch our cluster using Docker Machine on Windows. We will be using PowerShell
    for this rather than the more traditional Windows CMD prompt, however, even using
    PowerShell there are a few differences in the commands used due differences between
    PowerShell and bash.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to launch the three hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the three hosts are up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Swarm manually](img/B06455_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can create the manager node by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a Swarm manually](img/B06455_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have your manager you can add the two worker nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then configure your local Docker client to use your manager node and check
    the cluster status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, no matter which operating system you are using, you should have
    a three node Docker Swarm cluster in Digital Ocean, we can now look at a launching
    service into our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than launching containers using the `docker container run` command you
    need to create a service A service defines a task which the manager then passes
    to one of the workers and then a container is launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s launch a simple service called cluster which uses the image we looked
    at in [Chapter 2](ch02.html "Chapter 2. Launching Applications Using Docker"),
    *Launching Applications Using Docker*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, we should now have a single container running on one of our three
    nodes. To check that the service is running and get a little more information
    about the service, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have confirmed that our service is running, you will be able to
    open your browser and enter the IP address of one of your three nodes (which you
    can get by running `docker-machine ls`).One of the features of Docker Swarm is
    it's routing mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching a service](img/B06455_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A routing mesh? When we exposed the port using the `-p:80:80/tcp` flag, we did
    a little more than map port `80` on the host to port `80` on the container, we
    actually created a Swarm load balancer on `port 80` across all of the hosts within
    the cluster. The Swarm load balancer then directs requests to containers within
    our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the commands below, should show you which tasks are running on which
    nodes, remember tasks are containers which have been launched by the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Like me, you probably have your single task running on `swarm01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching a service](img/B06455_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can make things more interesting by scaling our service to add more tasks,
    to do this simply run the following commands to scale and check our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you should see, we now have 6 tasks running within our cluster service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching a service](img/B06455_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Checking the nodes should show that the tasks are evenly distributed between
    our three nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Launching a service](img/B06455_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hitting refresh in your browser should also update the hostname under the Docker
    image change, another way of seeing this on Mac and Linux is to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following terminal output, our requests are being load
    balanced between the running tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching a service](img/B06455_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we terminate our Docker Swarm cluster let''s look at another way we
    can launch services, before we do we need to remove the currently running service,
    to do this simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that the service has been removed, we can launch a stack.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where it may get confusing. If a service is the same as running container
    then a stack is running a collection of services like you would launch multiple
    containers using Docker Compose. In fact, you can launch a stack using a Docker
    Compose file, with a few additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at launching our Cluster application again. You can find the Docker
    Compose file we are going to be using in the repo in the `/bootcamp/chapter04/cluster/`
    folder, before we go through the contents of the `docker-compose.yml` file, let''s
    launch the stack. To do this run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get confirmation that the network for the stack has been created
    along with the service. You can list the services launched by the stack by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And then check on the tasks within the service by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Launching a stack](img/B06455_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may be surprised to see that service has launched its tasks on `swarm02`
    and `swarm03` only. For an explanation as to why, let''s open the `docker-compose.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `docker-compose.yml` file looks like what we covered in
    [Chapter 2](ch02.html "Chapter 2. Launching Applications Using Docker"), *Launching
    Applications Using Docker*, until we get to the `deploy` section.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already spotted the reason why we only have tasks running on our
    two worker nodes, as you can see in the `placement` section, we have told Docker
    to only launch our tasks on nodes with the role of worker.
  prefs: []
  type: TYPE_NORMAL
- en: Next up we have a defined a `restart_policy` this tells the Docker what to do
    should any of the tasks stop responding, in our case we are telling the Docker
    to restart them `on-failure`. Finally, we are telling the Docker to launch six
    `replicas` within our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test that restart policy by terminating one of our two worker nodes.
    There is a graceful way of doing this by draining the node, however, it more fun
    to just terminate the node, to do this run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running `docker stack ps` cluster immediately after removing the host shows
    that the Docker hasn't caught up yet.
  prefs: []
  type: TYPE_NORMAL
- en: Running `docker stack ps` a few seconds later will show that we still have six
    tasks running, but as you can see from the terminal output they are now all running
    on `swarm02` and the tasks the new ones have replaced are showing as **shutdown**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application should still be available by entering the IP address of `swarm01`
    or `swarm02` into your browser. Once you have finished with the remain two hosts
    you can them by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have manually created our Docker Swarm cluster in Digital Ocean,
    I am sure you agree that so far, the process has been straightforward, especially
    considering how powerful the clustering technology is, you are already probably
    starting to think how you can start to deploy services and stacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections we are going to look at Docker for Amazon Web Services
    and Docker for Azure, and how Docker can take advantage of the range of supporting
    features provided by the two public cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker for AWS is a Swarm cluster which has been tuned by Docker to run in Amazon
    Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AWS CloudFormation is a templating engine which allows you to define your AWS
    infrastructure and resources in a controllable and predictable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS CloudFormation template can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://editions-us-east-1.s3.amazonaws.com/aws/stable/Docker.tmpl](https://editions-us-east-1.s3.amazonaws.com/aws/stable/Docker.tmpl)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see there is quite a lot to it, the image below is a visualization
    of the template above – while you may not be able to see all the content in the
    image you should get an idea of the complexity of the **CloudFormation** template
    supplied by Docker.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the template does all the heavy lifting for you meaning you
    don't really have to do much apart from one thing, create an SSH key. To do this
    login to the AWS console at [https://console.aws.amazon.com/](https://console.aws.amazon.com/),
    select **EC2**from the **Services** menu at the top of the screen, once the EC2
    dashboard opens click on **Key Pairs** in the left-hand side menu.
  prefs: []
  type: TYPE_NORMAL
- en: Here you will have the option to **Create Key Pair** or **Import Key Pair**.
    Once you have your SSH key created or imported you can get to launching your Docker
    for Amazon Web Services cluster, to this, select **CloudFormation** from the **Services**
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking **Create New Stack** will take you a page which lets you define your
    stack, as Docker have already done this for us all you need to do is enter the
    URL of the stack definition file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://editions-us-east-1.s3.amazonaws.com/aws/stable/Docker.tmpl](https://editions-us-east-1.s3.amazonaws.com/aws/stable/Docker.tmpl)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the space below where is says **Specify an Amazon S3 template URL**, making
    sure that the radio icon above where you entered the URL is selected click on
    **Next**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next page you are taken to is where you define how you would like your
    stack to look, for this quick demonstration I used the following to roughly match
    the sizes of the manual Swarm cluster we launched in Digital Ocean:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack name**: Bootcamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of Swarm managers?** 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of Swarm worker nodes?** 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which SSH key to use?**<your own SSH key>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable daily resource clea****nup?** No'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Cloudwatch for container logging?**Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swarm manager instance type?**t2.micro'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manager ephemeral storage volume size?** 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manager ephemeral storage volume type** standard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent worker instance type?** t2.micro'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker ephemeral storage volume size?** 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker ephemeral storage vol****ume type**: standard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have filled in all the details, click on the **Next** button at the
    bottom of the page. The next screen you are taken to contains additional options
    such as tagging, we don't need to enter anything here so just click on the **Next**
    button,
  prefs: []
  type: TYPE_NORMAL
- en: The final page is where we review everything before we comit to launching our
    stack. If you need to change any of the values you can do so by clicking on **Previous**,
    once you are happy with how the details you need to tick the box which says, **I
    acknowledge that AWS CloudFormation might create IAM resources** and then click
    the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: This will immediately start deploying the resources for your Docker for Amazon
    Web Service cluster, you can check the status of the deployment by having the
    **Events** tab open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **refresh** button should show you something like the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Launching the stack will take several minutes, once it has completed you should
    see that the **Status** says **CREATE_COMPLETE**. Once you see this, click on
    the **Outputs** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here you should see four messages, the first contains the Elastic Load Balancer
    URL, the second is a message about the availability of your instances and finally
    you should see a message about **Managers**, this contains a link – click it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This takes you to the Instances page of the EC2 dashboard, you will also notice
    that our single manager node has been filtered, selecting it shows information
    such as the public URL and IP address of the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To interact with our cluster, we are going to SSH into the manager node, you
    need to use the `docker` username. I used the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you downloaded a key pair then you would use something like;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are logged in you should see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running `docker node ls` shows that we have three worker nodes and the one
    manager node we are logged into:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s launch our cluster application, as we are logged into a very basic
    operating system, in fact as you can from the output of running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We are logged into an Alpine Linux server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Git is not installed by default so let''s install it by switching to the root
    user and install the Git package using APK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Git is installed we can clone the Bootcamp repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Git is installed we can then launch our stack using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our stack is launched you can access it using the Elastic Load Balancer
    URL from the Outputs tab of the CloudFormation stack, in my case the URL was (please
    note that my URL no longer works):'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://bootcamp-elb-1145454691.eu-west-1.elb.amazonaws.com/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the screen below the page displays as expected with the
    host name of the container the content is being served from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As before, running curl against the Elastic Load Balancer URL shows that hostname
    of the container is changing (remember to replace the URL with your own):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Before we teardown our Cluster there is one more to take a quick look at, if
    you when we launched our Docker for Amazon Web Service stack we said yes to **Use
    Cloudwatch for container logging**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This option streams your container logs to Amazons own central logging service,
    to view return to the AWS console and select **Cloudwatch** from the **Services**
    menu, once the Cloudwatch dashboard has loaded, click **Logs** in the left-hand
    side menu and then click on the **Bootcamp-lg** link, here you should list of
    the containers which were launched by your `docker stack create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on one of the log streams will show you everything which that container
    has logged, which in our case should just be a lot of information from the supervisord
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Amazon Web Services](img/B06455_04_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To tear down our Docker for Amazon Web Services cluster return to the CloudFormation
    dashboard, select your stack then select **Delete Stack** from the **Actions**
    menu. This will pop-up a prompt, click the **Yes, Delete** button and deletion
    of your stack with start immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Removing all the resource will take several minutes, it is important to ensure
    that all the resources are removed as Amazon operate a pay-as-go model meaning
    if a resource such as an EC2 instance is running you will be being charged for
    it so I would recommend you keep the window open and ensure that the deletion
    is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of charges, you may have noticed that when we launched our stack there
    was a link to estimated costs, this takes all the resource defined in the CloudFormation
    template and runs it through Amazon's Simple Cost Calculator application, our
    four instance Docker for Amazon Web Services would cost us an estimated $66.98
    per month to run.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we launched a quite complex configuration without much effort
    at all, Docker have also applied this same methodology to Microsoft Azure, let's
    look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker for Azure needs a little more work up-front before we can deploy. Luckily,
    Docker have made this as simple as possible by providing the Azure command line
    interface as a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a service profile and resource group for our deployment to
    use, to do this simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download the Azure CLI. The three variables we are passing the command
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the service profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the resource group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which region we would like to launch our cluster in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After a few seconds, you should receive a URL and an authentication code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Azure](img/B06455_04_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open [https://aka.ms/devicelogin/](https://aka.ms/devicelogin/) in your browser
    and enter the code you were given, which in my case was **DQQXPYV7G**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Azure](img/B06455_04_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the screen above, the application is identifying itself
    as **Microsoft Azure Cross-platform Command Line Interface** so we know that the
    request is right; clicking on Continue will ask you to login. Once logged in you
    will receive confirmation that your request has been authorised and the application
    has logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a second or two you should see your command line spring into life, the
    first thing it will do is ask you which subscription it should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Azure](img/B06455_04_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the right subscription, and then leave the command to finish, it will
    take around five minutes to complete. At the of the process you should receive
    your access credentials, make a note of these as you will need them to launch
    your stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Azure](img/B06455_04_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have completed the preparation it is time to launch the Docker
    for Azure template, you can view the template at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://download.docker.com/azure/stable/Docker.tmpl](https://download.docker.com/azure/stable/Docker.tmpl)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And to launch it simply go to the following URL in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fdownload.docker.com%2Fazure%2Fstable%2FDocker.tmpl](https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fdownload.docker.com%2Fazure%2Fstable%2FDocker.tmpl)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should already be logged in from authorizing the command line interface,
    if not login and you will be take a to a page which asks for several pieces of
    information on how you would like your stack to look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscription** <Select your subscription>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use existing** <Select your resource group generated in the previous step
    >'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location** <This will be greyed out>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ad Service Principal App ID** <Enter your AD ServicePrincipal App ID generated
    in the previous step >'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ad Service Principal App Secret**: <Enter your AD ServicePrincipal App Secret
    generated in the previous step >'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable System Prune**: no'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manager Count**: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manager VM Size**: Standard_D2_v2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ssh Public Key**: <Enter your public key, see below>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swarm Name**: dockerswarm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker Count**: 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker VM** **Size**: Standard_D2_v2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To quickly copy your public SSH key to your clipboard on a Mac or Linux run
    the following command (changing the path to your own key if needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you tick the box next to **I agree to the terms and conditions stated
    above**, once you are happy with the contents of the form click on **Purchase**.
    This will kick off your deployment, the process will take several minutes, once
    complete your dashboard will have a new resource added to it, depending on your
    existing resources you may have to scroll to see it or the page may need to be
    refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **See more** in your resource tile will give you a list of all
    the resources created by Docker for Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Azure](img/B06455_04_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should be able to see two public IP addresses assigned, one for a **externalLoadBalancer-public-ip**
    and one for a **externalSSHLoadBalancer-public-ip** make a note of both as we
    are going to need them, to find out the IP address click on the resource to find
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the two IP addresses we can SSH into our manager node, SSH
    is listening on port `50000`, so to SSH to the node run the following command
    making sure you use the **externalSSHLoadBalancer-public-ip** address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in, run `docker node ls` and you should see your three worker nodes,
    if you don''t they may still be starting so give it a few minutes more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker for Azure](img/B06455_04_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As with Docker for Amazon Web Services, you are SSH'ed into an Alpine Linux
    host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meaning that to install Git we need to change to the root user and using APK
    to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once Git is installed we can check out the Bootcamp repository using;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And then launch our application stack using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And make sure everything is running by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting the externalLoadBalancer-public-ipaddress into your browser should
    show you your cluster application. Again, using the CURL command should show us
    that traffic is being distributed across our containers (remember to use your
    own Load Balancer IP address):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There you have it, we have successfully deployed Docker for Azure and our cluster
    application. The last thing to do is to delete the resources so that we do get
    any unexpected bills, to do this select **Resource groups** from the left-hand
    menu and then click on the three dots next to the **bootcamp-resource** entry
    and select **Delete**.
  prefs: []
  type: TYPE_NORMAL
- en: It will take about 10 minutes to remove all the resources and the group, but
    it is worth keeping the Azure portal open until the deletion process has completed
    as you do not want to incur any additional cost.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how long the resources were live this entire demo would have cost
    less than $0.10.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I suspect that by the end of this chapter things were getting very predictable
    and there were no real surprises, this is by design. As you have experienced,
    Docker have provided a very powerful clustering solution which once deployed acts
    in a consistent and predictable way no matter what underlying platform you have
    launched your cluster on.
  prefs: []
  type: TYPE_NORMAL
- en: There is one important thing which we yet to touch on yet, persistent storage
    for our containers. This is important, especially in a cluster, as it allows our
    containers to not only move between hosts but also introduces ways in which we
    can do rolling updates of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at both Docker network & volume plugins.
  prefs: []
  type: TYPE_NORMAL
