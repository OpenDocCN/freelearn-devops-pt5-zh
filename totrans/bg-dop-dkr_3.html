<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Orchestration and Delivery</h1></div></div></div><p>The main motivation behind creating a cluster of Docker hosts is designing for high availability. Most, if not all, clustering and orchestration tools, such as Docker Swarm and Kubernetes, take advantage of clustering by creating a master-slave kind of relationship. This ensures that there is always a node to fall back to in case any one node goes down in the environment. While deploying a cluster to a cloud provider, there are a couple of technologies you can leverage to ensure that your environment is highly available, for example Consul, and also take advantage of the native fault-tolerant design of the cloud by deploying masters and nodes in separate availability zones.</p><div><div><div><div><h1 class="title"><a id="ch04lvl4sec07"/>Lesson Objectives</h1></div></div></div><p>By the end of this lesson, you will be able to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Obtain an overview of the Docker Swarm mode</li><li class="listitem" style="list-style-type: disc">Use Docker engine to create a swarm of Docker engines</li><li class="listitem" style="list-style-type: disc">Manage services and applications in a swarm</li><li class="listitem" style="list-style-type: disc">Scale services up and down to handle more requests on your application</li><li class="listitem" style="list-style-type: disc">Load balance a Docker Swarm deployment</li><li class="listitem" style="list-style-type: disc">Secure Docker containers and deployments</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Orchestration</h1></div></div></div><p>Running containers<a class="indexterm" id="id94"/> on our local environment is easy and does not require a lot of our effort; when it comes to the cloud, we need a different kind of mindset and tools to aid us in achieving this. Our environment should be <strong>highly available, fault tolerant</strong>, and <strong>easily scalable</strong>. This process of  coordinating resources and/or containers, resulting in a consolidated workflow, is orchestration.</p><p>First, let's get familiarized with <a class="indexterm" id="id95"/>some of the terms used when it comes to orchestration:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">docker-engine</code>: This <a class="indexterm" id="id96"/>refers to the Docker bundle or installation we currently have on our computers</li><li class="listitem" style="list-style-type: disc"><code class="literal">docker-machine</code>: A tool<a class="indexterm" id="id97"/> that helps us install Docker on virtual hosts</li><li class="listitem" style="list-style-type: disc"><code class="literal">Virtual hosts</code>: These<a class="indexterm" id="id98"/> are virtual servers that run under physical hosts</li><li class="listitem" style="list-style-type: disc"><code class="literal">docker-swarm</code>: A<a class="indexterm" id="id99"/> clustering tool for Docker</li><li class="listitem" style="list-style-type: disc"><code class="literal">docker host</code>: A <a class="indexterm" id="id100"/>host or server that has Docker set up or installed</li><li class="listitem" style="list-style-type: disc"><code class="literal">Node</code>:  A Docker host <a class="indexterm" id="id101"/>that is connected to a swarm cluster</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cluster</code>: A group<a class="indexterm" id="id102"/> of Docker hosts or nodes</li><li class="listitem" style="list-style-type: disc"><code class="literal">Replica</code>: A duplicate <a class="indexterm" id="id103"/>or number of duplicates of an instance</li><li class="listitem" style="list-style-type: disc"><code class="literal">Task</code>: A <a class="indexterm" id="id104"/>defined operation to be run on nodes</li><li class="listitem" style="list-style-type: disc"><code class="literal">Service</code>: A<a class="indexterm" id="id105"/> group of tasks</li></ul></div><div><div><h3 class="title"><a id="note39"/>Note</h3><p>Here are the most common terms throughout the lesson:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">docker-engine</code>: running Docker on our computers;</li><li class="listitem" style="list-style-type: disc"><code class="literal">docker-machine</code>: A tool or CLI that helps us install Docker</li><li class="listitem" style="list-style-type: disc"><code class="literal">Virtual hosts</code>: A host or server running on a physical host. </li><li class="listitem" style="list-style-type: disc"><code class="literal">docker-swarm:</code>A<a class="indexterm" id="id106"/> clustering tool for Docker</li><li class="listitem" style="list-style-type: disc"><code class="literal">Docker host</code>: Any server or host running Docker </li><li class="listitem" style="list-style-type: disc"><code class="literal">Node</code>: This <a class="indexterm" id="id107"/>refers to any host bound to a swarm cluster.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cluster</code>: A <a class="indexterm" id="id108"/>group of managed and controlled hosts.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Replica</code>: A duplicate of other running hosts for various tasks </li><li class="listitem" style="list-style-type: disc"><code class="literal">Task</code>: Operations like install, upgrade, or remove.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Service</code>: Multiple tasks<a class="indexterm" id="id109"/> define a service. </li></ul></div></div></div><p>Now that we are at least conversant with the terms above, we are ready to implement a Docker Swarm orchestration flow using <code class="literal">docker-machine</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>An Overview of Docker Swarm </h1></div></div></div><p>Docker Swarm is<a class="indexterm" id="id110"/> a <strong>clustering</strong> tool<a class="indexterm" id="id111"/> for Docker containers. It allows you to establish and manage a cluster of <a class="indexterm" id="id112"/>Docker <strong>nodes </strong>as a <a class="indexterm" id="id113"/>single <strong>virtual system</strong>. This means we get to run Docker on multiple hosts on our computers.</p><p>We control <a class="indexterm" id="id114"/>the swarm cluster through a manager which primarily <strong>handles</strong> and <strong>controls </strong>containers. With the swarm manager, you can create a primary manager instance and multiple <strong>replica</strong> instances in case the primary fails. This means you can have more than one manager in a swarm!</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>A swarm is <a class="indexterm" id="id115"/>created from a manager node, and other Docker machines join the cluster, either as worker nodes or manager nodes.</p><p>Clustering is <a class="indexterm" id="id116"/>important because it creates a group of cooperating systems that provide redundancy, creating a fault-tolerant environment. For example, if one or more of the nodes goes down, Docker Swarm will fail over to another working node.</p></div></div><p>The <strong>Swarm manager</strong>
<a class="indexterm" id="id117"/> carries out the following roles:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accepts <code class="literal">docker</code> commands</li><li class="listitem" style="list-style-type: disc">Executes commands against the cluster</li><li class="listitem" style="list-style-type: disc">Supports high availability; deploys a primary and secondary instance which can take over in the event of the primary instance going down</li></ul></div><p>Docker Swarm uses <strong>scheduling</strong> to optimize resources and ensure efficiency in the environment. It <strong>assigns containers</strong> to the <a class="indexterm" id="id118"/>most appropriate <strong>nodes</strong>. This means Docker Swarm will assign containers to the most healthy node.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>Remember, a node is a <strong>host running Docker</strong>, not a <strong>container.</strong>
</p></div></div><p>Swarm can be configured<a class="indexterm" id="id119"/> to use any of the following scheduling strategies:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Random</strong>: Deploys a new container to a random node.</li><li class="listitem" style="list-style-type: disc"><strong>Spread</strong>: Swarm deploys a new container to the node with the least number of containers.</li><li class="listitem" style="list-style-type: disc"><strong>Binpack</strong>: The binpack strategy involves deploying a new container to the node with the highest number of containers.</li></ul></div><p>You can <a class="indexterm" id="id120"/>download VirtualBox at: <a class="ulink" href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>:
</p><div><img alt="An Overview of Docker Swarm" src="img/image03_01.jpg"/></div><div><div><h3 class="title"><a id="note42"/>Note</h3><p>To simulate a <a class="indexterm" id="id121"/>Docker Swarm cluster, we need to install a hypervisor (a hypervisor type 2 is a virtual machine manager that is installed as a software application on an existing operating system) locally, in this case VirtualBox, that will allow us to create multiple hosts running Docker locally via <code class="literal">docker-machine</code> and then add them to the swarm cluster. While deploying to a cloud vendor, this is achieved using their compute service, for instance EC2 on AWS.</p><p>For Windows operating systems, select your OS distribution and you should get a download immediately. Run the executable and install VirtualBox.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Using Docker Engine to Create a Swarm</h1></div></div></div><p>Before we <a class="indexterm" id="id122"/>create our swarm, let's get a quick overview of the <code class="literal">docker-machine cli</code>. Typing <code class="literal">docker-machine</code> on your terminal should give you<a class="indexterm" id="id123"/> this output:</p><div><img alt="Using Docker Engine to Create a Swarm" src="img/image03_03.jpg"/></div><p>Just below that, we have our list of commands:</p><div><img alt="Using Docker Engine to Create a Swarm" src="img/image03_04.jpg"/></div><div><div><h3 class="title"><a id="note43"/>Note</h3><p>Remember to always use the <code class="literal">help</code> option when you need to clarify something, that is, <code class="literal">docker-machine stop --help</code>
</p><p>To create<a class="indexterm" id="id124"/> our first Docker Swarm cluster, we are going to use <code class="literal">docker-machine</code> to create our manager and worker nodes first.</p><p>Before creating the first machine, a quick overview of our objectives gives us the following: we are going to have four docker-machines, one manager, and three workers; they are all running on VirtualBox, thus there are four <strong>virtual machines</strong>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Creating Docker Machines</h2></div></div></div><p>This command is <a class="indexterm" id="id125"/>used to create a new virtual Docker host:</p><div><pre class="programlisting">
<code class="literal">docker-machine create --driver &lt;driver&gt; &lt;machine_name&gt;</code>
</pre></div><p>This means our Docker host will be running on <strong>VirtualBox</strong>, but managed and controlled by <code class="literal">docker-machine</code>. The <code class="literal">--driver</code> option specifies the driver to create the machine with. In this case, our driver is <strong>VirtualBox</strong>.</p><p>Our command will be <code class="literal">docker-machine create --driver virtualbox manager1</code>.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>We require the <a class="indexterm" id="id126"/>driver in the command because that is our host's foundation, meaning our <code class="literal">manager1</code> machine will be running on VirtualBox as a virtual host. There are multiple drivers available from different vendors, but this is the best one for demo purposes.</p></div></div><div><img alt="Creating Docker Machines" src="img/image03_05.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Listing Created Machines</h2></div></div></div><p>This command <a class="indexterm" id="id127"/>will provide a listing of all the Docker Machines currently on your host and more information such as the state, driver, and so on of the machine:
<code class="literal">docker-machine ls</code>
</p><div><img alt="Listing Created Machines" src="img/image03_06.jpg"/></div><div><div><h3 class="title"><a id="note45"/>Note</h3><p>Listing our machine is very important as it gives us an update of our machine status. We don't really get<a class="indexterm" id="id128"/> notified of errors, which at times could build up to a fateful event. Before doing some work on a machine, this will give a brief overview. A more detailed check can be run through the <code class="literal">docker-machine status</code> command.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Worker Machine Creation</h2></div></div></div><p>We will follow the<a class="indexterm" id="id129"/> same process to create three worker machines for our swarm cluster, in other words, running <code class="literal">docker-machine create --driver virtualbox &lt;machine_name&gt;</code> three times, passing <code class="literal">worker1, worker2,</code> and<code class="literal"> worker3 </code>as the value for<code class="literal"> &lt;machine_name&gt; </code>on each subsequent run:</p><div><img alt="Worker Machine Creation" src="img/image03_07.jpg"/></div><div><img alt="Worker Machine Creation" src="img/image03_08.jpg"/></div><p>Finally, the <a class="indexterm" id="id130"/>last worker node will be displayed as follows:</p><div><img alt="Worker Machine Creation" src="img/image03_09.jpg"/></div><p>After doing so, run <code class="literal">docker-machine ls</code> and if the creation was successful, you will see an output similar to the following:</p><div><img alt="Worker Machine Creation" src="img/image03_10.jpg"/></div><div><div><h3 class="title"><a id="note46"/>Note</h3><p>Naming the<a class="indexterm" id="id131"/> machines according to their purpose helps us avoid unexpected calls to the wrong hosts.  </p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Initializing our Swarm</h2></div></div></div><p>Now that we <a class="indexterm" id="id132"/>have our machines running, it's time to create our swarm. This will be done through the manager node, <code class="literal">manager1</code>. The following are the steps we will take to achieve a full-fledged swarm:</p><div><ol class="orderedlist arabic"><li class="listitem">Connect to the manager node.</li><li class="listitem">Declare the <code class="literal">manager1</code> node as the manager and advertise its address.</li><li class="listitem">Get the invite address for nodes to join the swarm.</li></ol></div><p>We will be using <code class="literal">ssh </code>for our connection.  <code class="literal">ssh </code>is a secure network protocol used to access or connect to hosts or servers.</p><div><div><h3 class="title"><a id="note47"/>Note</h3><p>Docker Machines are controlled via the <code class="literal">docker-machine cli. </code>Docker Swarm runs as a service that bonds all the Docker Machines and unifies them under a manager machine, or node. This doesn't mean the machines in a swarm cluster are equal or similar in any way, they could all be running different services or operations, for example, a database host and a web server. Docker Swarm comes in to help orchestrate the hosts.</p></div></div><p>This command is used to get the IP address of one or more Docker machines:</p><div><pre class="programlisting">
<code class="literal">docker-machine ip &lt;machine_names&gt;</code>
</pre></div><p>This command is used to get the IP address of one or more Docker machines. The <code class="literal">&lt;machine_name&gt;</code> is the name or names of the machines whose IP addresses we need. In our case, we will use it<a class="indexterm" id="id133"/> to get the IP address of the <code class="literal">manager1</code> node as we will need it when initializing swarm mode: </p><div><img alt="Initializing our Swarm" src="img/image03_11.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Connecting to a Machine</h2></div></div></div><p>This<a class="indexterm" id="id134"/> command is used to log into a machine using <code class="literal">SSH:</code>
</p><div><pre class="programlisting">
<code class="literal">docker-machine ssh &lt;machine_name&gt;</code>
</pre></div><p>After a successful connection to our <code class="literal">manager1</code>, we should get an output that looks like the following:</p><div><img alt="Connecting to a Machine" src="img/image03_12.jpg"/></div><div><div><h3 class="title"><a id="note48"/>Note</h3><p>Using the <code class="literal">ssh protocol</code> on cloud vendors will require authentication and/or authorization through usernames and passwords or <code class="literal">ssh keys</code>. We will not be going deeper into this because this is a demo.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Initializing Swarm Mode</h2></div></div></div><p>Here is the command to initialize the swarm mode:</p><div><pre class="programlisting">
<code class="literal">docker swarm init --advertise-addr &lt;MANAGER_IP&gt;</code>
</pre></div><p>Let's run this command inside the manager node to initialize a swarm. The <code class="literal">advertise-addr </code>option is used to specify the address that will be advertised to other members of the swarm for API access and networking. </p><p>In this case, its value is the <code class="literal">manager IP address</code> whose value we got from running the <code class="literal">docker-machine ip manager1</code> earlier: </p><div><div><h3 class="title"><a id="note49"/>Note</h3><p>We mentioned earlier that Docker Swarm is a service that bonds and orchestrates all machines through a manager node. For this to happen, Docker Swarm lets us advertise the cluster through the address of the manager, by including <code class="literal">advertise-addr</code> in the <code class="literal">docker swarm init</code> command.</p></div></div><div><img alt="Initializing Swarm Mode" src="img/image03_13.jpg"/></div><p>The output of running the command shows us that our node is now a manager!</p><p>Notice we also have two commands: one should allow us to invite other nodes to the cluster and the other to add another manager to the cluster.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>When designing for high availability, it is recommended to have more than one manager node that will take over in the case of a failure on the primary manager node.</p></div></div><div><div><h3 class="title"><a id="note51"/>Note</h3><p>Ensure you <a class="indexterm" id="id135"/>save two commands listed in the output as they will be useful in adding other hosts in the swarm.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Adding Workers to our Swarm</h2></div></div></div><p>This command is <a class="indexterm" id="id136"/>used to add swarm workers<code class="literal">:</code>
</p><div><pre class="programlisting">
<code class="literal">docker swarm join --token &lt;provided_token&gt; &lt;manager_ip&gt;:&lt;port&gt;</code>
</pre></div><p>Before we can add our workers to the swarm, we will need to connect to them, through <code class="literal">ssh.</code>
</p><p>We achieve this by running <code class="literal">docker-machine ssh &lt;node_name&gt;</code> and then running the invite command we got from the <code class="literal">manager1 node.</code>
</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>The <code class="literal">docker-machine</code> command can be run from any directory and will always work with the created machines.</p></div></div><p>First, we will exit the manager node, using the <code class="literal">exit</code> command:</p><div><img alt="Adding Workers to our Swarm" src="img/image03_14.jpg"/></div><p>Then, we connect to a worker node via <code class="literal">ssh</code>:</p><div><img alt="Adding Workers to our Swarm" src="img/image03_15.jpg"/></div><p>Finally, we add the <a class="indexterm" id="id137"/>node to the cluster:</p><div><img alt="Adding Workers to our Swarm" src="img/image03_16.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Viewing a Cluster's Status</h2></div></div></div><p>We use this<a class="indexterm" id="id138"/> command to view the status of our cluster:</p><div><pre class="programlisting">docker node ls</pre></div><p>We use this command to view the status of our cluster. This command is run on the manager node and displays all the nodes in our cluster and their status and availability. Running this on our manager node shows output similar to that of the following:</p><div><img alt="Viewing a Cluster's Status" src="img/image03_17.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Activity 1 — Adding Nodes to a Cluster</h2></div></div></div><p>Ensure you <a class="indexterm" id="id139"/>have a manager node and the node invite command.</p><p>To get you conversant with <code class="literal">ssh</code> and cluster management.</p><p>You have been asked to connect to at least two nodes and add them to the cluster.</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">Ssh</code> into your first node:<div><img alt="Activity 1 — Adding Nodes to a Cluster" src="img/image03_18.jpg"/></div></li><li class="listitem">Run the invite command on the node to join the cluster. Remember, we got this command when we first initialized our manager node:<div><img alt="Activity 1 — Adding Nodes to a Cluster" src="img/image03_19.jpg"/></div></li><li class="listitem">Exit<a class="indexterm" id="id140"/> the node, <code class="literal">ssh</code> into another, and run the command:<div><img alt="Activity 1 — Adding Nodes to a Cluster" src="img/image03_20.jpg"/></div></li><li class="listitem"><code class="literal">Ssh</code> into the manager node to check the cluster status through <code class="literal">docker node ls:</code><div><img alt="Activity 1 — Adding Nodes to a Cluster" src="img/image03_21.jpg"/></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Managing Services and Applications in a Swarm</h1></div></div></div><p>Now that our <a class="indexterm" id="id141"/>cluster is ready, it's time to schedule some services on our cluster. As mentioned earlier, the role of the manager node is to accept Docker commands<a class="indexterm" id="id142"/> and apply them against the cluster. Therefore, we will create the services on the manager node.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>At this point, there really isn't much one can do on worker nodes as they are fully under the control of the manager.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Creating a Service</h2></div></div></div><p>This<a class="indexterm" id="id143"/> command is used to create a service:</p><div><pre class="programlisting">
<code class="literal">docker service create --replicas &lt;count&gt; -p &lt;host_port&gt;:&lt;container_port&gt; --name &lt;service_name&gt; &lt;image_name&gt;</code>
</pre></div><p>We run this on the manager as earlier alluded to. We are going to be using the WordPress example we built in the previous lesson. Since we already have this image locally, there will be no hassle pulling it from the hub. </p><p>Our replica count is going to be three because we currently have three worker nodes; confirm your node number by running <code class="literal">docker node ls</code>.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>We do not create a replica count; this introduces the following topics.The <code class="literal">-p &lt;host_port&gt;:&lt;container_port&gt;</code> maps the container to be built on our computer's defined port, against the container port. We do not need to have an equal number of replicas as our node number. Other nodes can handle different application layers, for example, the database:</p><div><img alt="Creating a Service" src="img/image03_22.jpg"/></div><p>We created<a class="indexterm" id="id144"/> a web, based on the WordPress image, and mapped the host port <code class="literal">80</code> to the container port <code class="literal">80</code>. </p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Listing Services </h2></div></div></div><p>This<a class="indexterm" id="id145"/> command is used to view the currently running services:</p><div><pre class="programlisting">docker service ls</pre></div><p>This command is used to view the currently running services and more information, such as the replicas, image, ports, and so on.</p><p>From the following output, we can see the service we just started and the associated information:</p><div><img alt="Listing Services" src="img/image03_23.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Service Status</h2></div></div></div><p>This command is used to know whether our services are operational:</p><div><pre class="programlisting">docker service ps &lt;service_name&gt;</pre></div><p>Viewing the <a class="indexterm" id="id146"/>service listing will not provide us with all the information we need, such as what nodes our service is deployed on. However, we get to know whether our services are operational and the errors encountered, if any. When we run this on our manager, we get the following output:</p><div><img alt="Service Status" src="img/image03_24.jpg"/></div><div><div><h3 class="title"><a id="note56"/>Note</h3><p>Viewing the status is very important. In a situation where we are running upgrades or updates on our nodes, running <code class="literal">docker ps</code> would inform us on the status of our nodes. In an ideal Docker Swarm setup, when a node goes down, the manager would reallocate traffic to the available nodes, thus it would be a little hard noticing downtime, unless monitoring is available. Before working with the nodes, always run this to check on the status of the nodes.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>How Do We Know Our Site is Running?</h2></div></div></div><p>We can verify WordPress is running by opening any of the workers' IP addresses on our browser:</p><div><img alt="How Do We Know Our Site is Running?" src="img/image03_25.jpg"/></div><p>Here is a screenshot of how WordPress would appear on our browser:</p><div><img alt="How Do We Know Our Site is Running?" src="img/image03_26.jpg"/></div><div><div><h3 class="title"><a id="note57"/>Note</h3><p>Opening any of the IP addresses running the WordPress web service, including the manager node, will open the same address.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Activity 2 — Running Services on a Swarm</h2></div></div></div><p>Ensure <a class="indexterm" id="id147"/>you have a manager node running. </p><p>To get you conversant with service management in a swarm.</p><p>You have been asked to add a new <code class="literal">postgres </code>service to the swarm.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new node and name it <code class="literal">dbworker</code>: <div><pre class="programlisting">docker-machine create --driver virtualbox dbworker</pre></div><div><img alt="Activity 2 — Running Services on a Swarm" src="img/image03_27.jpg"/></div></li><li class="listitem">Add the <a class="indexterm" id="id148"/>new worker to the swarm:<div><img alt="Activity 2 — Running Services on a Swarm" src="img/image03_28.jpg"/></div></li><li class="listitem">Create a new database service and name it <code class="literal">db</code>, using the postgres image as the base:<div><pre class="programlisting">docker service create --replicas 1 --name db postgres</pre></div><p>Here is a screenshot of the output:</p><div><img alt="Activity 2 — Running Services on a Swarm" src="img/image03_29.jpg"/></div></li><li class="listitem">Verify <code class="literal">postgres</code> is running through the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Map the <code class="literal">postgres</code> container running in <code class="literal">dbworker node</code> to your computer:<div><pre class="programlisting">
<code class="literal">docker run --name db -e POSTGRES_PASSWORD=postgres -d -p 5432:5432 postgres</code>
</pre></div><div><img alt="Activity 2 — Running Services on a Swarm" src="img/image03_30.jpg"/></div></li><li class="listitem">Run <code class="literal">docker ps</code> to list running containers; this should have our <code class="literal">postgres</code> container and the status should be <code class="literal">UP</code>:<p>             
</p><div><img alt="Activity 2 — Running Services on a Swarm" src="img/image03_31.jpg"/></div><p>	</p></li><li class="listitem">Exit and stop the <a class="indexterm" id="id149"/>container through the following:<div><img alt="Activity 2 — Running Services on a Swarm" src="img/image03_32.jpg"/></div></li></ol></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>
Scaling Services Up and Down</h1></div></div></div><p>As the number<a class="indexterm" id="id150"/> of requests coming into your application increases or decreases, there will be a need to scale the infrastructure. We have recently worked with node replicas running the same WordPress installation we made.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>That is a very basic example of a production-level setup.  Ideally, we would need a few more manager nodes and replicas, but since we are running a demo, this will be sufficient.</p><p>Scaling involves both the increase and decrease of resources depending on an application's traffic.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Scaling Our Database Service </h2></div></div></div><p>We will <a class="indexterm" id="id151"/>scale our database service as an example of how to scale services. In a real-world scenario, cloud services such as Google Cloud Platform and <a class="indexterm" id="id152"/>Amazon Web Services may have automatic scaling services defined, where a number of replicas are created and traffic is distributed across the replicas through a service known <a class="indexterm" id="id153"/>as <strong>load balancing</strong>. We will dig deeper into that in the next activity. First, we understand how scaling works from the basics. The command for scaling the database is in the following format:</p><div><pre class="programlisting">docker service scale &lt;service_name&gt;=&lt;count&gt;</pre></div><p>To scale the service, pass in the service name we provided when creating the service and the number of replicas you want to increase it to. </p><div><div><h3 class="title"><a id="note59"/>Note</h3><p>The <code class="literal">--detach=false</code> allows us to view the replication progress.The command is <code class="literal">docker service scale &lt;service_name&gt;=&lt;count&gt;:</code>
</p><div><img alt="Scaling Our Database Service" src="img/image03_33.jpg"/></div><p>From the <a class="indexterm" id="id154"/>output above, we can see that our <code class="literal">db</code> service has been replicated. We now have two database services running on the <code class="literal">dbworker</code> node. </p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>How Does Swarm Know Where to Schedule a Service?</h2></div></div></div><p>We covered scheduling <a class="indexterm" id="id155"/>modes earlier; they include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Random</li><li class="listitem" style="list-style-type: disc">Spread</li><li class="listitem" style="list-style-type: disc">Binpack</li></ul></div><p>The default scheduling strategy for Docker Swarm is <code class="literal">spread</code>, which assigns a new service to the node with the<strong> least</strong> resources.</p><div><div><h3 class="title"><a id="note61"/>Note</h3><p>If you don't have extra unassigned nodes on the swarm, the service you want to scale will be replicated on the currently running nodes.</p><p>The swarm manager will use the spread strategy and allocate according to resources. </p></div></div><p>We can then verify that the action was indeed successful using the <code class="literal">docker service ls</code> command and we can see that the number of replicas is two: </p><div><img alt="How Does Swarm Know Where to Schedule a Service?" src="img/image03_34.jpg"/></div><p>Scaling down<a class="indexterm" id="id156"/> is pretty similar to scaling up, only we pass a lower replica count than we had before. From the following output, we scale down to one replica and verify that the replica count is one: </p><div><img alt="How Does Swarm Know Where to Schedule a Service?" src="img/image03_35.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>How Does Swarm Load Balance Requests between Replicas?</h2></div></div></div><p>A <a class="indexterm" id="id157"/>load balancer helps in handling and managing requests in an application. In cases where an application handles a lot of requests, which could be 1,000 in less than 5 minutes, we would need to have multiple replicas and a load balancer on our application, specifically the logical (backend) section. The load balancer helps distribute requests and prevent overloading of an instance, eventually leading to downtime.</p><p>When deploying<a class="indexterm" id="id158"/> to production on a cloud platform <a class="indexterm" id="id159"/>such as <strong>Google Cloud Platform</strong> or <strong>Amazon Web Services</strong>, you can<a class="indexterm" id="id160"/> make use of an external load balancer to route requests to your swarm hosts.</p><p>Docker Swarm<a class="indexterm" id="id161"/> includes a built-in routing service that enables each node in the swarm to accept incoming connections to a published port, even if there is no service running on the node. <code class="literal">postgres </code>service uses port <code class="literal">5432</code> by default.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Activity 3 — Scaling Services on a Swarm</h2></div></div></div><p>Ensure <a class="indexterm" id="id162"/>you have a swarm with at least one manager, two services, and three worker nodes.</p><p>To get you conversant with scaling services and replicating nodes.</p><p>You have <a class="indexterm" id="id163"/>been asked to scale the web service to four replicas and the database service to two replicas.</p><div><ol class="orderedlist arabic"><li class="listitem">Create<a class="indexterm" id="id164"/> three new worker nodes, two for the web service and one for the database service.</li><li class="listitem">Connect to the manager node and scale the web and database services.</li><li class="listitem">Confirm<a class="indexterm" id="id165"/> the service replica count using docker service ls; the final result should be as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The WordPress web service should have two replica counts</li><li class="listitem" style="list-style-type: disc">The Postgres database service should have four replica counts</li></ul></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>In this lesson, we have done the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Talked about orchestration and mentioned a few example tools</li><li class="listitem" style="list-style-type: disc">Discussed clustering and why it's important, especially in production-level setups</li><li class="listitem" style="list-style-type: disc">Learned about virtual hosts by running Docker Machines on VirtualBox</li><li class="listitem" style="list-style-type: disc">Walked through Docker Swarm and how to create and manage a cluster of nodes</li><li class="listitem" style="list-style-type: disc">Introduced example services including Wordpress running on our swarm</li><li class="listitem" style="list-style-type: disc">Gained a high-level understanding of working with the <code class="literal">docker-machine cli</code></li><li class="listitem" style="list-style-type: disc">Talked about load balancing and how Docker Swarm manages this</li></ul></div><p>Congratulations for getting to the finish line! Here's a recap of the knowledge we have gained through the lessons.</p><p>In this book, we have covered the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Talked about DevOps and how Docker contributes to the workflow</li><li class="listitem" style="list-style-type: disc">Understood how to template applications on Dockerfiles</li><li class="listitem" style="list-style-type: disc">Built images and containers and pushed them to Docker Hub</li><li class="listitem" style="list-style-type: disc">Managed containers through <code class="literal">docker-compose</code></li><li class="listitem" style="list-style-type: disc">Learned how we can orchestrate our applications through Docker Swarm</li></ul></div></div></body></html>