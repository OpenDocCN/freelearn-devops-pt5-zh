- en: Chapter 10. Understanding VREFs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at VREFs briefly in [Chapter 7](ch07.html "Chapter 7. Advanced Access
    Control and Configuration"), *Advanced Access Control and Configuration*, including
    a small example to illustrate how Gitolite can allow or reject pushes based on
    which files have been modified in commits being pushed. In this chapter, we will
    explore VREFs in much greater detail, since this is one of the most powerful features
    of Gitolite. We will start small, describing the simplest use for VREFs, then
    move on to more complex uses.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating update hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some sites may already have been using update hooks in their existing (pre-Gitolite)
    repository setups. Since Gitolite reserves the update hook for itself, this presents
    a bit of a problem in terms of switching over.
  prefs: []
  type: TYPE_NORMAL
- en: If your site has such update hooks, the VREF mechanism can help replace them.
    Replacing update hooks is one of the simplest uses of VREFs, but understanding
    how that is done is also a good first step to understanding the full power of
    Gitolite's VREF mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: To convert your existing update hooks to VREFs, you first create a directory
    called VREF within `$HOME/local` (we're continuing the convention from [Chapter
    9](ch09.html "Chapter 9. Customizing Gitolite"), *Customizing Gitolite*, that
    the `LOCAL_CODE` variable in the `rc` file points here). Then, copy each unique
    update hook into this newly created directory, renaming each update hook in some
    way.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, say you had one repository that was frequently worked on by novice
    users using Windows, and so the update hook was used to make sure there were no
    line-ending problems. You might rename this to `check-crlf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for each repository that needs this check to be made (that is, each repository
    that had used that specific update hook in the pre-Gitolite setup), add a rule
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When Gitolite's update hook is processing a push, it will encounter this VREF
    rule and it will call the `check-crlf` program. The first three arguments passed
    are the same that Git itself has passed to the update hook, and if the program
    exits with a non-zero exit code, Gitolite will reject the push. No changes to
    the `check-crlf` code are needed to make all this happen; it just works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Astute readers will have noticed that they could, instead of the rule shown
    above, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This helps to limit the checking to only those users named in the rule. *In
    other words, Gitolite allows a plain old update hook to be selectively applied*,
    which could be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to the VREF code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let us suppose we had an update hook (in our pre-Gitolite setup) that prevented
    certain users from making changes to certain files. One way would be to write
    an update hook that checks for such files and use it as a VREF, as shown in the
    previous section. However, the list or pattern of files to be checked will need
    to somehow be encoded within the VREF code, or some other method of passing that
    information needs to be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitolite allows you to pass additional arguments to the VREF code. Let''s say
    the VREF used is called `NAME`, then instead of merely saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'and making sure that the code for the `NAME` VREF knows which files we are
    talking about, you can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see how this becomes really useful if you later find that another group
    of users needs to be restricted in a similar way, but for a different set of files.
    Let''s say we have a set of technical writers who are working on the documentation;
    there''s no reason for them to be touching the files that make up the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the VREF code is now not quite the same as it was when it was an
    update hook. Apart from the first three arguments (which are the same as those
    listed in man githooks for the `update` hook), there are now several other arguments,
    and the file patterns we just added are one of those (specifically, the eighth
    argument). The VREF code must get that pattern out of the incoming arguments and
    use it to decide whether the push is to be allowed or denied.
  prefs: []
  type: TYPE_NORMAL
- en: Using the permission field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us say we have several different kinds of source code files, and listing
    all of them in the rule for the technical writer is not only cumbersome, but error
    prone because we might miss something. We do know, however, that technical writers
    only work on documents, so we'd prefer to simply restrict them to `*.odt` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have considered the `NAME` VREF to behave in a certain way: receive
    a filename pattern, and if any file has been changed (in the push) that matches
    that pattern, exit with a non-zero return code to signal Gitolite to reject the
    push. As you can see, this behavior completely ignores the permission field; that
    is, even this rule would have the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we need is a way to consider the permission field as well. Our first impulse
    might be to develop some way to pass this field to the VREF code, perhaps with
    some new syntax, and let the VREF code reverse the check when required.
  prefs: []
  type: TYPE_NORMAL
- en: However, this complicates the VREF code, while at the same time not making use
    of Gitolite's rule processing logic.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite processes access control rules based on matching a *ref* (typically
    something like `refs/heads/master or refs/tags/v1.0`) against each rule in turn.
    So one way to make use of this is to not have the VREF code actually make a decision,
    but merely *output something* that Gitolite can capture and run through its access
    control rules, just like a normal *ref* would be.
  prefs: []
  type: TYPE_NORMAL
- en: You could call this a *virtual ref*, too!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us briefly recap the terminology, a VREF is the code that runs, and a virtual
    ref is what it might send back to Gitolite.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining the update hook function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, we do not want to affect the behavior of a standard (Git) update hook
    when used as a VREF, as described earlier in this chapter. This is easy enough—Gitolite
    treats any lines in the VREF's output as virtual refs only if they start with
    `VREF/`, and even that only if the VREF has exited with zero status.
  prefs: []
  type: TYPE_NORMAL
- en: Default is success
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we need to change the `NAME` VREF. Instead of making a decision,
    it should merely print all the files that have been changed, each prefixed with
    `VREF/NAME/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that is done, it might then seem that the following rule is all we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, that's not quite the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: There's a slight difference in how virtual refs are treated compared to real
    refs. With real refs, if no access rule matches the ref (and the user, and the
    actual type of write), the default is to reject the push.
  prefs: []
  type: TYPE_NORMAL
- en: However, virtual refs are designed as *additional* rules, adding checks that
    the normal Gitolite access rules cannot. Thus it makes more sense that if no VREFs
    match, it should be as if no additional checks *apply* to this push, and so the
    default is to *allow* the push.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we need one more rule, which brings our final ruleset to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Loosely speaking, what this does is, for each file that has been changed, generate
    a virtual ref by prefixing `VREF/NAME/` to it, and passing that virtual ref through
    the ruleset. The rest is obvious, for example, changing a file called `foo.c`
    creates a virtual ref called `VREF/NAME/foo.c`, which will match only the second
    rule and this push gets denied. Files whose names end in `.odt` will match the
    first rule and not cause a reject.
  prefs: []
  type: TYPE_NORMAL
- en: Example VREFs and their usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Gitolite source tree comes with a few VREFs ready to be used. To use them,
    you simply add rules similar to the ones we saw at the end of the previous section.
    We will look at a couple of them to get a feel for how they are used, and then
    design one from scratch so we know how to add our own.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look in the Gitolite source tree, you won't actually find a VREF called
    `NAME`. This is because `NAME` is special and the code for that is built in to
    Gitolite.
  prefs: []
  type: TYPE_NORMAL
- en: Newcomers to Git may sometimes end up creating a commit that changes a lot more
    files than are strictly necessary for the change being made. Perhaps they added
    debugging statements to some other files, or perhaps they accidentally saved some
    files with a different line-ending (Unix LF versus Windows CRLF), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are sure that your new developers are given relatively simple tasks,
    and at no time should any particular task touch more than, say, five files, you
    can use the `COUNT` VREF to prevent them from pushing more, and thus protect the
    repository from wide-ranging changes of the kind discussed in the previous paragraph.
    Here''s a rule that achieves that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `COUNT` VREF essentially counts all the files changed in the commits that
    constitute the current push (and do not exist on any other branch or tag).
  prefs: []
  type: TYPE_NORMAL
- en: If that last bit sounds complicated, consider what happens when a developer
    merely makes a new branch out of an existing one and pushes it. We don't want
    the `COUNT` VREF to basically see all the files in the branch as changed, simply
    because the old value of the branch pushed was empty. This is why the `COUNT`
    code looks at commits that do not appear in any other ref.
  prefs: []
  type: TYPE_NORMAL
- en: The `MAX_NEWBIN_SIZE` VREF is similar in concept. This addresses the issue that
    sometimes developers unintentionally or unknowingly commit, say, a JAR file or
    the executable file produced by a build step. Executable files like this tend
    to be a bit larger than normal source files, so if you have some idea of a reasonable
    limit, you can use this VREF to enforce it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own VREF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's an example use case where VREFs come in handy. We'll use this to design
    a very simple VREF, in a way that cannot be done with the existing rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement is simple: for any repository `foo`, if a repository called
    `l10n` contains a directory called `foo`, then you cannot push any files called
    `*.po` to `foo`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This has been adapted from a more complex, real-life use case, but for our purposes
    we don't need more than this. As you might guess, this is a multi-repository system
    that is gradually moving toward centralizing the local language files so that
    translators only have to deal with one repository. Each repository's local language
    files are moved over when they are deemed ready and from that point on, localization
    files must go to the single repository that was created for the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a very specific use case, we can write a simple VREF that does
    not take any arguments. Our rule can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're applying this rule to all repositories. (This is slightly
    inefficient if you have several repositories for which this will never be true—the
    VREF will be invoked for each of them, on every push. If so, replace `@all` in
    the `repo` line with a group name that contains only those repositories for which
    this check is required)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There may be individual rules for each of those repositories elsewhere—we need
    not put this VREF rule in each repository section. This is an example of the *Rule
    Accumulation and Delegation*, discussed in [Chapter 6](ch06.html "Chapter 6. Getting
    Started with Access Control"), *Getting Started with Access Control* in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one way to code this VREF (some familiarity with basic shell syntax
    and Git concepts is required to understand this code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first check uses the git diff command to check whether this
    push has changed any `po` files. If not, there's nothing to check and we exit
    without doing anything. The second check moves to the `l10n` repository, then
    runs an `ls-tree` on that repository to check whether it contains a file or directory
    whose name is the same as the repository that the user is pushing. If it does
    not, we can exit without complaint.
  prefs: []
  type: TYPE_NORMAL
- en: If those two checks succeed, we need to signal the error. One way would be to
    simply `exit 1`; Gitolite would catch the VREF code dying and reject the push.
    On the other hand, we could print the refex itself (which in this case is just
    `VREF/l10n`, but it's a good habit to use the argument instead). It will then
    match the access rule we set up, and because the permission is "-", the push will
    be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the VREF feature offers a little more. If, after the refex, you print a
    space and then some explanatory message, this message will be printed when the
    push is rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you write VREFs to catch rarely occurring conditions, then you may find it
    useful to augment Gitolite's rather spartan error reporting with something in
    plain English, so your users can scratch their heads a little less!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored one of Gitolite's most powerful features—the ability
    to use arbitrary external factors for access control decisions by writing VREFs.
    The next chapter will conclude our exploration of Gitolite by talking about mirroring—a
    feature which large multi-site setups could find very useful.
  prefs: []
  type: TYPE_NORMAL
