- en: Chapter 5. Building Your Own Plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with providing the core tools, Docker also documents an API that allows
    the core Docker engine to talk to the plugin services written by third-party developers.
    At the moment, this API allows you to hook your own storage and networking engines
    into Docker.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like it is limiting you to a very niche set of plugins, and it
    is. However, there is a good reason that Docker has taken this decision.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at some of the plugins that we have already installed in the
    previous chapters; however, rather than covering the functionality, we will take
    a look at what goes on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first page about plugins on the Docker documentation site lists a lot of
    third-party plugins. As already mentioned, let's get an idea of what's going on
    in the background of the plugins that we have already installed and used in [Chapter
    3](ch03.html "Chapter 3. Volume Plugins"), *Volume Plugins*, and [Chapter 4](ch04.html
    "Chapter 4. Network Plugins"), *Network Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: Convoy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Convoy was the first third-party plugin we looked at in [Chapter 3](ch03.html
    "Chapter 3. Volume Plugins"), *Volume Plugins*. To install it, we launched a Docker
    host in DigitalOcean as we needed a more complete underlying operating system
    than is provided by the Boot2Docker operating system, which is favored by Docker
    Machine.
  prefs: []
  type: TYPE_NORMAL
- en: To install Convoy, we downloaded a release file from GitHub. This tar archive
    contained the static binaries required to run Convoy on a Linux system, once the
    static binaries were in place, we created a Docker plugin folder and then added
    a symbolic link to the socket file that Convoy creates when it is first executed.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to configure a loopback device that we created on a volume.
    We then instructed Convoy to use the newly created volume by launching Convoy
    as a daemon using the Convoy static binary that we downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In multitasking computer operating systems, a daemon is a computer program
    that runs as a background process, rather than being under the direct control
    of an interactive user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Daemon(computing)](https://en.wikipedia.org/wiki/Daemon(computing)).'
  prefs: []
  type: TYPE_NORMAL
- en: As far as Docker is concerned, for each request it gets when the `--volume-driver=convoy`
    flag is used to launch a container, it will simply offload anything to do with
    volume the daemonized Convoy process.
  prefs: []
  type: TYPE_NORMAL
- en: If you review the *Convoy* section of [Chapter 3](ch03.html "Chapter 3. Volume
    Plugins"), *Volume Plugins*, you will notice that all of our interaction with
    Convoy is using the `convoy` command and not the `docker` one, in fact, the Convoy
    client is using the same socket file as we symbolically linked to the `Docker
    plugins` folder.
  prefs: []
  type: TYPE_NORMAL
- en: REX-Ray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next up, we installed REX-Ray. To do this, we ran a command, which downloaded
    and executed a bash script from [https://dl.bintray.com/emccode/rexray/install](https://dl.bintray.com/emccode/rexray/install).
  prefs: []
  type: TYPE_NORMAL
- en: This script works out the operating system you are running and then downloads
    and installs either the DEB or RPM file. These packages, as you may have already
    guessed, install the correct static binaries for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: REX-Ray goes one step further by also installing init, upstart, or systemd service
    scripts for the daemon, meaning that you can start and stop it as you would with
    any other services on your Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Again, once we have installed REX-Ray, the only interaction we had with the
    tool is by using the `rexray` command.
  prefs: []
  type: TYPE_NORMAL
- en: Flocker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flocker went one step further, rather than installing an installation script,
    we used the AWS CloudFormation templates supplied by Cluster HQ to bootstrap the
    environment for us.
  prefs: []
  type: TYPE_NORMAL
- en: This did the obvious task of launching the Docker host, setting up the security
    groups, and installing and configuring both Docker and Flocker.
  prefs: []
  type: TYPE_NORMAL
- en: Flocker goes one step further than Convoy and REX-Ray by installing an agent
    that interacts with the remotely-hosted web API, the volume hub.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as mentioned in this chapter, Flocker existed before the concept of volume
    plugins existed. So again, a lot of interaction with Flocker is done outside of
    Docker; in fact, Cluster HQ wrote their own wrapper for Docker so that you could
    easily create Flocker volumes before the option existed within Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Weave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was the only third-party network plugin we looked at. Like Flocker, Weave
    existed before Docker launched its plugin functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Weave is slightly different from the other third-party tools that we have looked
    at. In this, what is downloaded is actually a bash script rather than a static
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script is used to configure the host and download containers from the Weaveworks
    Docker Hub account, which can be found at [https://hub.docker.com/u/weaveworks/](https://hub.docker.com/u/weaveworks/).
  prefs: []
  type: TYPE_NORMAL
- en: The script launches and configures the containers with enough permissions to
    interact with the host machine. The script is also responsible for sending commands
    via the `docker exec` command to the running containers and also configure `iptables`
    on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: The commonalities among the plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, and as you have experienced, all of these plugins have scripts
    and binaries that are external to Docker itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are also pretty much all written in the same language as Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plugin | Language |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Convoy | Go |'
  prefs: []
  type: TYPE_TB
- en: '| REX-Ray | Go |'
  prefs: []
  type: TYPE_TB
- en: '| Flocker | Python |'
  prefs: []
  type: TYPE_TB
- en: '| Weave | Go |'
  prefs: []
  type: TYPE_TB
- en: 'Majority of the services are written in Go, the only exception is Flocker,
    which is mostly written in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Go is expressive, concise, clean, and efficient. Its concurrency mechanisms
    make it easy to write programs that get the most out of multicore and networked
    machines, while its novel type system enables flexible and modular program construction.
    Go compiles quickly to machine code yet has the convenience of garbage collection
    and the power of run-time reflection. It''s a fast, statically typed, compiled
    language that feels like a dynamically typed, interpreted language. [https://golang.org/](https://golang.org/).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understanding a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have established that all the plugins that we have installed have
    actually nothing to do with Docker directly, so what does a plugin do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker describes a plugin as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Docker plugins are out-of-process extensions which add capabilities to the
    Docker Engine."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is exactly what we have seen when installing third-party tools, they all
    run alongside Docker as separate daemons.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we are going to be creating a volume plugin called `mobyfs`
    for the remainder of this chapter. The mobyfs plugin is a fictional service which
    is written in Go and it runs as a daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, a plugin will be installed on the same host as the Docker binary.
    We can register our mobyfs plugin with Docker by creating the following files
    in either `/run/docker/plugins` if it''s a Unix socket file, or `/etc/docker/plugins`
    or `/usr/lib/docker/plugins` if it is one of the other two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mobyfs.sock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobyfs.spec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobyfs.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins that use a Unix socket file must run on the same hosts as your Docker
    installation. Ones which use either a `.spec` or `.json` file can run on external
    hosts if your daemon supports TCP connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were using a .spec file, your file would just contain a single URL to
    either a TCP host and port or local socket file. Any of the following three examples
    are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to use a `.json` file, it must look something similar to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `TLSConfig` section of the JSON file is optional; however, if you are running
    your service on host other than your Docker host, I would recommend using HTTPS
    for communication between Docker and your plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Startup order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ideally, your plugin service should be started before Docker. If you are running
    a host, which has `systemd` installed, this can be achieved by using a `systemd`
    service file similar to the following one, which should be called `mobyfs.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your plugin service is always started before the main
    Docker service.
  prefs: []
  type: TYPE_NORMAL
- en: If you are hosting your Plugin service on an external host, you may have to
    restart Docker for Docker to start communicating with your plugin service.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to package your plugin inside a container. To get around Docker
    having to be started before the plugin service, each activation request will retry
    several times over 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: This will give the container enough time to start and to run the plugin service
    run though any bootstrapping processes before binding itself to a port on the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Activation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the plugin service has started, and we need to let Docker know where
    it should send requests to if the plugin service is called. According to our example,
    service is a volume plugin and we should run something similar to the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will mount the `volumename` volume, which we have already configured in
    our plugin service to `/data` in a container, which runs my base container image
    and attaches us to a shell.
  prefs: []
  type: TYPE_NORMAL
- en: When the mobyfs volume driver is called, Docker will search through the three
    plugin directories that we covered in the *Discovery* section. By default, Docker
    will always look for a socket file, then either a `.spec` or `.json` file. The
    plugin name must match the filename in front of the file extension. If it is doesn't,
    the plugin will not be recognized by Docker.
  prefs: []
  type: TYPE_NORMAL
- en: API calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the plugin has been called, the Docker daemon will make a post request
    using RPC-style JSON over HTTP to the plugin service using either the socket file
    or the URL defined in the `.spec` or `.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: This means that your plugin service must implement an HTTP server and bind itself
    to the socket or port that you defined in the Discovery section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first request that is made by Docker will be to `/Plugin.Activate`. Your
    plugin service must respond to one of three responses. As mobyfs is a volume plugin,
    the response would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If it was a network driver, then the response our plugin service should give
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final response of plugin service is as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Any other responses will be rejected and the activation will fail. Now that
    Docker has activated the plugin, it will continue to make post requests to the
    plugin service depending on the response it got when calling `/Plugin.Activate`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your plugin service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, Docker will interact with your plugin
    service by making HTTP calls. These calls are documented on the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume** **Driver Plugins**: [https://docs.docker.com/engine/extend/plugins_volume/](https://docs.docker.com/engine/extend/plugins_volume/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network** **Driver Plugins**: [https://docs.docker.com/engine/extend/plugins_network/](https://docs.docker.com/engine/extend/plugins_network/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization** **Plugins**: [https://docs.docker.com/engine/extend/plugins_authorization/](https://docs.docker.com/engine/extend/plugins_authorization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker also provides an SDK as a collection for Go helpers, these can be found
    at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/docker/go-plugins-helpers](https://github.com/docker/go-plugins-helpers)'
  prefs: []
  type: TYPE_NORMAL
- en: Each helper comes with examples, as well as links to open source projects, which
    serve as further examples on how to implement the helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'These API requests should not be confused with the Docker Remote API, which
    is documented at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/reference/api/docker_remote_api/](https://docs.docker.com/engine/reference/api/docker_remote_api/)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the API, which allows your applications to interact with Docker, and
    not Docker to interact with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, we only discussed how Docker will interact with the plugin service
    that you have written and didn't cover how you can actually write a plugin service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that due to the plugin service that we would have had
    to cover, we would also need the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: To be written in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able run as a daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To contain an HTTP server bound to a Unix socket or TCP port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to accept and answer requests made to it by the Docker daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To translate the API requests that Docker is making to a filesystem or network
    service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can imagine, this has the potential of being an entire book by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Also, building your own plugin is quite an undertaking as you already have to
    have the foundations of a service written. While it seems like there are a lot
    of Docker plugins out there, searching GitHub for Docker plugins only returns
    a few dozen plugins that have been written to use the Docker plugin API.
  prefs: []
  type: TYPE_NORMAL
- en: The other projects returned are all tools or plugins for third-party services
    (such as Jenkins, Maven, and so on) that communicate with the Docker Remote API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at third-party tools to extend your
    infrastructure past using Docker Machine.
  prefs: []
  type: TYPE_NORMAL
