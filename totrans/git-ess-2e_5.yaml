- en: Obtaining the Most - Good Commits and Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have acquired some familiarity with Git and versioning systems,
    it's time to look at the whole thing from a much higher perspective, to become
    aware of common patterns and procedures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will walk through some of the most common ways to organize
    and build meaningful commits and repositories, obtaining not only a well-organized
    code stack, but even a meaningful source of information.
  prefs: []
  type: TYPE_NORMAL
- en: The art of committing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with Git, committing seems the easiest part of the job: you add
    files, write a short comment, and then you''re done. But it is just for its simplicity
    that often, especially at the very beginning of your experience, you acquire the
    bad habit of doing terrible commits: too late, too big, too short, or simply equipped
    with bad messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will take some time to identify possible issues, like unmeaning or too
    large commits, drawing attention to tips and hints to get rid of those bad habits.
  prefs: []
  type: TYPE_NORMAL
- en: Building the right commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the harder skills to acquire while programming in general is to **split
    the work into small and meaningful tasks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Too often, I have experienced this scenario: you start to fix a small issue
    in a file; then you see another piece of code that can be easily improved, even
    if it''s not related to what you are working on now - you can''t resist, and you
    fix it. At the end, and after some time, you find yourself with a ton of **concurrent**
    files and **changes** to commit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, *things get worse*, because usually *programmers are lazy people*,
    so they don''t write all the important things to describe changes in the commit
    message. In commit messages, you start to write sentences like "*Some fixes to
    this and that*", "*Removed old stuff*", "*Tweaks*" and so on, without anything
    that helps other programmers to understand what you have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50475693-9b9d-4707-95e2-1c09c796c2a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of http://xkcd.com/1296/
  prefs: []
  type: TYPE_NORMAL
- en: At the end, you realize *your repository is only a dump*, where you empty your
    index only now and then. I have seen some people committing only at the end of
    the day (and not every day), only to keep a backup of the data or because someone
    else needed the changes reflected on their computer.
  prefs: []
  type: TYPE_NORMAL
- en: Another side effect is that the resulting *repository history becomes useless*
    for anything other than retrieving the contents at a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: The following tips can help you turn your VCS from a backup system into *a valuable
    tool for communication and documentation*.
  prefs: []
  type: TYPE_NORMAL
- en: Making only one change per commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the routine morning coffee, you open your editor and then you start to
    work on a bug: `BUG42`. Working around fixing the bug in the code, you realize
    that fixing `BUG79` will require tweaking just a single line of code, so you fix
    it, but you not only change that awful class name, but also add a good-looking
    label to the form and make a few more changes. *The damage is done now*.'
  prefs: []
  type: TYPE_NORMAL
- en: How can you now wrap up all that work in a *meaningful commit*? Maybe in the
    meantime you went home for lunch, talked to your boss about another project, and
    even you can't remember exactly all the little things you did.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, there is only one way to **limit the damage**: *split files
    to commit in more than one commit*. Sometimes this helps to reduce the pain, but
    it is only a *palliative*: too often you modify the same file for *different reasons*,
    so doing that is quite difficult, if not impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: The only way to solve this problem completely is to **only make one change per
    commit**. It seems easy, I know, but is quite difficult to acquire this ability.
    There are no tools for it; no one but you can help, as it requires **discipline**,
    *the most lacking virtue in creative people* (like programmers).
  prefs: []
  type: TYPE_NORMAL
- en: There are some tips to pursue this aim; let's have a look at them together.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up features and tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As said before, breaking up things to do is a fine art. If you know and adopt
    some **Agile Movement** techniques, you have probably faced these problems already,
    so you have an advantage; otherwise you will need to make a little more effort,
    but it isn't anything you can't achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider you have been assigned to add the Remember Me check in the login page
    of a web application, like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af4909e1-428d-43b8-815d-65279b2b290a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This feature is quite small, but implies changes at different levels. To accomplish
    this, you''ll have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the UI to add the check control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the *is checked* information through different layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store this information somewhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve this information when needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invalidate (set it to false) following some kind of policy (after 15 days, after
    10 logins, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do you think you can do all these things in a shot? Yes? You are wrong! Even
    if you estimate a couple of hours for an ordinary task, remember that Murphy''s
    Law applies: you will receive four calls, your boss will look for you for three
    different meetings and your computer will go up in flames.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the first things to learn: **break up every piece of work into
    small tasks**. No matter if you use time-boxing techniques like the *Pomodoro
    Technique* or not, small things are easier to handle. I''m not talking about splitting
    hairs, but try to organize your tasks into things you can do in a defined amount
    of time, hopefully a bunch of half-hours, not days.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the Pomodoro Technique you can visit [https://cirillocompany.de/pages/pomodoro-technique](https://cirillocompany.de/pages/pomodoro-technique)
  prefs: []
  type: TYPE_NORMAL
- en: or Wikipedia [https://en.wikipedia.org/wiki/Pomodoro_Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *take paper and a pen and write down all the tasks*, as we did before with
    the login page example. Do you think now you can do all those things in a small
    amount of time? Maybe yes, maybe not: some tasks are bigger than others. That''s
    okay, this is not a scientific method, *it''s a matter of experience*; can you
    split a task, creating two other meaningful tasks? Do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you? No problem, *don't try to split tasks if they lose meaning*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a little notebook, like the one in the following picture - it will become
    one of your most precious tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b995efc5-b09e-48be-a21d-469d020de539.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing commit messages before starting to code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have a list of tasks to do; pick the first and... Start to code? No!
    Take another piece of paper and **describe every task's step with a sentence**;
    magically you will realize that every sentence can be the message of a single
    commit, where you describe features you deleted, added, or changed in your software.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of prior preparation helps you in *defining modifications to implement*
    (letting *better software design* emerge), *focusing on what matters,* and *lowering
    the stress* to think about the versioning part of the work during the coding session.
    While you are facing a programming problem, your brain floods with little implementation
    details related to the code you are working on, so the fewer distractions, the
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the best versioning related hints I ever received: if you have
    just quarter of an hour of spare time, I recommend reading the *Preemptive commit
    comments* blog post at [https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/](https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/)
    by *Arialdo Martini*, which is where I learnt this trick.'
  prefs: []
  type: TYPE_NORMAL
- en: Including the whole change in one commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making more than one change per commit is a bad thing, but even splitting a
    single change into more than one commit is considered harmful. As you may already
    know, in some trained teams you do not simply push your code to production; first
    you have to pass *code quality reviews*, where someone else tries to understand
    what you did to decide if your code is good or not (that is why there are *pull
    requests*, indeed). You can be the best developer in the world, but if the person
    at the other end can't get a sense of your commits, your work will probably be
    refused.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid these unpleasant situations, you have to follow a simple rule: **don''t
    do partial commits**. If time''s up, if you have to go to that damn meeting (programmers
    hate meetings) or whatever, remember that you can save your work at any moment
    without committing, using the `git stash` command. If you want to close the commit,
    because you want to push it to the remote branch for backup purposes, remember
    that *Git is not a backup tool*: backup your stash on another disk, put it in
    the cloud, or simply end your work before leaving, but don''t do commits like
    they are episodes of a TV series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more time, Git is a software tool like any other, and even it can fail:
    don''t think that by using Git or other versioning systems you don''t need backup
    strategies - backup local and remote repositories just the same as you backup
    all the other important things.'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the change, not what have you done
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Too often I read (and more often I wrote) commit messages like "*Removed this*",
    "*Changed that*", "*Added that one*" and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you are going to work on the common "*lost password*" feature on your
    website; you''ll probably find a message like this adequate: "*Added the lost
    password retrieval link to the login page*". This kind of commit message does
    not describe what modifications the feature brings to you, but what you did (and
    not everything you did). Try to answer sincerely: reading a repository history,
    do you want to read what every developer did? Or maybe it''s better to read the
    feature implemented in every single commit?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to make the effort, and **start writing sentences where the change itself
    is the subject**, not what you did to implement it. *Use the imperative present
    tense* (for example, *fix*, *add*, or *implement*), describing the change in a
    small subject sentence, and then add some details (when needed) in other lines
    of text; "*Implement the password retrieval mechanism*" is a good commit message
    subject; if you find it useful then you can add some other information to get
    a well-formed message, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you ever written a *changelog* for software by hand? I did, and it''s
    one of the most boring things to do. If you don''t like writing changelogs, like
    me, think of the repository history as your changelog: if you take the right care
    of your commit messages, you will get a beautiful changelog for free!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next paragraph, I will cover some other useful hints about good commit
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be afraid to commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fear is one of the most powerful of emotions; it can drive a person to do the
    craziest things on Earth. One of the most common reactions to fear is the **breakdown**:
    *you don''t know what to do, so you end up doing nothing*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a common reaction even when you begin to use a new tool like Git, where
    gaining confidence can be difficult; because of the fear of making a mistake,
    you don''t commit until you are obligated. **This is the real mistake: being scared**.
    In Git, you don''t have to be scared; maybe the solution is not obvious, and maybe
    you have to dig on the internet to find the right way, but you can get away with
    small or no consequences, ever (well, unless you are a hard user of the `--hard`
    option).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the contrary, you have to make the effort to **commit often**, as soon as
    possible. The more frequently you commit, the smaller your commits; the smaller
    your commits, the easier it is to read and understand the changelog, and the easier
    it is to cherry-pick commits, and do code reviews. To help myself get used to
    committing this way, I followed this simple trick: write the commit message in
    Visual Studio before starting to write any code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6d93f81-a85c-4a64-8b10-7a339797c513.png)'
  prefs: []
  type: TYPE_IMG
- en: Try to do the same in your IDE or directly in the Bash shell, it helps a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating meaningless commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The golden rule is to avoid them, but sometimes you need to commit *something
    that is not a real implementation*, but only a clean-up, like old comments deletion,
    formatting rearrangement, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, it is better to isolate these kind of code changes in separated
    commits. By doing this you prevent another team member from running towards you
    with a knife in his hand, frothing at the mouth. Don't commit meaningless changes,
    mixing them up with real ones, otherwise other developers (and you, after a couple
    of weeks) will not understand them while diffing.
  prefs: []
  type: TYPE_NORMAL
- en: The perfect commit message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me be honest: the perfect message does not exist. If you work alone, you
    probably find the best way for you, but when in a team there are different minds
    and different sensibilities, so what is good for me might not be as good for somebody
    else.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case you have to sit down around a table and make a retrospective, trying
    to end up with a shared standard; it may not be the one you prefer, but at least
    it's a way to find a common path.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for a good commit message really depend on the way you and your team work
    day by day, but some common hints can be applied by everyone; here they are.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a meaningful subject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The subject of a commit is the most important part: its role is to make clear
    what the commit contains. Avoid technical details of other things - a common developer
    can understand opening the code, and focus on the big picture: remember that every
    commit is a sentence on the repository history. So, wear the hat of the changelog
    reader and try to write the most convenient sentence for him, not for you: use
    present tense, and write a 50 chars max sentence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A good subject is one like this: "*Add the newsletter signup in homepage*".'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, I used the *imperative past tense* and, more importantly, *I
    didn''t say what I had done, but what the feature does*: it adds a newsletter
    signup box to my website.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 50-char rule is due to the way you use Git from the shell or GUI tools;
    if you start to write long sentences, reviewing logs and so on can become a nightmare.
    So, don''t try to be the *Stephen King* of commit messages: avoid adjectives and
    get straight to the point, you can then go more in-depth in the additional details
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing: start with capital letters, and do not end sentences with periods
    - they are useless, and even dangerous.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding bulleted details lines when needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often you can say all that you want in 50 chars; in that case, use details
    lines. In this situation, the common rule is to *leave a blank line after the
    subject*, use a dash and go no longer than 72 chars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In these lines go a little bit in depth, but not too much; try to describe the
    original problem (if you fixed it) or the original need, why this functionality
    has been implemented (what problem has been solved) and any possible limitations
    or known issues.
  prefs: []
  type: TYPE_NORMAL
- en: Tying other useful information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you use issue and project tracking systems, write down the issue number,
    bug id''s, or anything else helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Special messages for releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful thing is to write *special format* commit messages for releases,
    so it will be easier to find them. I usually decorate subjects with some special
    characters, but nothing more; for highlighting a particular commit, like a release
    one, there is the `git tag` command, remember?
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end, my suggestion is to try to compose your personal commit message
    standard, following previous hints and looking at message strategies adopted by
    great projects and teams around the web, but especially by doing it. Your standard
    will change for sure, as you evolve as a software developer and Git user, so start
    as soon as possible and let the time help you find the perfect way to write a
    commit message.
  prefs: []
  type: TYPE_NORMAL
- en: 'At least, don''t imitate this link: [http://www.commitlogsfromlastnight.com](http://www.commitlogsfromlastnight.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a workflow - a wise act
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we learnt how to perform good commits, it's time to fly higher and
    think of **workflows**. Git is a tool for versioning, but as with other powerful
    tools like knives, you can cut tasty sashimi or get hurt.
  prefs: []
  type: TYPE_NORMAL
- en: The thing that separates a great repository from a junkyard is the way you manage
    releases, the way you react when there is a bug to fix in particular version of
    your software, and the way you act when you have to make users able to beta-test
    incoming features.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of actions belong to ordinary administration for a modern software
    project, but too often I see teams out of breath because of the poor versioning
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: In this second part of the chapter, we will take a quick look at some of the
    most used workflows together with the Git versioning system.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we used to do in other VCS like Subversion or so, even in Git it is not uncommon
    to adopt a *centralized way of working*. If you work in a team, it is often necessary
    to share repositories with others, so a *common point of contact* becomes indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: We can assume that if you are not alone in your office, you will adopt one of
    the variations of this workflow. As we know, we can configure to get all the computers
    of our co-workers as remote, in a sort of *peer-to-peer* configuration, but you
    usually don't do this, because it quickly becomes too difficult to keep every
    branch in every remote in sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scenario is represented in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7029acee-f6e4-45e3-b620-d69820f66a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: How they work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this scenario, you usually follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Someone initializes the remote repository (in a local Git server, on GitHub,
    BitBucket, or so on)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other team members clone the original repository on their computer and start
    working
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the work is done, you push it to the remote to make it available to other
    colleagues
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, it is only a matter of internal rules and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Feature branch workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you will probably choose at least a *feature branch* approach,
    where every single developer works on his branch. When the work is done, the feature
    branch is ready to be merged onto the master branch; you will probably have to
    merge back from the `master` before, because one of your other colleagues has
    merged a feature branch after you started your one, but after that you basically
    have finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture represents the branches evolution within the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b537cf9-9883-4150-a33c-db9160770c74.png)'
  prefs: []
  type: TYPE_IMG
- en: Gitflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Gitflow** workflow comes from the mind of **Vincent Driessen**, a passionate
    software developer from the Netherlands; you can find his original blog post about
    it at [http://nvie.com/posts/a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model).
  prefs: []
  type: TYPE_NORMAL
- en: His workflow has gained success over the years, to the point that many other
    developers (including me!), teams, and companies are starting to use it. *Atlassian*,
    a well-known company that offers Git related services like *BitBucket*, integrates
    the Gitflow directly in their GUI tool, the nice *SourceTree*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the Gitflow work flow is a centralized one, and it is well described by
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80773189-8611-42ac-8788-9edd27562f0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This workflow is based on the use of some **main branches**; what makes these
    branches special is nothing other than the significance we attribute to them:
    there are no *special branches* with *special characteristics* in Git, but we
    can certainly use them for different purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Master branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Gitflow the `master` branch represents the final stage; merging your work
    in it is equal to making a *new release* of your software. You usually don't start
    new branches from the `master`; you do it only if there are severe bugs you have
    to fix instantly, even if that bug has been found and fixed in another evolving
    branch. This way of operating is superfast when you need to react to a painful
    situation. Other than that, the `master` branch is where you tag your release.
  prefs: []
  type: TYPE_NORMAL
- en: Hotfixes branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hotfixes branches** are branches derived only from the `master`, as we said
    before; once you have fixed a bug, you merge the `hotfix` branch onto the `master`,
    to enable you to get a new release to ship. If the bug has not been resolved anywhere
    else in your repository, the strategy is to merge the `hotfix` branch into the
    `develop` branch. After that, you can delete the `hotfix` branch, as it has hit
    the mark.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Git, there is *a trick to grouping similar branches*: you have to name them
    using a common prefix followed by a slash `/`; for the hotfix branches, the author
    recommends the `hotfix/<branchName>` prefix (for example `hotfix/LoginBug` or `hotfix/#123`
    for those using bug tracking systems, where `#123` is the bug ID).'
  prefs: []
  type: TYPE_NORMAL
- en: These branches are usually not pushed to remote; you push them only if you need
    the help of other team members.
  prefs: []
  type: TYPE_NORMAL
- en: The develop branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `develop` branch is a sort of *staging* branch. When you start to implement
    a new feature, you have to create a new branch starting from `develop`; you will
    continue to work in that branch until you complete your task.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the task completion, you can merge back to `develop` and delete your
    `feature` branch: as hotfix branches, these are only temporary branches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the master one, the `develop` branch is a **long living branch**: you
    will never close nor delete it.'
  prefs: []
  type: TYPE_NORMAL
- en: This branch is pushed and shared to a remote Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: The release branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, you need to wrap up the next release, including some of the features
    you implemented in the last few weeks. To prepare an incoming release you have
    to branch from `develop`, assigning the branch a name composed by the `release`
    prefix, followed by the numeric form of choice for your release (for example `release/1.0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention: **at this stage, no new feature is allowed**! You can no longer
    merge `develop` onto the `release` branch; you can create new branches from that
    branch only for bug-fixing; the purpose of this intermediate branch is to give
    the software to beta testers, allowing them to try it and send you feedback and
    bug tickets.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you have fixed some bug onto the `release` branch, the only thing to
    remember is to merge them into the `develop` branch, just to avoid the loss of
    the bug fix - the `release` branch will not be merged back to `develop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can keep this branch alive as long as you want, until you decide the software
    is both mature and tested sufficiently to go into production: at this point you
    merge the `release` branch onto the `master` branch, making a new release.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the merge to the `master` you have a choice: keep the `release` branch
    open, if you need to keep different releases alive, otherwise you can delete it.
    Personally, I always delete the `release` branch (as Vincent suggests), because
    I generally do frequent, small, and incremental releases (so I rarely need to
    fix an already shipped release) and because, as you certainly remember, you can
    open a brand-new branch from a commit (a tagged one in this case) whenever you
    want so, at the most, I will open it from that point only when necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: This branch is pushed and shared to a common remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: The feature branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have to start the implementation of a new feature, you have to create
    a new branch from the `develop` branch. Feature branches start with the `feature/`
    prefix (for example `feature/NewAuthenitcation` or `feature/#987` if you use some
    features tracking software, as `#987` is the feature ID).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will work on the feature release until you finish your work; I suggest
    you *frequently merge back* from `develop`: in case of concurrent modifications
    to the same files, you will resolve conflicts faster if you will resolve them
    earlier; then it is easier to resolve one or two conflicts at a time, rather than
    dozens at the end of the feature work.'
  prefs: []
  type: TYPE_NORMAL
- en: Once your work is done, you merge the feature onto `develop` and you are done;
    you can now delete the `feature` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Feature branches are mainly private branches, but you can push them to the remote
    repository in case you have to collaborate on it with some other team mates.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I really recommend taking a look at this workflow, as I can assure you there
    were no situations I have failed to solve using solve using it.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a deeper explanation, with Git commands ready to use, on **Vincent
    Driessen****'s** already cited blog. You can even use the *gitflow commands* Vincent
    made to customize his Git experience; check these out on his GitHub account at
    [https://github.com/nvie/gitflow](https://github.com/nvie/gitflow).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previously described *GitFlow* has tons of followers, but it's always a
    matter of taste; someone else found it too complex and rigid for their situation,
    and in fact there are other ways to manage software repositories that have gained
    consensus during the last few years.
  prefs: []
  type: TYPE_NORMAL
- en: One of these is the workflow used at GitHub for internal projects and repositories;
    this workflow takes the name of **GitHub flow** and it has been firstly described
    by the well-known **Scott Chacon**, former GitHubber and *ProGit* book author,
    on his blog at [http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html).
  prefs: []
  type: TYPE_NORMAL
- en: This workflow, compared to Gitflow, is better tailored for frequent releases,
    and when I say frequent, I mean very frequently, even twice a day. Obviously,
    this kind of flow works better on web projects, because to deploy you have to *only* put
    the new release on the production server; if you develop desktop solutions, you
    need a perfectly oiled update mechanism to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub software basically doesn't have releases, because they deploy to production
    regularly, even more than once a day. This is possible due to a robust *Continuous
    Delivery* structure, which is not so easy to obtain; it requires some effort.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub flow is based on these simple rules.
  prefs: []
  type: TYPE_NORMAL
- en: Anything in the master branch is deployable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to GitFlow, even here in GitHub flow, deploy is done from the `master`
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: This is the only *main* branch in this flow; in Gitflow there are no `hotfix`,
    `develop,` or other particular branches. Bug fixes, new implementations and so
    on are constantly merged onto the `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Other than this, code in the `master` branch is always in a *deployable* state;
    when you fix or add something new in a branch and then you merge it onto the `master`,
    you don't deploy automatically, but you can assume you changes will be up and
    running in a matter of hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Branching and merging constantly to the `master`, the production-ready branch,
    can be dangerous: you can easily introduce regressions or bugs, as no one other
    than you can check you have done a good job. This problem is avoided by a *social
    contract* commonly adopted by GitHub developers; in this contract, you promise
    to test your code before merging it to the `master`, assuring you that all automated
    tests have been successfully completed.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating descriptive branches off of master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In GitFlow you always branch from the `master`, so it's easy to get a forest
    of branches to look at when you have to pull one. To better identify them, in
    GitHub flow you have to use descriptive names to get meaningful *topic branches*.
    Even here it is a matter of good manners; if you start to create branches named
    *stuff-to-do* you will probably fail in adopting this flow. Some examples are
    `new-user-creation, most-starred-repositories,` and so on (note the use of the
    **Kebab Case**, [http://wiki.c2.com/?KebabCase](http://wiki.c2.com/?KebabCase));
    using a common way to define topics, you will easily find branches you are interested
    in by looking for topics' keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to named branches constantly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another great difference when comparing GitHub flow to Gitflow is that in GitHub
    flow you push feature branches to the remote regularly, even if you are the only
    developer involved and interested. This is done for continuous integration and
    testing, or maybe also for backup purposes; regarding the backup part, even if
    I already exposed my opinion in merit, I can't say this is a bad thing.
  prefs: []
  type: TYPE_NORMAL
- en: A thing I appreciate about Gitflow is that this habit of push every branch to
    the remote gives you the ability to see, with a simple `git fetch`, all the branches
    currently active, and so all the work in progress, even that of your team mates.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a pull request at any time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](20e98db3-d248-436e-88d5-069be7808998.xhtml), *Git Fundamentals
    - Working Remotely,* we talked about GitHub and made a quick try with *Pull Requests*.
    We have seen that basically they are for *contributing*: you fork someone else''s
    repository, create a new branch, make some modifications and then ask for a pull
    request from the original author.'
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub flow you use pull requests massively, even for asking another developer
    on your team to have a look at your work and help you, give you a hint, or review
    the work done. At this point you can start a discussion, using the GitHub pull
    request to chat and involving other people by putting in /CCing their username.
    In addition, the pull request feature lets you comment on even a single line of
    code in the diff view, making users involved able to discuss the work under revision.
  prefs: []
  type: TYPE_NORMAL
- en: Merging only after pull request review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can understand now that the *pull requested branch stage* we have seen above
    becomes a sort of *review stage*, where other users can take a look at the code
    and even simply leave a positive comment, just a `+1` to let other users know
    that they are confident about the job, and that they approve its merge into master.
  prefs: []
  type: TYPE_NORMAL
- en: After this step, when the CI server says the branch still passes all the automated
    tests, you are ready to merge the branch in `master`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying immediately after review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, you merge your branch into `master` and the work is done. The
    deploy is not instantly fired, but at GitHub they have a very straight and robust
    deployment procedure, so they can do that easily. They deploy big branches with
    50 commits but even branches with a single commit and a single line of code change,
    because deployment is very quick and cheap for them.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why they can afford such a simple branching strategy, where
    you put on `master` and then you deploy without the need for passing through `develop`
    or `release` stage branches like in GitFlow.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I consider this flow very responsive and effective for web based projects,
    where basically you deploy to production without much regard for the versions
    of your software. Using only the `master` branch to derive and integrate branches
    is faster than light, but this strategy can be applied only if you have these
    prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: A centralized remote ready to manage pull requests (as GitHub does)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good shared agreement about branch names and pull requests usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very robust deploy system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a big picture of this flow, graphically represented in the following
    image; for more details, I recommend visiting the GitHub related page at [https://guides.github.com/introduction/flow/index.html](https://guides.github.com/introduction/flow/index.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c32beb-274c-427c-b1c7-1f76312b4207.png)'
  prefs: []
  type: TYPE_IMG
- en: Trunk-based development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These days, another strategy has regained a certain popularity among developers
    all around the world; its name says it all: *stop using branches*, use only the
    *master branch*!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the picture below there''s the essence of this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c32367b-6f99-4206-8add-3521d03c716a.png)'
  prefs: []
  type: TYPE_IMG
- en: This trend aims to fight the so called *merge hell*; this happens when branches
    diverge for too long, so merging them is a pain. Similar to the GitHub flow, here
    there aren't long living branches, but even feature branches are discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration and Continuous Delivery are under the light here, and
    this way of working really enforces these good practices we already know thanks
    to the **eXtreme Programming** ([http://www.extremeprogramming.org/](http://www.extremeprogramming.org/))
    mindset and practices.
  prefs: []
  type: TYPE_NORMAL
- en: This movement is too wide and deep to be discussed here in a couple of sentences,
    but it's worth reading its principles, as it makes you reflect on the topics a
    developer faces during his day by day work. So please take a minute and read more
    about it at [trunkbaseddevelopment.com](http://trunkbaseddevelopment.com).
  prefs: []
  type: TYPE_NORMAL
- en: Other workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, there are many other workflows; I will spend just a moment on the
    one that (fortunately!) convinced Linus Torvalds to realize the Git VCS.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Linux kernel** uses a workflow that refers to the traditional way **Linus
    Torvalds** has driven its evolution during these years, based on a *military like
    hierarchy*.
  prefs: []
  type: TYPE_NORMAL
- en: Simple kernel developers work on their personal branches, rebasing the master
    branch on the reference repository, then push their branches to the *lieutenant
    developers *`master` branch. Lieutenants are developers that Linus assigned to
    particular topics and areas of the kernel because of their experience. When a
    lieutenant has his work done, he pushes it to the *benevolent dictator *`master`
    branch (Linus branch) and then if things are okay (it is not simple to cheat him),
    Linus pushes his master branch onto the *blessed repository*, the one the developers
    use to rebase from before starting their work.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of workflow is not usual; Linus and the Linux kernel bandwagon crafted
    it as it exactly reflected the way they used to work on projects since the beginning,
    when developers used patches and email to forward their work to Linus Torvalds.
  prefs: []
  type: TYPE_NORMAL
- en: Having millions of lines of code to manage, and thousands of contributors, I
    find this hierarchy model to be a good compromise in terms of working scope, responsibility,
    and patches skimming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture helps you better understand this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c336cf95-489a-415a-9efb-e0b763a79950.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we became aware of effective ways to use Git; I personally
    consider this chapter the most important for the *new Git user*, because it is
    only by applying some rules and discipline that you will obtain the most from
    this tool. So please pick up a good workflow (make your own, if necessary!), and
    pay attention to your commits: this is the only way to become a good versioning
    tool user, not only in Git.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see some tips and tricks for using Git even if
    you have to deal with Subversion servers, and then we will take a quick look at
    migrating definitely from Subversion to Git.
  prefs: []
  type: TYPE_NORMAL
