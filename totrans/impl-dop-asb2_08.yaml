- en: Ansible Modules and Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides integration and compatibility for hundreds of open and closed
    source software solutions. This integration opens the door for Ansible to communicate
    at a programmatic API level with a multitude of build, test, project management,
    cloud, and delivery software solutions. The module implementation, as a result,
    provides Ansible with a huge edge against competing automation and configuration
    management solutions on the market.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, we should be fairly well educated about some of the
    more common playbook implementations and structured approaches to leverage Ansible.
    To expand our knowledge further, this chapter will focus on the wide array of
    modules provided by the Ansible core implementation. Modules in Ansible provide
    the ability for playbooks to connect to and control third-party technologies (some
    open source, some closed source). In this chapter, we will discuss the most popular
    ones and dive into creating playbook tasks that help manage a suite of tools and
    services available to developers, testers, and operators.
  prefs: []
  type: TYPE_NORMAL
- en: To further our learning, in this chapter, we will take a look at the integration
    that Ansible provides with other software solutions. As we take a journey through
    this chapter, and will learn about some of the more popular integration points
    available within the Ansible realm. We will discover how Ansible's modular architecture
    works and learn how it provides hooks for integration with other technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will specifically cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ansible modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Ansible with other technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the integration options available within the Ansible documentation
    for various technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step-by-step examples of integrating Ansible with other technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ansible Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible modules represent the preferred way of connecting Ansible (and automating)
    with other software solutions. At the time of writing of this book, Ansible has
    the ability to integrate with a multitude of external software and hardware solutions.
    Some of the more obvious integrations we have already discovered include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux (OS and packages)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These basic modules that we have discussed so far are obvious for introductory
    playbook creation and management, but did you know that Ansible integrates with
    JIRA, Slack, Git, Artifactory, Jenkins, and *much much* more. Ansible module''s
    exhaustive integration has been broken down within the Ansible documentation into
    the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crypto modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Net tools modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote management modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web infrastructure modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the preceding list, Ansible provides a vast expanse of integrations
    with other technologies. Each integration point with another technology is leveraged
    via an Ansible playbook task. The complete documentation of each integration module
    can be found at [http://docs.ansible.com/ansible/modules_by_category.html](http://docs.ansible.com/ansible/modules_by_category.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible divides the module implementation into a few distinct categories: the
    Core, Community, Curated module set, and Custom modules, and plugins. Each is
    implemented in a very similar way but is organized by Ansible slightly differently.
    The diagram provided next shows where the Ansible module implementation sits within
    the Ansible architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a33f873b-f433-42bb-ab17-729ab03f683d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapters of this book, we have been using Ansible modules for
    basic system-level configurations, package management, file operations, and more.
    These implementations have taught us how to make use of the core Ansible module
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible implementation has three different module types. These module types
    are Core, Curated, Community, and Custom. Each of these modules have their own
    specific function and role within the Ansible solution. Let''s take a minute to
    look at what the Ansible documentation has to say about these different module
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core**: These are modules that the core ansible team maintains and will always
    ship with ansible itself. They will also receive slightly higher priority for
    all requests. Non-core modules are still fully usable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curated**: Some examples of Curated modules are submitted by other companies
    or maintained by the community. Maintainers of these types of modules must watch
    for any issues reported or pull requests raised against the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Committers will review all modules becoming Curated. Core Committers will
    review proposed changes to existing Curated modules once the community maintainers
    of the module have approved the changes. Core committers will also ensure that
    any issues that arise due to Ansible engine changes will be remediated. Also,
    it is strongly recommended (but not presently required) for these types of modules
    to have unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: These modules are currently shipped with Ansible, but might be shipped separately
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**Community**: These modules are not supported by Core Committers or by companies/partners
    associated to the module. They are maintained by the community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are still fully usable, but the response rate to issues is purely up to
    the community. Best effort support will be provided but is not covered under any
    support contracts.
  prefs: []
  type: TYPE_NORMAL
- en: These modules are currently shipped with Ansible, but will most likely be shipped
    separately in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the Ansible world, Ansible modules are also referred to as **task-plugins**
    or **library-plugins**, thus describing the way Ansible handles module implementations.
    Each module (Core or otherwise) is manifested via the pluggable architecture that
    is Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Within the context of an Ansible, modules offer a similar functionality to programming
    libraries. These libraries can be invoked via a playbook task *or* a direct single
    command-line operation. Let's take a quick look at each of these two implementation
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call an Ansible module from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call an Ansible module from a playbook task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding examples, we can see two distinct implementations of Ansible
    modules. Now that we can see how Ansible modules are executed (for system calls),
    let's take a look at how Ansible modules can provide connectivity solutions for
    other technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Ansible with Other Technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible integrates quite nicely with other technologies. The implementation
    of the module system provides us with a set of unique hooks that we can leverage
    to connect Ansible (on an API level) with popular software solutions. In this
    section of implementing Ansible with DevOps, we will take a closer look at how
    to actually use Ansible to connect with some of the more popular technology solutions
    available to DevOps-minded individuals.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible with JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides us with a handy set of built-in tasks that can be used to
    *create* tickets. For those of you unfamiliar with JIRA, it is a widely used ticketing
    system created and maintained by Atlassian ([http://www.atlassian.com](http://www.atlassian.com)).
    In this section, we will take a look at how to create and manipulate JIRA tickets
    using Ansible. The general implementation uses the JIRA module provided by Ansible.
    The following is an example of how to create a ticket using an Ansible task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding implementation uses Jinja to supply the module with
    a JIRA username and password. This might be best implemented using Ansible vault
    (which we just discovered in the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond simple ticket creation, Ansible can also be used to modify existing
    tickets. Let''s take a look at an example of that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: "For a complete documentation set of how to manipulate Jira tickets using Ansible,\
    \ visit [http://docs.ansible.com/ansible/jira_module.html#synopsis](http://docs.ansible.com/ansible/jira_module.html#synopsis).[\uFEFF\
    ](http://docs.ansible.com/ansible/jira_module.html#synopsis)"
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a complete module to manipulate Git repositories. For those
    unfamiliar with Git, Git is a modern distributed source control solution currently
    in use by a significant number of software organizations. Unlike traditional server/client-oriented
    source control solutions, Git provides a nifty distributed solution, which does
    not require a central server. Ansible's integration with Git is fairly robust.
    It provides a complete set of integration tasks. The complete documentation for
    the Ansible Git module can be found at [http://docs.ansible.com/ansible/git_module.html](http://docs.ansible.com/ansible/git_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some example playbook tasks and see how we can integrate
    Ansible and Git.
  prefs: []
  type: TYPE_NORMAL
- en: One prerequisite for Ansible's Git integration is that the target machine should
    have Git v1.7 or a higher command-line client installed and working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example Git checkout task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example where we''ll be creating ZIP file from the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ansible and Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins CI (Open sourced by CloudBees) is a modern day Continuous Integration
    and Continuous Delivery solution. It is widely leveraged by organizations of all
    sizes and supports simple automation as well as complex build and delivery pipeline
    implementations. It has a massive
  prefs: []
  type: TYPE_NORMAL
- en: Ansible integrates with Jenkins in a few different ways. For the purpose of
    this chapter, the one we will talk about is the module-specific integration point.
    That is, we will be automating the control of Jenkins itself using Ansible. In
    this section, you will learn about some interesting ways in which you can use
    Ansible to control and manage the Jenkins instance via Ansible. The complete documentation
    for the Ansible Jenkins module can be found at [http://docs.ansible.com/ansible/jenkins_job_module.html](http://docs.ansible.com/ansible/jenkins_job_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible communicates with Jenkins over the Jenkins REST API. So it is important
    that the Jenkins instance have the REST API available and can be reached from
    the target server that will be connecting to the REST API. In addition to the
    REST API availability, the Ansible Jenkins module requires the following Python
    packages to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Python-Jenkins 0.4.12 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lxml 3.3.3 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These packages are required because they provide direct API connectivity to
    Jenkins from Python. This is something Ansible has no direct connection to and
    as such they are required to use this specific module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the prerequisites taken care of, let''s look at some examples
    of Ansible tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to creating jobs based on templates, we can also delete jobs. The
    following example shows how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For a complete Jenkins REST API documentation, check out the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.cloudbees.com/blog/taming-jenkins-json-api-depth-and-tree](https://www.cloudbees.com/blog/taming-jenkins-json-api-depth-and-tree)'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker has become a powerhouse in the virtualization space within the last few
    years. Docker has a unique kernel, filesystem, and memory management solution,
    which makes Docker an ideal choice in virtualization for many organizations. Docker
    operates under the concept of container-based visualizations, which are lightweight
    virtualized operating systems. In this section, we will look at how Ansible integrates
    with Docker. We will discover how to control Docker containers using Ansible 2\.
    The complete Ansible Docker module reference can be found at [http://docs.ansible.com/ansible/docker_module.html](http://docs.ansible.com/ansible/docker_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of the Docker Ansible module, the following Python packages
    must be installed on the target system (the system running the playbook):'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.6 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker-py 0.3.0 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker server 0.10.0 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible provides a number of docker-oriented modules, which provides interconnectivity
    with Ansible and Docker. The complete list and descriptions of each is provided
    as follows ([https://docs.ansible.com/ansible/guide_docker.html](https://docs.ansible.com/ansible/guide_docker.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker_service`: Use your existing Docker compose files to orchestrate containers
    on a single Docker daemon or on Swarm. Supports compose versions 1 and 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_container`: Manages the container life cycle by providing the ability
    to create, update, stop, start, and destroy a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_image`: Provides full control over images, including `build`, `pull`,
    `push`, `tag`, and `remove`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_image_facts`: Inspects one or more images in the Docker host''s image
    cache, providing the information as facts to make decision or assertions in a
    playbook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_login`: Authenticates with Docker Hub or any Docker registry and updates
    the Docker Engine config file, which in turn provides password-free pushing and
    pulling of images to and from the registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker (dynamic inventory)`: Dynamically builds an inventory of all the available
    containers from a set of one or more Docker hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to note that the `docker_container` task name has been deprecated
    in Ansible 2.2\. Instead, Ansible recommends that you use `docker_container` and
    `docker_image` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some simple playbook task examples that will integrate Ansible
    with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can use Ansible to build a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you can use the command line to build a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the Ansible module architecture. We talked about
    how Ansible organizes modules by category (Core and user). Once you learned how
    Ansible manages modules, we talked about how Ansible modules can be called via
    two distinct methods (the command line and via playbook tasks). Then, we moved
    on and looked at a few examples of popular integration modules with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to look at how to integrate Ansible with
    popular CICD solutions, such as Jenkins, Git, and more. We will explore how to
    start making pipelines using Ansible and discover some tricks that will help us
    encourage the reuse of Ansible playbooks within an organization. Let's get moving,
    shall we?
  prefs: []
  type: TYPE_NORMAL
