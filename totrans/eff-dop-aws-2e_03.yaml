- en: Treating Your Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基础设施视为代码
- en: In the previous chapter, we familiarized ourselves with AWS. We also created
    an EC2 instance and deployed a Hello World web application onto it. However, to
    get there, we had to go through a number of steps to configure the instance and
    its security groups. Because we did that in a very manual fashion using the command-line
    interface, the steps that we went through will not be reusable or auditable, as
    you may recall from the first chapter when implementing DevOps best practices.
    Two key concepts that you should rely on as often as possible are source control
    (version control) and automation. In this chapter, we will explore how to apply
    those principles to our infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经熟悉了 AWS。我们还创建了一个 EC2 实例并将 Hello World 网页应用部署到该实例上。然而，为了完成这些操作，我们必须经历一系列步骤来配置实例及其安全组。由于我们使用命令行界面以非常手动的方式完成这些操作，这些步骤将不可复用，也不可审计，正如你可能还记得在第一章实现
    DevOps 最佳实践时提到的那样。你应该尽可能依赖的两个关键概念是源代码管理（版本控制）和自动化。在本章中，我们将探讨如何将这些原则应用于我们的基础设施。
- en: In a cloud environment, where almost everything is abstracted and served through
    the intermediary of virtual resources, it is easy to imagine that code can describe
    the topology of a network and the configuration of a system. To go through that
    transformation, we will learn about two key concepts in an effective DevOps organization.
    The first one is commonly called **Infrastructure as Code** (**IAC**). This is
    the process of describing all your virtual resources in the form of codes. These
    resources may include virtual servers, load balancers, storage, the network layer,
    and so on. The second concept, which is very close to IAC, focuses further on
    system configuration and is called **configuration management**. Through configuration
    management systems, developers and system administrators have the ability to automate
    operating system configuration, package installation, and even application deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，几乎所有内容都被抽象化并通过虚拟资源中介提供，我们可以很容易地想象，代码可以描述网络拓扑和系统配置。要完成这一转变，我们将学习 DevOps
    组织中两个关键的概念。第一个通常被称为**基础设施即代码**（**IAC**）。这是用代码的形式描述所有虚拟资源的过程。这些资源可能包括虚拟服务器、负载均衡器、存储、网络层等。第二个概念，虽然与
    IAC 非常相近，但更专注于系统配置，被称为**配置管理**。通过配置管理系统，开发人员和系统管理员能够自动化操作系统配置、软件包安装，甚至应用程序部署。
- en: 'Going through that transformation is a crucial step for any DevOps-focused
    organization. By having the code to describe the different resources and their
    configurations, we will be able to use the same tools and processes as we do when
    developing applications. We will be able to use source control and make smaller
    changes to individual branches, as well as submitting pull requests, following
    standard review processes, and finally, testing changes before they are applied
    to our production environment. This will give us better clarity, accountability,
    and auditability for infrastructure changes. Because of that, we will also be
    able to manage a much bigger fleet of resources without necessarily needing more
    engineers or without spending a lot more time operating all the resources. This
    will also open up the door to further automation, as we will see with continuous
    deployment in Chapter 5, *Adding Continuous Integration and Continuous Deployment*.
    In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这一转变是任何以 DevOps 为核心的组织的关键步骤。通过使用代码来描述不同的资源及其配置，我们将能够使用与开发应用程序时相同的工具和流程。我们将能够使用源代码管理，针对各个分支进行较小的更改，提交拉取请求，遵循标准的审核流程，并最终在将更改应用到生产环境之前进行测试。这将为我们提供更清晰的视角、更高的责任性以及更强的审计能力，以便管理基础设施的变化。正因如此，我们还能够管理更大规模的资源池，而不必增加更多的工程师，或者花费更多的时间来操作这些资源。这也为进一步的自动化打开了大门，正如我们在第
    5 章中将看到的那样，*添加持续集成和持续部署*。在本章中，我们将覆盖以下主题：
- en: Managing your infrastructure with CloudFormation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 管理基础设施
- en: Adding a configuration management system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加配置管理系统
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: AWS Console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 控制台
- en: AWS CloudFormation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFormation
- en: AWS CloudFormation Designer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFormation Designer
- en: CloudFormer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormer
- en: Troposphere
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Troposphere
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: GitHub
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Ansible
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: 'The GitHub links to find the codes in this chapter are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 GitHub 链接如下：
- en: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your infrastructure with CloudFormation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CloudFormation introduces a new way to manage services and their configurations.
    Through the creation of JSON or YAML files, CloudFormation lets you describe the
    AWS architecture you would like to build. Once your files are created, you can
    simply upload them to CloudFormation, which will execute them, and automatically
    create or update your AWS resources. Most AWS-managed tools and services are supported.
    You can get the full list at [http://amzn.to/1Odslix](http://amzn.to/1Odslix).
    In this chapter, we will only look at the infrastructure we have built so far,
    but we will add more resources in the following chapters. After a brief overview
    of how CloudFormation is structured, we will create a minimal list stack to recreate
    the Hello World web application from [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*. After that, we will see two more options
    to create CloudFormation templates—the designer, which lets you visually edit
    your template in a Web GUI, and CloudFormer, a tool to generate templates from
    existing infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with CloudFormation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you would expect, you can access CloudFormation through the AWS console
    at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation),
    or by using the following command line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，你可以通过 AWS 控制台访问 CloudFormation，网址为 [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)，或者使用以下命令行：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The service is organized around the concept of stacks. Each stack typically
    describes a set of AWS resources and their configuration in order to start an
    application. When working with CloudFormation, most of your time is spent editing
    those templates. There are different ways to get started with the actual editing
    of the templates. One of the easiest ways is to edit existing templates. AWS has
    a number of well-written examples available at [http://amzn.to/27cHmrb](http://amzn.to/27cHmrb).
    At the highest level, templates are structured as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务围绕堆栈的概念进行组织。每个堆栈通常描述一组 AWS 资源及其配置，以便启动应用程序。在使用 CloudFormation 时，你大部分时间都会花费在编辑这些模板上。开始编辑模板有不同的方法，其中一种最简单的方法是编辑现有的模板。AWS
    提供了多个编写良好的示例，网址为 [http://amzn.to/27cHmrb](http://amzn.to/27cHmrb)。在最高层次上，模板的结构如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `AWSTemplateFormatVersion` section is currently always `2010-09-09` and
    this represents the version of the template language used. This version is currently
    the only valid value. The `Description` section is there for you to summarize
    what the template does. The `Resources` section describes which AWS services will
    be instantiated and what their configurations are. When you launch a template,
    you have the ability to provide some extra information to CloudFormation, such
    as which SSH key-pair to use. For example, if you want to give SSH access to your
    EC2 instances, this kind of information goes into the `Parameters` section. The
    `Mappings` section is useful when you try to create a more generic template.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`AWSTemplateFormatVersion` 部分当前始终为 `2010-09-09`，表示使用的模板语言版本。这个版本目前是唯一有效的值。`Description`
    部分用于总结模板的功能。`Resources` 部分描述了将实例化哪些 AWS 服务及其配置。当你启动模板时，你可以提供一些额外的信息给 CloudFormation，例如使用哪个
    SSH 密钥对。例如，如果你想给 EC2 实例提供 SSH 访问权限，这类信息将放入 `Parameters` 部分。`Mappings` 部分在你尝试创建更通用的模板时非常有用。'
- en: You can, for example, define which **Amazon Machine Image** (**AMI**) to use
    for a given region, so that the same template can be used to start an application
    in that AWS region. The `Conditions` section allows you to add conditional logic
    to your other sections (if statements, logical operators, and so on), while the
    `Metadata` section lets you add more arbitrary information to your resources.
    Finally, the `Outputs` section lets you extract and print out useful information
    based on the execution of your template, such as the IP address of the EC2 server
    created, for example. In addition to those examples, AWS also provides a couple
    of tools and services around CloudFormation template creation. The first tool
    you can use to create your templates is called CloudFormation Designer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以定义在某个特定区域使用哪种 **Amazon Machine Image** (**AMI**)，以便在该 AWS 区域启动应用程序时使用相同的模板。`Conditions`
    部分允许你为其他部分添加条件逻辑（如 if 语句、逻辑运算符等），而 `Metadata` 部分则允许你为资源添加更多任意信息。最后，`Outputs` 部分让你根据模板的执行结果提取并打印出有用信息，例如创建的
    EC2 服务器的 IP 地址。除了这些示例，AWS 还提供了一些与 CloudFormation 模板创建相关的工具和服务。你可以用来创建模板的第一个工具叫做
    CloudFormation Designer。
- en: AWS CloudFormation Designer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS CloudFormation Designer
- en: 'AWS CloudFormation Designer is a tool that lets you create and edit CloudFormation
    templates using a graphic user interface. Designer hides a lot of the complexity
    of editing a CloudFormation template using a standard text editor. You can access
    this directly at [https://console.aws.amazon.com/cloudformation/designer](https://console.aws.amazon.com/cloudformation/designer),
    or in the CloudFormation dashboard after you click on the Create Stack button,
    as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation Designer 是一个工具，允许你使用图形用户界面创建和编辑 CloudFormation 模板。Designer
    隐藏了通过标准文本编辑器编辑 CloudFormation 模板时的大量复杂性。你可以直接访问 [https://console.aws.amazon.com/cloudformation/designer](https://console.aws.amazon.com/cloudformation/designer)，或者在点击创建堆栈按钮后通过
    CloudFormation 仪表板访问，如下所示：
- en: '*![](img/541decf4-3186-4bf3-9884-063c3c136b53.png)*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/541decf4-3186-4bf3-9884-063c3c136b53.png)*'
- en: The workflow is fairly simple. You simply drag and drop resources from the left-hand
    side menu into a canvas.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程相当简单。你只需将资源从左侧菜单拖放到画布上。
- en: 'Once your resources are added, you can then connect them to other resources
    using the small dots surrounding each resource icon. In the preceding example,
    we are connecting an EC2 instance to its security group. There are a number of
    hidden gems that can help you when designing your template. You can right-click
    on resources and directly access the documentation for the CloudFormation resource
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的资源被添加，你就可以通过围绕每个资源图标的小圆点将它们连接到其他资源。在前面的示例中，我们将一个EC2实例连接到其安全组。有许多隐藏的宝藏可以帮助你在设计模板时。你可以右键点击资源，直接访问CloudFormation资源的文档，如下所示：
- en: '![](img/be7eedd3-01e4-4e1d-abfb-8f7ec71abd1c.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be7eedd3-01e4-4e1d-abfb-8f7ec71abd1c.png)'
- en: 'When dragging a dot to connect two resources, a designer will highlight resources
    that are compatible with that connection. The editor on the bottom section of
    the designer supports auto completion using *Ctrl* + Spacebar:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当拖动一个点来连接两个资源时，设计器将高亮显示与该连接兼容的资源。设计器底部的编辑器支持使用*Ctrl* + 空格键的自动补全功能：
- en: '![](img/c1e036f6-de32-47a4-bcbb-8d3d509870d4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e036f6-de32-47a4-bcbb-8d3d509870d4.png)'
- en: Once your template is complete, you can simply click on a button and go from
    designing your stack to launching it. The next tool we will look at is called
    **CloudFormer**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的模板完成，你只需点击一个按钮，就可以从设计堆栈到启动堆栈。我们接下来要看的是名为**CloudFormer**的工具。
- en: CloudFormer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFormer
- en: 'CloudFormer is a tool that lets you create CloudFormation templates by looking
    at pre-existing resources. If you have a set of resources that you have already
    created on an ad hoc basis, as we have done so far in the book, then you can use
    CloudFormer to group them under a new CloudFormation template. You can then later
    customize the template that CloudFormer generates using a text editor or even
    CloudFormation designer, making it fit your needs. Unlike most AWS tools and services,
    CloudFormer isn''t completely managed by AWS; it''s a self-hosted tool that you
    can instantiate on demand using CloudFormation. To do so, follow the given steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormer是一个通过查看现有资源来创建CloudFormation模板的工具。如果你已经创建了一些临时的资源集，正如我们在本书中所做的那样，那么你可以使用CloudFormer将它们分组到一个新的CloudFormation模板下。之后，你可以使用文本编辑器甚至CloudFormation设计器自定义CloudFormer生成的模板，使其符合你的需求。与大多数AWS工具和服务不同，CloudFormer并非完全由AWS管理；它是一个自托管的工具，你可以通过CloudFormation按需实例化。为此，请按照以下步骤操作：
- en: Open [h](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[p](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[://c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[e](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[w](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[z](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[/c](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[u](https://console.aws.amazon.com/cloudformation)[d](https://console.aws.amazon.com/cloudformation)[f](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[r](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[i](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)
    in your browser.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 [h](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[p](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[://c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[e](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[w](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[z](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[/c](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[u](https://console.aws.amazon.com/cloudformation)[d](https://console.aws.amazon.com/cloudformation)[f](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[r](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[i](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)
    在你的浏览器中。
- en: Now, scroll down the AWS console screen, selectCreate a Template from your Existing
    Resources option, and click on the Launch CloudFormer button.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向下滚动 AWS 控制台屏幕，选择“从现有资源创建模板”选项，然后点击“启动 CloudFormer”按钮。
- en: 'In the Select a sample template drop-down menu, choose the CloudFormer option
    and click on the Next button, as shown in the following screenshot:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选择一个样本模板”下拉菜单中，选择 CloudFormer 选项，然后点击“下一步”按钮，如下图所示：
- en: '**![](img/46751091-bae2-4af6-986f-5e86de98a60f.png)**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/46751091-bae2-4af6-986f-5e86de98a60f.png)**'
- en: On that screen, at the top, you can provide a stack name (feel free to keep
    the default name, `AWSCloudFormer`) and in the bottom part, you are asked to provide
    three additional parameters, a Username, a Password and VPC Selection. This username
    and password will be used later to log into CloudFormer. Pick a username and a
    password, select the Default VPC, and click on the Next button.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该屏幕上，顶部你可以提供堆栈名称（可以保留默认名称`AWSCloudFormer`），在下方，你将被要求提供三个额外的参数：用户名、密码和 VPC 选择。此用户名和密码将用于稍后登录
    CloudFormer。选择一个用户名和密码，选择默认的 VPC，然后点击“下一步”按钮。
- en: On the next screen, you can provide extra tags and more advanced options, but
    we will simply continue by clicking on the Next button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，你可以提供额外的标签和更高级的选项，但我们将继续点击“下一步”按钮。
- en: This brings us to the review page, where we will check the checkbox to acknowledge
    that this will cause AWS CloudFormation to create IAM resources. Click on the Create
    button.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们进入审查页面，在这里我们将勾选复选框以确认这将导致 AWS CloudFormation 创建 IAM 资源。点击 **创建** 按钮。
- en: 'This will bring us back to the main screen of the CloudFormation console, where
    we can see our AWS CloudFormer stack being created . Once the Status column goes
    from CREATE_IN_PROGRESS to CREATE_COMPLETE, select it and click on the Outputs
    tab at the bottom. At that point, you have created the resources needed to use
    CloudFormer. In order to create a stack with it, do the following: in the Outputs
    tab (which illustrates the Outputs section of CloudFormation), click on the website
    URL link. This will open up the CloudFormer tool. Log in using the username and
    password provided in the fourth step of the previous set of instructions, and
    you should see something like the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把我们带回 CloudFormation 控制台的主屏幕，在那里我们可以看到我们的 AWS CloudFormer 堆栈正在创建中。一旦状态列从 CREATE_IN_PROGRESS
    变为 CREATE_COMPLETE，选择它并点击底部的 Outputs 标签。此时，你已经创建了使用 CloudFormer 所需的资源。为了使用它创建堆栈，请按照以下步骤操作：在
    Outputs 标签（显示 CloudFormation 的 Outputs 部分）中，点击网站 URL 链接。这将打开 CloudFormer 工具。使用在前一组说明的第四步中提供的用户名和密码登录，你应该能看到类似以下内容：
- en: '![](img/d45f2219-b0a7-44cd-ac34-1369a16757b9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d45f2219-b0a7-44cd-ac34-1369a16757b9.png)'
- en: 'Select the AWS region where you want to create the template and then click
    on the Create Template button. The following screen will then appear:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要创建模板的 AWS 区域，然后点击 **创建模板** 按钮。接下来会出现以下屏幕：
- en: '![](img/1bc2ff71-ff2a-4068-861d-f15ff6855af6.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bc2ff71-ff2a-4068-861d-f15ff6855af6.png)'
- en: Follow the workflow proposed by the tool to select the different resources that
    you want for your CloudFormation template, as far as the last step.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照工具所建议的工作流程选择你想要的不同资源，用于你的 CloudFormation 模板，直到最后一步。
- en: In the end, you will be able to download the generated template or save it directly
    in S3.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你将能够下载生成的模板或直接将其保存到 S3。
- en: The CloudFormation template generated by CloudFormer will usually need a bit
    of editing, as you will often want to create a more flexible stack with input
    parameters and an Outputs section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormer 生成的 CloudFormation 模板通常需要稍作编辑，因为你通常会希望创建一个更灵活的堆栈，带有输入参数和 Outputs
    部分。
- en: Recreating our Hello World example with CloudFormation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 重新创建我们的 Hello World 示例
- en: Designer and CloudFormer are two very useful tools when you are in the process
    of architecting your infrastructure and trying to add source control to your design.
    That said, whenever you wear your DevOps hat, it's a different story. Using those
    tools markedly reduces the added value that CloudFormation provides by using the
    JSON format. If you got a chance to read some of the templates available, or tried
    to use CloudFormer on your existing infrastructure, you probably noticed that
    raw CloudFormation templates tend to be fairly long and not **Don't Repeat Yourself**
    (**DRY**).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Designer 和 CloudFormer 是在构建基础设施并尝试为设计添加源代码控制时非常有用的两个工具。也就是说，每当你戴上 DevOps 帽子时，情况就不同了。使用这些工具显著减少了
    CloudFormation 通过使用 JSON 格式提供的附加价值。如果你有机会阅读一些现有的模板，或者尝试在现有的基础设施上使用 CloudFormer，你可能会注意到原始的
    CloudFormation 模板通常相当长，并且不符合 **不要重复自己**（**DRY**）原则。
- en: From a DevOps perspective, one of the most powerful aspects of CloudFormation
    is the ability to write code to dynamically generate those templates. To illustrate
    that point, we are going to turn to Python, and a library called `troposphere`,
    to generate our Hello World CloudFormation template.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DevOps 的角度来看，CloudFormation 最强大的功能之一就是能够编写代码动态生成这些模板。为了说明这一点，我们将使用 Python
    和一个名为 `troposphere` 的库来生成我们的 Hello World CloudFormation 模板。
- en: There are also a number of more advanced tools to assist with the creation of
    CloudFormation templates. If you plan on using other third-party services in addition
    to AWS, you can take a look at Terraform from Hashicorp (available at [https://www.terraform.io](https://www.terraform.io)),
    for example, which handles a number of other cloud providers and services in addition
    to CloudFormation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更高级的工具可以帮助创建 CloudFormation 模板。如果你计划使用除 AWS 之外的其他第三方服务，可以看看 Hashicorp 提供的
    Terraform（网址：[https://www.terraform.io](https://www.terraform.io)），它除了支持 CloudFormation
    外，还处理其他多个云提供商和服务。
- en: Using Troposphere to create a Python script for our template
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Troposphere 创建我们模板的 Python 脚本
- en: 'We will first install the `troposphere` library. Again, we are demonstrating
    all of the outputs from a CentOS 7.x-based Linux distribution, but the process
    applies equally to all of the supported platforms mentioned. The following is
    the command to install the `troposphere` library:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装`troposphere`库。同样，我们展示的是基于CentOS 7.x的Linux发行版的所有输出，但该过程同样适用于所有支持的平台。以下是安装`troposphere`库的命令：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One known issue with the Troposphere is the upgraded version of `setuptools`.
    If you come across the following issue, then the solution is to upgrade `setuptools`
    using the `pip install -U setuptools` command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Troposphere的一个已知问题是`setuptools`的升级版本。如果遇到以下问题，解决方案是使用`pip install -U setuptools`命令升级`setuptools`。
- en: 'Once you have run the preceding command, you may encounter the following error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了上述命令，您可能会遇到以下错误：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to fix the error, you can run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个错误，您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the installation is complete, you can then create a new file called `helloworld-cf-template.py`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以创建一个名为`helloworld-cf-template.py`的新文件。
- en: 'We will start our file by importing a number of definitions from the `troposphere`
    module as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从`troposphere`模块导入多个定义来开始我们的文件，如下所示：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are also going to define a first variable that will make editing the code
    easier for the remainder of the book. This is because we will create new scripts
    by building on this initial template:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义第一个变量，这将使后续的代码编辑变得更加容易。因为我们将通过在这个初始模板的基础上构建新脚本：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From a code standpoint, the first thing we will do is initialize a `Template`
    variable. By the end of our script, the template will contain the entire description
    of our infrastructure and we will be able to simply print its output to get our
    CloudFormation template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的角度来看，我们将做的第一件事是初始化一个`Template`变量。在脚本结束时，模板将包含我们基础设施的完整描述，我们将能够简单地打印其输出以获取我们的CloudFormation模板：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Throughout this book, we will create and run several CloudFormation templates concurrently.
    To help us identify what''s in a given stack, we have the ability to provide a
    description. After the creation of the template, add the description as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将并行创建并运行多个CloudFormation模板。为了帮助我们识别给定堆栈中的内容，我们可以提供一个描述。在模板创建后，按如下方式添加描述：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we launched EC2 instances using the web command-line interface, we selected
    which key-pair to use in order to gain SSH access to the host. In order to not
    lose this ability, the first thing our template will have is a parameter to offer
    the CloudFormation user the ability to select which key-pair to use when launching
    the EC2 instance. To do that, we are going to create a `Parameter` object and
    initialize it by providing an identifier, a description, a parameter type, a description
    of the parameter type, and a constraint description to help make the right decision
    when we launch the stack. In order for this parameter to exist in our final template,
    we will also use the `add_parameter()` function defined in the template class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Web命令行界面启动EC2实例时，我们选择了用于SSH访问主机的密钥对。为了不失去这一功能，我们的模板首先会包含一个参数，允许CloudFormation用户在启动EC2实例时选择使用哪个密钥对。为此，我们将创建一个`Parameter`对象，并通过提供标识符、描述、参数类型、参数类型的描述以及帮助做出正确决策的约束描述来初始化它。为了使这个参数出现在我们的最终模板中，我们还将使用模板类中定义的`add_parameter()`函数：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next thing we will look at is the security group. We will proceed exactly
    as we did for our `KeyPair` parameter. We want to open up `SSH/22` and `TCP/3000`
    to the world. Port `3000` was defined in the `ApplicationPort` variable declared
    earlier. In addition, this time, the information defined isn''t a parameter like
    before, but a resource. Consequently, we will add that new resource using the
    `add_resource()` function as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将关注的是安全组。我们将按照之前为`KeyPair`参数所做的方式进行操作。我们希望将`SSH/22`和`TCP/3000`开放给全球。端口`3000`之前在`ApplicationPort`变量中定义。此外，这次定义的信息不是像之前那样的参数，而是一个资源。因此，我们将使用`add_resource()`函数将该新资源添加如下：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our next section, we will replace the need to log on to our EC2 instance
    and install the `helloworld.js` file and its `init` scripts by hand. To do so,
    we will take advantage of the `UserData` features that EC2 offers. When you create
    an EC2 instance, the `UserData` optional parameter gives you the ability to provide
    a set of commands to run once the virtual machine has spawned up (you can read
    more on this topic at [http://amzn.to/1VU5b3s](http://amzn.to/1VU5b3s)). One of
    the constraints of the `UserData` parameter is that the script must be base64-encoded
    in order to be added to our API call.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将替换手动登录到我们的EC2实例并安装`helloworld.js`文件及其`init`脚本的需求。为此，我们将利用EC2提供的`UserData`功能。当您创建EC2实例时，`UserData`可选参数允许您提供一组命令，在虚拟机启动后执行（您可以在[http://amzn.to/1VU5b3s](http://amzn.to/1VU5b3s)上阅读更多有关此主题的内容）。`UserData`参数的一个限制是，脚本必须进行base64编码，才能添加到我们的API调用中。
- en: 'We are going to create a small script to reproduce the steps that we went through
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application.* Here, we will encode, deploy our first web application deployment
    step in base-64 and store it in a variable called `ud`. Note that installing the
    application in the `home` directory of `ec2-user` isn''t very clean. For now,
    we are trying to stay consistent with what we did in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying
    Your First Web Application*. We will fix that in Chapter 5, *Adding Continuous
    Integration and Continuous Deployment*, as we improve our deployment system:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小脚本来重现我们在[第2章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中所做的步骤，*部署您的第一个Web应用程序*。在这里，我们将对我们的第一个Web应用程序的部署步骤进行base-64编码，并将其存储在一个名为`ud`的变量中。请注意，在`ec2-user`的`home`目录中安装应用程序并不非常整洁。现在，我们尽量保持与在[第2章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中所做的步骤一致，*部署您的第一个Web应用程序*。我们将在第5章，*添加持续集成和持续部署*中解决这个问题，并改进我们的部署系统。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will now focus on the main resource of our template, which is our EC2 instance.
    The creation of the instance requires providing a name for identifying the resource,
    an image ID, an instance type, a security group, the key-pair to use for the SSH
    access, and the user data. In order to keep things simple, we will hardcode the
    AMI ID (`ami-cfe4b2b0`) and instance type (`t2.micro`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注我们模板的主要资源，即我们的EC2实例。创建该实例需要提供一个用于标识资源的名称、一个镜像ID、一个实例类型、安全组、用于SSH访问的密钥对，以及用户数据。为了简化操作，我们将硬编码AMI
    ID（`ami-cfe4b2b0`）和实例类型（`t2.micro`）。
- en: 'The remaining pieces of information needed to create our EC2 instances are
    the security group information and the `KeyPair` name, which we collected previously
    by defining a parameter and a resource. In CloudFormation, you can refer to pre-existing
    subsections of your template by using the `Ref` keyword. In Troposphere, this
    is done by calling the `Ref()` function. As before, we will add the resulting
    output to our template with the help of the `add_resource` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建EC2实例所需的其余信息是安全组信息和`KeyPair`名称，这些信息我们之前通过定义参数和资源收集过。在CloudFormation中，您可以通过使用`Ref`关键字引用模板中预先存在的子部分。在Troposphere中，这可以通过调用`Ref()`函数来完成。如前所述，我们将借助`add_resource`函数将生成的输出添加到我们的模板中。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the last section of our script, we will focus on producing the `Outputs`
    section of the template that gets populated when CloudFormation creates a stack.
    This selection allows you to print out useful information that was computed during
    the launch of the stack. In our case, there are two useful pieces of information—the
    URL to access our web application, and the public IP address of the instance,
    so that we can SSH into it if we want to. In order to retrieve such information,
    CloudFormation uses the `Fn::GetAtt ` function. In Troposphere, this is translated
    into the  `GetAtt()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的最后部分，我们将专注于生成模板的`Outputs`部分，该部分将在CloudFormation创建堆栈时填充。此选择允许您打印在堆栈启动过程中计算出的有用信息。在我们的例子中，有两条有用的信息——访问我们Web应用程序的URL和实例的公网IP地址，以便我们如果需要，可以通过SSH访问它。为了获取这些信息，CloudFormation使用`Fn::GetAtt`函数。在Troposphere中，这被转换为`GetAtt()`函数。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At that point, we can make our script output the final result of the template
    we generated:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们可以让我们的脚本输出我们生成的模板的最终结果。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The script is now complete. We can save this and quit our editor. The file created
    should look like the file at the following link:  [https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run our script, giving it the proper permissions and generating
    the CloudFormation template by saving the output of our script in a file as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`cloud-init` is a set of Python scripts compatible with most Linux distributions
    and cloud providers. This complements the `UserData` field by moving most standard
    operations, such as installing packages, creating files, and running commands
    into different sections of the template. This book doesn''t cover that tool, but
    if your CloudFormation templates rely heavily on the `UserData` field, take a
    look at it. You can get its documentation at [http://bit.ly/1W6s96M](http://bit.ly/1W6s96M).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Creating the stack in the CloudFormation console
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we can launch our template using the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser with the following link: [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
    Click on the Create Stack button.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, we will upload our newly generated template, `helloworld-
    cf.template`, by selecting Upload a template to Amazon S3, and then browsing to
    select our `helloworld-cf.template` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then pick a stack name, such as `HelloWorld`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the stack name, we can see the Parameters section of our template in action.
    CloudFormation lets us pick which SSH key-pair to use. Select your key-pair using
    the drop-down menu.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, we have to ability the add optional tags to our resources;
    in the Advanced section, we can see how we can potentially integrate CloudFormation
    and SNS, make decisions on what to do when a failure or a timeout occurs, and
    even add a stack policy that lets you control who can edit the stack, for example.
    For now, we will simply click on the Next button.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This leads us to the review screen where we can verify the information selected
    and even estimate how much it will cost to run that stack. Click on the Create
    button.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will bring us to the main CloudFormation console. On that screen, we are
    able to see how our resources are created in the Events tab.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the creation of the template is complete, click on the Outputs tabs, which
    will reveal the information we generated through the Outputs section of our template,
    as shown here:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59eb8843-7aa6-4dbb-adaf-f1c0f329a337.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Click on the link in the value of the WebUrl key, which will open our Hello
    World page.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding our template to a source control system
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have tested our template and know it's working, we are going to
    commit it to our source control system. This will allow us to keep track of changes,
    making it possible to treat our infrastructure code at the same standard as our
    application code (more on this in Chapter 5, *Adding Continuous Integration and
    Continuous Deployment*).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we will rely on Git. AWS has a service called AWS CodeCommit ([http://amzn.to/2tKUj0n](http://amzn.to/2tKUj0n)),
    which lets you manage Git repositories easily. However, because this service is
    a lot less popular than GitHub ([https://github.com](https://github.com/)), we
    will instead use the latter. If you don't have an account for GitHub yet, start
    by signing up for the service—it's completely free.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged into GitHub, create a new repository for the CloudFormation template:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, open [https://github.com/new](https://github.com/new).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the new repository the following: `EffectiveDevOpsTemplates`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Initialize this repository with a README checkbox.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, click on the Create repository button, as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91f23a82-9d36-415c-a6ca-a84e91b880d3.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Once your repository is created, you will want to clone it into your computer.
    For that, you need to have Git installed (search on Google for instructions on
    how to install Git for your operating system if you don''t have it yet). For CentOS,
    you just need to run `yum -y install git`, as the Git package is a part of Linux
    distribution now:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that the repository is cloned, we will go into it and copy the template
    previously created in the new GitHub repository:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will add and commit that new file to our project and push it to
    GitHub as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Monorepo versus multirepo: **When managing your code, there are two common
    approaches to organizing your code repositories. You can create one repository
    for each project you have, or decide to put your entire organization code under
    a single repository. We will choose the simplest option for this book, which is
    one repository per project, but with the recent releases of several open source
    projects, such as Bazel from Google, Buck from Facebook, or Pants from Twitter,
    using a monorepo becomes a very compelling option as it avoids juggling between
    multiple repositories when making big changes to your infrastructure and services
    simultaneously.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Updating our CloudFormation stack
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest benefits of using the CloudFormation template to manage our
    resources is that the resources created from CloudFormation are tightly coupled
    to our stack. If we want to make a change to our stack, we can update the template
    and apply the change to our existing CloudFormation stack. Let's see how that
    works.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Updating our Python script
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `helloworld-cf-template.py` script is fairly basic. At this point, we are
    only taking advantage of Python as far as using the `troposphere` library to easily
    generate JSON output in a more pleasant way than if we had to write it by hand.
    Of course, you might already realize that we are barely scratching the surface
    of what we can do when we have the ability to write scripts to create and manage
    infrastructures. The following section is a simple example that will let us write
    a couple more lines of Python and illustrate the concept of updating a CloudFormation
    stack, while taking advantage of more services and external resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The security groups we created in our previous example open up two ports to
    the world: `22` (SSH) and `3000` (the web application port). We could try to harden
    one aspect of our security by only allowing our own IP to use SSH. This means
    changing the **Classless Inter-Domain Routing** (**CIDR**) IP information in our
    Python script on the security group that handles the port `22` traffic. There
    are a number of free services online that will let us know what our public IP
    is. We are going to use one of these, available at [https://api.ipify.org](https://api.ipify.org/).
    We can see it in action with a simple `curl` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are going to take advantage of that service in our script. One of the reasons
    for using this particular service is that it has been packaged into a Python library.
    You can read more on this at [https://github.com/rdegges/python-ipify](https://github.com/rdegges/python-ipify).
    You can first install that library as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In case you come across some `pip` related errors, as shown in the following
    code block, the fix would be to downgrade the `pip` version, install `ipify`,
    and then upgrade the `pip` version again to the latest version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding error can be fixed with the following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our script requires a CIDR. In order to convert our IP address to CIDR, we
    will also install another library, called `ipaddress`. The main advantage of combining
    these libraries is that we don''t have to worry about handling IPv4 versus IPv6:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once those libraries are installed, reopen `helloworld-cf-template.py` in your
    editor. At the top of our script, we are going to import the libraries, then,
    after the `ApplicationPort` variable definition, we will define a new variable
    called `PublicCidrIp` and, combining the two libraries mentioned previously, we
    can extract our CIDR as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we can change the `CidrIp` declaration for the SSH group rule as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now save these changes. The file created should look like the file at
    [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now generate a new `diff` command to visually verify the change:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, our CIDR IP is now correctly restricting the connection to our
    IP. We can now apply that change.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Updating our stack
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having generated the new JSON CloudFormation template, we can get in the CloudFormation
    console and update the stack as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloWorld` stack that we created previously .
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Actions drop-down menu, and then choose the Update Stack option.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the `helloworld-cf-v2.template` file by clicking the Browse button, selecting
    the file, and then  clicking on the Next button.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This brings us to the next screen that lets us update the details of our stack.
    In our case, nothing has changed in the parameters, so we can continue by clicking
    on the Next button.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next screen as well, since we simply want to see the effect of our IP
    change, we can click on the Next button:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f0b5618-87d5-41b5-882d-2290b9798910.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'This brings us to the review page, where, after a couple of seconds, we can
    see CloudFormation giving us a preview of our change:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f7c9956-37d8-4a3e-8888-dc1fcb625efb.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: As you can see, the only change will be an update on the security group. Now
    click on the Update button. This will bring us back to the CloudFormation template,
    where we will see the change being applied.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this particular example, AWS is able to simply update the security group
    to take our change into account. We can verify the change by extracting the physical
    ID from either the review page, or in the Resources tab back in the console:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Change sets
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our template only includes a web server and a security group that makes updating
    CloudFormation a fairly harmless operation. Furthermore, our change was fairly
    trivial, as AWS could simply update the existing security group, as opposed to
    having to replace it. As you can imagine, as the architecture becomes more and
    more complex, so does the CloudFormation template. Depending on the update you
    want to perform, you might encounter unexpected changes when you review the change
    set in the final step of updating a template. AWS offers an alternative and safer
    way to update templates; this feature is called **change sets** and is accessible
    from the CloudFormation console. Follow this procedure in order to use change
    sets to review the updates, followed by execution:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloWorld` stack that we previously created
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Actions drop-down menu and then click the Create Change Set For
    Current Stack option
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, you can follow the same steps you took to create a simple update
    in the *Updating our stack* section. The main difference happens on the last screen,
    shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0deeb19b-d946-4819-97ec-0843960fdce0.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Unlike the regular stack updates, change sets have a strong emphasis on giving
    you the ability to review a change before applying it. If you are satisfied with
    the changes displayed, you have the ability to execute the update. Lastly, when
    using a change set to update your stack, you can easily audit recent changes using
    the Change Sets tab of your stack in the CloudFormation console. Finally, we will
    commit the changes to the Troposphere script with the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting our CloudFormation stack
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw how CloudFormation was able to update resources
    as we update our template. The same goes when you want to remove a CloudFormation
    stack and its resources. In a couple of clicks, you can delete your template and
    the various resources that were created at launch time. From a best practice standpoint,
    it is highly recommended to always use CloudFormation to make changes to your
    resources that were previously initialized with CloudFormation, including when
    you don't need your stack any more.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting a stack is very simple, and you should proceed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloWorld` stack that we created previously
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Actions drop-down menu, and then click on the Delete Stack option
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As always, you will be able to track completion in the Events tab:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97b24707-f9c2-4c6e-be1e-f1ed2aa3b374.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: CloudFormation has a unique place in the AWS ecosystem. As complex as they are,
    most architectures can be described and managed through CloudFormation, allowing
    you to keep tight control over your AWS resources creation. While CloudFormation
    does a great job of managing the creation of resources, it doesn't always make
    things easy. This is especially the case when you want to make simple changes
    on services such as EC2\. Because CloudFormation doesn't keep track of the state
    of the resources once they are launched, the only reliable way to update an EC2
    instance is, for example, to recreate a new instance and swap it with the existing
    instance when it is ready. This creates somewhat of an immutable design (assuming
    that you don't run any extra commands when the instance is created). This may
    be an attractive architecture choice and, in some cases, it may take you a long
    way, but you may wish to have the ability to have long-running instances where
    you can, as this allows you to quickly and reliably make changes through a controlled
    pipeline, like we did with CloudFormation. This is what configuration management
    systems excel at.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Adding a configuration management system
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration management systems are probably the most well known components
    of classic DevOps-driven organizations. Present in most companies (including in
    the enterprise market), configuration management systems are quickly replacing
    home-grown Shell, Python, and Perl scripts. There are many reasons why configuration
    management systems should be a part of your environment. One reason is that they
    offer domain-specific languages, which improves the readability of the code, and
    they are tailored to the specific needs that arise in organizations when trying
    to configure systems. This results in a lot of useful built-in features. Furthermore,
    the most common configuration management tools have a big and active user community,
    which often means that you will be able to find existing code for the system you
    are trying to automate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most popular configuration management tools include **Puppet**,
    **Chef**, **SaltStack**, and **Ansible**. While all of those options are fairly
    good, this book will focus on Ansible, the easiest of the four tools mentioned.
    There are a number of key characteristics that make Ansible a very popular and
    easy-to-use solution. Unlike other configuration management systems, Ansible is
    built to work without a server, a daemon, or a database. You can simply keep your
    code in source control and download it on the host whenever you need to run it
    or use a push mechanism through SSH. The automation code you write is in YAML
    static files, which makes the learning curve a lot less steep than some of the
    other alternatives that use Ruby or specific DSL. In order to store our configuration
    files, we will instead rely on our version control system (in our case, GitHub.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS OpsWorks and its Chef integration**: While Amazon hasn''t really released
    a service dedicated to configuration management, it supports Chef and Puppet within
    the OpsWorks service. Unlike the services we have explored so far in the book,
    OpsWorks aims at being a *complete application life cycle, including resource
    provisioning, configuration* *management, application deployment, software updates,
    monitoring, and access control**. *If you are willing to sacrifice some flexibility
    and control, OpsWorks might be able to handle what you need in order to run a
    simple web application. You can learn more about this at [http://amzn.to/1O8dTsn](http://amzn.to/1O8dTsn).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Ansible
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Begin by installing Ansible on your computer. After doing this, create an EC2
    instance that will let us illustrate the basic usage of Ansible. After that, we
    will work on recreating the Hello World Node.js application by creating and executing
    what Ansible calls a playbook. We will then look at how Ansible can run in pull
    mode, which offers a new approach to deploying changes. Finally, we will look
    at replacing the `UserData` block in our CloudFormation template with Ansible
    to combine the benefits of both CloudFormation and our configuration management
    system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is fairly easy to use and well documented throughout the web. This book
    will cover enough to get you started and up to speed on simple configurations,
    such as the one we need in our examples. However, you might be interested in spending
    a bit more time learning about Ansible in order to be really efficient with it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible on your computer
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, Ansible is a really simple application with very few dependencies.
    You can install Ansible on your computer using your operating system package manager,
    or through `pip`, as Ansible is written in Python. We will be demonstrating all
    of the outputs from a CentOS 7.x-based Linux distribution, but the process applies
    equally to all supported platforms. (For more information, refer to the following
    link in order to find and install Ansible binaries on your operating system: [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine).) The
    following command will install a number of binaries, libraries, and Ansible modules:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that no daemon or database is installed at this point. This is because,
    by default, Ansible relies on static files and SSH in order to run. At this point,
    we are ready to use Ansible:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Creating our Ansible playground
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the basic functionalities of Ansible, we are going to start by
    re-launching our Hello World application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to create a stack using the web interface.
    As you would expect, it is also possible to launch a stack using the command-line
    interface. Go into the `EffectiveDevOpsTemplates` directory where you previously
    generated the `helloworld-cf-v2.template` file and run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our instance will soon be ready. We can now bootstrap our environment by creating
    a workspace.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Ansible repository
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Ansible, our first goal is to be able to run commands on remote hosts.
    In order to do that efficiently, we need to configure our local environment. Because
    we don't want to have to redo those steps repeatedly, and because, ultimately,
    we want to source-control everything, we will create a new Git repository. To
    do that, we will repeat the same steps that we used when we created our `EffectiveDevOpsTemplate`
    repository.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged into GitHub, create a new repository for the CloudFormation template
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, open this link: [https://github.com/new](https://github.com/new).
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the new repository the name `ansible`, as shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b43c4445-ba61-459d-96a5-ad3d035a4b97.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Check the Initialize this repository with a README checkbox.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the Create repositorybutton.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your repository is created, clone it onto your computer as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that the repository is cloned, we will go into this and copy the template 
    created previously in the new GitHub repository:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At its base, Ansible is a tool that can run commands remotely on the hosts
    in your inventory. The inventory can be managed manually by creating an `INI`
    file where you list all your hosts and/or IPs. It can also be managed dynamically
    if it can query an API. As you can imagine, Ansible is perfectly capable of taking
    advantage of the AWS API in order to fetch our inventory. To do so, we will download
    a Python script from the official Ansible Git repository and give the execution
    permissions as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before we can start testing this Python script, we also need to provide a configuration
    for it. Create a new file in the same directory and call it `ec2.ini`. In this
    file, we will put the following configuration:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once this is done, you can finally validate that the inventory is working by
    executing the `ec2.py` script as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This command should return a big nested JSON of the different resources found
    on your AWS account. Among these is the public IP address of the EC2 instance
    that we created in the previous section. The last step in our bootstrapping is
    to configure Ansible itself, such that it knows how to get the inventory of our
    infrastructure; which user to use when it tries to SSH into our instances; how
    to become a root; and so on. We will create a new file in the same location and
    call it `ansible.cfg`. Its content should be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At that point, we are ready to start running Ansible commands. Ansible has a
    few commands and some simple concepts. We will first look at the `ansible` command
    and the concept of modules.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Executing modules
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ansible` command is the main command that drives the execution of the different
    modules on the remote hosts. Modules are libraries that can be executed directly
    on remote hosts. Ansible comes with a number of modules, as listed at [http://bit.ly/24rU0yk](http://bit.ly/24rU0yk).
    In addition to the standard modules, you can also create your own custom modules
    using Python. These are the modules for most common use cases and technologies.
    The first module we will see is a simple module called `ping`, which tries to
    connect to a host and returns `pong` if the host is usable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Module documentation can also be accessed using the `ansible-doc` command,
    shown as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`$ ansible-doc <Module-Name>`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`$ ansible-doc ping`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Here, `ping` is one of the Ansible module names.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating our Ansible playground section, we created a new EC2 instance
    using CloudFormation. So far, we haven''t looked up the IP address for this. Using
    Ansible and the `ping` module, we will discover that information. As mentioned
    before, we need to be in the `ansible` directory in order to run the `ansible`
    command. The command is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we can see, Ansible was able to find our EC2 instance by querying the AWS
    EC2 API. The newly created instance is now ready to be used.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring SSH**: As Ansible relies heavily on SSH, it is worth dedicating
    a bit of time to configuring SSH through the `$HOME/.ssh/config` file. For instance,
    you can use the following options to avoid having to specify `--private-key` and
    `-u` in the preceding example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`IdentityFile ~/.ssh/EffectiveDevOpsAWS.pem`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '`User ec2-user StrictHostKeyChecking no`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`PasswordAuthentication no`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`ForwardAgent yes`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Once configured, you won't need to provide the `--private-key` option to Ansible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Running arbitrary commands
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ansible` command can also be used to run arbitrary commands on remote
    servers. In the following example, we will only run the `df` command on hosts
    matching `18.206.223.*`  for their public IP address (you will need to adapt this
    command to match your instance public IP, as returned in the `ping` command in
    the previous example):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have a basic understanding of how Ansible works, we can start combining
    calls to different Ansible modules to put in place for automation. This is called
    creating a **playbook**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks are the files that contain Ansible's configuration, deployment, and
    orchestration language. By creating those files, you sequentially define the state
    of your systems, from the OS configuration down to application deployment and
    monitoring. Ansible uses YAML, which is fairly easy to read. For that reason,
    an easy way to get started with Ansible, similarly to what we did with CloudFormation, is
    to look at some examples inside the official Ansible GitHub repository, available
    at [https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples).
    Alternatively, you can even look in my repository, which makes it fairly simple
    and easy to understand playbooks, and which can be found at  [https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)
    for the book *Automation with Ansible*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Creating a playbook
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a number of best practices on their website, available at [http://bit.ly/1ZqdcLH](http://bit.ly/1ZqdcLH).
    One emphasis in their documentation is on using roles. One crucial way to organize
    your playbook content is Ansible's *roles* organization feature, which is documented
    as part of the main playbooks page. Creating roles is a key component in making
    Ansible code sharable and modular enough so that you can reuse your code across
    services and playbooks. To demonstrate a proper structure, we are going to create
    a role that our playbook will then call.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Creating roles to deploy and start our web application
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use roles to recreate the Hello World stack we made previously using
    the `UserData` block of CloudFormation. If you recall, the `UserData` section
    looked roughly like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will notice three different types of operation in the preceding script.
    We are first preparing the system to run our application. To do that, in our example,
    we are simply installing a Node.js package. Next, we copy the different resources
    needed to run the application. In our case, this is the JavaScript code and the
    upstart configuration. Finally, we start the service. As always when doing programming,
    it is important to keep the code DRY. If deploying and starting our application
    is very unique to our Hello World project, installing Node.js likely isn't. In
    order to make the installation of Node.js a reusable piece of code, we are going
    to create two roles—one to install Node.js, and one to deploy and start the Hello
    World application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Ansible expects to see roles inside a `roles` directory at the
    root of the Ansible repository. So, the first thing we need to do is to go inside
    the `ansible` directory that we created under the *Creating our Ansible repository* section.
    Create the `roles` directory inside, and `cd` the following into it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now create our roles. Ansible has an `ansible-galaxy` command that can
    be used to initialize the creation of a role. The first role we will look into
    is the role that will install Node.js:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As briefly mentioned, Ansible, like most other configuration management systems,
    has a strong support community who share roles online through [h](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[p](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[://g](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[x](https://galaxy.ansible.com/)[y](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[n](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[i](https://galaxy.ansible.com/)[b](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[e](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[c](https://galaxy.ansible.com/)[o](https://galaxy.ansible.com/)[m](https://galaxy.ansible.com/)[/](https://galaxy.ansible.com/).
    In addition to using the `ansible-galaxy` command to create the skeleton for new
    roles, you can also use `ansible-galaxy` to import and install community supported
    roles.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a `nodejs` directory, and a number of sub-directories that will
    let us structure the different sections of our role. We will enter this directory
    with the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The most important directory inside the `nodejs` directory is the one called
    `tasks`. When Ansible executes a playbook, it runs the code present in the `tasks/main.yml`
    file. Open the file with your favorite text editor.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first open `tasks/main.yml`, you will see the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The goal of the `nodejs` role is to install Node.js and `npm`. To do so, we
    will proceed similarly to how we did with the `UserData` script, and use the `yum` command
    to perform those tasks.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing a task in Ansible, you sequence a number of calls to various Ansible
    modules. The first module we are going to look at is a wrapper around the `yum`
    command. The documentation on it is available at [http://bit.ly/28joDLe](http://bit.ly/28joDLe).
    This will let us install our packages. We are also going to introduce the concept
    of loops. Since we have two packages to install, we will want to call the `yum`
    module twice. We will use the operator''s `with_items`**.** All Ansible codes
    are written in YAML, which is very easy to start with and use. After the initial
    three dashes and comments, which indicate the start of a YAML file, we are going
    to call the `yum` module in order to install our packages:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Whenever Ansible runs that playbook, it will look at packages installed on the
    system. If it doesn't find the `nodejs` or `npm` packages, it will install them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Your file should look like the example available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml).
    This first role is complete. For the purpose of this book, we are keeping the
    role very simple, but you can imagine how, in a more production-type environment,
    you might have a role that will install specific versions of Node.js and `npm`,
    fetch the binaries directly from [https://nodejs.org/en/](https://nodejs.org/en/),
    and maybe even install specific dependencies. Our next role will be dedicated
    to deploying and starting the Hello World application that we built previously.
    We are going to go one directory up back into the `roles` directory, and call
    `ansible-galaxy` one more time:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Like before, we will now go inside the newly created `helloworld` directory
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This time, we will explore some of the other directories present. One of the
    sub-directories that was created when we ran the `ansible-galaxy` command was
    the directory called `files`. Adding files to that directory will give us the
    ability to copy files on the remote hosts. To do so, we are first going to download
    our two files in this directory as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now use task files to perform the copy on the remote system. Open the
    `tasks/main.yml` file and, after the initial three dashes and comments, add the
    following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are taking advantage of the copy module documented at [h](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[p](http://bit.ly/1WBv08E)[://b](http://bit.ly/1WBv08E)[i](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[.](http://bit.ly/1WBv08E)[l](http://bit.ly/1WBv08E)[y](http://bit.ly/1WBv08E)[/1W](http://bit.ly/1WBv08E)[B](http://bit.ly/1WBv08E)[v](http://bit.ly/1WBv08E)[08E](http://bit.ly/1WBv08E)
    to copy our application file in the home directory of the `ec2-user`. On the last
    line of that call, we add a notify option at the end (note how the `notify` statement
    is aligned with the call to the copy module). Notify actions are triggers that
    can be added at the end of each block of tasks in a playbook. In this example,
    we are telling Ansible to call the restart `helloworld` directive if the file
    `helloworld.js` changed, and not to perform a restart if nothing is changed in
    the code (we will define how to do a restart of the `helloworld` application in
    a different file a bit later).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: One of the big differences between CloudFormation and Ansible is that Ansible
    is expected to run multiple times throughout the lifetime of your systems. A lot
    of the functionalities built into Ansible are optimized for long-running instances.
    As such, the `notify` option makes it easy to trigger events when a system changes
    state. Similarly, Ansible will know to stop the execution when an error encountered
    prevents outages as far as possible.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have copied our application file, we can add our second file, the
    `upstart` script. After the previous call to copy the `helloword.js` file, we
    are going to add the following call:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The last task we need to perform is to start our service. We will use the `service`
    module for that. The module documentation is available at [http://bit.ly/22I7QNH](http://bit.ly/22I7QNH):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our task file is now completed. You should end up with something resembling
    the sample available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Having finished our task file, we are going to move on to the next file, which
    will give Ansible knowledge of how and when to restart `helloworld`, as called
    out in the `notify` parameter of our task. These types of interaction are defined
    in the `handler` section of the role. We are going to edit the `handlers/main.yml`
    file. Here too, we are going to use the `service` module. The following is a comment:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following to the `main.yml` file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: No surprises here; we are using the same module we previously used to manage
    the service. We need one more step in our role. In order for the `helloworld`
    role to work, the system needs to have Node.js installed. Ansible supports the
    concept of role dependencies. We can explicitly tell that our `helloworld` role
    depends on the `nodejs` role we previously created, so that, if the `helloworld`
    role is executed, it will first call the `nodejs` role and install the necessary
    requirements to run the app.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `meta/main.yml` file. This file has two sections. The first one, under
    `galaxy_info`, lets you fill in the information on the role you are building.
    If you wish, you can ultimately publish your role on GitHub and link it back into
    `ansible-galaxy` to share your creation with the Ansible community. The second
    section at the bottom of the file is called `dependencies`and this is the one
    we want to edit to make sure that `nodejs` is present on the system prior to starting
    our application. Remove the square brackets ([]) and add an entry to call `nodejs`
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Your file should look like the sample available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml).
    This concludes the creation of the code for the role. From a documentation standpoint,
    it is good practice to also edit `README.md`. Once done, we can move on to creating
    a playbook file that will reference our newly created role.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Creating the playbook ﬁle
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the top level of our Ansible repository (two directories up from the `helloworld`
    role), we are going to create a new file called `helloworld.yml`. In this file,
    we are going to add the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This basically tells Ansible to execute the `helloworld` role onto the hosts
    listed in the `target` variable, or `localhost` if the target isn't defined. The
    `become` option will tell Ansible to execute the role with elevated privileges
    (in our case, `sudo`). At this point, your Ansible repository should look like
    the example at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible).
    We are now ready to test our playbook.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in practice, on a bigger scale, the roles sections could include
    more than a single role. If you deploy multiple applications or services to a
    target, you will often see playbook looking like this. In later chapters, we will
    see more examples of this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Executing a playbook
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The execution of playbooks is done using the dedicated `ansible-playbook` command.
    This command relies on the same Ansible configuration file that we used previously,
    and therefore, we want to run the command from the root of our Ansible repository.
    The syntax of the command is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will first run the following command (adapt the value of the `private-key`
    option):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The option `-e` (or `--extra-vars`) allows us to pass extra options for execution.
    In our case, we are defining the `target` variable (which we declared in the `hosts`
    section of our playbook) to be equal to `ec2`. This first `ansible-playbook` command
    will tell Ansible to target all EC2 instances. The `--list-hosts` option will
    make Ansible return a list of hosts that match the hosts criteria, but it won''t
    actually run anything against those hosts. The output of the command will be something
    like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `list-hosts` option is a good way to verify your inventory and, on more
    complex playbooks with more specific host values, to verify which hosts would
    run actual playbooks, allowing you to verify that they are targeting the hosts
    you expect.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know which hosts will be impacted if we were to use this value for the
    target. The next thing we want to check is what will happen if we run our playbook.
    The `ansible- playbook` command has an option `-C` (or `--check`) that will try
    to predict the change a given playbook will make; this is sometimes also called
    **dry-run** mode in Ansible:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running that command will execute our playbook in dry-run mode. Through that
    mode, we can ensure that the proper tasks will be executed. Because we are in
    dry-run mode, some of the modules don''t really find everything they need in order
    to simulate how they would run. This is the reason why we sometimes see service
    start errors at the end of the service module. If you see this, then don''t worry,
    it will get executed when the packages are installed in the real-mode. Having
    verified the hosts and code, we can finally run `ansible-playbook` and execute
    our changes in a real-mode as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is very similar to the `--check` command, except that this time,
    the execution is performed in real-mode. Our application is now installed and
    configured, and we can verify that it is running correctly as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We were able to reproduce what we did previously with CloudFormation using
    Ansible. Now that we have tested our first playbook, we can commit our changes.
    We will do that in two commits to break down the initialization of the repository
    and the creation of the role. From the root of your Ansible repository, run the
    following commands:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Canary-testing changes
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great benefits of using Ansible to manage services is that you can
    easily make changes to your code and quickly push the change. In some situations
    where you have a big fleet of services managed by Ansible, you may wish to push
    out a change only to a single host to make sure things are how you expect them
    to be. This is often called **canary testing**. With Ansible, doing this is really
    easy. To illustrate that, we are going to open the `roles/helloworld/files/helloworld.js` file
    and then simply change the response on line 11 from `Hello World` to `Hello World,
    Welcome again`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Save the file, and then run `ansible-playbook` again. Do this with the `--check`
    option first:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This time, Ansible detects only two changes. The first one overwrites the application
    file and the second one executes the `notify` statement, which means restarting
    the application. Seeing that it is what we expect, we can run our playbook without
    the `--check` options:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This produces the same output as in our previous command, but this time the
    change is in effect:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our change was very simple, but if we had done this by updating our CloudFormation
    template, CloudFormation would have had to create a new EC2 instance to make it
    happen. Here, we simply updated the code of the application and pushed it through
    Ansible on the target host. We will now revert this change locally in Git as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will demonstrate this by removing the changes from the EC2 instance as we
    illustrate a new concept. In the next section, we will be running Ansible asynchronously
    in a reverse mode (in this case, in pull mode).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**The sooner, the better: **Being able to push changes in seconds instead of
    minutes may seem like a small win, but it isn''t. Speed matters; it is what sets
    apart successful start-ups and technologies. The ability to deploy new servers
    in minutes instead of days is a big factor in cloud adoption. Similarly, the recent
    success of containers, as we will see later in the book, is also likely driven
    by the fact that it only takes seconds to run a new container, while it still
    takes minutes to start a virtual server.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Running Ansible in pull mode
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to instantly make a change like we just did is a very valuable
    feature. We could easily and synchronously push the new code out and verify that
    the Ansible execution was successful. On a larger scale, while being able to change
    anything across a fleet of servers remains as valuable as in our example, it is
    also sometimes a bit trickier. The risk with making changes that way is that you
    have to be very disciplined with regards to not pushing changes to only a subset
    of hosts, and forgetting other hosts that are also sharing the role that just
    got updated. Otherwise, the increasing number of changes between the Ansible configuration
    repository and the running servers quickly makes running Ansible a riskier operation.
    For those situations, it is usually preferable to use a pull mechanism that will
    automatically pull in the changes. Of course, you don't have to choose one or
    the other—it is easy to configure both push and pull mechanisms to deploy changes.
    Ansible provides a command called `ansible-pull`, which, as its name suggests,
    makes it easy to run Ansible in pull mode. The `ansible-pull` command works very
    much like `ansible-playbook`, except that it starts by pulling your code from
    your GitHub repository.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git and Ansible on our EC2 instance
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we need to be able to run Ansible and Git remotely, we first need to
    install those packages on our EC2 instance. For now, we will do that by manually
    installing those two packages. We will implement a reusable solution later in
    this chapter. Since Ansible is a perfect tool for running remote commands and
    this has a module to manage most common requirements such as installing packages,
    instead of logging in on the host through `ssh` and running some commands, we
    are going to use Ansible to push out those changes. We will install Git and Ansible
    from the EPEL `yum` repository. This will require running commands as **root**,
    which you can do with the help of the `become` option. After adapting the IP address
    of your EC2 instance, run the following commands:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: With `ansible-pull`, our goal is for Ansible to apply the change locally. We
    can make a change to our Ansible repository in order to optimize this operation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ansible to run on localhost
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `ansible-pull` relies on Git to locally clone the repository and execute
    it, we don''t need the execution to happen over SSH. Go to the `root` directory
    of your Ansible repository to create a new file. The file should be called `localhost`
    and it should contain the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Essentially, what we are doing is creating a static inventory and asking `ansible`
    to run commands in local mode (as opposed to using SSH) when the target host is
    `localhost`. We can save the changes and commit the new file to GitHub as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Adding a cron job to our EC2 instance
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to create a cron tab entry to periodically call `ansible-pull`.
    Here, too, we will rely on Ansible to create our cron job remotely. Run the following
    command by adapting the IP address:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the preceding command, we are telling Ansible to use the `cron` module targeting
    our `ec2` instance. Here, we are providing a name that Ansible will use to track
    the cron job over time, telling `cron` to run the job every `10` minutes, followed
    by the command to execute and its parameters. The parameters we are giving to
    `ansible-pull` are the GitHub URL of our branch, the inventory file we just added
    to our repository, and a `sleep` parameter that will make the command start sometime
    between `1` and `60` seconds after the call started. This will help spread out
    the load on the network and prevent all node services from restarting at the same
    time if we have more than one server. After waiting for a bit, we can verify that
    our change is effective through the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: After manually integrating Ansible to the EC2 instance we created using CloudFormation,
    we can now formalize the procedure.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Ansible with CloudFormation
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are different strategies to integrate Ansible to CloudFormation,
    in our situation there is an obvious path to take. We are going to take advantage
    of the `UserData` field, and initialize Ansible through the `ansible-pull` command.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to start the Troposphere script that we created earlier in
    this chapter. We will duplicate this and call the new script as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Go to your template repository and duplicate the previous template as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, open the `ansiblebase-cf-template.py` script with your editor. To keep
    the script readable, we will first define several variables. Before the declaration
    of the application port, we will define an application name:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We will also set a number of constants around the GitHub information. Replace
    the value of `GithubAccount` with your GitHub username or GitHub organization
    name as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After the definition of `GithubAnsibleURL`, we are going to create one more
    variable that will contain the command line we want to execute in order to configure
    the host through Ansible. We will call `ansible-pull` and use the `GithubAnsibleURL`
    and `ApplicationName` variables that we just defined. This is what this looks
    like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We are now going to update the `UserData` block. Instead of installing Node.js,
    downloading our application files and starting the service, we will change this
    block to install `git` and `ansible`, execute the command contained in the `AnsiblePullCmd`
    variable, and finally create a cron job to re-execute that command every `10`
    minutes. Delete the previous `ud` variable definition and replace it with the
    following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can now save our file, use it to create our JSON template, and test it.
    Your new script should look like the sample at [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can even create a new stack yourself. For example, let''s say `helloworld`,
    instead of changing the existing `ansible` stack. In this case, you need to run
    the following command for stack creation:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can now wait until the execution is complete:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that the stack creation is complete, we can query CloudFormation to get
    the output of the stack and, more specifically, its public IP address:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And finally, we can verify that our server is up and running as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can now commit our newly created `troposphere` script to our GitHub repository
    as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We now have a complete solution for efficiently managing our infrastructure
    using code. We demonstrated this through a very simple example. However, as you
    can imagine, everything is applicable to bigger infrastructure with a greater
    number of services. This section is almost over; we can now delete our stack to
    free up the resources that we are currently consuming. In the earlier part of
    the chapter, we did this using the web interface. As you can imagine, this can
    also be done easily using the following command-line interface:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note that if you have created a new `helloworld` stack for this example, then
    remove that too using the following command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Monitoring
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know by now, monitoring and measuring everything is an important
    aspect of a DevOps-driven organization. On the internet, you will find a number
    of well written blog posts and examples of how to efficiently monitor CloudFormation
    and Ansible. When working on monitoring CloudFormation, you will want to subscribe
    to an SNS topic for your stack creation to receive all events relating to your
    stack life cycle. It is also important to look out for CloudFormation stack creation
    failure. Ansible has a system of callbacks that will also give you a way to create
    some automation around the Ansible execution. Similarly to CloudFormation, receiving
    notifications when Ansible fails to run is important (it's even more important
    when Ansible is configured to run in pull mode).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to efficiently manage infrastructure by using
    code. We also explored CloudFormation, an AWS service that allows you to create
    templates for your different services in order to describe each AWS component
    used, as well as its configuration. In order to simplify the creation of those
    templates, we looked at a couple of options, ranging from CloudFormation designer,
    a tool with a graphic user interface, to Troposphere, a Python library. After
    that, we looked at configuration management, one of the most well-known aspects
    of the DevOps philosophy. To illustrate this topic, we looked at Ansible, one
    of the most popular configuration management solutions. We first looked at the
    different ways to use Ansible commands and ran simple commands against our infrastructure.
    We then looked at how to create playbooks, which allowed us to orchestrate the
    different steps to deploy our web server. Finally, we looked at how Ansible can
    be used in pull mode, which usually makes more sense when managing sizable infrastructure.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a good production environment that is ready to host any application,
    and we have seen how to architect it and monitor our servers. In Chapter 5, *Adding
    Continuous Integration and Continuous Deployment*, we will continue to use CloudFormation
    and Ansible, but in the context of software delivery: we will learn how to put
    in place continuous integration testing and continuous deployment.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does IaC stand for?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a simple Hello World application be deployed using the AWS CloudFormation
    Console?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List some of the popular SCM offerings. How is a GitHub account useful for source
    control management?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git (Local Version Control) package, clone your GitHub global repository
    created in the previous example and push your `helloworld-cf.template` to your
    GitHub repository.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Ansible? List some of its important characteristics.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to explore this topic in more detail, please visit the following links:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '*AWS CloudFormation details* at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Troposphere – Python library to create AWS CloudFormation descriptions* at [https://github.com/cloudtools/troposphere](https://github.com/cloudtools/troposphere)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible configuration management tool* at [https://docs.ansible.com/ansible](https://docs.ansible.com/ansible)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
