- en: Treating Your Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we familiarized ourselves with AWS. We also created
    an EC2 instance and deployed a Hello World web application onto it. However, to
    get there, we had to go through a number of steps to configure the instance and
    its security groups. Because we did that in a very manual fashion using the command-line
    interface, the steps that we went through will not be reusable or auditable, as
    you may recall from the first chapter when implementing DevOps best practices.
    Two key concepts that you should rely on as often as possible are source control
    (version control) and automation. In this chapter, we will explore how to apply
    those principles to our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In a cloud environment, where almost everything is abstracted and served through
    the intermediary of virtual resources, it is easy to imagine that code can describe
    the topology of a network and the configuration of a system. To go through that
    transformation, we will learn about two key concepts in an effective DevOps organization.
    The first one is commonly called **Infrastructure as Code** (**IAC**). This is
    the process of describing all your virtual resources in the form of codes. These
    resources may include virtual servers, load balancers, storage, the network layer,
    and so on. The second concept, which is very close to IAC, focuses further on
    system configuration and is called **configuration management**. Through configuration
    management systems, developers and system administrators have the ability to automate
    operating system configuration, package installation, and even application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going through that transformation is a crucial step for any DevOps-focused
    organization. By having the code to describe the different resources and their
    configurations, we will be able to use the same tools and processes as we do when
    developing applications. We will be able to use source control and make smaller
    changes to individual branches, as well as submitting pull requests, following
    standard review processes, and finally, testing changes before they are applied
    to our production environment. This will give us better clarity, accountability,
    and auditability for infrastructure changes. Because of that, we will also be
    able to manage a much bigger fleet of resources without necessarily needing more
    engineers or without spending a lot more time operating all the resources. This
    will also open up the door to further automation, as we will see with continuous
    deployment in Chapter 5, *Adding Continuous Integration and Continuous Deployment*.
    In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing your infrastructure with CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a configuration management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troposphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub links to find the codes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your infrastructure with CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CloudFormation introduces a new way to manage services and their configurations.
    Through the creation of JSON or YAML files, CloudFormation lets you describe the
    AWS architecture you would like to build. Once your files are created, you can
    simply upload them to CloudFormation, which will execute them, and automatically
    create or update your AWS resources. Most AWS-managed tools and services are supported.
    You can get the full list at [http://amzn.to/1Odslix](http://amzn.to/1Odslix).
    In this chapter, we will only look at the infrastructure we have built so far,
    but we will add more resources in the following chapters. After a brief overview
    of how CloudFormation is structured, we will create a minimal list stack to recreate
    the Hello World web application from [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*. After that, we will see two more options
    to create CloudFormation templates—the designer, which lets you visually edit
    your template in a Web GUI, and CloudFormer, a tool to generate templates from
    existing infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you would expect, you can access CloudFormation through the AWS console
    at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation),
    or by using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The service is organized around the concept of stacks. Each stack typically
    describes a set of AWS resources and their configuration in order to start an
    application. When working with CloudFormation, most of your time is spent editing
    those templates. There are different ways to get started with the actual editing
    of the templates. One of the easiest ways is to edit existing templates. AWS has
    a number of well-written examples available at [http://amzn.to/27cHmrb](http://amzn.to/27cHmrb).
    At the highest level, templates are structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `AWSTemplateFormatVersion` section is currently always `2010-09-09` and
    this represents the version of the template language used. This version is currently
    the only valid value. The `Description` section is there for you to summarize
    what the template does. The `Resources` section describes which AWS services will
    be instantiated and what their configurations are. When you launch a template,
    you have the ability to provide some extra information to CloudFormation, such
    as which SSH key-pair to use. For example, if you want to give SSH access to your
    EC2 instances, this kind of information goes into the `Parameters` section. The
    `Mappings` section is useful when you try to create a more generic template.
  prefs: []
  type: TYPE_NORMAL
- en: You can, for example, define which **Amazon Machine Image** (**AMI**) to use
    for a given region, so that the same template can be used to start an application
    in that AWS region. The `Conditions` section allows you to add conditional logic
    to your other sections (if statements, logical operators, and so on), while the
    `Metadata` section lets you add more arbitrary information to your resources.
    Finally, the `Outputs` section lets you extract and print out useful information
    based on the execution of your template, such as the IP address of the EC2 server
    created, for example. In addition to those examples, AWS also provides a couple
    of tools and services around CloudFormation template creation. The first tool
    you can use to create your templates is called CloudFormation Designer.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudFormation Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS CloudFormation Designer is a tool that lets you create and edit CloudFormation
    templates using a graphic user interface. Designer hides a lot of the complexity
    of editing a CloudFormation template using a standard text editor. You can access
    this directly at [https://console.aws.amazon.com/cloudformation/designer](https://console.aws.amazon.com/cloudformation/designer),
    or in the CloudFormation dashboard after you click on the Create Stack button,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/541decf4-3186-4bf3-9884-063c3c136b53.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: The workflow is fairly simple. You simply drag and drop resources from the left-hand
    side menu into a canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your resources are added, you can then connect them to other resources
    using the small dots surrounding each resource icon. In the preceding example,
    we are connecting an EC2 instance to its security group. There are a number of
    hidden gems that can help you when designing your template. You can right-click
    on resources and directly access the documentation for the CloudFormation resource
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be7eedd3-01e4-4e1d-abfb-8f7ec71abd1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When dragging a dot to connect two resources, a designer will highlight resources
    that are compatible with that connection. The editor on the bottom section of
    the designer supports auto completion using *Ctrl* + Spacebar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1e036f6-de32-47a4-bcbb-8d3d509870d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Once your template is complete, you can simply click on a button and go from
    designing your stack to launching it. The next tool we will look at is called
    **CloudFormer**.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CloudFormer is a tool that lets you create CloudFormation templates by looking
    at pre-existing resources. If you have a set of resources that you have already
    created on an ad hoc basis, as we have done so far in the book, then you can use
    CloudFormer to group them under a new CloudFormation template. You can then later
    customize the template that CloudFormer generates using a text editor or even
    CloudFormation designer, making it fit your needs. Unlike most AWS tools and services,
    CloudFormer isn''t completely managed by AWS; it''s a self-hosted tool that you
    can instantiate on demand using CloudFormation. To do so, follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [h](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[p](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[://c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[e](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[w](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[z](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[/c](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[u](https://console.aws.amazon.com/cloudformation)[d](https://console.aws.amazon.com/cloudformation)[f](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[r](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[i](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, scroll down the AWS console screen, selectCreate a Template from your Existing
    Resources option, and click on the Launch CloudFormer button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Select a sample template drop-down menu, choose the CloudFormer option
    and click on the Next button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/46751091-bae2-4af6-986f-5e86de98a60f.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: On that screen, at the top, you can provide a stack name (feel free to keep
    the default name, `AWSCloudFormer`) and in the bottom part, you are asked to provide
    three additional parameters, a Username, a Password and VPC Selection. This username
    and password will be used later to log into CloudFormer. Pick a username and a
    password, select the Default VPC, and click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, you can provide extra tags and more advanced options, but
    we will simply continue by clicking on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This brings us to the review page, where we will check the checkbox to acknowledge
    that this will cause AWS CloudFormation to create IAM resources. Click on the Create
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring us back to the main screen of the CloudFormation console, where
    we can see our AWS CloudFormer stack being created . Once the Status column goes
    from CREATE_IN_PROGRESS to CREATE_COMPLETE, select it and click on the Outputs
    tab at the bottom. At that point, you have created the resources needed to use
    CloudFormer. In order to create a stack with it, do the following: in the Outputs
    tab (which illustrates the Outputs section of CloudFormation), click on the website
    URL link. This will open up the CloudFormer tool. Log in using the username and
    password provided in the fourth step of the previous set of instructions, and
    you should see something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d45f2219-b0a7-44cd-ac34-1369a16757b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the AWS region where you want to create the template and then click
    on the Create Template button. The following screen will then appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1bc2ff71-ff2a-4068-861d-f15ff6855af6.png)'
  prefs: []
  type: TYPE_IMG
- en: Follow the workflow proposed by the tool to select the different resources that
    you want for your CloudFormation template, as far as the last step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, you will be able to download the generated template or save it directly
    in S3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CloudFormation template generated by CloudFormer will usually need a bit
    of editing, as you will often want to create a more flexible stack with input
    parameters and an Outputs section.
  prefs: []
  type: TYPE_NORMAL
- en: Recreating our Hello World example with CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designer and CloudFormer are two very useful tools when you are in the process
    of architecting your infrastructure and trying to add source control to your design.
    That said, whenever you wear your DevOps hat, it's a different story. Using those
    tools markedly reduces the added value that CloudFormation provides by using the
    JSON format. If you got a chance to read some of the templates available, or tried
    to use CloudFormer on your existing infrastructure, you probably noticed that
    raw CloudFormation templates tend to be fairly long and not **Don't Repeat Yourself**
    (**DRY**).
  prefs: []
  type: TYPE_NORMAL
- en: From a DevOps perspective, one of the most powerful aspects of CloudFormation
    is the ability to write code to dynamically generate those templates. To illustrate
    that point, we are going to turn to Python, and a library called `troposphere`,
    to generate our Hello World CloudFormation template.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a number of more advanced tools to assist with the creation of
    CloudFormation templates. If you plan on using other third-party services in addition
    to AWS, you can take a look at Terraform from Hashicorp (available at [https://www.terraform.io](https://www.terraform.io)),
    for example, which handles a number of other cloud providers and services in addition
    to CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: Using Troposphere to create a Python script for our template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will first install the `troposphere` library. Again, we are demonstrating
    all of the outputs from a CentOS 7.x-based Linux distribution, but the process
    applies equally to all of the supported platforms mentioned. The following is
    the command to install the `troposphere` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One known issue with the Troposphere is the upgraded version of `setuptools`.
    If you come across the following issue, then the solution is to upgrade `setuptools`
    using the `pip install -U setuptools` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have run the preceding command, you may encounter the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to fix the error, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is complete, you can then create a new file called `helloworld-cf-template.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our file by importing a number of definitions from the `troposphere`
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to define a first variable that will make editing the code
    easier for the remainder of the book. This is because we will create new scripts
    by building on this initial template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From a code standpoint, the first thing we will do is initialize a `Template`
    variable. By the end of our script, the template will contain the entire description
    of our infrastructure and we will be able to simply print its output to get our
    CloudFormation template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout this book, we will create and run several CloudFormation templates concurrently.
    To help us identify what''s in a given stack, we have the ability to provide a
    description. After the creation of the template, add the description as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we launched EC2 instances using the web command-line interface, we selected
    which key-pair to use in order to gain SSH access to the host. In order to not
    lose this ability, the first thing our template will have is a parameter to offer
    the CloudFormation user the ability to select which key-pair to use when launching
    the EC2 instance. To do that, we are going to create a `Parameter` object and
    initialize it by providing an identifier, a description, a parameter type, a description
    of the parameter type, and a constraint description to help make the right decision
    when we launch the stack. In order for this parameter to exist in our final template,
    we will also use the `add_parameter()` function defined in the template class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we will look at is the security group. We will proceed exactly
    as we did for our `KeyPair` parameter. We want to open up `SSH/22` and `TCP/3000`
    to the world. Port `3000` was defined in the `ApplicationPort` variable declared
    earlier. In addition, this time, the information defined isn''t a parameter like
    before, but a resource. Consequently, we will add that new resource using the
    `add_resource()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our next section, we will replace the need to log on to our EC2 instance
    and install the `helloworld.js` file and its `init` scripts by hand. To do so,
    we will take advantage of the `UserData` features that EC2 offers. When you create
    an EC2 instance, the `UserData` optional parameter gives you the ability to provide
    a set of commands to run once the virtual machine has spawned up (you can read
    more on this topic at [http://amzn.to/1VU5b3s](http://amzn.to/1VU5b3s)). One of
    the constraints of the `UserData` parameter is that the script must be base64-encoded
    in order to be added to our API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a small script to reproduce the steps that we went through
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application.* Here, we will encode, deploy our first web application deployment
    step in base-64 and store it in a variable called `ud`. Note that installing the
    application in the `home` directory of `ec2-user` isn''t very clean. For now,
    we are trying to stay consistent with what we did in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying
    Your First Web Application*. We will fix that in Chapter 5, *Adding Continuous
    Integration and Continuous Deployment*, as we improve our deployment system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will now focus on the main resource of our template, which is our EC2 instance.
    The creation of the instance requires providing a name for identifying the resource,
    an image ID, an instance type, a security group, the key-pair to use for the SSH
    access, and the user data. In order to keep things simple, we will hardcode the
    AMI ID (`ami-cfe4b2b0`) and instance type (`t2.micro`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining pieces of information needed to create our EC2 instances are
    the security group information and the `KeyPair` name, which we collected previously
    by defining a parameter and a resource. In CloudFormation, you can refer to pre-existing
    subsections of your template by using the `Ref` keyword. In Troposphere, this
    is done by calling the `Ref()` function. As before, we will add the resulting
    output to our template with the help of the `add_resource` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last section of our script, we will focus on producing the `Outputs`
    section of the template that gets populated when CloudFormation creates a stack.
    This selection allows you to print out useful information that was computed during
    the launch of the stack. In our case, there are two useful pieces of information—the
    URL to access our web application, and the public IP address of the instance,
    so that we can SSH into it if we want to. In order to retrieve such information,
    CloudFormation uses the `Fn::GetAtt ` function. In Troposphere, this is translated
    into the  `GetAtt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At that point, we can make our script output the final result of the template
    we generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The script is now complete. We can save this and quit our editor. The file created
    should look like the file at the following link:  [https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run our script, giving it the proper permissions and generating
    the CloudFormation template by saving the output of our script in a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`cloud-init` is a set of Python scripts compatible with most Linux distributions
    and cloud providers. This complements the `UserData` field by moving most standard
    operations, such as installing packages, creating files, and running commands
    into different sections of the template. This book doesn''t cover that tool, but
    if your CloudFormation templates rely heavily on the `UserData` field, take a
    look at it. You can get its documentation at [http://bit.ly/1W6s96M](http://bit.ly/1W6s96M).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the stack in the CloudFormation console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we can launch our template using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser with the following link: [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
    Click on the Create Stack button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, we will upload our newly generated template, `helloworld-
    cf.template`, by selecting Upload a template to Amazon S3, and then browsing to
    select our `helloworld-cf.template` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then pick a stack name, such as `HelloWorld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the stack name, we can see the Parameters section of our template in action.
    CloudFormation lets us pick which SSH key-pair to use. Select your key-pair using
    the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, we have to ability the add optional tags to our resources;
    in the Advanced section, we can see how we can potentially integrate CloudFormation
    and SNS, make decisions on what to do when a failure or a timeout occurs, and
    even add a stack policy that lets you control who can edit the stack, for example.
    For now, we will simply click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This leads us to the review screen where we can verify the information selected
    and even estimate how much it will cost to run that stack. Click on the Create
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will bring us to the main CloudFormation console. On that screen, we are
    able to see how our resources are created in the Events tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the creation of the template is complete, click on the Outputs tabs, which
    will reveal the information we generated through the Outputs section of our template,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59eb8843-7aa6-4dbb-adaf-f1c0f329a337.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the link in the value of the WebUrl key, which will open our Hello
    World page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding our template to a source control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have tested our template and know it's working, we are going to
    commit it to our source control system. This will allow us to keep track of changes,
    making it possible to treat our infrastructure code at the same standard as our
    application code (more on this in Chapter 5, *Adding Continuous Integration and
    Continuous Deployment*).
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we will rely on Git. AWS has a service called AWS CodeCommit ([http://amzn.to/2tKUj0n](http://amzn.to/2tKUj0n)),
    which lets you manage Git repositories easily. However, because this service is
    a lot less popular than GitHub ([https://github.com](https://github.com/)), we
    will instead use the latter. If you don't have an account for GitHub yet, start
    by signing up for the service—it's completely free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged into GitHub, create a new repository for the CloudFormation template:'
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, open [https://github.com/new](https://github.com/new).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the new repository the following: `EffectiveDevOpsTemplates`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Initialize this repository with a README checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, click on the Create repository button, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91f23a82-9d36-415c-a6ca-a84e91b880d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once your repository is created, you will want to clone it into your computer.
    For that, you need to have Git installed (search on Google for instructions on
    how to install Git for your operating system if you don''t have it yet). For CentOS,
    you just need to run `yum -y install git`, as the Git package is a part of Linux
    distribution now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the repository is cloned, we will go into it and copy the template
    previously created in the new GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add and commit that new file to our project and push it to
    GitHub as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Monorepo versus multirepo: **When managing your code, there are two common
    approaches to organizing your code repositories. You can create one repository
    for each project you have, or decide to put your entire organization code under
    a single repository. We will choose the simplest option for this book, which is
    one repository per project, but with the recent releases of several open source
    projects, such as Bazel from Google, Buck from Facebook, or Pants from Twitter,
    using a monorepo becomes a very compelling option as it avoids juggling between
    multiple repositories when making big changes to your infrastructure and services
    simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating our CloudFormation stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest benefits of using the CloudFormation template to manage our
    resources is that the resources created from CloudFormation are tightly coupled
    to our stack. If we want to make a change to our stack, we can update the template
    and apply the change to our existing CloudFormation stack. Let's see how that
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our Python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `helloworld-cf-template.py` script is fairly basic. At this point, we are
    only taking advantage of Python as far as using the `troposphere` library to easily
    generate JSON output in a more pleasant way than if we had to write it by hand.
    Of course, you might already realize that we are barely scratching the surface
    of what we can do when we have the ability to write scripts to create and manage
    infrastructures. The following section is a simple example that will let us write
    a couple more lines of Python and illustrate the concept of updating a CloudFormation
    stack, while taking advantage of more services and external resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security groups we created in our previous example open up two ports to
    the world: `22` (SSH) and `3000` (the web application port). We could try to harden
    one aspect of our security by only allowing our own IP to use SSH. This means
    changing the **Classless Inter-Domain Routing** (**CIDR**) IP information in our
    Python script on the security group that handles the port `22` traffic. There
    are a number of free services online that will let us know what our public IP
    is. We are going to use one of these, available at [https://api.ipify.org](https://api.ipify.org/).
    We can see it in action with a simple `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to take advantage of that service in our script. One of the reasons
    for using this particular service is that it has been packaged into a Python library.
    You can read more on this at [https://github.com/rdegges/python-ipify](https://github.com/rdegges/python-ipify).
    You can first install that library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you come across some `pip` related errors, as shown in the following
    code block, the fix would be to downgrade the `pip` version, install `ipify`,
    and then upgrade the `pip` version again to the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding error can be fixed with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our script requires a CIDR. In order to convert our IP address to CIDR, we
    will also install another library, called `ipaddress`. The main advantage of combining
    these libraries is that we don''t have to worry about handling IPv4 versus IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once those libraries are installed, reopen `helloworld-cf-template.py` in your
    editor. At the top of our script, we are going to import the libraries, then,
    after the `ApplicationPort` variable definition, we will define a new variable
    called `PublicCidrIp` and, combining the two libraries mentioned previously, we
    can extract our CIDR as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can change the `CidrIp` declaration for the SSH group rule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can now save these changes. The file created should look like the file at
    [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now generate a new `diff` command to visually verify the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our CIDR IP is now correctly restricting the connection to our
    IP. We can now apply that change.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having generated the new JSON CloudFormation template, we can get in the CloudFormation
    console and update the stack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloWorld` stack that we created previously .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Actions drop-down menu, and then choose the Update Stack option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the `helloworld-cf-v2.template` file by clicking the Browse button, selecting
    the file, and then  clicking on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This brings us to the next screen that lets us update the details of our stack.
    In our case, nothing has changed in the parameters, so we can continue by clicking
    on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next screen as well, since we simply want to see the effect of our IP
    change, we can click on the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f0b5618-87d5-41b5-882d-2290b9798910.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This brings us to the review page, where, after a couple of seconds, we can
    see CloudFormation giving us a preview of our change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f7c9956-37d8-4a3e-8888-dc1fcb625efb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the only change will be an update on the security group. Now
    click on the Update button. This will bring us back to the CloudFormation template,
    where we will see the change being applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this particular example, AWS is able to simply update the security group
    to take our change into account. We can verify the change by extracting the physical
    ID from either the review page, or in the Resources tab back in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Change sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our template only includes a web server and a security group that makes updating
    CloudFormation a fairly harmless operation. Furthermore, our change was fairly
    trivial, as AWS could simply update the existing security group, as opposed to
    having to replace it. As you can imagine, as the architecture becomes more and
    more complex, so does the CloudFormation template. Depending on the update you
    want to perform, you might encounter unexpected changes when you review the change
    set in the final step of updating a template. AWS offers an alternative and safer
    way to update templates; this feature is called **change sets** and is accessible
    from the CloudFormation console. Follow this procedure in order to use change
    sets to review the updates, followed by execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloWorld` stack that we previously created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Actions drop-down menu and then click the Create Change Set For
    Current Stack option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, you can follow the same steps you took to create a simple update
    in the *Updating our stack* section. The main difference happens on the last screen,
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0deeb19b-d946-4819-97ec-0843960fdce0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike the regular stack updates, change sets have a strong emphasis on giving
    you the ability to review a change before applying it. If you are satisfied with
    the changes displayed, you have the ability to execute the update. Lastly, when
    using a change set to update your stack, you can easily audit recent changes using
    the Change Sets tab of your stack in the CloudFormation console. Finally, we will
    commit the changes to the Troposphere script with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Deleting our CloudFormation stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw how CloudFormation was able to update resources
    as we update our template. The same goes when you want to remove a CloudFormation
    stack and its resources. In a couple of clicks, you can delete your template and
    the various resources that were created at launch time. From a best practice standpoint,
    it is highly recommended to always use CloudFormation to make changes to your
    resources that were previously initialized with CloudFormation, including when
    you don't need your stack any more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting a stack is very simple, and you should proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloWorld` stack that we created previously
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Actions drop-down menu, and then click on the Delete Stack option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As always, you will be able to track completion in the Events tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97b24707-f9c2-4c6e-be1e-f1ed2aa3b374.png)'
  prefs: []
  type: TYPE_IMG
- en: CloudFormation has a unique place in the AWS ecosystem. As complex as they are,
    most architectures can be described and managed through CloudFormation, allowing
    you to keep tight control over your AWS resources creation. While CloudFormation
    does a great job of managing the creation of resources, it doesn't always make
    things easy. This is especially the case when you want to make simple changes
    on services such as EC2\. Because CloudFormation doesn't keep track of the state
    of the resources once they are launched, the only reliable way to update an EC2
    instance is, for example, to recreate a new instance and swap it with the existing
    instance when it is ready. This creates somewhat of an immutable design (assuming
    that you don't run any extra commands when the instance is created). This may
    be an attractive architecture choice and, in some cases, it may take you a long
    way, but you may wish to have the ability to have long-running instances where
    you can, as this allows you to quickly and reliably make changes through a controlled
    pipeline, like we did with CloudFormation. This is what configuration management
    systems excel at.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a configuration management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration management systems are probably the most well known components
    of classic DevOps-driven organizations. Present in most companies (including in
    the enterprise market), configuration management systems are quickly replacing
    home-grown Shell, Python, and Perl scripts. There are many reasons why configuration
    management systems should be a part of your environment. One reason is that they
    offer domain-specific languages, which improves the readability of the code, and
    they are tailored to the specific needs that arise in organizations when trying
    to configure systems. This results in a lot of useful built-in features. Furthermore,
    the most common configuration management tools have a big and active user community,
    which often means that you will be able to find existing code for the system you
    are trying to automate.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most popular configuration management tools include **Puppet**,
    **Chef**, **SaltStack**, and **Ansible**. While all of those options are fairly
    good, this book will focus on Ansible, the easiest of the four tools mentioned.
    There are a number of key characteristics that make Ansible a very popular and
    easy-to-use solution. Unlike other configuration management systems, Ansible is
    built to work without a server, a daemon, or a database. You can simply keep your
    code in source control and download it on the host whenever you need to run it
    or use a push mechanism through SSH. The automation code you write is in YAML
    static files, which makes the learning curve a lot less steep than some of the
    other alternatives that use Ruby or specific DSL. In order to store our configuration
    files, we will instead rely on our version control system (in our case, GitHub.)
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS OpsWorks and its Chef integration**: While Amazon hasn''t really released
    a service dedicated to configuration management, it supports Chef and Puppet within
    the OpsWorks service. Unlike the services we have explored so far in the book,
    OpsWorks aims at being a *complete application life cycle, including resource
    provisioning, configuration* *management, application deployment, software updates,
    monitoring, and access control**. *If you are willing to sacrifice some flexibility
    and control, OpsWorks might be able to handle what you need in order to run a
    simple web application. You can learn more about this at [http://amzn.to/1O8dTsn](http://amzn.to/1O8dTsn).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Begin by installing Ansible on your computer. After doing this, create an EC2
    instance that will let us illustrate the basic usage of Ansible. After that, we
    will work on recreating the Hello World Node.js application by creating and executing
    what Ansible calls a playbook. We will then look at how Ansible can run in pull
    mode, which offers a new approach to deploying changes. Finally, we will look
    at replacing the `UserData` block in our CloudFormation template with Ansible
    to combine the benefits of both CloudFormation and our configuration management
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is fairly easy to use and well documented throughout the web. This book
    will cover enough to get you started and up to speed on simple configurations,
    such as the one we need in our examples. However, you might be interested in spending
    a bit more time learning about Ansible in order to be really efficient with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible on your computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, Ansible is a really simple application with very few dependencies.
    You can install Ansible on your computer using your operating system package manager,
    or through `pip`, as Ansible is written in Python. We will be demonstrating all
    of the outputs from a CentOS 7.x-based Linux distribution, but the process applies
    equally to all supported platforms. (For more information, refer to the following
    link in order to find and install Ansible binaries on your operating system: [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine).) The
    following command will install a number of binaries, libraries, and Ansible modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that no daemon or database is installed at this point. This is because,
    by default, Ansible relies on static files and SSH in order to run. At this point,
    we are ready to use Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Creating our Ansible playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the basic functionalities of Ansible, we are going to start by
    re-launching our Hello World application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to create a stack using the web interface.
    As you would expect, it is also possible to launch a stack using the command-line
    interface. Go into the `EffectiveDevOpsTemplates` directory where you previously
    generated the `helloworld-cf-v2.template` file and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our instance will soon be ready. We can now bootstrap our environment by creating
    a workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Ansible repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Ansible, our first goal is to be able to run commands on remote hosts.
    In order to do that efficiently, we need to configure our local environment. Because
    we don't want to have to redo those steps repeatedly, and because, ultimately,
    we want to source-control everything, we will create a new Git repository. To
    do that, we will repeat the same steps that we used when we created our `EffectiveDevOpsTemplate`
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged into GitHub, create a new repository for the CloudFormation template
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, open this link: [https://github.com/new](https://github.com/new).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the new repository the name `ansible`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b43c4445-ba61-459d-96a5-ad3d035a4b97.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the Initialize this repository with a README checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the Create repositorybutton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your repository is created, clone it onto your computer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the repository is cloned, we will go into this and copy the template 
    created previously in the new GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At its base, Ansible is a tool that can run commands remotely on the hosts
    in your inventory. The inventory can be managed manually by creating an `INI`
    file where you list all your hosts and/or IPs. It can also be managed dynamically
    if it can query an API. As you can imagine, Ansible is perfectly capable of taking
    advantage of the AWS API in order to fetch our inventory. To do so, we will download
    a Python script from the official Ansible Git repository and give the execution
    permissions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can start testing this Python script, we also need to provide a configuration
    for it. Create a new file in the same directory and call it `ec2.ini`. In this
    file, we will put the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, you can finally validate that the inventory is working by
    executing the `ec2.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should return a big nested JSON of the different resources found
    on your AWS account. Among these is the public IP address of the EC2 instance
    that we created in the previous section. The last step in our bootstrapping is
    to configure Ansible itself, such that it knows how to get the inventory of our
    infrastructure; which user to use when it tries to SSH into our instances; how
    to become a root; and so on. We will create a new file in the same location and
    call it `ansible.cfg`. Its content should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At that point, we are ready to start running Ansible commands. Ansible has a
    few commands and some simple concepts. We will first look at the `ansible` command
    and the concept of modules.
  prefs: []
  type: TYPE_NORMAL
- en: Executing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ansible` command is the main command that drives the execution of the different
    modules on the remote hosts. Modules are libraries that can be executed directly
    on remote hosts. Ansible comes with a number of modules, as listed at [http://bit.ly/24rU0yk](http://bit.ly/24rU0yk).
    In addition to the standard modules, you can also create your own custom modules
    using Python. These are the modules for most common use cases and technologies.
    The first module we will see is a simple module called `ping`, which tries to
    connect to a host and returns `pong` if the host is usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module documentation can also be accessed using the `ansible-doc` command,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ ansible-doc <Module-Name>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ ansible-doc ping`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `ping` is one of the Ansible module names.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating our Ansible playground section, we created a new EC2 instance
    using CloudFormation. So far, we haven''t looked up the IP address for this. Using
    Ansible and the `ping` module, we will discover that information. As mentioned
    before, we need to be in the `ansible` directory in order to run the `ansible`
    command. The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Ansible was able to find our EC2 instance by querying the AWS
    EC2 API. The newly created instance is now ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring SSH**: As Ansible relies heavily on SSH, it is worth dedicating
    a bit of time to configuring SSH through the `$HOME/.ssh/config` file. For instance,
    you can use the following options to avoid having to specify `--private-key` and
    `-u` in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IdentityFile ~/.ssh/EffectiveDevOpsAWS.pem`'
  prefs: []
  type: TYPE_NORMAL
- en: '`User ec2-user StrictHostKeyChecking no`'
  prefs: []
  type: TYPE_NORMAL
- en: '`PasswordAuthentication no`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ForwardAgent yes`'
  prefs: []
  type: TYPE_NORMAL
- en: Once configured, you won't need to provide the `--private-key` option to Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Running arbitrary commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ansible` command can also be used to run arbitrary commands on remote
    servers. In the following example, we will only run the `df` command on hosts
    matching `18.206.223.*`  for their public IP address (you will need to adapt this
    command to match your instance public IP, as returned in the `ping` command in
    the previous example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a basic understanding of how Ansible works, we can start combining
    calls to different Ansible modules to put in place for automation. This is called
    creating a **playbook**.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks are the files that contain Ansible's configuration, deployment, and
    orchestration language. By creating those files, you sequentially define the state
    of your systems, from the OS configuration down to application deployment and
    monitoring. Ansible uses YAML, which is fairly easy to read. For that reason,
    an easy way to get started with Ansible, similarly to what we did with CloudFormation, is
    to look at some examples inside the official Ansible GitHub repository, available
    at [https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples).
    Alternatively, you can even look in my repository, which makes it fairly simple
    and easy to understand playbooks, and which can be found at  [https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)
    for the book *Automation with Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a number of best practices on their website, available at [http://bit.ly/1ZqdcLH](http://bit.ly/1ZqdcLH).
    One emphasis in their documentation is on using roles. One crucial way to organize
    your playbook content is Ansible's *roles* organization feature, which is documented
    as part of the main playbooks page. Creating roles is a key component in making
    Ansible code sharable and modular enough so that you can reuse your code across
    services and playbooks. To demonstrate a proper structure, we are going to create
    a role that our playbook will then call.
  prefs: []
  type: TYPE_NORMAL
- en: Creating roles to deploy and start our web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use roles to recreate the Hello World stack we made previously using
    the `UserData` block of CloudFormation. If you recall, the `UserData` section
    looked roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You will notice three different types of operation in the preceding script.
    We are first preparing the system to run our application. To do that, in our example,
    we are simply installing a Node.js package. Next, we copy the different resources
    needed to run the application. In our case, this is the JavaScript code and the
    upstart configuration. Finally, we start the service. As always when doing programming,
    it is important to keep the code DRY. If deploying and starting our application
    is very unique to our Hello World project, installing Node.js likely isn't. In
    order to make the installation of Node.js a reusable piece of code, we are going
    to create two roles—one to install Node.js, and one to deploy and start the Hello
    World application.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Ansible expects to see roles inside a `roles` directory at the
    root of the Ansible repository. So, the first thing we need to do is to go inside
    the `ansible` directory that we created under the *Creating our Ansible repository* section.
    Create the `roles` directory inside, and `cd` the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create our roles. Ansible has an `ansible-galaxy` command that can
    be used to initialize the creation of a role. The first role we will look into
    is the role that will install Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As briefly mentioned, Ansible, like most other configuration management systems,
    has a strong support community who share roles online through [h](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[p](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[://g](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[x](https://galaxy.ansible.com/)[y](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[n](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[i](https://galaxy.ansible.com/)[b](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[e](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[c](https://galaxy.ansible.com/)[o](https://galaxy.ansible.com/)[m](https://galaxy.ansible.com/)[/](https://galaxy.ansible.com/).
    In addition to using the `ansible-galaxy` command to create the skeleton for new
    roles, you can also use `ansible-galaxy` to import and install community supported
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a `nodejs` directory, and a number of sub-directories that will
    let us structure the different sections of our role. We will enter this directory
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The most important directory inside the `nodejs` directory is the one called
    `tasks`. When Ansible executes a playbook, it runs the code present in the `tasks/main.yml`
    file. Open the file with your favorite text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first open `tasks/main.yml`, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The goal of the `nodejs` role is to install Node.js and `npm`. To do so, we
    will proceed similarly to how we did with the `UserData` script, and use the `yum` command
    to perform those tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing a task in Ansible, you sequence a number of calls to various Ansible
    modules. The first module we are going to look at is a wrapper around the `yum`
    command. The documentation on it is available at [http://bit.ly/28joDLe](http://bit.ly/28joDLe).
    This will let us install our packages. We are also going to introduce the concept
    of loops. Since we have two packages to install, we will want to call the `yum`
    module twice. We will use the operator''s `with_items`**.** All Ansible codes
    are written in YAML, which is very easy to start with and use. After the initial
    three dashes and comments, which indicate the start of a YAML file, we are going
    to call the `yum` module in order to install our packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Whenever Ansible runs that playbook, it will look at packages installed on the
    system. If it doesn't find the `nodejs` or `npm` packages, it will install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your file should look like the example available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml).
    This first role is complete. For the purpose of this book, we are keeping the
    role very simple, but you can imagine how, in a more production-type environment,
    you might have a role that will install specific versions of Node.js and `npm`,
    fetch the binaries directly from [https://nodejs.org/en/](https://nodejs.org/en/),
    and maybe even install specific dependencies. Our next role will be dedicated
    to deploying and starting the Hello World application that we built previously.
    We are going to go one directory up back into the `roles` directory, and call
    `ansible-galaxy` one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Like before, we will now go inside the newly created `helloworld` directory
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will explore some of the other directories present. One of the
    sub-directories that was created when we ran the `ansible-galaxy` command was
    the directory called `files`. Adding files to that directory will give us the
    ability to copy files on the remote hosts. To do so, we are first going to download
    our two files in this directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use task files to perform the copy on the remote system. Open the
    `tasks/main.yml` file and, after the initial three dashes and comments, add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We are taking advantage of the copy module documented at [h](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[p](http://bit.ly/1WBv08E)[://b](http://bit.ly/1WBv08E)[i](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[.](http://bit.ly/1WBv08E)[l](http://bit.ly/1WBv08E)[y](http://bit.ly/1WBv08E)[/1W](http://bit.ly/1WBv08E)[B](http://bit.ly/1WBv08E)[v](http://bit.ly/1WBv08E)[08E](http://bit.ly/1WBv08E)
    to copy our application file in the home directory of the `ec2-user`. On the last
    line of that call, we add a notify option at the end (note how the `notify` statement
    is aligned with the call to the copy module). Notify actions are triggers that
    can be added at the end of each block of tasks in a playbook. In this example,
    we are telling Ansible to call the restart `helloworld` directive if the file
    `helloworld.js` changed, and not to perform a restart if nothing is changed in
    the code (we will define how to do a restart of the `helloworld` application in
    a different file a bit later).
  prefs: []
  type: TYPE_NORMAL
- en: One of the big differences between CloudFormation and Ansible is that Ansible
    is expected to run multiple times throughout the lifetime of your systems. A lot
    of the functionalities built into Ansible are optimized for long-running instances.
    As such, the `notify` option makes it easy to trigger events when a system changes
    state. Similarly, Ansible will know to stop the execution when an error encountered
    prevents outages as far as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have copied our application file, we can add our second file, the
    `upstart` script. After the previous call to copy the `helloword.js` file, we
    are going to add the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The last task we need to perform is to start our service. We will use the `service`
    module for that. The module documentation is available at [http://bit.ly/22I7QNH](http://bit.ly/22I7QNH):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Our task file is now completed. You should end up with something resembling
    the sample available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Having finished our task file, we are going to move on to the next file, which
    will give Ansible knowledge of how and when to restart `helloworld`, as called
    out in the `notify` parameter of our task. These types of interaction are defined
    in the `handler` section of the role. We are going to edit the `handlers/main.yml`
    file. Here too, we are going to use the `service` module. The following is a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `main.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here; we are using the same module we previously used to manage
    the service. We need one more step in our role. In order for the `helloworld`
    role to work, the system needs to have Node.js installed. Ansible supports the
    concept of role dependencies. We can explicitly tell that our `helloworld` role
    depends on the `nodejs` role we previously created, so that, if the `helloworld`
    role is executed, it will first call the `nodejs` role and install the necessary
    requirements to run the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `meta/main.yml` file. This file has two sections. The first one, under
    `galaxy_info`, lets you fill in the information on the role you are building.
    If you wish, you can ultimately publish your role on GitHub and link it back into
    `ansible-galaxy` to share your creation with the Ansible community. The second
    section at the bottom of the file is called `dependencies`and this is the one
    we want to edit to make sure that `nodejs` is present on the system prior to starting
    our application. Remove the square brackets ([]) and add an entry to call `nodejs`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Your file should look like the sample available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml).
    This concludes the creation of the code for the role. From a documentation standpoint,
    it is good practice to also edit `README.md`. Once done, we can move on to creating
    a playbook file that will reference our newly created role.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the playbook ﬁle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the top level of our Ansible repository (two directories up from the `helloworld`
    role), we are going to create a new file called `helloworld.yml`. In this file,
    we are going to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This basically tells Ansible to execute the `helloworld` role onto the hosts
    listed in the `target` variable, or `localhost` if the target isn't defined. The
    `become` option will tell Ansible to execute the role with elevated privileges
    (in our case, `sudo`). At this point, your Ansible repository should look like
    the example at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible).
    We are now ready to test our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in practice, on a bigger scale, the roles sections could include
    more than a single role. If you deploy multiple applications or services to a
    target, you will often see playbook looking like this. In later chapters, we will
    see more examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Executing a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The execution of playbooks is done using the dedicated `ansible-playbook` command.
    This command relies on the same Ansible configuration file that we used previously,
    and therefore, we want to run the command from the root of our Ansible repository.
    The syntax of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first run the following command (adapt the value of the `private-key`
    option):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The option `-e` (or `--extra-vars`) allows us to pass extra options for execution.
    In our case, we are defining the `target` variable (which we declared in the `hosts`
    section of our playbook) to be equal to `ec2`. This first `ansible-playbook` command
    will tell Ansible to target all EC2 instances. The `--list-hosts` option will
    make Ansible return a list of hosts that match the hosts criteria, but it won''t
    actually run anything against those hosts. The output of the command will be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `list-hosts` option is a good way to verify your inventory and, on more
    complex playbooks with more specific host values, to verify which hosts would
    run actual playbooks, allowing you to verify that they are targeting the hosts
    you expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know which hosts will be impacted if we were to use this value for the
    target. The next thing we want to check is what will happen if we run our playbook.
    The `ansible- playbook` command has an option `-C` (or `--check`) that will try
    to predict the change a given playbook will make; this is sometimes also called
    **dry-run** mode in Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that command will execute our playbook in dry-run mode. Through that
    mode, we can ensure that the proper tasks will be executed. Because we are in
    dry-run mode, some of the modules don''t really find everything they need in order
    to simulate how they would run. This is the reason why we sometimes see service
    start errors at the end of the service module. If you see this, then don''t worry,
    it will get executed when the packages are installed in the real-mode. Having
    verified the hosts and code, we can finally run `ansible-playbook` and execute
    our changes in a real-mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is very similar to the `--check` command, except that this time,
    the execution is performed in real-mode. Our application is now installed and
    configured, and we can verify that it is running correctly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We were able to reproduce what we did previously with CloudFormation using
    Ansible. Now that we have tested our first playbook, we can commit our changes.
    We will do that in two commits to break down the initialization of the repository
    and the creation of the role. From the root of your Ansible repository, run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Canary-testing changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great benefits of using Ansible to manage services is that you can
    easily make changes to your code and quickly push the change. In some situations
    where you have a big fleet of services managed by Ansible, you may wish to push
    out a change only to a single host to make sure things are how you expect them
    to be. This is often called **canary testing**. With Ansible, doing this is really
    easy. To illustrate that, we are going to open the `roles/helloworld/files/helloworld.js` file
    and then simply change the response on line 11 from `Hello World` to `Hello World,
    Welcome again`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, and then run `ansible-playbook` again. Do this with the `--check`
    option first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, Ansible detects only two changes. The first one overwrites the application
    file and the second one executes the `notify` statement, which means restarting
    the application. Seeing that it is what we expect, we can run our playbook without
    the `--check` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the same output as in our previous command, but this time the
    change is in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Our change was very simple, but if we had done this by updating our CloudFormation
    template, CloudFormation would have had to create a new EC2 instance to make it
    happen. Here, we simply updated the code of the application and pushed it through
    Ansible on the target host. We will now revert this change locally in Git as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We will demonstrate this by removing the changes from the EC2 instance as we
    illustrate a new concept. In the next section, we will be running Ansible asynchronously
    in a reverse mode (in this case, in pull mode).
  prefs: []
  type: TYPE_NORMAL
- en: '**The sooner, the better: **Being able to push changes in seconds instead of
    minutes may seem like a small win, but it isn''t. Speed matters; it is what sets
    apart successful start-ups and technologies. The ability to deploy new servers
    in minutes instead of days is a big factor in cloud adoption. Similarly, the recent
    success of containers, as we will see later in the book, is also likely driven
    by the fact that it only takes seconds to run a new container, while it still
    takes minutes to start a virtual server.'
  prefs: []
  type: TYPE_NORMAL
- en: Running Ansible in pull mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to instantly make a change like we just did is a very valuable
    feature. We could easily and synchronously push the new code out and verify that
    the Ansible execution was successful. On a larger scale, while being able to change
    anything across a fleet of servers remains as valuable as in our example, it is
    also sometimes a bit trickier. The risk with making changes that way is that you
    have to be very disciplined with regards to not pushing changes to only a subset
    of hosts, and forgetting other hosts that are also sharing the role that just
    got updated. Otherwise, the increasing number of changes between the Ansible configuration
    repository and the running servers quickly makes running Ansible a riskier operation.
    For those situations, it is usually preferable to use a pull mechanism that will
    automatically pull in the changes. Of course, you don't have to choose one or
    the other—it is easy to configure both push and pull mechanisms to deploy changes.
    Ansible provides a command called `ansible-pull`, which, as its name suggests,
    makes it easy to run Ansible in pull mode. The `ansible-pull` command works very
    much like `ansible-playbook`, except that it starts by pulling your code from
    your GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git and Ansible on our EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we need to be able to run Ansible and Git remotely, we first need to
    install those packages on our EC2 instance. For now, we will do that by manually
    installing those two packages. We will implement a reusable solution later in
    this chapter. Since Ansible is a perfect tool for running remote commands and
    this has a module to manage most common requirements such as installing packages,
    instead of logging in on the host through `ssh` and running some commands, we
    are going to use Ansible to push out those changes. We will install Git and Ansible
    from the EPEL `yum` repository. This will require running commands as **root**,
    which you can do with the help of the `become` option. After adapting the IP address
    of your EC2 instance, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: With `ansible-pull`, our goal is for Ansible to apply the change locally. We
    can make a change to our Ansible repository in order to optimize this operation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ansible to run on localhost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `ansible-pull` relies on Git to locally clone the repository and execute
    it, we don''t need the execution to happen over SSH. Go to the `root` directory
    of your Ansible repository to create a new file. The file should be called `localhost`
    and it should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, what we are doing is creating a static inventory and asking `ansible`
    to run commands in local mode (as opposed to using SSH) when the target host is
    `localhost`. We can save the changes and commit the new file to GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Adding a cron job to our EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to create a cron tab entry to periodically call `ansible-pull`.
    Here, too, we will rely on Ansible to create our cron job remotely. Run the following
    command by adapting the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we are telling Ansible to use the `cron` module targeting
    our `ec2` instance. Here, we are providing a name that Ansible will use to track
    the cron job over time, telling `cron` to run the job every `10` minutes, followed
    by the command to execute and its parameters. The parameters we are giving to
    `ansible-pull` are the GitHub URL of our branch, the inventory file we just added
    to our repository, and a `sleep` parameter that will make the command start sometime
    between `1` and `60` seconds after the call started. This will help spread out
    the load on the network and prevent all node services from restarting at the same
    time if we have more than one server. After waiting for a bit, we can verify that
    our change is effective through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: After manually integrating Ansible to the EC2 instance we created using CloudFormation,
    we can now formalize the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Ansible with CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are different strategies to integrate Ansible to CloudFormation,
    in our situation there is an obvious path to take. We are going to take advantage
    of the `UserData` field, and initialize Ansible through the `ansible-pull` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to start the Troposphere script that we created earlier in
    this chapter. We will duplicate this and call the new script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to your template repository and duplicate the previous template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `ansiblebase-cf-template.py` script with your editor. To keep
    the script readable, we will first define several variables. Before the declaration
    of the application port, we will define an application name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also set a number of constants around the GitHub information. Replace
    the value of `GithubAccount` with your GitHub username or GitHub organization
    name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'After the definition of `GithubAnsibleURL`, we are going to create one more
    variable that will contain the command line we want to execute in order to configure
    the host through Ansible. We will call `ansible-pull` and use the `GithubAnsibleURL`
    and `ApplicationName` variables that we just defined. This is what this looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to update the `UserData` block. Instead of installing Node.js,
    downloading our application files and starting the service, we will change this
    block to install `git` and `ansible`, execute the command contained in the `AnsiblePullCmd`
    variable, and finally create a cron job to re-execute that command every `10`
    minutes. Delete the previous `ud` variable definition and replace it with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now save our file, use it to create our JSON template, and test it.
    Your new script should look like the sample at [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even create a new stack yourself. For example, let''s say `helloworld`,
    instead of changing the existing `ansible` stack. In this case, you need to run
    the following command for stack creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now wait until the execution is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the stack creation is complete, we can query CloudFormation to get
    the output of the stack and, more specifically, its public IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we can verify that our server is up and running as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now commit our newly created `troposphere` script to our GitHub repository
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a complete solution for efficiently managing our infrastructure
    using code. We demonstrated this through a very simple example. However, as you
    can imagine, everything is applicable to bigger infrastructure with a greater
    number of services. This section is almost over; we can now delete our stack to
    free up the resources that we are currently consuming. In the earlier part of
    the chapter, we did this using the web interface. As you can imagine, this can
    also be done easily using the following command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you have created a new `helloworld` stack for this example, then
    remove that too using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know by now, monitoring and measuring everything is an important
    aspect of a DevOps-driven organization. On the internet, you will find a number
    of well written blog posts and examples of how to efficiently monitor CloudFormation
    and Ansible. When working on monitoring CloudFormation, you will want to subscribe
    to an SNS topic for your stack creation to receive all events relating to your
    stack life cycle. It is also important to look out for CloudFormation stack creation
    failure. Ansible has a system of callbacks that will also give you a way to create
    some automation around the Ansible execution. Similarly to CloudFormation, receiving
    notifications when Ansible fails to run is important (it's even more important
    when Ansible is configured to run in pull mode).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to efficiently manage infrastructure by using
    code. We also explored CloudFormation, an AWS service that allows you to create
    templates for your different services in order to describe each AWS component
    used, as well as its configuration. In order to simplify the creation of those
    templates, we looked at a couple of options, ranging from CloudFormation designer,
    a tool with a graphic user interface, to Troposphere, a Python library. After
    that, we looked at configuration management, one of the most well-known aspects
    of the DevOps philosophy. To illustrate this topic, we looked at Ansible, one
    of the most popular configuration management solutions. We first looked at the
    different ways to use Ansible commands and ran simple commands against our infrastructure.
    We then looked at how to create playbooks, which allowed us to orchestrate the
    different steps to deploy our web server. Finally, we looked at how Ansible can
    be used in pull mode, which usually makes more sense when managing sizable infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a good production environment that is ready to host any application,
    and we have seen how to architect it and monitor our servers. In Chapter 5, *Adding
    Continuous Integration and Continuous Deployment*, we will continue to use CloudFormation
    and Ansible, but in the context of software delivery: we will learn how to put
    in place continuous integration testing and continuous deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does IaC stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a simple Hello World application be deployed using the AWS CloudFormation
    Console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List some of the popular SCM offerings. How is a GitHub account useful for source
    control management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git (Local Version Control) package, clone your GitHub global repository
    created in the previous example and push your `helloworld-cf.template` to your
    GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Ansible? List some of its important characteristics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to explore this topic in more detail, please visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AWS CloudFormation details* at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Troposphere – Python library to create AWS CloudFormation descriptions* at [https://github.com/cloudtools/troposphere](https://github.com/cloudtools/troposphere)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible configuration management tool* at [https://docs.ansible.com/ansible](https://docs.ansible.com/ansible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
