- en: Treating Your Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基础设施视为代码
- en: In the previous chapter, we familiarized ourselves with AWS. We also created
    an EC2 instance and deployed a Hello World web application onto it. However, to
    get there, we had to go through a number of steps to configure the instance and
    its security groups. Because we did that in a very manual fashion using the command-line
    interface, the steps that we went through will not be reusable or auditable, as
    you may recall from the first chapter when implementing DevOps best practices.
    Two key concepts that you should rely on as often as possible are source control
    (version control) and automation. In this chapter, we will explore how to apply
    those principles to our infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经熟悉了 AWS。我们还创建了一个 EC2 实例并将 Hello World 网页应用部署到该实例上。然而，为了完成这些操作，我们必须经历一系列步骤来配置实例及其安全组。由于我们使用命令行界面以非常手动的方式完成这些操作，这些步骤将不可复用，也不可审计，正如你可能还记得在第一章实现
    DevOps 最佳实践时提到的那样。你应该尽可能依赖的两个关键概念是源代码管理（版本控制）和自动化。在本章中，我们将探讨如何将这些原则应用于我们的基础设施。
- en: In a cloud environment, where almost everything is abstracted and served through
    the intermediary of virtual resources, it is easy to imagine that code can describe
    the topology of a network and the configuration of a system. To go through that
    transformation, we will learn about two key concepts in an effective DevOps organization.
    The first one is commonly called **Infrastructure as Code** (**IAC**). This is
    the process of describing all your virtual resources in the form of codes. These
    resources may include virtual servers, load balancers, storage, the network layer,
    and so on. The second concept, which is very close to IAC, focuses further on
    system configuration and is called **configuration management**. Through configuration
    management systems, developers and system administrators have the ability to automate
    operating system configuration, package installation, and even application deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，几乎所有内容都被抽象化并通过虚拟资源中介提供，我们可以很容易地想象，代码可以描述网络拓扑和系统配置。要完成这一转变，我们将学习 DevOps
    组织中两个关键的概念。第一个通常被称为**基础设施即代码**（**IAC**）。这是用代码的形式描述所有虚拟资源的过程。这些资源可能包括虚拟服务器、负载均衡器、存储、网络层等。第二个概念，虽然与
    IAC 非常相近，但更专注于系统配置，被称为**配置管理**。通过配置管理系统，开发人员和系统管理员能够自动化操作系统配置、软件包安装，甚至应用程序部署。
- en: 'Going through that transformation is a crucial step for any DevOps-focused
    organization. By having the code to describe the different resources and their
    configurations, we will be able to use the same tools and processes as we do when
    developing applications. We will be able to use source control and make smaller
    changes to individual branches, as well as submitting pull requests, following
    standard review processes, and finally, testing changes before they are applied
    to our production environment. This will give us better clarity, accountability,
    and auditability for infrastructure changes. Because of that, we will also be
    able to manage a much bigger fleet of resources without necessarily needing more
    engineers or without spending a lot more time operating all the resources. This
    will also open up the door to further automation, as we will see with continuous
    deployment in Chapter 5, *Adding Continuous Integration and Continuous Deployment*.
    In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这一转变是任何以 DevOps 为核心的组织的关键步骤。通过使用代码来描述不同的资源及其配置，我们将能够使用与开发应用程序时相同的工具和流程。我们将能够使用源代码管理，针对各个分支进行较小的更改，提交拉取请求，遵循标准的审核流程，并最终在将更改应用到生产环境之前进行测试。这将为我们提供更清晰的视角、更高的责任性以及更强的审计能力，以便管理基础设施的变化。正因如此，我们还能够管理更大规模的资源池，而不必增加更多的工程师，或者花费更多的时间来操作这些资源。这也为进一步的自动化打开了大门，正如我们在第
    5 章中将看到的那样，*添加持续集成和持续部署*。在本章中，我们将覆盖以下主题：
- en: Managing your infrastructure with CloudFormation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 管理基础设施
- en: Adding a configuration management system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加配置管理系统
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: AWS Console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 控制台
- en: AWS CloudFormation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFormation
- en: AWS CloudFormation Designer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFormation Designer
- en: CloudFormer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormer
- en: Troposphere
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Troposphere
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: GitHub
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Ansible
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: 'The GitHub links to find the codes in this chapter are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 GitHub 链接如下：
- en: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py)'
- en: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py)'
- en: '[https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)'
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml)'
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml)'
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml)'
- en: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py)'
- en: Managing your infrastructure with CloudFormation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 管理基础设施
- en: CloudFormation introduces a new way to manage services and their configurations.
    Through the creation of JSON or YAML files, CloudFormation lets you describe the
    AWS architecture you would like to build. Once your files are created, you can
    simply upload them to CloudFormation, which will execute them, and automatically
    create or update your AWS resources. Most AWS-managed tools and services are supported.
    You can get the full list at [http://amzn.to/1Odslix](http://amzn.to/1Odslix).
    In this chapter, we will only look at the infrastructure we have built so far,
    but we will add more resources in the following chapters. After a brief overview
    of how CloudFormation is structured, we will create a minimal list stack to recreate
    the Hello World web application from [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*. After that, we will see two more options
    to create CloudFormation templates—the designer, which lets you visually edit
    your template in a Web GUI, and CloudFormer, a tool to generate templates from
    existing infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 引入了一种全新的方式来管理服务及其配置。通过创建 JSON 或 YAML 文件，CloudFormation 让你能够描述你希望构建的
    AWS 架构。文件创建完成后，你只需将其上传到 CloudFormation，CloudFormation 将执行这些文件，自动创建或更新你的 AWS 资源。大多数
    AWS 管理的工具和服务都支持这种方式。你可以在 [http://amzn.to/1Odslix](http://amzn.to/1Odslix) 查看到完整的支持列表。在本章中，我们将仅关注我们迄今为止所构建的基础设施，但在接下来的章节中我们会添加更多资源。在简要了解
    CloudFormation 的结构之后，我们将创建一个最小化的堆栈，以重新创建来自[第二章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)的
    Hello World Web 应用程序，*部署你的第一个 Web 应用程序*。之后，我们将介绍另外两种创建 CloudFormation 模板的方式——设计器，它允许你在
    Web GUI 中可视化编辑模板，以及 CloudFormer，这是一种可以从现有基础设施生成模板的工具。
- en: Getting started with CloudFormation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 CloudFormation
- en: 'As you would expect, you can access CloudFormation through the AWS console
    at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation),
    or by using the following command line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，你可以通过 AWS 控制台访问 CloudFormation，网址为 [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)，或者使用以下命令行：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The service is organized around the concept of stacks. Each stack typically
    describes a set of AWS resources and their configuration in order to start an
    application. When working with CloudFormation, most of your time is spent editing
    those templates. There are different ways to get started with the actual editing
    of the templates. One of the easiest ways is to edit existing templates. AWS has
    a number of well-written examples available at [http://amzn.to/27cHmrb](http://amzn.to/27cHmrb).
    At the highest level, templates are structured as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务围绕堆栈的概念进行组织。每个堆栈通常描述一组 AWS 资源及其配置，以便启动应用程序。在使用 CloudFormation 时，你大部分时间都会花费在编辑这些模板上。开始编辑模板有不同的方法，其中一种最简单的方法是编辑现有的模板。AWS
    提供了多个编写良好的示例，网址为 [http://amzn.to/27cHmrb](http://amzn.to/27cHmrb)。在最高层次上，模板的结构如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `AWSTemplateFormatVersion` section is currently always `2010-09-09` and
    this represents the version of the template language used. This version is currently
    the only valid value. The `Description` section is there for you to summarize
    what the template does. The `Resources` section describes which AWS services will
    be instantiated and what their configurations are. When you launch a template,
    you have the ability to provide some extra information to CloudFormation, such
    as which SSH key-pair to use. For example, if you want to give SSH access to your
    EC2 instances, this kind of information goes into the `Parameters` section. The
    `Mappings` section is useful when you try to create a more generic template.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`AWSTemplateFormatVersion` 部分当前始终为 `2010-09-09`，表示使用的模板语言版本。这个版本目前是唯一有效的值。`Description`
    部分用于总结模板的功能。`Resources` 部分描述了将实例化哪些 AWS 服务及其配置。当你启动模板时，你可以提供一些额外的信息给 CloudFormation，例如使用哪个
    SSH 密钥对。例如，如果你想给 EC2 实例提供 SSH 访问权限，这类信息将放入 `Parameters` 部分。`Mappings` 部分在你尝试创建更通用的模板时非常有用。'
- en: You can, for example, define which **Amazon Machine Image** (**AMI**) to use
    for a given region, so that the same template can be used to start an application
    in that AWS region. The `Conditions` section allows you to add conditional logic
    to your other sections (if statements, logical operators, and so on), while the
    `Metadata` section lets you add more arbitrary information to your resources.
    Finally, the `Outputs` section lets you extract and print out useful information
    based on the execution of your template, such as the IP address of the EC2 server
    created, for example. In addition to those examples, AWS also provides a couple
    of tools and services around CloudFormation template creation. The first tool
    you can use to create your templates is called CloudFormation Designer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以定义在某个特定区域使用哪种 **Amazon Machine Image** (**AMI**)，以便在该 AWS 区域启动应用程序时使用相同的模板。`Conditions`
    部分允许你为其他部分添加条件逻辑（如 if 语句、逻辑运算符等），而 `Metadata` 部分则允许你为资源添加更多任意信息。最后，`Outputs` 部分让你根据模板的执行结果提取并打印出有用信息，例如创建的
    EC2 服务器的 IP 地址。除了这些示例，AWS 还提供了一些与 CloudFormation 模板创建相关的工具和服务。你可以用来创建模板的第一个工具叫做
    CloudFormation Designer。
- en: AWS CloudFormation Designer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS CloudFormation Designer
- en: 'AWS CloudFormation Designer is a tool that lets you create and edit CloudFormation
    templates using a graphic user interface. Designer hides a lot of the complexity
    of editing a CloudFormation template using a standard text editor. You can access
    this directly at [https://console.aws.amazon.com/cloudformation/designer](https://console.aws.amazon.com/cloudformation/designer),
    or in the CloudFormation dashboard after you click on the Create Stack button,
    as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation Designer 是一个工具，允许你使用图形用户界面创建和编辑 CloudFormation 模板。Designer
    隐藏了通过标准文本编辑器编辑 CloudFormation 模板时的大量复杂性。你可以直接访问 [https://console.aws.amazon.com/cloudformation/designer](https://console.aws.amazon.com/cloudformation/designer)，或者在点击创建堆栈按钮后通过
    CloudFormation 仪表板访问，如下所示：
- en: '*![](img/541decf4-3186-4bf3-9884-063c3c136b53.png)*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/541decf4-3186-4bf3-9884-063c3c136b53.png)*'
- en: The workflow is fairly simple. You simply drag and drop resources from the left-hand
    side menu into a canvas.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程相当简单。你只需将资源从左侧菜单拖放到画布上。
- en: 'Once your resources are added, you can then connect them to other resources
    using the small dots surrounding each resource icon. In the preceding example,
    we are connecting an EC2 instance to its security group. There are a number of
    hidden gems that can help you when designing your template. You can right-click
    on resources and directly access the documentation for the CloudFormation resource
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的资源被添加，你就可以通过围绕每个资源图标的小圆点将它们连接到其他资源。在前面的示例中，我们将一个EC2实例连接到其安全组。有许多隐藏的宝藏可以帮助你在设计模板时。你可以右键点击资源，直接访问CloudFormation资源的文档，如下所示：
- en: '![](img/be7eedd3-01e4-4e1d-abfb-8f7ec71abd1c.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be7eedd3-01e4-4e1d-abfb-8f7ec71abd1c.png)'
- en: 'When dragging a dot to connect two resources, a designer will highlight resources
    that are compatible with that connection. The editor on the bottom section of
    the designer supports auto completion using *Ctrl* + Spacebar:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当拖动一个点来连接两个资源时，设计器将高亮显示与该连接兼容的资源。设计器底部的编辑器支持使用*Ctrl* + 空格键的自动补全功能：
- en: '![](img/c1e036f6-de32-47a4-bcbb-8d3d509870d4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e036f6-de32-47a4-bcbb-8d3d509870d4.png)'
- en: Once your template is complete, you can simply click on a button and go from
    designing your stack to launching it. The next tool we will look at is called
    **CloudFormer**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的模板完成，你只需点击一个按钮，就可以从设计堆栈到启动堆栈。我们接下来要看的是名为**CloudFormer**的工具。
- en: CloudFormer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFormer
- en: 'CloudFormer is a tool that lets you create CloudFormation templates by looking
    at pre-existing resources. If you have a set of resources that you have already
    created on an ad hoc basis, as we have done so far in the book, then you can use
    CloudFormer to group them under a new CloudFormation template. You can then later
    customize the template that CloudFormer generates using a text editor or even
    CloudFormation designer, making it fit your needs. Unlike most AWS tools and services,
    CloudFormer isn''t completely managed by AWS; it''s a self-hosted tool that you
    can instantiate on demand using CloudFormation. To do so, follow the given steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormer是一个通过查看现有资源来创建CloudFormation模板的工具。如果你已经创建了一些临时的资源集，正如我们在本书中所做的那样，那么你可以使用CloudFormer将它们分组到一个新的CloudFormation模板下。之后，你可以使用文本编辑器甚至CloudFormation设计器自定义CloudFormer生成的模板，使其符合你的需求。与大多数AWS工具和服务不同，CloudFormer并非完全由AWS管理；它是一个自托管的工具，你可以通过CloudFormation按需实例化。为此，请按照以下步骤操作：
- en: Open [h](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[p](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[://c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[e](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[w](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[z](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[/c](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[u](https://console.aws.amazon.com/cloudformation)[d](https://console.aws.amazon.com/cloudformation)[f](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[r](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[i](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)
    in your browser.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 [h](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[p](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[://c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[e](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[w](https://console.aws.amazon.com/cloudformation)[s](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[z](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)[.](https://console.aws.amazon.com/cloudformation)[c](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[/c](https://console.aws.amazon.com/cloudformation)[l](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[u](https://console.aws.amazon.com/cloudformation)[d](https://console.aws.amazon.com/cloudformation)[f](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[r](https://console.aws.amazon.com/cloudformation)[m](https://console.aws.amazon.com/cloudformation)[a](https://console.aws.amazon.com/cloudformation)[t](https://console.aws.amazon.com/cloudformation)[i](https://console.aws.amazon.com/cloudformation)[o](https://console.aws.amazon.com/cloudformation)[n](https://console.aws.amazon.com/cloudformation)
    在你的浏览器中。
- en: Now, scroll down the AWS console screen, selectCreate a Template from your Existing
    Resources option, and click on the Launch CloudFormer button.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向下滚动 AWS 控制台屏幕，选择“从现有资源创建模板”选项，然后点击“启动 CloudFormer”按钮。
- en: 'In the Select a sample template drop-down menu, choose the CloudFormer option
    and click on the Next button, as shown in the following screenshot:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选择一个样本模板”下拉菜单中，选择 CloudFormer 选项，然后点击“下一步”按钮，如下图所示：
- en: '**![](img/46751091-bae2-4af6-986f-5e86de98a60f.png)**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/46751091-bae2-4af6-986f-5e86de98a60f.png)**'
- en: On that screen, at the top, you can provide a stack name (feel free to keep
    the default name, `AWSCloudFormer`) and in the bottom part, you are asked to provide
    three additional parameters, a Username, a Password and VPC Selection. This username
    and password will be used later to log into CloudFormer. Pick a username and a
    password, select the Default VPC, and click on the Next button.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该屏幕上，顶部你可以提供堆栈名称（可以保留默认名称`AWSCloudFormer`），在下方，你将被要求提供三个额外的参数：用户名、密码和 VPC 选择。此用户名和密码将用于稍后登录
    CloudFormer。选择一个用户名和密码，选择默认的 VPC，然后点击“下一步”按钮。
- en: On the next screen, you can provide extra tags and more advanced options, but
    we will simply continue by clicking on the Next button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，你可以提供额外的标签和更高级的选项，但我们将继续点击“下一步”按钮。
- en: This brings us to the review page, where we will check the checkbox to acknowledge
    that this will cause AWS CloudFormation to create IAM resources. Click on the Create
    button.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们进入审查页面，在这里我们将勾选复选框以确认这将导致 AWS CloudFormation 创建 IAM 资源。点击 **创建** 按钮。
- en: 'This will bring us back to the main screen of the CloudFormation console, where
    we can see our AWS CloudFormer stack being created . Once the Status column goes
    from CREATE_IN_PROGRESS to CREATE_COMPLETE, select it and click on the Outputs
    tab at the bottom. At that point, you have created the resources needed to use
    CloudFormer. In order to create a stack with it, do the following: in the Outputs
    tab (which illustrates the Outputs section of CloudFormation), click on the website
    URL link. This will open up the CloudFormer tool. Log in using the username and
    password provided in the fourth step of the previous set of instructions, and
    you should see something like the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把我们带回 CloudFormation 控制台的主屏幕，在那里我们可以看到我们的 AWS CloudFormer 堆栈正在创建中。一旦状态列从 CREATE_IN_PROGRESS
    变为 CREATE_COMPLETE，选择它并点击底部的 Outputs 标签。此时，你已经创建了使用 CloudFormer 所需的资源。为了使用它创建堆栈，请按照以下步骤操作：在
    Outputs 标签（显示 CloudFormation 的 Outputs 部分）中，点击网站 URL 链接。这将打开 CloudFormer 工具。使用在前一组说明的第四步中提供的用户名和密码登录，你应该能看到类似以下内容：
- en: '![](img/d45f2219-b0a7-44cd-ac34-1369a16757b9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d45f2219-b0a7-44cd-ac34-1369a16757b9.png)'
- en: 'Select the AWS region where you want to create the template and then click
    on the Create Template button. The following screen will then appear:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要创建模板的 AWS 区域，然后点击 **创建模板** 按钮。接下来会出现以下屏幕：
- en: '![](img/1bc2ff71-ff2a-4068-861d-f15ff6855af6.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bc2ff71-ff2a-4068-861d-f15ff6855af6.png)'
- en: Follow the workflow proposed by the tool to select the different resources that
    you want for your CloudFormation template, as far as the last step.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照工具所建议的工作流程选择你想要的不同资源，用于你的 CloudFormation 模板，直到最后一步。
- en: In the end, you will be able to download the generated template or save it directly
    in S3.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你将能够下载生成的模板或直接将其保存到 S3。
- en: The CloudFormation template generated by CloudFormer will usually need a bit
    of editing, as you will often want to create a more flexible stack with input
    parameters and an Outputs section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormer 生成的 CloudFormation 模板通常需要稍作编辑，因为你通常会希望创建一个更灵活的堆栈，带有输入参数和 Outputs
    部分。
- en: Recreating our Hello World example with CloudFormation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 重新创建我们的 Hello World 示例
- en: Designer and CloudFormer are two very useful tools when you are in the process
    of architecting your infrastructure and trying to add source control to your design.
    That said, whenever you wear your DevOps hat, it's a different story. Using those
    tools markedly reduces the added value that CloudFormation provides by using the
    JSON format. If you got a chance to read some of the templates available, or tried
    to use CloudFormer on your existing infrastructure, you probably noticed that
    raw CloudFormation templates tend to be fairly long and not **Don't Repeat Yourself**
    (**DRY**).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Designer 和 CloudFormer 是在构建基础设施并尝试为设计添加源代码控制时非常有用的两个工具。也就是说，每当你戴上 DevOps 帽子时，情况就不同了。使用这些工具显著减少了
    CloudFormation 通过使用 JSON 格式提供的附加价值。如果你有机会阅读一些现有的模板，或者尝试在现有的基础设施上使用 CloudFormer，你可能会注意到原始的
    CloudFormation 模板通常相当长，并且不符合 **不要重复自己**（**DRY**）原则。
- en: From a DevOps perspective, one of the most powerful aspects of CloudFormation
    is the ability to write code to dynamically generate those templates. To illustrate
    that point, we are going to turn to Python, and a library called `troposphere`,
    to generate our Hello World CloudFormation template.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DevOps 的角度来看，CloudFormation 最强大的功能之一就是能够编写代码动态生成这些模板。为了说明这一点，我们将使用 Python
    和一个名为 `troposphere` 的库来生成我们的 Hello World CloudFormation 模板。
- en: There are also a number of more advanced tools to assist with the creation of
    CloudFormation templates. If you plan on using other third-party services in addition
    to AWS, you can take a look at Terraform from Hashicorp (available at [https://www.terraform.io](https://www.terraform.io)),
    for example, which handles a number of other cloud providers and services in addition
    to CloudFormation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更高级的工具可以帮助创建 CloudFormation 模板。如果你计划使用除 AWS 之外的其他第三方服务，可以看看 Hashicorp 提供的
    Terraform（网址：[https://www.terraform.io](https://www.terraform.io)），它除了支持 CloudFormation
    外，还处理其他多个云提供商和服务。
- en: Using Troposphere to create a Python script for our template
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Troposphere 创建我们模板的 Python 脚本
- en: 'We will first install the `troposphere` library. Again, we are demonstrating
    all of the outputs from a CentOS 7.x-based Linux distribution, but the process
    applies equally to all of the supported platforms mentioned. The following is
    the command to install the `troposphere` library:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装`troposphere`库。同样，我们展示的是基于CentOS 7.x的Linux发行版的所有输出，但该过程同样适用于所有支持的平台。以下是安装`troposphere`库的命令：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One known issue with the Troposphere is the upgraded version of `setuptools`.
    If you come across the following issue, then the solution is to upgrade `setuptools`
    using the `pip install -U setuptools` command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Troposphere的一个已知问题是`setuptools`的升级版本。如果遇到以下问题，解决方案是使用`pip install -U setuptools`命令升级`setuptools`。
- en: 'Once you have run the preceding command, you may encounter the following error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了上述命令，您可能会遇到以下错误：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to fix the error, you can run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个错误，您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the installation is complete, you can then create a new file called `helloworld-cf-template.py`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以创建一个名为`helloworld-cf-template.py`的新文件。
- en: 'We will start our file by importing a number of definitions from the `troposphere`
    module as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从`troposphere`模块导入多个定义来开始我们的文件，如下所示：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are also going to define a first variable that will make editing the code
    easier for the remainder of the book. This is because we will create new scripts
    by building on this initial template:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义第一个变量，这将使后续的代码编辑变得更加容易。因为我们将通过在这个初始模板的基础上构建新脚本：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From a code standpoint, the first thing we will do is initialize a `Template`
    variable. By the end of our script, the template will contain the entire description
    of our infrastructure and we will be able to simply print its output to get our
    CloudFormation template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的角度来看，我们将做的第一件事是初始化一个`Template`变量。在脚本结束时，模板将包含我们基础设施的完整描述，我们将能够简单地打印其输出以获取我们的CloudFormation模板：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Throughout this book, we will create and run several CloudFormation templates concurrently.
    To help us identify what''s in a given stack, we have the ability to provide a
    description. After the creation of the template, add the description as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将并行创建并运行多个CloudFormation模板。为了帮助我们识别给定堆栈中的内容，我们可以提供一个描述。在模板创建后，按如下方式添加描述：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we launched EC2 instances using the web command-line interface, we selected
    which key-pair to use in order to gain SSH access to the host. In order to not
    lose this ability, the first thing our template will have is a parameter to offer
    the CloudFormation user the ability to select which key-pair to use when launching
    the EC2 instance. To do that, we are going to create a `Parameter` object and
    initialize it by providing an identifier, a description, a parameter type, a description
    of the parameter type, and a constraint description to help make the right decision
    when we launch the stack. In order for this parameter to exist in our final template,
    we will also use the `add_parameter()` function defined in the template class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Web命令行界面启动EC2实例时，我们选择了用于SSH访问主机的密钥对。为了不失去这一功能，我们的模板首先会包含一个参数，允许CloudFormation用户在启动EC2实例时选择使用哪个密钥对。为此，我们将创建一个`Parameter`对象，并通过提供标识符、描述、参数类型、参数类型的描述以及帮助做出正确决策的约束描述来初始化它。为了使这个参数出现在我们的最终模板中，我们还将使用模板类中定义的`add_parameter()`函数：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next thing we will look at is the security group. We will proceed exactly
    as we did for our `KeyPair` parameter. We want to open up `SSH/22` and `TCP/3000`
    to the world. Port `3000` was defined in the `ApplicationPort` variable declared
    earlier. In addition, this time, the information defined isn''t a parameter like
    before, but a resource. Consequently, we will add that new resource using the
    `add_resource()` function as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将关注的是安全组。我们将按照之前为`KeyPair`参数所做的方式进行操作。我们希望将`SSH/22`和`TCP/3000`开放给全球。端口`3000`之前在`ApplicationPort`变量中定义。此外，这次定义的信息不是像之前那样的参数，而是一个资源。因此，我们将使用`add_resource()`函数将该新资源添加如下：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our next section, we will replace the need to log on to our EC2 instance
    and install the `helloworld.js` file and its `init` scripts by hand. To do so,
    we will take advantage of the `UserData` features that EC2 offers. When you create
    an EC2 instance, the `UserData` optional parameter gives you the ability to provide
    a set of commands to run once the virtual machine has spawned up (you can read
    more on this topic at [http://amzn.to/1VU5b3s](http://amzn.to/1VU5b3s)). One of
    the constraints of the `UserData` parameter is that the script must be base64-encoded
    in order to be added to our API call.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将替换手动登录到我们的EC2实例并安装`helloworld.js`文件及其`init`脚本的需求。为此，我们将利用EC2提供的`UserData`功能。当您创建EC2实例时，`UserData`可选参数允许您提供一组命令，在虚拟机启动后执行（您可以在[http://amzn.to/1VU5b3s](http://amzn.to/1VU5b3s)上阅读更多有关此主题的内容）。`UserData`参数的一个限制是，脚本必须进行base64编码，才能添加到我们的API调用中。
- en: 'We are going to create a small script to reproduce the steps that we went through
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application.* Here, we will encode, deploy our first web application deployment
    step in base-64 and store it in a variable called `ud`. Note that installing the
    application in the `home` directory of `ec2-user` isn''t very clean. For now,
    we are trying to stay consistent with what we did in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying
    Your First Web Application*. We will fix that in Chapter 5, *Adding Continuous
    Integration and Continuous Deployment*, as we improve our deployment system:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小脚本来重现我们在[第2章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中所做的步骤，*部署您的第一个Web应用程序*。在这里，我们将对我们的第一个Web应用程序的部署步骤进行base-64编码，并将其存储在一个名为`ud`的变量中。请注意，在`ec2-user`的`home`目录中安装应用程序并不非常整洁。现在，我们尽量保持与在[第2章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中所做的步骤一致，*部署您的第一个Web应用程序*。我们将在第5章，*添加持续集成和持续部署*中解决这个问题，并改进我们的部署系统。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will now focus on the main resource of our template, which is our EC2 instance.
    The creation of the instance requires providing a name for identifying the resource,
    an image ID, an instance type, a security group, the key-pair to use for the SSH
    access, and the user data. In order to keep things simple, we will hardcode the
    AMI ID (`ami-cfe4b2b0`) and instance type (`t2.micro`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注我们模板的主要资源，即我们的EC2实例。创建该实例需要提供一个用于标识资源的名称、一个镜像ID、一个实例类型、安全组、用于SSH访问的密钥对，以及用户数据。为了简化操作，我们将硬编码AMI
    ID（`ami-cfe4b2b0`）和实例类型（`t2.micro`）。
- en: 'The remaining pieces of information needed to create our EC2 instances are
    the security group information and the `KeyPair` name, which we collected previously
    by defining a parameter and a resource. In CloudFormation, you can refer to pre-existing
    subsections of your template by using the `Ref` keyword. In Troposphere, this
    is done by calling the `Ref()` function. As before, we will add the resulting
    output to our template with the help of the `add_resource` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建EC2实例所需的其余信息是安全组信息和`KeyPair`名称，这些信息我们之前通过定义参数和资源收集过。在CloudFormation中，您可以通过使用`Ref`关键字引用模板中预先存在的子部分。在Troposphere中，这可以通过调用`Ref()`函数来完成。如前所述，我们将借助`add_resource`函数将生成的输出添加到我们的模板中。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the last section of our script, we will focus on producing the `Outputs`
    section of the template that gets populated when CloudFormation creates a stack.
    This selection allows you to print out useful information that was computed during
    the launch of the stack. In our case, there are two useful pieces of information—the
    URL to access our web application, and the public IP address of the instance,
    so that we can SSH into it if we want to. In order to retrieve such information,
    CloudFormation uses the `Fn::GetAtt ` function. In Troposphere, this is translated
    into the  `GetAtt()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的最后部分，我们将专注于生成模板的`Outputs`部分，该部分将在CloudFormation创建堆栈时填充。此选择允许您打印在堆栈启动过程中计算出的有用信息。在我们的例子中，有两条有用的信息——访问我们Web应用程序的URL和实例的公网IP地址，以便我们如果需要，可以通过SSH访问它。为了获取这些信息，CloudFormation使用`Fn::GetAtt`函数。在Troposphere中，这被转换为`GetAtt()`函数。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At that point, we can make our script output the final result of the template
    we generated:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们可以让我们的脚本输出我们生成的模板的最终结果。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The script is now complete. We can save this and quit our editor. The file created
    should look like the file at the following link:  [https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在已经完成。我们可以保存并退出编辑器。创建的文件应该与以下链接中的文件类似：[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template-part-1.py)。
- en: 'We can now run our script, giving it the proper permissions and generating
    the CloudFormation template by saving the output of our script in a file as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行脚本，给予适当的权限，并通过将脚本的输出保存到文件中来生成 CloudFormation 模板，如下所示：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`cloud-init` is a set of Python scripts compatible with most Linux distributions
    and cloud providers. This complements the `UserData` field by moving most standard
    operations, such as installing packages, creating files, and running commands
    into different sections of the template. This book doesn''t cover that tool, but
    if your CloudFormation templates rely heavily on the `UserData` field, take a
    look at it. You can get its documentation at [http://bit.ly/1W6s96M](http://bit.ly/1W6s96M).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloud-init` 是一组与大多数 Linux 发行版和云提供商兼容的 Python 脚本。它通过将大多数标准操作（如安装包、创建文件和运行命令）移动到模板的不同部分，来补充
    `UserData` 字段。本书不涉及该工具，但如果你的 CloudFormation 模板严重依赖 `UserData` 字段，请查看它。你可以在[http://bit.ly/1W6s96M](http://bit.ly/1W6s96M)获取文档。'
- en: Creating the stack in the CloudFormation console
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CloudFormation 控制台中创建堆栈
- en: 'At this point, we can launch our template using the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们可以按照以下步骤启动我们的模板：
- en: Open the CloudFormation web console in your browser with the following link: [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
    Click on the Create Stack button.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 CloudFormation 网络控制台，使用以下链接：[https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)。点击“创建堆栈”按钮。
- en: On the next screen, we will upload our newly generated template, `helloworld-
    cf.template`, by selecting Upload a template to Amazon S3, and then browsing to
    select our `helloworld-cf.template` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个页面中，我们将通过选择“上传模板到 Amazon S3”来上传我们新生成的模板`helloworld-cf.template`，然后浏览并选择我们的`helloworld-cf.template`文件。
- en: We will then pick a stack name, such as `HelloWorld`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将选择一个堆栈名称，例如`HelloWorld`。
- en: After the stack name, we can see the Parameters section of our template in action.
    CloudFormation lets us pick which SSH key-pair to use. Select your key-pair using
    the drop-down menu.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆栈名称之后，我们可以看到模板的参数部分正在发挥作用。CloudFormation 允许我们选择使用哪个 SSH 密钥对。使用下拉菜单选择你的密钥对。
- en: On the next screen, we have to ability the add optional tags to our resources;
    in the Advanced section, we can see how we can potentially integrate CloudFormation
    and SNS, make decisions on what to do when a failure or a timeout occurs, and
    even add a stack policy that lets you control who can edit the stack, for example.
    For now, we will simply click on the Next button.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个页面中，我们可以为我们的资源添加可选标签；在“高级”部分，我们可以看到如何将 CloudFormation 与 SNS 集成，决定在发生故障或超时时采取什么行动，甚至添加堆栈策略来控制谁可以编辑堆栈。例如，暂时我们只需点击“下一步”按钮。
- en: This leads us to the review screen where we can verify the information selected
    and even estimate how much it will cost to run that stack. Click on the Create
    button.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到审查页面，我们可以在其中验证所选的信息，甚至估算运行该堆栈的费用。点击“创建”按钮。
- en: This will bring us to the main CloudFormation console. On that screen, we are
    able to see how our resources are created in the Events tab.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们进入主要的 CloudFormation 控制台。在该页面上，我们可以在“事件”标签中查看资源的创建情况。
- en: 'When the creation of the template is complete, click on the Outputs tabs, which
    will reveal the information we generated through the Outputs section of our template,
    as shown here:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模板创建完成后，点击“输出”标签页，这将显示我们通过模板的输出部分生成的信息，如下所示：
- en: '![](img/59eb8843-7aa6-4dbb-adaf-f1c0f329a337.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59eb8843-7aa6-4dbb-adaf-f1c0f329a337.png)'
- en: Click on the link in the value of the WebUrl key, which will open our Hello
    World page.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 WebUrl 键的值中的链接，将打开我们的 Hello World 页面。
- en: Adding our template to a source control system
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的模板添加到源控制系统中
- en: Now that we have tested our template and know it's working, we are going to
    commit it to our source control system. This will allow us to keep track of changes,
    making it possible to treat our infrastructure code at the same standard as our
    application code (more on this in Chapter 5, *Adding Continuous Integration and
    Continuous Deployment*).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经测试了模板并确认它正常工作，我们将把它提交到我们的源代码管理系统。这将帮助我们跟踪更改，使我们能够像管理应用代码一样，管理基础设施代码（更多内容将在第
    5 章 *添加持续集成与持续部署* 中讲解）。
- en: To do that, we will rely on Git. AWS has a service called AWS CodeCommit ([http://amzn.to/2tKUj0n](http://amzn.to/2tKUj0n)),
    which lets you manage Git repositories easily. However, because this service is
    a lot less popular than GitHub ([https://github.com](https://github.com/)), we
    will instead use the latter. If you don't have an account for GitHub yet, start
    by signing up for the service—it's completely free.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将依赖 Git。AWS 提供了一个名为 AWS CodeCommit 的服务（[http://amzn.to/2tKUj0n](http://amzn.to/2tKUj0n)），可以让你轻松管理
    Git 仓库。然而，由于该服务的流行程度远低于 GitHub（[https://github.com](https://github.com/)），我们将使用后者。如果你还没有
    GitHub 账号，先注册一个——完全免费。
- en: 'Once logged into GitHub, create a new repository for the CloudFormation template:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 GitHub 后，为 CloudFormation 模板创建一个新的仓库：
- en: In your browser, open [https://github.com/new](https://github.com/new).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [https://github.com/new](https://github.com/new)。
- en: Call the new repository the following: `EffectiveDevOpsTemplates`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的仓库命名为：`EffectiveDevOpsTemplates`。
- en: Check the Initialize this repository with a README checkbox.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“Initialize this repository with a README”选项框。
- en: 'Finally, click on the Create repository button, as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击此处显示的“Create repository”按钮：
- en: '![](img/91f23a82-9d36-415c-a6ca-a84e91b880d3.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91f23a82-9d36-415c-a6ca-a84e91b880d3.png)'
- en: 'Once your repository is created, you will want to clone it into your computer.
    For that, you need to have Git installed (search on Google for instructions on
    how to install Git for your operating system if you don''t have it yet). For CentOS,
    you just need to run `yum -y install git`, as the Git package is a part of Linux
    distribution now:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建仓库后，你需要将其克隆到你的电脑中。为此，你需要安装 Git（如果尚未安装，可以通过 Google 查找安装 Git 的操作系统相关教程）。对于 CentOS，只需运行
    `yum -y install git`，因为 Git 包现在是 Linux 发行版的一部分：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that the repository is cloned, we will go into it and copy the template
    previously created in the new GitHub repository:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然仓库已经被克隆下来，我们将进入该仓库并将之前创建的模板复制到新的 GitHub 仓库中：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will add and commit that new file to our project and push it to
    GitHub as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将把新文件添加并提交到项目中，并将其推送到 GitHub，如下所示：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Monorepo versus multirepo: **When managing your code, there are two common
    approaches to organizing your code repositories. You can create one repository
    for each project you have, or decide to put your entire organization code under
    a single repository. We will choose the simplest option for this book, which is
    one repository per project, but with the recent releases of several open source
    projects, such as Bazel from Google, Buck from Facebook, or Pants from Twitter,
    using a monorepo becomes a very compelling option as it avoids juggling between
    multiple repositories when making big changes to your infrastructure and services
    simultaneously.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一代码仓库与多仓库：**在管理代码时，有两种常见的方法来组织代码仓库。你可以为每个项目创建一个仓库，或者决定将整个组织的代码放在一个仓库中。我们将在本书中选择最简单的选项——每个项目一个仓库，但随着像谷歌的
    Bazel、Facebook 的 Buck 或 Twitter 的 Pants 等多个开源项目的发布，使用单一仓库（monorepo）变得非常具有吸引力，因为它可以避免在对基础设施和服务进行大规模更改时，在多个仓库之间来回切换。'
- en: Updating our CloudFormation stack
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的 CloudFormation 堆栈
- en: One of the biggest benefits of using the CloudFormation template to manage our
    resources is that the resources created from CloudFormation are tightly coupled
    to our stack. If we want to make a change to our stack, we can update the template
    and apply the change to our existing CloudFormation stack. Let's see how that
    works.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 模板管理资源的最大优势之一是，CloudFormation 创建的资源与我们的堆栈紧密绑定。如果我们想对堆栈进行更改，可以更新模板，并将更改应用到现有的
    CloudFormation 堆栈中。让我们来看看这个过程是如何工作的。
- en: Updating our Python script
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的 Python 脚本
- en: Our `helloworld-cf-template.py` script is fairly basic. At this point, we are
    only taking advantage of Python as far as using the `troposphere` library to easily
    generate JSON output in a more pleasant way than if we had to write it by hand.
    Of course, you might already realize that we are barely scratching the surface
    of what we can do when we have the ability to write scripts to create and manage
    infrastructures. The following section is a simple example that will let us write
    a couple more lines of Python and illustrate the concept of updating a CloudFormation
    stack, while taking advantage of more services and external resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`helloworld-cf-template.py`脚本非常基础。目前，我们仅仅在使用Python的`troposphere`库来以比手动编写更愉快的方式生成JSON输出。当然，你可能已经意识到，我们仅仅触及了编写脚本来创建和管理基础设施所能做的事情的冰山一角。接下来的部分是一个简单的示例，将让我们编写几行Python代码，演示如何更新CloudFormation堆栈，并利用更多的服务和外部资源。
- en: 'The security groups we created in our previous example open up two ports to
    the world: `22` (SSH) and `3000` (the web application port). We could try to harden
    one aspect of our security by only allowing our own IP to use SSH. This means
    changing the **Classless Inter-Domain Routing** (**CIDR**) IP information in our
    Python script on the security group that handles the port `22` traffic. There
    are a number of free services online that will let us know what our public IP
    is. We are going to use one of these, available at [https://api.ipify.org](https://api.ipify.org/).
    We can see it in action with a simple `curl` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的示例中创建的安全组向世界开放了两个端口：`22`（SSH）和`3000`（Web应用端口）。我们可以通过只允许自己的IP使用SSH来加固安全性。这意味着需要在处理端口`22`流量的安全组中更改Python脚本中的**无类域间路由**（**CIDR**）IP信息。网上有许多免费的服务可以帮助我们查看自己的公网IP。我们将使用其中一个服务，地址为[https://api.ipify.org](https://api.ipify.org/)。我们可以通过一个简单的`curl`命令查看其效果：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are going to take advantage of that service in our script. One of the reasons
    for using this particular service is that it has been packaged into a Python library.
    You can read more on this at [https://github.com/rdegges/python-ipify](https://github.com/rdegges/python-ipify).
    You can first install that library as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在脚本中利用这个服务。使用这个特定服务的原因之一是它已经被打包成了一个Python库。你可以在[https://github.com/rdegges/python-ipify](https://github.com/rdegges/python-ipify)上了解更多内容。你可以首先按如下方式安装该库：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In case you come across some `pip` related errors, as shown in the following
    code block, the fix would be to downgrade the `pip` version, install `ipify`,
    and then upgrade the `pip` version again to the latest version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到一些与`pip`相关的错误，如以下代码块所示，可以通过降级`pip`版本，安装`ipify`，然后再次将`pip`升级到最新版本来修复：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding error can be fixed with the following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误可以通过以下命令修复：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our script requires a CIDR. In order to convert our IP address to CIDR, we
    will also install another library, called `ipaddress`. The main advantage of combining
    these libraries is that we don''t have to worry about handling IPv4 versus IPv6:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本需要一个CIDR。为了将IP地址转换为CIDR，我们还将安装另一个名为`ipaddress`的库。结合这些库的主要优势是，我们不必担心处理IPv4与IPv6的问题：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once those libraries are installed, reopen `helloworld-cf-template.py` in your
    editor. At the top of our script, we are going to import the libraries, then,
    after the `ApplicationPort` variable definition, we will define a new variable
    called `PublicCidrIp` and, combining the two libraries mentioned previously, we
    can extract our CIDR as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些库安装完成，重新打开`helloworld-cf-template.py`文件。在脚本的顶部，我们将导入这些库，然后，在`ApplicationPort`变量定义后，我们将定义一个名为`PublicCidrIp`的新变量，并结合前面提到的两个库，我们可以按如下方式提取CIDR：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we can change the `CidrIp` declaration for the SSH group rule as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以按如下方式更改SSH组规则的`CidrIp`声明：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now save these changes. The file created should look like the file at
    [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保存这些更改。创建的文件应该与[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/EffectiveDevOpsTemplates/helloworld-cf-template.py)中的文件类似。
- en: 'We can now generate a new `diff` command to visually verify the change:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成一个新的`diff`命令来直观地验证更改：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, our CIDR IP is now correctly restricting the connection to our
    IP. We can now apply that change.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的 CIDR IP 现在已正确限制了对我们 IP 的连接。我们现在可以应用该更改。
- en: Updating our stack
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的堆栈
- en: 'Having generated the new JSON CloudFormation template, we can get in the CloudFormation
    console and update the stack as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 生成新的 JSON CloudFormation 模板后，我们可以进入 CloudFormation 控制台并按照以下步骤更新堆栈：
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 CloudFormation Web 控制台，访问[https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)。
- en: Select the `HelloWorld` stack that we created previously .
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前创建的 `HelloWorld` 堆栈。
- en: Click on the Actions drop-down menu, and then choose the Update Stack option.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“操作”下拉菜单，然后选择“更新堆栈”选项。
- en: Choose the `helloworld-cf-v2.template` file by clicking the Browse button, selecting
    the file, and then  clicking on the Next button.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击“浏览”按钮，选择 `helloworld-cf-v2.template` 文件，然后点击“下一步”按钮。
- en: This brings us to the next screen that lets us update the details of our stack.
    In our case, nothing has changed in the parameters, so we can continue by clicking
    on the Next button.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到下一个屏幕，让我们更新堆栈的详细信息。在我们的例子中，参数没有发生变化，因此我们可以继续点击“下一步”按钮。
- en: 'In the next screen as well, since we simply want to see the effect of our IP
    change, we can click on the Next button:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕中，由于我们只希望看到 IP 更改的效果，我们可以点击“下一步”按钮：
- en: '![](img/7f0b5618-87d5-41b5-882d-2290b9798910.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f0b5618-87d5-41b5-882d-2290b9798910.png)'
- en: 'This brings us to the review page, where, after a couple of seconds, we can
    see CloudFormation giving us a preview of our change:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到审核页面，在几秒钟后，我们可以看到 CloudFormation 给我们预览更改：
- en: '![](img/6f7c9956-37d8-4a3e-8888-dc1fcb625efb.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f7c9956-37d8-4a3e-8888-dc1fcb625efb.png)'
- en: As you can see, the only change will be an update on the security group. Now
    click on the Update button. This will bring us back to the CloudFormation template,
    where we will see the change being applied.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，唯一的变化将是对安全组的更新。现在点击“更新”按钮。这将带我们回到 CloudFormation 模板，在那里我们将看到更改被应用。
- en: 'In this particular example, AWS is able to simply update the security group
    to take our change into account. We can verify the change by extracting the physical
    ID from either the review page, or in the Resources tab back in the console:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个特定的示例中，AWS 能够简单地更新安全组，以便考虑到我们的更改。我们可以通过提取物理 ID 来验证更改，无论是在审核页面，还是回到控制台中的“资源”标签页：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Change sets
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改集
- en: 'Our template only includes a web server and a security group that makes updating
    CloudFormation a fairly harmless operation. Furthermore, our change was fairly
    trivial, as AWS could simply update the existing security group, as opposed to
    having to replace it. As you can imagine, as the architecture becomes more and
    more complex, so does the CloudFormation template. Depending on the update you
    want to perform, you might encounter unexpected changes when you review the change
    set in the final step of updating a template. AWS offers an alternative and safer
    way to update templates; this feature is called **change sets** and is accessible
    from the CloudFormation console. Follow this procedure in order to use change
    sets to review the updates, followed by execution:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板只包括一个 Web 服务器和一个安全组，这使得更新 CloudFormation 成为一个相对无害的操作。此外，我们的更改也相对简单，因为 AWS
    只需更新现有的安全组，而无需替换它。正如你所想象的那样，随着架构变得越来越复杂，CloudFormation 模板也会变得更复杂。根据你想要执行的更新，你可能会在更新模板的最终步骤中审查更改集时遇到意想不到的变化。AWS
    提供了一种替代且更安全的更新模板的方式；这个功能被称为**更改集**，可以通过 CloudFormation 控制台访问。请按照以下步骤使用更改集来审查更新，并执行操作：
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 CloudFormation Web 控制台，访问[https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
- en: Select the `HelloWorld` stack that we previously created
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前创建的 `HelloWorld` 堆栈
- en: Click on the Actions drop-down menu and then click the Create Change Set For
    Current Stack option
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“操作”下拉菜单，然后点击“为当前堆栈创建更改集”选项
- en: 'From there, you can follow the same steps you took to create a simple update
    in the *Updating our stack* section. The main difference happens on the last screen,
    shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以按照 *更新我们的堆栈* 部分中进行简单更新时所采取的相同步骤操作。主要的区别出现在最后一个屏幕，如下所示：
- en: '![](img/0deeb19b-d946-4819-97ec-0843960fdce0.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0deeb19b-d946-4819-97ec-0843960fdce0.png)'
- en: 'Unlike the regular stack updates, change sets have a strong emphasis on giving
    you the ability to review a change before applying it. If you are satisfied with
    the changes displayed, you have the ability to execute the update. Lastly, when
    using a change set to update your stack, you can easily audit recent changes using
    the Change Sets tab of your stack in the CloudFormation console. Finally, we will
    commit the changes to the Troposphere script with the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规堆栈更新不同，变更集强调在应用变更之前让你有机会审核变更。如果你对显示的变更感到满意，你就可以执行更新。最后，在使用变更集更新堆栈时，你可以通过
    CloudFormation 控制台中的“变更集”标签轻松审核最近的变更。最后，我们将使用以下命令将变更提交到 Troposphere 脚本：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting our CloudFormation stack
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除我们的 CloudFormation 堆栈
- en: In the last section, we saw how CloudFormation was able to update resources
    as we update our template. The same goes when you want to remove a CloudFormation
    stack and its resources. In a couple of clicks, you can delete your template and
    the various resources that were created at launch time. From a best practice standpoint,
    it is highly recommended to always use CloudFormation to make changes to your
    resources that were previously initialized with CloudFormation, including when
    you don't need your stack any more.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到 CloudFormation 如何在更新模板时更新资源。同样的操作适用于当你想要删除 CloudFormation 堆栈及其资源时。只需点击几下，你就可以删除模板以及启动时创建的各种资源。从最佳实践的角度来看，强烈建议始终使用
    CloudFormation 来对以前通过 CloudFormation 初始化的资源进行更改，包括在你不再需要堆栈时。
- en: 'Deleting a stack is very simple, and you should proceed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 删除堆栈非常简单，你应该按以下步骤进行：
- en: Open the CloudFormation web console in your browser at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 CloudFormation Web 控制台：[https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)
- en: Select the `HelloWorld` stack that we created previously
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前创建的`HelloWorld`堆栈
- en: Click on the Actions drop-down menu, and then click on the Delete Stack option
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“操作”下拉菜单，然后点击“删除堆栈”选项
- en: 'As always, you will be able to track completion in the Events tab:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以在“事件”标签中跟踪完成情况：
- en: '![](img/97b24707-f9c2-4c6e-be1e-f1ed2aa3b374.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97b24707-f9c2-4c6e-be1e-f1ed2aa3b374.png)'
- en: CloudFormation has a unique place in the AWS ecosystem. As complex as they are,
    most architectures can be described and managed through CloudFormation, allowing
    you to keep tight control over your AWS resources creation. While CloudFormation
    does a great job of managing the creation of resources, it doesn't always make
    things easy. This is especially the case when you want to make simple changes
    on services such as EC2\. Because CloudFormation doesn't keep track of the state
    of the resources once they are launched, the only reliable way to update an EC2
    instance is, for example, to recreate a new instance and swap it with the existing
    instance when it is ready. This creates somewhat of an immutable design (assuming
    that you don't run any extra commands when the instance is created). This may
    be an attractive architecture choice and, in some cases, it may take you a long
    way, but you may wish to have the ability to have long-running instances where
    you can, as this allows you to quickly and reliably make changes through a controlled
    pipeline, like we did with CloudFormation. This is what configuration management
    systems excel at.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 在 AWS 生态系统中占有独特地位。尽管架构复杂，绝大多数架构可以通过 CloudFormation 描述和管理，从而让你对
    AWS 资源的创建保持严格控制。虽然 CloudFormation 在资源创建管理上做得非常好，但并不总是让事情变得简单。特别是当你想要在像 EC2 这样的服务上进行简单更改时，情况尤其如此。因为
    CloudFormation 不会跟踪资源启动后的状态，所以更新 EC2 实例的唯一可靠方法是，例如，重新创建一个新的实例，并在其准备好后将其与现有实例进行交换。这种做法创造了某种不可变设计（假设在实例创建时没有运行任何额外的命令）。这可能是一个有吸引力的架构选择，并且在某些情况下，它可能会带你走得很远，但你也可能希望能够拥有长期运行的实例，这样你就可以像我们在
    CloudFormation 中所做的那样，通过受控的管道快速而可靠地进行更改。这正是配置管理系统的强项。
- en: Adding a configuration management system
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个配置管理系统
- en: Configuration management systems are probably the most well known components
    of classic DevOps-driven organizations. Present in most companies (including in
    the enterprise market), configuration management systems are quickly replacing
    home-grown Shell, Python, and Perl scripts. There are many reasons why configuration
    management systems should be a part of your environment. One reason is that they
    offer domain-specific languages, which improves the readability of the code, and
    they are tailored to the specific needs that arise in organizations when trying
    to configure systems. This results in a lot of useful built-in features. Furthermore,
    the most common configuration management tools have a big and active user community,
    which often means that you will be able to find existing code for the system you
    are trying to automate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理系统可能是经典DevOps驱动型组织中最为人熟知的组成部分。它们存在于大多数公司（包括企业市场中），并迅速替代了自制的Shell、Python和Perl脚本。有很多理由说明配置管理系统应该成为你环境的一部分。一个原因是，它们提供了领域特定语言，这提升了代码的可读性，而且它们是专门为组织在配置系统时出现的特定需求量身定制的。这也导致了很多有用的内置功能。此外，最常见的配置管理工具都有庞大且活跃的用户社区，这通常意味着你能找到已有的代码来自动化你正在使用的系统。
- en: Some of the most popular configuration management tools include **Puppet**,
    **Chef**, **SaltStack**, and **Ansible**. While all of those options are fairly
    good, this book will focus on Ansible, the easiest of the four tools mentioned.
    There are a number of key characteristics that make Ansible a very popular and
    easy-to-use solution. Unlike other configuration management systems, Ansible is
    built to work without a server, a daemon, or a database. You can simply keep your
    code in source control and download it on the host whenever you need to run it
    or use a push mechanism through SSH. The automation code you write is in YAML
    static files, which makes the learning curve a lot less steep than some of the
    other alternatives that use Ruby or specific DSL. In order to store our configuration
    files, we will instead rely on our version control system (in our case, GitHub.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最流行的配置管理工具包括**Puppet**、**Chef**、**SaltStack**和**Ansible**。虽然这些选项都相当不错，本书将重点介绍Ansible，它是四个工具中最易用的。Ansible之所以成为一种非常流行且易于使用的解决方案，有几个关键特性。与其他配置管理系统不同，Ansible被设计为无需服务器、守护进程或数据库即可运行。你可以将代码保存在版本控制中，并在需要时通过SSH使用推送机制将其下载到主机上。你编写的自动化代码是YAML静态文件，这使得学习曲线比使用Ruby或特定DSL的其他替代方案平缓得多。为了存储我们的配置文件，我们将依赖版本控制系统（在我们的案例中是GitHub）。
- en: '**AWS OpsWorks and its Chef integration**: While Amazon hasn''t really released
    a service dedicated to configuration management, it supports Chef and Puppet within
    the OpsWorks service. Unlike the services we have explored so far in the book,
    OpsWorks aims at being a *complete application life cycle, including resource
    provisioning, configuration* *management, application deployment, software updates,
    monitoring, and access control**. *If you are willing to sacrifice some flexibility
    and control, OpsWorks might be able to handle what you need in order to run a
    simple web application. You can learn more about this at [http://amzn.to/1O8dTsn](http://amzn.to/1O8dTsn).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS OpsWorks及其Chef集成**：虽然亚马逊并没有真正发布一个专门用于配置管理的服务，但它在OpsWorks服务中支持Chef和Puppet。与我们在本书中探索的其他服务不同，OpsWorks旨在成为一个*完整的应用程序生命周期管理，包括资源配置、配置管理*、*应用程序部署、软件更新、监控和访问控制**。*如果你愿意牺牲一些灵活性和控制，OpsWorks可能能够满足你运行简单Web应用程序的需求。你可以在[http://amzn.to/1O8dTsn](http://amzn.to/1O8dTsn)了解更多信息。'
- en: Getting started with Ansible
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Ansible
- en: Begin by installing Ansible on your computer. After doing this, create an EC2
    instance that will let us illustrate the basic usage of Ansible. After that, we
    will work on recreating the Hello World Node.js application by creating and executing
    what Ansible calls a playbook. We will then look at how Ansible can run in pull
    mode, which offers a new approach to deploying changes. Finally, we will look
    at replacing the `UserData` block in our CloudFormation template with Ansible
    to combine the benefits of both CloudFormation and our configuration management
    system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在你的电脑上安装Ansible。安装完成后，创建一个EC2实例，我们将通过它来演示Ansible的基本用法。接下来，我们将重新创建Hello World
    Node.js应用程序，通过创建和执行Ansible所称之为的playbook。然后，我们将探讨Ansible如何在拉取模式下运行，这为部署更改提供了一种新的方法。最后，我们将研究如何将`UserData`块替换为Ansible，以便结合CloudFormation和我们的配置管理系统的优势。
- en: Ansible is fairly easy to use and well documented throughout the web. This book
    will cover enough to get you started and up to speed on simple configurations,
    such as the one we need in our examples. However, you might be interested in spending
    a bit more time learning about Ansible in order to be really efficient with it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible非常易于使用，并且在网络上有丰富的文档资源。本书将涵盖足够的内容，帮助你入门并快速掌握简单的配置，例如我们示例中需要的配置。然而，你可能会有兴趣花更多时间学习Ansible，以便能更高效地使用它。
- en: Installing Ansible on your computer
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的计算机上安装Ansible
- en: 'As mentioned before, Ansible is a really simple application with very few dependencies.
    You can install Ansible on your computer using your operating system package manager,
    or through `pip`, as Ansible is written in Python. We will be demonstrating all
    of the outputs from a CentOS 7.x-based Linux distribution, but the process applies
    equally to all supported platforms. (For more information, refer to the following
    link in order to find and install Ansible binaries on your operating system: [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine).) The
    following command will install a number of binaries, libraries, and Ansible modules:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ansible是一个非常简单的应用程序，依赖项非常少。你可以通过操作系统的包管理器或使用`pip`来安装Ansible，因为Ansible是用Python编写的。我们将演示所有的输出来自基于CentOS
    7.x的Linux发行版，但该过程同样适用于所有受支持的平台。（更多信息，请参阅以下链接，了解如何在操作系统上查找并安装Ansible二进制文件：[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-the-control-machine)。）以下命令将安装一些二进制文件、库和Ansible模块：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that no daemon or database is installed at this point. This is because,
    by default, Ansible relies on static files and SSH in order to run. At this point,
    we are ready to use Ansible:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此时没有安装守护进程或数据库。这是因为默认情况下，Ansible依赖于静态文件和SSH来运行。此时，我们已经准备好使用Ansible了：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Creating our Ansible playground
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Ansible沙箱环境
- en: To illustrate the basic functionalities of Ansible, we are going to start by
    re-launching our Hello World application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Ansible的基本功能，我们将从重新启动我们的Hello World应用程序开始。
- en: 'In the previous section, we saw how to create a stack using the web interface.
    As you would expect, it is also possible to launch a stack using the command-line
    interface. Go into the `EffectiveDevOpsTemplates` directory where you previously
    generated the `helloworld-cf-v2.template` file and run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何使用Web界面创建堆栈。正如你所期望的，也可以通过命令行界面启动堆栈。进入你之前生成`helloworld-cf-v2.template`文件的`EffectiveDevOpsTemplates`目录，并运行以下命令：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our instance will soon be ready. We can now bootstrap our environment by creating
    a workspace.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实例很快就会准备好。现在我们可以通过创建一个工作区来引导我们的环境。
- en: Creating our Ansible repository
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Ansible仓库
- en: With Ansible, our first goal is to be able to run commands on remote hosts.
    In order to do that efficiently, we need to configure our local environment. Because
    we don't want to have to redo those steps repeatedly, and because, ultimately,
    we want to source-control everything, we will create a new Git repository. To
    do that, we will repeat the same steps that we used when we created our `EffectiveDevOpsTemplate`
    repository.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible，我们的第一个目标是能够在远程主机上运行命令。为了高效地完成这项任务，我们需要配置本地环境。因为我们不想重复进行这些步骤，并且最终我们希望将所有内容都进行版本控制，所以我们将创建一个新的Git仓库。为此，我们将重复之前在创建`EffectiveDevOpsTemplate`仓库时所使用的相同步骤。
- en: 'Once logged into GitHub, create a new repository for the CloudFormation template
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到GitHub后，为CloudFormation模板创建一个新的仓库，如下所示：
- en: In your browser, open this link: [https://github.com/new](https://github.com/new).
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，打开这个链接：[https://github.com/new](https://github.com/new)。
- en: 'Give the new repository the name `ansible`, as shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新的仓库命名为`ansible`，如图所示：
- en: '![](img/b43c4445-ba61-459d-96a5-ad3d035a4b97.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b43c4445-ba61-459d-96a5-ad3d035a4b97.png)'
- en: Check the Initialize this repository with a README checkbox.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“初始化该仓库并附加README”复选框。
- en: Finally, click on the Create repositorybutton.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击“创建仓库”按钮。
- en: 'Once your repository is created, clone it onto your computer as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦仓库创建完成，将其克隆到你的计算机上，如下所示：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that the repository is cloned, we will go into this and copy the template 
    created previously in the new GitHub repository:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在仓库已被克隆，我们将进入该仓库并将之前在新的GitHub仓库中创建的模板复制进去：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At its base, Ansible is a tool that can run commands remotely on the hosts
    in your inventory. The inventory can be managed manually by creating an `INI`
    file where you list all your hosts and/or IPs. It can also be managed dynamically
    if it can query an API. As you can imagine, Ansible is perfectly capable of taking
    advantage of the AWS API in order to fetch our inventory. To do so, we will download
    a Python script from the official Ansible Git repository and give the execution
    permissions as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，Ansible 是一个可以在你清单中的主机上远程执行命令的工具。清单可以通过手动创建一个`INI`文件来管理，文件中列出所有的主机和/或 IP
    地址。如果能够查询 API，也可以动态管理清单。正如你可以想象的那样，Ansible 完全可以利用 AWS API 来获取我们的清单。为此，我们将从官方 Ansible
    Git 仓库下载一个 Python 脚本，并授予执行权限，命令如下：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before we can start testing this Python script, we also need to provide a configuration
    for it. Create a new file in the same directory and call it `ec2.ini`. In this
    file, we will put the following configuration:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始测试这个 Python 脚本之前，我们还需要为它提供一个配置文件。在相同目录下创建一个新文件，并命名为`ec2.ini`。在这个文件中，我们将放入以下配置：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once this is done, you can finally validate that the inventory is working by
    executing the `ec2.py` script as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你可以通过执行如下命令验证清单是否正常工作：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This command should return a big nested JSON of the different resources found
    on your AWS account. Among these is the public IP address of the EC2 instance
    that we created in the previous section. The last step in our bootstrapping is
    to configure Ansible itself, such that it knows how to get the inventory of our
    infrastructure; which user to use when it tries to SSH into our instances; how
    to become a root; and so on. We will create a new file in the same location and
    call it `ansible.cfg`. Its content should be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回一个包含不同资源的大型嵌套 JSON，这些资源是你 AWS 账户中找到的。在这些资源中，有我们在上一节中创建的 EC2 实例的公共 IP 地址。我们引导过程的最后一步是配置
    Ansible 本身，使其知道如何获取我们基础设施的清单；当它尝试通过 SSH 连接到我们的实例时，使用哪个用户；如何获取 root 权限；等等。我们将在相同位置创建一个新文件，并命名为`ansible.cfg`。其内容应如下所示：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At that point, we are ready to start running Ansible commands. Ansible has a
    few commands and some simple concepts. We will first look at the `ansible` command
    and the concept of modules.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经准备好开始运行 Ansible 命令。Ansible 有一些命令和简单的概念。我们将首先了解 `ansible` 命令和模块的概念。
- en: Executing modules
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行模块
- en: The `ansible` command is the main command that drives the execution of the different
    modules on the remote hosts. Modules are libraries that can be executed directly
    on remote hosts. Ansible comes with a number of modules, as listed at [http://bit.ly/24rU0yk](http://bit.ly/24rU0yk).
    In addition to the standard modules, you can also create your own custom modules
    using Python. These are the modules for most common use cases and technologies.
    The first module we will see is a simple module called `ping`, which tries to
    connect to a host and returns `pong` if the host is usable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible` 命令是驱动不同模块在远程主机上执行的主要命令。模块是可以直接在远程主机上执行的库。Ansible 附带了许多模块，模块列表可以在
    [http://bit.ly/24rU0yk](http://bit.ly/24rU0yk) 中找到。除了标准模块外，你还可以使用 Python 创建自己的自定义模块。这些是最常见用例和技术的模块。我们将首先看到的模块是一个简单的模块，叫做
    `ping`，它尝试连接到主机并返回 `pong`，如果主机可用的话。'
- en: 'Module documentation can also be accessed using the `ansible-doc` command,
    shown as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文档也可以通过使用 `ansible-doc` 命令访问，命令如下：
- en: '`$ ansible-doc <Module-Name>`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ ansible-doc <Module-Name>`'
- en: '`$ ansible-doc ping`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ ansible-doc ping`'
- en: Here, `ping` is one of the Ansible module names.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ping` 是 Ansible 模块之一的名称。
- en: 'When creating our Ansible playground section, we created a new EC2 instance
    using CloudFormation. So far, we haven''t looked up the IP address for this. Using
    Ansible and the `ping` module, we will discover that information. As mentioned
    before, we need to be in the `ansible` directory in order to run the `ansible`
    command. The command is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Ansible 游乐场部分时，我们使用 CloudFormation 创建了一个新的 EC2 实例。到目前为止，我们还没有查找该实例的 IP 地址。使用
    Ansible 和 `ping` 模块，我们将发现该信息。如前所述，我们需要处于 `ansible` 目录下才能运行 `ansible` 命令。命令如下：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we can see, Ansible was able to find our EC2 instance by querying the AWS
    EC2 API. The newly created instance is now ready to be used.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Ansible 通过查询 AWS EC2 API 成功找到了我们的 EC2 实例。新创建的实例现在已经准备好可以使用了。
- en: '**Configuring SSH**: As Ansible relies heavily on SSH, it is worth dedicating
    a bit of time to configuring SSH through the `$HOME/.ssh/config` file. For instance,
    you can use the following options to avoid having to specify `--private-key` and
    `-u` in the preceding example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置 SSH**：由于 Ansible 强烈依赖 SSH，因此值得花点时间通过 `$HOME/.ssh/config` 文件配置 SSH。例如，你可以使用以下选项来避免在前面的示例中指定
    `--private-key` 和 `-u`：'
- en: '`IdentityFile ~/.ssh/EffectiveDevOpsAWS.pem`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityFile ~/.ssh/EffectiveDevOpsAWS.pem`'
- en: '`User ec2-user StrictHostKeyChecking no`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`User ec2-user StrictHostKeyChecking no`'
- en: '`PasswordAuthentication no`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasswordAuthentication no`'
- en: '`ForwardAgent yes`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForwardAgent yes`'
- en: Once configured, you won't need to provide the `--private-key` option to Ansible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，你将不再需要为 Ansible 提供 `--private-key` 选项。
- en: Running arbitrary commands
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行任意命令
- en: 'The `ansible` command can also be used to run arbitrary commands on remote
    servers. In the following example, we will only run the `df` command on hosts
    matching `18.206.223.*`  for their public IP address (you will need to adapt this
    command to match your instance public IP, as returned in the `ping` command in
    the previous example):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible` 命令也可以用于在远程服务器上运行任意命令。在以下示例中，我们将仅在匹配 `18.206.223.*` 公共 IP 地址的主机上运行
    `df` 命令（你需要根据前面 `ping` 命令中返回的实例公共 IP 调整此命令）：'
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have a basic understanding of how Ansible works, we can start combining
    calls to different Ansible modules to put in place for automation. This is called
    creating a **playbook**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Ansible 的工作原理有了基本的了解，我们可以开始结合调用不同的 Ansible 模块来实现自动化。这就叫做创建 **playbook**。
- en: Ansible playbooks
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible playbooks
- en: Playbooks are the files that contain Ansible's configuration, deployment, and
    orchestration language. By creating those files, you sequentially define the state
    of your systems, from the OS configuration down to application deployment and
    monitoring. Ansible uses YAML, which is fairly easy to read. For that reason,
    an easy way to get started with Ansible, similarly to what we did with CloudFormation, is
    to look at some examples inside the official Ansible GitHub repository, available
    at [https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples).
    Alternatively, you can even look in my repository, which makes it fairly simple
    and easy to understand playbooks, and which can be found at  [https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)
    for the book *Automation with Ansible*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks 是包含 Ansible 配置、部署和编排语言的文件。通过创建这些文件，你可以按顺序定义系统的状态，从操作系统配置到应用程序部署和监控。Ansible
    使用 YAML，易于阅读。因此，类似于我们在 CloudFormation 中所做的，开始使用 Ansible 的一个简单方法是查看官方 Ansible GitHub
    仓库中的一些示例，网址是 [https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples)。或者，你甚至可以查看我的仓库，该仓库使理解
    playbooks 变得相对简单，并且可以在 [https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja](https://github.com/yogeshraheja/Automation-with-Ansible-By-Yogesh-Raheja)
    找到，这本书是 *Automation with Ansible*。
- en: Creating a playbook
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 playbook
- en: Ansible provides a number of best practices on their website, available at [http://bit.ly/1ZqdcLH](http://bit.ly/1ZqdcLH).
    One emphasis in their documentation is on using roles. One crucial way to organize
    your playbook content is Ansible's *roles* organization feature, which is documented
    as part of the main playbooks page. Creating roles is a key component in making
    Ansible code sharable and modular enough so that you can reuse your code across
    services and playbooks. To demonstrate a proper structure, we are going to create
    a role that our playbook will then call.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 在其网站上提供了一些最佳实践，网址是 [http://bit.ly/1ZqdcLH](http://bit.ly/1ZqdcLH)。他们文档中的一个重点是使用角色。组织
    playbook 内容的一个关键方法是 Ansible 的 *角色* 组织功能，这部分内容在主 playbooks 页面中有详细说明。创建角色是使 Ansible
    代码可共享和模块化的关键，这样你就可以在不同的服务和 playbooks 中重复使用你的代码。为了演示正确的结构，我们将创建一个角色，然后在我们的 playbook
    中调用它。
- en: Creating roles to deploy and start our web application
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建角色以部署和启动我们的 web 应用程序
- en: 'We are going to use roles to recreate the Hello World stack we made previously using
    the `UserData` block of CloudFormation. If you recall, the `UserData` section
    looked roughly like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用角色重新创建之前使用 CloudFormation 的 `UserData` 块创建的 Hello World 堆栈。如果你还记得，`UserData`
    部分大致是这样的：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will notice three different types of operation in the preceding script.
    We are first preparing the system to run our application. To do that, in our example,
    we are simply installing a Node.js package. Next, we copy the different resources
    needed to run the application. In our case, this is the JavaScript code and the
    upstart configuration. Finally, we start the service. As always when doing programming,
    it is important to keep the code DRY. If deploying and starting our application
    is very unique to our Hello World project, installing Node.js likely isn't. In
    order to make the installation of Node.js a reusable piece of code, we are going
    to create two roles—one to install Node.js, and one to deploy and start the Hello
    World application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在前面的脚本中有三种不同类型的操作。首先，我们准备系统来运行我们的应用程序。为了做到这一点，在我们的示例中，我们只是安装了一个 Node.js
    包。接下来，我们复制运行应用所需的不同资源。在我们的例子中，这些资源是 JavaScript 代码和启动配置。最后，我们启动服务。像编程中的其他任务一样，保持代码的
    DRY（Don't Repeat Yourself）原则非常重要。如果部署和启动我们的应用程序非常独特于 Hello World 项目，安装 Node.js
    可能不是。为了使 Node.js 的安装成为可重用的代码，我们将创建两个角色——一个用于安装 Node.js，另一个用于部署和启动 Hello World
    应用程序。
- en: 'By default, Ansible expects to see roles inside a `roles` directory at the
    root of the Ansible repository. So, the first thing we need to do is to go inside
    the `ansible` directory that we created under the *Creating our Ansible repository* section.
    Create the `roles` directory inside, and `cd` the following into it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible 期望在 Ansible 仓库的根目录下看到一个 `roles` 目录。因此，首先我们需要进入在 *创建我们的 Ansible
    仓库* 部分下创建的 `ansible` 目录。在其中创建 `roles` 目录，并通过以下命令进入它：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now create our roles. Ansible has an `ansible-galaxy` command that can
    be used to initialize the creation of a role. The first role we will look into
    is the role that will install Node.js:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的角色了。Ansible 提供了一个 `ansible-galaxy` 命令，可以用来初始化角色的创建。我们将首先查看安装 Node.js
    的角色：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As briefly mentioned, Ansible, like most other configuration management systems,
    has a strong support community who share roles online through [h](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[p](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[://g](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[x](https://galaxy.ansible.com/)[y](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[n](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[i](https://galaxy.ansible.com/)[b](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[e](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[c](https://galaxy.ansible.com/)[o](https://galaxy.ansible.com/)[m](https://galaxy.ansible.com/)[/](https://galaxy.ansible.com/).
    In addition to using the `ansible-galaxy` command to create the skeleton for new
    roles, you can also use `ansible-galaxy` to import and install community supported
    roles.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ansible 和大多数其他配置管理系统一样，拥有一个强大的支持社区，社区成员通过 [h](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[t](https://galaxy.ansible.com/)[p](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[://g](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[x](https://galaxy.ansible.com/)[y](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[a](https://galaxy.ansible.com/)[n](https://galaxy.ansible.com/)[s](https://galaxy.ansible.com/)[i](https://galaxy.ansible.com/)[b](https://galaxy.ansible.com/)[l](https://galaxy.ansible.com/)[e](https://galaxy.ansible.com/)[.](https://galaxy.ansible.com/)[c](https://galaxy.ansible.com/)[o](https://galaxy.ansible.com/)[m](https://galaxy.ansible.com/)[/](https://galaxy.ansible.com/)
    分享角色。在使用 `ansible-galaxy` 命令创建新角色的骨架时，你还可以使用 `ansible-galaxy` 导入和安装社区支持的角色。
- en: 'This creates a `nodejs` directory, and a number of sub-directories that will
    let us structure the different sections of our role. We will enter this directory
    with the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个 `nodejs` 目录，并生成若干子目录，帮助我们结构化角色的不同部分。我们可以使用以下命令进入该目录：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The most important directory inside the `nodejs` directory is the one called
    `tasks`. When Ansible executes a playbook, it runs the code present in the `tasks/main.yml`
    file. Open the file with your favorite text editor.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodejs` 目录中最重要的目录是名为 `tasks` 的目录。当 Ansible 执行一个 playbook 时，它会运行 `tasks/main.yml`
    文件中的代码。用你喜欢的文本编辑器打开这个文件。'
- en: 'When you first open `tasks/main.yml`, you will see the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开 `tasks/main.yml` 文件时，你将看到以下内容：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The goal of the `nodejs` role is to install Node.js and `npm`. To do so, we
    will proceed similarly to how we did with the `UserData` script, and use the `yum` command
    to perform those tasks.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodejs` 角色的目标是安装 Node.js 和 `npm`。为此，我们将以类似于我们在 `UserData` 脚本中所做的方式进行操作，使用
    `yum` 命令来执行这些任务。'
- en: 'When writing a task in Ansible, you sequence a number of calls to various Ansible
    modules. The first module we are going to look at is a wrapper around the `yum`
    command. The documentation on it is available at [http://bit.ly/28joDLe](http://bit.ly/28joDLe).
    This will let us install our packages. We are also going to introduce the concept
    of loops. Since we have two packages to install, we will want to call the `yum`
    module twice. We will use the operator''s `with_items`**.** All Ansible codes
    are written in YAML, which is very easy to start with and use. After the initial
    three dashes and comments, which indicate the start of a YAML file, we are going
    to call the `yum` module in order to install our packages:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中编写任务时，你会按顺序调用多个 Ansible 模块。我们首先要查看的模块是 `yum` 命令的包装器。有关它的文档可以在 [http://bit.ly/28joDLe](http://bit.ly/28joDLe)
    上找到。它将允许我们安装我们的包。我们还将引入循环的概念。由于我们有两个包需要安装，我们将希望调用 `yum` 模块两次。我们将使用操作符的 `with_items`**。**
    所有的 Ansible 代码都是用 YAML 编写的，这非常容易入门并使用。在初始的三个破折号和注释之后（这表示 YAML 文件的开始），我们将调用 `yum`
    模块来安装我们的包：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Whenever Ansible runs that playbook, it will look at packages installed on the
    system. If it doesn't find the `nodejs` or `npm` packages, it will install them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Ansible 运行该剧本时，它将检查系统上已安装的包。如果没有找到 `nodejs` 或 `npm` 包，它将会安装它们。
- en: 'Your file should look like the example available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml).
    This first role is complete. For the purpose of this book, we are keeping the
    role very simple, but you can imagine how, in a more production-type environment,
    you might have a role that will install specific versions of Node.js and `npm`,
    fetch the binaries directly from [https://nodejs.org/en/](https://nodejs.org/en/),
    and maybe even install specific dependencies. Our next role will be dedicated
    to deploying and starting the Hello World application that we built previously.
    We are going to go one directory up back into the `roles` directory, and call
    `ansible-galaxy` one more time:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件应该看起来像在 [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/nodejs/tasks/main.yml)
    中提供的示例一样。第一个角色完成了。为了本书的目的，我们保持这个角色非常简单，但你可以想象，在更具生产性质的环境中，你可能会有一个角色来安装特定版本的 Node.js
    和 `npm`，直接从 [https://nodejs.org/en/](https://nodejs.org/en/) 获取二进制文件，甚至可能安装特定的依赖项。我们的下一个角色将专注于部署并启动我们之前构建的
    Hello World 应用程序。我们将返回到 `roles` 目录，向上移动一层，并再次调用 `ansible-galaxy`：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Like before, we will now go inside the newly created `helloworld` directory
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前一样，我们现在将进入新创建的 `helloworld` 目录，方法如下：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This time, we will explore some of the other directories present. One of the
    sub-directories that was created when we ran the `ansible-galaxy` command was
    the directory called `files`. Adding files to that directory will give us the
    ability to copy files on the remote hosts. To do so, we are first going to download
    our two files in this directory as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将探索一些其他的目录。我们在运行 `ansible-galaxy` 命令时创建的子目录之一就是名为 `files` 的目录。将文件添加到该目录可以让我们在远程主机上复制文件。为了实现这一点，我们将首先按照以下步骤下载这两个文件：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now use task files to perform the copy on the remote system. Open the
    `tasks/main.yml` file and, after the initial three dashes and comments, add the
    following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用任务文件在远程系统上执行复制操作。打开 `tasks/main.yml` 文件，在最初的三个破折号和注释之后，添加以下内容：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are taking advantage of the copy module documented at [h](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[p](http://bit.ly/1WBv08E)[://b](http://bit.ly/1WBv08E)[i](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[.](http://bit.ly/1WBv08E)[l](http://bit.ly/1WBv08E)[y](http://bit.ly/1WBv08E)[/1W](http://bit.ly/1WBv08E)[B](http://bit.ly/1WBv08E)[v](http://bit.ly/1WBv08E)[08E](http://bit.ly/1WBv08E)
    to copy our application file in the home directory of the `ec2-user`. On the last
    line of that call, we add a notify option at the end (note how the `notify` statement
    is aligned with the call to the copy module). Notify actions are triggers that
    can be added at the end of each block of tasks in a playbook. In this example,
    we are telling Ansible to call the restart `helloworld` directive if the file
    `helloworld.js` changed, and not to perform a restart if nothing is changed in
    the code (we will define how to do a restart of the `helloworld` application in
    a different file a bit later).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在利用文档中提到的 `copy` 模块，参考链接为 [h](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[p](http://bit.ly/1WBv08E)[://b](http://bit.ly/1WBv08E)[i](http://bit.ly/1WBv08E)[t](http://bit.ly/1WBv08E)[.](http://bit.ly/1WBv08E)[l](http://bit.ly/1WBv08E)[y](http://bit.ly/1WBv08E)[/1W](http://bit.ly/1WBv08E)[B](http://bit.ly/1WBv08E)[v](http://bit.ly/1WBv08E)[08E](http://bit.ly/1WBv08E)，将我们的应用程序文件复制到
    `ec2-user` 的主目录。在该调用的最后一行，我们在末尾添加了一个 `notify` 选项（注意 `notify` 语句如何与 `copy` 模块的调用对齐）。通知动作是可以添加到每个任务块末尾的触发器。在这个例子中，我们告诉
    Ansible，当文件 `helloworld.js` 发生变化时调用重启 `helloworld` 指令，而如果代码没有发生变化，则不执行重启操作（稍后我们会在另一个文件中定义如何重启
    `helloworld` 应用程序）。
- en: One of the big differences between CloudFormation and Ansible is that Ansible
    is expected to run multiple times throughout the lifetime of your systems. A lot
    of the functionalities built into Ansible are optimized for long-running instances.
    As such, the `notify` option makes it easy to trigger events when a system changes
    state. Similarly, Ansible will know to stop the execution when an error encountered
    prevents outages as far as possible.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 和 Ansible 之间的一个主要区别是，Ansible 预计将在系统生命周期内多次运行。Ansible 内置的许多功能都是针对长时间运行的实例进行了优化。因此，`notify`
    选项使得在系统状态发生变化时触发事件变得非常容易。类似地，当遇到错误时，Ansible 会自动停止执行，以尽量避免出现故障。
- en: 'Now that we have copied our application file, we can add our second file, the
    `upstart` script. After the previous call to copy the `helloword.js` file, we
    are going to add the following call:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经复制了应用程序文件，可以添加我们的第二个文件——`upstart` 脚本。在前一个 `helloword.js` 文件的复制调用之后，我们将添加以下调用：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The last task we need to perform is to start our service. We will use the `service`
    module for that. The module documentation is available at [http://bit.ly/22I7QNH](http://bit.ly/22I7QNH):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的最后一个任务是启动我们的服务。我们将使用 `service` 模块来实现。模块文档可以在 [http://bit.ly/22I7QNH](http://bit.ly/22I7QNH)
    找到：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our task file is now completed. You should end up with something resembling
    the sample available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务文件现在已经完成。你最终应该得到类似于 [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/tasks/main.yml)
    的文件。
- en: 'Having finished our task file, we are going to move on to the next file, which
    will give Ansible knowledge of how and when to restart `helloworld`, as called
    out in the `notify` parameter of our task. These types of interaction are defined
    in the `handler` section of the role. We are going to edit the `handlers/main.yml`
    file. Here too, we are going to use the `service` module. The following is a comment:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 完成任务文件后，我们将继续处理下一个文件，该文件将让 Ansible 知道何时以及如何重启 `helloworld`，正如我们在任务的 `notify`
    参数中所指定的那样。这些类型的交互在角色的 `handler` 部分定义。我们将编辑 `handlers/main.yml` 文件。在这里，我们也将使用 `service`
    模块。以下是一个注释：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following to the `main.yml` file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `main.yml` 文件：
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: No surprises here; we are using the same module we previously used to manage
    the service. We need one more step in our role. In order for the `helloworld`
    role to work, the system needs to have Node.js installed. Ansible supports the
    concept of role dependencies. We can explicitly tell that our `helloworld` role
    depends on the `nodejs` role we previously created, so that, if the `helloworld`
    role is executed, it will first call the `nodejs` role and install the necessary
    requirements to run the app.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外；我们使用的是之前用于管理服务的相同模块。我们在角色中需要一个额外的步骤。为了使 `helloworld` 角色正常工作，系统需要安装
    Node.js。Ansible 支持角色依赖的概念。我们可以明确告知我们的 `helloworld` 角色依赖于我们之前创建的 `nodejs` 角色，因此，如果执行
    `helloworld` 角色，它将首先调用 `nodejs` 角色并安装运行应用所需的依赖。
- en: 'Open the `meta/main.yml` file. This file has two sections. The first one, under
    `galaxy_info`, lets you fill in the information on the role you are building.
    If you wish, you can ultimately publish your role on GitHub and link it back into
    `ansible-galaxy` to share your creation with the Ansible community. The second
    section at the bottom of the file is called `dependencies`and this is the one
    we want to edit to make sure that `nodejs` is present on the system prior to starting
    our application. Remove the square brackets ([]) and add an entry to call `nodejs`
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `meta/main.yml` 文件。该文件分为两个部分。第一部分在 `galaxy_info` 下，允许您填写您正在构建的角色信息。如果您愿意，最终可以将您的角色发布到
    GitHub 并将其链接回 `ansible-galaxy`，与 Ansible 社区共享您的创作。文件底部的第二部分称为 `dependencies`，这是我们想要编辑的部分，确保在启动应用之前系统上存在
    `nodejs`。去掉方括号（[]），并添加以下条目来调用 `nodejs`：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Your file should look like the sample available at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml).
    This concludes the creation of the code for the role. From a documentation standpoint,
    it is good practice to also edit `README.md`. Once done, we can move on to creating
    a playbook file that will reference our newly created role.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您的文件应与 [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/blob/master/Chapter03/ansible/roles/helloworld/meta/main.yml) 中的示例类似。这标志着角色代码的创建完成。从文档编写的角度来看，良好的做法是编辑
    `README.md`。完成后，我们可以继续创建一个将引用我们新创建角色的 playbook 文件。
- en: Creating the playbook ﬁle
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 playbook 文件
- en: 'At the top level of our Ansible repository (two directories up from the `helloworld`
    role), we are going to create a new file called `helloworld.yml`. In this file,
    we are going to add the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 Ansible 仓库的顶层（位于 `helloworld` 角色的上两层目录），我们将创建一个名为 `helloworld.yml` 的新文件。在此文件中，我们将添加以下内容：
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This basically tells Ansible to execute the `helloworld` role onto the hosts
    listed in the `target` variable, or `localhost` if the target isn't defined. The
    `become` option will tell Ansible to execute the role with elevated privileges
    (in our case, `sudo`). At this point, your Ansible repository should look like
    the example at [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible).
    We are now ready to test our playbook.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上告诉 Ansible 将 `helloworld` 角色应用到 `target` 变量中列出的主机上，或者如果未定义目标，则应用于 `localhost`。`become`
    选项将告诉 Ansible 以提升的权限执行该角色（在我们的例子中是 `sudo`）。此时，您的 Ansible 仓库应与 [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter03/ansible) 中的示例类似。我们现在准备好测试我们的
    playbook 了。
- en: 'Note that in practice, on a bigger scale, the roles sections could include
    more than a single role. If you deploy multiple applications or services to a
    target, you will often see playbook looking like this. In later chapters, we will
    see more examples of this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实际操作中，规模更大的角色部分可能不止一个角色。如果您向目标部署多个应用或服务，您经常会看到像这样的 playbook。在后续章节中，我们将看到更多的示例：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Executing a playbook
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 playbook
- en: 'The execution of playbooks is done using the dedicated `ansible-playbook` command.
    This command relies on the same Ansible configuration file that we used previously,
    and therefore, we want to run the command from the root of our Ansible repository.
    The syntax of the command is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 playbooks 使用专门的 `ansible-playbook` 命令。此命令依赖于我们之前使用的相同的 Ansible 配置文件，因此，我们希望从
    Ansible 仓库的根目录运行此命令。命令的语法如下：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will first run the following command (adapt the value of the `private-key`
    option):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先运行以下命令（调整`private-key`选项的值）：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The option `-e` (or `--extra-vars`) allows us to pass extra options for execution.
    In our case, we are defining the `target` variable (which we declared in the `hosts`
    section of our playbook) to be equal to `ec2`. This first `ansible-playbook` command
    will tell Ansible to target all EC2 instances. The `--list-hosts` option will
    make Ansible return a list of hosts that match the hosts criteria, but it won''t
    actually run anything against those hosts. The output of the command will be something
    like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e`（或`--extra-vars`）选项允许我们传递额外的执行选项。在我们的案例中，我们将`target`变量（在剧本的`hosts`部分声明）定义为`ec2`。这个第一个`ansible-playbook`命令将告诉Ansible以EC2实例为目标。`--list-hosts`选项会让Ansible返回一个符合主机标准的主机列表，但不会实际对这些主机执行任何操作。命令的输出结果类似于以下内容：'
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `list-hosts` option is a good way to verify your inventory and, on more
    complex playbooks with more specific host values, to verify which hosts would
    run actual playbooks, allowing you to verify that they are targeting the hosts
    you expect.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-hosts`选项是验证清单的好方法，对于更复杂的剧本，尤其是有更具体主机值的情况，它能够帮助验证哪些主机会运行实际的剧本，从而确保它们指向你期望的主机。'
- en: 'We now know which hosts will be impacted if we were to use this value for the
    target. The next thing we want to check is what will happen if we run our playbook.
    The `ansible- playbook` command has an option `-C` (or `--check`) that will try
    to predict the change a given playbook will make; this is sometimes also called
    **dry-run** mode in Ansible:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，如果我们使用这个值作为目标，将会影响哪些主机。接下来我们要检查的是，如果我们运行我们的剧本，会发生什么。`ansible-playbook`命令有一个`-C`（或`--check`）选项，它会尝试预测给定剧本将会进行的更改；有时这也被称为Ansible中的**干运行**模式：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running that command will execute our playbook in dry-run mode. Through that
    mode, we can ensure that the proper tasks will be executed. Because we are in
    dry-run mode, some of the modules don''t really find everything they need in order
    to simulate how they would run. This is the reason why we sometimes see service
    start errors at the end of the service module. If you see this, then don''t worry,
    it will get executed when the packages are installed in the real-mode. Having
    verified the hosts and code, we can finally run `ansible-playbook` and execute
    our changes in a real-mode as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令会在干运行模式下执行我们的剧本。通过这种模式，我们可以确保正确的任务会被执行。由于我们处于干运行模式，一些模块可能无法找到它们需要的一切资源来模拟它们的执行方式。这就是为什么我们有时会看到服务启动错误出现在服务模块末尾。如果你看到这种情况，不用担心，等到在实时模式中安装软件包时，任务会正确执行。经过验证主机和代码后，我们最终可以运行`ansible-playbook`并在实时模式下执行我们的更改，如下所示：
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is very similar to the `--check` command, except that this time,
    the execution is performed in real-mode. Our application is now installed and
    configured, and we can verify that it is running correctly as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果与`--check`命令非常相似，唯一不同的是这次执行是在实时模式下进行的。我们的应用程序现在已经安装并配置完毕，接下来我们可以通过以下方式验证其是否正常运行：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We were able to reproduce what we did previously with CloudFormation using
    Ansible. Now that we have tested our first playbook, we can commit our changes.
    We will do that in two commits to break down the initialization of the repository
    and the creation of the role. From the root of your Ansible repository, run the
    following commands:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地使用Ansible重现了之前使用CloudFormation所做的操作。现在我们已经测试了第一个剧本，我们可以提交我们的更改。我们将分两次提交，以便拆分仓库的初始化和角色的创建。在你的Ansible仓库的根目录下，运行以下命令：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Canary-testing changes
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金丝雀测试变更
- en: 'One of the great benefits of using Ansible to manage services is that you can
    easily make changes to your code and quickly push the change. In some situations
    where you have a big fleet of services managed by Ansible, you may wish to push
    out a change only to a single host to make sure things are how you expect them
    to be. This is often called **canary testing**. With Ansible, doing this is really
    easy. To illustrate that, we are going to open the `roles/helloworld/files/helloworld.js` file
    and then simply change the response on line 11 from `Hello World` to `Hello World,
    Welcome again`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible管理服务的一个巨大好处是，你可以轻松地对代码进行更改并快速推送该更改。在一些情况下，如果你有一大批由Ansible管理的服务，你可能希望仅将更改推送到单个主机，以确保一切如你所预期的那样运行。这通常被称为**金丝雀测试**。使用Ansible，执行这一操作非常简单。为了说明这一点，我们将打开`roles/helloworld/files/helloworld.js`文件，然后简单地将第11行的响应从`Hello
    World`更改为`Hello World, Welcome again`：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Save the file, and then run `ansible-playbook` again. Do this with the `--check`
    option first:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后再次运行`ansible-playbook`。首先使用`--check`选项执行：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This time, Ansible detects only two changes. The first one overwrites the application
    file and the second one executes the `notify` statement, which means restarting
    the application. Seeing that it is what we expect, we can run our playbook without
    the `--check` options:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Ansible 只检测到两个更改。第一个覆盖了应用程序文件，第二个执行了`notify`语句，这意味着重新启动应用程序。看到这正是我们预期的，我们可以在没有`--check`选项的情况下运行我们的
    playbook：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This produces the same output as in our previous command, but this time the
    change is in effect:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生的输出与我们之前的命令相同，但这次更改已经生效：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our change was very simple, but if we had done this by updating our CloudFormation
    template, CloudFormation would have had to create a new EC2 instance to make it
    happen. Here, we simply updated the code of the application and pushed it through
    Ansible on the target host. We will now revert this change locally in Git as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的更改非常简单，但如果我们通过更新 CloudFormation 模板来完成，CloudFormation 就需要创建一个新的 EC2 实例来实现这一点。在这里，我们只是更新了应用程序的代码，并通过
    Ansible 将其推送到目标主机。现在，我们将在 Git 中本地撤销这一更改，操作如下：
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will demonstrate this by removing the changes from the EC2 instance as we
    illustrate a new concept. In the next section, we will be running Ansible asynchronously
    in a reverse mode (in this case, in pull mode).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过移除 EC2 实例上的更改来演示这一点，同时说明一个新的概念。在下一节中，我们将以异步方式在反向模式下（在这种情况下为拉模式）运行 Ansible。
- en: '**The sooner, the better: **Being able to push changes in seconds instead of
    minutes may seem like a small win, but it isn''t. Speed matters; it is what sets
    apart successful start-ups and technologies. The ability to deploy new servers
    in minutes instead of days is a big factor in cloud adoption. Similarly, the recent
    success of containers, as we will see later in the book, is also likely driven
    by the fact that it only takes seconds to run a new container, while it still
    takes minutes to start a virtual server.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**越早越好：**能够在几秒钟内推送更改而不是几分钟，可能看起来是一个小的胜利，但其实不是。速度很重要，它是区分成功的初创公司和技术的关键因素。能够在几分钟内而不是几天内部署新服务器是云计算采纳的一个重要因素。同样，容器的近期成功，正如我们在本书后面看到的，可能也是因为运行一个新容器只需要几秒钟，而启动一个虚拟服务器仍然需要几分钟。'
- en: Running Ansible in pull mode
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以拉模式运行 Ansible
- en: Having the ability to instantly make a change like we just did is a very valuable
    feature. We could easily and synchronously push the new code out and verify that
    the Ansible execution was successful. On a larger scale, while being able to change
    anything across a fleet of servers remains as valuable as in our example, it is
    also sometimes a bit trickier. The risk with making changes that way is that you
    have to be very disciplined with regards to not pushing changes to only a subset
    of hosts, and forgetting other hosts that are also sharing the role that just
    got updated. Otherwise, the increasing number of changes between the Ansible configuration
    repository and the running servers quickly makes running Ansible a riskier operation.
    For those situations, it is usually preferable to use a pull mechanism that will
    automatically pull in the changes. Of course, you don't have to choose one or
    the other—it is easy to configure both push and pull mechanisms to deploy changes.
    Ansible provides a command called `ansible-pull`, which, as its name suggests,
    makes it easy to run Ansible in pull mode. The `ansible-pull` command works very
    much like `ansible-playbook`, except that it starts by pulling your code from
    your GitHub repository.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 能够像刚才那样即时进行更改是一个非常有价值的功能。我们可以轻松并同步地推送新的代码，并验证 Ansible 执行是否成功。在更大规模上，虽然能够在一批服务器上做任何更改仍然像我们的示例一样有价值，但有时也会更加复杂。以这种方式进行更改的风险是，你必须非常有纪律地避免只将更改推送到一部分主机，而忽略其他也在共享刚刚更新角色的主机。否则，随着
    Ansible 配置库和运行中的服务器之间的更改越来越多，运行 Ansible 就会变得更加危险。对于这些情况，通常最好使用一种拉取机制，它会自动拉取更改。当然，你不必选择其中一个——很容易配置推送和拉取机制来部署更改。Ansible
    提供了一条名为`ansible-pull`的命令，顾名思义，它使得在拉模式下运行 Ansible 变得更加容易。`ansible-pull`命令的工作方式与`ansible-playbook`非常相似，不同之处在于它是通过从
    GitHub 仓库中拉取代码开始的。
- en: Installing Git and Ansible on our EC2 instance
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 EC2 实例上安装 Git 和 Ansible
- en: 'Since we need to be able to run Ansible and Git remotely, we first need to
    install those packages on our EC2 instance. For now, we will do that by manually
    installing those two packages. We will implement a reusable solution later in
    this chapter. Since Ansible is a perfect tool for running remote commands and
    this has a module to manage most common requirements such as installing packages,
    instead of logging in on the host through `ssh` and running some commands, we
    are going to use Ansible to push out those changes. We will install Git and Ansible
    from the EPEL `yum` repository. This will require running commands as **root**,
    which you can do with the help of the `become` option. After adapting the IP address
    of your EC2 instance, run the following commands:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要能够远程运行 Ansible 和 Git，因此我们首先需要在 EC2 实例上安装这些软件包。现在，我们将通过手动安装这两个软件包来完成这项工作。稍后在本章中，我们会实现一个可重用的解决方案。由于
    Ansible 是一个非常适合执行远程命令的工具，并且它有一个模块可以管理大多数常见需求，如安装软件包，因此，我们将不通过 `ssh` 登录到主机并运行一些命令，而是使用
    Ansible 来推送这些更改。我们将从 EPEL `yum` 仓库安装 Git 和 Ansible。这将需要以 **root** 身份运行命令，你可以借助
    `become` 选项来实现。调整 EC2 实例的 IP 地址后，运行以下命令：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: With `ansible-pull`, our goal is for Ansible to apply the change locally. We
    can make a change to our Ansible repository in order to optimize this operation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ansible-pull`，我们的目标是让 Ansible 在本地应用更改。我们可以对 Ansible 仓库进行修改，以优化这一操作。
- en: Configuring Ansible to run on localhost
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Ansible 在 localhost 上运行
- en: 'Since `ansible-pull` relies on Git to locally clone the repository and execute
    it, we don''t need the execution to happen over SSH. Go to the `root` directory
    of your Ansible repository to create a new file. The file should be called `localhost`
    and it should contain the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ansible-pull`依赖于 Git 来本地克隆仓库并执行操作，我们不需要通过 SSH 来进行执行。请进入你的 Ansible 仓库的`root`目录，创建一个新文件。文件名应为`localhost`，并且文件内容应包含以下内容：
- en: '[PRE70]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Essentially, what we are doing is creating a static inventory and asking `ansible`
    to run commands in local mode (as opposed to using SSH) when the target host is
    `localhost`. We can save the changes and commit the new file to GitHub as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们所做的就是创建一个静态清单，并要求 `ansible` 在目标主机为 `localhost` 时以本地模式（而不是使用 SSH）运行命令。我们可以保存更改并将新文件提交到
    GitHub，如下所示：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Adding a cron job to our EC2 instance
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的 EC2 实例添加一个 cron 作业
- en: 'We are now going to create a cron tab entry to periodically call `ansible-pull`.
    Here, too, we will rely on Ansible to create our cron job remotely. Run the following
    command by adapting the IP address:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个 cron 表条目，以定期调用 `ansible-pull`。在这里，我们同样依赖于 Ansible 来远程创建我们的 cron 作业。运行以下命令时，请根据需要调整
    IP 地址：
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the preceding command, we are telling Ansible to use the `cron` module targeting
    our `ec2` instance. Here, we are providing a name that Ansible will use to track
    the cron job over time, telling `cron` to run the job every `10` minutes, followed
    by the command to execute and its parameters. The parameters we are giving to
    `ansible-pull` are the GitHub URL of our branch, the inventory file we just added
    to our repository, and a `sleep` parameter that will make the command start sometime
    between `1` and `60` seconds after the call started. This will help spread out
    the load on the network and prevent all node services from restarting at the same
    time if we have more than one server. After waiting for a bit, we can verify that
    our change is effective through the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们告诉 Ansible 使用 `cron` 模块，目标是我们的 `ec2` 实例。在这里，我们提供了一个名称，Ansible 将用它来跟踪
    cron 作业，告诉 `cron` 每 `10` 分钟运行一次该作业，接着是要执行的命令及其参数。我们给 `ansible-pull` 的参数包括我们分支的
    GitHub URL，我们刚刚添加到仓库中的清单文件，以及一个 `sleep` 参数，这将使命令在启动后的 `1` 到 `60` 秒之间某个时刻启动。这有助于分散网络负载，防止如果我们有多个服务器时，所有节点服务同时重启。等待片刻后，我们可以通过以下命令验证更改是否生效：
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: After manually integrating Ansible to the EC2 instance we created using CloudFormation,
    we can now formalize the procedure.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 CloudFormation 手动将 Ansible 集成到我们创建的 EC2 实例后，现在可以正式化该过程。
- en: Integrating Ansible with CloudFormation
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Ansible 与 CloudFormation 集成
- en: While there are different strategies to integrate Ansible to CloudFormation,
    in our situation there is an obvious path to take. We are going to take advantage
    of the `UserData` field, and initialize Ansible through the `ansible-pull` command.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有不同的策略可以将 Ansible 集成到 CloudFormation 中，但在我们的情况下，显然有一条明确的路径可以选择。我们将利用 `UserData`
    字段，并通过 `ansible-pull` 命令初始化 Ansible。
- en: 'We are now going to start the Troposphere script that we created earlier in
    this chapter. We will duplicate this and call the new script as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将启动本章之前创建的 Troposphere 脚本。我们将复制它，并将新脚本命名如下：
- en: '[PRE74]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Go to your template repository and duplicate the previous template as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 转到你的模板仓库，并按如下方式复制先前的模板：
- en: '[PRE75]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, open the `ansiblebase-cf-template.py` script with your editor. To keep
    the script readable, we will first define several variables. Before the declaration
    of the application port, we will define an application name:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用你的编辑器打开`ansiblebase-cf-template.py`脚本。为了保持脚本的可读性，我们将首先定义几个变量。在应用端口声明之前，我们将定义一个应用名称：
- en: '[PRE76]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We will also set a number of constants around the GitHub information. Replace
    the value of `GithubAccount` with your GitHub username or GitHub organization
    name as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置一些关于 GitHub 信息的常量。将`GithubAccount`的值替换为你的 GitHub 用户名或 GitHub 组织名称，如下所示：
- en: '[PRE77]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After the definition of `GithubAnsibleURL`, we are going to create one more
    variable that will contain the command line we want to execute in order to configure
    the host through Ansible. We will call `ansible-pull` and use the `GithubAnsibleURL`
    and `ApplicationName` variables that we just defined. This is what this looks
    like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`GithubAnsibleURL`之后，我们将创建一个新变量，该变量包含我们希望执行的命令行，用于通过 Ansible 配置主机。我们将调用`ansible-pull`并使用我们刚刚定义的`GithubAnsibleURL`和`ApplicationName`变量。它看起来像这样：
- en: '[PRE78]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We are now going to update the `UserData` block. Instead of installing Node.js,
    downloading our application files and starting the service, we will change this
    block to install `git` and `ansible`, execute the command contained in the `AnsiblePullCmd`
    variable, and finally create a cron job to re-execute that command every `10`
    minutes. Delete the previous `ud` variable definition and replace it with the
    following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`UserData`块。我们将不再安装 Node.js、下载应用文件并启动服务，而是将这个块更改为安装`git`和`ansible`，执行`AnsiblePullCmd`变量中包含的命令，最后创建一个
    cron 任务，每`10`分钟重新执行该命令。删除之前的`ud`变量定义，并用以下内容替换：
- en: '[PRE79]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can now save our file, use it to create our JSON template, and test it.
    Your new script should look like the sample at [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以保存文件，使用它来创建我们的 JSON 模板，并进行测试。你新的脚本应该像这个示例一样：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ansiblebase-cf-template.py):'
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can even create a new stack yourself. For example, let''s say `helloworld`,
    instead of changing the existing `ansible` stack. In this case, you need to run
    the following command for stack creation:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以自己创建一个新的堆栈。例如，假设是`helloworld`，而不是更改现有的`ansible`堆栈。在这种情况下，你需要运行以下命令来创建堆栈：
- en: '[PRE81]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can now wait until the execution is complete:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以等待执行完成：
- en: '[PRE82]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that the stack creation is complete, we can query CloudFormation to get
    the output of the stack and, more specifically, its public IP address:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在堆栈创建完成，我们可以查询 CloudFormation 获取堆栈的输出，特别是它的公共 IP 地址：
- en: '[PRE83]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And finally, we can verify that our server is up and running as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以验证服务器是否已启动并正常运行，如下所示：
- en: '[PRE84]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can now commit our newly created `troposphere` script to our GitHub repository
    as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将新创建的`troposphere`脚本提交到我们的 GitHub 仓库，如下所示：
- en: '[PRE85]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We now have a complete solution for efficiently managing our infrastructure
    using code. We demonstrated this through a very simple example. However, as you
    can imagine, everything is applicable to bigger infrastructure with a greater
    number of services. This section is almost over; we can now delete our stack to
    free up the resources that we are currently consuming. In the earlier part of
    the chapter, we did this using the web interface. As you can imagine, this can
    also be done easily using the following command-line interface:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了一个完整的解决方案，可以通过代码高效地管理我们的基础设施。我们通过一个非常简单的示例演示了这一点。不过，正如你所想象的，所有这些也适用于更大规模的基础设施和更多的服务。本节几乎结束；我们现在可以删除我们的堆栈，以释放我们当前消耗的资源。在本章前面部分，我们通过
    Web 界面做到了这一点。正如你所想象的，这也可以通过以下命令行接口轻松完成：
- en: '[PRE86]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note that if you have created a new `helloworld` stack for this example, then
    remove that too using the following command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你为这个示例创建了新的`helloworld`堆栈，则可以使用以下命令将其删除：
- en: '[PRE87]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Monitoring
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: As you probably know by now, monitoring and measuring everything is an important
    aspect of a DevOps-driven organization. On the internet, you will find a number
    of well written blog posts and examples of how to efficiently monitor CloudFormation
    and Ansible. When working on monitoring CloudFormation, you will want to subscribe
    to an SNS topic for your stack creation to receive all events relating to your
    stack life cycle. It is also important to look out for CloudFormation stack creation
    failure. Ansible has a system of callbacks that will also give you a way to create
    some automation around the Ansible execution. Similarly to CloudFormation, receiving
    notifications when Ansible fails to run is important (it's even more important
    when Ansible is configured to run in pull mode).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，监控和度量一切是 DevOps 驱动组织的一个重要方面。在互联网上，你会找到许多撰写良好的博客文章和示例，展示如何高效地监控 CloudFormation
    和 Ansible。在处理 CloudFormation 的监控时，你需要订阅与你的堆栈创建相关的 SNS 主题，以接收所有与堆栈生命周期相关的事件。关注
    CloudFormation 堆栈创建失败也非常重要。Ansible 有一个回调系统，它同样提供了围绕 Ansible 执行创建自动化的方式。与 CloudFormation
    类似，当 Ansible 执行失败时接收通知也很重要（当 Ansible 配置为拉取模式时，这一点尤为重要）。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to efficiently manage infrastructure by using
    code. We also explored CloudFormation, an AWS service that allows you to create
    templates for your different services in order to describe each AWS component
    used, as well as its configuration. In order to simplify the creation of those
    templates, we looked at a couple of options, ranging from CloudFormation designer,
    a tool with a graphic user interface, to Troposphere, a Python library. After
    that, we looked at configuration management, one of the most well-known aspects
    of the DevOps philosophy. To illustrate this topic, we looked at Ansible, one
    of the most popular configuration management solutions. We first looked at the
    different ways to use Ansible commands and ran simple commands against our infrastructure.
    We then looked at how to create playbooks, which allowed us to orchestrate the
    different steps to deploy our web server. Finally, we looked at how Ansible can
    be used in pull mode, which usually makes more sense when managing sizable infrastructure.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过代码高效地管理基础设施。我们还探索了 CloudFormation，这是一个 AWS 服务，允许你为不同的服务创建模板，以描述每个
    AWS 组件及其配置。为了简化这些模板的创建，我们看了几个选项，从带有图形用户界面的 CloudFormation 设计工具，到 Python 库 Troposphere。随后，我们研究了配置管理，这是
    DevOps 思想中最著名的方面之一。为了说明这个话题，我们研究了 Ansible，这是最流行的配置管理解决方案之一。我们首先查看了使用 Ansible 命令的不同方式，并在我们的基础设施上运行了简单的命令。然后我们学习了如何创建
    playbook，这使我们能够编排不同的步骤来部署我们的 Web 服务器。最后，我们讨论了如何在拉取模式下使用 Ansible，这通常在管理大规模基础设施时更为合理。
- en: 'We now have a good production environment that is ready to host any application,
    and we have seen how to architect it and monitor our servers. In Chapter 5, *Adding
    Continuous Integration and Continuous Deployment*, we will continue to use CloudFormation
    and Ansible, but in the context of software delivery: we will learn how to put
    in place continuous integration testing and continuous deployment.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个良好的生产环境，已准备好托管任何应用程序，我们也看到了如何设计它并监控我们的服务器。在第五章，*添加持续集成与持续部署*，我们将继续使用
    CloudFormation 和 Ansible，但将在软件交付的背景下进行：我们将学习如何实施持续集成测试和持续部署。
- en: Questions
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does IaC stand for?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IaC 代表什么？
- en: How can a simple Hello World application be deployed using the AWS CloudFormation
    Console?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 AWS CloudFormation 控制台部署一个简单的 Hello World 应用程序？
- en: List some of the popular SCM offerings. How is a GitHub account useful for source
    control management?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一些流行的 SCM 提供商。GitHub 账户在源代码管理中有何作用？
- en: Install Git (Local Version Control) package, clone your GitHub global repository
    created in the previous example and push your `helloworld-cf.template` to your
    GitHub repository.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Git（本地版本控制）包，克隆你在之前示例中创建的 GitHub 全局仓库，并将你的 `helloworld-cf.template` 推送到 GitHub
    仓库。
- en: What is Ansible? List some of its important characteristics.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Ansible？列出它的一些重要特性。
- en: Further reading
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'In order to explore this topic in more detail, please visit the following links:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地探索这个话题，请访问以下链接：
- en: '*AWS CloudFormation details* at [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS CloudFormation 详情* 见 [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)'
- en: '*Troposphere – Python library to create AWS CloudFormation descriptions* at [https://github.com/cloudtools/troposphere](https://github.com/cloudtools/troposphere)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Troposphere – 用于创建 AWS CloudFormation 描述的 Python 库* 在 [https://github.com/cloudtools/troposphere](https://github.com/cloudtools/troposphere)'
- en: '*Ansible configuration management tool* at [https://docs.ansible.com/ansible](https://docs.ansible.com/ansible)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ansible 配置管理工具* 在 [https://docs.ansible.com/ansible](https://docs.ansible.com/ansible)'
