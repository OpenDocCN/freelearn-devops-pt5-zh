- en: '*Chapter 8*: Deploying Docker Apps to Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第八章*：将 Docker 应用程序部署到 Kubernetes'
- en: 'Recently, lots of container orchestrators have sprung up like mushrooms after
    a rainstorm, but one orchestrator is poised to dominate the market: Kubernetes,
    from the Cloud Native Computing Foundation. Google originally released Kubernetes
    with the intention of bringing the same level of sophistication to the world of
    open source container runtimes as it has been doing for years internally with
    the Borg clustering system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，很多容器编排工具如雨后春笋般涌现，但有一个编排工具准备主导市场：Kubernetes，来自云原生计算基金会。Google 最初发布 Kubernetes
    的目的是将其内部使用的 Borg 集群系统的复杂性引入开源容器运行时世界。
- en: We will begin by learning more about different Kubernetes distributions and
    why you might want to use each one. We will start with using Kubernetes on a local
    development workstation, and then install a sample application locally.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解不同的 Kubernetes 发行版以及为什么你可能会选择使用每个版本。我们将从在本地开发工作站上使用 Kubernetes 开始，然后在本地安装一个示例应用程序。
- en: As we progress through the chapter, you will learn how to create a Kubernetes
    cluster on **Amazon Web Services** (**AWS**) through **Elastic Kubernetes Service**
    (**EKS**), and deploy your application to a cluster running on multiple **Elastic
    Compute Cloud** (**EC2**) nodes. We will use AWS CloudFormation, an infrastructure-as-code
    system, to deploy the EKS cluster. Once we have deployed the cluster to AWS, we
    will learn about using labels and namespaces to organize our applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进展过程中，你将学习如何通过 **Elastic Kubernetes Service**（**EKS**）在 **Amazon Web Services**（**AWS**）上创建一个
    Kubernetes 集群，并将应用程序部署到运行在多个 **Elastic Compute Cloud**（**EC2**）节点上的集群中。我们将使用 AWS
    CloudFormation，这是一个基础设施即代码系统，用于部署 EKS 集群。一旦我们将集群部署到 AWS 后，我们将学习如何使用标签和命名空间来组织我们的应用程序。
- en: Running a Kubernetes cluster is more complex than the alternatives presented
    so far, but it opens up a huge universe of tools and techniques for running clustered
    applications with a vendor-neutral, cloud-native approach. Kubernetes is useful
    not only for cloud deployments, but also for on-premises deployments and local
    development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Kubernetes 集群比迄今为止介绍的其他方案更为复杂，但它为运行集群化应用程序提供了一个庞大的工具和技术世界，采用供应商中立的云原生方法。Kubernetes
    不仅对云部署有用，对本地部署和本地开发也同样适用。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Options for Kubernetes local installation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 本地安装选项
- en: Deploying a sample application – ShipIt Clicker v4
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署示例应用程序 – ShipIt Clicker v4
- en: Choosing a Kubernetes distribution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 Kubernetes 发行版
- en: Getting familiar with Kubernetes concepts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 Kubernetes 概念
- en: Spinning up AWS EKS with CloudFormation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CloudFormation 启动 AWS EKS
- en: Deploying an application with resource limits to Kubernetes on AWS EKS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将带有资源限制的应用程序部署到 AWS EKS 上的 Kubernetes
- en: Using AWS Elastic Container Registry with AWS EKS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AWS EKS 上使用 AWS Elastic Container Registry
- en: Using labels and namespaces to segregate environments
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签和命名空间来隔离环境
- en: Let's get started by getting Kubernetes running on our local workstation. Then,
    we will look at the various Kubernetes distributions available.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在本地工作站上启动 Kubernetes 开始。然后，我们将了解可用的各种 Kubernetes 发行版。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to set up Kubernetes on your local workstation,
    either through Docker Desktop or by installing a Kubernetes distribution, such
    as Minikube. In addition, to deploy your containers to AWS, you will need an account
    set up in advance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要在本地工作站上设置 Kubernetes，可以通过 Docker Desktop 或安装 Kubernetes 发行版（如 Minikube）。此外，为了将容器部署到
    AWS，你需要提前设置好 AWS 账户。
- en: 'You can sign up for an AWS account at the following URL if you haven''t already
    done so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有 AWS 账户，可以通过以下网址注册：
- en: '[https://aws.amazon.com/](https://aws.amazon.com/)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/](https://aws.amazon.com/)'
- en: The code files for this chapter can be downloaded from the `chapter8` directory
    at [https://github.com/PacktPublishing/Docker-for-Developers/](https://github.com/PacktPublishing/Docker-for-Developers/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从 `chapter8` 目录下载，网址为 [https://github.com/PacktPublishing/Docker-for-Developers/](https://github.com/PacktPublishing/Docker-for-Developers/)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码演示：
- en: '[https://bit.ly/3fXO5xy](https://bit.ly/3fXO5xy)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3fXO5xy](https://bit.ly/3fXO5xy)'
- en: Options for Kubernetes local installation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 本地安装选项
- en: You need to set up a local Kubernetes installation in order to build, package,
    and test your Docker application in preparation for deploying it to a production
    installation in the cloud. Please review the Kubernetes *Getting Started* documentation
    ([https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)). This
    documentation calls this local environment a **learning environment**. Think of
    the local environment as a way to learn about and test your application before
    you take the application to production with Kubernetes in the cloud. Let's continue
    by weighing up the options, starting with Docker Desktop's Kubernetes support.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要设置一个本地 Kubernetes 安装环境，以便在将 Docker 应用程序部署到云端生产环境之前进行构建、打包和测试。请查阅 Kubernetes
    *入门指南* 文档（[https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)）。这份文档将这个本地环境称为
    **学习环境**。可以将本地环境视为在将应用程序推向云端的生产环境之前，用来了解和测试应用程序的一个途径。接下来，我们将继续评估选项，首先从 Docker
    Desktop 的 Kubernetes 支持开始。
- en: Docker Desktop with Kubernetes
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Kubernetes 的 Docker Desktop
- en: For most people, this is the easiest way to start experimenting with Kubernetes.
    You don't have to set up cloud accounts or do a complicated installation to get
    started if you choose to do this. To install Docker Desktop, follow the download
    links at [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数人来说，这是开始尝试 Kubernetes 的最简单方式。如果您选择这样做，您不需要设置云账户或进行复杂的安装即可开始。要安装 Docker
    Desktop，请访问 [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    下载安装。
- en: 'With recent versions of Docker Desktop, you can enable Kubernetes support and
    run and develop Kubernetes applications on your workstation. Open the Docker Desktop
    application on your workstation and go to the **Preferences** menu to open the
    **Settings** dialog. Tick the **Enable Kubernetes** box and hit the **Apply &
    Restart** button:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近版本的 Docker Desktop 中，您可以启用 Kubernetes 支持，并在工作站上运行和开发 Kubernetes 应用程序。打开工作站上的
    Docker Desktop 应用程序，进入 **首选项** 菜单，打开 **设置** 对话框。勾选 **启用 Kubernetes** 选项，然后点击 **应用并重启**
    按钮：
- en: '![](img/B11641_08_001.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_08_001.jpg)'
- en: Figure 8.1 – Example of enabling Kubernete
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 启用 Kubernetes 的示例
- en: This will activate a single-node Kubernetes cluster on your local workstation.
    Once you have enabled Kubernetes, you are ready to verify that your local installation
    works. See the following section to find out how to do this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将激活您本地工作站上的单节点 Kubernetes 集群。一旦启用了 Kubernetes，您就可以验证您的本地安装是否正常工作。请参见下文了解如何操作。
- en: Minikube
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Minikube
- en: If you don't want to run Kubernetes through Docker Desktop, you should probably
    use Minikube to set up a local Kubernetes single-node cluster environment. This
    is available on Windows, Macintosh, and a wide variety of Linux operating system
    distributions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想通过 Docker Desktop 运行 Kubernetes，您应该使用 Minikube 来设置一个本地的 Kubernetes 单节点集群环境。此环境适用于
    Windows、Macintosh 以及各种 Linux 操作系统发行版。
- en: To install Minikube, follow the directions for your operating system found at
    [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/),
    and then follow the instructions in the following section to verify that your
    Minikube installation works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Minikube，请根据您的操作系统访问 [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/)
    上的安装说明，然后按照以下章节中的说明验证您的 Minikube 安装是否正常工作。
- en: Verifying that your Kubernetes installation works
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 Kubernetes 安装是否正常工作
- en: 'Interacting with Kubernetes is done mostly through the **command-line interface**
    (**CLI**). You can issue the following command to see whether your environment
    is functional; it will show all the running pods, including the system pods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 进行交互大多是通过 **命令行界面** (**CLI**) 完成的。您可以执行以下命令来查看您的环境是否正常工作；该命令将显示所有正在运行的
    pod，包括系统 pod：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will look something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '![Figure 8.2 – Output of kubectl get pods'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – kubectl get pods 输出](img/B11641_08_001.jpg)'
- en: '](img/B11641_08_002.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B11641_08_002.jpg)'
- en: Figure 8.2 – Output of kubectl get pods
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – kubectl get pods 输出
- en: Now that you have Kubernetes running on your local workstation, you can develop
    and deploy applications using Kubernetes. Applications you develop and package
    with Kubernetes can be deployed with the same tools that you use locally – but
    at a much larger scale in the cloud. Before we deploy an application to the cloud,
    though, we should show that we can deploy a packaged application locally.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在本地工作站上运行了 Kubernetes，可以使用 Kubernetes 开发和部署应用程序。你开发并用 Kubernetes 打包的应用程序可以使用你在本地使用的相同工具进行部署——但在云中可以扩展到更大的规模。然而，在将应用程序部署到云端之前，我们应该先展示如何将一个打包的应用程序部署到本地。
- en: Deploying a sample application – ShipIt Clicker v4
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个示例应用程序——ShipIt Clicker v4
- en: Let's imagine that the ShipIt Clicker application introduced in previous chapters
    has been shipped to production and the team responsible for operations is nervous
    about the limits of scaling this application since it is only deployed on one
    server. In order to scale out this Docker application to multiple servers, the
    team has decided to migrate to Kubernetes and package the software for Kubernetes
    using the Helm package manager. To proceed, let's install Helm and test it out.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面章节中介绍的 ShipIt Clicker 应用程序已经上线到生产环境，而负责运维的团队对该应用程序的扩展能力感到担忧，因为它仅部署在一台服务器上。为了将该
    Docker 应用程序扩展到多个服务器，团队决定迁移到 Kubernetes，并使用 Helm 包管理器为 Kubernetes 打包软件。接下来，让我们安装
    Helm 并进行测试。
- en: Installing Helm
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Helm
- en: Helm is to Kubernetes what a package manager is to a modern operating system.
    It allows developers to specify how their application is packaged and deployed
    in a Kubernetes cluster. Helm is not only a package manager, but also a templating
    system for generating Kubernetes configurations and applying those configurations
    in a controlled way. Helm allows developers to define the entire set of containers
    and their interrelated Kubernetes configurations. Once you have defined an application
    in Helm, it becomes simple to install and update that application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 对 Kubernetes 的作用类似于包管理器对现代操作系统的作用。它允许开发人员指定如何在 Kubernetes 集群中打包和部署应用程序。Helm
    不仅是一个包管理器，还是一个用于生成 Kubernetes 配置和以受控方式应用这些配置的模板系统。Helm 允许开发人员定义一整套容器及其相互关联的 Kubernetes
    配置。一旦在 Helm 中定义了一个应用程序，安装和更新该应用程序就变得非常简单。
- en: 'You can install this on macOS easily with Homebrew using the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令，使用 Homebrew 在 macOS 上轻松安装它：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For other operating systems, follow the Helm installation instructions at [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统，请按照 [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)
    上的 Helm 安装说明进行操作。
- en: 'Once you have installed Helm, use it to install the stable Helm repository
    (so that we can install other software packages that Helm supports, such as the
    NGINX Ingress Controller) with the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Helm 后，使用以下命令安装稳定的 Helm 仓库（这样我们就可以安装 Helm 支持的其他软件包，比如 NGINX Ingress 控制器）：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you have installed this, you can use Helm to install applications from
    the catalog to your local Kubernetes instance. You can also use Helm to install
    applications defined in local Helm charts. We will use Helm to deploy ShipIt Clicker
    to Kubernetes, in conjunction with another Helm package, the NGINX Ingress Controller.
    In this chapter, we will first deploy the ShipIt Clicker application to the local
    learning environment Kubernetes cluster, and later, we will deploy ShipIt Clicker
    to the cloud on Amazon EKS.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用 Helm 从目录中安装应用程序到本地 Kubernetes 实例。你还可以使用 Helm 安装在本地 Helm 图表中定义的应用程序。我们将使用
    Helm 将 ShipIt Clicker 部署到 Kubernetes，并结合另一个 Helm 包——NGINX Ingress 控制器。在本章中，我们将首先将
    ShipIt Clicker 应用程序部署到本地学习环境的 Kubernetes 集群，稍后我们将把 ShipIt Clicker 部署到 Amazon EKS
    云环境中。
- en: Deploying the NGINX Ingress Controller and ShipIt Clicker locally
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地部署 NGINX Ingress 控制器和 ShipIt Clicker
- en: 'Let''s use Helm to install a packaged application, the NGINX Ingress Controller,
    and then use it to install ShipIt Clicker. An Ingress Controller is a Kubernetes
    networking proxy that allows requests from the outside to reach applications deployed
    to Kubernetes, with well-defined interfaces to help wire together the applications.
    The stable Helm repository contains the NGINX Ingress Controller. Install it as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Helm 安装一个打包的应用程序——NGINX Ingress 控制器，然后用它来安装 ShipIt Clicker。Ingress 控制器是
    Kubernetes 网络代理，允许外部请求访问部署在 Kubernetes 上的应用程序，并提供清晰的接口来帮助连接这些应用程序。稳定的 Helm 仓库包含了
    NGINX Ingress 控制器。安装步骤如下：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Later in the chapter, we will explore Ingress Controller in more detail. Know
    for now that this simple installation is sufficient to expose services inside
    the Kubernetes cluster with the right configurations to `localhost` so that you
    can test them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将更详细地探讨 Ingress Controller。暂时知道，这个简单的安装已经足够通过正确的配置将服务暴露到 Kubernetes
    集群内部的 `localhost`，以便你进行测试。
- en: 'Next, we will build the ShipIt Clicker Docker container, tag it, and push it
    to Docker Hub. Kubernetes relies on pulling Docker images from a Docker image
    registry, so it is insufficient to only have the container on your local system.
    Issue these commands, replacing `dockerfordevelopers` with your Docker Hub username:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建 ShipIt Clicker Docker 容器、为其打标签，并将其推送到 Docker Hub。Kubernetes 依赖于从 Docker
    镜像注册表拉取 Docker 镜像，因此仅仅在本地系统上拥有容器是不够的。执行以下命令，替换 `dockerfordevelopers` 为你的 Docker
    Hub 用户名：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit the `shipitclicker/values.yaml` file and replace `dockerfordevelopers`
    with your Docker Hub username in this stanza:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `shipitclicker/values.yaml` 文件，并在此段落中将 `dockerfordevelopers` 替换为你的 Docker
    Hub 用户名：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, deploy ShipIt Clicker to the Kubernetes local environment. In this case,
    we will use a local Helm Chart instead of one from a network Helm Chart repository.
    The Helm Chart for ShipIt Clicker is in the GitHub repository, in the `chapter8/shipitclicker`
    directory. Install it with Helm, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 ShipIt Clicker 部署到 Kubernetes 本地环境中。在这种情况下，我们将使用本地 Helm Chart，而不是来自网络 Helm
    Chart 仓库的 Helm Chart。ShipIt Clicker 的 Helm Chart 位于 GitHub 仓库的 `chapter8/shipitclicker`
    目录中。使用 Helm 安装它，命令如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Visit `http://localhost/` to view the ShipIt Clicker application. You should
    see the running application splash screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost/` 来查看 ShipIt Clicker 应用程序。你应该能看到正在运行的应用程序启动画面。
- en: Troubleshooting local installation
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地安装故障排除
- en: If you can't reach the application at `http://localhost/`, you might have another
    web server running on port `80`, such as Apache 2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在 `http://localhost/` 访问应用程序，可能是因为在端口 `80` 上运行了另一个 Web 服务器，例如 Apache 2。
- en: Now that we are running this on Kubernetes, you need to use Kubernetes commands
    to connect to services that are on the inside of the cluster and not exposed through
    the Ingress Controller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 Kubernetes 上运行此应用程序，你需要使用 Kubernetes 命令连接到集群内部的服务，而这些服务并未通过 Ingress Controller
    暴露。
- en: 'To expose the Redis port from the Kubernetes cluster for testing, use the following
    commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Kubernetes 集群中暴露 Redis 端口进行测试，使用以下命令：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that you have deployed the ShipIt Clicker application to a local Kubernetes
    installation, you can proceed with deploying it to a larger cloud environment
    and configuring it for production readiness.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经将 ShipIt Clicker 应用程序部署到本地 Kubernetes 安装中，可以继续将其部署到更大的云环境中，并为生产就绪做配置。
- en: Choosing a Kubernetes distribution
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Kubernetes 发行版
- en: So, how do we host Kubernetes beyond installing it on our workstations? When
    it comes to choosing a Kubernetes distribution, you are presented with a plethora
    of options, as we saw in [*Chapter 5*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080),
    *Alternatives for Deploying and Running Containers in Production*. We are now
    going to revisit some of the most popular options to help you gain an understanding
    of the choices available based on your cloud provider or bare-metal data center
    setup, as well as see why we are choosing to use EKS to demonstrate the migration
    of the ShipIt Clicker sample application to Kubernetes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在不将 Kubernetes 安装在工作站上的情况下托管 Kubernetes 呢？当选择 Kubernetes 发行版时，你会面临许多选择，正如我们在
    [*第 5 章*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080) *生产环境中部署和运行容器的替代方案*
    中所看到的那样。现在，我们将重新回顾一些最流行的选项，帮助你根据你的云服务提供商或裸机数据中心设置，了解可用的选择，并解释为什么我们选择使用 EKS 来演示将
    ShipIt Clicker 示例应用程序迁移到 Kubernetes。
- en: Google Kubernetes Engine
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine
- en: '**Google Kubernetes Engine** (**GKE**) is Google''s key service for hosting
    containers in a Kubernetes-based environment. GKE (formerly known as Google Container
    Engine) was released in an Alpha state in November 2014 and went live in August
    2015 for general usage.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Kubernetes Engine** (**GKE**) 是 Google 在基于 Kubernetes 的环境中托管容器的关键服务。GKE（前身为
    Google Container Engine）在 2014 年 11 月发布了 Alpha 版本，并于 2015 年 8 月开始面向公众上线。'
- en: 'It currently offers one of the most mature Kubernetes services offered by cloud
    providers, including the following features:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它目前提供了云服务商提供的最成熟的 Kubernetes 服务之一，包括以下功能：
- en: A single cluster quick start option for trialing the service
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一集群的快速启动选项，用于试用该服务
- en: Container vulnerability scanning
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器漏洞扫描
- en: Built-in data encryption
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据加密
- en: Multiple channels for upgrading, repairing, and releasing
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种升级、修复和发布渠道
- en: Integration with Google monitoring services
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Google 监控服务的集成
- en: Automatic scaling and load balancing
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展和负载均衡
- en: Google-managed underlying hardware
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 管理的底层硬件
- en: Further documentation for interested readers can be found at the GKE website
    at [https://cloud.google.com/kubernetes-engine/docs](https://cloud.google.com/kubernetes-engine/docs).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣的读者可以在 GKE 网站上找到更多文档：[https://cloud.google.com/kubernetes-engine/docs](https://cloud.google.com/kubernetes-engine/docs)。
- en: Let's now compare this with Amazon's offerings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来与亚马逊的产品进行比较。
- en: AWS EKS
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS EKS
- en: Amazon's answer to serving and managing containers in the cloud is its EKS service.
    As with GKE, Amazon's Kubernetes services, EKS, offers a managed service. Unlike
    Google's offering, it came to the market later, not being available until early
    2018\. However, what EKS loses in maturity, it makes up for in features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊针对云中容器服务和管理的解决方案是其 EKS 服务。与 GKE 一样，亚马逊的 Kubernetes 服务 EKS 提供托管服务。不同于 Google
    的产品，它是稍晚进入市场的，直到 2018 年初才发布。然而，EKS 在成熟度上有所欠缺，但在功能上却弥补了这一点。
- en: 'These features include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性包括：
- en: Serverless hosting via AWS Fargate ([https://aws.amazon.com/fargate/](https://aws.amazon.com/fargate/))
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 AWS Fargate 进行无服务器托管 ([https://aws.amazon.com/fargate/](https://aws.amazon.com/fargate/))
- en: Server deployment options on EC2
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2 上的服务器部署选项
- en: Zero-downtime upgrades and patching
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零停机升级和补丁
- en: Auto-detection of unhealthy nodes
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动检测不健康的节点
- en: Hybrid hosting solutions with AWS Outposts ([https://aws.amazon.com/outposts/](https://aws.amazon.com/outposts/))
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Outposts 的混合托管解决方案 ([https://aws.amazon.com/outposts/](https://aws.amazon.com/outposts/))
- en: Kubernetes Jobs for batch processing
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 批处理作业
- en: You can read more about EKS on the official website at [https://aws.amazon.com/eks/features/](https://aws.amazon.com/eks/features/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方网页上阅读更多关于 EKS 的信息：[https://aws.amazon.com/eks/features/](https://aws.amazon.com/eks/features/)。
- en: We'll be exploring EKS in more detail throughout this chapter and in subsequent
    chapters, mostly since it is the managed Kubernetes offering from the dominant
    cloud vendor. Other distributions have their merits, however, so we will also
    examine some of the other options out there. Next is Red Hat OpenShift.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及后续章节中，我们将更详细地探讨 EKS，主要是因为它是主导云服务商提供的托管 Kubernetes 服务。然而，其他发行版也有其优势，因此我们也将研究一些其他的选择。接下来是
    Red Hat OpenShift。
- en: Red Hat OpenShift
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat OpenShift
- en: OpenShift is a collection of software developed by Red Hat geared toward containerized
    application architectures. Like GKE and EKS, OpenShift is Kubernetes-focused;
    however, where it diverges is with its focus on build-related artifacts and a
    native image repository.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 是由 Red Hat 开发的一组软件，专为容器化应用架构而设计。像 GKE 和 EKS 一样，OpenShift 以 Kubernetes
    为核心；然而，它的不同之处在于，OpenShift 更侧重于构建相关的工件和本地镜像库。
- en: Having used Jenkins in the projects presented in this book, you will now be
    familiar with `kubectl`commands to include mechanisms that replicate the sort
    of CI/CD functionality that you might otherwise have to use software such as Jenkins
    or Spinnaker to get. This includes the ability to create builds, test runs, and
    deployments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中使用 Jenkins 的项目之后，你现在应该熟悉 `kubectl` 命令，了解包括机制在内的 CI/CD 功能，这些功能通常需要使用 Jenkins
    或 Spinnaker 等软件来实现。这包括创建构建、测试运行和部署的能力。
- en: 'There are some other key features that also make OpenShift a desirable option:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他关键特性，使得 OpenShift 成为一个值得选择的选项：
- en: Automated upgrades and life cycle management
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化升级和生命周期管理
- en: Open source code base available on GitHub ([https://github.com/openshift](https://github.com/openshift))
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 上的开源代码库 ([https://github.com/openshift](https://github.com/openshift))
- en: Deploy in any cloud, in a data center, or on-premises
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可部署于任何云环境、数据中心或本地
- en: An image registry
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个镜像注册库
- en: Monitoring and log aggregation
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和日志聚合
- en: For further information on Red Hat OpenShift, make sure to check out the documentation
    on GitHub ([https://github.com/openshift/openshift-docs](https://github.com/openshift/openshift-docs))
    or on the official website ([https://www.openshift.com/](https://www.openshift.com/)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 Red Hat OpenShift 的信息，请务必查看 GitHub 上的文档 ([https://github.com/openshift/openshift-docs](https://github.com/openshift/openshift-docs))
    或访问官方网站 ([https://www.openshift.com/](https://www.openshift.com/))。
- en: Microsoft Azure Kubernetes Service
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft Azure Kubernetes 服务
- en: We've looked at the major players so far, but of course, couldn't go any further
    without mentioning Microsoft's contribution to the Kubernetes ecosystem. For users
    of Microsoft cloud products, **Azure Kubernetes Service** (**AKS**) provides a
    mechanism to serve Docker containers in a Kubernetes-based environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了主要的参与者，但当然，在深入之前，必须提到微软对Kubernetes生态系统的贡献。对于使用微软云产品的用户，**Azure
    Kubernetes Service**（**AKS**）提供了一种机制，用于在基于Kubernetes的环境中提供Docker容器服务。
- en: 'Let''s take a brief tour of what AKS offers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要浏览一下AKS提供的功能：
- en: The elastic provisioning of services
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的弹性供应
- en: Integration with the Azure DevOps and Monitor services
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Azure DevOps和监控服务的集成
- en: Identity and access management with Active Directory
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Active Directory进行身份和访问管理
- en: Failure detection and container health monitoring
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障检测和容器健康监控
- en: Canary deployments
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Log aggregation
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志聚合
- en: As you can see, for Azure users, it has a comparable set of features to those
    available in EKS and GKE. If you would like to learn more, please refer to the
    AKS documentation ([https://docs.microsoft.com/en-us/azure/aks/](https://docs.microsoft.com/en-us/azure/aks/)).
    Here, you will also find a quick start guide for getting a taste of what the service
    has to offer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于Azure用户来说，它提供了一组与EKS和GKE类似的功能。如果你想了解更多信息，请参考AKS文档（[https://docs.microsoft.com/en-us/azure/aks/](https://docs.microsoft.com/en-us/azure/aks/)）。在这里，你还可以找到一个快速入门指南，帮助你快速体验该服务提供的功能。
- en: Before running through the components that form the basis of Kubernetes, let's
    briefly review the other options available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍构成Kubernetes基础的各个组件之前，我们先简要回顾一下其他可用的选项。
- en: Reviewing other relevant options
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾其他相关选项
- en: EKS, OpenShift, GKE, and AKS represent the most popular Kubernetes services
    on the market. However, they are not alone. Digital Ocean offers an option for
    those wishing to get a taste of a managed service outside of deploying your own
    RedShift infrastructure or signing up to the big cloud providers. You can read
    more about it at [https://www.digitalocean.com/products/kubernetes/](https://www.digitalocean.com/products/kubernetes/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: EKS、OpenShift、GKE和AKS代表了市场上最流行的Kubernetes服务。然而，它们并不是唯一的。Digital Ocean为那些希望尝试托管服务，而不是自己部署RedShift基础设施或注册大云服务提供商的用户提供了一个选择。你可以在[https://www.digitalocean.com/products/kubernetes/](https://www.digitalocean.com/products/kubernetes/)阅读更多相关内容。
- en: Many readers will be familiar with IBM, and they too offer cloud-hosting services.
    If you want to try out Kubernetes in their cloud environment, you can find details
    on their website, including how to set up a free cluster ([https://www.ibm.com/cloud/container-service/](https://www.ibm.com/cloud/container-service/)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 许多读者应该熟悉IBM，他们也提供云托管服务。如果你想在他们的云环境中尝试Kubernetes，可以在他们的网站上找到相关详情，包括如何设置一个免费集群（[https://www.ibm.com/cloud/container-service/](https://www.ibm.com/cloud/container-service/)）。
- en: Anyone familiar with VMware might wish to explore their Kubernetes offering
    as well –VMware Tanzu Kubernetes Grid – which has strengths in building hybrid
    clouds ([https://tanzu.vmware.com/kubernetes-grid](https://tanzu.vmware.com/kubernetes-grid)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任何熟悉VMware的用户可能也想了解他们的Kubernetes解决方案——VMware Tanzu Kubernetes Grid——它在构建混合云方面具有优势（[https://tanzu.vmware.com/kubernetes-grid](https://tanzu.vmware.com/kubernetes-grid)）。
- en: Finally, those looking for a fully managed Kubernetes service or those who are
    already customers of Rackspace have the option of checking out their **Kubernetes
    as a Service** (**KaaS**) offerings ([https://www.rackspace.com/managed-kubernetes](https://www.rackspace.com/managed-kubernetes)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，寻求完全托管Kubernetes服务的用户，或者已经是Rackspace客户的用户，可以选择查看他们的**Kubernetes as a Service**（**KaaS**）服务（[https://www.rackspace.com/managed-kubernetes](https://www.rackspace.com/managed-kubernetes)）。
- en: That wraps up our whistle-stop tour of the hosting platforms available for deploying
    your containers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对容器部署托管平台的快速浏览。
- en: 'For the remainder of this chapter, we will be using Amazon''s EKS service.
    If you haven''t created an account, we recommend you sign up for one here now:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分我们将使用Amazon的EKS服务。如果你还没有创建账户，建议你现在立即注册：
- en: '[https://aws.amazon.com/](https://aws.amazon.com/)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/](https://aws.amazon.com/)'
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Users of other cloud providers may find that they can adapt the following sections
    to their own services if they wish.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其他云服务提供商的用户可能会发现，如果愿意，他们可以将以下部分内容适配到自己的服务上。
- en: Let's now dig into the core concepts of Kubernetes, including pods, nodes, and
    namespaces.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨Kubernetes的核心概念，包括pods、nodes和namespaces。
- en: Getting familiar with Kubernetes concepts
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉Kubernetes的概念
- en: 'Now that you know where you can deploy Kubernetes, let''s dive into some of
    the key concepts (including objects, ConfigMaps, pods, nodes, services, Ingress
    Controllers, secrets, and namespaces) and how they work. Let''s start by examining
    an architecture diagram that shows the relationship between the various components
    of the system:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道了可以在哪些地方部署 Kubernetes，让我们深入了解一些关键概念（包括对象、ConfigMap、Pod、节点、服务、Ingress 控制器、秘密和命名空间）以及它们如何工作。我们先从一个架构图开始，展示系统中各个组件之间的关系：
- en: '![Figure 8.3 – Kubernetes architecture diagram'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – Kubernetes 架构图'
- en: '](img/B11641_08_003.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B11641_08_003.jpg)'
- en: Figure 8.3 – Kubernetes architecture diagram
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Kubernetes 架构图
- en: Figure 8.3 – Kubernetes architecture diagram
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Kubernetes 架构图
- en: With Kubernetes, the cluster consists of a control plane that manages all aspects
    of the Kubernetes cluster (including the interface with the cloud provider) and
    a set of workers for the cluster, known as nodes, where the applications hosted
    by the cluster live. Developers and cluster operators interact with Kubernetes
    via the control plane through an API. The processes in the control plane communicate
    with the processes running on the individual worker nodes via the `kubelet` process,
    and the processes on the worker nodes are organized as pods that communicate with
    one another via the `kube-proxy` process that runs on each node.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，集群由一个控制平面和一组工作节点组成。控制平面管理 Kubernetes 集群的各个方面（包括与云提供商的接口），而工作节点是托管集群中的应用程序的地方。开发人员和集群操作员通过控制平面与
    Kubernetes 交互，控制平面中的进程通过 `kubelet` 进程与各个工作节点上的进程进行通信，工作节点上的进程被组织为 Pod，通过每个节点上运行的
    `kube-proxy` 进程相互通信。
- en: Objects
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: The most fundamental concept in Kubernetes is an `kubectl` utility to create,
    query, and modify all the different types of Kubernetes objects, as well as to
    configure the cluster.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中最基本的概念是 `kubectl` 工具，它用于创建、查询和修改各种 Kubernetes 对象，以及配置集群。
- en: The `kubectl` command-line utility can take YAML format files that describe
    the objects and use them to create and update the state of the system. This is
    the most basic way of defining, installing, and upgrading Kubernetes applications.
    The Helm tool we used to install applications takes this a step further by providing
    templating and life cycle capabilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 命令行工具可以接收描述对象的 YAML 格式文件，并使用这些文件来创建和更新系统的状态。这是定义、安装和升级 Kubernetes
    应用程序的最基本方式。我们用于安装应用程序的 Helm 工具则进一步提供了模板化和生命周期管理功能。'
- en: We recommend configuring your application through Helm Charts. You briefly saw
    how to use Helm at the beginning of this chapter. A Helm Chart is simply a set
    of YAML configuration files that contain information about your containerized
    application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐通过 Helm Charts 配置您的应用程序。您在本章开始时简要了解了如何使用 Helm。Helm Chart 只是包含关于您的容器化应用程序信息的一组
    YAML 配置文件。
- en: 'You can create a new Helm Chart using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令创建一个新的 Helm Chart：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sets up a Helm Chart structure with template files that are ready for customization.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这会设置一个 Helm Chart 结构，包含可以定制的模板文件。
- en: ConfigMaps
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConfigMap
- en: Kubernetes handles application configuration with a concept known as a ConfigMap.
    Then, we need to define the configuration for the container itself. This is handled
    through a ConfigMap.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用名为 ConfigMap 的概念来处理应用程序配置。接着，我们需要定义容器本身的配置。这通过 ConfigMap 来处理。
- en: The key idea behind ConfigMaps is that you can separate the important configuration
    from the content of the images themselves. This is done in order to provide better
    portability of your microservices and applications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 的核心理念是，您可以将重要的配置与镜像本身的内容分离开来。这样做是为了更好地实现微服务和应用程序的可移植性。
- en: 'ConfigMaps can be created directly through `kubectl` using the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 可以通过 `kubectl` 使用以下命令直接创建：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A ConfigMap will contain information used by your application, and other key-value
    pairs, such as the namespace. The following example illustrates how an application''s
    ConfigMap might look:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 将包含应用程序使用的信息，以及其他键值对，例如命名空间。以下示例展示了一个应用程序的 ConfigMap 可能是什么样子：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A ConfigMap such as the one we just demonstrated would then be stored inside
    your Helm Chart directory in the templates folder – for example, `shipitclicker/templates/configmap.yaml`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才演示的 ConfigMap 将存储在 Helm Chart 目录中的 templates 文件夹里——例如，`shipitclicker/templates/configmap.yaml`。
- en: With this basic setup in place, you can then install your configuration through
    the `helm install` command. We will be exploring configuration in both its ConfigMap
    and Helm Chart formats in further detail throughout this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本设置完成后，你可以通过`helm install`命令安装你的配置。我们将在本章的后续部分更详细地探讨ConfigMap和Helm Chart格式的配置。
- en: Pods
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pods
- en: Pods in Kubernetes serve the purpose of grouping together *1* to *n* containerized
    components, which are then run in a shared context. They also include shared resources,
    such as IP addresses, storage, and definitions on how containers should be run.
    Multiple containers running together in a pod can communicate with each other
    on fixed ports on `localhost`, simplifying application configuration significantly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的Pod用于将*1*到*n*个容器化组件组合在一起，然后在共享的上下文中运行。它们还包括共享资源，例如IP地址、存储和容器如何运行的定义。在Pod中一起运行的多个容器可以通过`localhost`上的固定端口互相通信，从而大大简化应用配置。
- en: When defining what should be run in a pod, the best approach is to think of
    it as holding all the necessary containers for a system or application. Multiple
    pods can then be added to Kubernetes to scale your application out horizontally.
    This allows you to create redundancy and helps cope with increases in traffic
    and load.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义应该在Pod中运行的内容时，最好的方法是将其视为包含系统或应用所需所有容器的容器组。然后，可以将多个Pod添加到Kubernetes中，水平扩展你的应用。这使你能够创建冗余，并帮助应对流量和负载的增加。
- en: The shared context that the pods use is implemented through Linux concepts such
    as cgroups and namespaces. In [*Chapter 12*](B11641_12_Final_NM_ePub.xhtml#_idTextAnchor278),
    *Introduction to Container Security*, we will explore some of these concepts in
    depth in relation to container security.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Pod所使用的共享上下文是通过Linux概念（如cgroups和namespaces）实现的。在[*第12章*](B11641_12_Final_NM_ePub.xhtml#_idTextAnchor278)《容器安全概述》中，我们将深入探讨一些与容器安全相关的概念。
- en: Nodes
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: Machines that host Docker containers in Kubernetes' ecosystem are known as **nodes**,
    though you may also encounter the terms *minions* or *workers* – they all mean
    the same thing, but node is the official term. Kubernetes supports nodes that
    are either physical or virtual machines. Services such as Amazon's EKS provide
    the mechanisms for deploying node infrastructure. You deploy Kubernetes pods on
    nodes; the pods include both containers and shared resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 托管Docker容器的机器在Kubernetes生态系统中被称为**节点**，尽管你也可能遇到术语*minions*或*workers*——它们的意思相同，但节点是官方术语。Kubernetes支持物理机或虚拟机类型的节点。像Amazon的EKS这样的服务提供了部署节点基础设施的机制。你将Kubernetes
    Pod部署在节点上；Pod包括容器和共享资源。
- en: In the learning environment that we are using, our local development workstation
    is the sole node in the cluster. Later in this chapter, we will be creating a
    Kubernetes cluster with nodes managed by EKS on AWS EC2\. Kubernetes nodes run
    containers through pods and other Kubernetes objects, such as DaemonSets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的学习环境中，我们的本地开发工作站是集群中唯一的节点。在本章稍后的部分，我们将创建一个由EKS管理的Kubernetes集群，节点部署在AWS
    EC2上。Kubernetes节点通过Pod和其他Kubernetes对象（如DaemonSets）来运行容器。
- en: Alternative container runtimes
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 替代的容器运行时
- en: Kubernetes nodes could potentially run different container runtimes. Kubernetes
    not only supports Docker containers, but also other container technologies, including
    containerd, CRI-O, and Frakti. Since this book is about Docker, we will exclusively
    use the Docker runtime in our examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes节点可能运行不同的容器运行时。Kubernetes不仅支持Docker容器，还支持其他容器技术，包括containerd、CRI-O和Frakti。由于本书主要讲解Docker，我们将在示例中专门使用Docker运行时。
- en: Services
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: A Kubernetes service is a way of declaring how your application exposes its
    interfaces to the world. It typically defines a network port that other Kubernetes
    pods can use to communicate with your application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务是一种声明应用如何向外界暴露其接口的方式。它通常定义一个网络端口，其他Kubernetes Pod可以使用该端口与应用进行通信。
- en: 'The Helm Chart for ShipIt Clicker emits a service template that defines a `ClusterIP`
    service definition:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ShipIt Clicker的Helm Chart会发出一个服务模板，定义一个`ClusterIP`服务定义：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This declaration describes the fact that ShipIt Clicker exposes HTTP on port
    `8008` as a service on each pod. This lets other Kubernetes services discover
    and make connections to it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这份声明描述了ShipIt Clicker在每个Pod上通过`8008`端口暴露HTTP作为服务的事实。这让其他Kubernetes服务能够发现并与其建立连接。
- en: Ingress Controllers
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ingress控制器
- en: Kubernetes manages an internal network where the applications in a cluster can
    communicate with one another via a private network. By default, there is no way
    to reach applications running on the inside of a Kubernetes cluster from the outside.
    The Ingress Controller plays the role of a proxy and connection broker. Depending
    on whether you are deploying on-premises or in the cloud, different types of Ingress
    Controller have different uses. For example, earlier in this chapter, we installed
    the `nginx-ingress` Ingress Controller to allow us to reach applications running
    on our local Kubernetes installation. That controller is also useful when you
    want a vendor-neutral way of granting access to Kubernetes applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes管理一个内部网络，在该网络中，集群中的应用程序可以通过私有网络相互通信。默认情况下，无法从外部访问运行在Kubernetes集群内的应用程序。Ingress
    Controller充当代理和连接经纪人。根据你是部署在本地还是云端，不同类型的Ingress Controller有不同的用途。例如，在本章前面，我们安装了`nginx-ingress`
    Ingress Controller，以便让我们能够访问本地Kubernetes安装上运行的应用程序。当你希望以与供应商无关的方式授予访问Kubernetes应用程序的权限时，这个控制器也是很有用的。
- en: Other Ingress Controllers allow Kubernetes to work smoothly with different types
    of external load balancers, such as `aws-alb-ingress-controller`, which enables
    the use of an `k8s-bigip-ctlr`, which enables the use of F5 BIG-IP load balancers,
    which are found in many data centers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Ingress Controllers允许Kubernetes与不同类型的外部负载均衡器（例如`aws-alb-ingress-controller`）平滑协作，`aws-alb-ingress-controller`使得可以使用`k8s-bigip-ctlr`，后者允许使用F5
    BIG-IP负载均衡器，这些负载均衡器在许多数据中心中都有使用。
- en: 'You can use Ingress Controllers to map domain names and HTTP paths to Kubernetes
    services. This makes it really easy to expose different services at different
    URLs. If you had a fleet of microservices, you could expose them at different
    API endpoints using this pattern. You can take advantage of Ingress Controllers
    by declaring an ingress object for your application that advertises how to connect
    your service to the outside world. For the ShipIt Clicker example, we use the
    following to map the service to `localhost` in the default namespace:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Ingress Controllers将域名和HTTP路径映射到Kubernetes服务。这使得在不同的URL下暴露不同的服务变得非常简单。如果你有一组微服务，你可以使用这种模式将它们暴露在不同的API端点上。通过声明一个Ingress对象并为你的应用程序广告如何将你的服务连接到外部世界，你可以利用Ingress
    Controllers。例如，对于ShipIt Clicker示例，我们使用以下方式将服务映射到默认命名空间中的`localhost`：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Kubernetes system handles connections to applications hosted inside the
    cluster from the outside using this Ingress Controllers definition. This means
    that when you are first developing your application, you do not need to worry
    about how it is connected to the outside world. The Kubernetes configurations
    that enable Ingress Controllers can all be managed with Helm Charts, too.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes系统使用这个Ingress Controllers定义处理外部与集群内托管的应用程序的连接。这意味着，当你首次开发你的应用程序时，你不需要担心它是如何连接到外部世界的。启用Ingress
    Controllers的Kubernetes配置也可以通过Helm Charts进行管理。
- en: Next, we will examine how Kubernetes deals with sensitive information – using
    secrets.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Kubernetes如何处理敏感信息——通过使用密钥。
- en: Secrets
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥
- en: Every application has values that need to be protected, from database passwords
    to API keys, so having a mechanism to store and retrieve them securely is an important
    function. In Kubernetes, this is handled with a mechanism called secrets. You
    can use a combination of configuration files and `kubectl` commands for sharing
    and modifying information that needs to be protected with your pods and their
    running containers. Once you have created a secret, you can use it in your application
    through a variety of mechanisms, including exposing a secret as an environment
    variable or creating a file that containers running in a pod can retrieve.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有需要保护的值，从数据库密码到API密钥，因此拥有一个安全存储和检索它们的机制是一个重要功能。在Kubernetes中，这是通过一个名为“secrets”的机制来处理的。你可以使用配置文件和`kubectl`命令的组合来共享和修改需要保护的信息，这些信息与你的Pod及其运行的容器相关联。一旦你创建了一个密钥，你可以通过多种机制在你的应用程序中使用它，包括将密钥暴露为环境变量，或者创建一个文件供在Pod中运行的容器来检索。
- en: 'The key operations in Kubernetes related to secrets are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中与密钥相关的关键操作如下：
- en: Creating a secret
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个密钥
- en: Describing a secret
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述一个密钥
- en: Retrieving a secret
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索一个密钥
- en: Editing a secret
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑一个密钥
- en: Let's explore these four concepts, starting with creating a secret.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个密钥开始，探索这四个概念。
- en: Creating a secret
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个密钥
- en: We can use several procedures to create a secret. This could be done by adding
    it manually on the command line or storing it in a YAML template file and using
    it from there.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a secret stored in a text document via the command line, we can use
    the following commands:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we do this, `kubectl` will take care of encoding the secret for us using
    Base64 encoding.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s prepare a secret another way, with a configuration file. In order to
    prepare a text secret for this file, it must be Base64-encoded. You can do that
    from the command line in macOS or Linux with the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we wanted to instead store the secret in a configuration file, and use `kubectl`
    to add it to Kubernetes, we could create the following `secret-api-token.yaml`
    file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, using the `kubectl apply` command-line option, we can create the secret:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will notice that the configuration file format for the secret is very similar
    to the example ConfigMap we examined.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `shipitclicker` uses Helm to manage its Kubernetes objects, it has
    support for secrets built into its templates. The one secret it references in
    the code in this chapter is related to a Node.js server-side framework setting
    for the Express framework used by the sample application that deals with server
    sessions. This secret is called `SESSION_SECRET`, and it is stored in the `chapter8/shipitclicker/templates/secrets.yaml`
    file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that this uses template expressions for `name` and `namespace` in order
    to align with the other templates that Helm transforms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We created this secret when we installed the `shipitclicker` Helm template earlier
    in the chapter when we used the `helm install` command. That is how you create
    secrets when you use a Helm template.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen several ways of creating secrets, we will show how we
    ask Kubernetes what secrets it knows about.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Describing a secret
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a secret has been created, you can list it using the `kubectl get secrets`command.
    This will list the secrets in a similar way to this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_08_004.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – List of secrets
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the secret, use the `kubectl describe` command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Output of the kubectl describe command showing the secret''s
    metadata'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_005.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Output of the kubectl describe command showing the secret's metadata
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: You will see metadata about your secret displayed, including the key of the
    secret – in this case, `SESSION_SECRET`. It will not show the value of the secret,
    though.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a secret
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A typical way for a Kubernetes application to retrieve a simple secret is to
    define it as an environment variable passed to the container referencing the secret.
    See this excerpt from the rendered Helm chart templates:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that the environment variables mapped to the deployment for the
    `shipitclicker` container reference both the `configMapKeyRef` and `secretKeyRef`
    entries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: To deal with more complex secrets that are complete files, such as SSH private
    keys, the mechanism is similar. See the Kubernetes secrets documentation for more
    scenarios at [https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'For troubleshooting purposes, we can retrieve a secret from Kubernetes from
    the command line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have seen how to retrieve a secret, we will examine how to edit
    secrets.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Editing secrets
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you wish to edit the secret after creating it, use the `kubectl edit` command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will open your default editor (by default, vi) and you can edit the secret.
    You will have to have the Base64-encoded replacement value ready. It will look
    something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can edit secrets directly this way. You might need to redeploy your application
    after updating a secret, depending on how it uses that secret. Having to manage
    this by hand can get complicated, which is one of the reasons why we use Helm
    to package applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Updating the ShipIt Clicker session secret
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For applications deployed with Helm, it is usual practice to make changes through
    the Helm templates instead of using raw `kubectl` commands. Now, we will change
    the ShipIt Clicker `SESSION_SECRET` key using Helm by following this procedure:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a Base64-encoded secret with the following command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Edit the template `chapter8/shipitclicker/templates/secrets.yaml` file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the value outputted by the `openssl` command for the new `SESSION_SECRET`
    value.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `chapter8/shipitclicker/Chart.yaml` file and increment the chart's
    `version` number.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have to do this every time you update a Helm Chart. Then, update the template
    with the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the basic commands to add and edit secrets are very simple.
    Using them in our application is slightly more complex. This should give you a
    taste of how to create a secret value and retrieve information on it to explore
    the feature.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: For further information on secrets, you can check out the latest Kubernetes
    documentation at [https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 14*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316), *Advanced
    Docker Security – Secrets, Secret Commands, Tagging, and Labels*, we look into
    secret storage and usage in relation to Docker Swarm. While Docker Swarm is falling
    out of favor, with many teams switching to Kubernetes, it is important to understand
    these concepts when maintaining legacy systems. Additionally, you may find yourself
    in a position where you have to migrate systems from Docker Swarm to Kubernetes.
    The information provided in this chapter and [*Chapter 14*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316),
    *Advanced Docker Security – Secrets, Secret Commands, Tagging, and Labels*, should
    help you map concepts from one technology to the other.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to partition resources within Kubernetes, we can use a concept called
    namespaces. Namespaces provide a mechanism to group container resources into non-overlapping
    sets, which then allows you to subdivide your Kubernetes resources, based on your
    business needs, within the same cluster. This could include everything from environments
    (development, staging, and production) to groups of microservices. One important
    factor you should consider is that applications in the same namespace can read
    any secret in that namespace, so it represents a security boundary as well.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'It is tempting, once you learn of this feature, to want to use it everywhere,
    but the Kubernetes documentation cautions against this. The main namespaces content
    page ([https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/))
    states the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '"*For clusters with a few to tens of users, you should not need to create or
    think about namespaces at all*."'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, though, that different teams might want to segregate applications
    from one another, and namespaces are a good way to do that as they provide a security
    boundary. Later in this chapter, in the *Using labels and namespaces to segregate
    environments* section, we will explore using this concept to deploy our application
    to both a staging and production environment in AWS.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's set up AWS EKS with CloudFormation in order to deploy our application
    to the public cloud using Kubernetes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Spinning up AWS EKS with CloudFormation
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have walked through a local installation of Kubernetes and explored
    some of the cloud vendor options, we are going to try deploying containers to
    an AWS-hosted Kubernetes environment. This will be the EKS service we briefly
    introduced in the previous section of this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, we will describe how to create and manage an EKS cluster
    using AWS CloudFormation, their infrastructure-as-code service. For more information
    on CloudFormation, be sure to check out the AWS guides and documentation at [https://docs.aws.amazon.com/cloudformation/](https://docs.aws.amazon.com/cloudformation/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have previously created an AWS account or followed the instructions
    under the *Technical requirements* section of this chapter, load up the AWS cloud
    console.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, we need to set up EKS. There are many ways to get a working EKS
    cluster that require varying amounts of work:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Set up everything by hand, step by step through the AWS console. We *do not
    recommend* this approach as it requires deep AWS knowledge to carry out correctly,
    and will lead to a hard-to-replicate environment with poor controls.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write infrastructure-as-code templates from scratch in either AWS CloudFormation
    or Terraform to control all the resources needed. This is an approach that might
    work for you if you are an expert in either CloudFormation or Terraform and have
    an existing investment in CloudFormation or Terraform tooling, but we *do not
    recommend this for beginners*.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `eksctl` tool (see [https://eksctl.io](https://eksctl.io)) to create
    a cluster with a simple CLI tool. This could work well if you are already familiar
    with AWS and want to put your cluster in a specific region and tweak more of the
    parameters of your cluster. We *only recommend this if you are familiar with AWS
    and EKS already*.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Research and adopt infrastructure-as-code templates that someone else has already
    written. Both AWS and many other people have created CloudFormation and Terraform
    templates.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to follow this last approach and use the AWS Quick Start CloudFormation
    templates for EKS to create our first cloud Kubernetes cluster.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the AWS EKS Quick Start CloudFormation templates
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon provides a handy set of CloudFormation templates called Quick Starts,
    built by their expert cloud architects to quickly get you up and running for a
    wide selection of AWS services and scenarios ([https://aws.amazon.com/quickstart/](https://aws.amazon.com/quickstart/)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: We will be using an AWS EKS Quick Start template for the next section of this
    chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: However, before you deploy the EKS Quick Start CloudFormation templates, please
    take a moment to prepare your AWS account for deployment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Preparing an AWS account
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are just starting to use AWS, there are a few critical things to take
    care of before you proceed in order to protect your account. These precautions
    and preparations also apply if you choose a method other than using the AWS Quick
    Start CloudFormation templates to create your EKS cluster.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: If you are already an experienced AWS user and have an AWS `us-east-2` region,
    and you know your public IPv4 address, you can skip ahead to the *Launching the
    AWS EKS Quick Start CloudFormation templates* section. Avoid using an assumed
    IAM role with administrative privileges to create the CloudFormation template,
    though – that can cause some of the child templates to enter an `UPDATE_ROLLBACK_FAILED`
    state, which is difficult to recover from.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Using an IAM administrator user and not the root account user
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, ensure that you are not using the AWS console as the root account
    user. This is a major security risk. You will need an AWS IAM user account with
    administrative privileges. If you have just created your AWS root account, you
    can set one up by following the AWS instructions at [https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Once you have set up this user and enabled billing access for the IAM user as
    per instructions, go to the [https://console.aws.amazon.com/iam/home#/home](https://console.aws.amazon.com/iam/home#/home)
    page and copy the IAM user's sign-in link to the clipboard. Edit your web browser
    bookmarks and use this URL to create an **AWS IAM Login** item. You will want
    to use this to sign in to your AWS account with your administrator account instead
    of using the root account.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'On your local system, create an `eks-notes.txt` file and record the sign-in
    link there. Also, record the **User ARN** value of the administrator user from
    the [https://console.aws.amazon.com/iam/home?region=us-east-2#/users/Administrator](https://console.aws.amazon.com/iam/home?region=us-east-2#/users/Administrator)
    URL:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – AWS IAM user summary for the administrative user'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_006.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – AWS IAM user summary for the administrative user
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: This **Amazon Resource Name** (**ARN**) user is a string, much like a web **Uniform
    Resource Identifier** (**URI**), but it is Amazon-specific. Now that we have set
    up an administrative user, let's set up **multi-factor authentication** (**MFA**)
    to protect both the root account and the administrator user.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MFA
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend that you protect both the root account and every IAM user account
    with administrative privileges using MFA. If someone compromises your root account,
    they could create huge bills by launching expensive cloud resources, steal your
    information, or even delete all your data. When you are getting started, we recommend
    that you use MFA with a virtual MFA device and supporting software such as Google
    Authenticator, Authy, or 1Password.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'For added security, you have the option of using one of the supported hardware
    token solutions, but virtual MFA works fine. Please see the AWS MFA documentation
    for more details on setting up MFA:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/iam/features/mfa/](https://aws.amazon.com/iam/features/mfa/)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Signing in to the AWS console with the IAM user account
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure you have signed out of the root account. Then, use the sign-in URL from
    your `eks-notes.txt` document to sign in to the AWS console with your administrator
    IAM user account before proceeding.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Creating access keys for the IAM administrator user
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use the AWS command-line tools, you will need to generate AWS access
    keys. You can read more about access keys and other types of AWS credentials at
    [https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AWS console, go to the IAM service and look in the **Users** section
    for the administrator user you just created. Then, navigate to the **Security
    credentials** tab and create new access keys by pressing the **Create access key**
    button:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_08_007.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7– AWS IAM user summary for an administrative user
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Download these access keys as a CSV file to your local system. You will need
    to open that file and examine the keys in order to configure the AWS CLI, which
    we will do next.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS CLI on your local workstation
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are going to need a working AWS CLI installation on your local workstation
    to complete the configuration of the EKS cluster. If you don't already have this
    installed, follow the instructions to install it at [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is installed, issue the `aws configure` command and use the access
    ID and secret key from the access key''s CSV file you saved in the previous section
    to configure the CLI to use the administrator user. Verify that it works with
    the `aws sts get-caller-identity` command. Inspect the output to make sure that
    it does not show an error message, and then verify that the ARN that this command
    emits for the active user is the same one as for the administrator user shown
    in the IAM web console. The output should look something like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Output of aws sts get-caller-identity'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_008.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Output of aws sts get-caller-identity
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: You will need this set up when you configure the cluster for the ALB Ingress
    Controller later in the chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EC2 key pair for the EKS cluster
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to perform the initial configuration of the EKS cluster, you will
    need to SSH to an EC2 virtual server that the CloudFormation template sets up,
    known as the bastion host. A `us-east-2` region. Signed in as your IAM administrator
    user, go to [https://console.aws.amazon.com/ec2](https://console.aws.amazon.com/ec2),
    and then make sure you switch your region to **us-east-2** from the region picker:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Switching your AWS region'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_009.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Switching your AWS region
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, find and click on the key pairs link in the menu on the left, create
    a new key pair called `ec2-eks`, and download it. You will need this key pair
    when you configure the EKS cluster. To prepare for that, copy this key pair to
    the `.ssh` directory under your local user home directory and set its permissions
    so that SSH will allow its use:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will need this key to connect to the bastion host for your EKS cluster later.
    Next, make sure you know your public IP address.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Recording your public IP address in CIDR notation
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to restrict access from the internet to the Kubernetes cluster
    by restricting it to just the pubic IPv4 address you are currently using. This
    will keep malicious hackers and people who attack internet hosts from scanning
    your system. To do this, go to [https://whatismyip.com/](https://whatismyip.com/)
    and copy your public IPv4 address in CIDR format, which is the raw numerical address
    with `/32` appended. For example, if it was `192.2.0.15`, the CIDR form of your
    IPv4 address would be `192.2.0.15/32`. On your local system, open your `eks-notes.txt`
    file and record the CIDR address there.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Launching the AWS EKS Quick Start CloudFormation templates
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the documentation on the AWS EKS Quick Start CloudFormation templates
    at [https://aws.amazon.com/quickstart/architecture/amazon-eks/](https://aws.amazon.com/quickstart/architecture/amazon-eks/).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a complete picture of what this offers, read the deployment guide that
    AWS offers related to this quick start:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/quickstart/latest/amazon-eks-architecture/welcome.html](https://docs.aws.amazon.com/quickstart/latest/amazon-eks-architecture/welcome.html)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'At a minimum, review the outline on that page. When you want to proceed with
    deployment, click on the **How to Deploy** section. You will see that you have
    two options when deploying the CloudFormation templates, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy to a new VPC** ([https://fwd.aws/6dEQ7](https://fwd.aws/6dEQ7))'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy to an existing VPC** ([https://fwd.aws/e37MA](https://fwd.aws/e37MA))'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you begin, sign out of the AWS console if you are still signed in with
    the root account user, and sign in as a administrator user using the IAM sign-in
    URL you recorded in the `eks-notes.txt` file.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you start by deploying this infrastructure to a new **Virtual
    Private Cloud** (**VPC**). Click on that link or use the preceding URL to go to
    the CloudFormation stack creation forms. Most of the items in these forms can
    be left at their defaults, but some must be filled out both to complete initial
    cluster configuration and to ensure that you do not accidentally create an unsecure
    configuration.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Guidance for EKS Quick Start CloudFormation creation
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating the CloudFormation stack will require you to fill out a four-page
    CloudFormation parameters form by following the **Deploy into a new VPC** link
    in the previous section. This is the first page of that form:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – CloudFormation form, page 1 of 4: Prepare template'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_010.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10 – CloudFormation form, page 1 of 4: Prepare template'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: This guidance will allow you to complete the items to get a working EKS cluster
    in about 30 minutes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Create Stack – Prerequisite – Prepare Template
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Leave all the items on this form at their defaults and hit the **Next** button.
    This will take you to the **Specify Stack Details** screen.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Specify Stack Details
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can leave almost all of these items at their defaults, but specify items
    for the following parameters:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`us-east-2a`, `us-east-2b`, and `us-east-2c`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.2.0.15/32`.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EKS cluster name**: Choose a short cluster name.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8`.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eks-ec2`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional EKS admin ARN (IAM Role)**: Leave this blank, unless you have
    another AWS IAM role in your account that you want to give access to.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional EKS admin ARN (IAM User)**: Leave this blank, unless you have
    another AWS IAM user in your account that you want to give access to.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes Version**: 1.15.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not use 1.16 or higher if you want to experiment with Spinnaker as described
    in [*Chapter 9*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191), *Cloud-Native
    Continous Deployment Using Spinnaker*, as Spinnaker is not compatible with higher
    versions
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**EKS Public Access Endpoint**: Enabled.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.2.0.15/32`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALB Ingress Controller**: Enabled.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster Autoscaler**: Enabled.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EFS Storage Class**: Enabled.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring Stack**: Prometheus and Grafana.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting these options will ultimately allow you to manage the EKS cluster
    from your local workstation using the `kubectl`, `helm`, and `eksctl` tools. Once
    these are specified, press the **Next** button at the bottom of the form. This
    will take you to the **Configure Stack Options** screen.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Configure Stack Options
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Leave all of these at their defaults. Press the **Next** button at the bottom
    of the form. This will take you to the **Review** screen.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Review
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Scroll to the bottom of the form and check both of the checkboxes acknowledging
    that this might create IAM resources with custom names and that it might require
    the `CAPABILITY_AUTO_EXPAND` capability. Press the **Next** button at the bottom
    of the form to create the CloudFormation template. Wait about 30 minutes and review
    the creation status of the template in the CloudFormation console—it should complete
    without issue. Check that all the CloudFormation templates reach the completed
    state before proceeding. It should look something like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The CloudFormation console with the CREATE_COMPLETE status'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_011.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – The CloudFormation console with the CREATE_COMPLETE status
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Now, your EKS cluster is ready for its initial configuration.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the EKS cluster
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having deployed the CloudFormation template, you will have an environment that
    contains the following AWS services:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: A VPC that serves as networking infrastructure for the cluster
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An EKS Kubernetes control plane managed by AWS
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An EC2 bastion host used to configure the cluster
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes infrastructure, including three EC2 instances serving as nodes deployed
    across three AWS availability zones
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ALB Ingress Controller that will allow outside access to cluster services
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To gain initial access to the cluster, view the CloudFormation outputs for
    the stack and note the IPv4 address marked `BastionIP`. Then, SSH to the host
    with that address, replacing `192.2.10` with that IP address:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the deployment is complete, follow the AWS deployment guide to validate
    the cluster state:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/quickstart/latest/amazon-eks-architecture/step-3.html](https://docs.aws.amazon.com/quickstart/latest/amazon-eks-architecture/step-3.html).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Use some of the commands you have learned about, such as `kubectl get all -A`,
    `kubectl get nodes`, and `kubectl describe service/kubernetes`, to explore the
    cluster configuration from the bastion host.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The bastion node already has `kubectl`, `helm`, and `git` installed, so you
    have the option of using it to perform some cluster maintenance chores. The Helm
    installation even has the stable charts repository already installed, which you
    can verify with the `helm repo list` command.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye on AWS costs
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Once you have deployed the EKS infrastructure, AWS will start charging you by
    the hour while it is running. You will be responsible for all charges incurred
    while the EKS cluster and EC2 servers are running. Keeping this EKS cluster running
    might cost up to **$10-20 per day**. Please visit the **Billing & Cost Management**
    dashboard at [https://console.aws.amazon.com/billing/home?#/](https://console.aws.amazon.com/billing/home?#/)
    in order to see your month-to-date and projected costs. We recommend that you
    have AWS generate cost and usage reports on a regular basis to help you track
    your spending. Information on enabling this can be found at [https://docs.aws.amazon.com/cur/latest/userguide/cur-create.html](https://docs.aws.amazon.com/cur/latest/userguide/cur-create.html).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the ALB Ingress Controller is working
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we enabled the ALB Ingress Controller optional add-in when we created
    the EKS cluster, we can skip the detailed directions in the ALB user guide ([https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html](https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html))
    to set up an ALB Ingress Controller for EKS. Since the ALB Ingress Controller
    is already set up, the cluster will automatically be able to create new Ingress
    Controllers and application load balancers when it finds a correctly annotated
    ingress object.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can deploy the 2048 game described in the last section of
    the user guide to validate that the ALB works as expected.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application with resource limits to Kubernetes on AWS EKS
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, we can set resource limits on an application in order to prevent
    it from consuming all the available CPU and memory resources in the cluster. This
    is desirable to protect the system from resource exhaustion, and to ensure that
    an application that has a memory leak or a bug that causes it to consume more
    CPU than expected does not bring down the entire cluster.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate setting resource limits, we are going to deploy the ShipIt Clicker
    Docker container and Helm charts we deployed to our local Kubernetes installation
    in the *Deploying a sample application* section earlier in this chapter to the
    EKS cluster.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate setting resource limits, we will now look at deploying the ShipIt
    Clicker application to Kubernetes, managed by the AWS EKS service, with CPU and
    memory limits enabled. We will also expose this application to the world using
    an Ingress Controller.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Configuring resource limits to guard against memory leaks and runaway CPU usage
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are deploying to EKS, we want to be sure that our pod's containers
    are good citizens in the cluster. To do this, we will specify both resource requests
    and limits. Requests give Kubernetes guidance about how much of each resource
    it will initially allocate to the application, and will guide the orchestrator
    when it places the containers and pods on the nodes. Kubernetes will only schedule
    a pod on a node if it has adequate headroom to support a request. Limits give
    the orchestrator hard-maximum limits on how much CPU or memory to allocate. If
    a container exceeds its memory limit, its process will be killed with an **out-of-memory**
    (**OOM**) error.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the Helm templates at `chapter8/shipitclicker-eks/` in order
    to make the first set of changes versus the basic Helm template we installed on
    our local system.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'In `chapter8/shipitclicker-eks/values.yaml`, we are now specifying the CPU
    and memory requests and limits for the containers:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These apply both to the Redis and the ShipIt Clicker containers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Annotating ShipIt Clicker to use the ALB Ingress Controller
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some changes are required for the `chapter8/shipitclicker-eks/values.yaml`
    file to make sure that the Ingress Controller annotations are compatible with
    the EKS setup. We need to switch up the annotations so that they are targeted
    toward EKS. Also, we will remove the host restriction and make sure that the configuration
    for paths has a wildcard in it. Since we use a `ClusterIP` service point, we also
    need to use the `ip` target type for the ALB Ingress Controller:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Without these annotations, the ALB Ingress Controller would have trouble connecting
    to the services.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an EKS-ready ShipIt Clicker to EKS
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to the bastion host, clone the repository, and deploy the software with
    Helm:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Check in the AWS EC2 console for evidence that an elastic load balancer is getting
    created. It may take a few minutes to become available. When it does, enter its
    DNS name in a browser and you should see the ShipIt Clicker game.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t see it, troubleshoot by looking at the Ingress Controller logs:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have the ShipIt Clicker application deployed to EKS and exposed
    to the world with an ALB Ingress Controller, let's examine how we can segregate
    environments so that different Docker containers can run without interfering with
    each other.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Using AWS Elastic Container Registry with AWS EKS
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using public images stored in Docker Hub is fine for some applications, but
    for more sensitive applications, you might want to store your Docker containers
    in a private Docker registry. AWS provides just such a registry: **Elastic Container
    Registry** (**ECR**). You can read more about the basics of ECR on the main product
    website at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: In order to get a Kubernetes cluster to use images from a private repository,
    you must configure the cluster with the right credentials so that it can pull
    images from the repository. The process for most repositories is in the Kubernetes
    documentation at [https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: However, AWS ECR uses an enhanced security system that relies on AWS IAM to
    grant temporary access tokens that are used to authenticate with ECR. Kubernetes
    has built-in support for this authentication process, as described in the documentation
    on images regarding using a private registry ([https://kubernetes.io/docs/concepts/containers/images/#using-aws-ec2-container-registry](https://kubernetes.io/docs/concepts/containers/images/#using-aws-ec2-container-registry)).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'When using ECR with Kubernetes, you use an ECR identifier in the specification
    for the images used in pod configurations or their Helm templates. Instead of
    using the default Docker Hub image specifications, you can specify images using
    the following syntax:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '`ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS documentation on EKS explains that the worker nodes that run the pods
    must have the correct IAM policies applied via IAM roles in order to get authentication
    tokens and retrieve the images:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the AWS CloudFormation templates we used to set up the EKS cluster
    produce worker nodes that already have the correct permissions applied, as do
    all clusters set up using the `eksctl` tool, if you set up your cluster with that
    alternative path. The access control rules described in ECR on the preceding EKS
    web page will grant EKS nodes permission to read any images stored in any ECR
    repository on the account.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: So, to use ECR with EKS, all we should have to do is make sure our containers
    are pushed to an ECR repository in the same account with the EKS cluster, and
    that we use the ECR-style repository URIs as the identifiers for the containers
    that run in our Kubernetes pods.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's create an ECR repository so that we can prepare for integrating
    ECR and EKS.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ECR repository
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a web browser, log in to the AWS console. Make sure you switch to the `us-east-2`
    region (the same region where your EKS cluster lives), and then click on the **Services**
    link and choose **Elastic Container Registry**. If you don't have any registries
    created yet, click on the **Get Started** button. The AWS console will prompt
    you for a namespace and repository.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, visit the following URL to start the creation process:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[https://console.aws.amazon.com/ecr/create-repository?region=us-east-2](https://console.aws.amazon.com/ecr/create-repository?region=us-east-2)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, you will see something like this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – The ECR Create repository form'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_012.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – The ECR Create repository form
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the other settings at their defaults. After you create the repository,
    note the URI for your repository; you will need it in order to push containers
    to the registry. You will see the URI on a screen that looks like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – The ECR Repositories page'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_013.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – The ECR Repositories page
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Then, click on the **View push commands** button. This will give you detailed
    instructions on how to use the AWS CLI to get temporary credentials that you can
    use to accomplish a Docker push to the ECR repository.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – pushing ShipIt Clicker to the ECR repository
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow the instructions shown after clicking on the `REPO` value with the hostname
    of your ECR registry from the URI generated in the **Create** form):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If this succeeds, you will see an output similar to the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – A Docker push to ECR'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_08_014.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – A Docker push to ECR
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to use ECR to store Docker images that we
    build through Jenkins and deploy using Spinnaker and Helm.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how we might store Docker container images in an ECR repository,
    we will examine how we can segregate environments using labels and namespaces.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Using labels and namespaces to segregate environments
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: We learned earlier in this chapter what a namespace is. Now, we will explore
    how we can use both namespaces and labels to create separate environments in both
    a local environment and in an EKS cluster.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Local example – labeled environments in the default namespace
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine you are developing the ShipIt Clicker application and want to
    keep a working stable environment deployed so that you can demonstrate it to others
    and compare new behaviors in code that you are changing to stable behavior. While
    you could use namespaces to segregate the application, it would be simpler to
    just deploy the Helm Chart again with deployments that have different labels.
    You can use multiple deployments with distinct labels, along with some template
    overrides, to accomplish this with Helm, without having to deal with the complexity
    of multiple namespaces.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to do the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Define a hostname to use to reach the service.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Ingress Controller for ShipIt Clicker to use that hostname.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure and bump the chart version in `chapter8/shipitclicker/Chart.yaml`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Helm Chart with a different name from the one already deployed, for
    example `shipit-stable`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that we can reach the alternative environment.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's go through each of these steps in order to set up this stable environment
    using namespaces.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple hostnames to the local environment
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The time-tested way to add alternative names for your local environment is to
    edit your operating system hosts file – this is `/etc/hosts` on UNIX-inspired
    systems, such as Linux and macOS, or `C:\Windows\System32\Drivers\etc\hosts` on
    Windows systems. You must do so as a user with administrative privileges, though.
    You might add an entry such as `127.0.0.1 shipit-stable.internal.` to your `hosts`
    file, following some of the guidance at [https://tools.ietf.org/html/rfc6762#appendix-G](https://tools.ietf.org/html/rfc6762#appendix-G)
    to pick a TLD that is unlikely to cause operational problems.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: However, there is an easier way to do this now. You can use a hostname of the
    `name.A.B.C.D.nip.io` form and it will map to whatever IP address you give, thanks
    to the free [https://nip.io/](https://nip.io/) service. This enables the easy
    creation of `localhost` aliases as we can use `shipit-stable.127.0.0.1.nip.io`
    and similar names for local development.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily configuring the Helm Chart for the shipit-stable environment
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Edit the `chapter8/shipitclicker/values.yaml` file to switch up the host so
    that it matches `shipit-stable.127.0.0.1.nip.io`, and bump the chart version.
    Then, use Helm to deploy the app using the command `helm install shipit-stable
    shipitclicker/`. You should then be able to see the application in your web browser
    by going to http://shipit-stable.127.0.0.1.[nip.io/](http://nip.io/).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Staged environments – Dev, QA, staging, and production
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the EKS environment, you could also get a pretty good separation of environments
    just by deploying labeled stacks. You could label the stacks with a prefix or
    suffix name that indicates what environment they are. With ALB support, each separate
    service that is exposed to the world will get its own distinct load balancer,
    whether they are in different namespaces or not.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: But there are some cases where you would want to use namespaces. For example,
    if you host both production and non-production resources in the cluster, you could
    make it so that the namespaces for the non-production resources use quotes. Refer
    to [https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)
    for more information on quotas.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Create a `qa` namespace with `kubectl` and use Helm to deploy ShipIt Clicker
    to that namespace. Then, set a memory quota on that namespace so that it never
    uses more than 1 GB of RAM.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: For even more advanced practices regarding namespaces, you should consult the
    best practices documentation at [https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-organizing-with-namespaces](https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-organizing-with-namespaces).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up a separate environment that is segregated using namespaces,
    we have more flexibility in how we might deploy and manage our applications. Next,
    let's review what we have learned in this chapter.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all about Kubernetes and options for hosting it
    in the cloud. We walked through some of the cloud-hosting platforms on the market
    and then completed a quick overview of the key components of Kubernetes.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we developed a process for deploying our Docker containers to
    AWS EKS, using AWS ECR as a Docker container registry. Here, you also got the
    chance to experiment with Amazon's CloudFormation technology, a platform for developing
    infrastructure as code.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Next, we studied Helm and Helm Charts and built on the ShipIt Clicker application.
    This was stood up in AWS with resource limits.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: You should now feel comfortable with repeating this process for another project
    if you wish!
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Now that our basic Kubernetes setup is ready to go, what other concerns do we
    need to address before we can use it for a scalable production project? We have
    seen how we can use Jenkins for continuous deployment, but it would be tedious
    to write all the scripts required to get the basic Jenkins system to manage a
    complex Kubernetes cluster and deploy applications to it reliably.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has presented a simplified set of Helm Charts that generate Kubernetes
    configurations that result in a running application, but there are some refinements
    we must make in order to make the application production-ready, just as we did
    in previous chapters with Docker Compose.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to introduce Spinnaker as a cloud-native CI/CD
    platform that will help us facilitate CI/CD for a Kubernetes for this exact task.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'These articles may help you get a better handle on some of the essential Kubernetes
    concepts:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'A gentle illustrated introduction to Kubernetes concepts through this tongue-in-cheek
    guide: [https://www.cncf.io/the-childrens-illustrated-guide-to-kubernetes/](https://www.cncf.io/the-childrens-illustrated-guide-to-kubernetes/)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another Cloud Native Computing Foundation illustrated guide to Kubernetes concepts
    featuring Phippy: [https://www.cncf.io/phippy-goes-to-the-zoo-book/](https://www.cncf.io/phippy-goes-to-the-zoo-book/)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why is Kubernetes getting so popular? See this blog article: [https://stackoverflow.blog/2020/05/29/why-kubernetes-getting-so-popular/](https://stackoverflow.blog/2020/05/29/why-kubernetes-getting-so-popular/)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many applications require you to use private Docker image registries, whether
    that is Docker Hub, AWS ECR, or something else. Read this to find out how to integrate
    registry secrets into your Kubernetes configuration files: [https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While this is targeted at customers of Digital Ocean using their Kubernetes
    service, it does an excellent job of explaining NGINX Ingress Controllers: [https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nginx-ingress-on-digitalocean-kubernetes-using-helm](https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nginx-ingress-on-digitalocean-kubernetes-using-helm)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user guide for EKS. This is chock full of super-detailed information about
    running EKS: [https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html](https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploy the Kubernetes dashboard. This is optional but will give you a nice
    web user interface to see more information about the cluster: [https://docs.aws.amazon.com/eks/latest/userguide/dashboard-tutorial.html](https://docs.aws.amazon.com/eks/latest/userguide/dashboard-tutorial.html)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of an advanced configuration using Kubernetes namespaces might involve
    using the Kubernetes **role-based access control** (**RBAC**) system to further
    restrict how applications in different namespaces interact: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn more about the options for EKS installations, including Terraform, using
    a hybrid strategy that mixes NGINX and ALB Ingress Controller, and more: [https://medium.com/](https://medium.com/)@dmaas/setting-up-amazon-eks-what-you-must-know-9b9c39627fbc'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
