- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Windows Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the ever-growing collection of built-in Ansible
    modules that support and interact with Windows-based servers; coming from an almost
    exclusively macOS and Linux background, it seemed odd to be using a tool not natively
    supported on Windows to manage Windows.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of our time in this chapter, I am sure you will agree that looking
    at the options available, the Ansible developers have made managing Windows Server
    workloads with a playbook as seamless and familiar as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch a Windows server instance in Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable features in Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install third-party packages using Chocolatey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Windows server in Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible preparation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows Playbook roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the Playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than trying to run a full Windows Server 2022 locally in a **virtual
    machine** (**VM**), in this chapter, we will cover securely launching and configuring
    a Windows Server 2022 VM hosted in Microsoft Azure. If you are following along,
    you must have an active Microsoft Azure subscription and the Azure **command-line
    interface** (**CLI**) installed.
  prefs: []
  type: TYPE_NORMAL
- en: For details on how to install and configure the Azure CLI, please see the documentation
    at [https://learn.microsoft.com/en-us/cli/azure/install-azure-cli/](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli/).
    If you are following along on a Windows host, I recommend installing the Azure
    CLI within your Windows Subsystem for Linux installation alongside where you installed
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Windows server in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will not use Ansible to deploy the Azure resources as we will do in [*Chapter
    9*](B21620_09.xhtml#_idTextAnchor411), *Moving to the Cloud*; instead, we will
    use the Azure CLI to launch our VM.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As some of the commands in this chapter will be pretty long, I will break them
    up with a backslash. In Linux command lines, the backslash (`\`) followed by a
    newline is a line continuation character. It lets you split a single command over
    multiple lines for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by changing to the `Chapter07` folder within your checked-out copy of
    the repository that accompanies this title and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first two commands set two variables on your command line; the first uses
    the `$MYIP` variable with the public IP address of your current network session.
  prefs: []
  type: TYPE_NORMAL
- en: The second generates a random password using the `openssl` command and assigns
    it to the variable called `$VMPASSWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: The third command copies the content of `$VMPASSWORD` to a file called `VMPASSWORD`;
    this command must be executed in the same folder as the host inventory file, as
    it will be called in our host inventory file, which we will discuss later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I will follow the Azure Cloud Adoption Framework recommendations around resource
    naming and launching the resources in the UK South region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know our IP address and have a password, we can start using the
    Azure CLI to launch resources. The first thing we need to do is make sure that
    we are logged in by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in, we can then create an **Azure Resource Group** by executing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Azure Resource Group is the logic container we will be deploying our Azure
    resources to, the first of which will be an **Azure** **Virtual Network**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will create the Azure Virtual Network with an address
    space of `10.0.0.0/24` and a single subnet using `10.0.0.0/27`; this is where
    we will launch our Windows Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to create a **Network Security Group** to assign to the network
    interface of our VM once it has been launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need this as we will assign a public IP address to the VM, and we don’t
    want to expose our three management ports directly to the internet; instead, we
    want to lock them down to just us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an empty Network Security Group created. Let’s add some rules,
    starting with the rule that opens port `80` to everyone to allow HTTP traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the rule that opens port `3389`, which **Remote Desktop** uses
    to allow you to create a session to the host; we only want this open to us, so
    the command here would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are passing in the `$MYIP` variable we registered when launching
    the resources. This will pass your IP address, and as you can see, we are then
    appending `/32` to the end; this is the **Classless Inter-Domain Routing** (**CIDR**)
    notation for a single IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the rule for Remote Desktop in place, which is how we, as
    end users, will connect to the VM, we need to open the **Windows Remote Management**
    (**WinRM**) port, which is how Ansible will be connecting to the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next of the commands we need to run is the one that launches the VM itself
    and configures it to use the core networking components we have just launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are instructing the Azure CLI to launch a VM that uses the
    `rg-ansible-windows-server-uks` resource group and using all of the network resources
    we launched using the previous commands.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, great, let’s get back to looking at Ansible. However,
    there is one more command we need to run before we can connect to the VM using
    Ansible – and the reason is that while we have a Windows 2022 server up and running,
    the WinRM protocol is not enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to enable this functionality is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This enables a VM Extension on the Azure VM we have just deployed. There are
    many different types of Virtual Machine Extensions; the one we are using is **Custom
    Script Extension**. This extension downloads a script from a URL passed to it
    and then executes a command; in our case, we are downloading the script configuring
    WinRM from the GitHub repository accompanying this title.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the script that will be downloaded at the following URL: [https://raw.githubusercontent.com/PacktPublishing/Learn-Ansible-Second-Edition/main/Scripts/ConfigureRemotingForAnsible.ps1](https://raw.githubusercontent.com/PacktPublishing/Learn-Ansible-Second-Edition/main/Scripts/ConfigureRemotingForAnsible.ps1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that runs once the script is downloaded is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Virtual Machine Extension executes the preceding command, so we do not have
    to run it directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Resource Visualizer in the Azure portal for the resource group should show
    you something that looks like the following overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Reviewing our resources in the Azure Resource Visualizer](img/B21620_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Reviewing our resources in the Azure Resource Visualizer
  prefs: []
  type: TYPE_NORMAL
- en: Once completed, our Windows Server VM is ready to have our Ansible run against
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous section, Ansible will use WinRM to interact with
    our Windows host.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: WinRM provides access to a **Simple Object Access Protocol** (**SOAP**)-like
    protocol called **WS-Management**. Unlike **Secure Shell** (**SSH**), which provides
    the user with an interactive shell to manage the host, WinRM accepts executed
    scripts, and the results are passed back to you.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible requires us to install a few Python modules to enable it to use the
    protocol; these modules need to be installed as they are not typically installed
    alongside Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the module, if you are running on Ubuntu, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, we need to update our environment file to instruct Ansible to
    use the WinRM protocol rather than SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our updated `hosts` file looks like the following file, which is a copy of
    the `hosts.example` file from the `Chapter07` folder in the accompanying repository.
    If you are following along with the exercise, you will need to update yours to
    update the IP address to match that of your Azure Virtual Machine once it has
    been launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The start of the file mirrors what we have been used to so far in that it contains
    a name for a host and the resolvable hostname of the VM, again using the **Nip.io**
    service ([https://nip.io/](https://nip.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take the named host and put it in the `ansible_hosts` group before
    defining a bunch of settings for the group.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these settings instructs Ansible to use `winrm` by setting it as
    the value for the `ansible_connection` key.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the `ansible_user` key; the value is `azureuser`, which we defined
    when we launched the Azure Virtual Machine; and also the `ansible_password` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, at the start of the chapter, we ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This took the random password we generated, that is, `$VMPASSWORD`, and placed
    it inside a file named `VMPASSWORD`; this means that when we define the `ansible_password`
    key, we can use a lookup value, using `{{ lookup('ansible.builtin.file', 'VMPASSWORD')
    }}`, to read the contents of the `VMPASSWORD` file and use that rather than us
    having to hardcode the password into our environment file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tell Ansible to ignore any certificate errors by setting the `ansible_winrm_server_cert_validation`
    key to `false`; we need to do this because WinRM has been configured to use a
    self-signed certificate, which will cause a certificate error as our local machine
    does not know to trust the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Windows up and running and Ansible configured, we can start
    interacting with it.
  prefs: []
  type: TYPE_NORMAL
- en: The ping module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all Ansible modules work with Windows hosts, and `ansible.builtin.ping`
    is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You would then get quite a verbose error with the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, there is a module provided for Windows called `ansible.windows.win_ping`,
    so let’s update our command to run that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the result you would expect to receive if you sent a ping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The next module we will look at doesn’t require any changes from how we ran
    it against a Linux host.
  prefs: []
  type: TYPE_NORMAL
- en: The setup module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As before, we need to run the module and target our host, so the command is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return information on the host as it did when executing the same
    module against our Linux host, a snippet of which can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Some of the output from the setup module](img/B21620_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Some of the output from the setup module
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the only modules that will work on Windows and Linux hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have confirmed that our host is accessible, let’s look at the changes
    we need to make to the playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Playbook roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire playbook can be found in the `Chapter 07` folder in the repository
    that accompanies the title, so I will not cover how to create roles in this chapter
    as we have covered it at length in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Windows features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two roles cover how to enable features; the first role, called `iis`, enables
    the **Internet Information Services** (**IIS**) on our Windows Server.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'IIS is the default web server that ships with Windows Server, and it supports
    the following protocols: HTTP, HTTPS, and HTTP/2, as well as FTP, FTPS, SMTP,
    and NNTP. It was first released in 1995 as part of Windows NT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some default variables in `roles/iis/defaults/main.yml`; these define
    where things need to be copied to on the server and also include the contents
    on an HTML file we will copy to the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are then two tasks in `roles/iis/tasks/main.yml`. The first task is *where
    the* *magic happens*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I say *where the magic happens* because I don’t get to touch Windows hosts very
    often as a Linux system administrator by trade.
  prefs: []
  type: TYPE_NORMAL
- en: Still, as you can see from the preceding task, Ansible is giving us a Linux-like
    experience, meaning that I don’t have to roll up my sleeves and get under the
    hood of Windows too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task uses the `ansible.windows.win_feature` module to enable the `Web-Server`
    and `Web-Common-Http` features; as we are sticking with the default out-of-the-box
    settings, there isn’t any more configuration we need to do other than to copy
    an HTML file across to the document root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using a Jinja2 template file, an abridged version of
    which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: But rather than `ansible.builtin.template`, we are using `ansible.windows.win_template`,
    which is the Windows module version, as I am sure you will have already guessed.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we were to use the `ansible.builtin.template` version; we would get
    the same error as when we ran the `ansible.builtin.ping` module, and complaints
    about Python not being installed.
  prefs: []
  type: TYPE_NORMAL
- en: The next role expands on the `iis` file and enables `.Net`; the role is called
    `dotnet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, there are some default variables in `roles/dotnet/defaults/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this time, the body contains some inline code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you may have yet to spot a subtle difference in how we define the
    paths in the variables. For both tasks for our Windows workload, the path variables
    have been defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if we look at how we defined the path in [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress*, there is quite a crucial difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The difference is not that we have used `wordpress_system.home` as the variable;
    it is more subtle than that.
  prefs: []
  type: TYPE_NORMAL
- en: If you have noticed that the Windows workload paths are using single quotes
    and the Linux one is using double quotes, give yourself a pat on the back.
  prefs: []
  type: TYPE_NORMAL
- en: In Ansible, single quotes (`'`) that enclose strings are treated as literals,
    ensuring special characters aren’t interpreted or expanded, making them ideal
    for Windows paths.
  prefs: []
  type: TYPE_NORMAL
- en: Double quotes (`"`) allow for string interpolation, meaning embedded Jinja2
    template expressions or special characters will be expanded. They also support
    escape sequences, such as `\n` for new lines, because many escape sequences such
    as `\`, which is in our path, could cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we needed to use double quotes because we needed to pass in something that
    needed to be expanded, then you could have a double slash (`\\`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, it can confuse reading the paths, so I used single quotes in our examples
    – back to the role now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of four tasks in `roles/dotnet/tasks/main.yml` enables `.Net`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also triggering a restart of IIS via a handler if any changes are detected;
    this uses `ansible.windows.win_service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next task creates a folder if one doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, a Windows version of an existing module we have used is called, this
    time `ansible.windows.win_file`. Next, we copy the file to the folder we just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The final task in the role configures IIS to consider we are now running an
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are a few more roles to cover before we run the playbook; let’s look at
    the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This role creates a user for us to connect to our instance with. The defaults
    that can be found in `roles/user/defaults/main.yml` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here, we are defining a user called `ansible` that has a 30-character
    random `password`, which Ansible will create using a lookup plugin if one doesn’t
    exist. The `ansible` user will be a member of the `Users` and `Administrators`
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a single task in `roles/user/tasks/main.yml` using the `ansible.windows.win_user`
    module, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Like all Windows modules, the syntax is similar to the Linux equivalent, so
    you should know what each key means. As you can see from the previous task, we
    are using a Jinja2 transformation to capitalize the first letter of the `ansible.username`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing applications using Chocolatey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next role, called `choco`, uses **Chocolatey** to install a few bits of
    software on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Chocolatey is Windows’ answer to macOS’s Homebrew – a package manager streamlining
    software installations. Like we used Homebrew earlier, Chocolatey wraps typical
    Windows installations into neat PowerShell commands, making it a perfect match
    for orchestration tools such as Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `roles/choco/defaults/main.yml`, we have a single variable that contains
    a list of the packages we want to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have already guessed, this is the task that installs the applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Again, the module takes a similar input to the previous package manager modules,
    `ansible.builtin.apt` and `ansible.builtin.dnf`, that we used. This means that
    the logic Ansible uses across the modules that do similar tasks is consistent
    across multiple operating systems and not just different Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Information role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final role is called info; its only purpose is to output once the playbook
    has finished running. The role has a single task defined in `roles/info/tasks/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this will provide us with the hostname to create a Remote Desktop
    session, along with confirming the username and password we should use.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at the roles that will be called when we run the playbook,
    which we are now ready to do.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `site.yml` is missing some of the settings at the top because we are targeting
    a Windows host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no need for the `become` or `become_method` keys to
    be set, as we do not need to change users once connected to the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside of that, the rest of the file is as expected, as is the way we run
    the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a little while to run as a lot is going on in the background,
    as you will see from the output when the playbook runs for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Reviewing the playbook output](img/B21620_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Reviewing the playbook output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding output, the host I was given was `20.50.120.120.nip.io`
    (this host has long since been terminated, but if you are following along, you
    can replace the preceding host with your own).
  prefs: []
  type: TYPE_NORMAL
- en: To view the static HTML and `.Net` pages we uploaded, you can visit [http://20.50.120.120.nip.io/ansible.html](http://20.50.120.120.nip.io/ansible.html)
    or [http://20.50.120.120.nip.io/ansible/default.aspx](http://20.50.120.120.nip.io/ansible/default.aspx),
    making sure to update the host to reflect your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also open a remote desktop session to the host using the credentials
    given in the output; the following screenshot shows a session using the user we
    created and opening the side using **Google Chrome** with notes in **Notepad++**,
    both of which are applications we installed with the Playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A remote desktop session](img/B21620_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A remote desktop session
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished with the host, you can run the following Azure CLI command
    to terminate all the resources we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Double-check that everything has been removed as expected to ensure you do not
    get any unexpected bills.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the start of the chapter, using what we would consider a traditional
    Linux tool such as Ansible on Windows always feels a little strange. However,
    I am sure you will agree that the experience is as Linux-like as possible.
  prefs: []
  type: TYPE_NORMAL
- en: When I first started experimenting with the Windows modules, I was surprised
    that I managed to launch a Windows Server in Azure and deploy a simple web application
    without having to remote desktop into the target instance.
  prefs: []
  type: TYPE_NORMAL
- en: With each new release, Ansible gets more and more support for Windows-based
    hosts, making it easy to manage mixed workloads from your playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the networking modules available in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more information on the excellent Chocolatey at [https://chocolatey.org/](https://chocolatey.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Network and Cloud Automation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible’s power extends beyond just managing servers; it can also automate network
    devices and cloud infrastructure. Here, we will explore Ansible’s network modules
    and discuss how to interact with network devices programmatically. We will then
    shift our attention to the cloud, where you will discover how to provision and
    manage resources on popular cloud platforms such as Microsoft Azure and Amazon
    Web Services. By the end of this part, you will have the skills needed to automate
    complex cloud deployments using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21620_08.xhtml#_idTextAnchor386), *Ansible Network Modules*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21620_09.xhtml#_idTextAnchor411), *Moving to the Cloud*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21620_10.xhtml#_idTextAnchor458), *Building Out a Cloud Network*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21620_11.xhtml#_idTextAnchor501), *Highly Available Cloud Deployments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21620_12.xhtml#_idTextAnchor550), *Building Out a VMware Deployment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
