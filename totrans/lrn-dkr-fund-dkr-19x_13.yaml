- en: Single-Host Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单主机网络
- en: In the previous chapter, we learned about the most important architectural patterns
    and best practices that are used when dealing with a distributed application architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了分布式应用架构中最重要的架构模式和最佳实践。
- en: In this chapter, we will introduce the Docker container networking model and
    its single-host implementation in the form of the bridge network. This chapter
    also introduces the concept of software-defined networks and how they are used
    to secure containerized applications. Furthermore, we will demonstrate how container
    ports can be opened to the public and thus make containerized components accessible
    to the outside world. Finally, we will introduce Traefik, a reverse proxy, which
    can be used to enable sophisticated HTTP application-level routing between containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Docker 容器网络模型及其在单主机上的实现，具体表现为桥接网络。本章还介绍了软件定义网络的概念，以及它们如何用于保护容器化应用程序。此外，我们还将演示如何将容器端口开放给外部，从而使容器化组件可以访问外部世界。最后，我们将介绍
    Traefik，这是一个反向代理，可以用于在容器之间启用复杂的 HTTP 应用程序级路由。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Dissecting the container network model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解剖容器网络模型
- en: Network firewalling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络防火墙
- en: Working with the bridge network
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用桥接网络
- en: The host and null network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机和空网络
- en: Running in an existing network namespace
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有网络命名空间中运行
- en: Managing container ports
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器端口
- en: HTTP-level routing using a reverse proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向代理进行 HTTP 层路由
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够完成以下任务：
- en: Create, inspect, and delete a custom bridge network
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、检查和删除自定义桥接网络
- en: Run a container attached to a custom bridge network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行附加到自定义桥接网络的容器
- en: Isolate containers from each other by running them on different bridge networks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将容器运行在不同的桥接网络上来隔离容器
- en: Publish a container port to a host port of your choice
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器端口发布到您选择的主机端口
- en: Add Traefik as a reverse proxy to enable application-level routing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Traefik 作为反向代理以启用应用程序级路由
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, the only thing you will need is a Docker host that is able
    to run Linux containers. You can use your laptop with either Docker for macOS
    or Windows or have Docker Toolbox installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您唯一需要的就是能够运行 Linux 容器的 Docker 主机。您可以使用安装了 Docker for macOS 或 Windows 的笔记本电脑，或者安装了
    Docker Toolbox。
- en: Dissecting the container network model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖容器网络模型
- en: 'So far, we have been mostly working with single containers. But in reality,
    a containerized business application consists of several containers that need
    to collaborate to achieve a goal. Therefore, we need a way for individual containers
    to communicate with each other. This is achieved by establishing pathways that
    we can use to send data packets back and forth between containers. These pathways are
    called **networks**. Docker has defined a very simple networking model, the so-called **container
    network model** (**CNM**), to specify the requirements that any software that
    implements a container network has to fulfill. The following is a graphical representation
    of the CNM:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要处理的是单个容器。但实际上，一个容器化的业务应用程序由多个容器组成，它们需要协作才能实现目标。因此，我们需要一种方法让单个容器能够相互通信。这是通过建立路径来实现的，这些路径允许我们在容器之间来回发送数据包。这些路径被称为**网络**。Docker
    定义了一个非常简单的网络模型，即所谓的**容器网络模型**（**CNM**），用于指定任何实现容器网络的软件必须满足的要求。以下是 CNM 的图示：
- en: '![](img/01bba337-0560-4f72-a31e-7e51d7cb98ac.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01bba337-0560-4f72-a31e-7e51d7cb98ac.png)'
- en: The Docker CNM
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CNM
- en: 'The CNM has three elements – sandbox, endpoint, and network:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CNM 包含三个元素——沙箱、端点和网络：
- en: '**Sandbox:** The sandbox perfectly isolates a container from the outside world.
    No inbound network connection is allowed into the sandboxed container. But, it
    is very unlikely that a container will be of any value in a system if absolutely
    no communication with it is possible. To work around this, we have element number
    two, which is the endpoint.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙箱：** 沙箱完美地将容器与外部世界隔离。禁止任何入站网络连接进入沙箱容器。但如果容器与外界完全无法通信，它在系统中的价值是非常有限的。为了解决这个问题，我们引入了第二个元素——端点。'
- en: '**Endpoint:** An endpoint is a controlled gateway from the outside world into
    the network''s sandbox that shields the container. The endpoint connects the network
    sandbox (but not the container) to the third element of the model, which is the
    network.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点：** 端点是一个受控的网关，用于将外部世界连接到网络沙箱，从而保护容器。端点将网络沙箱（而非容器）与模型的第三个元素——网络连接起来。'
- en: '**Network:** The network is the pathway that transports the data packets of
    an instance of communication from endpoint to endpoint or, ultimately, from container
    to container.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络：** 网络是数据包传输的路径，负责将通信实例的数据包从端点传输到端点，最终从一个容器传输到另一个容器。'
- en: It is important to note that a network sandbox can have zero to many endpoints,
    or, said differently, each container living in a network sandbox can either be attached
    to no network at all or it can be attached to multiple different networks at the
    same time. In the preceding diagram, the middle of the three **Network Sandboxes**
    is attached to both **Network** **1** and **Network** **2** through an **endpoint**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，网络沙箱可以有零到多个端点，或者换句话说，生活在网络沙箱中的每个容器可以**既**不连接任何网络，也可以同时连接多个不同的网络。在前面的图示中，三个
    **网络沙箱** 中的中间一个通过 **端点** 同时连接了 **网络 1** 和 **网络 2**。
- en: This networking model is very generic and does not specify where the individual
    containers that communicate with each other over a network run. All containers
    could, for example, run on one and the same host (local) or they could be distributed
    across a cluster of hosts (global).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络模型非常通用，并没有指定相互通信的容器到底在哪个位置运行。所有容器可以，例如，运行在同一个主机上（本地），或者分布在多个主机的集群中（全球）。
- en: 'Of course, the CNM is just a model describing how networking works among containers.
    To be able to use networking with our containers, we need real implementations
    of the CNM. For both local and global scope, we have multiple implementations
    of the CNM. In the following table, we''ve given a short overview of the existing
    implementations and their main characteristics. The list is in no particular order:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CNM 只是描述容器间网络如何工作的模型。为了能够在我们的容器中使用网络，我们需要 CNM 的实际实现。对于本地和全球范围，我们有多个 CNM 的实现。下表中，我们简要概述了现有的实现及其主要特点。该列表没有特定顺序：
- en: '| **Network** | **Company** | **Scope** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **网络** | **公司** | **范围** | **描述** |'
- en: '| Bridge | Docker | Local | Simple network based on Linux bridges to allow
    networking on a single host |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 桥接 | Docker | 本地 | 基于 Linux 桥接的简单网络，允许在单一主机上进行网络通信 |'
- en: '| Macvlan | Docker | Local | Configures multiple layer 2 (that is, MAC) addresses
    on a single physical host interface |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Macvlan | Docker | 本地 | 在单个物理主机接口上配置多个第二层（即 MAC）地址 |'
- en: '| Overlay | Docker | Global | Multinode-capable container network based on **Virtual
    Extensible LAN** (**VXLan**) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Overlay | Docker | 全球 | 基于 **虚拟扩展局域网** (**VXLan**) 的多节点容器网络 |'
- en: '| Weave Net | Weaveworks | Global | Simple, resilient, multi-host Docker networking
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Weave Net | Weaveworks | 全球 | 简单、弹性、多主机 Docker 网络 |'
- en: '| Contiv Network Plugin | Cisco | Global | Open source container networking
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Contiv Network Plugin | Cisco | 全球 | 开源容器网络 |'
- en: All network types not directly provided by Docker can be added to a Docker host
    as a plugin.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不是由 Docker 直接提供的网络类型都可以作为插件添加到 Docker 主机中。
- en: Network firewalling
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络防火墙
- en: Docker has always had the mantra of security first. This philosophy had a direct
    influence on how networking in a single and multi-host Docker environment was
    designed and implemented. Software-defined networks are easy and cheap to create,
    yet they perfectly firewall containers that are attached to this network from
    other non-attached containers, and from the outside world. All containers that
    belong to the same network can freely communicate with each other, while others
    have no means to do so.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 一直秉持“安全第一”的理念。这一哲学直接影响了单主机和多主机 Docker 环境中网络的设计和实现。软件定义的网络既易于创建，又成本低廉，但它们完美地为附加到该网络上的容器与其他非附加容器以及外部世界之间设置了防火墙。所有属于同一网络的容器可以自由通信，而其他容器则无法做到这一点。
- en: 'In the following diagram, we have two networks called **front** and **back**.
    Attached to the front network, we have containers **c1** and **c2**, and attached
    to the back network, we have containers **c3** and **c4**. **c1** and **c2** can
    freely communicate with each other, as can **c3** and **c4**. But **c1** and **c2** have
    no way to communicate with either **c3** or **c4**, and vice versa:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们有两个网络，分别叫做 **front** 和 **back**。**c1** 和 **c2** 容器附加到前端网络，**c3** 和 **c4**
    容器附加到后端网络。**c1** 和 **c2** 可以自由地互相通信，**c3** 和 **c4** 也是如此。但 **c1** 和 **c2** 不能与
    **c3** 或 **c4** 通信，反之亦然：
- en: '![](img/dc455aaa-c719-42f7-bbe6-9183e1cc50e0.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc455aaa-c719-42f7-bbe6-9183e1cc50e0.png)'
- en: Docker networks
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 网络
- en: 'Now, what about the situation where we have an application consisting of three
    services: **webAPI**, **productCatalog**, and **database**? We want **webAPI **to
    be able to communicate with **productCatalog**, but not with the **database**, and
    we want **productCatalog **to be able to communicate with the **database **service.
    We can solve this situation by placing **webAPI** and the database on different
    networks and attaching **productCatalog** to both of these networks, as shown
    in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个由三个服务组成的应用程序：**webAPI**、**productCatalog** 和 **database**。我们希望 **webAPI**
    能够与 **productCatalog** 通信，但不能与 **database** 通信，并且我们希望 **productCatalog** 能够与 **database**
    服务进行通信。我们可以通过将 **webAPI** 和数据库放置在不同的网络上，并将 **productCatalog** 附加到这两个网络上来解决这个问题，如下图所示：
- en: '![](img/86503975-ece8-4312-b380-9454f4494e0d.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86503975-ece8-4312-b380-9454f4494e0d.png)'
- en: Container attached to multiple networks
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 容器附加到多个网络
- en: Since creating SDNs is cheap, and each network provides added security by isolating
    resources from unauthorized access, it is highly recommended that you design and
    run applications so that they use multiple networks and only run services on the
    same network that absolutely need to communicate with each other. In the preceding
    example, there is absolutely no need for the **webAPI** component to ever communicate
    directly with the **database** service, so we have put them on different networks.
    If the worst-case scenario happens and a hacker compromises the **webAPI**, they
    cannot access the **database** from there without also hacking the **productCatalog**
    service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建 SDN 网络的成本较低，并且每个网络通过将资源与未经授权的访问隔离来提供额外的安全性，因此强烈建议您设计和运行应用程序，使其使用多个网络，并且仅在需要互相通信的服务才运行在同一网络上。在前面的示例中，**webAPI**
    组件根本不需要直接与 **database** 服务通信，因此我们将它们放在不同的网络上。如果最坏的情况发生，黑客入侵了 **webAPI**，他们也无法直接从那里访问
    **database**，除非他们也侵入了 **productCatalog** 服务。
- en: Working with the bridge network
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用桥接网络
- en: The Docker bridge network is the first implementation of the container network
    model that we're going to look at in detail. This network implementation is based
    on the Linux bridge. When the Docker daemon runs for the first time, it creates
    a Linux bridge and calls it `docker0`. This is the default behavior and can be
    changed by changing the configuration. Docker then creates a network with this
    Linux bridge and calls the network `bridge`. All the containers that we create
    on a Docker host and that we do not explicitly bind to another network leads to
    Docker automatically attaching to this bridge network.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 桥接网络是我们将要详细了解的容器网络模型的**第一种**实现。该网络实现基于 Linux 桥接。当 Docker 守护进程首次运行时，它会创建一个
    Linux 桥接并将其命名为 `docker0`。这是默认行为，可以通过更改配置进行更改。Docker 然后创建一个使用这个 Linux 桥接的网络，并将网络命名为
    `bridge`。所有在 Docker 主机上创建的容器，如果我们没有显式绑定到另一个网络，将自动附加到这个桥接网络。
- en: 'To verify that we indeed have a network called `bridge` of the `bridge` type defined
    on our host, we can list all the networks on the host with the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们确实在主机上定义了一个名为 `bridge` 的 `bridge` 类型的网络，我们可以使用以下命令列出主机上的所有网络：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should provide an output similar to the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出类似以下内容的结果：
- en: '![](img/593ac4e8-8745-4f2b-8e50-ed4c631a97ad.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/593ac4e8-8745-4f2b-8e50-ed4c631a97ad.png)'
- en: Listing all the Docker networks available by default
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列出默认可用的所有 Docker 网络
- en: In your case, the IDs will be different, but the rest of the output should look
    the same. We do indeed have a first network called `bridge` using the `bridge` driver.
    The scope being `local` just means that this type of network is restricted to
    a single host and cannot span multiple hosts. In [Chapter 13](a6f04592-db31-452a-aad1-ca56d9999767.xhtml),
    *Introduction to Docker Swarm*, we will also discuss other types of networks that
    have a global scope, meaning they can span whole clusters of hosts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，ID会不同，但输出的其余部分应该是相同的。我们确实有一个名为`bridge`的网络，使用`bridge`驱动程序。`local`范围意味着这种类型的网络仅限于单一主机，无法跨多个主机。在[第13章](a6f04592-db31-452a-aad1-ca56d9999767.xhtml)《Docker
    Swarm简介》中，我们还将讨论具有全局范围的其他网络类型，这些网络可以跨整个主机集群。
- en: 'Now, let''s look a little bit deeper into what this bridge network is all about.
    For this, we are going to use the Docker `inspect` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解一下这个`bridge`网络的详细情况。为此，我们将使用Docker的`inspect`命令：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When executed, this outputs a big chunk of detailed information about the network
    in question. This information should look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，这将输出关于相关网络的大量详细信息。该信息应该如下所示：
- en: '![](img/443fa38e-8fb7-4a8b-a781-08bd8b40bdc4.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/443fa38e-8fb7-4a8b-a781-08bd8b40bdc4.png)'
- en: Output generated when inspecting the Docker bridge network
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`inspect`命令后生成的输出
- en: 'We saw the `ID`, `Name`, `Driver`, and `Scope` values when we listed all the
    networks, so that is nothing new. But let''s have a look at the **IP address management** (**IPAM**)
    block. IPAM is a piece of software that is used to track IP addresses that are
    used on a computer. The important part of the `IPAM` block is the `Config` node
    with its values for `Subnet` and `Gateway`. The subnet for the bridge network
    is defined by default as `172.17.0.0/16`. This means that all containers attached
    to this network will get an IP address assigned by Docker that is taken from the
    given range, which  is `172.17.0.2` to `172.17.255.255`. The `172.17.0.1` address is
    reserved for the router of this network whose role in this type of network is
    taken by the Linux bridge. We can expect that the very first container that will
    be attached to this network by Docker will get the `172.17.0.2 `address. All subsequent
    containers will get a higher number; the following diagram illustrates this fact:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列出所有网络时看到了`ID`、`Name`、`Driver`和`Scope`值，这些内容并不新鲜。但让我们来看看**IP地址管理**（**IPAM**）模块。IPAM是一种用于追踪计算机上使用的IP地址的软件。`IPAM`模块的重要部分是`Config`节点，其包含`Subnet`和`Gateway`的值。桥接网络的子网默认定义为`172.17.0.0/16`。这意味着，所有连接到此网络的容器都会从给定的地址范围内由Docker分配一个IP地址，范围为`172.17.0.2`到`172.17.255.255`。`172.17.0.1`地址被保留给该网络的路由器，在这种类型的网络中，Linux桥接器承担了路由器的角色。我们可以预期，第一个由Docker连接到此网络的容器将获得`172.17.0.2`地址。所有后续容器将分配更高的地址；以下图示说明了这一点：
- en: '![](img/305f89fe-d167-4b3b-bb00-8f6bd3b8e800.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/305f89fe-d167-4b3b-bb00-8f6bd3b8e800.png)'
- en: The bridge network
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络
- en: In the preceding diagram, we can see the network namespace of the host, which
    includes the host's **eth0** endpoint, which is typically a NIC if the Docker
    host runs on bare metal or a virtual NIC if the Docker host is a VM. All traffic
    to the host comes through **eth0**. The **Linux** **bridge** is responsible for
    routing the network traffic between the host's network and the subnet of the bridge
    network.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图中，我们可以看到主机的网络命名空间，其中包括主机的**eth0**端点，如果Docker主机运行在裸机上，它通常是一个网络接口卡（NIC），如果Docker主机是虚拟机，则是一个虚拟NIC。所有到主机的流量都通过**eth0**。**Linux**桥接器负责在主机网络和桥接网络的子网之间路由网络流量。
- en: 'By default, only egress traffic is allowed, and all ingress is blocked. What
    this means is that while containerized applications can reach the internet, they
    cannot be reached by any outside traffic. Each container attached to the network
    gets its own **virtual ethernet** (**veth**) connection with the bridge. This
    is illustrated in the following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只允许出口流量，所有入口流量都被阻止。这意味着，虽然容器化应用可以访问互联网，但它们无法被外部流量访问。每个连接到网络的容器都会与桥接器建立自己的**虚拟以太网**（**veth**）连接。下图展示了这一过程：
- en: '![](img/c4b34b80-5e37-4257-8a0e-c79110390eda.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4b34b80-5e37-4257-8a0e-c79110390eda.png)'
- en: Details of the bridge network
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络的详细信息
- en: The preceding diagram shows us the world from the perspective of the **Host**.
    We will explore what this situation looks like from within a container later on
    in this section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了从**主机**的角度看这个世界。我们将在本节后面讨论从容器内部看这个情况。
- en: 'We are not limited to just the bridge network, as Docker allows us to define
    our own custom bridge networks. This is not just a feature that is nice to have, but
    it is a recommended best practice to not run all containers on the same network.
    Instead, we should use additional bridge networks to further isolate containers
    that have no need to communicate with each other. To create a custom bridge network
    called `sample-net`, use the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅局限于`bridge`网络，因为Docker允许我们定义自己的自定义桥接网络。这不仅仅是一个“很好”用的功能，而是一个推荐的最佳实践——不要让所有容器都运行在同一个网络上。相反，我们应该使用额外的桥接网络来进一步隔离那些不需要相互通信的容器。要创建一个名为`sample-net`的自定义桥接网络，可以使用以下命令：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we do this, we can then inspect what subnet Docker has created for this
    new custom network, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，就可以检查Docker为这个新的自定义网络创建了什么子网，如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This returns the following value:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下值：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Evidently, Docker has just assigned the next free block of IP addresses to
    our new custom bridge network. If, for some reason, we want to specify our own
    subnet range when creating a network, we can do so by using the `--subnet` parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Docker刚刚将下一个可用的IP地址块分配给了我们新的自定义桥接网络。如果因为某些原因，我们希望在创建网络时指定自己的子网范围，可以通过使用`--subnet`参数来实现：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To avoid conflicts due to duplicate IP addresses, make sure you avoid creating
    networks with overlapping subnets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免因重复IP地址而产生冲突，请确保避免创建具有重叠子网的网络。
- en: 'Now that we have discussed what a bridge network is and how we can create a
    custom bridge network, we want to understand how we can attach containers to these networks.
    First, let''s interactively run an Alpine container without specifying the network
    to be attached:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了桥接网络是什么以及如何创建自定义桥接网络，我们希望了解如何将容器附加到这些网络。首先，让我们交互式地运行一个Alpine容器，而不指定要附加的网络：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In another Terminal window, let''s inspect the `c1` container:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，我们来检查一下`c1`容器：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the vast output, let''s concentrate for a moment on the part that provides
    network-related information. This can be found under the `NetworkSettings` node.
    I have it listed in the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在庞大的输出中，我们暂时集中注意力在提供网络相关信息的部分。这可以在`NetworkSettings`节点下找到。我已在以下输出中列出：
- en: '![](img/aa6b5fcb-a394-4fa6-85bf-fbdced83fdbe.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa6b5fcb-a394-4fa6-85bf-fbdced83fdbe.png)'
- en: The NetworkSettings section of the container metadata
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 容器元数据的NetworkSettings部分
- en: In the preceding output, we can see that the container is indeed attached to
    the `bridge` network since `NetworkID` is equal to `026e65...`, which we can see
    from the preceding code is the ID of the `bridge` network. We can also see that
    the container got the IP address of `172.17.0.4` assigned as expected and that
    the gateway is at `172.17.0.1`. Please note that the container also had a `MacAddress` associated
    with it. This is important as the Linux bridge uses the `MacAddress` for routing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到容器确实附加到了`bridge`网络，因为`NetworkID`等于`026e65...`，从前面的代码中可以看到，这是`bridge`网络的ID。我们还可以看到，容器如预期地获得了`172.17.0.4`的IP地址，并且网关位于`172.17.0.1`。请注意，容器还关联了一个`MacAddress`。这很重要，因为Linux桥接使用`MacAddress`进行路由。
- en: 'So far, we have approached this from the outside of the container''s network
    namespace. Now, let''s see what the situation looks like when we''re not only
    inside the container but inside the containers'' network namespace. Inside the `c1` container, let''s
    use the `ip` tool to inspect what''s going on. Run the `ip addr` command and observe
    the output that is generated, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们是从容器的网络命名空间外部来处理这个问题的。现在，让我们看看当我们不仅在容器内部，而且在容器的网络命名空间内部时，情况如何。在`c1`容器内，我们使用`ip`工具检查发生了什么。运行`ip
    addr`命令并观察生成的输出，如下所示：
- en: '![](img/27033243-df1d-4f06-bc3f-e75f79595799.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27033243-df1d-4f06-bc3f-e75f79595799.png)'
- en: Container namespace, as seen by the IP tool
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 容器命名空间，正如通过IP工具所看到的那样
- en: The interesting part of the preceding output is number `19`, that is, the `eth0` endpoint.
    The `veth0` endpoint that the Linux bridge created outside of the container namespace
    is mapped to `eth0` inside the container. Docker always maps the first endpoint
    of a container network namespace to `eth0`, as seen from inside the namespace.
    If the network namespace is attached to an additional network, then that endpoint
    will be mapped to `eth1`, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出中有一个有趣的部分是数字`19`，即`eth0`端点。Linux桥接在容器命名空间外创建的`veth0`端点映射到容器内的`eth0`。Docker始终将容器网络命名空间的第一个端点映射为`eth0`，从命名空间内部可以看到这一点。如果网络命名空间附加到其他网络，则该端点将映射到`eth1`，以此类推。
- en: 'Since at this point we''re not really interested in any endpoint other than `eth0`,
    we could have used a more specific variant of the command, which would have given
    us the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时我们并不关心除`eth0`以外的任何端点，我们本可以使用命令的更具体变体，这将为我们提供以下输出：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the output, we can also see what MAC address (`02:42:ac:11:00:02`) and what
    IP (`172.17.0.2`) have been associated with this container network namespace by
    Docker.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们还可以看到Docker为该容器网络命名空间分配了什么MAC地址（`02:42:ac:11:00:02`）和IP地址（`172.17.0.2`）。
- en: 'We can also get some information about how requests are routed by using the `ip
    route` command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`ip route`命令获取一些关于请求路由的信息：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This output tells us that all the traffic to the gateway at `172.17.0.1` is
    routed through the `eth0` device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出告诉我们，所有到网关`172.17.0.1`的流量都通过`eth0`设备路由。
- en: 'Now, let''s run another container called `c2` on the same network:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一网络上运行另一个名为`c2`的容器：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `c2` container will also be attached to the `bridge` network since we have
    not specified any other network. Its IP address will be the next free one from
    the subnet, which is `172.17.0.3`, as we can readily test:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`c2`容器也将连接到`bridge`网络，因为我们没有指定其他网络。它的IP地址将是子网中下一个空闲的IP，即`172.17.0.3`，我们可以通过以下测试来验证：'
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we have two containers attached to the `bridge` network. We can try to
    inspect this network once again to find a list of all containers attached to it
    in the output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个容器连接到`bridge`网络。我们可以再次尝试检查此网络，以便在输出中找到连接到该网络的所有容器列表：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This information can be found under the `Containers` node:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息可以在`Containers`节点下找到：
- en: '![](img/86ee4f8a-562b-48c9-a5f5-f592fd090036.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86ee4f8a-562b-48c9-a5f5-f592fd090036.png)'
- en: The Containers section of the output of the Docker network inspect bridge
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网络检查bridge命令的容器部分输出
- en: Once again, we have shortened the output to the relevant part for readability.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次为了可读性，我们已经缩短了输出，仅保留相关部分。
- en: 'Now, let''s create two additional containers, `c3` and `c4`, and attach them
    to `test-net`. For this, we''ll use the `--network` parameter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建两个附加到`test-net`的额外容器，`c3`和`c4`。为此，我们将使用`--network`参数：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s inspect `network test-net` and confirm that containers `c3` and `c4` are
    indeed attached to it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`network test-net`并确认容器`c3`和`c4`确实连接到了它：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will give us the following output for the `Containers` section:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供以下`Containers`部分的输出：
- en: '![](img/3ae3275a-6e10-49e8-8c51-59287cb8c746.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ae3275a-6e10-49e8-8c51-59287cb8c746.png)'
- en: Containers section of the docker network inspect test-net command
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网络检查命令test-net中的容器部分
- en: 'The next question we''re going to ask ourselves is whether the `c3` and `c4` containers can
    freely communicate with each other. To demonstrate that this is indeed the case,
    we can `exec` into the `c3` container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要问自己的是，`c3`和`c4`容器是否可以自由通信。为了证明这一点，我们可以通过`exec`进入`c3`容器：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once inside the container, we can try to ping container `c4` by name and by
    IP address:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，我们可以尝试通过名称和IP地址ping容器`c4`：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the result of the ping using the IP address of `c4`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`c4`的IP地址进行ping的结果：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The answer in both cases confirms to us that the communication between containers
    attached to the same network is working as expected. The fact that we can even use the
    name of the container we want to connect to shows us that the name resolution
    provided by the Docker DNS service works inside this network.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，答案都向我们确认，连接到同一网络的容器之间的通信正在按预期工作。我们甚至能够使用容器名称进行连接，表明Docker DNS服务在此网络内提供的名称解析功能正常工作。
- en: 'Now, we want to make sure that the `bridge` and the `test-net` networks are
    firewalled from each other. To demonstrate this, we can try to ping the `c2` container from
    the `c3` container, either by its name or by its IP address:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望确保`bridge`和`test-net`网络彼此隔离。为了演示这一点，我们可以尝试从`c3`容器ping`c2`容器，可以通过容器的名称或IP地址：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the result of the ping using the IP address of the `c2` container instead:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`c2`容器的IP地址进行ping操作的结果：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command remained hanging and I had to terminate the command with *Ctrl*+*C*.
    From the output of pinging `c2`, we can also see that the name resolution does
    not work across networks. This is the expected behavior. Networks provide an extra
    layer of isolation, and thus security, to containers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令一直挂起，我不得不通过*Ctrl*+*C*终止命令。从ping`c2`的输出中，我们还可以看到名称解析在网络之间无法工作。这是预期的行为。网络为容器提供了额外的隔离层，因此也增强了安全性。
- en: 'Earlier, we learned that a container can be attached to multiple networks.
    Let''s attach the `c5` container to the `sample-net` and `test-net` networks at
    the same time:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们了解到一个容器可以连接到多个网络。现在，我们将同时把`c5`容器连接到`sample-net`和`test-net`网络：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can test that `c5` is reachable from the `c2` container, similar to
    when we tested the same for the `c4` and `c2` containers. The result will show
    that the connection indeed works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试`c5`是否可以从`c2`容器访问，类似于我们之前测试`c4`和`c2`容器时的情况。结果将显示连接确实有效。
- en: 'If we want to remove an existing network, we can use the `docker network rm` command,
    but note that we cannot accidentally delete a network that has containers attached
    to it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除一个现有的网络，可以使用`docker network rm`命令，但请注意，我们不能不小心删除已连接容器的网络：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we continue, let''s clean up and remove all the containers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们清理并移除所有容器：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can remove the two custom networks that we created:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除我们创建的两个自定义网络：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, we could remove all the networks that no container is attached
    to with the `prune` command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`prune`命令删除所有没有容器连接的网络：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I used the `--force` (or `-f`) argument here to prevent Docker from reconfirming
    that I really want to remove all unused networks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了`--force`（或`-f`）参数，以防止Docker重新确认我是否真的要删除所有未使用的网络。
- en: The host and null network
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机和空网络
- en: In this section, we are going to look at two predefined and somewhat unique
    types of networks, the `host` and the `null` networks. Let's start with the former.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍两种预定义的、具有一定独特性的网络类型：`host`网络和`null`网络。我们先从前者开始。
- en: The host network
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机网络
- en: There are occasions where we want to run a container in the network namespace
    of the host. This can be necessary when we need to run some software in a container
    that is used to analyze or debug the host networks' traffic. But keep in mind
    that these are very specific scenarios. When running business software in containers,
    there is no good reason to ever run the respective containers attached to the
    host's network. For security reasons, it is strongly recommended that you do not
    run any such container attached to the `host` network on a production or production-like
    environment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在主机的网络命名空间中运行一个容器。这在我们需要在容器中运行一些用于分析或调试主机网络流量的软件时可能是必要的。但请记住，这些是非常特定的场景。在容器中运行业务软件时，永远没有理由将相关容器连接到主机网络。出于安全原因，强烈建议你不要在生产环境或类似生产的环境中运行任何连接到`host`网络的容器。
- en: 'That said, *how can we run a container inside the network namespace of the
    host?* Simply by attaching the container to the `host` network:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，*我们如何在主机的网络命名空间中运行一个容器？* 只需将容器连接到`host`网络即可：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we use the `ip` tool to analyze the network namespace from within the container,
    we will see that we get exactly the same picture as we would if we were running
    the `ip` tool directly on the host. For example, if I inspect the `eth0` device on
    my host, I get this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ip`工具分析容器内部的网络命名空间，我们会看到与直接在主机上运行`ip`工具时完全相同的结果。例如，如果我检查主机上的`eth0`设备，我得到如下信息：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, I can see that `192.168.65.3` is the IP address that the host has been
    assigned and that the MAC address shown here also corresponds to that of the host.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以看到`192.168.65.3`是主机被分配的IP地址，并且显示的MAC地址也与主机的MAC地址相对应。
- en: 'We can also inspect the routes to get the following (shortened):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查路由，得到如下（简化版）：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before I let you go on to the next section of this chapter, I want to once more
    point out that the use of the `host` network is dangerous and needs to be avoided
    if possible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读本章的下一部分之前，我想再次指出，使用`host`网络是危险的，并且如果可能的话需要避免使用。
- en: The null network
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空网络
- en: 'Sometimes, we need to run a few application services or jobs that do not need
    any network connection at all to execute the task at hand. It is strongly advised
    that you run those applications in a container that is attached to the `none` network.
    This container will be completely isolated, and is thus safe from any outside
    access. Let''s run such a container:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要运行一些应用服务或任务，这些任务完全不需要任何网络连接。强烈建议将这些应用运行在一个连接到`none`网络的容器中。这个容器将完全隔离，因此避免了任何外部访问。让我们运行一个这样的容器：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once inside the container, we can verify that there is no `eth0` network endpoint
    available:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，我们可以验证没有`eth0`网络端点可用：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is also no routing information available, as we can demonstrate by using
    the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 也没有可用的路由信息，我们可以通过以下命令来演示：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This returns nothing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会返回任何内容。
- en: Running in an existing network namespace
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行在现有的网络命名空间中
- en: Normally, Docker creates a new network namespace for each container we run.
    The network namespace of the container corresponds to the sandbox of the container
    network model we described earlier on. As we attach the container to a network,
    we define an endpoint that connects the container network namespace with the actual
    network. This way, we have one container per network namespace.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Docker会为我们运行的每个容器创建一个新的网络命名空间。容器的网络命名空间对应于我们之前描述的容器网络模型的沙箱。我们将容器连接到一个网络时，会定义一个端点，将容器的网络命名空间与实际的网络连接起来。这样，每个网络命名空间就对应一个容器。
- en: 'Docker provides an additional way for us to define the network namespace that
    a container runs in. When creating a new container, we can specify that it should
    be attached to (or maybe we should say included) in the network namespace of an
    existing container. With this technique, we can run multiple containers in a single
    network namespace:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还为我们提供了一种额外的方式来定义容器运行的网络命名空间。在创建新容器时，我们可以指定它应该附加到（或者说包括在）一个现有容器的网络命名空间中。通过这种技术，我们可以在一个单独的网络命名空间中运行多个容器：
- en: '![](img/fab345c0-6d16-4d82-ab56-ed17edd9cb1c.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fab345c0-6d16-4d82-ab56-ed17edd9cb1c.png)'
- en: Multiple containers running in a single network namespace
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一网络命名空间中运行多个容器
- en: In the preceding diagram, we can see that in the leftmost **Network** **Namespace**,
    we have two containers. The two containers, since they share the same namespace,
    can communicate on localhost with each other. The network namespace (and not the
    individual containers) is then attached to **Network 1**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图中，我们可以看到，在最左侧的**网络命名空间**中，我们有两个容器。这两个容器因为共享相同的命名空间，所以可以通过localhost互相通信。然后，网络命名空间（而不是单独的容器）被连接到**网络1**。
- en: This is useful when we want to debug the network of an existing container without
    running additional processes inside that container. We can just attach a special
    utility container to the network namespace of the container to inspect. This feature
    is also used by Kubernetes when it creates a pod. We will learn more about Kubernetes
    and pods in [Chapter 15](b8e4dc09-b2ce-4f89-9682-d8f0c6e126f6.xhtml), *Introduction
    to Kubernetes* of this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要调试现有容器的网络时，这非常有用，而不需要在该容器内运行额外的进程。我们只需将一个特殊的工具容器附加到容器的网络命名空间中进行检查。Kubernetes在创建Pod时也使用了这个功能。我们将在本书的[第15章](b8e4dc09-b2ce-4f89-9682-d8f0c6e126f6.xhtml)，*Kubernetes简介*中了解更多关于Kubernetes和Pod的内容。
- en: 'Now, let''s demonstrate how this works:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示一下这个是如何工作的：
- en: 'First, we create a new bridge network:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的桥接网络：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we run a container attached to this network:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行一个连接到该网络的容器：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we run another container and attach it to the network of our `web` container:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行另一个容器，并将其连接到我们`web`容器的网络：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Specifically, note how we define the network: `--network container:web`. This
    tells Docker that our new container shall use the same network namespace as the
    container called `web`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，注意我们如何定义网络：`--network container:web`。这告诉Docker，我们的新容器将使用与名为`web`的容器相同的网络命名空间。
- en: 'Since the new container is in the same network namespace as the web container
    running nginx, we''re now able to access nginx on localhost! We can prove this
    by using the `wget` tool, which is part of the Alpine container, to connect to
    nginx. We should see the following:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于新的容器与运行 nginx 的 Web 容器在同一个网络命名空间中，我们现在可以在本地主机上访问 nginx！我们可以通过使用 `wget` 工具来证明这一点，`wget`
    是 Alpine 容器的一部分，它可以连接到 nginx。我们应该会看到如下内容：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we have shortened the output for readability. Please also note that
    there is an important difference between running two containers attached to the
    same network and two containers running in the same network namespace. In both
    cases, the containers can freely communicate with each other, but in the latter
    case, the communication happens over localhost.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已将输出缩短以提高可读性。还请注意，在将两个容器附加到同一网络和将两个容器运行在同一网络命名空间之间，存在一个重要的区别。在这两种情况下，容器之间可以自由通信，但在后者的情况下，通信是通过本地主机进行的。
- en: 'To clean up the container and network, we can use the following command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理容器和网络，我们可以使用以下命令：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we are going to learn how to expose container ports on
    the container host.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习如何在容器主机上暴露容器端口。
- en: Managing container ports
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器端口
- en: Now that we know how we can isolate firewall containers from each other by placing
    them on different networks, and that we can have a container attached to more
    than one network, we have one problem that remains unsolved. *How can we expose
    an application service to the outside world?* Imagine a container running a web
    server hosting our webAPI from before. We want customers from the internet to
    be able to access this API. We have designed it to be a publicly accessible API.
    To achieve this, we have to, figuratively speaking, open a gate in our firewall
    through which we can funnel external traffic to our API. For security reasons,
    we don't just want to open the doors wide; we want to have a single controlled
    gate that traffic flows through.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，如何通过将防火墙容器放置在不同的网络中，来实现容器之间的隔离；而且我们还可以让一个容器连接到多个网络。但仍然有一个问题没有解决。*我们如何将应用服务暴露到外部世界？*
    想象一下，一个容器运行着一个 Web 服务器，承载着我们之前提到的 WebAPI。我们希望来自互联网的客户能够访问这个 API。我们已经设计了一个对外公开的
    API。为了实现这一点，我们必须，形象地说，在防火墙中打开一个门，通过这个门将外部流量引导到我们的 API。出于安全原因，我们不想将大门完全打开；我们希望有一个单一的控制门，所有流量都通过这个门流入。
- en: 'We can create such a gate by mapping a container port to an available port
    on the host. We''re also calling this opening a gate to the container port to
    publish a port. Remember that the container has its own virtual network stack,
    as does the host. Therefore, container ports and host ports exist completely independently
    and by default have nothing in common at all. But we can now wire a container
    port with a free host port and funnel external traffic through this link, as illustrated
    in the following diagram:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将容器端口映射到主机上的一个可用端口来创建这样一个“门”。我们也将其称为打开一个门，发布一个容器端口。请记住，容器和主机各自有自己的虚拟网络堆栈。因此，容器端口和主机端口是完全独立的，默认情况下它们没有任何关联。但现在我们可以将一个容器端口与一个空闲的主机端口连接，并通过这个链接引导外部流量，正如下面的图示所示：
- en: '![](img/ed84f752-d199-4870-90eb-1ee9216cc749.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed84f752-d199-4870-90eb-1ee9216cc749.png)'
- en: Mapping container ports to host ports
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 映射容器端口到主机端口
- en: 'But now, it is time to demonstrate how we can actually map a container port
    to a host port. This is done when creating a container. We have different ways
    of doing so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，是时候展示我们如何实际将容器端口映射到主机端口了。这是在创建容器时完成的。我们有几种不同的方式来实现：
- en: 'First, we can let Docker decide which host port our container port shall be
    mapped to. Docker will then select one of the free host ports in the range of
    32xxx. This automatic mapping is done by using the `-P` parameter:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以让 Docker 决定将容器端口映射到哪个主机端口。Docker 会从 32xxx 范围内选择一个空闲的主机端口。这种自动映射是通过使用
    `-P` 参数完成的：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding command runs an nginx server in a container. nginx is listening
    at port `80` inside the container. With the `-P` parameter, we''re telling Docker
    to map all the exposed container ports to a free port in the 32xxx range. We can
    find out which host port Docker is using by using the `docker container port` command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在容器中运行一个 nginx 服务器。nginx 在容器内监听端口 `80`。通过 `-P` 参数，我们告诉 Docker 将所有暴露的容器端口映射到
    32xxx 范围内的一个空闲端口。我们可以使用 `docker container port` 命令找出 Docker 使用的是哪个主机端口：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The nginx container only exposes port `80`, and we can see that it has been
    mapped to the host port `32768`. If we open a new browser window and navigate
    to `localhost:32768`, we should see the following screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 容器只暴露了端口 `80`，我们可以看到它已经映射到了主机端口 `32768`。如果我们打开一个新的浏览器窗口并访问 `localhost:32768`，我们应该能看到以下界面：
- en: '![](img/6b50f760-dad5-486e-bc18-2cec42bbaae3.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b50f760-dad5-486e-bc18-2cec42bbaae3.png)'
- en: The welcome page of nginx
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 的欢迎页面
- en: 'An alternative way to find out which host port Docker is using for our container
    is to inspect it. The host port is part of the `NetworkSettings` node:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是通过检查容器来找出 Docker 正在使用的主机端口。主机端口是 `NetworkSettings` 节点的一部分：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, the third way of getting this information is to list the container:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，获取此信息的第三种方式是列出容器：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Please note that in the preceding output, the `/tcp` part tells us that the
    port has been opened for communication with the TCP protocol, but not for the
    UDP protocol. TCP is the default, and if we want to specify that we want to open
    the port for UDP, then we have to specify this explicitly. `0.0.0.0` in the mapping
    tells us that traffic from any host IP address can now reach container port `80` of
    the `web` container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述输出中，`/tcp` 部分告诉我们该端口已为 TCP 协议开放，但并未为 UDP 协议开放。TCP 是默认协议，如果我们想明确表示要为 UDP
    开放端口，则必须显式指定。映射中的 `0.0.0.0` 告诉我们，任何主机 IP 地址的流量现在都可以到达 `web` 容器的端口 `80`。
- en: 'Sometimes, we want to map a container port to a very specific host port. We
    can do this by using the `-p` parameter (or `--publish`). Let''s look at how this
    is done with the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望将容器端口映射到一个非常特定的主机端口。我们可以通过使用 `-p` 参数（或 `--publish`）来实现。让我们看看如何通过以下命令来实现：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The value of the `-p` parameter is in the form of `<host port>:<container port>`.
    Therefore, in the preceding case, we map container port `80` to host port `8080`.
    Once the `web2` container runs, we can test it in the browser by navigating to
    `localhost:8080`, and we should be greeted by the same nginx welcome page that
    we saw in the previous example that dealt with automatic port mapping.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 参数的值形式为 `<host port>:<container port>`。因此，在上述情况下，我们将容器端口 `80` 映射到主机端口
    `8080`。一旦 `web2` 容器运行，我们可以通过浏览器访问 `localhost:8080` 来进行测试，我们应该会看到与之前自动端口映射示例中看到的相同的
    nginx 欢迎页面。'
- en: When using the UDP protocol for communication over a certain port, the `publish`
    parameter will look like `-p 3000:4321/udp`. Note that if we want to allow communication
    with both TCP and UDP protocols over the same port, then we have to map each protocol
    separately.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 UDP 协议在某个端口进行通信时，`publish` 参数将类似于 `-p 3000:4321/udp`。请注意，如果我们希望允许使用 TCP
    和 UDP 协议在同一端口进行通信，那么我们必须分别为每种协议单独映射端口。
- en: HTTP-level routing using a reverse proxy
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理进行 HTTP 层级路由
- en: Imagine you have been tasked with containerizing a monolithic application. The
    application has organically evolved over the years into an unmaintainable monster.
    Changing even a minor feature in the source code may break other features due
    to the tight coupling existing in the code base. Releases are rare due to their
    complexity and require the whole team to be on deck. The application has to be
    taken down during the release window, which costs the company a lot of money due
    to lost opportunities, not to mention their loss of reputation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的任务是将一个单体应用程序容器化。这个应用程序多年来已经演变成一个无法维护的庞然大物。即使是修改源代码中的一个小功能，也可能由于代码库中的紧密耦合而导致其他功能的崩溃。由于其复杂性，发布过程很少，并且需要整个团队参与。在发布窗口期间，应用程序必须停机，这会给公司带来大量损失，除了错失的机会，还包括他们的声誉损失。
- en: Management has decided to put an end to that vicious cycle and improve the situation
    by containerizing the monolith. This alone will lead to a massively decreased
    time between releases as witnessed by the industry. In a later step, the company
    wants to break out every piece of functionality from the monolith and implement
    them as microservices. This process will continue until the monolith has been
    completely starved.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层决定结束这种恶性循环，并通过将单体应用程序容器化来改善这种情况。仅这一措施就会显著减少发布之间的时间，这一点已经在业内得到了验证。在后续步骤中，公司还计划将单体应用程序中的每个功能模块拆分出来，转变为微服务。这个过程将持续进行，直到单体应用程序完全被消除。
- en: But it is this second point that leads to some head-scratching in the team involved.
    How will we break down the monolith into loosely coupled microservices without
    affecting all the many clients of the monolith out there? The public API of the
    monolith, though very complex, has a well-structured design. Public URIs had been
    carefully crafted and should not be changed at all costs. For example, there is
    a product catalog function implemented in the app that can be accessed via `https://acme.com/catalog?category=bicycles` so
    that we can access a list of bicycles offered by the company.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但正是这一点让团队成员感到困惑。我们如何在不影响众多现有客户端的情况下，将这个单体应用拆解成松耦合的微服务呢？尽管单体应用的公共 API 非常复杂，但其设计结构良好。公共
    URI 经精心设计，绝不应更改。例如，应用程序中有一个产品目录功能，可以通过 `https://acme.com/catalog?category=bicycles`
    访问，从而查看公司提供的自行车列表。
- en: On the other hand, there is a URL called `https://acme.com/checkout` that we
    can use to initiate the checkout of a customers' shopping cart, and so on. I hope
    it is clear where we are going with this.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有一个 URL `https://acme.com/checkout`，可以用来启动客户购物车的结账流程，等等。我希望您能明白我们这么做的目的。
- en: Containerizing the monolith
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化单体应用
- en: 'Let''s start with the monolith. I have prepared a simple code base that has
    been implemented in Python 2.7 and uses Flask to implement the public REST API.
    The sample app is not really a full-blown application but just complex enough
    to allow for some redesign. The sample code can be found in the `ch10/e-shop` folder.
    Inside this folder is a subfolder called `monolith` containing the Python application.
    Follow these steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单体应用开始。我已经准备了一份简单的代码库，使用 Python 2.7 实现，并使用 Flask 构建公共 REST API。这个示例应用程序并不完全是一个完整的应用，只是足够复杂以进行一些重构。示例代码可以在
    `ch10/e-shop` 文件夹中找到。该文件夹内有一个名为 `monolith` 的子文件夹，包含 Python 应用程序。请按照以下步骤操作：
- en: 'In a new Terminal window, navigate to that folder, install the required dependencies,
    and run the application:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端窗口中，导航到该文件夹，安装所需的依赖项，并运行应用程序：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The application will be starting and listening on `localhost` on port `5000`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将在`localhost`上通过`5000`端口启动并监听：
- en: '![](img/0898d2ee-bb7a-47ed-a3b3-d4b30633783d.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0898d2ee-bb7a-47ed-a3b3-d4b30633783d.png)'
- en: Running the Python monolith
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Python 单体应用
- en: 'We can use `curl` to test the app. Use the following command to retrieve a
    list of all the bicycles the company offers:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `curl` 来测试该应用。使用以下命令检索公司提供的所有自行车列表：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You should see a JSON formatted list of three types of bicycles. OK – so far,
    so good.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个格式为 JSON 的三种自行车类型的列表。好的，到这里一切正常。
- en: 'Now, let''s change the `hosts` file, add an entry for `acme.com`, and map it
    to `127.0.0.1`, the loop-back address. This way, we can simulate a real client
    accessing the app with the URL `http://acme.cnoteom/catalog?category=bicycles`
    instead of using `localhost`. You need to use sudo to edit the hosts file on a
    macOS or on Linux. You should add a line to the `hosts` file that looks like this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来修改 `hosts` 文件，添加 `acme.com` 的条目，并将其映射到 `127.0.0.1`（回环地址）。这样，我们就能模拟真实客户端通过
    URL `http://acme.cnoteom/catalog?category=bicycles` 访问应用程序，而不是使用 `localhost`。在
    macOS 或 Linux 上，您需要使用 sudo 编辑 `hosts` 文件。您应该在 `hosts` 文件中添加如下内容：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save your changes and assert that it works by pinging `acme.com`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改，并通过 ping `acme.com` 来验证是否成功：
- en: '![](img/68e14aa6-b00c-441b-a1c9-bcc6d6804765.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68e14aa6-b00c-441b-a1c9-bcc6d6804765.png)'
- en: Mapping `acme.com` to the loop-back address via the `hosts` file
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `hosts` 文件将 `acme.com` 映射到回环地址
- en: On Windows, you can edit the file by, for example, running Notepad as an administrator,
    opening the `c:\Windows\System32\Drivers\etc\hosts` file, and modifying it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，您可以通过例如以管理员身份运行记事本，打开 `c:\Windows\System32\Drivers\etc\hosts` 文件并进行修改来编辑该文件。
- en: After all this, it is time to containerize the application. The only change
    we need to make in the application is ensuring that we have the application web
    server listening on `0.0.0.0` instead of `localhost`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些后，就该将应用程序容器化了。我们需要在应用程序中做的唯一更改是确保应用程序的 Web 服务器监听在`0.0.0.0`上，而不是`localhost`。
- en: 'We can do this easily by modifying the application and adding the following
    start logic at the end of `main.py`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过修改应用程序并在 `main.py` 文件末尾添加以下启动逻辑来轻松完成这项任务：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then, we can start the application with `python main.py`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过 `python main.py` 启动应用程序。
- en: 'Now, add a `Dockerfile` to the `monolith` folder with the following content:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `monolith` 文件夹中添加一个 `Dockerfile`，并将以下内容填入其中：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In your Terminal window, from within the monolith folder, execute the following
    command to build a Docker image for the application:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，从巨石文件夹中，执行以下命令来构建应用程序的 Docker 镜像：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After the image has been built, try to run the application:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在镜像构建完成后，尝试运行该应用程序：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that the output from the app now running inside a container is indistinguishable
    from what we got when running the application directly on the host. We can now
    test if the application still works as before by using the two `curl` commands
    to access the catalog and the checkout logic:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在在容器中运行的应用程序输出与直接在主机上运行应用程序时的输出是无法区分的。我们现在可以通过使用两个 `curl` 命令来访问目录和结账逻辑，测试应用程序是否像以前一样工作：
- en: '![](img/eb78770c-6b08-4775-aa10-bddd915b27ce.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb78770c-6b08-4775-aa10-bddd915b27ce.png)'
- en: Testing the monolith while running in a container
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行时测试巨石
- en: Evidently, the monolith still works exactly the same way as before, even when
    using the correct URL, that is, `http://acme.com`. Great! Now, let's break out
    part of the monolith's functionality into a Node.js microservice, which will be
    deployed separately.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，即使使用正确的 URL，即`http://acme.com`，该巨石仍然以与之前完全相同的方式工作。太好了！现在，让我们将巨石的一部分功能拆分为一个
    Node.js 微服务，并将其单独部署。
- en: Extracting the first microservice
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取第一个微服务
- en: The team, after some brainstorming, has decided that the product `catalog` is
    a good candidate for the first piece of functionality that is cohesive yet self-contained
    enough to be extracted from the monolith. They decide to implement the product
    catalog as a microservice implemented in Node.js.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 团队经过一些头脑风暴后，决定产品 `catalog` 是从巨石中提取的第一个功能的一个好候选者，它既紧密相关，又足够独立。于是他们决定将产品目录作为一个
    Node.js 微服务来实现。
- en: 'You can find the code they came up with and the `Dockerfile` in the `catalog` subfolder
    of the project folder, that is, `e-shop`. It is a simple Express.js application
    that replicates the functionality that was previously available in the monolith.
    Let''s get started:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目文件夹中的 `catalog` 子文件夹中找到他们编写的代码和 `Dockerfile`，也就是 `e-shop` 文件夹。这是一个简单的
    Express.js 应用程序，复现了之前在巨石中提供的功能。让我们开始吧：
- en: 'In your Terminal window, from within the `catalog` folder, build the Docker
    image for this new microservice:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，从 `catalog` 文件夹中，构建这个新微服务的 Docker 镜像：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, run a container from the new image you just built:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从刚刚构建的新镜像运行一个容器：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'From a different Terminal window, try to access the microservice and validate
    that it returns the same data as the monolith:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，尝试访问微服务，并验证它返回的数据是否与巨石相同：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Please notice the differences in the URL compared to when accessing the same
    functionality in the monolith. Here, we are accessing the microservice on port
    `3000` (instead of `5000`). But we said that we didn't want to have to change
    the clients that access our e-shop application. What can we do? Luckily, there
    are solutions to problems like this. We need to reroute incoming requests. We'll
    show you how to do this in the next section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与在巨石中访问相同功能时的 URL 相比，URL 有哪些不同。这里，我们正在访问微服务的端口是 `3000`（而不是 `5000`）。但是我们说过，我们不想改变访问我们电商应用的客户端。那么我们该怎么做呢？幸运的是，像这种问题是有解决方案的。我们需要重新路由传入请求。我们将在下一部分展示如何操作。
- en: Using Traefik to reroute traffic
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Traefik 重新路由流量
- en: In the previous section, we realized that we will have to reroute incoming traffic
    with a target URL starting with `http://acme.com:5000/catalog` to an alternative
    URL such as `product-catalog:3000/catalog`. We will be using Traefik to do exactly
    that.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们意识到我们需要将以 `http://acme.com:5000/catalog` 开头的目标 URL 的传入流量重新路由到一个替代 URL，例如
    `product-catalog:3000/catalog`。我们将使用 Traefik 来完成这一操作。
- en: Traefik is a cloud-native edge router and it is open source, which is great
    for our specific case. It even has a nice web UI that you can use to manage and
    monitor your routes. Traefik can be combined with Docker in a very straightforward
    way, as we will see in a moment.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik 是一个云原生边缘路由器，且是开源的，这对于我们的特定情况非常适用。它甚至有一个漂亮的 Web UI，你可以用来管理和监控你的路由。Traefik
    可以与 Docker 非常简便地结合使用，稍后我们将看到这一点。
- en: To integrate well with Docker, Traefik relies on metadata found on each container
    or service. This metadata can be applied in the form of labels that contain the
    routing information.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Docker 很好地集成，Traefik 依赖于每个容器或服务中的元数据。这些元数据可以通过包含路由信息的标签的形式应用。
- en: 'First, let''s look at how to run the catalog service:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下如何运行目录服务：
- en: 'Here is the Docker `run` command:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 Docker `run` 命令：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s quickly look at the four labels we define:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们定义的四个标签：
- en: '`traefik.enable=true`: This tells Traefik that this particular container should
    be included in the routing (the default is `false`).'
  id: totrans-251
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.enable=true`：这告诉 Traefik 这个特定的容器应该包含在路由中（默认值是 `false`）。'
- en: '`traefik.port=3000`: The router should forward the call to port `3000` (which
    is the port that the Express.js app is listening on).'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.port=3000`：路由器应该将请求转发到端口 `3000`（这是 Express.js 应用程序正在监听的端口）。'
- en: '`traefik.priority=10`: Give this route high priority. We will see why in a
    second.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.priority=10`：为这个路由设置较高的优先级。稍后我们会看到为什么。'
- en: '`traefik.http.routers.catalog.rule="Host(\"acme.com\") && PathPrefix(\"/catalog\")"`:
    The route must include the hostname, `acme.com`, and the path must start with
    `/catalog` in order to be rerouted to this service. As an example, `acme.com/catalog?type=bicycles`
    would qualify for this rule.'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.http.routers.catalog.rule="Host(\"acme.com\") && PathPrefix(\"/catalog\")"`：此路由必须包含主机名
    `acme.com`，且路径必须以 `/catalog` 开头，才能重定向到此服务。例如，`acme.com/catalog?type=bicycles`
    将符合此规则。'
- en: Please note the special form of the fourth label. Its general form is `traefik.http.routers.<service
    name>.rule`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第四个标签的特殊形式。其一般形式为 `traefik.http.routers.<service name>.rule`。
- en: 'Now, let''s look at how we can run the `eshop` container:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何运行 `eshop` 容器：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we forward any matching calls to port `5000`, which corresponds to the
    port where the `eshop` application is listening. Pay attention to the priority,
    which is set to `1` (low). This, in combination with the high priority of the
    `catalog` service, allows us to have all URLs starting with `/catalog` being filtered
    out and redirected to the `catalog` service, while all other URLs will go to the
    `eshop` service.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将任何匹配的请求转发到端口 `5000`，对应 `eshop` 应用程序监听的端口。请注意优先级，它设置为 `1`（低）。这与 `catalog`
    服务的高优先级结合使用，允许我们将所有以 `/catalog` 开头的 URL 过滤并重定向到 `catalog` 服务，而其他所有 URL 都将转发到 `eshop`
    服务。
- en: 'Now, we can finally run Traefik as the edge router that will serve as a reverse
    proxy in front of our application. This is how we start it:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以运行 Traefik 作为边缘路由器，它将在我们的应用程序前面作为反向代理。我们可以通过以下方式启动它：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note how we mount the Docker socket into the container so that Traefik can interact
    with the Docker engine. We will be able to send web traffic to port `80` of Traefik,
    from where it will be rerouted according to our rules in the routing definitions
    found in the metadata of the participating container. Furthermore, we can access
    the web UI of Traefik via port `8080`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将 Docker 套接字挂载到容器中，以便 Traefik 能与 Docker 引擎交互。我们可以将 Web 流量发送到 Traefik
    的端口 `80`，然后根据参与容器元数据中的路由定义规则重新路由流量。此外，我们还可以通过端口 `8080` 访问 Traefik 的 Web UI。
- en: 'Now that everything is running, that is, the monolith, the first microservice
    called `catalog`, and Traefik, we can test if all works as expected. Use `curl`
    once again to do so:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都已运行，即单体应用、名为 `catalog` 的第一个微服务和 Traefik，我们可以测试是否一切按预期工作。再次使用 `curl` 来进行测试：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we mentioned earlier, we are now sending all traffic to port `80`, which
    is what Traefik is listening on. This proxy will then reroute the traffic to the
    correct destination.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，现在我们将所有流量发送到端口 `80`，这是 Traefik 监听的端口。这个代理将把流量重新路由到正确的目标。
- en: 'Before proceeding, stop all containers:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，停止所有容器：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's it for this chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章到此为止。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about how containers running on a single host
    can communicate with each other. First, we looked at the CNM, which defines the
    requirements of a container network, and then we investigated several implementations
    of the CNM, such as the bridge network. We then looked at how the bridge network
    functions in detail and also what kind of information Docker provides us with
    about the networks and the containers attached to those networks. We also learned
    about adopting two different perspectives, from both outside and inside the container. Last
    but not least we introduced Traefik as a means to provide application level routing
    to our applications.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何在单个主机上运行的容器相互通信。首先，我们了解了 CNM，它定义了容器网络的要求，然后我们研究了几种 CNM 实现，例如桥接网络。接着，我们详细了解了桥接网络的功能，以及
    Docker 提供的有关网络和附加到这些网络的容器的信息。我们还学习了从容器内外两种视角进行观察的方法。最后，我们介绍了 Traefik，作为为我们的应用程序提供应用级路由的手段。
- en: In the next chapter, we're going to introduce Docker Compose. We will learn
    about creating an application that consists of multiple services, each running
    in a container, and how Docker Compose allows us to easily build, run, and scale
    such an application using a declarative approach.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Docker Compose。我们将学习如何创建一个由多个服务组成的应用程序，每个服务运行在一个容器中，以及 Docker Compose
    如何使我们能够使用声明性方法轻松构建、运行和扩展这样的应用程序。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess the skills that you have gained from this chapter, please try to
    answer the following questions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你从本章学到的技能，请尝试回答以下问题：
- en: Name the three core elements of the **container network model** (**CNM**).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名 **容器网络模型** (**CNM**) 的三个核心元素。
- en: How do you create a custom bridge network called, for example, `frontend`?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个自定义的桥接网络，例如 `frontend`？
- en: How do you run two `nginx:alpine` containers attached to the `frontend` network?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何运行两个附加到 `frontend` 网络的 `nginx:alpine` 容器？
- en: 'For the `frontend` network, get the following:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `frontend` 网络，获取以下内容：
- en: The IPs of all the attached containers
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有附加容器的 IP 地址
- en: The subnet associated with the network
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网络关联的子网
- en: What is the purpose of the `host` network?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host` 网络的目的是什么？'
- en: Name one or two scenarios where the use of the `host` network is appropriate.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举一个或两个适合使用 `host` 网络的场景。
- en: What is the purpose of the `none` network?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`none` 网络的目的是什么？'
- en: In what scenarios should the `none` network be used?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪些场景下应该使用 `none` 网络？
- en: Why would we use a reverse proxy such as Traefik together with our containerized
    application?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要将反向代理如 Traefik 与我们的容器化应用程序一起使用？
- en: Further reading
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some articles that describe the topics that were presented in this
    chapter in more detail:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些更详细描述本章内容的文章：
- en: Docker networking overview: [http://dockr.ly/2sXGzQn](http://dockr.ly/2sXGzQn)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 网络概述: [http://dockr.ly/2sXGzQn](http://dockr.ly/2sXGzQn)'
- en: Container networking: [http://dockr.ly/2HJfQKn](http://dockr.ly/2HJfQKn)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '容器网络: [http://dockr.ly/2HJfQKn](http://dockr.ly/2HJfQKn)'
- en: What is a bridge?: [https://bit.ly/2HyC3Od](https://bit.ly/2HyC3Od)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是桥接？: [https://bit.ly/2HyC3Od](https://bit.ly/2HyC3Od)'
- en: Using bridge networks: [http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用桥接网络: [http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)'
- en: Using Macvlan networks: [http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 Macvlan 网络: [http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)'
- en: Networking using the host network: [http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用主机网络进行网络连接: [http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)'
