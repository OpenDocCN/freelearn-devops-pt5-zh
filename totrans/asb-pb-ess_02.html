<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Blueprinting Your Infrastructure</h1></div></div></div><p>This book is a primer for anyone who has conceptual knowledge of Ansible and would like to get started writing Ansible playbooks to automate common infrastructure tasks, orchestrate application deployments, and/or manage configurations across multiple environments. This book follows an incremental approach, starting with the basics such as learning about the anatomy of a playbook and writing simple roles to create modular code. Once comfortable with the basics, you will be introduced to primitives such as adding dynamic data with variables and templates, and controlling execution flow with conditionals and iterators. This is then followed by more advanced topics such as node discovery, clustering, encrypting data, and managing environments. We conclude with the discussion on the orchestration features of Ansible. Let's begin our journey towards being an Ansible practitioner by learning about playbooks.</p><p>In this chapter, we will learn about:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The anatomy of a playbook</li><li class="listitem" style="list-style-type: disc">What plays are and how to write a Hosts inventory and search patterns</li><li class="listitem" style="list-style-type: disc">Ansible modules and the batteries-included approach</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Getting introduced to Ansible</h1></div></div></div><p>
<strong>Ansible</strong> is a <a id="id0" class="indexterm"/>simple, flexible, and extremely powerful tool that gives you the ability to automate common infrastructure tasks, run ad hoc commands, and deploy multitier applications spanning multiple machines. Even though you can use Ansible to launch commands on a number of hosts in parallel, the real power lies in managing those using playbooks.</p><p>As systems engineer, infrastructure that we typically need to automate contains complex multitier applications. Each of which represents a class of servers, for example, load balancers, web servers, database servers, caching applications, and middleware queues. Since many of these applications have to work in tandem to provide a service, there is topology involved as well. For example, a load balancer would connect to web servers, which in turn read/write to a database and connect to the caching server to fetch in-memory objects. Most of the time, when we launch such application stacks, we need to configure these components in a very specific order.</p><p>Here is an example of a <a id="id1" class="indexterm"/>very common three-tier web application running a load balancer, a web server, and a database backend:</p><div><img src="img/B03800_01_01.jpg" alt="Getting introduced to Ansible"/></div><p>Ansible lets you translate this diagram into a blueprint, which defines your infrastructure policies. The format used to specify such policies is what playbooks are.</p><p>Example policies and the sequence in which those are to be applied is shown in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Install, configure, and start the MySQL service on the database servers.</li><li class="listitem">Install and configure the web servers that run <strong>Nginx</strong> with <strong>PHP</strong> bindings.</li><li class="listitem">Deploy a Wordpress application on the web servers and add respective configurations to Nginx.</li><li class="listitem">Start the Nginx service on all web servers after deploying Wordpress. Finally, install, configure, and start the <strong>haproxy</strong> service on the load balancer hosts. Update haproxy configurations with the hostnames of all the web servers created earlier.</li></ol></div><p>The following is a sample <a id="id2" class="indexterm"/>playbook that translates the infrastructure blueprint into policies enforceable by Ansible:</p><div><img src="img/B03800_01_02.jpg" alt="Getting introduced to Ansible"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Plays</h1></div></div></div><p>A playbook consists of <a id="id3" class="indexterm"/>one or more plays, which map groups of hosts to well-defined tasks. The preceding example contains three plays, each to configure one layer in the multitiered web application. Plays also define the order in which tasks are configured. This allows us to orchestrate multitier deployments. For example, configure the load balancers only after starting the web servers, or perform two-phase deployment where the first <a id="id4" class="indexterm"/>phase only adds this configurations and the second phase starts the services in the desired order.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>YAML – the playbook language</h2></div></div></div><p>As you may have <a id="id5" class="indexterm"/>already noticed, the playbook that we wrote previously resembles more of a text configuration than a code snippet. This is because the creators of <a id="id6" class="indexterm"/>Ansible chose to use a simple, human-readable, and familiar YAML format to blueprint the infrastructure. This adds to Ansible's appeal, as users of this tool need not learn any special programming language to get started with. Ansible code is self-explanatory and self-documenting in nature. A quick crash course on YAML should suffice to understand the basic syntax. Here is what you need to know about YAML to get started with your first playbook:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line of a playbook should begin with "--- " (three hyphens) which indicates the beginning of the YAML document.</li><li class="listitem" style="list-style-type: disc">Lists in YAML are represented with a hyphen followed by a white space. A playbook contains a list of plays; they are represented with "-  ". Each play is an associative array, a dictionary, or a map in terms of key-value pairs.</li><li class="listitem" style="list-style-type: disc">Indentations are important. All members of a list should be at the same indentation level.</li><li class="listitem" style="list-style-type: disc">Each play can contain key-value pairs separated by ":" to denote hosts, variables, roles, tasks, and so on.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Our first playbook</h1></div></div></div><p>Equipped with the basic rules <a id="id7" class="indexterm"/>explained previously and assuming readers have done a quick dive into YAML fundamentals, we will now begin writing our first playbook. Our problem statement includes the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a devops user on all hosts. This user should be part of the <code class="literal">devops</code> group.</li><li class="listitem">Install the "htop" utility. <strong>Htop</strong> <a id="id8" class="indexterm"/>is an improved version of top—an interactive system process monitor.</li><li class="listitem">Add the Nginx repository to the web servers and start it as a service.</li></ol></div><p>Now, we will create our first playbook and save it as <code class="literal">simple_playbook.yml</code> containing the following code:</p><div><pre class="programlisting">---
- hosts: all
  remote_user: vagrant
  sudo: yes
  tasks:
  
  - group:
      name: devops
      state: present
  - name: create devops user with admin privileges
    
    user:
      name: devops
      comment: "Devops User"
      uid: 2001
      group: devops
  - name: install htop package
    action: apt name=htop state=present update_cache=yes

- hosts: www
  user: vagrant
  sudo: yes
  tasks:
  - name: add official nginx repository
    apt_repository:
      repo: 'deb http://nginx.org/packages/ubuntu/ lucid nginx'
  - name: install nginx web server and ensure its at the latest version
    apt:
      name: nginx
      state: latest
  - name: start nginx service
    service:
      name: nginx
      state: started</pre></div><p>Our playbook contains <a id="id9" class="indexterm"/>two plays. Each play consists of the following two <a id="id10" class="indexterm"/>important parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>What to configure</strong>: We need to configure a host or group of hosts to run the play against. Also, we need to include useful connection information, such as which user to connect as, whether to use <code class="literal">sudo</code> command, and so on.</li><li class="listitem" style="list-style-type: disc"><strong>What to run</strong>: This includes <a id="id11" class="indexterm"/>the specification of tasks to be run, including which system components to modify and which state they should be in, for example, installed, started, or latest. This could be represented with tasks and later on, by roles.</li></ul></div><p>Let's now look at each of these briefly.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Creating a host inventory</h2></div></div></div><p>Before we even start <a id="id12" class="indexterm"/>writing our playbook with Ansible, we need to define an inventory of all hosts that need to be configured, and make it available for Ansible to use. Later, we will start running plays against a selection of hosts from this inventory. If you have an existing inventory, such as cobbler, LDAP, a CMDB software, or wish to pull it from a cloud provider, such as ec2, it can be pulled from Ansible using the concept of a dynamic inventory.</p><p>For text-based local inventory, the default location is <code class="literal">/etc/ansible/hosts</code>. For our learning environment, however, we will create a custom inventory file <code class="literal">customhosts</code> in our working directory, the contents of which are shown as follows. You are free to create your own inventory file:</p><div><pre class="programlisting">#customhosts
#inventory configs for my cluster
[db]
192.168.61.11  ansible_ssh_user=vagrant

[www]
www-01.example.com ansible_ssh_user=ubuntu
www-02 ansible_ssh_user=ubuntu

[lb]
lb0.example.com</pre></div><p>Now, when our playbook maps a play to the group, the <code class="literal">www</code> (<code class="literal">hosts:</code> <code class="literal">www</code>), hosts in that group will be configured. The <code class="literal">all</code> keywords will match to all hosts from the inventory.</p><p>The following are the guidelines to for creating inventory files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inventory files follow INI style configurations, which essentially include configuration blocks that start with host group/class names included in "<code class="literal">[ ]</code>". This allows the selective execution on classes of systems, for example, <code class="literal">[namenodes]</code>.</li><li class="listitem" style="list-style-type: disc">A single host can be part of multiple groups. In such cases, host variables from both the groups will get merged, and the precedence rules apply. We will discuss variables and precedence in detail later.</li><li class="listitem" style="list-style-type: disc">Each group contains a list of hosts and connection details, such as the SSH user to connect as, the SSH <a id="id13" class="indexterm"/>port number if non-default, SSH credentials/keys, sudo credentials, and so on. Hostnames can also contain globs, ranges, and more, to make it easy to include multiple hosts of the same type, which follow some naming patterns.</li></ul></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>After creating an inventory of the hosts, it's a good idea to validate connectivity using Ansible's ping module (for example, <code class="literal">ansible -m ping all</code>).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Patterns</h2></div></div></div><p>In the preceding playbook, the <a id="id14" class="indexterm"/>following lines decide which hosts to select to run a specific play:</p><div><pre class="programlisting">- hosts: all
- hosts: www</pre></div><p>The first code will match <a id="id15" class="indexterm"/>all hosts, and the second code will match hosts which are part of the <code class="literal">www</code> group.</p><p>Patterns can be any of the following or their combinations:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pattern Types</p>
</th><th style="text-align: left" valign="bottom">
<p>Examples</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Group name</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">namenodes</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Match all</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">all</code> or <code class="literal">*</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Range</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">namenode[0:100]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Hostnames/hostname globs</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">*.example.com</code>, <code class="literal">host01.example.com</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Exclusions</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">namenodes:!secondaynamenodes</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Intersection</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">namenodes:&amp;zookeeper</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Regular <a id="id16" class="indexterm"/>expressions</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">~(nn|zk).*\.example\.org </code>
</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Tasks</h2></div></div></div><p>Plays map hosts to tasks. Tasks <a id="id17" class="indexterm"/>are a sequence of actions performed against a <a id="id18" class="indexterm"/>group of hosts that match the pattern specified in a play. Each play typically contains multiple tasks that are run serially on each machine that matches the pattern. For example, take a look at the following code snippet:</p><div><pre class="programlisting">
<strong>- group:</strong>
<strong>    name:devops</strong>
<strong>    state: present</strong>
<strong>- name: create devops user with admin privileges</strong>
<strong>  user:</strong>
<strong>    name: devops</strong>
<strong>    comment: "Devops User"</strong>
<strong>    uid: 2001</strong>
<strong>    group: devops</strong>
</pre></div><p>In the preceding example, we have two tasks. The first one is to create a group, and second is to create a user and add it to the group created earlier. If you notice, there is an additional line in the second task, which starts with <code class="literal">name:</code>. While writing tasks, it's good to provide a name with a human-readable description of what this task is going to achieve. If not, the action string will be printed instead.</p><p>Each action in a task list can be declared by specifying the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of the module</li><li class="listitem" style="list-style-type: disc">Optionally, the state of the system component being managed</li><li class="listitem" style="list-style-type: disc">The optional parameters</li></ul></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>With newer versions of Ansible (0.8 onwards), writing an action keyword is now optional. We can directly provide the name of the module instead. So, both of these lines will have a similar action, that is,. installing a package with the <code class="literal">apt</code> module:</p><div><pre class="programlisting">
<strong>action: apt name=htop state=present update_cache=yes</strong>
<strong>apt: name=nginx state=latest</strong>
</pre></div></div></div><p>Ansible stands out from other configuration management tools, with its batteries-included included approach. These batteries <a id="id19" class="indexterm"/>are "modules." It's important to understand what <a id="id20" class="indexterm"/>modules are before we proceed.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Modules</h3></div></div></div><p>Modules are the <a id="id21" class="indexterm"/>encapsulated procedures that are responsible for managing specific system <a id="id22" class="indexterm"/>components on specific platforms.</p><p>Consider the following example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">apt</code> module for Debian and the <code class="literal">yum</code> module for RedHat helps manage system packages</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> user</code> module is responsible for adding, removing, or modifying users on the system</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> service</code> module will start/stop system services</li></ul></div><p>Modules abstract the actual implementation from users. They expose a declarative syntax that accepts a list of the parameters and states of the system components being managed. All this can be declared using the human-readable YAML syntax, using key-value pairs.</p><p>In terms of functionality, modules resemble providers for those of you who are familiar with Chef/Puppet software. Instead of writing procedures to create a user, with Ansible we declare which state our component should be in, that is, which user to create, its state, and its characteristics, such as UID, group, shell, and so on. The actual procedures are inherently known to Ansible via modules, and are executed in the background.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The <code class="literal">Command</code> and <code class="literal">Shell</code> modules are special ones. They neither take key-value pairs as parameters, nor are idempotent.</p></div></div><p>Ansible comes preinstalled with a library of modules, which ranges from the ones which manage basic system resources to more sophisticated ones that send notifications, perform cloud integrations, and so on. If you want to provision an ec2 instance, create a database on the remote PostgreSQL server, and get notifications on <strong>IRC</strong>, then Ansible has a module for it. Isn't this amazing?</p><p>No need to worry about finding an external plugin, or struggle to integrate with cloud providers, and so on. To find a list of modules available, you can refer to the Ansible documentation <a id="id23" class="indexterm"/>at <a class="ulink" href="http://docs.ansible.com/list_of_all_modules.html">http://docs.ansible.com/list_of_all_modules.html</a>.</p><p>Ansible is extendible too. If you do not find a module that does the job for you, it's easy to write one, and it doesn't <a id="id24" class="indexterm"/>have to be in Python. A module can be written for Ansible in the <a id="id25" class="indexterm"/>language of your choice. This is discussed in detail at <a class="ulink" href="http://docs.ansible.com/developing_modules.html">http://docs.ansible.com/developing_modules.html</a>.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec01"/>The modules and idempotence</h4></div></div></div><p>Idempotence is an <a id="id26" class="indexterm"/>important characteristic of a module. It is something which can be applied on your system multiple times, and will return deterministic results. It <a id="id27" class="indexterm"/>has built-in intelligence. For instance, we have a task that uses the <code class="literal">apt</code> module to install Nginx and ensure that it's up to date. Here is what happens if you run it multiple times:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every time idempotance is run multiple times, the <code class="literal">apt</code> module will compare what has been declared in the playbook versus the current state of that package on the system. The first time it runs, Ansible will determine that Nginx is not installed, and will go ahead with the installation.</li><li class="listitem" style="list-style-type: disc">For every consequent run, it will skip the installation part, unless there is a new version of the package available in the upstream repositories.</li></ul></div><p>This allows executing the same task multiple times without resulting in the error state. Most of the Ansible modules are idempotent, except for the command and shell modules. Users will have to make these modules idempotent.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Running the playbook</h2></div></div></div><p>Ansible comes <a id="id28" class="indexterm"/>with the <code class="literal">ansible-playbook</code> command to launch a playbook with. Let's now run the plays we created:</p><div><pre class="programlisting">
<strong>$ ansible-playbook simple_playbook.yml -i customhosts</strong>
</pre></div><p>Here is what happens when you run the preceding command:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">ansible-playbook</code> parameter is the command that takes the playbook as an argument (<code class="literal">simple_playbook.yml</code>) and runs the plays against the hosts</li><li class="listitem" style="list-style-type: disc">The <code class="literal">simple_playbook</code> parameter contains the two plays that we created: one for common tasks, and the other for installing Nginx</li><li class="listitem" style="list-style-type: disc">The <code class="literal">customhosts</code> parameter is our host's inventory, which lets Ansible know which hosts, or groups of hosts, to call plays against</li></ul></div><p>Launching the preceding command will start calling plays, orchestrating in the sequence that we described in the playbook. Here is the output of the preceding command:</p><div><img src="img/B03800_01_03.jpg" alt="Running the playbook"/></div><p>Let's now analyze <a id="id29" class="indexterm"/>what happened:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ansible reads the playbooks specified as an argument to the <code class="literal">ansible-playbook</code> command and starts executing plays in the serial order.</li><li class="listitem" style="list-style-type: disc">The first play that we declared, runs against the "<code class="literal">all</code>" hosts. The <code class="literal">all</code> keyword is a special pattern that will match all hosts (similar to <code class="literal">*</code>). So, the tasks in the first play will be executed on all hosts in the inventory we passed as an argument.</li><li class="listitem" style="list-style-type: disc">Before running any of the tasks, Ansible will gather information about the systems that it is going to configure. This information is collected in the form of facts.</li><li class="listitem" style="list-style-type: disc">The first play includes the creation of the <code class="literal">devops</code> group and user, and installation of the htop package. Since we have three hosts in our inventory, we see one line per host being printed, which indicates whether there was a change in the state of the entity being managed. If the state was not changed, "ok" will be printed.</li><li class="listitem" style="list-style-type: disc">Ansible then moves to the next play. This is executed only on one host, as we have specifed "<code class="literal">hosts:www</code>" in our play, and our inventory contains a single host in the group "<code class="literal">www</code>".</li><li class="listitem" style="list-style-type: disc">During the second <a id="id30" class="indexterm"/>play, the Nginx repository is added, the package is installed, and the service is started.</li><li class="listitem" style="list-style-type: disc">Finally, Ansible prints the summary of the playbook run in the "<code class="literal">PLAY RECAP</code>" section. It indicates how many modifications were made, if any of the hosts were unreachable, or execution failed on any of the systems.</li></ul></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>What if a host is unresponsive, or fails to run tasks? Ansible has built-in intelligence, which will identify such issues and take the failed host out of rotation. It will not affect the execution on other hosts.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Review questions</h1></div></div></div><p>Do you think you've understood the chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">What is idempotence when it comes to modules?</li><li class="listitem">What is the host's inventory and why is it required?</li><li class="listitem">Playbooks map ___ to ___ (fill in the blanks)</li><li class="listitem">What types of patterns can you use while selecting a list of hosts to run plays against?</li><li class="listitem">Where is the actual procedure to execute an action on a specific platform defined?</li><li class="listitem">Why is it said that Ansible comes with batteries included?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter, you learned about what Ansible playbooks are, what components those are made up of, and how to blueprint your infrastructure with it. We also did a primer on YAML—the language used to create plays. You learned about how plays map tasks to hosts, how to create a host inventory, how to filter hosts with patterns, and how to use modules to perform actions on our systems. We then created a simple playbook as a proof of concept.</p><p>In the upcoming chapter, we will start refactoring our code to create reusable and modular chunks of code, and call them roles.</p></div></body></html>