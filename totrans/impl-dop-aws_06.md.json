["```\nresource \"aws_subnet\" \"public-2\" { \n  vpc_id = \"${aws_vpc.terraform-vpc.id}\" \n  cidr_block = \"${cidrsubnet(var.vpc-cidr, 8, 3)}\" \n  availability_zone = \"${element(split(\",\",var.aws-availability-zones), count.index + 1)}\" \n  map_public_ip_on_launch = true \n\n  tags { \n    Name = \"Public\" \n  } \n} \n\n```", "```\nresource \"aws_route_table_association\" \"public-2\" { \n  subnet_id = \"${aws_subnet.public-2.id}\" \n  route_table_id = \"${aws_route_table.public.id}\" \n} \n\n```", "```\n\nresource \"aws_subnet\" \"private-2\" { \n  vpc_id = \"${aws_vpc.terraform-vpc.id}\" \n  cidr_block = \"${cidrsubnet(var.vpc-cidr, 8, 4)}\" \n  availability_zone = \"${element(split(\",\",var.aws-availability-zones), count.index +1)}\" \n  map_public_ip_on_launch = false \n\n  tags { \n    Name = \"Private\" \n  } \n} \n\nresource \"aws_route_table_association\" \"private-2\" { \n  subnet_id = \"${aws_subnet.private-2.id}\" \n  route_table_id = \"${aws_route_table.private.id}\" \n} \n\n```", "```\nresource \"aws_security_group\" \"demo-app-elb-prod\" { \n  name = \"demo-app-elb-prod\" \n  description = \"ELB security group\" \n  vpc_id = \"${aws_vpc.terraform-vpc.id}\" \n\n  ingress { \n    from_port = \"80\" \n    to_port = \"80\" \n    protocol = \"tcp\" \n    cidr_blocks = [\"0.0.0.0/0\"] \n  } \n\n```", "```\n  egress { \n    from_port = 0 \n    to_port = 0 \n    protocol = \"-1\" \n    cidr_blocks = [\"0.0.0.0/0\"] \n  } \n\n} \n\nresource \"aws_elb\" \"demo-app-elb-prod\" { \n  name = \"demo-app-elb-prod\" \n  security_groups = [\"${aws_security_group.demo-app-elb-prod.id}\"] \n  subnets = [\"${aws_subnet.public-1.id}\", \"${aws_subnet.public-2.id}\"] \n  cross_zone_load_balancing = true \n  connection_draining = true \n  connection_draining_timeout = 30 \n\n  listener { \n    instance_port = 80 \n    instance_protocol = \"http\" \n    lb_port = 80 \n    lb_protocol = \"http\" \n  } \n\n  tags { \n    Name = \"demo-app-elb-prod\" \n  } \n} \n\n```", "```\nresource \"aws_security_group\" \"demo-app\" { \n  name = \"demo-app\" \n  description = \"ec2 instance security group\" \n  vpc_id = \"${aws_vpc.terraform-vpc.id}\" \n\n  ingress { \n    from_port = \"80\" \n    to_port = \"80\" \n    protocol = \"tcp\" \n    security_groups = [\"${aws_security_group.demo-app-elb.id}\", \"${aws_security_group.demo-app-elb-prod.id}\"] \n  }  \n\n```", "```\nresource \"aws_launch_configuration\" \"demo-app-lcfg\" { \n    name = \"placeholder_launch_config\" \n    image_id = \"${var.jenkins-ami-id}\" \n    instance_type = \"${var.jenkins-instance-type}\" \n    iam_instance_profile = \"${aws_iam_instance_profile.demo-app.id}\" \n    security_groups = [\"${aws_security_group.demo-app.id}\"] \n} \n\nresource \"aws_autoscaling_group\" \"demo-app-blue\" { \n  name = \"demo-app-blue\" \n  launch_configuration = \"${aws_launch_configuration.demo-app-lcfg.id}\" \n  vpc_zone_identifier = [\"${aws_subnet.private-1.id}\", \"${aws_subnet.private-2.id}\"] \n  min_size = 0 \n  max_size = 0 \n\n  tag { \n    key = \"ASG\" \n    value = \"demo-app-blue\" \n    propagate_at_launch = true \n  } \n} \n\nresource \"aws_autoscaling_group\" \"demo-app-green\" { \n  name = \"demo-app-green\" \n  launch_configuration = \"${aws_launch_configuration.demo-app-lcfg.id}\" \n  vpc_zone_identifier = [\"${aws_subnet.private-1.id}\", \"${aws_subnet.private-2.id}\"] \n  min_size = 0 \n  max_size = 0 \n\n  tag { \n    key = \"ASG\" \n    value = \"demo-app-green\" \n    propagate_at_launch = true \n  } \n} \n\n```", "```\noutput \"ELB URI PROD\" { \n  value = \"${aws_elb.demo-app-elb-prod.dns_name}\" \n} \n\n```", "```\n#!groovy \n\nnode { \n\n  step([$class: 'WsCleanup']) \n\n  stage \"Checkout Git repo\" { \n    checkout scm \n  } \n\n  stage \"Deploy AMI\" { \n   sh returnStdout: false, script: \"bash ./cdeployment.sh ${AMI_ID}\" \n  } \n\n} \n\n```", "```\n#!/bin/bash \nset -ef -o pipefail \n\nblueGroup=\"demo-app-blue\" \ngreenGroup=\"demo-app-green\" \nelbName=\"demo-app-elb-prod\" \nAMI_ID=${1} \n\n```", "```\nfunction techo() {  \n  echo \"[$(date +%s)] \" ${1} \n} \n\nfunction Err() { \n  techo \"ERR: ${1}\" \n  exit 100 \n} \n\n```", "```\nfunction rollback() { \n  techo \"Metrics check failed, rolling back\" \n  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${newActiveGroup} \\ \n  --min-size 0 \n  techo \"Instances ${1} entering standby in group ${newActiveGroup}\" \n  aws autoscaling enter-standby --should-decrement-desired-capacity \\ \n    --auto-scaling-group-name ${newActiveGroup} --instance-ids ${1} \n  techo \"Detaching ${elbName} from ${newActiveGroup}\" \n  aws autoscaling detach-load-balancers --auto-scaling-group-name ${newActiveGroup} \\ \n    --load-balancer-names ${elbName} \n  Err \"Deployment rolled back. Please check instances in StandBy.\" \n} \n\n```", "```\ntecho \">>> Waiting for instances to launch\" \nasgInstances=() \n\nwhile [ ${#asgInstances[*]} -ne ${1} ];do \n  sleep 10 \n  asgInstances=($(aws autoscaling describe-auto-scaling-groups \\ \n    --auto-scaling-group-name ${newActiveGroup} | jq .AutoScalingGroups[0].Instances[].InstanceId | tr -d '\"' )) \n  techo \"Launched ${#asgInstances[*]} out of ${1}\" \ndone \n\n```", "```\ntecho \">>> Waiting for instances to become available\" \nasgInstancesReady=0 \niterList=(${asgInstances[*]}) \n\nwhile [ ${asgInstancesReady} -ne ${#asgInstances[*]} ];do \n  sleep 10 \n  for i in ${iterList[*]};do \n    asgInstanceState=$(aws autoscaling describe-auto-scaling-instances \\ \n      --instance-ids ${i} | jq .AutoScalingInstances[0].LifecycleState | tr -d '\"') \n\n    if [[ ${asgInstanceState} == \"InService\" ]];then \n      asgInstancesReady=\"$((asgInstancesReady+1))\" \n      iterList=(${asgInstances[*]/${i}/}) \n    fi \n  done \n  techo \"Available ${asgInstancesReady} out of ${#asgInstances[*]}\" \ndone \n\n```", "```\ntecho \">>> Waiting for ELB instances to become InService\" \nelbInstancesReady=0 \niterList=(${asgInstances[*]}) \n\nwhile [ ${elbInstancesReady} -ne ${#asgInstances[*]} ];do \n  sleep 10 \n  for i in ${iterList[*]};do \n    elbInstanceState=$(aws elb describe-instance-health \\ \n      --load-balancer-name ${elbName} --instances ${i} | jq .InstanceStates[].State | tr -d '\"') \n\n    if [[ ${elbInstanceState} == \"InService\" ]];then \n      elbInstancesReady=$((elbInstancesReady+1)) \n      iterList=(${asgInstances[*]/${i}/}) \n    fi \n  done \n  techo \"InService ${elbInstancesReady} out of ${#asgInstances[*]}\"  \ndone \n\n```", "```\nexport AWS_DEFAULT_REGION=\"us-east-1\" \n\n```", "```\n[[ ${AMI_ID} = ami-* ]] || Err \"AMI ID ${AMI_ID} is invalid\" \n\n```", "```\nblueElb=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names ${blueGroup} | \\ \n  jq .AutoScalingGroups[0].LoadBalancerNames[0] | tr -d '\"') \ngreenElb=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names ${greenGroup} | \\ \n  jq .AutoScalingGroups[0].LoadBalancerNames[0] | tr -d '\"') \n\n```", "```\n[[ \"${blueElb}\" != \"${greenElb}\" ]] || Err \"Identical ELB value for both groups\" \n\nif [[ \"${blueElb}\" == \"${elbName}\" ]]; then \n  activeGroup=${blueGroup} \n  newActiveGroup=${greenGroup} \nelif [[ \"${greenElb}\" == \"${elbName}\" ]]; then \n  activeGroup=${greenGroup} \n  newActiveGroup=${blueGroup} \nfi \n\n[ -n \"${activeGroup}\" ] || Err \"Missing activeGroup\" \n[ -n \"${newActiveGroup}\" ] || Err \"Missing newActiveGroup\" \n\ntecho \"Active group: ${activeGroup}\" \ntecho \"New active group: ${newActiveGroup}\" \n\n```", "```\nasgInstances=($(aws autoscaling describe-auto-scaling-groups \\ \n    --auto-scaling-group-name ${newActiveGroup} | jq .AutoScalingGroups[0].Instances[].InstanceId | tr -d '\"' )) \n[ ${#asgInstances[*]} -eq 0 ] || Err \"Found instances attached to ${newActiveGroup}!\" \n\n```", "```\nactiveDesired=$(aws autoscaling describe-auto-scaling-groups \\ \n  --auto-scaling-group-name ${activeGroup} | jq .AutoScalingGroups[0].DesiredCapacity) \nactiveMin=$(aws autoscaling describe-auto-scaling-groups \\ \n  --auto-scaling-group-name ${activeGroup} | jq .AutoScalingGroups[0].MinSize) \nactiveMax=$(aws autoscaling describe-auto-scaling-groups \\ \n  --auto-scaling-group-name ${activeGroup} | jq .AutoScalingGroups[0].MaxSize) \nscaleStep=$(( (30 * ${activeDesired}) /100 )) \n\n```", "```\n[ ${activeDesired} -gt 0 ] || Err \"Active group ${activeGroup} is set to 0 instances!\" \n\n[ ${scaleStep} -gt 0 ] || scaleStep=1 \n\n```", "```\nactiveInstance=$(aws autoscaling describe-auto-scaling-groups \\ \n  --auto-scaling-group-name ${activeGroup} | jq .AutoScalingGroups[0].Instances[0].InstanceId | tr -d '\"') \n\n[[ ${activeInstance} = i-* ]] || Err \"activeInstance ${activeInstance} is invalid\" \n\nlaunchConf=\"demo-app-${AMI_ID}-$(date +%s)\"  \n\naws autoscaling create-launch-configuration --launch-configuration-name ${launchConf} \\ \n  --image-id ${AMI_ID} --instance-id ${activeInstance} \n\n```", "```\ntecho \">>> Attaching ${launchConf} to ${newActiveGroup}\" \naws autoscaling update-auto-scaling-group --auto-scaling-group-name ${newActiveGroup} \\ \n  --launch-configuration-name ${launchConf} \n\n```", "```\ntecho \">>> Attaching ${elbName} to ${newActiveGroup}\" \naws autoscaling attach-load-balancers --auto-scaling-group-name ${newActiveGroup} \\ \n  --load-balancer-names ${elbName} \n\n```", "```\ntecho \">>> Increasing ${newActiveGroup} capacity (min/max/desired) to ${scaleStep}\" \naws autoscaling update-auto-scaling-group --auto-scaling-group-name ${newActiveGroup} \\ \n  --min-size ${scaleStep} --max-size ${scaleStep} --desired-capacity ${scaleStep} \n\n```", "```\nwait_for_instances ${scaleStep} \n\n```", "```\ntecho \">>> Checking error metrics\" \nsleep 5 \ndoRollback=false \n${doRollback} && rollback \"${asgInstances[*]}\" \n\ntecho \">>> Matching ${newActiveGroup} capacity (min/max/desired) to that of ${activeGroup}\" \naws autoscaling update-auto-scaling-group --auto-scaling-group-name ${newActiveGroup} \\ \n  --min-size ${activeMin} --max-size ${activeMax} --desired-capacity ${activeDesired} \n\n```", "```\nwait_for_instances ${activeDesired} \n\n```", "```\ntecho \">>> Checking error metrics\" \nsleep 5 \ndoRollback=true \n${doRollback} && rollback \"${asgInstances[*]}\"\n```", "```\ntecho \">>> Reducing ${activeGroup} size to 0\" \naws autoscaling update-auto-scaling-group --auto-scaling-group-name ${activeGroup} \\ \n  --min-size 0 --max-size 0 --desired-capacity 0 \n\n```", "```\ntecho \">>> Detaching ${elbName} from ${activeGroup}\" \naws autoscaling detach-load-balancers --auto-scaling-group-name ${activeGroup} \\ \n  --load-balancer-names ${elbName} \n\n```"]