- en: '*Chapter 8*: Continuous Delivery Pipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：持续交付流水线'
- en: In this chapter, we will focus on the missing parts of the final pipeline, which are
    the environments and infrastructure, application versioning, and non-functional
    testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将重点讨论最终流水线中缺失的部分——即环境和基础设施、应用程序版本管理以及非功能性测试。
- en: 'We will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Environments and infrastructure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境和基础设施
- en: Non-functional testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性测试
- en: Application versioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序版本管理
- en: Completing the continuous delivery pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成持续交付流水线
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow this chapter, you''ll need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要以下资源：
- en: A Jenkins instance (with Java 8+, Docker, and `kubectl` installed on your Jenkins
    agents)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Jenkins 实例（在 Jenkins 代理上安装了 Java 8+、Docker 和 `kubectl`）
- en: A Docker registry (for example, an account on Docker Hub)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 注册表（例如，Docker Hub 上的帐户）
- en: Two Kubernetes clusters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 Kubernetes 集群
- en: All the examples and solutions for the exercises in this chapter can be found
    on GitHub at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例和练习解决方案都可以在 GitHub 上找到，链接：[https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter08)。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3JeyQ1X](https://bit.ly/3JeyQ1X).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 Code in Action 视频可以在以下链接查看：[https://bit.ly/3JeyQ1X](https://bit.ly/3JeyQ1X)。
- en: Environments and infrastructure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境和基础设施
- en: 'So far, we have deployed our applications to some servers – that is, Docker
    hosts, Kubernetes clusters, and pure Ubuntu servers (in the case of Ansible).
    However, when we think more deeply about the **continuous delivery** (**CD**)
    process (or the software delivery process in general), we need to logically group
    our resources. There are two main reasons why this is important:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将应用程序部署到一些服务器——也就是 Docker 主机、Kubernetes 集群和纯 Ubuntu 服务器（在 Ansible 的情况下）。然而，当我们深入思考
    **持续交付**（**CD**）过程（或者一般的软件交付过程）时，我们需要逻辑地将资源进行分组。这一点很重要，主要有两个原因：
- en: The physical location of machines matters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器的物理位置很重要
- en: No testing should be done on the production machines
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应在生产机器上进行测试
- en: Taking these facts into consideration, in this section, we will discuss different types of
    environments, their role in the CD process, and the security aspect of our infrastructure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些事实，在本节中，我们将讨论不同类型的环境，它们在 CD 过程中的角色，以及我们的基础设施的安全性方面。
- en: Types of environments
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境类型
- en: There are four common environment types – **production**, **staging**, **QA** (testing),
    and **development**. Let's discuss each of them one by one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种常见的环境类型——**生产**、**预发布**、**QA**（测试）和 **开发**。我们将逐一讨论它们。
- en: Production
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产
- en: The production environment is the environment that is used by the end user.
    It exists in every company and is the most important environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境是终端用户使用的环境。它存在于每个公司中，并且是最重要的环境。
- en: 'The following diagram shows how most production environments are organized:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了大多数生产环境的组织方式：
- en: '![Figure 8.1 – Production environment'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 生产环境](img/B18223_08_01.jpg)'
- en: '](img/B18223_08_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_08_01.jpg)'
- en: Figure 8.1 – Production environment
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 生产环境
- en: Users access the service through the load balancer, which chooses the machine.
    If the application is released in multiple physical locations, then the (first)
    device is usually a DNS-based geographic load balancer. In each location, we have
    a cluster of servers. If we use Docker and Kubernetes, for example, this means
    that in each location, we have at least one Kubernetes cluster.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过负载均衡器访问服务，负载均衡器选择机器。如果应用程序发布在多个物理位置，则（第一个）设备通常是基于 DNS 的地理负载均衡器。在每个位置，我们都有一个服务器集群。例如，如果我们使用
    Docker 和 Kubernetes，这意味着在每个位置，我们至少有一个 Kubernetes 集群。
- en: The physical location of machines matters because the request-response time
    can differ significantly, depending on the physical distance. Moreover, the database
    and other dependent services should be located on a machine that is close to where
    the service is deployed. What's even more important is that the database should
    be sharded in a way that minimizes the replication overhead between different
    locations; otherwise, we may end up waiting for the databases to reach a consensus
    between their instances, which will be located far away from each other. More
    details on the physical aspects are beyond the scope of this book, but it's important
    to remember that Docker and Kubernetes themselves do not solve this problem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 机器的物理位置很重要，因为请求-响应时间会因物理距离的不同而有显著差异。此外，数据库和其他依赖服务应部署在接近服务所在机器的地方。更重要的是，数据库应该按分片方式进行划分，以最小化不同地点之间的复制开销；否则，我们可能会陷入等待数据库在不同实例间达成一致的情况，而这些实例可能相距较远。关于物理方面的更多细节超出了本书的范围，但需要记住的是，Docker和Kubernetes本身并不能解决这个问题。
- en: Information
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Containerization and virtualization allow you to think about servers as infinite
    resources; however, some physical aspects such as location are still relevant.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化和虚拟化使你可以将服务器视为无限资源；然而，某些物理方面，如位置，仍然是相关的。
- en: Staging
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试环境
- en: The staging environment is where the release candidate is deployed to perform
    the final tests before going live. Ideally, this environment is a mirror of the
    production environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境是部署发布候选版本的地方，用于在正式上线前进行最终测试。理想情况下，这个环境应该是生产环境的镜像。
- en: 'The following diagram shows what such an environment should look like in the
    context of the delivery process:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了在交付过程中，这种环境应该是什么样子的：
- en: '![Figure 8.2 – Staging environment'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 测试环境]'
- en: '](img/B18223_08_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_08_02.jpg)'
- en: Figure 8.2 – Staging environment
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 测试环境
- en: Note that the staging environment is a clone of the production environment.
    If the application is deployed in multiple locations, then the staging environment
    should also have multiple locations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试环境是生产环境的克隆。如果应用部署在多个地点，那么测试环境也应该有多个地点。
- en: In the CD process, all automated acceptance tests (both functional and non-functional)
    are run against this environment. While most functional tests don't usually require
    identical production-like infrastructure, in the case of non-functional (especially
    performance) tests, it is a must.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付（CD）过程中，所有自动化的验收测试（包括功能性和非功能性测试）都会在这个环境中运行。虽然大多数功能性测试通常不要求与生产环境完全相同的基础设施，但在非功能性测试（尤其是性能测试）的情况下，这一点是必须的。
- en: To save costs, it's not uncommon for the staging infrastructure to differ from
    the production environment (usually, it contains fewer machines). Such an approach
    can, however, lead to many production issues. *Michael T. Nygard*, in *Release
    It! Design and Deploy Production-Ready Software*, gives an example of a real-life
    scenario in which fewer machines were used in the staging environment than in
    production.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省成本，测试基础设施与生产环境不同并不罕见（通常包含较少的机器）。然而，这种做法可能导致许多生产问题。*Michael T. Nygard* 在《Release
    It! 设计与部署生产就绪软件》中举了一个真实案例，说明测试环境中使用的机器比生产环境中的要少。
- en: 'The story goes like this: in one company, the system was stable until a certain code
    change caused the production environment to become extremely slow, even though
    all the stress tests were passed. *How was this possible?* This happened because
    there was a synchronization point where each server communicated with the others.
    In the case of the staging environment, there was one server, so there was no
    blocker. In production, however, there were many servers, which resulted in servers
    waiting for each other. This example is just the tip of the iceberg, and many
    production issues may fail to be tested by acceptance tests if the staging environment
    is different from the production environment.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 故事是这样的：在某家公司，系统在某次代码变更后变得极其缓慢，尽管所有压力测试都通过了。*这是怎么可能的？* 这种情况发生的原因是有一个同步点，其中每个服务器都需要与其他服务器通信。在测试环境中，只有一台服务器，因此没有阻塞。但在生产环境中，服务器数量很多，导致服务器之间相互等待。这个例子只是冰山一角，如果测试环境与生产环境不同，很多生产问题可能无法通过验收测试。
- en: QA
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QA
- en: 'The QA environment (also called the testing environment) is intended for the
    QA team to perform exploratory testing and for external applications (that depend
    on our service) to perform integration testing. The use cases and the infrastructure
    of the QA environment are shown in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: QA环境（也叫做测试环境）是为QA团队执行探索性测试以及外部应用程序（依赖我们的服务）进行集成测试而设计的。QA环境的用例和基础设施如以下图所示：
- en: '![Figure 8.3 – QA environment'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – QA环境'
- en: '](img/B18223_08_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_08_03.jpg)'
- en: Figure 8.3 – QA environment
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – QA环境
- en: While staging does not need to be stable (in the case of CD, it is changed after
    every code change that's committed to the repository), the QA instance needs to
    provide a certain amount of stability and expose the same (or backward-compatible)
    API as the production environment. In contrast to the staging environment, the
    infrastructure can be different from that of the production environment since
    its purpose is not to ensure that the release candidate works properly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然暂存环境不需要保持稳定（在CD情况下，它会在每次提交到代码仓库后进行更改），但QA实例需要提供一定的稳定性，并暴露与生产环境相同（或向后兼容的）API。与暂存环境不同，基础设施可以与生产环境不同，因为它的目的是不保证发布候选版本的正常运行。
- en: A very common case is to allocate fewer machines (for example, only from one
    location) to the QA instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的情况是将较少的机器（例如，仅来自一个位置）分配给QA实例。
- en: Information
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Deploying to the QA environment is usually done in a separate pipeline so that
    it's independent of the automatic release process. Such an approach is convenient
    because the QA instance has a different life cycle than the production one (for
    instance, the QA team may want to perform testing on the experimental code branched
    from the trunk).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到QA环境通常是在单独的流水线中完成的，使其独立于自动发布流程。这种方法很方便，因为QA实例的生命周期与生产实例不同（例如，QA团队可能希望在从主干分出的实验代码上进行测试）。
- en: Development
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发
- en: 'The development environment can be created as a shared server for all developers,
    or each developer can have a development environment for themselves. The following
    is a simple diagram of this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境可以作为所有开发者共享的服务器，或者每个开发者可以拥有自己的开发环境。以下是一个简单的示意图：
- en: '![Figure 8.4 – Development environment'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 开发环境'
- en: '](img/B18223_08_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_08_04.jpg)'
- en: Figure 8.4 – Development environment
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 开发环境
- en: The development environment always contains the latest version of the code.
    It is used to enable integration between developers and can be treated the same
    way as the QA environment. However, it is used by developers, not QAs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境始终包含最新版本的代码。它用于实现开发者之间的集成，可以与QA环境一样对待。然而，它是开发者使用的，而不是QA人员使用的。
- en: Now that we've looked at all the environments, let's see how they fit into the
    CD process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了所有环境，接下来看看它们如何适应CD流程。
- en: Environments in continuous delivery
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付中的环境
- en: In the CD process, the staging environment is indispensable. In some very rare
    cases, when performance is not important and the project doesn't have many dependencies,
    we can perform the acceptance tests on the local (development) Docker host, but
    that should be an exception, not a rule. In such cases, we always risk some production
    issues occurring that are related to the environment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在CD流程中，暂存环境是不可或缺的。在一些极为少见的情况下，当性能不是关键且项目没有太多依赖时，我们可以在本地（开发）Docker主机上进行验收测试，但这应该是一个例外，而不是常规。在这种情况下，我们始终面临环境相关的生产问题的风险。
- en: The other environments are usually not important in terms of CD. If we would
    like to deploy to the QA or development environment with every commit, then we
    can create separate pipelines for that purpose (being careful not to obscure the
    main release pipeline). In many cases, deployment to the QA environment is triggered
    manually since it has a different life cycle from production.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其他环境通常在CD中不重要。如果我们希望每次提交后都部署到QA或开发环境，那么我们可以为此目的创建单独的流水线（小心不要遮蔽主发布流水线）。在许多情况下，部署到QA环境是手动触发的，因为它与生产环境的生命周期不同。
- en: Securing environments
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境安全
- en: All environments need to be well secured – that's clear. What's even more obvious
    is that the most important requirement is to keep the production environment secure
    because our business depends on it, and the consequences of any security flaw
    can be the most serious.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境都需要得到充分的安全保护——这是显而易见的。更为显而易见的是，最重要的要求是保持生产环境的安全，因为我们的业务依赖于它，任何安全漏洞的后果都可能是最严重的。
- en: Information
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Security is a broad topic. In this section, we will only focus on the topics
    related to the CD process. Nevertheless, setting up a complete server infrastructure
    requires much more security knowledge.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一个广泛的话题。本节我们将专注于与 CD 过程相关的主题。然而，搭建完整的服务器基础设施需要更多的安全知识。
- en: In the CD process, the Jenkins agent must have access to servers so that it
    can deploy the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CD 过程中，Jenkins 代理必须能够访问服务器，以便它能够部署应用程序。
- en: 'There are different approaches for providing agents with the server''s credentials:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方式为代理提供服务器的凭证：
- en: '**Put an SSH key in the agent**: If we don''t use dynamic Docker slave provisioning,
    then we can configure Jenkins agent machines so that they contain private SSH
    keys.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 SSH 密钥放入代理中**：如果我们不使用动态 Docker 从节点配置，那么可以配置 Jenkins 代理机器，使其包含私有的 SSH 密钥。'
- en: '**Put an SSH key in the agent image**: If we use dynamic Docker slave provisioning,
    we can add the SSH private key to the Docker agent image; however, this creates
    a possible security hole since anyone who has access to that image would have
    access to the production servers.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 SSH 密钥放入代理镜像中**：如果我们使用动态 Docker 从节点配置，我们可以将 SSH 私钥添加到 Docker 代理镜像中；然而，这样会产生一个可能的安全漏洞，因为任何可以访问该镜像的人都将可以访问生产服务器。'
- en: '**Use Jenkins credentials**: We can configure Jenkins to store credentials
    and use them in the pipeline.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Jenkins 凭证**：我们可以配置 Jenkins 存储凭证并在流水线中使用它们。'
- en: '**Copy to the slave Jenkins plugin**: We can copy the SSH key dynamically into
    the slave while starting the Jenkins build.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制到从节点 Jenkins 插件**：我们可以在启动 Jenkins 构建时将 SSH 密钥动态复制到从节点中。'
- en: Each solution has some advantages and drawbacks. While using any of them, we
    have to take extra caution since, when an agent has access to the production environment,
    anyone breaking into that agent can break into the production environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每种解决方案都有一些优缺点。使用任何一种时，我们都必须格外小心，因为当代理可以访问生产环境时，任何进入该代理的人都可能侵入生产环境。
- en: The riskiest solution is to put SSH private keys into the Jenkins agent image
    since everywhere the image is stored (the Docker registry or Docker host within
    Jenkins) needs to be well secured.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最具风险的解决方案是将 SSH 私钥放入 Jenkins 代理镜像中，因为镜像存储的每个地方（无论是 Docker 注册表还是 Jenkins 内部的
    Docker 主机）都需要得到良好的安全保护。
- en: Now that we've covered the infrastructure, let's look at a topic that we haven't
    covered yet – non-functional testing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了基础设施，接下来让我们看一个我们还没有涉及的话题——非功能性测试。
- en: Non-functional testing
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能性测试
- en: We learned a lot about functional requirements and automated acceptance testing
    in the previous chapters. *But what should we do with non-functional requirements?* Or
    even more challenging, *what if there are no requirements?* *Should we skip them
    in the CD process?* We will answer these questions throughout this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中学到了很多关于功能性需求和自动化验收测试的知识。*但是我们应该如何处理非功能性需求呢？* 或者更具挑战性的是，*如果没有需求呢？* *我们是否应该在
    CD 过程中跳过它们？* 我们将在本节中回答这些问题。
- en: Non-functional aspects of the software are always important because they can
    cause a significant risk to how the system operates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的非功能性方面始终很重要，因为它们可能会对系统的运行造成重大风险。
- en: For example, many applications fail because they are unable to bear the load
    of a sudden increase in the number of users. In one of his books, *Jakob Nielsen* writes
    about the user experience that *1 second is about the limit for the user's flow
    of thought to stay uninterrupted*. Imagine that our system, with its growing load,
    starts to exceed that limit. Users may stop using the service just because of
    its performance. Taking this into consideration, non-functional testing is just
    as important as functional testing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多应用程序失败是因为它们无法承受用户数量突然增加的负载。在他的某本书中，*Jakob Nielsen* 写到关于用户体验的观点，*1 秒钟大约是用户思维流畅不被打断的极限*。想象一下，如果我们的系统在负载不断增加时，开始超出这个极限，用户可能因为性能问题而停止使用该服务。考虑到这一点，非功能性测试和功能性测试同样重要。
- en: 'To cut a long story short, we should always take the following steps for non-functional
    testing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，我们应该始终采取以下步骤进行非功能性测试：
- en: Decide which non-functional aspects are crucial to our business.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪些非功能方面对我们的业务至关重要。
- en: 'For each of them, we must do the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一个测试，我们都需要做以下几点：
- en: Specify the tests the same way we did for acceptance testing
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像我们为验收测试所做的那样指定测试
- en: Add a stage to the CD pipeline (after acceptance testing, while the application
    is still deployed on the staging environment)
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CD管道中添加一个阶段（在验收测试后，应用程序仍部署在预发布环境中）
- en: The application comes to the release stage only after all the non-functional
    tests have passed.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序只有在所有非功能测试通过后，才会进入发布阶段。
- en: Irrespective of the type of non-functional test, the idea is always the same.
    The approach, however, may differ slightly. Let's examine different test types
    and the challenges they pose.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种类型的非功能测试，基本思想总是相同的。然而，方法可能略有不同。我们来看看不同测试类型及其带来的挑战。
- en: Types of non-functional test
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能测试的类型
- en: Functional tests are always related to the same aspect – the behavior of the
    system. In contrast, non-functional tests are concerned with a lot of different
    aspects. Let's discuss the most common system properties and how they can be tested
    inside the CD process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试始终与同一方面相关——系统的行为。相反，非功能测试则关注许多不同的方面。我们来讨论一些最常见的系统属性以及如何在CD过程中进行测试。
- en: Performance testing
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests are the most widely used non-functional tests. They measure
    the responsiveness and stability of the system. The simplest performance test
    we can create is one that sends a request to the web service and measures its **round-trip
    time** (**RTT**).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试是最常用的非功能测试。它们测量系统的响应性和稳定性。我们可以创建的最简单性能测试是向**Web**服务发送请求并测量其**往返时间**（**RTT**）。
- en: There are different definitions of performance testing. They are often meant
    to include load, stress, and scalability testing. Sometimes, they are also described
    as white-box tests. In this book, we will define performance testing as the most
    basic form of black-box test to measure the latency of the system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试有不同的定义。它们通常包括负载、压力和可扩展性测试。有时，它们也被描述为白盒测试。在本书中，我们将性能测试定义为一种最基本的黑盒测试形式，用来衡量系统的延迟。
- en: For performance testing, we can use a dedicated framework (for Java, the most
    popular is JMeter) or just use the same tool we used for our acceptance tests.
    A simple performance test is usually added as a pipeline stage, just after the
    acceptance tests. Such a test should fail if the RTT exceeds the given limit and
    it detects bugs that slow down our service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能测试，我们可以使用专用框架（对于Java，最流行的是JMeter），或者仅仅使用我们在验收测试中使用的相同工具。简单的性能测试通常作为管道阶段添加，就在验收测试之后。这样的测试应该在RTT超出给定限制时失败，并且可以发现导致我们服务变慢的错误。
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The JMeter plugin for Jenkins can show performance trends over time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins的JMeter插件可以显示性能趋势随时间的变化。
- en: Load testing
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载测试
- en: Load tests are used to check how the system functions when there are a lot of
    concurrent requests. While a system can be very fast with a single request, this
    doesn't mean that it works fast enough with 1,000 requests being worked on at
    the same time. During load testing, we measure the average request-response time
    of many concurrent calls, which are usually performed from many machines. Load
    testing is a very common QA phase in the release cycle. To automate it, we can
    use the same tools that we do when conducting a simple performance test; however,
    in the case of larger systems, we may need a separate client environment to perform
    a large number of concurrent requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试用于检查在大量并发请求时系统的表现。虽然系统在处理单个请求时可能非常快速，但这并不意味着它在同时处理1,000个请求时依然足够快。在负载测试中，我们会测量多个并发调用的平均请求响应时间，这些调用通常会从多台机器上进行。负载测试是发布周期中非常常见的QA阶段。为了自动化这一过程，我们可以使用与简单性能测试时相同的工具；但是在面对更大规模的系统时，我们可能需要一个独立的客户端环境来执行大量的并发请求。
- en: Stress testing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压力测试
- en: Stress testing, also called **capacity testing** or **throughput testing**,
    is a test that determines how many concurrent users can access our service. It
    may sound the same as load testing, but in the case of load testing, we set the
    number of concurrent users (throughput) to a given number, check the response time
    (latency), and make the build fail if that limit is exceeded. During stress testing,
    however, we keep the latency constant and increase the throughput to discover
    the maximum number of concurrent calls when the system is still operable. Therefore,
    the result of a stress test may be a notification that our system can handle 10,000
    concurrent users, which helps us prepare for the peak usage time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试，也叫**容量测试**或**吞吐量测试**，是一种测试，旨在确定有多少并发用户能够访问我们的服务。它听起来可能和负载测试相似，但在负载测试中，我们会将并发用户数（吞吐量）设置为给定的数值，检查响应时间（延迟），并在超过这个限制时使构建失败。然而，在压力测试中，我们保持延迟不变，并增加吞吐量，以发现系统仍然可以操作的最大并发调用数。因此，压力测试的结果可能是一个通知，告知我们的系统可以处理10,000个并发用户，这有助于我们为高峰使用期做准备。
- en: Stress testing is not well suited for the CD process because it requires long
    tests with an increasing number of concurrent requests. It should be prepared
    as a separate script of a separate Jenkins pipeline and triggered on demand when
    we know that the code change can cause performance issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试不太适合用于CD流程，因为它需要长时间的测试，并且并发请求数量不断增加。它应该作为一个单独的脚本，在一个独立的Jenkins管道中准备，并在我们知道代码更改可能会引发性能问题时按需触发。
- en: Scalability testing
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性测试
- en: Scalability testing explains how latency and throughput change when we add more
    servers or services. The perfect characteristic would be linear, which means that
    if we have one server and the average request-response time is 500 ms when it's
    used by 100 parallel users, then adding another server would keep the response
    time the same and allow us to add another 100 parallel users. In reality, it's
    often hard to achieve this because of the need to keep data consistent between
    servers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性测试解释了当我们增加更多的服务器或服务时，延迟和吞吐量如何变化。理想的特征是线性的，这意味着如果我们有一台服务器，且在100个并发用户使用时，平均请求-响应时间为500毫秒，那么增加另一台服务器应该能保持响应时间不变，并且允许我们再增加100个并发用户。实际上，由于需要在服务器之间保持数据一致性，这通常很难实现。
- en: Scalability testing should be automated and provide a graph that shows the relationship
    between the number of machines and the number of concurrent users. Such data helps
    determine the limits of the system and the point at which adding more machines
    doesn't help.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性测试应该实现自动化，并提供一张图表，显示机器数量与并发用户数量之间的关系。这些数据有助于确定系统的极限，以及何时增加更多机器不再有效。
- en: Scalability tests, similar to stress tests, are hard to put into the CD pipeline
    and should be kept separate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性测试，与压力测试类似，也很难融入CD管道，应该单独保持。
- en: Soak testing
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长期测试
- en: Soak tests, also called **endurance tests** or **longevity tests**, run the system
    for a long time to see if the performance drops after a certain period. They detect
    memory leaks and stability issues. Since they require a system to run for a long
    time, it doesn't make sense to run them inside the CD pipeline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试，也称为**耐力测试**或**长期测试**，是将系统运行长时间，查看在一定时间后性能是否下降。它们能检测内存泄漏和稳定性问题。由于它们需要系统长时间运行，因此在持续集成（CD）管道内运行并不合理。
- en: Security testing
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全测试
- en: Security testing deals with different aspects related to security mechanisms
    and data protection. Some security aspects are purely functional requirements,
    such as authentication, authorization, and role assignment. These elements should
    be checked the same way as any other functional requirement – during the acceptance
    test phase. Other security aspects are non-functional; for example, the system
    should be protected against SQL injection. No client would probably specify such
    a requirement, but it's implicit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试处理与安全机制和数据保护相关的不同方面。一些安全方面是纯粹的功能性需求，如认证、授权和角色分配。这些元素应该像其他功能需求一样，在验收测试阶段进行检查。其他安全方面是非功能性的；例如，系统应防止SQL注入。客户可能不会明确指定这样的需求，但它是隐含的。
- en: Security tests should be included in the CD process as a pipeline stage. They
    can be written using the same frameworks as the acceptance tests or with dedicated security
    testing frameworks – for example, **behavior-driven development** (**BDD**) security.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试应该作为持续交付过程中的一个管道阶段。它们可以使用与验收测试相同的框架编写，也可以使用专门的安全测试框架，例如 **行为驱动开发**（**BDD**）安全性。
- en: Information
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Security should also always be a part of the explanatory testing process, in
    which testers and security experts detect security holes and add new testing scenarios.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性也应该始终是解释性测试过程的一部分，在这个过程中，测试人员和安全专家会发现安全漏洞并添加新的测试场景。
- en: Maintainability testing
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可维护性测试
- en: Maintainability tests explain how simple a system is to maintain. In other words,
    they judge code quality. We have already described stages in the commit phase
    that check test coverage and perform static code analysis. The Sonar tool can
    also provide an overview of the code quality and the technical debt.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性测试解释了一个系统的维护简单性。换句话说，它们评估代码质量。我们已经在提交阶段描述了检查测试覆盖率和执行静态代码分析的步骤。Sonar 工具也可以提供代码质量和技术债务的概览。
- en: Recovery testing
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复测试
- en: Recovery testing is a technique that's used to determine how quickly the system
    can recover after it's crashed because of a software or hardware failure. The
    best case would be if the system doesn't fail at all, even if a part of its service
    is down. Some companies even perform production failures on purpose to check if
    they can survive a disaster. The most well-known example is Netflix and their
    Chaos Monkey tool, which randomly terminates instances of the production environment.
    Such an approach forces engineers to write code that makes systems resilient to
    failures.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复测试是一种用于确定系统在因软件或硬件故障崩溃后能够多快恢复的技术。最理想的情况是，如果系统根本不崩溃，即使其一部分服务宕机。一些公司甚至故意进行生产故障测试，检查它们是否能在灾难中生还。最著名的例子是
    Netflix 和他们的 Chaos Monkey 工具，该工具会随机终止生产环境中的实例。这种方法迫使工程师编写能让系统在故障时具有恢复力的代码。
- en: Recovery testing is not part of the CD process, but rather a periodic event
    that checks its overall health.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复测试不是持续交付过程的一部分，而是定期检查系统整体健康状况的事件。
- en: Tip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can read more about Chaos Monkey at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey)了解更多关于
    Chaos Monkey 的信息。
- en: Many more nonfunctional test types are closer to or further from the code and
    the CD process. Some of them relate to the law, such as compliance testing, while
    others are related to documentation or internationalization. There's also usability
    testing and volume testing (which check whether the system behaves well when it's
    handling large amounts of data). Most of these tests, however, have no part in
    the CD process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非功能性测试类型与代码和持续交付（CD）过程的关系更近或更远。有些与法律相关，例如合规性测试，而其他则与文档或国际化相关。还有可用性测试和容量测试（它检查系统在处理大量数据时的表现）。然而，这些测试中的大多数与持续交付过程无关。
- en: Non-functional challenges
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性挑战
- en: 'Non-functional aspects pose new challenges to software development and delivery. Let''s
    go over some of them now:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性方面给软件开发和交付带来了新的挑战。让我们现在来看看其中的一些：
- en: '**Long test runs**: The tests can take a long time to run and may need a special
    execution environment.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长时间的测试运行**：测试可能需要很长时间才能完成，并可能需要特殊的执行环境。'
- en: '**Incremental nature**: It''s hard to set the limit value when the test should
    fail (unless the SLA is well-defined). Even if the edge limit is set, the application
    would probably incrementally approach the limit. In most cases, no code changes
    will cause the test to fail.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进性质**：很难设定何时测试应当失败的限制值（除非 SLA 定义得很好）。即使设定了边界值，应用程序也可能会逐步接近该限制。在大多数情况下，代码更改不会导致测试失败。'
- en: '**Vague requirements**: Users usually don''t have much input when it comes
    to non-functional requirements. They may provide some guidelines concerning the
    request-response time or the number of users; however, they probably won''t know
    much about maintainability, security, or scalability.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊的需求**：用户在非功能性需求方面通常没有太多输入。他们可能会提供一些关于请求-响应时间或用户数量的指导，但他们可能不了解可维护性、安全性或可扩展性。'
- en: '**Multiplicity**: There are a lot of different non-functional tests and choosing
    which should be implemented means making some compromises.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多样性**：有很多不同的非功能性测试，选择应该实施哪些测试意味着需要做出一些妥协。'
- en: 'The best approach to address non-functional aspects is to perform the following
    steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决非功能性方面的最佳方法是执行以下步骤：
- en: Make a list of all the non-functional test types.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有非功能性测试类型。
- en: 'Explicitly cross out the tests you don''t need for your system. There may be
    a lot of reasons you don''t need one kind of test, such as the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确划掉不需要的测试。你可能不需要某种测试的原因有很多种，例如以下几种：
- en: The service is super small, and a simple performance test is enough.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务非常小，一个简单的性能测试就足够了。
- en: The system is internal only and exclusively available for read-only purposes,
    so it may not need any security checks.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该系统仅限内部使用，且仅供只读，因此可能不需要任何安全检查。
- en: The system is designed for one machine only and does not need any scaling.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该系统仅为单台机器设计，无需进行扩展。
- en: The cost of creating certain tests is too high.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建某些测试的成本太高。
- en: 'Split your tests into two groups:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的测试分成两组：
- en: '**Continuous Delivery**: It is possible to add it to the pipeline.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付**：可以将其添加到流水线中。'
- en: '**Analysis**: It is not possible to add it to the pipeline because of its execution
    time, nature, or associated cost.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：由于其执行时间、性质或相关成本，无法将其添加到流水线中。'
- en: For the CD group, implement the related pipeline stages.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 CD 组，实现相关的流水线阶段。
- en: 'For the analysis group, do the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于分析组，请执行以下操作：
- en: Create automated tests
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自动化测试
- en: Schedule when they should be run
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排它们应该运行的时间
- en: Schedule meetings to discuss their results and take action
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排会议讨论它们的结果并采取行动
- en: Tip
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: A very good approach is to have a nightly build with the long tests that don't
    fit the CD pipeline. Then, it's possible to schedule a weekly meeting to monitor
    and analyze the trends of system performance.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种非常好的方法是进行夜间构建，包含那些不适合 CD 流水线的长时间测试。然后，可以安排每周的会议来监控和分析系统性能的趋势。
- en: As we can see, there are many types of non-functional tests, and they pose additional
    challenges to the delivery process. Nevertheless, for the sake of the stability
    of our system, these tests should never be skipped. The technical implementation
    differs based on the test's type, but in most cases, they can be implemented similarly
    to functional acceptance tests and should be run against the staging environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，非功能性测试有很多类型，它们给交付过程带来了额外的挑战。然而，为了系统的稳定性，这些测试绝不应该被跳过。技术实现会根据测试类型有所不同，但在大多数情况下，它们可以像功能性验收测试一样实现，并应在预发布环境中运行。
- en: Tip
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you're interested in the topic of non-functional testing, system properties,
    and system stability, then read the book *Release It!*, by *Michael T. Nygard*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对非功能性测试、系统属性和系统稳定性感兴趣，可以阅读*Michael T. Nygard*的书籍《Release It!》。
- en: Now that we've discussed the nonfunctional testing, let's look at another aspect
    that we haven't looked at in too much detail – application versioning.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了非功能性测试，让我们看一下另一个方面——应用程序版本控制，这是我们之前没有详细讨论过的。
- en: Application versioning
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序版本控制
- en: 'So far, throughout every Jenkins build, we have created a new Docker image,
    pushed it into the Docker registry, and used the *latest* version throughout the
    process. However, such a solution has at least three disadvantages:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在每次 Jenkins 构建过程中，我们都会创建一个新的 Docker 镜像，将其推送到 Docker 注册中心，并在整个过程中使用*最新*版本。然而，这种解决方案至少有三个缺点：
- en: If, during the Jenkins build, after the acceptance tests, someone pushes a new
    version of the image, then we can end up releasing the untested version.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在 Jenkins 构建过程中，在验收测试后，有人推送了新的镜像版本，那么我们可能会发布未经测试的版本。
- en: We always push an image that's named in the same way so that, effectively, it
    is overwritten in the Docker registry.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们总是推送一个以相同方式命名的镜像，因此它实际上会在 Docker 注册中心被覆盖。
- en: It's very hard to manage images without versions just by using their hashed-style
    IDs.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用它们的哈希式 ID 来管理没有版本的镜像非常困难。
- en: '*What is the recommended way of managing Docker image versions alongside the
    CD process?* In this section, we''ll look at the different versioning strategies
    and learn how to create versions in the Jenkins pipeline.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理 Docker 镜像版本与 CD 流程的推荐方法是什么？* 在本节中，我们将探讨不同的版本控制策略，并学习如何在 Jenkins 流水线中创建版本。'
- en: Versioning strategies
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制策略
- en: There are different ways to version applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以对应用程序进行版本控制。
- en: 'Let''s discuss the most popular solutions that can be applied alongside the
    CD process (when each commit creates a new version):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论可以与 CD 流程一起应用的最流行的解决方案（当每次提交都会创建一个新版本时）：
- en: '`x.y.z`). This method requires a commit to be made to the repository by Jenkins
    to increase the current version number, which is usually stored in the build file.
    This solution is well supported by Maven, Gradle, and other build tools. The identifier
    usually consists of three numbers:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x.y.z`）。此方法要求Jenkins向代码库提交更改，以增加当前的版本号，通常该版本号存储在构建文件中。此解决方案得到了Maven、Gradle和其他构建工具的广泛支持。标识符通常由三个数字组成：'
- en: '`x`: This is the major version; the software does not need to be backward compatible
    when this version is incremented.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：这是主版本号；当此版本号增加时，软件不需要向后兼容。'
- en: '`y`: This is the minor version; the software needs to be backward compatible
    when the version is incremented.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：这是次版本号；当此版本号增加时，软件需要向后兼容。'
- en: '`z`: This is the build number (also called the **patch version**); this is
    sometimes also considered as a backward-and forward-compatible change.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z`：这是构建号（也称为**修补版本**）；有时也将其视为向后兼容和向前兼容的更改。'
- en: '**Timestamp**: Using the date and time of the build for the application version
    is less verbose than sequential numbers, but it''s very convenient in the case
    of the CD process because it does not require Jenkins to commit it back to the
    repository.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**：使用构建的日期和时间作为应用程序版本，比顺序编号更简洁，但在CD过程中非常方便，因为它不需要Jenkins将其提交回代码库。'
- en: '**Hash**: A randomly generated hash version shares the benefit of the date-time
    and is probably the simplest solution possible. The drawback is that it''s not
    possible to look at two versions and tell which is the latest one.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希**：一个随机生成的哈希版本与日期时间的优势相似，并且可能是最简单的解决方案。缺点是无法通过查看两个版本来判断哪个是最新版本。'
- en: '**Mixed**: There are many variations of the solutions described earlier – for
    example, the major and minor versions with the date-time.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：如前所述，有许多解决方案的变体——例如，主版本号和次版本号与日期时间结合使用。'
- en: All of these solutions can be used alongside the CD process. Semantic versioning,
    however, requires a commit to be made to the repository from the build execution
    so that the version is increased in the source code repository.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解决方案都可以与CD过程一起使用。然而，语义版本控制需要在构建执行过程中向代码库提交更改，以便在源代码库中增加版本号。
- en: Information
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Maven (and other build tools) popularized version snapshotting, which added
    a `SNAPSHOT` suffix to the versions that haven't been released and have been kept
    just for the development process. Since CD means releasing every change, there
    are no snapshots.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Maven（以及其他构建工具）推广了版本快照，它为尚未发布并且仅用于开发过程的版本添加了`SNAPSHOT`后缀。由于CD意味着发布每一次更改，因此没有快照。
- en: Now, let's learn how to adapt versioning in the Jenkins pipeline.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在Jenkins流水线中适配版本控制。
- en: Versioning in the Jenkins pipeline
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins流水线中的版本控制
- en: As we mentioned earlier, there are different possibilities when it comes to
    using software versioning, and each of them can be implemented in Jenkins.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用软件版本控制时有不同的选择，每种方式都可以在Jenkins中实现。
- en: As an example, let's use the date-time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，使用日期和时间。
- en: Information
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: To use the timestamp information from Jenkins, you need to install the Build
    Timestamp plugin and set the timestamp format in the Jenkins configuration under
    `yyyyMMdd-HHmm`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用来自Jenkins的时间戳信息，您需要安装Build Timestamp插件，并在Jenkins配置中设置时间戳格式为`yyyyMMdd-HHmm`。
- en: Everywhere we use the Docker image, we need to add the `${BUILD_TIMESTAMP}`
    tag suffix.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Docker镜像的地方，我们需要添加`${BUILD_TIMESTAMP}`标签后缀。
- en: 'For example, the `Docker build` stage should look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Docker构建`阶段应该如下所示：
- en: '[PRE0]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After making these changes, when we run the Jenkins build, the image should
    be tagged with the timestamp's version in our Docker registry.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，当我们运行Jenkins构建时，镜像应该会使用时间戳的版本标签，并存储在我们的Docker注册表中。
- en: With versioning completed, we are finally ready to complete the CD pipeline.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制完成后，我们终于准备好完成CD流水线。
- en: Completing the continuous delivery pipeline
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成持续交付流水线
- en: Now that we've covered Ansible, environments, non-functional testing, and versioning,
    we are ready to extend the Jenkins pipeline and finalize a simple, but complete,
    CD pipeline.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了Ansible、环境、非功能性测试和版本控制，我们就可以扩展Jenkins流水线，并完成一个简单但完整的CD流水线。
- en: 'Follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Create the inventory of staging and production environments.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建预发布和生产环境的清单。
- en: Use version in the Kubernetes deployment.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes部署中使用版本。
- en: Use a remote Kubernetes cluster as the staging environment.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用远程 Kubernetes 集群作为 staging 环境。
- en: Update the acceptance tests so that they use the staging Kubernetes cluster.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新验收测试，以便它们使用 staging Kubernetes 集群。
- en: Release the application to the production environment.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序发布到生产环境。
- en: Add a smoke test that makes sure the application was released successfully.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个冒烟测试，以确保应用程序已经成功发布。
- en: Let's start by creating an inventory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个清单开始。
- en: Inventory
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单
- en: We looked at the inventory file in the previous chapter while describing Ansible.
    To generalize this concept, an inventory contains a list of environments that
    describe how to access them. In this example, we'll use Kubernetes directly, so
    the Kubernetes configuration file, which is usually stored in `.kube/config`,
    will act as the inventory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们描述了 Ansible 时查看了清单文件。为了概括这个概念，清单包含了描述如何访问环境的列表。在这个例子中，我们将直接使用 Kubernetes，因此
    Kubernetes 配置文件，通常存储在 `.kube/config` 中，将作为清单使用。
- en: Information
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: As we explained in the previous chapter, depending on your needs, you may use
    `kubectl` directly or via Ansible or Terraform. These approaches are suitable
    for the CD pipeline.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中解释的，根据你的需求，你可以直接使用 `kubectl`，或者通过 Ansible 或 Terraform 来使用它。这些方法适用于
    CD 流水线。
- en: 'Let''s configure two Kubernetes clusters – `staging` and `production`. Your
    `.kube/config` file should look similar to the following one:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 配置两个 Kubernetes 集群 – `staging` 和 `production`。你的 `.kube/config` 文件应该类似于下面的示例：
- en: '[PRE1]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Kubernetes configuration stores the following information for each cluster:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 配置为每个集群存储以下信息：
- en: '`cluster`: The address of the cluster (Kubernetes master endpoint) and its
    CA certificate'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster`：集群的地址（Kubernetes 主节点端点）及其 CA 证书'
- en: '`context`: The binding of the cluster and user'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：集群和用户的绑定'
- en: '`user`: The authorization data to access the Kubernetes cluster'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：访问 Kubernetes 集群的授权数据'
- en: Tip
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: The simplest way to create two Kubernetes clusters is to use `kubectl` using
    `gcloud container clusters get-credentials`, and finally rename the cluster context
    with `kubectl config rename-context <original-context-name> staging`. Note that
    you may also need to create a GCP Firewall rule to allow traffic into your Kubernetes
    nodes.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建两个 Kubernetes 集群的最简单方法是使用 `kubectl` 和 `gcloud container clusters get-credentials`，最后通过
    `kubectl config rename-context <original-context-name> staging` 重命名集群上下文。注意，你可能还需要创建一个
    GCP 防火墙规则，以允许流量进入你的 Kubernetes 节点。
- en: You also need to make sure that the Kubernetes configuration is available on
    the Jenkins agent nodes. As we mentioned in the previous sections, think carefully
    about your security so that no unauthorized persons can access your environments
    via the Jenkins agent.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保 Kubernetes 配置在 Jenkins 代理节点上可用。正如我们在前面部分提到的，仔细考虑你的安全性，确保没有未经授权的人通过 Jenkins
    代理访问你的环境。
- en: Now that we've defined the inventory, we can prepare the Kubernetes deployment
    configuration so that it can work with application versioning.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了清单，可以准备 Kubernetes 部署配置，使其能够与应用程序版本管理一起工作。
- en: Versioning
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本管理
- en: 'Kubernetes YAML files are the same as what we defined in the previous chapters.
    The only difference is that we need to introduce a template variable for the application
    version. Let''s make one change in the `deployment.yaml` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes YAML 文件与我们在前几章中定义的相同。唯一的区别是，我们需要为应用程序版本引入一个模板变量。让我们在 `deployment.yaml`
    文件中做一个修改：
- en: '[PRE2]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we can fill the version in `Jenkinsfile`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `Jenkinsfile` 中填写版本：
- en: '[PRE3]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can change acceptance testing to use the remote staging environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改验收测试，使用远程的 staging 环境。
- en: The remote staging environment
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程 staging 环境
- en: Depending on our needs, we could test the application by running it on the local
    Docker host (as we did previously) or using the remote (and clustered) staging
    environment. The former solution is closer to what happens in production, so it
    can be considered a better one.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以通过在本地 Docker 主机上运行应用程序（如前所述）或使用远程（且集群化的）staging 环境来进行测试。前者的解决方案更接近生产环境，因此可以视为更好的选择。
- en: 'To do this, we need to change the command we use from `docker` to `kubectl`.
    Let''s modify the related part of our `Jenkinsfile`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要将使用的命令从 `docker` 改为 `kubectl`。让我们修改 `Jenkinsfile` 中的相关部分：
- en: '[PRE4]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we switched `kubectl` to use the `staging` context. Then, we deployed
    the Hazelcast server. Finally, we deployed `Calculator` into the Kubernetes server.
    At this point, we have a fully functional application in our staging environment.
    Let's see how we need to modify the acceptance testing stage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`kubectl`切换到`staging`上下文。然后，我们部署了Hazelcast服务器。最后，我们将`Calculator`部署到Kubernetes服务器上。此时，我们在staging环境中已经有了一个完全功能的应用程序。接下来，让我们看看如何修改接受测试阶段。
- en: The acceptance testing environment
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受测试环境
- en: 'The `Acceptance test` stage looks the same as it did in the previous chapter.
    The only thing we need to change is the IP and port of our service to the one
    from the remote Kubernetes cluster. As we explained in [*Chapter 6*](B18223_06_ePub.xhtml#_idTextAnchor152), *Clustering
    with Kubernetes*, the way you should do this depends on your Kubernetes Service
    type. We used `NodePort`, so we need to make the following change in `Jenkinsfile`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`接受测试`阶段与上一章中完全相同。我们需要更改的唯一内容是服务的IP和端口，使用远程Kubernetes集群中的地址。正如我们在[*第6章*](B18223_06_ePub.xhtml#_idTextAnchor152)《使用Kubernetes进行集群化》中所解释的那样，如何进行此操作取决于你的Kubernetes服务类型。我们使用的是`NodePort`，因此我们需要在`Jenkinsfile`中做以下更改：'
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `acceptance-test.sh` script should look as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`acceptance-test.sh`脚本应如下所示：'
- en: '[PRE6]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we used `sleep` to wait for our application to be deployed. Then, using `kubectl`,
    we fetched the IP address (`NODE_IP`) and the port (`NODE_PORT`) of our service.
    Finally, we executed the acceptance testing suite.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`sleep`等待应用程序部署完成。然后，使用`kubectl`获取服务的IP地址（`NODE_IP`）和端口（`NODE_PORT`）。最后，我们执行了接受测试套件。
- en: Tip
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you use Minishift for your Kubernetes cluster, then you can fetch `NODE_IP` using `minishift
    ip`. If you use Docker for Desktop, then your IP will be `localhost`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Minishift作为Kubernetes集群，那么你可以使用`minishift ip`获取`NODE_IP`。如果你使用Docker for
    Desktop，那么你的IP将是`localhost`。
- en: Now that all our tests are in place, it's time to release the application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有测试都已经就绪，是时候发布应用程序了。
- en: Release
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布
- en: The production environment should be as close to the staging environment as
    possible. The Jenkins stage for the release should also be as close as possible
    to the `Deploy to staging` step.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境应该尽可能接近staging环境。发布的Jenkins阶段也应该尽可能接近`部署到staging`步骤。
- en: 'In the simplest scenario, the only difference will be the Kubernetes configuration
    context and the application configuration (for example, in the case of a Spring
    Boot application, we would set a different Spring profile, which results in taking
    a different `application.properties` file). In our case, there are no application
    properties, so the only difference is the `kubectl` context:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，唯一的区别将是Kubernetes配置上下文和应用程序配置（例如，在Spring Boot应用程序的情况下，我们将设置不同的Spring配置文件，这样就会使用不同的`application.properties`文件）。在我们的例子中，应用程序没有属性文件，因此唯一的区别是`kubectl`上下文：
- en: '[PRE7]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the release has been done, we may think that everything is complete; however,
    one stage is missing – smoke testing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布完成，我们可能认为一切都已完成；然而，有一个阶段是缺失的——烟雾测试。
- en: Smoke testing
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烟雾测试
- en: A smoke test is a very small subset of acceptance tests whose only purpose is
    to check that the release process is completed successfully; otherwise, we could
    have a situation where the application is perfectly fine, but where there is an
    issue in the release process, so we may end up with a non-working production environment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试是接受测试的一个非常小的子集，其唯一目的就是检查发布过程是否成功完成；否则，可能会出现应用程序本身没有问题，但发布过程中存在问题，导致生产环境无法正常工作。
- en: 'The smoke test is usually defined in the same way as the acceptance test. So,
    the `Smoke test` stage in the pipeline should look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试通常与接受测试的定义相同。因此，流水线中的`烟雾测试`阶段应该是这样的：
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once everything has been set up, the CD build should run automatically, and
    the application should be released to production. With that, we have finished
    analyzing the CD pipeline in its simplest, but fully productive, form.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切设置完成，CD构建应该会自动运行，应用程序应该被发布到生产环境。这样，我们就完成了对CD流水线的分析，这是最简单但完全实用的形式。
- en: Complete Jenkinsfile
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的Jenkinsfile
- en: To summarize, in the past few chapters, we have gone through quite a few stages
    that have resulted in us creating a complete CD pipeline that can be used in many
    projects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在过去的几章中，我们经历了多个阶段，最终我们创建了一个完整的CD流水线，可以用于许多项目。
- en: 'The following is the complete `Jenkinsfile` for the `Calculator` project:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Calculator`项目的完整`Jenkinsfile`：
- en: '[PRE9]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is a declarative description of the whole CD process, which
    starts with checking out the code and ends with releasing it to production. Congratulations
    – with this code, you have completed the main goal of this book, which is to create
    a CD pipeline!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是对整个CD过程的声明性描述，从检出代码开始，到将其发布到生产环境结束。恭喜你，使用这段代码，你已经完成了本书的主要目标，那就是创建一个CD管道！
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we completed the CD pipeline, which means we can finally release
    the application. The following are the key takeaways from this chapter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了CD管道，这意味着我们终于可以发布应用程序。以下是本章的关键要点：
- en: 'When it comes to CD, two environments are indispensable: staging and production.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CD过程中，两个环境是不可或缺的：staging和production。
- en: Non-functional tests are an essential part of the CD process and should always
    be considered as pipeline stages.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性测试是CD过程的重要组成部分，应该始终作为管道阶段进行考虑。
- en: Non-functional tests that don't fit the CD process should be used as periodic
    tasks to monitor the overall performance trends.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不适合CD过程的非功能性测试应作为周期性任务，用于监控整体性能趋势。
- en: Applications should always be versioned; however, the versioning strategy depends
    on the type of application.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应始终进行版本控制；然而，版本控制策略取决于应用程序的类型。
- en: 'A minimal CD pipeline can be implemented as a sequence of scripts that ends
    with two stages: release and smoke test.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个最小的CD管道可以通过一系列脚本实现，最终以两个阶段结束：发布和烟雾测试。
- en: The smoke test should always be added as the last stage of the CD pipeline to
    check whether the release was successful.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烟雾测试应该始终作为CD管道的最后一个阶段，以检查发布是否成功。
- en: In the next chapter, we will look at some of the advanced aspects of the CD
    pipeline.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将研究CD管道的一些高级方面。
- en: Exercises
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we have covered a lot of new aspects of the CD pipeline. To
    help you understand these concepts, we recommend that you complete the following
    exercises:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了CD管道的许多新方面。为了帮助你理解这些概念，我们建议你完成以下练习：
- en: 'Add a performance test that tests the `hello world` service:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个性能测试，测试`hello world`服务：
- en: The `hello world` service can be taken from the previous chapter.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hello world`服务可以来自前一章。'
- en: Create a `performance-test.sh` script that makes 100 calls and checks whether
    the average request-response time is less than 1 second.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`performance-test.sh`脚本，进行100次调用并检查平均请求响应时间是否小于1秒。
- en: You can use Cucumber or the `curl` command for the script.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用Cucumber或`curl`命令来执行脚本。
- en: 'Create a Jenkins pipeline that builds the `hello world` web service as a versioned
    Docker image and performs performance tests:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Jenkins管道，构建`hello world` Web服务为一个版本化的Docker镜像，并执行性能测试：
- en: Create a `Docker build` (and `Docker push`) stage that builds the Docker image
    with the `hello world` service and adds a timestamp as a version tag.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Docker build`（和`Docker push`）阶段，构建带有`hello world`服务的Docker镜像，并将时间戳添加为版本标签。
- en: Use the Kubernetes deployment from the previous chapters to deploy the application.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前几章的Kubernetes部署来部署应用程序。
- en: Add the `Deploy to staging` stage, which deploys the image to the remote machine.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Deploy to staging`阶段，将镜像部署到远程机器。
- en: Add the `Performance testing` stage, which executes `performance-test.sh`.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Performance testing`阶段，执行`performance-test.sh`。
- en: Run the pipeline and observe the results.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行管道并观察结果。
- en: Questions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To check your knowledge of this chapter, answer the following questions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你对本章的知识掌握情况，请回答以下问题：
- en: Name at least three different types of software environments.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列出三种不同类型的软件环境。
- en: What is the difference between the staging and QA environments?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: staging和QA环境之间有什么区别？
- en: Name at least five types of non-functional tests.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列出五种非功能性测试类型。
- en: Should all non-functional tests be part of the CD pipeline?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有非功能性测试都应该是CD管道的一部分吗？
- en: Name at least two types of application versioning strategies.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列出两种应用程序版本控制策略。
- en: What is a smoke test?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是烟雾测试？
- en: Further reading
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the CD pipeline, please refer to the following resources:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于CD管道的内容，请参阅以下资源：
- en: '*Sameer Paradkar: Mastering Non-Functional Requirements*: [https://www.packtpub.com/application-development/mastering-non-functional-requirements](https://www.packtpub.com/application-development/mastering-non-functional-requirements).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sameer Paradkar：精通非功能性需求*：[https://www.packtpub.com/application-development/mastering-non-functional-requirements](https://www.packtpub.com/application-development/mastering-non-functional-requirements)。'
- en: '*Sander Rossel: Continuous Integration, Delivery, and Deployment*: [https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sander Rossel: 持续集成、交付和部署*: [https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment).'
