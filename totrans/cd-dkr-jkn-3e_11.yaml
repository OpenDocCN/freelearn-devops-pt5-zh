- en: '*Chapter 8*: Continuous Delivery Pipeline'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the missing parts of the final pipeline, which are
    the environments and infrastructure, application versioning, and non-functional
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Environments and infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing the continuous delivery pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow this chapter, you''ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Jenkins instance (with Java 8+, Docker, and `kubectl` installed on your Jenkins
    agents)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker registry (for example, an account on Docker Hub)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and solutions for the exercises in this chapter can be found
    on GitHub at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3JeyQ1X](https://bit.ly/3JeyQ1X).
  prefs: []
  type: TYPE_NORMAL
- en: Environments and infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have deployed our applications to some servers – that is, Docker
    hosts, Kubernetes clusters, and pure Ubuntu servers (in the case of Ansible).
    However, when we think more deeply about the **continuous delivery** (**CD**)
    process (or the software delivery process in general), we need to logically group
    our resources. There are two main reasons why this is important:'
  prefs: []
  type: TYPE_NORMAL
- en: The physical location of machines matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No testing should be done on the production machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking these facts into consideration, in this section, we will discuss different types of
    environments, their role in the CD process, and the security aspect of our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Types of environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are four common environment types – **production**, **staging**, **QA** (testing),
    and **development**. Let's discuss each of them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The production environment is the environment that is used by the end user.
    It exists in every company and is the most important environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how most production environments are organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Production environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Production environment
  prefs: []
  type: TYPE_NORMAL
- en: Users access the service through the load balancer, which chooses the machine.
    If the application is released in multiple physical locations, then the (first)
    device is usually a DNS-based geographic load balancer. In each location, we have
    a cluster of servers. If we use Docker and Kubernetes, for example, this means
    that in each location, we have at least one Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The physical location of machines matters because the request-response time
    can differ significantly, depending on the physical distance. Moreover, the database
    and other dependent services should be located on a machine that is close to where
    the service is deployed. What's even more important is that the database should
    be sharded in a way that minimizes the replication overhead between different
    locations; otherwise, we may end up waiting for the databases to reach a consensus
    between their instances, which will be located far away from each other. More
    details on the physical aspects are beyond the scope of this book, but it's important
    to remember that Docker and Kubernetes themselves do not solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and virtualization allow you to think about servers as infinite
    resources; however, some physical aspects such as location are still relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Staging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The staging environment is where the release candidate is deployed to perform
    the final tests before going live. Ideally, this environment is a mirror of the
    production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what such an environment should look like in the
    context of the delivery process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Staging environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Staging environment
  prefs: []
  type: TYPE_NORMAL
- en: Note that the staging environment is a clone of the production environment.
    If the application is deployed in multiple locations, then the staging environment
    should also have multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: In the CD process, all automated acceptance tests (both functional and non-functional)
    are run against this environment. While most functional tests don't usually require
    identical production-like infrastructure, in the case of non-functional (especially
    performance) tests, it is a must.
  prefs: []
  type: TYPE_NORMAL
- en: To save costs, it's not uncommon for the staging infrastructure to differ from
    the production environment (usually, it contains fewer machines). Such an approach
    can, however, lead to many production issues. *Michael T. Nygard*, in *Release
    It! Design and Deploy Production-Ready Software*, gives an example of a real-life
    scenario in which fewer machines were used in the staging environment than in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The story goes like this: in one company, the system was stable until a certain code
    change caused the production environment to become extremely slow, even though
    all the stress tests were passed. *How was this possible?* This happened because
    there was a synchronization point where each server communicated with the others.
    In the case of the staging environment, there was one server, so there was no
    blocker. In production, however, there were many servers, which resulted in servers
    waiting for each other. This example is just the tip of the iceberg, and many
    production issues may fail to be tested by acceptance tests if the staging environment
    is different from the production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: QA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The QA environment (also called the testing environment) is intended for the
    QA team to perform exploratory testing and for external applications (that depend
    on our service) to perform integration testing. The use cases and the infrastructure
    of the QA environment are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – QA environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – QA environment
  prefs: []
  type: TYPE_NORMAL
- en: While staging does not need to be stable (in the case of CD, it is changed after
    every code change that's committed to the repository), the QA instance needs to
    provide a certain amount of stability and expose the same (or backward-compatible)
    API as the production environment. In contrast to the staging environment, the
    infrastructure can be different from that of the production environment since
    its purpose is not to ensure that the release candidate works properly.
  prefs: []
  type: TYPE_NORMAL
- en: A very common case is to allocate fewer machines (for example, only from one
    location) to the QA instance.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the QA environment is usually done in a separate pipeline so that
    it's independent of the automatic release process. Such an approach is convenient
    because the QA instance has a different life cycle than the production one (for
    instance, the QA team may want to perform testing on the experimental code branched
    from the trunk).
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The development environment can be created as a shared server for all developers,
    or each developer can have a development environment for themselves. The following
    is a simple diagram of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Development environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Development environment
  prefs: []
  type: TYPE_NORMAL
- en: The development environment always contains the latest version of the code.
    It is used to enable integration between developers and can be treated the same
    way as the QA environment. However, it is used by developers, not QAs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at all the environments, let's see how they fit into the
    CD process.
  prefs: []
  type: TYPE_NORMAL
- en: Environments in continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the CD process, the staging environment is indispensable. In some very rare
    cases, when performance is not important and the project doesn't have many dependencies,
    we can perform the acceptance tests on the local (development) Docker host, but
    that should be an exception, not a rule. In such cases, we always risk some production
    issues occurring that are related to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The other environments are usually not important in terms of CD. If we would
    like to deploy to the QA or development environment with every commit, then we
    can create separate pipelines for that purpose (being careful not to obscure the
    main release pipeline). In many cases, deployment to the QA environment is triggered
    manually since it has a different life cycle from production.
  prefs: []
  type: TYPE_NORMAL
- en: Securing environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All environments need to be well secured – that's clear. What's even more obvious
    is that the most important requirement is to keep the production environment secure
    because our business depends on it, and the consequences of any security flaw
    can be the most serious.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Security is a broad topic. In this section, we will only focus on the topics
    related to the CD process. Nevertheless, setting up a complete server infrastructure
    requires much more security knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In the CD process, the Jenkins agent must have access to servers so that it
    can deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different approaches for providing agents with the server''s credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Put an SSH key in the agent**: If we don''t use dynamic Docker slave provisioning,
    then we can configure Jenkins agent machines so that they contain private SSH
    keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Put an SSH key in the agent image**: If we use dynamic Docker slave provisioning,
    we can add the SSH private key to the Docker agent image; however, this creates
    a possible security hole since anyone who has access to that image would have
    access to the production servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Jenkins credentials**: We can configure Jenkins to store credentials
    and use them in the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy to the slave Jenkins plugin**: We can copy the SSH key dynamically into
    the slave while starting the Jenkins build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each solution has some advantages and drawbacks. While using any of them, we
    have to take extra caution since, when an agent has access to the production environment,
    anyone breaking into that agent can break into the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The riskiest solution is to put SSH private keys into the Jenkins agent image
    since everywhere the image is stored (the Docker registry or Docker host within
    Jenkins) needs to be well secured.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the infrastructure, let's look at a topic that we haven't
    covered yet – non-functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot about functional requirements and automated acceptance testing
    in the previous chapters. *But what should we do with non-functional requirements?* Or
    even more challenging, *what if there are no requirements?* *Should we skip them
    in the CD process?* We will answer these questions throughout this section.
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional aspects of the software are always important because they can
    cause a significant risk to how the system operates.
  prefs: []
  type: TYPE_NORMAL
- en: For example, many applications fail because they are unable to bear the load
    of a sudden increase in the number of users. In one of his books, *Jakob Nielsen* writes
    about the user experience that *1 second is about the limit for the user's flow
    of thought to stay uninterrupted*. Imagine that our system, with its growing load,
    starts to exceed that limit. Users may stop using the service just because of
    its performance. Taking this into consideration, non-functional testing is just
    as important as functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cut a long story short, we should always take the following steps for non-functional
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide which non-functional aspects are crucial to our business.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each of them, we must do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the tests the same way we did for acceptance testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a stage to the CD pipeline (after acceptance testing, while the application
    is still deployed on the staging environment)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The application comes to the release stage only after all the non-functional
    tests have passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Irrespective of the type of non-functional test, the idea is always the same.
    The approach, however, may differ slightly. Let's examine different test types
    and the challenges they pose.
  prefs: []
  type: TYPE_NORMAL
- en: Types of non-functional test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional tests are always related to the same aspect – the behavior of the
    system. In contrast, non-functional tests are concerned with a lot of different
    aspects. Let's discuss the most common system properties and how they can be tested
    inside the CD process.
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performance tests are the most widely used non-functional tests. They measure
    the responsiveness and stability of the system. The simplest performance test
    we can create is one that sends a request to the web service and measures its **round-trip
    time** (**RTT**).
  prefs: []
  type: TYPE_NORMAL
- en: There are different definitions of performance testing. They are often meant
    to include load, stress, and scalability testing. Sometimes, they are also described
    as white-box tests. In this book, we will define performance testing as the most
    basic form of black-box test to measure the latency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: For performance testing, we can use a dedicated framework (for Java, the most
    popular is JMeter) or just use the same tool we used for our acceptance tests.
    A simple performance test is usually added as a pipeline stage, just after the
    acceptance tests. Such a test should fail if the RTT exceeds the given limit and
    it detects bugs that slow down our service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The JMeter plugin for Jenkins can show performance trends over time.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Load tests are used to check how the system functions when there are a lot of
    concurrent requests. While a system can be very fast with a single request, this
    doesn't mean that it works fast enough with 1,000 requests being worked on at
    the same time. During load testing, we measure the average request-response time
    of many concurrent calls, which are usually performed from many machines. Load
    testing is a very common QA phase in the release cycle. To automate it, we can
    use the same tools that we do when conducting a simple performance test; however,
    in the case of larger systems, we may need a separate client environment to perform
    a large number of concurrent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stress testing, also called **capacity testing** or **throughput testing**,
    is a test that determines how many concurrent users can access our service. It
    may sound the same as load testing, but in the case of load testing, we set the
    number of concurrent users (throughput) to a given number, check the response time
    (latency), and make the build fail if that limit is exceeded. During stress testing,
    however, we keep the latency constant and increase the throughput to discover
    the maximum number of concurrent calls when the system is still operable. Therefore,
    the result of a stress test may be a notification that our system can handle 10,000
    concurrent users, which helps us prepare for the peak usage time.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing is not well suited for the CD process because it requires long
    tests with an increasing number of concurrent requests. It should be prepared
    as a separate script of a separate Jenkins pipeline and triggered on demand when
    we know that the code change can cause performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scalability testing explains how latency and throughput change when we add more
    servers or services. The perfect characteristic would be linear, which means that
    if we have one server and the average request-response time is 500 ms when it's
    used by 100 parallel users, then adding another server would keep the response
    time the same and allow us to add another 100 parallel users. In reality, it's
    often hard to achieve this because of the need to keep data consistent between
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability testing should be automated and provide a graph that shows the relationship
    between the number of machines and the number of concurrent users. Such data helps
    determine the limits of the system and the point at which adding more machines
    doesn't help.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability tests, similar to stress tests, are hard to put into the CD pipeline
    and should be kept separate.
  prefs: []
  type: TYPE_NORMAL
- en: Soak testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Soak tests, also called **endurance tests** or **longevity tests**, run the system
    for a long time to see if the performance drops after a certain period. They detect
    memory leaks and stability issues. Since they require a system to run for a long
    time, it doesn't make sense to run them inside the CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security testing deals with different aspects related to security mechanisms
    and data protection. Some security aspects are purely functional requirements,
    such as authentication, authorization, and role assignment. These elements should
    be checked the same way as any other functional requirement – during the acceptance
    test phase. Other security aspects are non-functional; for example, the system
    should be protected against SQL injection. No client would probably specify such
    a requirement, but it's implicit.
  prefs: []
  type: TYPE_NORMAL
- en: Security tests should be included in the CD process as a pipeline stage. They
    can be written using the same frameworks as the acceptance tests or with dedicated security
    testing frameworks – for example, **behavior-driven development** (**BDD**) security.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Security should also always be a part of the explanatory testing process, in
    which testers and security experts detect security holes and add new testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maintainability tests explain how simple a system is to maintain. In other words,
    they judge code quality. We have already described stages in the commit phase
    that check test coverage and perform static code analysis. The Sonar tool can
    also provide an overview of the code quality and the technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recovery testing is a technique that's used to determine how quickly the system
    can recover after it's crashed because of a software or hardware failure. The
    best case would be if the system doesn't fail at all, even if a part of its service
    is down. Some companies even perform production failures on purpose to check if
    they can survive a disaster. The most well-known example is Netflix and their
    Chaos Monkey tool, which randomly terminates instances of the production environment.
    Such an approach forces engineers to write code that makes systems resilient to
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery testing is not part of the CD process, but rather a periodic event
    that checks its overall health.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Chaos Monkey at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey).
  prefs: []
  type: TYPE_NORMAL
- en: Many more nonfunctional test types are closer to or further from the code and
    the CD process. Some of them relate to the law, such as compliance testing, while
    others are related to documentation or internationalization. There's also usability
    testing and volume testing (which check whether the system behaves well when it's
    handling large amounts of data). Most of these tests, however, have no part in
    the CD process.
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Non-functional aspects pose new challenges to software development and delivery. Let''s
    go over some of them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long test runs**: The tests can take a long time to run and may need a special
    execution environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental nature**: It''s hard to set the limit value when the test should
    fail (unless the SLA is well-defined). Even if the edge limit is set, the application
    would probably incrementally approach the limit. In most cases, no code changes
    will cause the test to fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vague requirements**: Users usually don''t have much input when it comes
    to non-functional requirements. They may provide some guidelines concerning the
    request-response time or the number of users; however, they probably won''t know
    much about maintainability, security, or scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplicity**: There are a lot of different non-functional tests and choosing
    which should be implemented means making some compromises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best approach to address non-functional aspects is to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a list of all the non-functional test types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Explicitly cross out the tests you don''t need for your system. There may be
    a lot of reasons you don''t need one kind of test, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service is super small, and a simple performance test is enough.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is internal only and exclusively available for read-only purposes,
    so it may not need any security checks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is designed for one machine only and does not need any scaling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of creating certain tests is too high.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Split your tests into two groups:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous Delivery**: It is possible to add it to the pipeline.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis**: It is not possible to add it to the pipeline because of its execution
    time, nature, or associated cost.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the CD group, implement the related pipeline stages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the analysis group, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create automated tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule when they should be run
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule meetings to discuss their results and take action
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A very good approach is to have a nightly build with the long tests that don't
    fit the CD pipeline. Then, it's possible to schedule a weekly meeting to monitor
    and analyze the trends of system performance.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As we can see, there are many types of non-functional tests, and they pose additional
    challenges to the delivery process. Nevertheless, for the sake of the stability
    of our system, these tests should never be skipped. The technical implementation
    differs based on the test's type, but in most cases, they can be implemented similarly
    to functional acceptance tests and should be run against the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in the topic of non-functional testing, system properties,
    and system stability, then read the book *Release It!*, by *Michael T. Nygard*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed the nonfunctional testing, let's look at another aspect
    that we haven't looked at in too much detail – application versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Application versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, throughout every Jenkins build, we have created a new Docker image,
    pushed it into the Docker registry, and used the *latest* version throughout the
    process. However, such a solution has at least three disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: If, during the Jenkins build, after the acceptance tests, someone pushes a new
    version of the image, then we can end up releasing the untested version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We always push an image that's named in the same way so that, effectively, it
    is overwritten in the Docker registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's very hard to manage images without versions just by using their hashed-style
    IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the recommended way of managing Docker image versions alongside the
    CD process?* In this section, we''ll look at the different versioning strategies
    and learn how to create versions in the Jenkins pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: Versioning strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different ways to version applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the most popular solutions that can be applied alongside the
    CD process (when each commit creates a new version):'
  prefs: []
  type: TYPE_NORMAL
- en: '`x.y.z`). This method requires a commit to be made to the repository by Jenkins
    to increase the current version number, which is usually stored in the build file.
    This solution is well supported by Maven, Gradle, and other build tools. The identifier
    usually consists of three numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: This is the major version; the software does not need to be backward compatible
    when this version is incremented.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: This is the minor version; the software needs to be backward compatible
    when the version is incremented.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z`: This is the build number (also called the **patch version**); this is
    sometimes also considered as a backward-and forward-compatible change.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp**: Using the date and time of the build for the application version
    is less verbose than sequential numbers, but it''s very convenient in the case
    of the CD process because it does not require Jenkins to commit it back to the
    repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hash**: A randomly generated hash version shares the benefit of the date-time
    and is probably the simplest solution possible. The drawback is that it''s not
    possible to look at two versions and tell which is the latest one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixed**: There are many variations of the solutions described earlier – for
    example, the major and minor versions with the date-time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these solutions can be used alongside the CD process. Semantic versioning,
    however, requires a commit to be made to the repository from the build execution
    so that the version is increased in the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Maven (and other build tools) popularized version snapshotting, which added
    a `SNAPSHOT` suffix to the versions that haven't been released and have been kept
    just for the development process. Since CD means releasing every change, there
    are no snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to adapt versioning in the Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning in the Jenkins pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, there are different possibilities when it comes to
    using software versioning, and each of them can be implemented in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's use the date-time.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: To use the timestamp information from Jenkins, you need to install the Build
    Timestamp plugin and set the timestamp format in the Jenkins configuration under
    `yyyyMMdd-HHmm`.
  prefs: []
  type: TYPE_NORMAL
- en: Everywhere we use the Docker image, we need to add the `${BUILD_TIMESTAMP}`
    tag suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Docker build` stage should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After making these changes, when we run the Jenkins build, the image should
    be tagged with the timestamp's version in our Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: With versioning completed, we are finally ready to complete the CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the continuous delivery pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered Ansible, environments, non-functional testing, and versioning,
    we are ready to extend the Jenkins pipeline and finalize a simple, but complete,
    CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the inventory of staging and production environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use version in the Kubernetes deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a remote Kubernetes cluster as the staging environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the acceptance tests so that they use the staging Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release the application to the production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a smoke test that makes sure the application was released successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by creating an inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at the inventory file in the previous chapter while describing Ansible.
    To generalize this concept, an inventory contains a list of environments that
    describe how to access them. In this example, we'll use Kubernetes directly, so
    the Kubernetes configuration file, which is usually stored in `.kube/config`,
    will act as the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: As we explained in the previous chapter, depending on your needs, you may use
    `kubectl` directly or via Ansible or Terraform. These approaches are suitable
    for the CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure two Kubernetes clusters – `staging` and `production`. Your
    `.kube/config` file should look similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kubernetes configuration stores the following information for each cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster`: The address of the cluster (Kubernetes master endpoint) and its
    CA certificate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: The binding of the cluster and user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: The authorization data to access the Kubernetes cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The simplest way to create two Kubernetes clusters is to use `kubectl` using
    `gcloud container clusters get-credentials`, and finally rename the cluster context
    with `kubectl config rename-context <original-context-name> staging`. Note that
    you may also need to create a GCP Firewall rule to allow traffic into your Kubernetes
    nodes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You also need to make sure that the Kubernetes configuration is available on
    the Jenkins agent nodes. As we mentioned in the previous sections, think carefully
    about your security so that no unauthorized persons can access your environments
    via the Jenkins agent.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've defined the inventory, we can prepare the Kubernetes deployment
    configuration so that it can work with application versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes YAML files are the same as what we defined in the previous chapters.
    The only difference is that we need to introduce a template variable for the application
    version. Let''s make one change in the `deployment.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can fill the version in `Jenkinsfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can change acceptance testing to use the remote staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: The remote staging environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on our needs, we could test the application by running it on the local
    Docker host (as we did previously) or using the remote (and clustered) staging
    environment. The former solution is closer to what happens in production, so it
    can be considered a better one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to change the command we use from `docker` to `kubectl`.
    Let''s modify the related part of our `Jenkinsfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we switched `kubectl` to use the `staging` context. Then, we deployed
    the Hazelcast server. Finally, we deployed `Calculator` into the Kubernetes server.
    At this point, we have a fully functional application in our staging environment.
    Let's see how we need to modify the acceptance testing stage.
  prefs: []
  type: TYPE_NORMAL
- en: The acceptance testing environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Acceptance test` stage looks the same as it did in the previous chapter.
    The only thing we need to change is the IP and port of our service to the one
    from the remote Kubernetes cluster. As we explained in [*Chapter 6*](B18223_06_ePub.xhtml#_idTextAnchor152), *Clustering
    with Kubernetes*, the way you should do this depends on your Kubernetes Service
    type. We used `NodePort`, so we need to make the following change in `Jenkinsfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `acceptance-test.sh` script should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we used `sleep` to wait for our application to be deployed. Then, using `kubectl`,
    we fetched the IP address (`NODE_IP`) and the port (`NODE_PORT`) of our service.
    Finally, we executed the acceptance testing suite.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you use Minishift for your Kubernetes cluster, then you can fetch `NODE_IP` using `minishift
    ip`. If you use Docker for Desktop, then your IP will be `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all our tests are in place, it's time to release the application.
  prefs: []
  type: TYPE_NORMAL
- en: Release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The production environment should be as close to the staging environment as
    possible. The Jenkins stage for the release should also be as close as possible
    to the `Deploy to staging` step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the simplest scenario, the only difference will be the Kubernetes configuration
    context and the application configuration (for example, in the case of a Spring
    Boot application, we would set a different Spring profile, which results in taking
    a different `application.properties` file). In our case, there are no application
    properties, so the only difference is the `kubectl` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once the release has been done, we may think that everything is complete; however,
    one stage is missing – smoke testing.
  prefs: []
  type: TYPE_NORMAL
- en: Smoke testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A smoke test is a very small subset of acceptance tests whose only purpose is
    to check that the release process is completed successfully; otherwise, we could
    have a situation where the application is perfectly fine, but where there is an
    issue in the release process, so we may end up with a non-working production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smoke test is usually defined in the same way as the acceptance test. So,
    the `Smoke test` stage in the pipeline should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once everything has been set up, the CD build should run automatically, and
    the application should be released to production. With that, we have finished
    analyzing the CD pipeline in its simplest, but fully productive, form.
  prefs: []
  type: TYPE_NORMAL
- en: Complete Jenkinsfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To summarize, in the past few chapters, we have gone through quite a few stages
    that have resulted in us creating a complete CD pipeline that can be used in many
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the complete `Jenkinsfile` for the `Calculator` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a declarative description of the whole CD process, which
    starts with checking out the code and ends with releasing it to production. Congratulations
    – with this code, you have completed the main goal of this book, which is to create
    a CD pipeline!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we completed the CD pipeline, which means we can finally release
    the application. The following are the key takeaways from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to CD, two environments are indispensable: staging and production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-functional tests are an essential part of the CD process and should always
    be considered as pipeline stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-functional tests that don't fit the CD process should be used as periodic
    tasks to monitor the overall performance trends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications should always be versioned; however, the versioning strategy depends
    on the type of application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A minimal CD pipeline can be implemented as a sequence of scripts that ends
    with two stages: release and smoke test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smoke test should always be added as the last stage of the CD pipeline to
    check whether the release was successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the advanced aspects of the CD
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered a lot of new aspects of the CD pipeline. To
    help you understand these concepts, we recommend that you complete the following
    exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a performance test that tests the `hello world` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `hello world` service can be taken from the previous chapter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `performance-test.sh` script that makes 100 calls and checks whether
    the average request-response time is less than 1 second.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use Cucumber or the `curl` command for the script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Jenkins pipeline that builds the `hello world` web service as a versioned
    Docker image and performs performance tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Docker build` (and `Docker push`) stage that builds the Docker image
    with the `hello world` service and adds a timestamp as a version tag.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Kubernetes deployment from the previous chapters to deploy the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Deploy to staging` stage, which deploys the image to the remote machine.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Performance testing` stage, which executes `performance-test.sh`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the pipeline and observe the results.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To check your knowledge of this chapter, answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Name at least three different types of software environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the staging and QA environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least five types of non-functional tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should all non-functional tests be part of the CD pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least two types of application versioning strategies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a smoke test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the CD pipeline, please refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sameer Paradkar: Mastering Non-Functional Requirements*: [https://www.packtpub.com/application-development/mastering-non-functional-requirements](https://www.packtpub.com/application-development/mastering-non-functional-requirements).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sander Rossel: Continuous Integration, Delivery, and Deployment*: [https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
