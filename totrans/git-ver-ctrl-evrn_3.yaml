- en: Chapter 3. Polishing Your Routine – How to Increase Everyday Productivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We scratched the surface of version control system concepts to understand
    how Git can make us more efficient in doing our work. Without any delay we also
    quickly grabbed a copy of it and got it up and running in our systems.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*I hear you shouting with excitement, "Let''s dive in!".*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aye aye, Captain, here we go. In this chapter you will look at five important
    concepts, which is all you really need most of the time in your workplace:'
  prefs: []
  type: TYPE_NORMAL
- en: Initiating the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding your files to the cabin (repository)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing the added files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's right, just five concepts are all you need to create a difference. And
    of course we shall learn how to get back on track with Git's built-in helper functions
    if you get lost along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Suit up – getting ready for your Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you have a magic wand, and it will do exactly what you order it to
    do! Yeah, that's right, you have Git now. You need to command Git to do what it
    has to do for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds fun, right?
  prefs: []
  type: TYPE_NORMAL
- en: We already read that to maintain multiple versions of files they have to be
    kept inside a directory (folder), so we shall create a directory called `Workbench`
    on your desktop to learn the concepts explained in chapters hands on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to handling computers there are people who would like to get
    the job done with either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GUI mode (graphical user interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CLI mode (command-line interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of both can also be used. In the interest of serving a diverse
    audience, we shall try to cover both modes of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Initiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initiation is nothing but a process of pointing your finger towards that directory
    so that Git will know it has to monitor its contents for changes from then on.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, we shall cover both ways (GUI and CLI) of performing
    these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initiation in GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create/initiate a repository, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Git Gui** from your desktop or from your applications menu and select
    the option **Create New Repository**, as shown in the following screenshot:![Time
    for action – initiation in GUI mode](img/7522_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git will present you with a new screen, expecting from you the location of the
    directory that you want to make a repository. So click the on the **Browse** button,
    select our **Workbench** directory from the desktop, and click on the **Create**
    button.![Time for action – initiation in GUI mode](img/7522_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should get a screen as follows:![Time for action – initiation in GUI mode](img/7522_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now don't close this window; we shall continue from this screen for our remaining
    concepts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have successfully commanded Git to monitor your `Workbench` directory and
    its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous image showed the master page, which we will be interacting with
    very often. It consists of four panes; let''s call them the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unstaged Changes** pane (top left)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staged Changes** pane (bottom left)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Differential Content** pane (top right)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action** pane (bottom right)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example we created a new directory called `Workbench` and initiated it
    as a repository. You can also follow the same procedures to convert an existing
    directory that already holds your files into a repository for Git to monitor.
    When you do that, your files inside the repository will initially appear in the
    **Unstaged Changes** pane.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initiation in CLI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who like to hear the sounds of more keystrokes instead of clicks,
    there's always **command-line interface** (**CLI**) mode.
  prefs: []
  type: TYPE_NORMAL
- en: There has been a constant increase in the percentage of people who are quick
    with keyboard's key strokes, giving more priority to performing operations using
    keystrokes instead of mouse clicks wherever possible. This is also a main reason
    why **Gmail** introduced shortcut keys for almost all of its functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create or initiate the repository using the command-line interface mode
    you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your **shell** (command prompt in Windows or Terminal/Console in Mac/Linux).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to your `Workbench` directory on your desktop using the `cd`(change directory)
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are inside the `Workbench` directory type `git init` and hit *Enter*
    to complete the initiation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should get a status message from Git saying **Initialized empty Git repository
    in your/path/to/Workbench/directory/goes/here**.![Time for action – initiation
    in CLI mode](img/7522_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ah! The sound of keystrokes, so good to hear.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have successfully commanded GIT to monitor our `Workbench` directory and
    its contents. `Init` is the operational keyword that initializes the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This initiation process will create a directory called `.git` inside our `Workbench`
    directory. This directory is usually made **read-only** and **hidden** by Git
    to safeguard itself from accidental deletion or tampering by users. It's the place
    where Git will hold all the history about your files and changes made to them.
  prefs: []
  type: TYPE_NORMAL
- en: So be careful with that directory; deleting it will *wipe out* the entire history
    of your files present in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: Configure Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gear up your Git installation for usage by configuring it properly. There are
    several reasons why you should configure Git before starting to use it, but discussing
    all of them now would be premature, so we shall learn about them as and when the
    necessity occurs. For now, as a bare minimum configuration to get started, we
    will tell our name and e-mail address to Git so that it can log the changes under
    our identity.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – configure Git in GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convey to Git our name and e-mail address using GUI mode follow these procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Options** from the **Edit** menu of the screen that you left open after
    the initiation process.![Time for action – configure Git in GUI mode](img/7522_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration screen is divided into two halves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Local configuration (left side – particularly our Workbench Repository)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Global configuration (right side – applies to all the repositories created using
    this installation)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't let the big screen with numerous options overwhelm you. Let's focus on
    the top portion alone for now and type our name and e-mail address in both local
    and global configurations as shown in the previous image, and hit the **Save**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By giving out our username and e-mail address both locally and globally we have
    provided ways for Git to identify and group the changes made to files present
    in any repository.
  prefs: []
  type: TYPE_NORMAL
- en: Out of flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just in case you closed the screen after the initiation process and were wondering
    how to go about getting to the same screen again, don't worry. There are two ways
    of getting back.
  prefs: []
  type: TYPE_NORMAL
- en: Open up **Git Gui** where you will see a newly added option called **Open Recent
    Repository**, under which you can find our **Workbench** repository.![Out of flow](img/7522_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Workbench`directory on the desktop and right-click with your mouse
    on the folder. In the menu select **Git GUI here**. Peoplewho want to switch from
    CLI mode to GUI mode can use this option as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time for action – configure Git in CLI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure Git using CLI you can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – configure Git in CLI mode](img/7522_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By giving out our username and e-mail address both locally and globally we have
    provided ways for Git to identify and group the changes made to files present
    in any repository.
  prefs: []
  type: TYPE_NORMAL
- en: '`config` is the operational keyword that needs to be used with `git` to set
    up the configuration of Git. To set a global value we add the `--global` parameter
    with the command, and to set a local value we add the `--local` parameter with
    the command.'
  prefs: []
  type: TYPE_NORMAL
- en: As the name indicates, global configuration is nothing but a global value for
    all repositories created in the system by that system user, whereas local configuration
    is the exact opposite. As you would have guessed by now, the parameters `user.name`
    and `user.email` are used to record the user's name and e-mail address, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To get a list of configurations set till date you can use the last command,
    which had the `–l` parameter. It lists all the configuration variables for you.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your files to your directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have set a perfect base to operate on, let's move one step ahead
    by adding your files to the repository that you have created.
  prefs: []
  type: TYPE_NORMAL
- en: Whoa, wait! What's that term that we often came across earlier – **repository**?
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will address a directory/folder that has been pointed to
    Git to monitor as a repository.
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, baby, learn Git lingo and impress your date! The process of adding files
    is as simple as copying and pasting or creating your files inside our repository
    and asking Git to watch them.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding files to your directory (GUI and CLI mode)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a Word document called **content.docx** that contains the text
    "I love working with Git. It's a simple, fast, and superb version control system`"`
    to learn and put in practice the functionalities mentioned at the beginning of
    our chapter (people who are not able to create a `.docx` file can proceed with
    any other document format such as `.odt`, `.txt`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – adding files to your directory (GUI and CLI mode)](img/7522_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Git will report to you about the files that have been added to our repository
    and will stand by for your instructions to proceed. Now we can go ahead and tell
    Git to monitor these files for changes by performing the steps that we will discuss
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using GUI mode, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Rescan** button (or press *F5* on your keyboard) present in the
    **Action** pane.![Time for action – adding files to your directory (GUI and CLI
    mode)](img/7522_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the page-like icon next to the filename to push the file to the **Staged
    Changes** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using the CLI mode ,use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully added our files to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the **Rescan** button or typing the `git status` command we ordered
    our slave to list the changes that were made to the repository since its previous
    state. These changes are called unstaged changes, meaning changes that have happened
    since our last confirmed state of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: These changes have to be confirmed by the user by moving them to the staged
    changes state, which is done by clicking on the file icon next to the filename
    or using the `git add` command.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore 'em
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just saw ways to put your files under Git''s radar but there are numerous
    situations where one might want to avoid adding certain files into one''s working
    repository. As a live case, after adding some content in the `content.docx` file
    and trying to add your files into the repository as seen in the previous step,
    some might have encountered the situation where Git reports (of course, after
    refreshing the Git GUI or using the `git status` command in CLI) changes made
    in two files, **content.docx** and **~$ontent.docx**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ignore ''em](img/7522_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This happens only if the opened `content.docx` Word document is not closed before
    refreshing or hitting the `git status` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ignore ''em](img/7522_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is because Microsoft's Word application has a habit of saving your current
    workspace at regular intervals (which can be configured) in a temporary file for
    disaster recovery.
  prefs: []
  type: TYPE_NORMAL
- en: It is only because of this mechanism that Word prompts you with a file recovery
    dialog from where you can retrieve your latest changes when a proper save is not
    done before abrupt closure of the document.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ignore ''em](img/7522_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not only Microsoft Word but all smart applications and editors follow such a
    procedure to comfort the end users. These files are automatically deleted once
    the corresponding source file is saved and closed properly. There would be no
    value added in controlling the versions of these temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: So while adding files to your repository it is important that you exclude these
    temporary files before proceeding to the committing concept as the reversal would
    be a painful process.
  prefs: []
  type: TYPE_NORMAL
- en: This way of adding files to Git holds good for a few files, but when it comes
    to handling several files in the repository, clicking on the icon next to each
    of them or performing a `git add` for each file is going to be a time consuming
    and tiresome activity.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to move several files from the **Unstaged Changes** area to the
    **Staged Changes** area you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUI**: Press *Ctrl* + *I* and select **yes** if there is a prompt about adding
    unknown files instead of clicking at each and every icon next to that file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLI**: The command `git add .`is the equivalent of pressing *Ctrl* + *I*
    when using GUI mode. It will stage all your changes at a single shot. The use
    of **wildcard characters** like `*.docx` is also permitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using these options we can eliminate our tiresome process of adding a single
    file at a time, but it defeats the objective of excluding the temporary files
    from being added to the repository. So how do we combine the power of bulk operations
    along with the control to exclude certain files or file types?
  prefs: []
  type: TYPE_NORMAL
- en: .gitignore to the rescue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To handle this smartly, Git has a provision. By creating a file called `.gitignore`
    inside the repository and entering the names of files or pattern of the filenames
    we can make Git exclude them.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – usage of .gitignore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your text editor and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file as `.gitignore` inside our **Workbench** repository, as shown
    in the following screenshot:![Time for action – usage of .gitignore](img/7522_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to select the **All Files** option from the **Save as type** listbox
    when you save the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully commanded Git to ignore the temporary file created by the
    Word application. Go ahead and refresh your GUI or get the status from your CLI
    now. The only addition to your `content.docx` file in the **Unstaged Changes**
    area would be the `.gitignore` file and not the temporary file.
  prefs: []
  type: TYPE_NORMAL
- en: Every time Git wants to check for new files (untracked changes) present in the
    repository it checks with the `.gitignore` file for exclusions. By observing the
    temporary file's name (`~$ontent.docx`) we can guess that any temporary file created
    by Word is going to start with the special character **~** so we put an entry
    in `.gitignore` to match all files starting with that character. The very entry
    `~*.*` under the `.gitignore` file says to exclude any filename starting with
    the character ~ with any extension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though addition of the `.gitignore` file itself is a one-time process, the exclusion
    rules inside the file have to be updated as per the nature and content type of
    the files added in the repository as required.
  prefs: []
  type: TYPE_NORMAL
- en: Undo addition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At any given point of time before committing, if you want to move a file from
    the **Staged Changes** to the **Unstaged Changes** area you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUI**: Click on the tick icon next to that particular filename present in
    the **Staged Changes** pane'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLI**: Use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Committing the added files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now we have initiated the repository, added our files into the repository,
    and confirmed those changes by staging them (pushing them to the staged changes
    stage) but until they are committed the files are not said to be under version
    control. (This is because only when you commit does Git record the content of
    the files and save it as a new phase of that file/files, so that next time it
    can identify whether the files have any change of content by comparing the existing
    version to the last saved version).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a new addition to your Git lingo: This process is called **committing**.'
  prefs: []
  type: TYPE_NORMAL
- en: So let's make an initial commit of your files. The first time you add a file
    to the repository and make a commit, Git registers the new file. Any further commits
    made to these files inside the same repository will be a commit for the changes
    based on the previous version of the same file available in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Though Git follows your orders it has a healthy habit of associating a comment
    at the time of every single commit so that it can learn about your behavior and
    moods with respect to various file types and build an artificially intelligent
    system based on observed patterns to automate your routines.
  prefs: []
  type: TYPE_NORMAL
- en: Basically comments that you provide at each commit is just to help yourself
    or any other person reading the history of your repository understand the purpose
    of, and/or changes to, the files.
  prefs: []
  type: TYPE_NORMAL
- en: It's good to make a comment, which can be anything informative. Having learned
    the theory behind it, let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – committing files in GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's type our reason for this commit in the space provided under the **Initial
    Commit Message** label present in the **Action** pane.![Time for action – committing
    files in GUI mode](img/7522_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Commit** button. Once the commit is done Git gives you a status
    message at the bottom of the pattern **status commit ID: your comment for the
    commit**.![Time for action – committing files in GUI mode](img/7522_03_15.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit ID is nothing but a unique identifier for Git to recollect your commit
    in future. We will see the other usages of our comments on the commit and the
    Git commit ID in the oncoming functionalities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Time for action – committing files in CLI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming you already have the command prompt opened by doing the steps mentioned
    under initiation process, give Git the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – committing files in CLI mode](img/7522_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you see a status message similar to the one mentioned previously it's a sign
    of an affirmation.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have successfully committed your files to the repository. Henceforth any
    changes made to these files will be relative.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what happens when you change the contents of the file inside the repository.
  prefs: []
  type: TYPE_NORMAL
- en: I suddenly feel that I need to convey how Git impacts my work instead of just
    saying "It's a simple, fast, and superb version control system" in our `content.docx`
    file. So I am replacing this with the text "It increases my productivity manyfold
    when working with files that have frequent content changes."
  prefs: []
  type: TYPE_NORMAL
- en: Git tracks the change and indicates it to us when asked about a status update.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – rescan in GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you already have **Git Gui** open then just hit the **Rescan** button to
    get the latest status update from Git. If you don't have the tool opened already,
    I'm assuming you know how to open it.
  prefs: []
  type: TYPE_NORMAL
- en: And you see, it shows the files that have changed from their earlier state in
    the **Unstaged Changes** area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – rescan in GUI mode](img/7522_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You recently learned how to stage a file's change and how to commit it, so I'll
    leave the rest to you. Just so that you know, my commit message for this commit
    was "Added more text that explains why I use Git."
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Content** pane shows the change that you have made in the file. Green
    text indicates addition and red text indicates deletion when compared to the previous
    version of the file. We shall explore more about this in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For CLI lovers, we have been using the `status` command from the time we added
    files to check the status of the repository, and it is no different here. Employ
    the `git status` command to get to know about the changes in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, until now we have been moving forward in versioning our files by giving
    orders to Git with the concepts we learned. Whatever you have learned up to now
    is just a one way process!
  prefs: []
  type: TYPE_NORMAL
- en: To make it clearer – *how do you feel about not knowing how to use the undo
    and redo features of your Word application?*
  prefs: []
  type: TYPE_NORMAL
- en: So let's learn how to travel back in time with respect to content using Git.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out is one of the processes that helps you jump to and fro between
    the changes that you have made in any single file or the entire subset of files
    that you have in your repository at the time you committed.
  prefs: []
  type: TYPE_NORMAL
- en: You can go back to a commit that you have made earlier to view the contents
    of a single file or group of files and return to the latest version of the same
    file with the latest changes – all in an instant.
  prefs: []
  type: TYPE_NORMAL
- en: How good is that?
  prefs: []
  type: TYPE_NORMAL
- en: There are several things you can do other than just viewing the file in an earlier
    commit, which we will discuss in later chapters under the topic called branching.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned the theory behind it, let's put it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – checking out using GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select the **Repository** menu and then the **Visualize All Branch History**
    option in the opened **Git Gui** screen to open **gitk**; you will get a screen
    like the following:![Time for action – checking out using GUI mode](img/7522_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gitk is a powerful graphical repository browser allowing us to perform various
    kinds of operations such as visualizing the repository, tagging, resetting, and
    so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Again, don't worry about the overwhelming information on the screen; we shall
    get there step-by-step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For now let's focus on the top-left pane, which shows a pathway in which the
    colored circles indicate the commits you have made; alongside the circles are
    your comments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And directly beneath it is a field called **SHA1 ID**, which shows you the commit
    ID for the commit that you have selected above. As we discussed earlier we will
    use this commit ID to identify a particular commit to travel back in time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select our first commit, which says **Initial commit to showcase the commit
    functionality of Git**, to get its commit ID displayed in the **SHA1 ID** field
    and copy the ID (by double-clicking to select the entire line's content and pressing
    *Ctrl* + *C* to copy it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to **Git Gui** and select **Branch | Checkout** to open the checkout
    operation window (alternatively you can press *Ctrl* + *O*). Paste the SHA1 ID
    that you have copied into the **Revision Expression** textbox and click on the
    **Checkout** button, as shown in the following screenshot:![Time for action –
    checking out using GUI mode](img/7522_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button on the dialog window that appears (we will discuss
    more about the term detached checkout in later chapters under the branching topic).![Time
    for action – checking out using GUI mode](img/7522_03_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have successfully travelled back in time. If we open our document now, we
    can see the content we had initially created in the document.
  prefs: []
  type: TYPE_NORMAL
- en: At any given point of time you can revert to your latest changes by selecting
    **Branch** | **Checkout** | **Localbranch**; ensure **master** is selected, and
    click on the **Checkout** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/7522_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you have jumped back to your contents with the latest changes.
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, awesome, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – checking out using CLI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn two more commands to add to your Git lingo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Git log` is for showing the history of a repository; it gives us information
    such as commit ID, author, date, and the commit comment given by us.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need the commit ID for use later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – checking out using CLI mode](img/7522_03_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Don't worry about memorizing a sequence of 40 characters. Our magic wand, Git,
    does the hard work of filling in the remaining characters for you to identify
    a commit if you supply it with the first five characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's see it in action.![Time for action – checking out using CLI mode](img/7522_03_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have travelled back to a previous commit, and your files will contain
    the contents of the previous commit. You can view the contents of the file now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have checked back to a previous commit you are hanging in the air;
    any changes to your files now will be lost once you go back to the master. We'll
    see how to handle this in later chapters with a concept called branching.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To return to the latest changes run `git checkout master`; this will bring you
    to the latest changes.![Time for action – checking out using CLI mode](img/7522_03_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see a message similar to the one in the previous screenshot, you have
    returned to your latest changes. Again, you can view the contents of the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Resetting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the checkout function that we learned previously, resetting is a permanent
    travel back in time with respect to the content. There are three types of resetting.
  prefs: []
  type: TYPE_NORMAL
- en: Soft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our aim of ignoring all the changes made after a particular commit can be achieved
    only by performing a **hard reset**, so we will learn about the hard type alone
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – reset using GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select the **Repository** menu and then the **Visualize All Branch History**
    option on the opened **Git Gui** screen to open Gitk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the top-left panel you can see how your repository history is shaping up.
    Right now it's linear with two commits. Now right-click on the first commit, which
    has the commit message **Initial commit to showcase the commit functionality of
    Git**, and choose the **Reset master branch to here** option, as shown in the
    following screenshot:![Time for action – reset using GUI mode](img/7522_03_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get a confirmation dialog box with three types of reset options as
    discussed earlier; let's select **Hard** and click on the **OK** button, as shown
    in the following screenshot:![Time for action – reset using GUI mode](img/7522_03_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gitk should automatically reload to show you the altered history of our repository.
    If it does not reload by itself we can manually do it by selecting the **File**
    | **Reload** option or pressing *Ctrl* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time for action – reset using CLI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Resetting can be done by using the following commands in the CLI mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – reset using CLI mode](img/7522_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Git log` is used to get to know the commit ID of the particular commit that
    you want to reset and the command `git reset --hard your_commitid` is to convey
    to Git that you want to reset all changes that have happened after the commit
    mentioned by its ID.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations! We have successfully reset our repository to an earlier state
    permanently. You can verify this by checking the content of your files and logs
    of your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Git is a continuous learning platform. No matter how good you are with it already,
    the chances are you will learn something new every time you use it because there
    are multiple ways of doing things. Any command you will need to get started with
    Git CLI to perform basic operations always has the following pattern: `git operation_keyword
    parameters and/or values`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we say that almost all operations are local/offline in Git, we mean it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Git has a built-in help module that can help you whenever you are unsure about
    the usage of a specific command or even the command itself. You can immediately
    refer to the built-in documentation by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git help` to get a list of command-line parameters and most commonly used
    operation keywords with description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git help operation_keyword` to get a complete reference sheet of that particular
    operation keyword opened in your default browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a go hero – try out the help module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try listing out the commonly used Git commands, pick one command, and try opening
    up the helper page for it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to do the following in both the GUI and CLI modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Initiate a repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add files to our repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore unwanted files being added to our repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit the new files/changes in existing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out to previous commits in case we need to refer old data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset the repository to permanently travel back to an earlier recorded state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the built-in help modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Very soon you will learn how to do the following and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintain multiple environments and switch between them as though they are logged
    into multiple user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue making changes from a previous commit, thereby maintaining multiple
    routes (technically called branches) from one source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
