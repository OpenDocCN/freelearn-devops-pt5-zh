<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Simple Playbooks</h1></div></div></div><p>Ansible can be used as a command-line tool for making small changes. However, its real power lies in its scripting abilities. While setting up machines, we almost always need to do more than one thing at a <a id="id63" class="indexterm"/>time. Ansible uses a concept named <strong>playbook</strong> to do this. Using playbooks, we can perform many actions at once, and across multiple systems. They provide a way to orchestrate deployments, ensure a consistent configuration, or simply perform a common task.</p><p>Playbooks are expressed <a id="id64" class="indexterm"/>in <strong>YAML,</strong> and for the most part, Ansible uses a standard YAML parser. This means that we have all the features of YAML available to us as we write them. For example, we can use the same commenting system in playbook as we <a id="id65" class="indexterm"/>would in YAML. Many lines of a playbook can also be written and represented in YAML data types. See <a class="ulink" href="http://www.yaml.org/">http://www.yaml.org/</a> for more information.</p><p>Playbooks also open up many opportunities. They allow us to carry the state from one command to the other. For example, we can grab the content of a file on one machine, register it as a variable, and then use the value on another machine. This allows us to make complex deployment mechanisms that will be impossible with the Ansible command alone. Additionally, since each module tries to be idempotent, we should be able to run a playbook several times and changes will only be made if they need to be.</p><p>The command to execute a playbook is <code class="literal">ansible-playbook</code>. It accepts arguments similar to the Ansible command-line tool. For example, <code class="literal">-k</code> (<code class="literal">--ask-pass</code>) and <code class="literal">-K</code> (<code class="literal">--ask-sudo</code>) make Ansible prompt for the SSH and sudo passwords, respectively; <code class="literal">-u</code> can be used to set the user to use for SSH. However, these options can also be set inside the playbooks themselves in the target section. For example, to use the play named <code class="literal">example-play.yml</code>, we can use the following command:</p><div><pre class="programlisting">
<strong>$ ansible-playbook example-play.yml</strong>
</pre></div><p>The Ansible playbooks are <a id="id66" class="indexterm"/>made up of one or more plays. A play consists of three sections:</p><div><ul class="itemizedlist"><li class="listitem">The <strong>target section</strong> <a id="id67" class="indexterm"/>defines the hosts on which the play will be run, and how it will be run. This is where we set the SSH username and other SSH-related settings.</li><li class="listitem">The <strong>variable section</strong> <a id="id68" class="indexterm"/>defines variables, which will be made available to the play while running.</li><li class="listitem">The <strong>task section</strong> lists all <a id="id69" class="indexterm"/>the modules in the order we want them to be run by Ansible.</li></ul></div><p>We can include as many plays as we want in a single YAML file. YAML files start with <code class="literal">---</code> and contain many key values and lists. In YAML line indentation is used to indicate variable nesting to the parser, which also makes the file easier to read.</p><p>A full example of an Ansible play looks like the following code snippet:</p><div><pre class="programlisting">---
- hosts: webservers
  user: root
  vars:
    apache_version: 2.6
    motd_warning: 'WARNING: Use by ACME Employees ONLY'
    testserver: yes
  tasks:
    - name: setup a MOTD
      copy:
        dest: /etc/motd
        content: "{{ motd_warning }}"</pre></div><p>In the next few sections, we will examine each section and explain in detail how they work.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>The target section</h1></div></div></div><p>The target section <a id="id70" class="indexterm"/>looks like the following code snippet:</p><div><pre class="programlisting">- hosts: webservers
  user: root</pre></div><p>This is an incredibly simple version, but likely to be all we need in most cases. Each play exists within a list. As per the YAML syntax, the line must start with a dash. The hosts that a play will be run on must be set in the value of <code class="literal">hosts</code>. This value uses the same syntax as the one used when selecting hosts using the Ansible command line, which we discussed in the previous chapter. The host-pattern-matching features of Ansible were also discussed in the previous chapter. In the next line, the user tells the Ansible playbook which user to connect to the machine as.</p><p>The other lines that we can provide in this section are as follows:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Name</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">sudo</code>
</p>
</td><td valign="top">
<p>Set this <a id="id71" class="indexterm"/>to <code class="literal">yes</code> if you want Ansible to use <code class="literal">sudo</code> to <a id="id72" class="indexterm"/>become the root once it is connected to the machines in the play.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">user</code>
</p>
</td><td valign="top">
<p>This defines the <a id="id73" class="indexterm"/>username to connect to the machine originally, before running <code class="literal">sudo</code> if configured.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">sudo_user</code>
</p>
</td><td valign="top">
<p>This is the user that <a id="id74" class="indexterm"/>Ansible will try and become using <code class="literal">sudo</code>. For example, if we set <code class="literal">sudo</code> to <code class="literal">yes</code> and <code class="literal">user</code> to <code class="literal">daniel</code>, setting <code class="literal">sudo_user</code> to <code class="literal">kate</code> will cause Ansible to use <code class="literal">sudo</code> to get from <code class="literal">daniel</code> to <code class="literal">kate</code> once logged in. If you were doing this in an interactive SSH session, we could use <code class="literal">sudo -u kate</code> while you are logged in as <code class="literal">daniel</code>.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">connection</code>
</p>
</td><td valign="top">
<p>This allows us to <a id="id75" class="indexterm"/>tell Ansible what transport to use to connect to the remote host. We will mostly use <code class="literal">ssh</code> or <code class="literal">paramiko</code> for remote hosts. However, we could also use <code class="literal">local</code> to avoid a connection overhead when running things on the <code class="literal">localhost</code>. Most of the time we will be using either <code class="literal">local</code>, <code class="literal">winrm</code> or <code class="literal">ssh</code> here.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">gather_facts</code>
</p>
</td><td valign="top">
<p>Ansible will <a id="id76" class="indexterm"/>automatically run the setup module <a id="id77" class="indexterm"/>on the remote hosts unless we tell it not to. If we don't need the variables from the setup module, we could set this now and save some time.</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>The variable section</h1></div></div></div><p>Here, we can define <a id="id78" class="indexterm"/>variables that apply to the entire play on all machines. We can also make Ansible prompt for variables if they weren't supplied on the command line. This allows us to make easily maintainable plays, and prevents us from changing the same thing in several parts of the play. This also allows us to have the entire configuration for the play stored at the top, where we can easily read and modify it without worrying about what the rest of the play does.</p><p>Variables in this section of a play can be overridden by machine facts (those that are set by modules), but they themselves override the facts we set in our inventory. So they are useful to define defaults that we might collect in a module later, but they can't be used to keep defaults for inventory variables as they will override those defaults.</p><p>Variable declarations, which happen in the <code class="literal">vars</code> section, look like the values in the target section and contain a YAML dictionary or a list. An example looks like the following code snippet:</p><div><pre class="programlisting">vars:
  apache_version: 2.6
  motd_warning: 'WARNING: Use by ACME Employees ONLY'
  testserver: yes</pre></div><p>Variables can also be loaded from external YAML files by giving Ansible a list of variable files to load. This is done in a similar way using the <code class="literal">vars_files</code> directive. Then simply provide the name of another YAML file that contains its own dictionary. This means that instead of storing the variables in the same file, they can be stored and distributed separately, allowing us to share our playbook with others.</p><p>Using <code class="literal">vars_files</code>, the files look like the following code snippet in our playbook:</p><div><pre class="programlisting">vars_files:
  conf/country-AU.yml
  conf/datacenter-SYD.yml
  conf/cluster-mysql.yml</pre></div><p>In the previous example, Ansible looks for <code class="literal">country-AU.yml</code>, <code class="literal">datacenter-SYD.yml</code>, and <code class="literal">cluster-mysql.yml</code> in the <code class="literal">conf</code> folder relative to the playbook path. Each YAML file looks similar to the <a id="id79" class="indexterm"/>following code snippet:</p><div><pre class="programlisting">---
ntp: ntp1.au.example.com
TZ: Australia/Sydney</pre></div><p>Finally, we can make Ansible ask the user for each variable interactively. This is useful when we have variables that we don't want to make available for automation, and instead require human input. One example where this is useful is when prompting for the passphrases used to decrypt secret keys for the HTTPS servers.</p><p>We can instruct Ansible to prompt for variables with the following code snippet:</p><div><pre class="programlisting">vars_prompt:
  - name: https_passphrase
    prompt: Key Passphrase
    private: yes</pre></div><p>In the previous example, <code class="literal">https_passphrase</code> is where the entered data will be stored. The user will be prompted with <code class="literal">Key Passphrase</code>, and because <code class="literal">private</code> is set to <code class="literal">yes</code>, the value will not be printed on the screen as the user enters it.</p><p>We can use variables, facts, and inventory variables with the help of <code class="literal">{{ variablename }}</code>. We can even refer to complex variables, such as dictionaries, with a dotted notation. For example a variable named <code class="literal">httpd</code>, with a key in it named <code class="literal">maxclients</code>, will be accessed as <code class="literal">{{ httpd.maxclients }}</code>. This works with facts from the setup module too. For example, we can get the IPv4 address of a network interface named <code class="literal">eth0</code> using <code class="literal">{{ ansible_eth0.ipv4.address }}</code>.</p><p>Variables that are set in the variable section do not survive between different plays in the same playbook. However, facts gathered by the setup module or set by <code class="literal">set_fact</code> do. This means if we are running a second play on the same machines, or a subset of the machines in an earlier play, we can set <code class="literal">gather_facts</code> in the target section to <code class="literal">false</code>. The <code class="literal">setup</code> module can sometimes take a while to run, so this can dramatically speed up plays, especially in plays where the serial is set to a low value.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The task section</h1></div></div></div><p>The task section is the <a id="id80" class="indexterm"/>last section of each play. It contains a list of actions that we want Ansible to perform in the order we want them to be performed. There are several styles in which we can express each module's arguments. We suggest you try to stick with one as much as possible, and use the others only when required. This makes our playbooks easier to read and maintain. The following code snippet is what a task section looks like with all three styles shown:</p><div><pre class="programlisting">tasks:
  - name: install apache
    action: yum name=httpd state=installed

  - name: configure apache
    copy: src=files/httpd.conf dest=/etc/httpd/conf/httpd.conf

  - name: restart apache
    service:
      name: httpd
      state: restarted</pre></div><p>Here we see the three different styles of syntax being used to install, configure, and start the Apache web server as it will look on a CentOS machine. The first task shows us how to install Apache using the original syntax, which requires us to call the module as the first keyword inside an <code class="literal">action</code> key. The second task copies Apache's configuration file into place using the second style of the task. In this style, use the module name in place of the <code class="literal">action</code> keyword and its value simply becomes its argument. Finally, the last task, the third style, shows how to use the service module to restart Apache. In this style, we use the module name as the key, as usual, but we supply the arguments as a YAML dictionary. This can come in handy when we are providing a large number of arguments to a single module, or if the module wants the arguments in a complex form, such as the cloud formation module. The latter style is quickly becoming the preferred way of writing playbooks, as an increasing number of modules require complex arguments. In this book, we will be using this style in order to save space for the examples and prevent line wrapping.</p><p>Note that names are not required for tasks. However, they make good documentation and allow us to refer to each task later on, if required. This will become useful especially when we come to handlers. The names are also outputted to the console when the playbook is run, so that the user can tell what is happening. If we don't provide a name, Ansible will just use the action line of the task or the handler.</p><div><h3 class="title"><a id="note03"/>Note</h3><p>Unlike other configuration management tools, Ansible does not provide a fully featured dependency system. This is a blessing and a curse; with a complete dependency system, we can get to a point where we are never quite sure what changes will be applied to a particular machine. Ansible, however, does guarantee that our changes will be executed in the order they are written. So, if one module depends on <a id="id81" class="indexterm"/>another module that is executed before it, simply place one before the other in the playbook.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The handlers section</h1></div></div></div><p>The handlers section is <a id="id82" class="indexterm"/>syntactically the same as the task section and supports the same format for calling modules. Handlers are called only when the task they were called from, records that something changed during execution. To trigger a handler, add a notify key to the task with the value set to the name of the task.</p><p>Handlers are run if previously triggered when Ansible has finished running the task list. They are run in the order that they are listed in the handlers section, and even if they are called multiple times in the task section, they will run only once. This is often used to restart <a id="id83" class="indexterm"/>daemons after they have been upgraded and configured. The following play demonstrates how we will upgrade an <strong>ISC</strong> <strong>DHCP</strong> (<strong>Dynamic Host Configuration Protocol</strong>) server to the latest version, configure it, and set it to start at boot. If this playbook is run on a server where the ISC DHCP daemon is already running the latest version and the config files are not changed, the handler will not be called and DHCP will not be restarted. Consider the following code for example:</p><div><pre class="programlisting">---
- hosts: dhcp
  tasks:
  - name: update to latest DHCP
    yum
      name: dhcp
      state: latest
    notify: restart dhcp

  - name: copy the DHCP config
    copy:
      src: dhcp/dhcpd.conf
      dest: /etc/dhcp/dhcpd.conf
    notify: restart dhcp

  - name: start DHCP at boot
    service:
      name: dhcpd
      state: started
      enabled: yes

  handlers:
  - name: restart dhcp
    service:
      name: dhcpd
      state: restarted</pre></div><p>Each handler can only be a single module, but we can notify a list of handlers from a single task. This allows us to trigger many handlers from a single step in the task list. For example, if we have just checked out a newer version of any Django application, we can set a handler to migrate the database, deploy the static files, and restart Apache. We can do this by simply using a YAML list on the notify action. This might look something like the following code snippet:</p><div><pre class="programlisting">---
- hosts: qroud
  tasks:
  - name: checkout Qroud
    git:
      repo:git@github.com:smarthall/Qroud.git
      dest: /opt/apps/Qroud force=no
    notify:
      - migrate db
      - generate static
      - restart httpd

  handlers:
  - name: migrate db
    command: ./manage.py migrate –all
    args:
      chdir: /opt/apps/Qroud

  - name: generate static
    command: ./manage.py collectstatic -c –noinput
    args:
       chdir: /opt/apps/Qroud

  - name: restart httpd
    service:
      name: httpd
      state: restarted</pre></div><p>We can see that the <code class="literal">git</code> <a id="id84" class="indexterm"/>module is used to check out some public GitHub code, and if that caused anything to change, it triggers the <code class="literal">migrate db</code>, <code class="literal">generate static</code>, and <code class="literal">restart httpd</code> actions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>The playbook modules</h1></div></div></div><p>Using modules in <a id="id85" class="indexterm"/>playbooks is a little bit different from using them in the command line. This is mainly because we have many facts available from the previous modules and the <code class="literal">setup</code> module. Certain modules don't work in the Ansible command line because they require access to those variables. Other modules will work in the command-line version, but are able to provide enhanced functionalities when used in a playbook.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>The template module</h2></div></div></div><p>One of the most frequently <a id="id86" class="indexterm"/>used examples of a module that requires <a id="id87" class="indexterm"/>facts from Ansible is the <code class="literal">template</code> module. This module allows us to design an outline of a configuration file and then have Ansible insert values in the right places. To perform this, Ansible uses the Jinja2 templating language. In reality, the Jinja2 templates can be much more complicated than this, including things such as conditionals, <code class="literal">for</code> loops, and macros. The following is an example of a Jinja2 configuration template for configuring BIND:</p><div><pre class="programlisting"># {{ ansible_managed }}
options {
  listen-on port 53 {
    127.0.0.1;
    {% for ip in ansible_all_ipv4_addresses %}
      {{ ip }};
    {% endfor %}
  };
  listen-on-v6 port 53 { ::1; };
  directory       "/var/named";
  dump-file       "/var/named/data/cache_dump.db";
  statistics-file "/var/named/data/named_stats.txt";
  memstatistics-file "/var/named/data/named_mem_stats.txt";
};

zone "." IN {
  type hint;
  file "named.ca";
};

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";

{# Variables for zone config #}
{% if 'authorativenames' in group_names %}
  {% set zone_type = 'master' %}
  {% set zone_dir = 'data' %}
{% else %}
  {% set zone_type = 'slave' %}
  {% set zone_dir = 'slaves' %}
{% endif %}

zone "internal.example.com" IN {
  type {{ zone_type }};
  file "{{ zone_dir }}/internal.example.com";
  {% if 'authorativenames' not in group_names %}
    masters { 192.168.2.2; };
  {% endif %}
};</pre></div><p>By convention, Jinja2 <a id="id88" class="indexterm"/>templates are named with the file extension of <code class="literal">.j2</code>; however, this is not strictly required. Now let's break this example down into its parts. The <a id="id89" class="indexterm"/>example starts with the following line of code:</p><div><pre class="programlisting"># {{ ansible_managed }}</pre></div><p>This line adds a comment at the top of the file that shows which template the file came from, the host, modification time of the template, and the owner. Putting this somewhere in the template as a comment is a good practice, and it ensures that people know what they should edit if they wish to alter it permanently.</p><p>Later, on the fifth line, there is a <code class="literal">for</code> loop:</p><div><pre class="programlisting">    {% for ip in ansible_all_ipv4_addresses %}
      {{ ip }};
    {% endfor %}</pre></div><p>
<code class="literal">For</code> loops go through all the elements of a list once for each item in the list. They optionally assign the item to the variable of our choice so that we can use it inside the loop. This one loops across all the values in <code class="literal">ansible_all_ipv4_addresses</code>, which is a list provided by the <code class="literal">setup</code> module that contains all the IPv4 addresses that the machine has. Inside the <code class="literal">for</code> loop, it simply adds each of them into the configuration to make sure BIND will listen on that interface.</p><p>Comments are also possible in templates such as the one on line 24:</p><div><pre class="programlisting">{# Variables for zone config #}</pre></div><p>Anything in between <code class="literal">{#</code> and <code class="literal">#}</code> is simply ignored by the Jinja2 template processor. This allows us to add comments in the template that do not make it into the final file. This is especially handy if we are <a id="id90" class="indexterm"/>doing something complicated, setting variables within the <a id="id91" class="indexterm"/>template, or if the configuration file does not allow comments.</p><p>The next few lines are part of an <code class="literal">if</code> statement, which sets up <code class="literal">zone_type</code> and <code class="literal">zone_dir</code> variables for use later in the template:</p><div><pre class="programlisting">{% if 'authorativenames' in group_names %}
  {% set zone_type = 'master' %}
  {% set zone_dir = 'data' %}
{% else %}
  {% set zone_type = 'slave' %}
  {% set zone_dir = 'slaves' %}
{% endif %}</pre></div><p>Anything between <code class="literal">{% if %}</code> and <code class="literal">{% else %}</code> is ignored if the statement in the <code class="literal">if</code> tag is <code class="literal">false</code>. Here we check whether the value <code class="literal">authorativenames</code> is in the list of group names that apply to this host. If this is <code class="literal">true</code>, the next two lines are set two custom variables. <code class="literal">zone_type</code> is set to master and <code class="literal">zone_dir</code> is set to data. If this host is not in the <code class="literal">authorativenames</code> group, <code class="literal">zone_type</code> and <code class="literal">zone_dir</code> will be set to <code class="literal">slave</code> and <code class="literal">slaves</code>, respectively.</p><p>Finally, starting at line 33, we provide the actual configuration for the zone:</p><div><pre class="programlisting">zone "internal.example.com" IN {
  type {{ zone_type }};
  file "{{ zone_dir }}/internal.example.com";
  {% if zone_type == 'slave' %}
    masters { 192.168.2.2; };
  {% endif %}
};</pre></div><p>We set the type to the <code class="literal">zone_type</code> variable we created earlier, and the location to <code class="literal">zone_dir</code>. Finally we check whether the zone type is a slave, and if it is, we configure its master to a particular IP address.</p><p>To get this template to set up an authoritative nameserver, we need to create a group in our inventory file named <code class="literal">authorativenames</code> and add some hosts under it. How to do this was discussed back in <a class="link" title="Chapter 1. Getting Started with Ansible" href="part0014.xhtml">Chapter 1</a>, <em>Getting Started with Ansible</em>.</p><p>We can simply call the <code class="literal">templates</code> module and the facts from the machines will be sent through, including the <a id="id92" class="indexterm"/>groups the machine is in. This is as simple as calling any <a id="id93" class="indexterm"/>other module. The <code class="literal">template</code> module also accepts similar arguments to the <code class="literal">copy</code> module such as owner, group, and mode. Consider the following code for example:</p><div><pre class="programlisting">---
- name: Setup BIND
  host: allnames
  tasks:
  - name: configure BIND
    template: src=templates/named.conf.j2 dest=/etc/named.conf owner=root group=named mode=0640</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>The set_fact module</h2></div></div></div><p>The <code class="literal">set_fact</code> module <a id="id94" class="indexterm"/>allows us to build our own facts on the machine inside an Ansible play. These facts can then be used inside templates or as variables in the playbook. Facts act just like arguments that come from modules such as the <a id="id95" class="indexterm"/>
<code class="literal">setup</code> module, in that they work on a per-host basis. We should use this to avoid putting complex logic into templates. For example, if we are trying to configure a buffer to take a certain percentage of RAM, we should calculate the value in the playbook.</p><p>The following example shows how to use <code class="literal">set_fact</code> to configure a MySQL server to have an InnoDB buffer size of approximately half of the total RAM available on the machine:</p><div><pre class="programlisting">---
- name: Configure MySQL
  hosts: mysqlservers
  tasks:
  - name: install MySql
    yum:
      name: mysql-server
      state: installed

  - name: Calculate InnoDB buffer pool size
    set_fact:
      innodb_buffer_pool_size_mb="{{ansible_memtotal_mb/2}}"

  - name: Configure MySQL
    template:
      src: templates/my.cnf.j2
      dest: /etc/my.cnf
      owner: root
      group: root
      mode: 0644
    notify: restart mysql

  - name: Start MySQL
    service:
      name: mysqld
      state: started
      enabled: yes

  handlers:
  - name: restart mysql
    service:
      name: mysqld
      state: restarted</pre></div><p>The first task here simply installs MySQL using yum. The second task creates a fact by getting the total memory of the managed machine, dividing it by two, losing any non-integer remainder, and putting it in a fact called <code class="literal">innodb_buffer_pool_size_mb</code>. The next line then loads a template into <code class="literal">/etc/my.cnf</code> to configure MySQL. Finally, MySQL is started and set to <a id="id96" class="indexterm"/>start at boot time. A handler is also included to restart MySQL when its configuration changes.</p><p>The template then only <a id="id97" class="indexterm"/>needs to get the value of <code class="literal">innodb_buffer_pool_size</code> and place it into the configuration. This means we can re-use the same template in places where the buffer pool should be one-fifth of the RAM, or one-eighth, and simply change the playbook for those hosts. In this case, the template will look something like the following code snippet:</p><div><pre class="programlisting"># {{ ansible_managed }}
[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
# Settings user and group are ignored when systemd is used.
# If we need to run mysqld under a different user or group,
# customize our systemd unit file for mysqld according to the
# instructions in http://fedoraproject.org/wiki/Systemd

# Configure the buffer pool
innodb_buffer_pool_size = {{ innodb_buffer_pool_size_mb|default(128) }}M

[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid</pre></div><p>We can see that in the previous template, we are simply putting the variables we get from the play into the <a id="id98" class="indexterm"/>template. If the template doesn't see the <code class="literal">innodb_buffer_pool_size_mb</code> fact, it simply <a id="id99" class="indexterm"/>uses a default of <code class="literal">128</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>The pause module</h2></div></div></div><p>The <code class="literal">pause</code> module stops <a id="id100" class="indexterm"/>the execution of a playbook for a certain period of time. We can configure it to wait for a particular period, or we can make it prompt for the user to continue. While effectively useless when used from the Ansible command line, it can be very handy when used inside a playbook.</p><p>Generally, the <code class="literal">pause</code> <a id="id101" class="indexterm"/>module is used when we want the user to provide confirmation to continue, or if manual intervention is required at a particular point. For example, if we have just deployed a new version of a web application to a server, and we need to have the user check manually to make sure it looks okay before we configure them to receive production traffic, we can put a pause there. It is also handy to warn the user of a possible problem and give them the option of continuing. This will make Ansible print out the names of the servers and ask the user to press <em>Enter</em> to continue. If used with the serial key in the target section, it will ask once for each group of hosts that Ansible is running on. This way we can give the user the flexibility of running the deployment at our own pace while they interactively monitor the progress.</p><p>Less usefully, this module can simply wait for a specified period of time. This is not useful always as we usually don't know how long a particular action might take, and guessing might have disastrous outcomes. We should not use it for waiting for networked daemons to start up; instead we should use the <code class="literal">wait_for</code> module (described in the next section) for this task. The following play demonstrates using the <code class="literal">pause</code> module first in the user interactive mode and then in the timed mode:</p><div><pre class="programlisting">---
- hosts: localhost
  tasks:
  - name: wait on user input
    pause:
      prompt: "Warning! Press ENTER to continue or CTRL-C to quit."

  - name: timed wait
    pause:
      seconds: 30</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>The wait_for module</h2></div></div></div><p>The <code class="literal">wait_for</code> <a id="id102" class="indexterm"/>module is used to poll a particular TCP <a id="id103" class="indexterm"/>port and not continue until that port accepts a remote connection. The polling is done from the remote machine. If we only provide a port, or set the host argument to <code class="literal">localhost</code>, the poll will try to connect to the managed machine. We can utilize <code class="literal">local_action</code> to run the command from the controller machine and use the <code class="literal">ansible_hostname</code> variable as our host argument to make it try and connect to the managed machine from the controller machine.</p><p>This module is particularly useful for daemons that can take a while to start, or things that we want to run in the background. Apache Tomcat ships with an init script, which immediately returns when we try to start it, leaving Tomcat starting in the background. Depending on the application that Tomcat is configured to load, it might take anywhere between two seconds to 10 minutes to fully start up and be ready for connections. We can time our application's start up and use the <code class="literal">pause</code> module. However, the next deployment might take longer or shorter, and this will break our deployment mechanism. With the <code class="literal">wait_for</code> module, we <a id="id104" class="indexterm"/>have Ansible to recognize when <a id="id105" class="indexterm"/>Tomcat is ready to accept connections. The following is a play that does exactly this:</p><div><pre class="programlisting">---
- hosts: webapps
  tasks:
  - name: Install Tomcat
    yum:
      name: tomcat7
      state: installed

  - name: Start Tomcat
    service:
      name: tomcat7
      state: started

  - name: Wait for Tomcat to start
    wait_for:
      port: 8080
      state: started</pre></div><p>After the completion of this play, Tomcat should be installed, started, and ready to accept requests. We can append further modules to this example and depend on Tomcat being available and listening.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The assemble module</h2></div></div></div><p>The <code class="literal">assemble</code> <a id="id106" class="indexterm"/>module combines several files on the managed machine and saves them to another file on the managed machine. This is useful in <a id="id107" class="indexterm"/>playbooks when we have a <code class="literal">config</code> file which does not allow includes or globbing in its includes. This is useful for the <code class="literal">authorized_keys</code> file for say, the root user. The following play will send a bunch of SSH public keys to the managed machine, then make it assemble them all together and place it in the root user's home directory:</p><div><pre class="programlisting">---
- hosts: all
  tasks:
  - name: Make a Directory in /opt
    file:
      path: /opt/sshkeys
      state: directory
      owner: root
      group: root
      mode: 0700

  - name: Copy SSH keys over
    copy:
      src: "keys/{{ item }}.pub"
      dest: "/opt/sshkeys/{{ item }}.pub"
      owner: root
      group: root
      mode: 0600
    with_items:
      - dan
      - kate
      - mal

  - name: Make the root users SSH config directory
    file:
      path: /root/.ssh
      state: directory
      owner: root
      group: root
      mode: 0700

  - name: Build the authorized_keys file
    assemble:
      src: /opt/sshkeys
      dest: /root/.ssh/authorized_keys
      owner: root
      group: root
      mode: 0700</pre></div><p>By now, this should all look familiar. We might note the <code class="literal">with_items</code> key in the task that copies the keys over, and the <code class="literal">{{ items }}</code> variable. These will be explained later in <a class="link" title="Chapter 3. Advanced Playbooks" href="part0028.xhtml">Chapter 3</a>, <em>Advanced Playbooks</em>, but all we need to know now is that whatever item we supply to the <code class="literal">with_items</code> key is substituted into the <code class="literal">{{ items }}</code> variable, similar to how a <code class="literal">for</code> loop works. This simply lets us easily copy many files to the remote host at once.</p><p>The last task <a id="id108" class="indexterm"/>shows the usage of the <code class="literal">assemble</code> module. We <a id="id109" class="indexterm"/>pass the directory containing the files to be concatenated into the output as the <code class="literal">src</code> argument, and then pass <code class="literal">dest</code> as the output file. It also accepts many of the same arguments (<code class="literal">owner</code>, <code class="literal">group</code>, and <code class="literal">mode</code>) as the other modules that create files. It also combines the files in the same order as the <code class="literal">ls -1</code> command lists them. This means we can use the same approach as <code class="literal">udev</code> and <code class="literal">rc.d</code>, and prepend numbers to the files to ensure that they end up in the correct order.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>The add_host module</h2></div></div></div><p>The <code class="literal">add_host</code> <a id="id110" class="indexterm"/>module is one of the most powerful modules that are available in playbooks. <code class="literal">add_host</code> lets us dynamically add new machines inside a play. We can do this using the <code class="literal">uri</code> module to get a host from our <strong>Configuration Management Database</strong> (<strong>CMDB</strong>) and then adding it to the current play. This module will also add our host to a group, dynamically creating that group if it does not already exist.</p><p>The module simply takes a <code class="literal">name</code> and a <code class="literal">groups</code> argument, which are rather self-explanatory, and sets <a id="id111" class="indexterm"/>the hostname and groups. We can also send extra arguments, and these are treated in the same way in which extra values in the inventory file are treated. This means we can set <code class="literal">ansible_ssh_user</code>, <code class="literal">ansible_ssh_port</code>, and so on.</p><p>If we are using a cloud provider, such as RackSpace or Amazon EC2, there are modules available in Ansible <a id="id112" class="indexterm"/>that will let us manage our compute resources. We might decide to create machines at the start of the play, if we can't find them in the inventory. If we do this, we can use this module to add the machines to the inventory so that we can configure them later. Here is an example of using Google Compute Modules to do this:</p><div><pre class="programlisting">---
- name: Create infrastructure
  hosts: localhost
  connection: local
  tasks:
    - name: Make sure the mailserver exists
      gce:
        image: centos-6
        name: mailserver
        tags: mail
        zone: us-central1-a
      register: mailserver
      when: '"mailserver" not in groups.all'

    - name: Add new machine to inventory
      add_hosts:
        name: mailserver
        ansible_ssh_host: "{{ mailserver.instance_data[0].public_ip }}"
        groups: tag_mail
      when: not mailserver|skipped</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>The group_by module</h2></div></div></div><p>In addition to <a id="id113" class="indexterm"/>creating hosts dynamically in our play, we can also <a id="id114" class="indexterm"/>create groups. The <code class="literal">group_by</code> module can create groups based on the facts about the machines, including the ones we set up ourselves using the <code class="literal">add_fact</code> module explained earlier. The <code class="literal">group_by</code> module accepts one argument, <code class="literal">key</code>, which takes the name of a group the machine will be added to. By combining this with the use of variables, we can make the module add a server to a group based on its operating system, virtualization technology, or any other fact that we have access to. We can then use this group in the target section of any subsequent plays, or in templates.</p><p>So if we want to create a group that groups the hosts by the operating system, we will call the module as follows:</p><div><pre class="programlisting">---
- name: Create operating system group
  hosts: all
  tasks:
    - group_by: key=os_{{ ansible_distribution }}

- name: Run on CentOS hosts only
  hosts: os_CentOS
  tasks:
  - name: Install Apache
    yum: name=httpd state=latest

- name: Run on Ubuntu hosts only
  hosts: os_Ubuntu
  tasks:
  - name: Install Apache
    apt: pkg=apache2 state=latest</pre></div><p>We can then use these groups to install packages using the right packager. In practice, this is often used to avoid Ansible outputting lots of "skipped" messages while it is executing. Instead of adding <code class="literal">when</code> clauses to each task that needs to be skipped, we can create a group for machines where the action should happen and then use a separate play to configure those <a id="id115" class="indexterm"/>machines separately. Here is an example of <a id="id116" class="indexterm"/>installing an ssl private key across Debian and RedHat machines without using a <code class="literal">when</code> clause:</p><div><pre class="programlisting">---
- name: Catergorize hosts
  hosts: all
  tasks:
    - name: Gather hosts by OS
      group_by:
        key: "os_{{ ansible_os_family }}"

- name: Install keys on RedHat
  hosts: os_RedHat
  tasks:
    - name: Install SSL certificate
      copy:
        src: sslcert.pem
        dest: /etc/pki/tls/private/sslcert.pem

- name: Install keys on Debian
  hosts: os_Debian
  tasks:
    - name: Install SSL certificate
      copy:
        src: sslcert.pem
        dest: /etc/ssl/private/sslcert.pem</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>The slurp module</h2></div></div></div><p>The <code class="literal">slurp</code> <a id="id117" class="indexterm"/>module grabs a file from the remote system, encodes it with base 64, and then returns the result. We can utilize the register keyword in order to place the contents into a fact. When using the <code class="literal">slurp</code> module to fetch files, we should <a id="id118" class="indexterm"/>be wary of the file size. This module loads the entire file into memory, so using <code class="literal">slurp</code> with large files can consume all available RAM and cause our system to crash. Files also need to be transferred from the managed machine to the controller machine, and for large files, this could take a considerable amount of time.</p><p>Combining this module with the copy module provides a way to copy files between two machines. This is demonstrated in the following playbook:</p><div><pre class="programlisting">---
- name: Fetch a SSH key from a machine
  hosts: bastion01
  tasks:
    - name: Fetch key
      slurp:
        src: /root/.ssh/id_rsa.pub
      register: sshkey

- name: Copy the SSH key to all hosts
  hosts: all
  tasks:
    - name: Make directory for key
      file:
        state: directory
        path: /root/.ssh
        owner: root
        group: root
        mode: 0700

    - name: Install SSH key
      copy:
        contents: "{{ hostvars.bastion01.sshkey|b64decode }}"
        dest: /root/.ssh/authorized_keys
        owner: root
        group: root
        mode: 0600</pre></div><div><h3 class="title"><a id="note04"/>Note</h3><p>Note that <a id="id119" class="indexterm"/>because the <code class="literal">slurp</code> module encodes the data with base 64, we have to use the jinja2 filter named <code class="literal">b64decode</code> to decode the data before the copy module can use it. Filters will be covered in more detail in <a class="link" title="Chapter 3. Advanced Playbooks" href="part0028.xhtml">Chapter 3</a>, <em>Advanced Playbooks</em>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Windows playbook modules</h1></div></div></div><p>Windows support is <a id="id120" class="indexterm"/>new to Ansible and as such, there aren't many modules available for it. Modules that are windows only are named beginning with <code class="literal">win_</code>. There are also a few modules available, which work on both Windows and Unix systems such as the <code class="literal">slurp</code> module, which we covered earlier.</p><p>Extra care should be taken in Windows modules to quote the path strings. Backslashes are an important character in both YAML, where they escape characters and in windows paths, where they denote directories. Because of this, YAML might confuse parts of our paths for escape sequences. To prevent this, we use single quotes on our strings. Additionally, if our path is a directory itself, we should leave off the trailing backspace so that YAML doesn't confuse the end of the string with an escape sequence. If we have to end our path with a backslash, make it a double backslash, and the second one will be ignored. The following are some examples of correct and incorrect strings:</p><div><pre class="programlisting"># Correct
'C:\Users\Daniel\Documents\secrets.txt'
'C:\Program Files\Fancy Software Inc\Directory'
'D:\\' # \\ becomes \
# Incorrect
"C:\Users\Daniel\newcar.jpg" # \n becomes a new line
'C:\Users\Daniel\Documents\' # \' becomes '</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Cloud Infrastructure modules</h1></div></div></div><p>Infrastructure <a id="id121" class="indexterm"/>modules allow us to not only manage the setup of our machines, but also the creation of those machines themselves. Apart from this, we can also automate much of the infrastructure surrounding them. This can be used as a simple replacement for services such as Amazon Cloud Formation.</p><p>When creating machines that we want to manage in a later play in the same playbook, we will want to use the <code class="literal">add_hosts</code> module that we discussed earlier in the chapter to add the machine to the in-memory inventory so that it can be the target of further plays. We might also wish to run the <code class="literal">group_by</code> module to arrange them into groups as we would arrange other machines. The <code class="literal">wait_for</code> module should also be used to check that the machine is responding to SSH connections before trying to manage it.</p><p>The Cloud Infrastructure modules can be a bit complicated to use, so we will be showing how to setup and install the Amazon modules. For details on how to configure the other modules, see their documentation using <code class="literal">ansible-doc</code>.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>The AWS modules</h2></div></div></div><p>The AWS modules <a id="id122" class="indexterm"/>work similar to how most AWS tools work. This is because <a id="id123" class="indexterm"/>they use the python <strong>boto </strong>library, which is popular with many other tools and follows the conventions of the original AWS tools that were released by Amazon.</p><p>It is best to install boto the same way that we installed Ansible. For most use cases, we will be running the module on the managed machine, so we will only need to install the boto module there. We can install the boto library in the following ways:</p><div><ul class="itemizedlist"><li class="listitem">Centos/RHEL/Fedora: <code class="literal">yum install python-boto</code></li><li class="listitem">Ubuntu: <code class="literal">apt-get install python-boto</code></li><li class="listitem">Pip: <code class="literal">pip install boto</code></li></ul></div><p>Then we need to setup the correct environment variables. The easiest way to do this is by running the modules <a id="id124" class="indexterm"/>using the localhost connection on our local machine. If we do this, then the variables from our shell are passed through and automatically become available to the Ansible module. Here, are the variables that the boto library uses to connect to AWS:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Variable Name</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">AWS_ACCESS_KEY</code>
</p>
</td><td valign="top">
<p>This is the access key for a valid IAM account</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">AWS_SECRET_KEY</code>
</p>
</td><td valign="top">
<p>This is the secret key corresponding to the access key above</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">AWS_REGION</code>
</p>
</td><td valign="top">
<p>This is the default region to use unless overridden</p>
</td></tr></tbody></table></div><p>We can set these environment variables in our example using the following code:</p><div><pre class="programlisting">export AWS_ACCESS_KEY="AKIAIOSFODNN7EXAMPLE"
export AWS_SECRET_KEY="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
export AWS_REGION="us-east-1"</pre></div><p>These are just example <a id="id125" class="indexterm"/>credentials and will not work. Once we have these set, we can then use the AWS modules. In the next block of code, we combine several modules from this chapter to create a machine and add it to the inventory. Several features not yet discussed, such as <code class="literal">register</code> and <code class="literal">delegate_to</code>, are used in the following example, which will be covered in <a class="link" title="Chapter 3. Advanced Playbooks" href="part0028.xhtml">Chapter 3</a>, <em>Advanced Playbooks</em>:</p><div><pre class="programlisting">---
- name: Setup an EC2 instance
  hosts: localhost
  connection: local
  tasks:
    - name: Create an EC2 machine
      ec2:
        key_name: daniel-keypair
        instance_type: t2.micro
        image: ami-b66ed3de
        wait: yes
        group: webserver
        vpc_subnet_id: subnet-59483
        assign_public_ip: yes
      register: newmachines

    - name: Wait for SSH to start
      wait_for:
        host: "{{ newmachines.instances[0].public_ip }}"
        port: 22
        timeout: 300
      delegate_to: localhost

    - name: Add the machine to the inventory
      add_host:
        hostname: "{{ newmachines.instances[0].public_ip }}"
        groupname: new

- name: Configure the new machines
  hosts: new
  sudo: yes
  tasks:
    - name: Install a MOTD
      template:
        src: motd.j2
        dest: /etc/motd</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we covered the sections that are available in the playbook file. We also learned how to use variables to make our playbooks maintainable, how to trigger handlers when changes have been made, and finally, we looked at how certain modules are more useful when used inside a playbook. You can explore further modules provided with Ansible using the official documentation at <a class="ulink" href="http://docs.ansible.com/modules_by_category.html">http://docs.ansible.com/modules_by_category.html</a>.</p><p>In the next chapter, we will be looking into the more complex features of playbooks. This will allow us to build more complex playbooks capable of deploying and configuring entire systems.</p></div></body></html>