- en: Repository Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Pruning remote branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running garbage collection manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning off automatic garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting a repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting history – changing a single file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a backup of your repositories as mirror repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick "how-to" submodule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtree merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submodule versus subtree merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll take a look at various tools used for repository maintenance.
    We'll look at how we can easily delete branches in the local repository that have
    been deleted from the remote repository. We'll also see how we can trigger garbage
    collection and how to turn it off. We'll take a look at how a repository can be
    split with the `filter-branch` command, and how the same command can be used to
    rewrite the history of a repository. Finally, we'll take a quick look at how to
    integrate other Git projects into a Git repository as subprojects, with either
    the submodule functionality or the subtree strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Pruning remote branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the development of a software project tracked by Git happens on feature
    branches, and, as time goes by, an increasing number of feature branches are merged
    to the mainline. Usually, these feature branches are deleted in the main repository
    (the origin). However, branches are not automatically deleted from all clones
    while fetching and pulling request. Git must explicitly be told to delete branches
    from the local repository that have been deleted from the origin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll set up two repositories and use one of them as a remote for the
    other. We will use the `Git-Version-Control-Second-Edition_hello_world_flow_model`
    repository, but first we''ll clone a repository to a local bare repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll clone the newly cloned repository to a local one with a working
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s delete a couple of merged feature branches in the bare repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the directory to your working copy and make sure `develop` branch
    is checked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by listing all of the branches using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to fetch or pull and see whether anything happens, using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The branches are still there, even if they have been deleted in the remote
    repository. We need to tell Git explicitly to delete the branches that have also
    been deleted from the remote repository, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The branches have now also been deleted from our local repository.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git simply checks the remote-tracking branches under the remote or origin namespace
    and removes branches that are not found on the remote any more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to remove the branches from Git that have been deleted
    from the master. It can be done while updating the local repository, as we saw
    with `git fetch --prune`, and also with `git pull --prune`. It can even be performed
    with the `git remote prune origin` command. This will also remove the branches
    from Git that are no longer available on the remote, but it will not update remote-tracking
    branches in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Running garbage collection manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Git on a regular basis, you might notice that some commands sometimes
    trigger Git to perform garbage collection and pack loose objects into a pack file
    (Git's objects storage). The garbage collection and packing of loose objects can
    also be triggered manually by executing the `git gc` command. Triggering `git
    gc` is useful if you have a lot of loose objects. A loose object can, for example,
    be a blob, a tree, or a commit. As we saw in [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*, `blob-`, `tree-`, and `commit` objects are added to Git's database
    when we add files and create commits. These objects are first stored as unreachable
    objects in Git's object storage as single files inside the `.git/objects` folder.
    Eventually, or by manual request, Git packs the loose objects into pack files,
    which can reduce disk usage. A lot  of objects can become loose after adding many
    files to Git, for example, when starting a new project or after frequent adds
    and commits. Running garbage collection will make sure that loose objects are
    packed, and objects not referred to by any reference or object will be deleted.
    The latter is useful when you have deleted some branches/commits and want to make
    sure that the objects referenced by them are also deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can trigger garbage collection and remove some objects from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need a repository to perform the garbage collection on. We''ll use
    the same repository as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll check the repository for unpacked objects; we can do this with
    the `count-objects` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also check for unreachable objects, which are objects that can''t be
    reached from any reference (tag, branch, or other object). The unreachable objects
    will be deleted when the garbage collection runs. We also check the size of the
    `.git` directory using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no unreachable objects. This is because we just cloned and haven''t
    actually worked in the repository. If we delete the origin remotely, the remote
    branches (`remotes/origin/*`) will be deleted, and we''ll lose the reference to
    some of the objects in the repository; they''ll be displayed as unreachable while
    running `fsck` and can be garbage collected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have some unreachable objects due to the deletion of the
    remote. Let''s try to trigger garbage collection manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we investigate the repository now, we will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The object count is smaller. Git has packed the objects to the pack file stored
    in the `.git/objects/pack` folder. The size of the repository is also smaller,
    as Git compresses and optimizes the objects in the pack file. However, there are
    still some unreachable objects left. This is because objects will only be deleted
    if they are older than what is specified in the `gc.pruneexpire` configuration
    option, which defaults to two weeks (`config value: 2.weeks.ago`). We can override
    the default or configured option by running the `--prune=now` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Investigating the repository gives the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The unreachable objects have been deleted, there are no loose objects, and the
    repository size is smaller now that the objects have been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git gc` command optimizes the repository by compressing file revisions
    and deleting objects that there are no references to. The objects can be commits,
    and so on. On an abandoned (deleted) branch, blobs from invocations of git add,
    commits discarded/redone with `git commit --amend`, or other commands can leave
    objects behind. Objects are, by default, already compressed with `zlib` when they
    are created and, when moved into the pack file, Git makes sure to only store the
    necessary changes. For example, if you change only a single line in a large file,
    storing the entire file in the pack file again would waste a bit of space. Instead,
    Git stores the latest file as a whole in the pack file and only the delta for
    the older version. This is pretty smart, as you are more likely to require the
    latest version of the file, and Git doesn't have to do delta calculations for
    this. This might seem like a contradiction to the information from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*, where we learned that Git stores snapshots and not deltas. However,
    remember how the snapshot is made. Git hashes all of the file content in blobs,
    makes `tree` and `commit` objects, and the commit object describes the full tree
    state with the `root-tree sha-1` hash. Storing objects inside the pack-files has
    no effect on the computation of the tree state. When you check out an earlier
    version of commit, Git makes sure the sha-1 hashes match the branch, commit, or
    tag you requested.
  prefs: []
  type: TYPE_NORMAL
- en: Turning off automatic garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automatic triggering of garbage collection can be turned off so that it
    will not run unless manually triggered. This can be useful if you are searching
    the repository for a lost commit/file and want to make sure that it is not being
    garbage collected while searching (running Git commands).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the `Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model`
    repository again for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To switch off automatic garbage collection from being triggered, we need to
    set the `gc.auto` configuration to 0\. First, we''ll check the existing setting,
    and then we can set it and verify the configuration using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try to run `git gc` with the `--auto` flag, as it will be called
    when normally triggered from an other command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, nothing happens, as the configuration disables automatic garbage
    collection. We can still trigger it manually though (without the `--auto` flag):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Splitting a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a project tracked with Git is not one logical project, but consists
    of several projects. This may be fully intentional and there is nothing wrong
    with that, but there can also be cases where projects tracked in the same Git
    repository really should belong to two different repositories. You can imagine
    a project where the code base grows and, at some point in time, one of the subprojects
    could have value as an independent project. This can be achieved by splitting
    the subfolders and/or files that contain the project that should have its own
    repository with the full history of commits touching the files and/or folders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll use the JGit repository, so we'll have some history to
    filter through. The subfolders we split into are not really projects, but serve
    well as an example for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, clone the JGit repository and create local branches of the remote ones
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the name of the current branch in a variable named `current`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following step, we create local branches from all the remote branches
    in the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we filter the branches. From all the branches (`git branch -a`), we exclude
    branches that match the `$current` variable somewhere in the name (`grep -v $current`).
    Then, we include only the branches that match the remote (`grep remotes`). Finally,
    we exclude all branches with `HEAD` (`grep -v HEAD`). For each of the branches
    (`$br`), we create a local branch with the name given after the last "`/`" in
    the full name of the branch (`git branch ${br##*/} $br`). For example, the branch
    `remotes/origin/stable-0.10` becomes the local branch `stable-0.10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll prepare a short script that will delete everything apart from the
    input to the shell script from the Git index. Save the following to the `clean-tree` file
    in the folder that contains the JGit repository (not the repository itself):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The short script filters all the files currently in the staging area (`git ls-files`), excluding
    the ones that match the input (`grep -v -E "$1"`). It lists only the first part
    of their `name/path` up to the first "`/`" (`grep -o -E "^[^/\"]"`), and finally
    sorts them by unique entries (`sort -u`). The entries in the remaining list (`$f`)
    are removed from the staging of Git (`git rm -rq --cached --ignore-unmatch $f`).
    The `--cached` option tells Git to remove them from the staging area and `--ignore-unmatched`
    tells Git not to fail if the file does not exist in the staging area. The `-rq`
    option is recursive and quiet respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The staging area contains all the files tracked by Git in the last snapshot
    (commit) and files (modified or new) you have added with `git add`. However, you
    only see differences between the latest commit and the staging area when you run
    `git status`, along with differences between the working tree and the staging
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the file executable using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to split out a subpart of the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll decide which folders and files to keep in the new repository;
    we''ll delete everything from the repository except those files. We''ll store
    the files and folders to be kept in a string separated by `|` so that we can feed
    it to `grep` as a regular expression, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to start the conversion of the repository. We'll use the `git
    filter-branch` command, which can rewrite the entire history of the repository; just
    what we need for this task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always remember to make sure you have a backup of the repository you are about
    to run `git filter-branch` on, in case something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `--index-filter` option to filter the branch. The option allows
    us to rewrite the index or staging area just before each commit is recorded, and
    we''ll do this with the `clean-tree` script we created previously. We''ll also
    preserve tags using `cat` as the `tag-name-filter`. We''ll perform the rewrite
    on all branches and remember to use the absolute path to the clean-tree script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The rewrite takes a bit of time, as all commits need to be processed. Once
    the rewrite is done, we can see that everything is deleted, except the files and
    folders we wanted to keep:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The cleanup isn''t done just yet. `git filter-branch` saves all the original
    references, branches and tags, under the `refs/original` namespace in the repository.
    After verification, the new history looks good, and we can get rid of the original
    `refs`, as these point to objects that are not in our current history and take
    up a lot of disk space. We''ll delete all the original refs and run the garbage
    collector to clear the repository of old objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete original references, `refs/original`, and remove old objects with `git
    gc`, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the size of the repository after garbage collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The repository is now clean of all old objects, the size has been reduced, and
    the history is preserved for the files and directories we listed to keep.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git filter-branch` command has different filter options depending on what
    needs to be done when rewriting the repository. In this example, where we are
    only removing files and folders from the repository; the `index-filter` is highly
    usable, as it allows us to rewrite the index just before recording a commit in
    the database without actually checking out the tree on disk, thereby saving a
    lot of disk I/O. The `clean-tree` script we prepared previously is then used to
    remove the unwanted files and folders from the index. First, we list the content
    of the index and filter the files and folders we want to keep. Then, we remove
    the remaining files and folders (`$f`) from the index with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `--cached` option tells Git to remove the index from files, and the `-rq`
    option tells it to remove `recursive (r)` option and be quiet (`q`). Finally,
    the `--ignore-unmatch` option is used so that `git rm` will not exit with an error
    if it tries to remove a file that is not in the index.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many more filters for `git filter-branch`; the most common ones and
    their use cases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env-filter`: This filter is used to modify the environment where commits are
    recorded. This is particularly useful when rewriting author and committer information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tree-filter`: The `tree-filter` is used to rewrite the tree. This is useful
    if you need to add or modify files in the tree, for example, to remove sensitive
    data from a repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg-filter`: This filter is used to update the commit message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subdirectory-filter`: This filter can be used if you want to extract a single
    subdirectory to a new repository and keep the history of that subdirectory. The
    subdirectory will be the root of the new repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting history – changing a single file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll see how we can use Git `filter-branch` to remove sensitive
    data from a file throughout the repository history.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simplicity, we''ll use a very simple example repository. It contains a
    few files. One of them is .credentials, which contains a username and password.
    Start by cloning the repository and changing the directory, as shown in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Before proceeding, you can take a look at the content of the repository using
    `ls` and examine the history with `git log`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we need to modify a file when rewriting the history of this repository,
    we''ll use the `tree-filter` option to filter the branch. The `.credentials` file
    looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do is remove everything after the equals sign on each line of
    the file. We can use the following `sed` command to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the filter branch with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the file now, we can see that the username and password are gone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the previous example, we still need to clean up after  `filter-branch`,
    by deleting original references, expiring the `reflog`, and triggering garbage
    collection. But, at this point, you can compare the content and commit history
    of the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each commit in the repository, Git will check the content of that commit
    and run `tree-filter`. If the filter fails with a non-zero exit code, `filter-branch`
    will fail. Therefore, it is important to remember to handle cases where `tree-filter`
    might fail. This is the reason why the previous `tree-filter` checks whether the
    `.credentials` file exists, runs the `sed` command if it does, and otherwise returns
    true to continue the `filter-branch`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a backup of your repositories as mirror repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Git is distributed and every clone is essentially a backup, there
    are some tricks that can be useful when backing up Git repositories. A normal
    Git repository has a working copy of the files it tracks and the full history
    of the repository in the `.git` folder of that repository. The repositories on
    the server, the ones you push to and pull from, will usually be bare repositories.
    A bare repository is a repository without a working copy. Roughly, it is just
    the `.git` folder of a normal repository. A mirror repository is almost the same
    as a bare repository, except it fetches all the references under `refs/*`, whereas
    a bare repository only fetches the references that fall under `refs/heads/*`.
    We'll now take a closer look at a normal, a bare, and a mirror clone of the JGit
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by creating three clones of the JGit repository: a normal, a bare,
    and a mirror clone. When we create the first clone, we can use that as a reference
    repository for the other clones. In this way, we can share the objects in the
    database, and we don''t have to transfer the same data three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the differences between a normal repository and a bare or mirror one
    is that there are no remote branches in a bare repository. All the branches are
    created locally. We can see this in the three repositories by listing the branches
    with the `git branch` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the difference between the bare and mirror repositories, we need to
    list the different refspecs fetches and the different `refs` namespaces. List
    the fetch `refspec` of origin in the mirror repository (`jgit.mirror`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'List the different `refs` namespaces in the mirror repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no explicit `refspec` fetch in the configuration for origin in the
    bare repository (`jgit.git`). When no configuration entry is found, Git uses the
    default `refspec` fetch, as it does in a normal repository. We can check the remote
    URL of origin using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'List the different `refs` namespaces in the bare repository using the following
    command and see the difference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can list the `refspec` fetch and `refs` namespaces for the normal
    repository (`jgit`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The mirror repository has four ref namespaces not found in either the normal
    or the bare repositories: `refs-cache-automerge`, `changes`, `meta`, and `notes`.
    The normal repository is the only one that has the `refs/remote` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The normal and bare repositories are pretty similar, only the mirror one sticks
    out. This is due to the `refspec` fetch on the mirror repository, `+refs/*:refs/*`,
    which will fetch all `refs` from the remote and not just `refs/heads/*` and `refs/tags/*`
    as a normal repository (and a `bare` repository) does. The many different `ref`
    namespaces on the JGit repository is because the JGit repository is managed by
    Gerrit Code Review. It uses different namespaces for repository-specific content,
    such as change branches for all commits submitted for code review, and metadata
    on code review score.
  prefs: []
  type: TYPE_NORMAL
- en: The `mirror` repositories are ideal when you would like a quick way to back
    up a Git repository. It ensures that you have everything included without the
    need for additional access than the Git access to the machine that hosts the Git
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The repositories on GitHub store extra information in some refs namespaces.
    If a repository has had a pull request made, the pull request will be recorded
    in the `refs/pull/*` namespace. Let''s look at this in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A quick "how-to" submodule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working on a software project, you sometimes find yourself in a situation
    where you need to use another project as a part of your project. This other project
    can be anything, from another project you are developing to a third-party library.
    You want to keep projects separate, even though you need to use one project for
    the other. Git has a mechanism for this kind of project dependency, called submodules.
    The basic idea is that you can clone another Git repository into your project
    as a subdirectory, but keep the commits from the two repositories separate, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/272fa5ac-8cd1-4483-8660-0637a3408093.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by cloning an example repository to be used as the super project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll add a subproject, `lib_a`, to the super project as a Git submodule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check `git status` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take a closer look at the two files in the Git index; `.gitmodules`
    is a regular file, so we can use `cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `.gitmodules` file, as above, contains information about all the submodules
    registered in the repository. The `lib_a` file stores which commit the submodule's
    `HEAD` is pointing to when added to the super project. Whenever the submodule
    is updated with new commits (created locally or fetched), the super project will
    show the submodule as having changed while running `git status`. If the changes
    to the submodule can be accepted, the submodule revision in the super project
    is updated by adding the submodule file and committing this to the super project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll update the submodule, `lib_a`, to the latest change on the develop branch
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just check whether there are any updates to the submodule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! Now we actually reset our submodule to the state described in the file
    for that submodule. We need to switch to the submodule again, check develop, and
    this time create a commit in the super repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, by default, the submodule is in a detached head state, which means
    that `HEAD` is pointing directly to a commit instead of a branch. You can still
    edit the submodule and record commits; however, if you perform a submodule update in
    the super repository without first committing a new submodule state, your changes
    can be hard to find. Always remember to check out or create a branch while switching
    to a submodule to work on. If so, you can just check out the branch again and
    get your changes back. Since Git Version 1.8.2, it has been possible to make submodules
    track a branch rather than a single commit. Git 1.8.2 was released on March 13,
    2013, and you can check your version by running `git --version`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make Git track the branch of a submodule rather than a specific commit,
    we need to record the name of the branch we want to track. This is done in the
    `.gitmodules` file for the submodule; here, we''ll use the stable branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add and commit the submodule, and then try to update it using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The submodule is still in the detached `HEAD` state. However, when updating
    the submodule with `git submodule update --remote`, changes from the submodule's
    remote repository will be fetched and the submodule will be updated to the latest
    commit on the branch it is tracking. We still need to record a commit to the super
    repository, specifying the state of the submodule.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are cloning a repository that contains one or more submodules, you
    need to explicitly fetch them after the clone. We can try this with our newly
    created submodule repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, initialize and update the submodules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The repository is ready for development!
  prefs: []
  type: TYPE_NORMAL
- en: When cloning the repository, the submodules can be initialized and updated directly
    after the clone if the `--recursive` or `--recurse-submodules` option is given.
  prefs: []
  type: TYPE_NORMAL
- en: Subtree merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to submodules is subtree merging. Subtree merging is a strategy
    that can be used when performing merges with Git. The strategy is useful when
    merging a branch (or, as we'll see in this recipe, another project) into a subdirectory
    of a Git repository instead of the root directory. When using the subtree merge
    strategy, the history of the subproject is joined with the history of the super
    project, while the subproject's history can be kept clean, except for commits
    intended to go upstream.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repositories as in the last recipe, and we''ll reclone
    the super project to get rid of the submodule setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll add the subproject as a new remote and fetch the history:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a local branch, `lib_a_master`, which points to the same
    commit as the master branch in lib a (`lib_a/master`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the content of our working tree using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we switch back to the `master` branch, we should see the content of the
    super repository in our directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Git changes branches and populates the working directory as normal, even though
    the branches are originally from two different repositories. Now, we want to merge
    the history from `lib_a` into a subdirectory. First, we prepare a merge commit
    by merging with the `ours` strategy and make sure the commit isn''t completed
    (we need to bring in all the files):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, what the `ours` strategy tells Git to do is the following: merge
    in this branch, but keep the resulting tree the same as the tree on the tip of
    this branch. So, the branch is merged, but all the changes it introduced are discarded.
    In our previous command line, we also passed the `--no-commit` option. This option
    stops Git from completing the merge, but leaves the repository in a merging state.
    We can now add the content of the `lib_a` repository to the `lib_a` folder in
    the repository root. We do this with `git read-tree` to make sure the two trees
    are exactly the same, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Our current directory structure looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to conclude the merge commit we started using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, the subproject is added. Next, we'll see how we can update the super project
    with new commits from the subproject and how to copy commits made in the super
    project to the subproject.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add and commit a few changes to the super project using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes are made to the subproject and committed in the super project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The current history looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d983deb6-1f1c-4003-905f-5688b88b8e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The merge can be seen in the preceding screenshot, and also the two root commits
    of the repository: the original root commit and the root from `lib_a`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will learn how to integrate new commits into the super repository made
    in the subproject, `lib_a`. Normally, we would do this by checking out the `lib_a_master`
    branch and performing pull on it to get the latest commit from the remote repository.
    However, as we are working with example repositories in this recipe, no new commits
    are available on the master branch. Instead, we''ll use the `develop` and `stable`
    branches from `lib_a`. We''ll now integrate commits from the develop branch into `lib_a`.
    We do this directly using the `lib_a/develop` reference in the repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Our master branch has now been updated with the commits from `lib_a/develop`, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cdb3cb4-19d3-4f0b-bf13-195d9a1b5a5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it is time to add the commits we made in the `lib_a` directory back to
    the `lib_a` project. First, we''ll change the `lib_a_master` branch and merge
    that with `lib_a/develop` to be as up-to-date as possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to merge changes from the super project with the subproject.
    In order to not merge the history of the super project with the subproject, we''ll
    use the `--squash` option. This option stops Git from completing the merge and,
    unlike the previous case, where we also stopped a merge from recording a commit,
    it does not leave the repository in a merging state. The state of the working
    directory and staging area are, however, set as though a real merge has happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can record a commit with all the changes made in `lib_a` from the super
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The history for the `lib_a` repository is seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65298db8-e8a5-4a83-afb3-97360e546772.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can integrate more changes from `lib_a/stable` into the super project, but
    first we''ll update the `lib_a_master` branch so that we can integrate them from
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A new commit was added to the subproject, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3969f74d-fbc1-494b-9153-1002f42732dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last task is to integrate the new commit on `lib_a_master` into the `master`
    branch in the super repository. This is done as in the previous case, using the
    `subtree strategy` option to `git merge`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting history is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b03aa1d4-b6ed-4159-9725-a57dcaca49cb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the subtree strategy, Git finds out which subtree in your repository
    the branch you are trying to merge fits into. This is why we added the content
    of the `lib_a` repository with the `read-tree` command, to make sure we got the
    exact same SHA-1 ID for the `lib_a` directory in the super project as the root
    tree in the `lib_a` project. In the following example, the SHA-1 is found in the
    first command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by finding the SHA-1 of the `lib_a` tree in the super project
    in the commit that we merged the subproject with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The ID of the root tree at `lib_a/master` can be found out by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of using subtree merging is with the `git subtree` command. This
    is not enabled by default in many Git installations, but has been distributed
    with Git since 1.7.11\. You can see how to install and use it at the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: For installation, go to [https://github.com/git/git/blob/master/contrib/subtree/INSTALL](https://github.com/git/git/blob/master/contrib/subtree/INSTALL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how to use a subtree, go to [https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt](https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are a Homebrew or an Ubuntu user, their basic packages have support for
    subtrees. For Fedora, you must install additional packages.
  prefs: []
  type: TYPE_NORMAL
- en: Submodule versus subtree merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no easy answer to the question of whether or not to use submodules
    or subtree merging for a project. When choosing submodules, a lot of extra pressure
    is put on the developers working on the project, as they need to make sure they
    keep the submodules and the super project in sync. When choosing to add a project
    by subtree merging, little to no extra complexity is added for developers. The
    repository maintainer, however, needs to make sure the subproject is up-to-date
    and that commits are added back to the subproject. Both methods work and are in
    use, and it is probably just a matter of getting used to either method. A completely
    different solution is to use the build system of the super project to fetch the
    necessary dependencies, as for example, Maven or Gradle does.
  prefs: []
  type: TYPE_NORMAL
