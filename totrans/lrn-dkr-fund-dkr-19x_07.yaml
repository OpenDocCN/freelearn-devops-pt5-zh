- en: Data Volumes and Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned how to build and share our own container images.
    Particular focus was placed on how to build images that are as small as possible
    by only containing artifacts that are really needed by the containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how we can work with stateful containers—that
    is, containers that consume and produce data. We will also learn how to configure
    our containers at runtime and at image build time, using environment variables
    and config files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the topics we''re going to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using host volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining volumes in images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After working through this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create, delete, and list data volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount an existing data volume into a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create durable data from within a container using a data volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share data between multiple containers using data volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount any host folder into a container using data volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the access mode (read/write or read-only) for a container when accessing
    data in a data volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure environment variables for applications running in a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametrize a `Dockerfile` by using build arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need either Docker Toolbox installed on your machine or
    access to a Linux **virtual machine** (**VM**) running Docker on your laptop or
    in the cloud. Furthermore, it is advantageous to have Docker for Desktop installed
    on your machine. There is no code accompanying this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting data volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All meaningful applications consume or produce data. Yet containers are, preferably,
    meant to be stateless. How are we going to deal with this? One way is to use Docker
    volumes. Volumes allow containers to consume, produce, and modify a state. Volumes
    have a life cycle that goes beyond the life cycle of containers. When a container
    that uses a volume dies, the volume continues to exist. This is great for the
    durability of the state.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the container layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into volumes, let''s first discuss what happens if an application
    in a container changes something in the filesystem of the container. In this case,
    the changes are all happening in the writable container layer that we introduced
    in [Chapter 3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering Containers*.
    Let''s quickly demonstrate this by running a container, and execute a script in
    it that is creating a new file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates a container named `demo`, and, inside this container,
    creates a file called `sample.txt` with the content `This is a test`. The container
    exits after running the `echo` command but remains in memory, available for us
    to do our investigations. Let''s use the `diff` command to find out what has changed
    in the container''s filesystem in relation to the filesystem of the original image,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, a new file, as indicated by the `A`, has been added to the filesystem of
    the container, as expected. Since all layers that stem from the underlying image
    (`alpine`, in this case) are immutable, the change could only happen in the writeable
    container layer.
  prefs: []
  type: TYPE_NORMAL
- en: Files that have changed compared to the original image will be marked with a
    `C`, and those that have been deleted, with a `D`.
  prefs: []
  type: TYPE_NORMAL
- en: If we now remove the container from memory, its container layer will also be
    removed, and with it, all the changes will be irreversibly deleted. If we need
    our changes to persist even beyond the lifetime of the container, this is not
    a solution. Luckily, we have better options, in the form of Docker volumes. Let's
    get to know them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since at this time, when using Docker for Desktop on a macOS or Windows computer,
    containers are not running natively on macOS or Windows but rather in a (hidden)
    VM created by Docker for Desktop, for illustrative purposes it is best we use `docker-machine` to
    create and use an explicit VM running Docker. At this point, we assume that you
    have Docker Toolbox installed on your system. If not, then please go back to [Chapter
    2](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml), *Setting up a Working Environment,* where
    we provide detailed instructions on how to install Toolbox:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `docker-machine` to list all VMs currently running in VirtualBox, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not have a VM called `node-1` listed, then please create one with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Refer back to [Chapter 2](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml), *Setting
    up a Working Environment*, on how to create a Hyper-V-based VM with `docker-machine`
    if you are running on Windows with Hyper-V enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, you have a VM called `node-1` but it is not running,
    then please start it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is ready, use `docker-machine` to SSH into this VM, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be greeted by this welcome image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/223cb246-5c36-42aa-8905-22913d6642ba.png)'
  prefs: []
  type: TYPE_IMG
- en: docker-machine VM welcome message
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new data volume, we can use the `docker volume create` command.
    This will create a named volume that can then be mounted into a container and
    used for persistent data access or storage. The following command creates a volume
    called `sample`, using the default volume driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The default volume driver is the so-called local driver, which stores the data
    locally in the host filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to find out where the data is stored on the host is by using
    the `docker volume inspect` command on the volume we just created. The actual
    location can differ from system to system, and so, this is the safest way to find
    the target folder. You can see this command in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The host folder can be found in the output under `Mountpoint`. In our case,
    when using `docker-machine` with a LinuxKit-based VM running in VirtualBox, the
    folder is `/mnt/sda1/var/lib/docker/volumes/sample/_data`.
  prefs: []
  type: TYPE_NORMAL
- en: The target folder is often a protected folder, and we thus might need to use `sudo` to
    navigate to this folder and execute any operations in it.
  prefs: []
  type: TYPE_NORMAL
- en: On our LinuxKit-based VM in Docker Toolbox, access is also denied, yet we don't
    have `sudo` available either. Is that the end of our exploration?
  prefs: []
  type: TYPE_NORMAL
- en: Luckily not; I have prepared a `fundamentalsofdocker/nsenter` utility container that
    allows us to access the backing folder of our `sample` volume we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to run this container in `privileged` mode to get access to this protected
    part of the filesystem, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are running the container with the `--privileged` flag. This means that any
    app running in the container gets access to the devices of the host. The `--pid=host` flag
    signifies that the container is allowed to access the process tree of the host
    (the hidden VM in which the Docker daemon is running). Now, the preceding container
    runs the Linux `nsenter` tool to enter the Linux namespace of the host and then
    runs a shell within there. From this shell, we are thus granted access to all
    resources managed by the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the container, we basically execute the following command inside
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nsenter -t 1 -m -u -n -i sh`'
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds complicated to you, don't worry; you will understand more as
    we proceed through this book. If there is one takeaway for you out of this, then
    it is to realize how powerful the right use of containers can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within this container, we can now navigate to the folder representing
    the mount point of the volume, and then list its content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The folder is currently empty since we have not yet stored any data in the volume.
  prefs: []
  type: TYPE_NORMAL
- en: Exit the tool container by pressing *Ctrl* + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are other volume drivers available from third parties, in the form of
    plugins. We can use the `--driver` parameter in the `create` command to select
    a different volume driver. Other volume drivers use different types of storage
    systems to back a volume, such as cloud storage, **Network File System** (**NFS**)
    drives, software-defined storage, and more. The discussion of the correct usage
    of other volume drivers is beyond the scope of this book, though.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have created a named volume, we can mount it into a container by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we can use the `-v` parameter in the `docker container run` command,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command mounts the `sample` volume to the `/data` folder inside
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, we can now create files in the `/data` folder and then
    exit, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we navigate to the host folder that contains the data of the volume and
    list its content, we should see the two files we just created inside the container
    (remember: we need to use the `fundamentalsofdocker/nsenter` tool container to
    do so), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even try to output the content of, say, the second file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to create a file in this folder from the host, and then use the
    volume with another container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Exit the tool container by pressing *Ctrl* + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s delete the `test` container, and run another one based on CentOS.
    This time, we are even mounting our volume to a different container folder, `/app/data`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the `centos` container, we can navigate to the `/app/data` folder
    to which we have mounted the volume, and list its content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we should see these three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the definitive proof that data in a Docker volume persists beyond the
    lifetime of a container, and also, that volumes can be reused by other, even different,
    containers from the one that used it first.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the folder inside the container to which we mount
    a Docker volume is excluded from the Union filesystem. That is, each change inside
    this folder and any of its subfolders will not be part of the container layer,
    but will be persisted in the backing storage provided by the volume driver. This
    fact is really important since the container layer is deleted when the corresponding
    container is stopped and removed from the system.
  prefs: []
  type: TYPE_NORMAL
- en: Exit the `centos` container with *Ctrl* + *D*. Now, exit the `node-1` VM by
    pressing *Ctrl* + *D* again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Volumes can be removed using the `docker volume rm` command. It is important
    to remember that removing a volume destroys the containing data irreversibly,
    and thus is to be considered a dangerous command. Docker helps us a bit in this
    regard, as it does not allow us to delete a volume that is still in use by a container.
    Always make sure before you remove or delete a volume that you either have a backup
    of its data or you really don''t need this data anymore. Let''s see how to remove
    volumes by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command deletes our `sample` volume that we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After executing the preceding command, double-check that the folder on the host
    has been deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To remove all running containers in order to clean up the system, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that by using the `-v` or `--volume` flag in the command you use to remove
    a container, you can ask the system to also remove any volume associated with
    that particular container. Of course, that will only work if the particular volume
    is only used by this container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show how we can access the backing folder of a
    volume when working with Docker for Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing volumes created with Docker for Desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `sample` volume and inspect it using Docker for Desktop on
    our macOS or Windows machine, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Mountpoint` is shown as `/var/lib/docker/volumes/sample/_data`, but you
    will discover that there is no such folder on your macOS or Windows machine. The
    reason is that the path shown is in relation to the hidden VM that Docker for
    Windows uses to run containers. At this time, Linux containers cannot run natively
    on macOS, nor on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s generate two files with data in the volume from within an `alpine`
    container. To run the container and mount the sample `volume` to the `/data` folder
    of the container, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate two files in the `/data` folder inside the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Exit the `alpine` container by pressing *Ctrl + D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned earlier, we cannot directly access the backing folder of the `sample`
    volume from our macOS or from Windows. This is because the volume is in the hidden
    VM running on macOS or Windows that is used to run the Linux container in Docker
    for Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: To access that hidden VM from our macOS, we have two options. We can either
    use a special container and run it in privileged mode, or we can use the `screen`
    utility to screen into the Docker driver. The first method is also applicable
    to Docker for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the first method mentioned, by running a container from the `fundamentalsofdocker/nsenter` image.
    We have been using this container already in the previous section. Run the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now navigate to the folder backing our `sample` volume, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what is in this folder by running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to create a file from within this special container, and then list
    the content of the folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And now, we have the files in the backing folder of the `sample` volume.
  prefs: []
  type: TYPE_NORMAL
- en: To exit our special privileged container, we can just press *Ctrl* + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have explored the first option, and if you''re using macOS, let''s
    try the `screen` tool, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing so, we will be greeted by an empty screen. Hit *Enter*, and a `docker-desktop:~#` command-line
    prompt will be displayed. We can now navigate to the volume folder, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another file with some data in it, and then list the content
    of the folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To exit this session with the Docker VM, press *Ctrl* + *A* + *K*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have now created data using three different methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From within a container that has a `sample` volume mounted.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a special privileged folder to access the hidden VM used by Docker for
    Desktop, and directly writing into the backing folder of the `sample` volume.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only on macOS, using the `screen` utility to enter into the hidden VM, and also directly
    writing into the backing folder of the `sample` volume.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are like sandboxes for the applications running inside them. This
    is mostly beneficial and wanted, in order to protect applications running in different
    containers from each other. It also means that the whole filesystem visible to
    an application running inside a container is private to this application, and
    no other application running in a different container can interfere with it.
  prefs: []
  type: TYPE_NORMAL
- en: At times, though, we want to share data between containers. Say an application
    running in container A produces some data that will be consumed by another application
    running in container B. *How can we achieve this?* Well, I'm sure you've already
    guessed it—we can use Docker volumes for this purpose. We can create a volume
    and mount it to container A, as well as to container B. In this way, both applications
    A and B have access to the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as always when multiple applications or processes concurrently access
    data, we have to be very careful to avoid inconsistencies. To avoid concurrency
    problems such as race conditions, we ideally have only one application or process
    that is creating or modifying data, while all other processes concurrently accessing
    this data only read it. We can enforce a process running in a container to only
    be able to read the data in a volume by mounting this volume as read-only. Have
    a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a container called `writer` that has a volume, `shared-data`,
    mounted in default read/write mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to create a file inside this container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It should succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit this container, and then execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: And we have a container called `reader` that has the same volume mounted as **read-only** (`ro`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, make sure you can see the file created in the first container, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, try to create a file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It will fail with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s exit the container by typing `exit` at the Command Prompt. Back on the
    host, let''s clean up all containers and volumes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, exit the `docker-machine` VM by also typing `exit` at the
    Command Prompt. You should be back on your Docker for Desktop. Use `docker-machine` to
    stop the VM, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will show how to mount arbitrary folders from the Docker host into
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Using host volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In certain scenarios, such as when developing new containerized applications
    or when a containerized application needs to consume data from a certain folder
    produced—say—by a legacy application, it is very useful to use volumes that mount
    a specific host folder. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression interactively starts an `alpine` container with a shell
    and mounts the `src` subfolder of the current directory into the container at `/app/src`.
    We need to use `$(pwd)` (or `` `pwd` ``, for that matter), which is the current
    directory, as when working with volumes, we always need to use absolute paths.
  prefs: []
  type: TYPE_NORMAL
- en: Developers use these techniques all the time when they are working on their
    application that runs in a container, and want to make sure that the container
    always contains the latest changes they make to the code, without the need to
    rebuild the image and rerun the container after each change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a sample to demonstrate how that works. Let''s say we want to create
    a simple static website using nginx as our web server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new folder on the host, where we will put our web assets—such
    as HTML, CSS, and JavaScript files—and navigate to it, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a simple web page, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we add a `Dockerfile` that will contain instructions on how to build the
    image containing our sample website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a file called `Dockerfile` to the folder, with this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `Dockerfile` starts with the latest Alpine version of nginx, and then copies
    all files from the current host directory into the `/usr/share/nginx/html` containers
    folder. This is where nginx expects web assets to be located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build the image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we run a container from this image. We will run the container
    in detached mode, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note the `-p 8080:80` parameter. We haven't discussed this yet, but we will
    do it in detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *Single-Host
    Networking*. At the moment, just know that this maps the container port `80` on
    which nginx is listening for incoming requests to port `8080` of your laptop,
    where you can then access the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open a browser tab and navigate to `http://localhost:8080/index.html`,
    and you should see your website, which currently consists only of a title, `Personal
    Website`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `index.html` file in your favorite editor, to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save it, and then refresh the browser. Oh! That didn''t work. The browser
    still displays the previous version of the `index.html` file, which consists only
    of the title. So, let''s stop and remove the current container, then rebuild the
    image, and rerun the container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This time, when you refresh the browser, the new content should be shown. Well,
    it worked, but there is way too much friction involved. Imagine you have to do
    this each and every time that you make a simple change to your website. That's
    not sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is the time to use host-mounted volumes. Once again, remove the current
    container and rerun it with the volume mount, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, append some more content to the `index.html` file, and save it. Then, refresh
    your browser. You should see the changes. And this is exactly what we wanted to
    achieve; we also call this an *edit-and-continue* experience. You can make as
    many changes in your web files and always immediately see the result in the browser,
    without having to rebuild the image and restart the container containing your
    website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note that the updates are now propagated bi-directionally.
    If you make changes on the host, they will be propagated to the container, and
    vice versa. Also important is the fact that when you mount the current folder
    into the container target folder, `/usr/share/nginx/html`, the content that is
    already there is replaced by the content of the host folder.
  prefs: []
  type: TYPE_NORMAL
- en: Defining volumes in images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we go for a moment back to what we have learned about containers in [Chapter
    3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering Containers,* then we
    have this: the filesystem of each container, when started, is made up of the immutable
    layers of the underlying image, plus a writable container layer specific to this
    very container. All changes that the processes running inside the container make
    to the filesystem will be persisted in this container layer. Once the container
    is stopped and removed from the system, the corresponding container layer is deleted
    from the system and irreversibly lost.'
  prefs: []
  type: TYPE_NORMAL
- en: Some applications, such as databases running in containers, need to persist
    their data beyond the lifetime of the container. In this case, they can use volumes.
    To make things a bit more explicit, let's look at a concrete example. MongoDB
    is a popular open source document database. Many developers use MongoDB as a storage
    service for their applications. The maintainers of MongoDB have created an image
    and published it on Docker Hub, which can be used to run an instance of the database
    in a container. This database will be producing data that needs to be persisted
    long term, but the MongoDB maintainers do not know who uses this image and how
    it is used. So, they have no influence over the `docker container run` command
    with which the users of the database will start this container. *How can they
    now define volumes?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a way of defining volumes in the `Dockerfile`. The keyword
    to do so is `VOLUME`, and we can either add the absolute path to a single folder
    or a comma-separated list of paths. These paths represent folders of the container''s
    filesystem. Let''s look at a few samples of such volume definitions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the preceding snippet defines a single volume to be mounted
    at `/app/data`. The second line defines three volumes as a comma-separated list.
    The last one defines the same as the second line, but this time, the value is
    formatted as a JSON array.
  prefs: []
  type: TYPE_NORMAL
- en: When a container is started, Docker automatically creates a volume and mounts
    it to the corresponding target folder of the container for each path defined in
    the `Dockerfile`. Since each volume is created automatically by Docker, it will
    have an SHA-256 as its ID.
  prefs: []
  type: TYPE_NORMAL
- en: At container runtime, the folders defined as volumes in the `Dockerfile` are
    excluded from the Union filesystem, and thus any changes in those folders do not
    change the container layer but are persisted to the respective volume. It is now
    the responsibility of the operations engineers to make sure that the backing storage
    of the volumes is properly backed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `docker image inspect` command to get information about the
    volumes defined in the `Dockerfile`. Let''s see what MongoDB gives us by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we pull the image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we inspect this image, and use the `--format` parameter to only extract
    the essential part from the massive amount of data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note the `| jq .` at the end of the command. We are piping the output of `docker
    image inspect` into the `jq` tool, which nicely formats the output. If you haven't
    installed `jq` yet on your system, you can do so with `brew install jq` on your
    macOS, or with `choco install jq` on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the `Dockerfile` for MongoDB defines two volumes at `/data/configdb` and `/data/db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run an instance of MongoDB in the background as a daemon, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the `docker container inspect` command to get information about
    the volumes that have been created, among other things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use this command to just get the volume information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should output something like this (shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the values of the `Name` and `Source` fields have been trimmed for
    readability. The `Source` field gives us the path to the host directory, where
    the data produced by the MongoDB inside the container will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the moment about volumes. In the next section, we will explore
    how we can configure applications running in containers, and the container image
    build process itself.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often than not, we need to provide some configuration to the application
    running inside a container. The configuration is often used to allow one and the
    same container to run in very different environments, such as in development,
    test, staging, or production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, configuration values are often provided via environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that an application running inside a container is completely
    shielded from its host environment. Thus, the environment variables that we see
    on the host are different from the ones that we see from within a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s prove that by first looking at what is defined on our host:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'On my macOS, I see something like this (shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s run a shell inside an `alpine` container, and list the environment
    variables we see there, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output we see from the `export` command is evidently totally different
    than what we saw directly on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *D* to leave the `alpine` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's define environment variables for containers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables for containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the good thing is that we can actually pass some configuration values
    into the container at start time. We can use the `--env` (or the short form, `-e`)
    parameter in the form `--env <key>=<value>` to do so, where `<key>` is the name
    of the environment variable and `<value>` represents the value to be associated
    with that variable. Let''s assume we want the app that is to be run in our container
    to have access to an environment variable called `LOG_DIR`, with the value `/var/log/my-log`.
    We can do so with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code starts a shell in an `alpine` container and defines the
    requested environment inside the running container. To prove that this is true,
    we can execute this command inside the `alpine` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The output looks as expected. We now indeed have the requested environment variable
    with the correct value available inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, define more than just one environment variable when we run
    a container. We just need to repeat the `--env` (or `-e`) parameter. Have a look
    at this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do a list of the environment variables now, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at situations where we have many environment variables to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex applications can have many environment variables to configure, and thus
    our command to run the corresponding container can quickly become unwieldy. For
    this purpose, Docker allows us to pass a collection of environment variable definitions
    as a file, and we have the `--env-file` parameter in the `docker container run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `fod/05` folder and navigate to it, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your favorite editor to create a file called `development.config` in this
    folder. Add the following content to the file, and save it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we have the definition of a single environment variable per line
    in the format `<key>=<value>`, where, once again, `<key>` is the name of the environment
    variable, and `<value>` represents the value to be associated with that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from within the `fod/05` folder, let''s run an `alpine` container, pass
    the file as an environment file, and run the `export` command inside the container
    to verify that the variables listed inside the file have indeed been created as
    environment variables inside the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And indeed, the variables are defined, as we can see in the output generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at how to define default values for environment variables that
    are valid for all container instances of a given Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables in container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to define some default value for an environment variable
    that must be present in each container instance of a given container image. We
    can do so in the `Dockerfile` that is used to create that image by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to create a file called `Dockerfile` in the `~/fod/05` folder.
    Add the following content to the file, and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a container image called `my-alpine` using the preceding `Dockerfile`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a container instance from this image that outputs the environment variables
    defined inside the container, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we would have expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing, though, is that we are not stuck with those variable values
    at all. We can override one or many of them, using the `--env` parameter in the
    `docker container run` command. Have a look at the following command and its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We can also override default values, using environment files together with the
    `--env-file` parameter in the `docker container run` command. Please try it out
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables at build time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we would want to have the possibility to define some environment
    variables that are valid at the time when we build a container image. Imagine
    that you want to define a `BASE_IMAGE_VERSION` environment variable that shall
    then be used as a parameter in your `Dockerfile`. Imagine the following `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `ARG` keyword to define a default value that is used each time
    we build an image from the preceding `Dockerfile`. In this case, that means that
    our image uses the `node:12.7-stretch` base image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to create a special image for—say—testing purposes, we can
    override this variable at image build time using the `--build-arg` parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the resulting `my-node-test:latest` image will be built from the `node:12.7-alpine` base
    image and not from the `node:12.7-stretch` default image.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, environment variables defined via `--env` or `--env-file` are
    valid at container runtime. Variables defined with `ARG` in the `Dockerfile` or
    `--build-arg` in the `docker container build` command are valid at container image
    build time. The former are used to configure an application running inside a container,
    while the latter are used to parametrize the container image build process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced Docker volumes that can be used to persist
    states produced by containers and make them durable. We can also use volumes to
    provide containers with data originating from various sources. We have learned
    how to create, mount, and use volumes. We have learned various techniques of defining
    volumes such as by name, by mounting a host directory, or by defining volumes
    in a container image.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have also discussed how we can configure environment variables
    that can be used by applications running inside a container. We have shown how
    to define those variables in the `docker container run` command, either explicitly,
    one by one, or as a collection in a configuration file. We have also shown how
    to parametrize the build process of container images by using build arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please try to answer the following questions to assess your learning progress:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you create a named data volume with a name—for example, `my-products`—using
    the default driver?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you run a container using the `alpine` image and mount the `my-products` volume
    in read-only mode into the `/data` container folder?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you locate the folder that is associated with the `my-products` volume and
    navigate to it? Also, how will you create a file, `sample.txt`, with some content?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you run another `alpine` container in to which you mount the `my-products` volume
    to the `/app-data` folder, in read/write mode? Inside this container, navigate
    to the `/app-data` folder and create a `hello.txt` file with some content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you mount a host volume—for example, `~/my-project`—into a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you remove all unused volumes from your system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list of environment variables that an application running in a container
    sees is the same as if the application were to run directly on the host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: Your application that shall run in a container needs a huge list of environment
    variables for configuration. What is the simplest method to run a container with
    your application and provide all this information to it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following articles provide more in-depth information:'
  prefs: []
  type: TYPE_NORMAL
- en: Use volumes, at [http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage data in Docker, at [http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker volumes on **Play with Docker** (**PWD**), at [http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nsenter` —Linux man page, at [https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set environment variables, at [https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how `ARG` and `FROM` interact, at [https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
