<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-342"><a id="_idTextAnchor371" class="pcalibre1 pcalibre calibre6"/>15</h1>
<h1 id="_idParaDest-343" class="calibre5"><a id="_idTextAnchor372" class="pcalibre1 pcalibre calibre6"/>Git Best Practices</h1>
<p class="calibre3">The last chapter of <em class="italic">Mastering Git</em> presents a collection of generic and Git-specific version control recommendations and best practices. You have encountered many of these recommendations already in the earlier chapters; they are here as a summary and as a reminder. For details and the reasoning behind each best practice, refer to the specific chapters.</p>
<p class="calibre3">This chapter will cover the issues of managing the working directory, creating commits and series of commits (pull requests), submitting changes for inclusion, and the peer review of changes.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">How to separate projects into repositories</li>
<li class="calibre15">What types of data to store in a repository and which files Git should ignore</li>
<li class="calibre15">What to check before creating a new commit</li>
<li class="calibre15">How to create a good commit and a good commit series (or, in other words,  how to create a good pull request)</li>
<li class="calibre15">How to choose an effective branching strategy, and how to name branches  and tags</li>
<li class="calibre15">How to review changes and how to respond to the review</li>
</ul>
<h1 id="_idParaDest-344" class="calibre5"><a id="_idTextAnchor373" class="pcalibre1 pcalibre calibre6"/>Starting a project</h1>
<p class="calibre3">When starting<a id="_idIndexMarker1370" class="pcalibre1 pcalibre calibre6"/> a project, you should choose and clearly define a project governance model (who manages work, who integrates changes, and who is responsible for what). You should decide about the license and the copyright of the code: whether it is work for hire and whether contributions require a copyright assignment, a contributor agreement, a contributor license agreement, or simply a digital certificate of origin.</p>
<h2 id="_idParaDest-345" class="calibre7"><a id="_idTextAnchor374" class="pcalibre1 pcalibre calibre6"/>Dividing work into repositories</h2>
<p class="calibre3">In centralized version control systems, often everything is put under the same project tree. With distributed version control systems such as Git, it very much depends on the nature of the project. Often, it is better to split separate projects into separate repositories, but if those projects are tightly coupled together it might be better to use a <strong class="bold">monorepo</strong> – all projects<a id="_idIndexMarker1371" class="pcalibre1 pcalibre calibre6"/> in a single large repository.</p>
<p class="calibre3">If some part of the code is needed by multiple separate projects, consider extracting it into its own project and then incorporating it as a submodule or subtree, grouping concepts into a superproject. See <a href="B21194_11.xhtml#_idTextAnchor270" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>,<em class="italic"> Managing Subprojects</em>, for the details.</p>
<h2 id="_idParaDest-346" class="calibre7"><a id="_idTextAnchor375" class="pcalibre1 pcalibre calibre6"/>Selecting the collaboration workflow</h2>
<p class="calibre3">You need to make decisions on the collaboration structure, whether your project will use a dispersed contributor model, a “blessed” repository model, or a central repository, and so on (as found in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>,<em class="italic"> Collaborative Development </em><em class="italic">with Git</em>).</p>
<p class="calibre3">This often requires setting up an access control mechanism and deciding on the permission structure; see <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a><em class="italic">, Git Administration</em>, for details on how one can set up this.</p>
<p class="calibre3">You also need to decide<a id="_idIndexMarker1372" class="pcalibre1 pcalibre calibre6"/> on the branching patterns to use. See <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced Branching Techniques</em>, for examples of the most common patterns. You need to decide how to integrate changes, and how to isolate independent work. Those branching patterns are often grouped together into a single named branching workflow.</p>
<p class="calibre3">This decision about branching doesn’t need to be cast in stone. As your project and your team experience grow, you might want to consider changing the branching model, for example, from the trunk-based workflow to a plain branch-per-feature model, a GitHub flow, or any of the other derivatives.</p>
<p class="calibre3">The decisions about licensing, the collaboration structure, and the branching model should all be stated explicitly in the developer documentation (at a minimum in the <code>README</code> and <code>LICENSE</code>/<code>COPYRIGHT</code> files, and perhaps also in <code>CodingGuidelines</code> and <code>CodeOfConduct</code>). You need to remember that if the way in which the project is developed changes, this documentation needs to be updated to reflect the changes. This can happen, for example, because the project has grown beyond its initial stage.</p>
<h2 id="_idParaDest-347" class="calibre7"><a id="_idTextAnchor376" class="pcalibre1 pcalibre calibre6"/>Choosing which files to keep under version control</h2>
<p class="calibre3">In most cases, you should not include <a id="_idIndexMarker1373" class="pcalibre1 pcalibre calibre6"/>any of the <strong class="bold">generated files</strong> in the version control system (though there are some very rare exceptions). You should track only the sources (the original resources); Git works best if these sources are plain text files, but it also works well with binary files.</p>
<p class="calibre3">To avoid accidentally including unwanted files in a repository, you should use the <code>.gitignore</code> file in the project tree; those specific to the developer (for example, backup files created by the editor one uses or the operating system-specific helper files) should go into their per-user <code>core.excludesFile</code> (which, in modern Git, is the <code>~/.config/git/ignore</code> file), or into a local configuration of the specific clone of the repository, that is, <code>.git/info/excludes</code>. See <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>,<em class="italic"> Managing Your </em><em class="italic">Worktrees</em>, for details.</p>
<p class="calibre3">A good start for ignore patterns is the <a href="https://gitignore.io" class="pcalibre1 pcalibre calibre6">https://gitignore.io</a> site with its <code>.gitignore</code> templates for various operating systems, IDEs, and programming languages.</p>
<p class="calibre3">Another suggestion is<a id="_idIndexMarker1375" class="pcalibre1 pcalibre calibre6"/> to not add to Git the configuration files that might change from environment to environment (for example, those that are different for MS Windows and Linux).</p>
<h1 id="_idParaDest-348" class="calibre5"><a id="_idTextAnchor377" class="pcalibre1 pcalibre calibre6"/>Working on a project</h1>
<p class="calibre3">Here are some<a id="_idIndexMarker1376" class="pcalibre1 pcalibre calibre6"/> guidelines on how to create changes and develop new revisions. These guidelines can be used either for your work on your own project, or to help contribute your code to a project maintained by somebody else.</p>
<p class="calibre3">Different projects can use different development workflows; therefore, some of the recommendations presented here might not make sense depending on the given workflow in use.</p>
<h2 id="_idParaDest-349" class="calibre7"><a id="_idTextAnchor378" class="pcalibre1 pcalibre calibre6"/>Working on a topic branch</h2>
<p class="calibre3">Branching in Git has two functions (<a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced Branching Techniques</em>): as a mediator for the code contributed by developers keeping to the <strong class="bold">specified level of code stability and maturity</strong> (long-running public branches), providing the road to integration and deployment, and as a <strong class="bold">sandbox for the development of a new idea</strong> (short-lived private branches).</p>
<p class="calibre3">The ability to sandbox changes is why it is considered a good practice to create a separate branch for each new task you work on. Such a branch is called a topic branch or a feature branch. Using separate branches makes it possible to switch between tasks easily, and to keep disparate pieces of work in progress from interfering with each other. On the other hand, if such branches are long-lived, it would go against <strong class="bold">c</strong><strong class="bold">ontinuous integration</strong> (<strong class="bold">CI</strong>) practices, reduce<a id="_idIndexMarker1377" class="pcalibre1 pcalibre calibre6"/> changeset visibility, and lead to more difficult integration because of larger divergence.</p>
<p class="calibre3">You should choose short and descriptive names for branches. There are different naming conventions for topic branches; the convention your project uses should be specified in the developer documentation. In general, branches are usually named with a summary of a topic they host, usually in all-lowercase and with the spaces between words replaced by<a id="_idIndexMarker1378" class="pcalibre1 pcalibre calibre6"/> hyphens or underscores (see the <code>git-check-ref-format</code> manpage to know what is forbidden in branch names). Branch names can include slashes (be hierarchical).</p>
<p class="calibre3">If you are using an issue tracker, then a branch that fixes a bug or implements an issue can have its name prefixed with the identifier (the number) of the ticket describing the issue, for example, <code>1234-doc_spellcheck</code>. On the other hand, the maintainer, while gathering submissions from other developers, could put these submissions in topic branches named after the initials of the developer and the name of the topic, for example, <code>ad/whitespace-cleanup</code> (this is an example<a id="_idIndexMarker1379" class="pcalibre1 pcalibre calibre6"/> of a <strong class="bold">hierarchical </strong><strong class="bold">branch name</strong>).</p>
<p class="calibre3">It is considered a good practice to delete your topic branch from your local repository, and also from the upstream repository after you are done with the branch in question, to reduce clutter.</p>
<h2 id="_idParaDest-350" class="calibre7"><a id="_idTextAnchor379" class="pcalibre1 pcalibre calibre6"/>Deciding what to base your work on</h2>
<p class="calibre3">As a developer, you are usually working on some specific issue at a given time, be it a bug fix, an enhancement, a correction to some topic, or a new feature.</p>
<p class="calibre3">Where to start your work on a given topic, and what branch to base your work on, both depend on the branching workflow chosen for the project (see <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced Branching Techniques</em>,<em class="italic"> </em>for a selection of branching workflows). This decision also depends on the type of work you do.</p>
<p class="calibre3">For a topic branch workflow (or a branch-per-feature workflow), you would want to base your work on the oldest and most stable long-running branch that your change is relevant to, and for which you plan to merge your changes into. This is because, as described in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced Branching Techniques</em>, you should <strong class="bold">never merge </strong>a <strong class="bold">less stable branch into </strong>a <strong class="bold">more stable branch</strong>. The reason behind this best practice rule is to avoid destabilizing the branch as merging carries over all the changes.</p>
<p class="calibre3">Different types of changes require a different long-lived branch to be used as a base  for a topic branch with those changes, or to put those changes onto. In general, to help developers working on a project, this information should be described in the developer documentation; not everybody needs to be knowledgeable about the branching workflow used by<a id="_idIndexMarker1380" class="pcalibre1 pcalibre calibre6"/> the project.</p>
<p class="calibre3">The following describes what is usually used as a base branch, depending on the  purpose of the changes:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Bugfix</strong>: In this case, the topic branch (the bugfix branch) should be based on the oldest and the most stable branch in which the bug is present. This means, in general, starting with the maintenance branch. If the bug is not present in the maintenance branch, then base the bugfix branch on the stable branch. For a bug that is not present in the stable branch, find the topic branch that introduced it and base your work on top of that topic branch.</li>
<li class="calibre15"><strong class="bold">New feature</strong>: In this case, the topic branch (the feature branch) should be based on the stable branch, if possible. If the new feature depends on some topic that is not ready for the stable branch, then base your work on that topic (from a topic branch).</li>
<li class="calibre15">Corrections and enhancements to a topic that didn’t get merged into the stable branch should be based on the tip of the topic branch being corrected. If the topic in question is not considered published, it’s alright to make changes to the steps of the topic, squashing minor corrections in the series (see the section about rewriting history in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a><em class="italic">, Keeping </em><em class="italic">History Clean</em>).</li>
</ul>
<p class="calibre3">If the project you are contributing to is large enough to have dedicated maintainers for selected parts (subsystems) of the system, you first need to decide which repository and fork (sometimes named “a tree”) to base your work on.</p>
<h2 id="_idParaDest-351" class="calibre7"><a id="_idTextAnchor380" class="pcalibre1 pcalibre calibre6"/>Splitting changes into logically separate steps</h2>
<p class="calibre3">Unless your work is really simple and can be done in a single step (a single commit)—as is the case with many bugfixes—you should make separate commits for logically separate changes, one commit per single step. Those commits should be ordered logically.</p>
<p class="calibre3">Following good practice for commit messages (with an explanation of what you have done—see the next section) could help in deciding when to commit. If your description gets too long and you <a id="_idIndexMarker1381" class="pcalibre1 pcalibre calibre6"/>begin to see that you have two independent changes squashed together, that’s a sign that you probably need to split your commit into finer-grained pieces and use smaller steps.</p>
<p class="calibre3">Remember, however, that it is a matter of balance between the project conventions and the development workflow chosen. Changes should, at a minimum, stand on their own. At each step (at each commit) of the implementation of a feature, the code compiles and the program passes the test suite. You should <code>git bisect</code> (which is described in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>,<em class="italic"> Exploring </em><em class="italic">Project History</em>).</p>
<p class="calibre3">Note that you don’t necessarily need to come up with the perfect sequence of steps from the start. If you notice that you have entangled the work directory’s state, you can make use of the staging area, using an interactive add to disentangle it (this is described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a><em class="italic">, Developing with Git,</em> and <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a><em class="italic">, Managing Your </em><em class="italic">Worktrees</em>). You can also use an interactive rebase or a similar technique, as shown in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a><em class="italic">, Keeping History Clean</em>, to curate commits into an easy-to-read (and easy-to-bisect) history before publishing.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You should remember that a commit is a place to record your result (or a particular step towards the result), not a place to save the temporary state of your work. If you need to temporarily save the current state before going back to it, use <strong class="source-inline1">git stash</strong>.</p>
<h2 id="_idParaDest-352" class="calibre7"><a id="_idTextAnchor381" class="pcalibre1 pcalibre calibre6"/>Writing a good commit message</h2>
<p class="calibre3">A good commit message should include an explanation for the change with sufficient detail so that other developers on the team (including reviewers and the maintainer) can judge whether it is a good idea to include the change in the codebase. This good-or-not decision should not require them to read the actual changes to find out what the commit intends to do.</p>
<p class="calibre3">The first line of the commit message should be a short, terse description (from around 50 to 72 characters) with a summary of the changes. It should be separated by an empty line from the rest of the commit message, if there is one. This is partly because, in many places, such as in the <code>git log --oneline</code> command output, in a graphical history viewer such as <code>gitk</code>, and in the instruction sheet of <code>git rebase --interactive</code>, you will see only this one line of the commit message and have to decide the action with respect to that commit on the basis of this one line. If you have trouble with coming up <a id="_idIndexMarker1382" class="pcalibre1 pcalibre calibre6"/>with a good summary of changes, this might mean that these changes need to be split into smaller steps.</p>
<p class="calibre3">There are various conventions for this summary line of changes. One convention is to prefix the first summary line with <strong class="bold">area:</strong>, which is an identifier for the general area of the code being modified: the name of the subsystem, of an affected subdirectory, or a filename of a file being changed. If the development is managed via an issue tracker, this summary line can start with something like the <strong class="bold">[#1234]</strong> prefix, where <strong class="bold">1234</strong> is the identifier of an issue or task implemented in the commit. In general, when not sure about what information to include in the commit message, refer to the development documentation or fall back to the current convention used by other commits in the history.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you are using agile development methods, you can look for especially good commit messages during retrospectives and add them as examples to the developer documentation for the future.</p>
<p class="calibre3">For all but trivial changes, there should be a longer meaningful description, the body of the commit message. There is something that people coming from other version control systems might need to unlearn: namely, not writing a commit message at all or writing it all on one long line. Note that Git will not allow the creation of a commit with an empty commit message unless forced to with <code>--allow-empty</code>.</p>
<p class="calibre3">The commit message should do the following:</p>
<ul class="calibre16">
<li class="calibre15">Include the rationale for the commit, explaining the problem that the commit tries to solve – the <em class="italic">why</em>, in other words. It should include a description of what is wrong with the current code or the current behavior of the project without the change. This should be self-contained, but it can refer to other sources including the issue tracker (the bug tracker) or other external documents such as<a id="_idIndexMarker1383" class="pcalibre1 pcalibre calibre6"/> articles, wikis, or <strong class="bold">Common Vulnerabilities and </strong><strong class="bold">Exposures</strong> (<strong class="bold">CVEs</strong>).</li>
<li class="calibre15">Include a quick <a id="_idIndexMarker1384" class="pcalibre1 pcalibre calibre6"/>summary. In most cases, it should also explain the <em class="italic">how</em> and justify the way the commit solves the problem.</li>
<li class="calibre15">Describe why you think the result with the change is better; this part of the description does not need to explain what the code does, as that is largely a task for the code comments.</li>
<li class="calibre15">If there was more than one possible solution, include a description of the alternative solutions that were considered but ultimately discarded, perhaps with links to the discussion or review(s).</li>
</ul>
<p class="calibre3">It’s a good idea to try to make sure that your explanation of the changes can be understood without access to any external resources (that is, without accessing the issue tracker, the internet, or a mailing list archive). Instead of just referring to the discussion, or in addition to giving a URL or an issue number, write a summary of the relevant points in the commit message.</p>
<p class="calibre3">One of the possible recommendations when writing a commit message is to describe changes in the imperative mood, for example, <strong class="bold">make foo do bar</strong>, as if you are giving orders to the codebase to change its behavior, instead of writing <strong class="bold">This commit makes...</strong> or <strong class="bold">[I] </strong><strong class="bold">changed ...</strong>.</p>
<p class="calibre3">Here, <code>commit.template</code> and commit message hooks can help in following these practices. see<em class="italic"> </em><a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>,<em class="italic"> Customizing and Extending Git</em>, for details (and <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>,<em class="italic"> Git Administration</em>, for a description of the way to enforce this recommendation).</p>
<h2 id="_idParaDest-353" class="calibre7"><a id="_idTextAnchor382" class="pcalibre1 pcalibre calibre6"/>Preparing changes for submission</h2>
<p class="calibre3">If the topic branch was started a long time ago, consider rebasing the branch to be submitted on top of the current tip of the base branch. This should make it easier to integrate changes in the future. If your topic branch was based on the development version, or on the other in-flight topic branch (perhaps because it depended on some specific feature), and the branch it was based on got merged into a stable line of development, you should rebase your changes on top of the stable integration branch instead.</p>
<p class="calibre3">Rebasing is also a chance for a final clean-up of the history; the chance to make submitted changes easier to review. Simply run an interactive rebase with <code>git rebase --interactive</code>, or a patch management tool if you prefer (see <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>,<em class="italic"> Keeping History Clean</em>). One caveat: <strong class="bold">do not rewrite the </strong><strong class="bold">published history</strong>.</p>
<p class="calibre3">Consider testing that your changes merge cleanly, and fix it if they don’t (if possible). Make sure that they apply or merge cleanly into the appropriate integration branch.</p>
<p class="calibre3">Take a last look at your<a id="_idIndexMarker1385" class="pcalibre1 pcalibre calibre6"/> commits to be submitted. Make sure that your changes do not add the commented-out (or the ifdef-ed-out) code, nor any extra files not related to the purpose of the patch (for example, changes in an upcoming feature). Review your commit series before submission to ensure accuracy.</p>
<h1 id="_idParaDest-354" class="calibre5"><a id="_idTextAnchor383" class="pcalibre1 pcalibre calibre6"/>Integrating changes</h1>
<p class="calibre3">The exact details <a id="_idIndexMarker1386" class="pcalibre1 pcalibre calibre6"/>on how to submit changes for merging depends, of course, on the development workflow that the project is using. Various classes of possible workflows are described in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>,<em class="italic"> Collaborative Development </em><em class="italic">with Git.</em></p>
<h2 id="_idParaDest-355" class="calibre7"><a id="_idTextAnchor384" class="pcalibre1 pcalibre calibre6"/>Submitting and describing changes</h2>
<p class="calibre3">If the project has a dedicated maintainer or, at least someone responsible for merging the proposed changes into the official version, you also need to describe the submitted changes as a whole (in addition to describing each commit in the series). This can be done in the form of a cover letter for the patch series while sending changes as patches via email. It can also be done with comments in the pull request while using the collocated contributor repositories model, or it can be the description in an email with a pull request, which already includes the URL and the branch in your public repository with changes (generated with <code>git request-pull</code>).</p>
<p class="calibre3">This cover letter or pull request should include a description of the purpose of the patch series or the pull request. Consider also providing an overview of why the work is taking place (with any relevant links and a summary of the discussion). Be explicit in stating that it is a work in progress in the description of changes.</p>
<p class="calibre3">In the dispersed contributor model, where changes are submitted for review as patches or patch series, usually to a mailing list, you should use Git-based tools such as <code>git format-patch</code> and, if possible, <code>git send-email</code>. Multiple related patches should be grouped together, for example, in their own email thread. The convention is to send them as replies to an additional cover letter message, which should describe the feature as a whole.</p>
<p class="calibre3">If the changes are sent to the mailing list, it is a common convention to prefix your subject line with <code>[PATCH]</code> or <code>[PATCH m/n]</code> (where <code>m</code> is the patch number in the series of the <code>n</code> patches). This lets people easily distinguish patch submissions from other emails. This part can be done with <code>git format-patch</code>. What you need to decide yourself is whether to use additional markers after <code>PATCH</code> to mark the nature of the series, for example, <code>PATCH/RFC</code>. (<strong class="bold">RFC</strong> here means <strong class="bold">Request For Comments</strong>, i.e., an idea for a feature<a id="_idIndexMarker1387" class="pcalibre1 pcalibre calibre6"/> with an example of its implementation. Such a patch series should only be examined if the idea is worthy; it is not ready to be applied/merged yet and is provided only for discussion among the developers.)</p>
<p class="calibre3">In the collocated<a id="_idIndexMarker1388" class="pcalibre1 pcalibre calibre6"/> contributor repositories model, where all the developers use the same Git hosting website or software (for example, GitHub, Bitbucket, GitLab, or a private instance of it), you would push changes to your own public repository, a fork of the official version. Then, you would create a merge request or pull request, usually via the web interface of the hosting service, again describing the changes as a whole there.</p>
<p class="calibre3">In the case of using the central repository (perhaps in a shared maintenance model), you would push changes to a separate and possibly new branch in the integration repository, and then send an announcement to the maintainer so that they can find the changes to merge. The details of this step depend on the exact setup; sending announcements might be done via email, some kind of internal messaging mechanism, or even via tickets (or the comments in the tickets).</p>
<p class="calibre3">The development documentation might include rules specifying where to send announcements and/or changes. It is considered a courtesy to notify the people who are involved in the area of code you are changing about the new changes (you can use <code>git blame</code> and <code>git shortlog</code> to identify these</p>
<p class="calibre3">people; see <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>,<em class="italic"> Exploring Project History</em>). These people are important; they can write comments <a id="_idIndexMarker1389" class="pcalibre1 pcalibre calibre6"/>about the change and help review it.</p>
<p class="callout-heading">Crediting people and signing your work</p>
<p class="callout">Some open source projects, in order to improve the tracking provenance of the code, use the sign-off procedure borrowed from the Linux kernel called <strong class="bold">Digital Certificate of Origin</strong>. The<a id="_idIndexMarker1390" class="pcalibre1 pcalibre calibre6"/> sign-off is a simple line at the end of the commit message, like the following example:</p>
<p class="callout"><strong class="bold">Signed-off-by: Random </strong><strong class="bold">Developer &lt;rdeveloper@company.com&gt;</strong></p>
<p class="callout">By adding this line, you certify that the contribution is either created as a whole or in part by you, or is based on previous work, or was provided directly to you, and that everybody in the chain has the right to submit it under the appropriate license. If your work is based on work by somebody else, or if you are just passing somebody’s work, then there can be multiple sign-off lines forming a chain of provenance.</p>
<p class="callout">In order to credit people who helped with creating the commit, you can append to the commit message other trailers, such as <strong class="bold">Reported-by:</strong>, <strong class="bold">Reviewed-by:</strong>, <strong class="bold">Acked-by:</strong> (this one states that it was liked by the person responsible for the area covered by the change), or <strong class="bold">Tested-by:</strong>.</p>
<h2 id="_idParaDest-356" class="calibre7"><a id="_idTextAnchor385" class="pcalibre1 pcalibre calibre6"/>The art of the change review</h2>
<p class="calibre3">Completing a peer review of changes is time-consuming (although so is using version control), but the benefits are huge: better code quality, a reduction in the time needed for quality assurance testing, transfer of knowledge, and so on. The change can be reviewed by a peer developer, reviewed by a community (requiring consensus), or reviewed by the maintainer or one of their lieutenants.</p>
<p class="calibre3">Before beginning the code review process, you should read through the description of the proposed changes to discover why the change was proposed and decide whether you are the correct person to perform the review (that is one of the reasons why good commit messages are so important). You need to understand the problem that the change tries to solve. You should familiarize yourself with the context of the issue, and with the code in the area of changes.</p>
<p class="calibre3">The first step is to reproduce the state before the change and check whether the program works as described (for example, that the bug in a bugfix can be reproduced). Then, you need to check out the topic branch with the proposed changes and verify that the result works correctly. If it works, review the proposed changes, creating a comprehensive list of everything wrong (though if there are errors early in the process, it might be unnecessary to go deeper), as follows:</p>
<ul class="calibre16">
<li class="calibre15">Are the commit messages descriptive enough? Is the code easily understood?</li>
<li class="calibre15">Is the contribution<a id="_idIndexMarker1391" class="pcalibre1 pcalibre calibre6"/> architected correctly? is it architecturally sound?</li>
<li class="calibre15">Does the code comply with the project’s coding standards and with the agreed-upon coding conventions?</li>
<li class="calibre15">Are the changes limited to the scope described in the commit message?</li>
<li class="calibre15">Does the code follow the industry’s best practices? Is it safe and efficient?</li>
<li class="calibre15">Is there any redundant or duplicate code? Is the code as modular as possible?</li>
<li class="calibre15">Does the code introduce any regressions in the test suite? If it is a new feature, does the change include the tests for the new feature, both positive and negative?</li>
<li class="calibre15">Is the new code performing the way it did before the change (within the project’s tolerances)?</li>
<li class="calibre15">Are all the words spelled correctly, and does the new version follow the formatting guidelines for the content?</li>
</ul>
<p class="calibre3">This is only one possible proposal for such a code review checklist. Depending on the specifics of the project, there might be more questions that need to be asked as a part of the review; make the team write their own checklist. You can find good examples online.</p>
<p class="calibre3">Divide the problems that you have found during reviews into the following categories:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Wrong problem</strong>: This feature does not lie within the scope of the project. It is sometimes used for a bug that cannot be reproduced. Is the idea behind the contribution sound? If so, eject the changes with or without prejudice and do not continue the analysis for the review.</li>
<li class="calibre15"><strong class="bold">Does not work</strong>: This does not compile, introduces a regression, doesn’t pass the test suite, doesn’t fix the bug, and so on. These problems absolutely must be fixed.</li>
<li class="calibre15"><strong class="bold">Fails best practices</strong>: This does not follow the industry guidelines or the project’s coding conventions. Is the contribution polished? These are pretty important to fix, but there might be some nuances as to why it is written the way it is.</li>
<li class="calibre15"><strong class="bold">Does not match</strong> <strong class="bold">reviewer preferences</strong>. In this case, you should suggest modifications, or alternatively ask for clarification.</li>
</ul>
<p class="calibre3">Minor problems, for <a id="_idIndexMarker1392" class="pcalibre1 pcalibre calibre6"/>example, typos or spelling errors, can be fixed immediately by the reviewer. If the exact problem repeats itself, however, consider asking the original author for a fix and resubmission; this is done to spread knowledge. You should not be making any substantive edits in the review process (barring extenuating circumstances).</p>
<p class="calibre3">Ask, don’t tell. Explain your reasoning about why the code should be changed. Offer ways to improve the code. Distinguish between facts and opinions. </p>
<h2 id="_idParaDest-357" class="calibre7"><a id="_idTextAnchor386" class="pcalibre1 pcalibre calibre6"/>Responding to reviews and comments</h2>
<p class="calibre3">Changes are not always accepted on the first try. You can and will get suggestions for improvement (and other comments) from the maintainer, the code reviewer, and other developers. You might even get these comments in the patch form or a fixup commit form.</p>
<p class="calibre3">First, consider leading your response with an expression of appreciation for the commenter having taken the time to perform a review. If anything in the review is unclear, do ask for clarification; if there is a lack of understanding between you and the reviewer, offer clarification.</p>
<p class="calibre3">The next step is often to polish and refine the changes. Then, you should resubmit them (perhaps, marking them as <strong class="bold">v2</strong>). You should respond to the review for each commit and for the whole series.</p>
<p class="calibre3">If you are responding to comments in a pull request, reply in the same way. In the case of patch submissions via email, you can put the comments for a new version (with a response to the review or a description of the difference from the previous attempt), either between three dashes <code>diffstat</code>, or at the top of an email separated from what is to be in the commit message by a “scissors” line, for example, <code>git </code><code>format-patch --notes</code>.</p>
<p class="calibre3">Depending on the project’s governance structure, you will likely have to wait for the changes to be considered good and ready for inclusion. This can be the decision of a benevolent dictator for life in open source projects, or the decision of the team leader, a committee, or a consensus. It is considered a good practice to summarize the discussion while submitting a <a id="_idIndexMarker1393" class="pcalibre1 pcalibre calibre6"/>final version of a feature.</p>
<p class="calibre3">Note that changes that have been accepted might nevertheless go through a few more stages before finally graduating to the stable branch and being present in the project.</p>
<h1 id="_idParaDest-358" class="calibre5"><a id="_idTextAnchor387" class="pcalibre1 pcalibre calibre6"/>Other recommendations</h1>
<p class="calibre3">In this section, you<a id="_idIndexMarker1394" class="pcalibre1 pcalibre calibre6"/> will find the best practices and recommendations that do not fit cleanly into one of the areas described so far, namely starting a project, working on a project, and integrating changes.</p>
<h2 id="_idParaDest-359" class="calibre7"><a id="_idTextAnchor388" class="pcalibre1 pcalibre calibre6"/>Don’t panic, recovery is almost always possible</h2>
<p class="calibre3">As long as you have committed your work and stored your changes in the repository, it will not be lost. It could only perhaps be misplaced. Git also tries to preserve your current uncommitted (unsaved) work, but it cannot distinguish for example between the accidental and the conscious removal of all the changes to the working directory with <code>git reset --hard</code>. Therefore, make sure to commit or stash your current work before trying to recover lost commits.</p>
<p class="calibre3">Thanks to the reflog (both for the specific branch and for the <code>HEAD</code> ref), it is easy to undo most operations. Then, there is the list of stashed changes (see <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>), where your changes might be hiding. And there is <code>git fsck</code> as the last resort. See <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>,<em class="italic"> Git Administration</em>, for some further information about data recovery.</p>
<p class="calibre3">If the problem is that you have made a mess of the working directory, stop and think. Do not drop your changes needlessly. With the help of interactive add, interactive reset (the <code>--patch</code> option), and <a id="_idIndexMarker1395" class="pcalibre1 pcalibre calibre6"/>interactive checkout (the same), you can usually disentangle the mess.</p>
<p class="calibre3">Running <code>git status</code> and carefully reading its output helps in many cases where you are stuck after doing some lesser-known <code>git</code> operation.</p>
<p class="calibre3">If you have a problem with a rebase or merge, and you cannot pass the responsibility to another developer, there is always the third-party <code>git-imerge</code> tool.</p>
<h2 id="_idParaDest-360" class="calibre7"><a id="_idTextAnchor389" class="pcalibre1 pcalibre calibre6"/>Don’t change the published history</h2>
<p class="calibre3">Once you have made your changes public, you should ideally consider those revisions to be etched in stone, immutable, and unchanging. If you find problems with commits, create a fix (perhaps by undoing the effect of the changes with <code>git revert</code>). This is all described in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>,<em class="italic"> Keeping History Clean</em>: that is, unless it is stated explicitly in the development documentation that these specific branches can be rewritten or redone; but it is nevertheless better to avoid creating such branches.</p>
<p class="calibre3">In some rare cases, you might really need to change the history: remove a file, clean up an unencrypted stored password, remove accidentally added large files, and so on. If you need to do it, notify all the developers of the fact.</p>
<h2 id="_idParaDest-361" class="calibre7"><a id="_idTextAnchor390" class="pcalibre1 pcalibre calibre6"/>Numbering and tagging releases</h2>
<p class="calibre3">Before you release a new version of your project, mark the version to be released with a signed tag. This ensures the integrity of the just-created revision.</p>
<p class="calibre3">There are various conventions for naming the release tags and using release numbering. One of the more common ones is tagging releases by using, for example, <code>1.0.2</code> or <code>v1.0.2</code> as a tag name.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If the integrity of the project is important, consider using signed merges for integration (that is, merging signed tags). See <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>,<em class="italic"> Collaborative Development with Git</em>, and for signed pushes, see <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>,<em class="italic"> </em><em class="italic">Git Administration</em>.</p>
<p class="calibre3">There are different <a id="_idIndexMarker1396" class="pcalibre1 pcalibre calibre6"/>conventions for naming releases. For example, with time-based releases, there is the convention of naming releases after dates, such as <code>2015.04</code> (or <code>15.04</code>). Then, there is the common convention <a id="_idIndexMarker1397" class="pcalibre1 pcalibre calibre6"/>of <code>MAJOR.MINOR.PATCH</code> numbering, where <code>PATCH</code> increases when you are making backward-compatible bug fixes, <code>MINOR</code> is increased when adding functionality that is backward compatible, and the <code>MAJOR</code> version is increased when making incompatible API changes. Even when not using full semantic versioning, it is common to add a third number for maintenance releases, for example, <code>v1.0</code> and <code>v1.0.3</code>.</p>
<h2 id="_idParaDest-362" class="calibre7"><a id="_idTextAnchor391" class="pcalibre1 pcalibre calibre6"/>Automate where possible</h2>
<p class="calibre3">You should not only have the coding standards written down in the development documentation; you also need to enforce them. Following these standards can be facilitated with client-side hooks (<a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>,<em class="italic"> Customizing and Extending Git</em>) and enforced with server-side hooks (<a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>,<em class="italic"> </em><em class="italic">Git Administration</em>).</p>
<p class="calibre3">Hooks can also help by automatically managing tickets in the issue tracker and selecting an operation based on given triggers (patterns) in the commit message. Hooks can also be used to protect against rewriting the history.</p>
<p class="calibre3">Consider using third-party solutions, such as Gitolite or GitLab, to enforce rules for access control. If you need to do a code review, use appropriate tools such as Gerrit or the pull requests<a id="_idIndexMarker1398" class="pcalibre1 pcalibre calibre6"/> of GitHub, Bitbucket, or GitLab.</p>
<h1 id="_idParaDest-363" class="calibre5"><a id="_idTextAnchor392" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">These recommendations, based on the best practices of using Git as a version control system, can really help your development and your team. You have learned the steps along the road, starting from an idea, going all the way, and ending with the changes being integrated into the project. These checklists should help you develop better code.</p>
<h1 id="_idParaDest-364" class="calibre5"><a id="_idTextAnchor393" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Emma Jane Hogbin Westby: <em class="italic">Git for Teams</em> (2015), O’Reilly Media</li>
<li class="calibre15"><em class="italic">Learn Git </em><em class="italic">Branching </em><a href="https://learngitbranching.js.org/" class="pcalibre1 pcalibre calibre6">https://learngitbranching.js.org/</a></li>
<li class="calibre15"><em class="italic">Conventional Commits: A specification for adding human and machine-readable meaning to commit </em><em class="italic">messages </em><a href="https://www.conventionalcommits.org/" class="pcalibre1 pcalibre calibre6">https://www.conventionalcommits.org/</a></li>
<li class="calibre15"><em class="italic">Commitizen - a release management tool designed for </em><em class="italic">teams </em><a href="https://commitizen-tools.github.io/commitizen/" class="pcalibre1 pcalibre calibre6">https://commitizen-tools.github.io/commitizen/</a></li>
<li class="calibre15">Sage Sharp: <em class="italic">The Gentle Art Of Patch Review</em> (2014) <a href="https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/" class="pcalibre1 pcalibre calibre6">https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/</a></li>
<li class="calibre15"><em class="italic">Dangit, </em><em class="italic">Git!?! </em><a href="https://dangitgit.com/en" class="pcalibre1 pcalibre calibre6">https://dangitgit.com/en</a></li>
<li class="calibre15">Julia Evans: <em class="italic">Oh shit, git!</em> Zine <a href="https://wizardzines.com/zines/oh-shit-git/" class="pcalibre1 pcalibre calibre6">https://wizardzines.com/zines/oh-shit-git/</a></li>
<li class="calibre15"><em class="italic">Semantic Versioning </em><em class="italic">2.0.0 </em><a href="https://semver.org/" class="pcalibre1 pcalibre calibre6">https://semver.org/</a></li>
</ul>
</div>
</body></html>