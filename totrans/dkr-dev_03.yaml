- en: '*Chapter 2*: Using VirtualBox and Docker Containers for Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced virtualization and containerization.
    In this chapter, we'll demonstrate how you can use software such as VirtualBox
    to create virtual machines and we'll use Docker to create containers. The focus
    of this chapter will be on using these technologies for development on your workstation.
  prefs: []
  type: TYPE_NORMAL
- en: A common problem among developers who work on multiple projects is that, over
    time, they end up with a lot of software installed on their workstations that
    they don't currently use. This can be so problematic that the developer might
    reformat their workstation's hard drive and reinstall the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Both VirtualBox and Docker containers can be used to resolve this problem. The
    software you install stays within either the **virtual machine's** or the container's
    filesystem and is separate from the workstation's native filesystem. If you delete
    a virtual machine or container, all the files installed therein are removed –
    including any applications or development software that was installed.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that arises for developers is the version of software required
    to work on a specific project. If the developer is working on one project that
    uses Node.js v12 and another that uses Node.js v10, they can't really run both
    projects on the workstation at the same time and switching between versions of
    Node.js is doable, but ugly. This is a non-issue with virtual machines or containers
    – you can have one virtual machine with Node.js v12 and another with Node.js v10
    and run both virtual machines at the same time. It is similar with two containers,
    one for each version of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization is very useful when you need to model an entire machine. If your
    production systems are virtual machines or physical machines, a virtual machine
    is a good way to emulate that environment. Virtualization is terrific for running
    a complete alternate operating system on the workstation; that is, you can run
    Windows 10 in a virtual machine on a macOS or Linux workstation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Host filesystem pollution problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using VirtualBox for virtual machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be downloaded from: [https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2](https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3gX9dFE](https://bit.ly/3gX9dFE)'
  prefs: []
  type: TYPE_NORMAL
- en: Host filesystem pollution problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both virtualization and containerization solve certain problems developers face.
    There's no real point in installing server-style software systems on your workstation
    – that kind of software can be installed in a virtual machine or a Docker container.
    Using this strategy means you don't have to pollute your workstation's filesystem,
    you won't have software version conflicts, and you can run a different operating
    system than the one your workstation runs.
  prefs: []
  type: TYPE_NORMAL
- en: The pollution problem is a real concern for developers – they end up with a
    lot of cruft, or installed software, that they don't use day to day, but that
    take up system resources. We will learn to use virtualization or containerization
    to install that software in a way that isn't installed on your host's filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Using VirtualBox for virtual machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options for running virtual machines on your workstation.
    These include Parallels (for macOS), KVM/QEMU (for Linux), VMware (commercial
    for several host operating systems), and VirtualBox (an Oracle product). We'll
    use VirtualBox because it is open source and free to use. It's also portable in
    the sense that you can run VirtualBox and your virtual machines on Linux, Windows,
    macOS, and other host operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtualization uses special instructions and features of your workstation's
    CPU to run a generic pseudo-computer system (virtual machine) on your host. Within
    this virtual machine, you can install a wide range of operating systems, including
    various versions of Windows Server, Linux, BSD, and so on. The operating system
    running in a virtual machine is called the guest operating system; the operating
    system running on your workstation is called the host operating system.
  prefs: []
  type: TYPE_NORMAL
- en: As the guest operating system executes code, it will be required to perform
    disk and network access, execute privileged CPU instructions, and otherwise access
    shared resources with the host. The virtualization software effectively traps
    these guest operating system accesses and translates them into host operating
    system calls. Thus, code running in the virtual machine is mostly running at full
    native CPU speed until these shared access traps are executed – then there is
    some overhead for the translation to host accesses.
  prefs: []
  type: TYPE_NORMAL
- en: The guest virtual machines may be configured before you install an operating
    system within. You can set how much RAM to use, one or more virtual disks, one
    or more Ethernet controllers, a graphics card, an ISO file (installation media)
    to insert in the virtual CD-ROM drive, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You typically set RAM, disk space, and the number of virtual CPU cores to appropriate
    values for your guest operating system and the apps you intend to use within the
    guest. For example, if you are going to run Windows in a virtual machine, you
    might want to give it at least 2 virtual CPU cores and 8 gigabytes of RAM and
    32 gigabytes of disk space. If you are going to run an application in the virtual
    machine that needs more than 8 gigabytes of memory, you would want to assign more
    RAM; if the app needs a lot of disk space, you would assign more disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To boot the virtual machine, use the VirtualBox program (user interface). When
    the virtual machine boots, it acts just like a physical PC – as far as the installer
    on the installation media is concerned, it is a physical PC. The installer will
    work as if you were installing on a new PC or reinstalling on your PC.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual machine may present its console or desktop within a window on your
    workstation's desktop, or it can be **headless**. A headless virtual machine is
    similar to a server machine – you access it via FTP, SSH, and so on. You would
    use a headless virtual machine when you have no use for the operating system console
    or graphical interface. The headless machine provides all the services of a server
    you would remotely access.
  prefs: []
  type: TYPE_NORMAL
- en: 'You start a headless virtual machine from the command line instead of the VirtualBox
    user interface program. This is done via the `VBoxManage` command, which is documented
    here: [https://www.virtualbox.org/manual/ch08.html](https://www.virtualbox.org/manual/ch08.html).
    It is more likely that you will be using a guest operating system with a graphical
    user interface, though.'
  prefs: []
  type: TYPE_NORMAL
- en: A typical headless virtual machine might be used to run a **LAMP** application—**Linux,
    Apache, MySQL, and PHP** all contained neatly within the virtual machine and not
    within the filesystem of your workstation. You can model a scalable LAMP application
    by starting a headless virtual machine that runs MySQL and two headless virtual
    machines that run the HTTP server and the PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: A typical graphics/desktop virtual machine might be used to run Windows in a
    window on your Mac computer, to run Linux in a window on your Mac computer, to
    run Linux in a window on your Windows machine, and so on. If you like to use Linux,
    but you need to run Windows programs, doing it in a virtual machine is a good
    way to go.
  prefs: []
  type: TYPE_NORMAL
- en: A non-headless install will have a few display options. The entire desktop can
    be displayed in a window on your host's desktop. This is the default display mode.
    The window can be resized like any other window on the desktop. However, within
    the interior of the window, the guest's desktop will not resize to fit until you
    install the VirtualBox guest additions in the guest.
  prefs: []
  type: TYPE_NORMAL
- en: The guest window can be made full screen. This makes the guest look like it's
    the operating system running native on the workstation. If you are running macOS,
    you can switch desktops using the macOS gestures and go back and forth between
    full-screen Windows and full-screen macOS desktops.
  prefs: []
  type: TYPE_NORMAL
- en: For some host operating systems, the guest can be put into seamless mode, where
    the desktop is not displayed at all, but any applications running in the virtual
    machine render their windows on top of the host desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a mixture of virtual machine application windows and your host
    operating system application menus on your desktop, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Microsoft Windows 10 running fullscreen in VirtualBox on a Linux
    host](img/B11641_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Microsoft Windows 10 running fullscreen in VirtualBox on a Linux
    host
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you may run and manage a full Windows installation on your workstation
    within a virtual machine. You can access the files and directories on your host
    if you set up Samba for file sharing on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, portions of this book were written using Microsoft Word 365, running
    in a Windows 10 virtual machine on a Linux host. The Docker examples that follow
    were executed on the Linux host. This is a great example of why you would run
    a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft allows you to buy a Windows 10 license and use it to activate Windows
    10 within a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Apple only allows macOS to be run in a virtual machine on Apple hardware. It
    is a violation of their licensing terms to run macOS within a virtual machine
    on a PC running Windows or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and most BSD variants are generally free to use on a PC or within a virtual
    machine on a PC.
  prefs: []
  type: TYPE_NORMAL
- en: Guest additions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Windows and Linux guest operating systems, you can install drivers that
    fully integrate the guest and host operating systems. These drivers are known
    as guest additions and you can download these from the VirtualBox site: [https://virtualbox.org](https://virtualbox.org).
    They are installed within the virtual machine as any program you install for Windows
    or Linux. The integration with the host is quite useful.'
  prefs: []
  type: TYPE_NORMAL
- en: The guest additions display drivers that allow you to use the full resolution
    of the host's screen and, if you're running in windowed mode (guest desktop in
    a host desktop window), resizing the window will cause the guest desktop to resize
    to fit the new window size. If you want to use the seamless windows feature, you
    are required to install the guest display drivers.
  prefs: []
  type: TYPE_NORMAL
- en: The additions provide mouse pointer integration. This allows you to freely move
    the cursor between physical screens, from guest windows to host windows. Otherwise,
    the mouse would be captured by the virtual machine so that it can manage pointer
    events.
  prefs: []
  type: TYPE_NORMAL
- en: The guest additions also share the host and guest clipboards as if they were
    one clipboard. You can select and copy text in a macOS host application and then
    paste that copied text into a Windows application running in the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux guests, the additions allow you to share host filesystem directories
    and files. This is particularly useful because you can use the host operating
    system tools and software to develop files seen by the host. For example, you
    create a shared folder on your macOS machine for your project's working directory.
    You can use your macOS editors to edit files in the project and, in the virtual
    machine, you can run Linux native compilers or tools to execute your project.
    Let's now begin by installing VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VirtualBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The URL for VirtualBox is [https://www.virtualbox.org/](https://www.virtualbox.org/).
    There, you can find documentation and downloads for the various host platforms
    (workstation operating systems), add-ons, see screenshots, see recommended third-party
    software that works with VirtualBox, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Windows installation instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install the Windows installation, go to the downloads page at the VirtualBox
    site, download the installer for the latest version, and then, when the download
    is complete, double-click on it. Then, follow the onscreen instructions.
  prefs: []
  type: TYPE_NORMAL
- en: macOS installation instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For macOS installation, you can use Homebrew or download the installer `.dmg`
    file from the VirtualBox site and install from that. To use Homebrew, you only
    need to enter one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Homebrew ([https://brew.sh/](https://brew.sh/)) is the missing package manager
    for macOS. It is a command-line system for installing software from Homebrew's
    repositories. It is a terrific tool for augmenting the software shipped with macOS.
    The software in those repositories is updated far more frequently than the Apple
    software updates.
  prefs: []
  type: TYPE_NORMAL
- en: Linux installation instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The installation instructions for VirtualBox on Linux varies depending on the
    Linux distribution that you use on your workstation. Since there are so many different
    distributions, we'll cover Ubuntu to give you an idea of what to do and provide
    you with helpful pointers for installing VirtualBox on other distributions (Arch
    Linux, Fedora, and suchlike).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ubuntu, you can install VirtualBox from the Ubuntu Software Center, download
    a `.deb` file from the VirtualBox site, or use `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For Arch Linux and its variants, you can follow the instructions on the terrific
    Arch wiki at [https://wiki.archlinux.org/index.php/VirtualBox](https://wiki.archlinux.org/index.php/VirtualBox).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Fedora or other RPM-based Linux distributions, follow the instructions
    at the VirtualBox site: [https://virtualbox.org](https://virtualbox.org). Let''s
    now learn how to use Docker containers.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is generally used to create containers, which run your application as
    if in a headless virtual machine. In fact, on host operating systems that are
    not Linux-based, Docker effectively runs Linux in a virtual machine and runs your
    containers within that virtual machine. This is done transparently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to install VirtualBox yourself. Docker is packaged in such a
    way that it will install or use any already-existing virtualization technology
    (for example, a hypervisor) for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier versions of Docker installed VirtualBox to create its virtual machine,
    but more recent virtualization technology implemented within the operating systems
    allows Docker to use those technologies instead.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Linux containers expects the host operating system or the virtual
    machine to be running Linux. The containers share the Linux kernel with the host.
    Docker can be used to run Windows native containers, in a similar manner to Linux
    containers. The Windows kernel is shared among the host and guests. For discussion
    purposes, we'll focus on the Linux host and guests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker containers are typically used to implement something like headless virtual
    machines. The use of virtual machines for each application you might create a
    container for is expensive – you must reserve a fixed amount of RAM and disk space
    for the virtual machine. On a 16 gigabyte RAM MacBook Pro, you can roughly fit
    three 4 gigabyte RAM virtual machines running at the same time. You do need to
    have some RAM for the host operating system to run. Starving the host or guest
    virtual machines of RAM will cause them to swap, which crushes performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Docker containers illustrated](img/B11641_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Docker containers illustrated
  prefs: []
  type: TYPE_NORMAL
- en: Containers are separated from the host operating system using host operating
    system features. The containers use the Linux kernel's namespaces feature ([https://manpages.debian.org/stretch/manpages/namespaces.7.en.html](https://manpages.debian.org/stretch/manpages/namespaces.7.en.html))
    to separate the code running in containers from one another, and cgroups (see
    [https://manpages.debian.org/stretch/manpages/cgroups.7.en.html](https://manpages.debian.org/stretch/manpages/cgroups.7.en.html))
    to limit the resources that a container may use (including RAM and CPU). Containers
    also use the Linux `unionfs` ([https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html](https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html))
    filesystem to implement the layered filesystem our containers see when running
    under Docker.
  prefs: []
  type: TYPE_NORMAL
- en: From the applications running within the container's point of view, the container
    is a whole and dedicated computer; there is no direct communication with the host
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Containers do not require the number of virtual CPUs or a dedicated block of
    RAM per container.
  prefs: []
  type: TYPE_NORMAL
- en: You are only limited by how much RAM the containers need and how much RAM the
    host has.
  prefs: []
  type: TYPE_NORMAL
- en: Containers share the host's Linux kernel, while virtual machines must have a
    whole operating system installed!
  prefs: []
  type: TYPE_NORMAL
- en: You may choose to limit the resources used by a container instance, but this
    is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Host resources may be shared with the guest containers. The host's networking
    can be shared with any container, but this is only really needed for containers
    running applications that require this. For example, to use the host's Bonjour
    networking functionality, the guest would use the host's networking.
  prefs: []
  type: TYPE_NORMAL
- en: The guest containers may expose ports to the host and any computers that can
    access the host. For example, a container running an HTTP server might expose
    port 80 and, when the host is accessed at port 80, the container responds.
  prefs: []
  type: TYPE_NORMAL
- en: Containers have driven the concept of microservices. An application using microservice
    architecture implements a collection of services that communicate among themselves
    and the host. These services are meant to be trivial to implement – only the specific
    code required to support the service needs to be included in the program. It's
    not uncommon for microservices to be implemented in a single source code file
    with just a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Container architecture is quite scalable. You can run multiple containers running
    the same application (horizontal scaling) and you can dedicate more host resources
    to the container system (vertical scaling). For example, you might create a container
    running an HTTP server; you can create a server farm by instantiating as many
    of these containers as you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker for development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great reason to use Docker for development is that you don't have to install
    any programs, other than Docker itself, on your host to enable development. For
    example, you can run Apache in a container without installing it on your workstation.
  prefs: []
  type: TYPE_NORMAL
- en: You can also mix and match software versions within your containers. A microservices
    architecture might require one container to use Node.js version 8 and another
    container to use Node.js version 10\. This is obviously problematic on a single
    host, but is straightforward when using Docker. One container installs and runs
    version 8, and another container installs and runs version 10.
  prefs: []
  type: TYPE_NORMAL
- en: During development, you can share your project's development files with the
    container so that when you edit these files, the container sees that the files
    have changed.
  prefs: []
  type: TYPE_NORMAL
- en: Each container has its own set of global environment variables. It's typical
    to configure the application using environment variables, rather than in source
    code or configuration files within the container.
  prefs: []
  type: TYPE_NORMAL
- en: When you are ready to deploy or publish a container, you can push it to a container
    hosting service, such as Docker Hub. In fact, Docker Hub is a terrific source
    for already-existing containers that may aid you in your project development.
    There are pre-made container images for MongoDB, Node.js (various versions), Apache,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Container construction is effectively object-oriented. You inherit from a base
    container and add the functionality you need to that. You can create a Node.js
    application in a container that starts with a ready-made Node.js container, install
    `npm` packages in the container, and run your custom code in the container.
  prefs: []
  type: TYPE_NORMAL
- en: You can always develop your own base containers. For these, you can start with
    ready-made packages for a flavor of Linux. The Alpine Linux base container is
    popular because it is one of the most lightweight images to start from. There
    are base containers for Fedora, Ubuntu, Arch Linux, and more. Whichever of these
    Linux containers you start from, you can use that operating system's installation
    tools to add packages from the official repositories for that operating system;
    that is, `apt` for Ubuntu, `yum` for Fedora, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to Dockerize an existing application that wasn't designed to
    run in a container. You can choose a flavor and version of Linux for the container
    that is compatible with the application, and you can split up the application
    into multiple container images to afford future scalability.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might have an older LAMP application that requires specific
    versions of PHP, MySQL, and Apache, as well as an older version of Ubuntu. You
    would break this up into a distinct MySQL container, and a distinct Apache plus
    PHP container. You would want your Apache+PHP containers to use a shared volume
    so that they're all running the same and latest PHP source code. You can set up
    the MySQL container to use master-slave replication. You can set up a load balancer
    in another container that balances between as many Apache and PHP container instances
    as you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Time for a hands-on example, using Docker for development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a GitHub repository to share code examples for this book. The
    repository can be found at [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers).
    You should fork this repository, and then clone it to your host. Creating the
    fork means you can manage your copy of the repository as you see fit without requiring
    permissions. The code of interest for this section is in the `chapter2/` directory.
    The code here implements a small Apache+PHP application that is designed to run
    in a container. There are `sh` scripts to perform the Docker command lines, so
    you don't have to keep typing in a long string of command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the code, let''s make sure that Docker is installed properly.
    The `docker ps` command prints a list of all running Docker containers. We can
    see we have no containers running and there is an actual `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A Dockerfile is a text file that defines how to build a Docker container image.
    The container is not started; it is just created on disk. Once built, you can
    start as many instances as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Docker commands via sh scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to make heavy use of the `docker cli` command and `sh` scripts
    to automate command-line use. The use of `sh` script files has a few advantages.
    Once the script file is created, you don''t have to remember what all the command-line
    switches to the command are. Once the script is correct, you won''t have any issues
    due to typos or improper command-line switches. Typing the script filename is
    much shorter and your shell should autocomplete it when you type the first few
    characters of the name and hit the *Tab* key. Finally, the names of the scripts
    are mnemonic: `build.sh` means build the container, `run.sh` means run the container,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sh` scripts we provide are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./build.sh`: This builds the container from the Dockerfile. You will want
    to run this script whenever you edit the Dockerfile, or if the container otherwise
    needs to be built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./debug.sh`: This runs the container in debug mode. In debug mode, Apache
    is run in foreground mode and you can hit `^C` to stop the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./run.sh`: This runs the container as a daemon. Unlike the `./debug.sh` script,
    you will be returned to the command-line prompt, with the container running in
    Docker. You will use this script to run the container locally, as if in production,
    so that you can test production behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./stop.sh`: When you have your container running in the background, this script
    can be used to stop it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./shell.sh`: Sometimes, when creating your container and editing the Dockerfile,
    things do not work as expected. You can use this script to get a Bash command
    line running within the container. From this command line, you can inspect and
    diagnose the problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./persist.sh`: This script demonstrates using a named volume to persist the
    application state within the container. That is, with a named volume, you can
    stop and restart the container and the contents of the volume are persisted. The
    volume is mounted in the container as if it were a disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate how building a container using a Dockerfile works, we''ve created
    one in the GitHub repository, in the `chapter2/` directory (file named `Dockerfile`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what the Dockerfile does, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile inherits from the Debian image on Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the time zone for the container to match the time zone of the host; in
    other words, ensure that the timestamps of files inside the container and on the
    host match. This is important when mapping host directories to the container's
    filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then install Apache and PHP 7.3\. These are installed in the container's
    filesystem and not on the host's filesystem. We have avoided the pollution problem
    of having a version of both installed on the host that later become unused when
    not working on this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also installed some command-line utilities that allow us to examine the state
    of the built container from a Bash shell running within the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the user and group that will be running the project in the container
    is `root`. In order to provide some typical Unix/Linux security, we want to run
    as an actual user; in our case, the username is `app`. So we add the user to the
    container's environment with `useradd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to put our PHP scripts in `/home/app`, with the ability to map
    our working directory with our PHP scripts on the host over `/home/app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our demo app writes its state to `/data`, so we need to create it and ensure
    that the PHP script running as a user app can read and write files there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a custom PHP configuration file that we want to use within the container,
    so we copy it to the container in the correct location in the filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to enable the `userdir` and `php7.3` modules. This allows us to run
    PHP scripts from Apache as well as have our PHP scripts in `/home/app/public_html`
    accessed via a URL such as `http://localhost/~app/index.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the container is started, it needs to run some program or script within
    the container. We use an `sh` script named `entrypoint.sh` in the `/home/app`
    directory to start the application. We can edit this file to suit our needs during
    development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could have chosen from a variety of Linux flavors from which to start. We
    chose Debian here because the configuration commands should be familiar to most
    readers. If you install Debian in a virtual machine, you'd use the same commands
    to install and maintain your system. Debian isn't the smallest or most lightweight
    of Linux images to start from; Alpine is a great choice if you want to make your
    container use fewer resources. If you choose to use Alpine, be sure to read up
    on how to install packages and maintain the system using Alpine.
  prefs: []
  type: TYPE_NORMAL
- en: Note that whichever Linux image you start from, it's sharing the Linux kernel
    with your host machine. Only within the container is it Debian – your host operating
    system can be some other Linux distribution. What you install inside the container
    is not installed on your workstation, only within the container. Obviously, you
    shouldn't mix, say, Debian commands and installed packages directly on an Arch
    Linux workstation.
  prefs: []
  type: TYPE_NORMAL
- en: When you install Apache on an actual host or virtual machine, you configure
    it by using the `a2enmod` and `a2dismod` commands, as well as by editing the various
    configuration files in `/etc/apache2`. What we do here is edit the configuration
    file locally on our workstation, and then we copy that configuration file to the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile installs a few Debian applications within the container using
    `apt-get`. The `RUN` command that spawns `apt-get` within the container uses the
    `-y` switch to answer `yes` to any questions `apt-get` might ask, the `-qq` switch
    to make the `apt-get` command less verbose, and the `>/dev/null` redirection of
    `stdio` to make the Docker build (`build.sh`) output compact. Without the `-qq`
    and `stdout` redirection, the build output would contain every package and dependency
    downloaded, along with all the installation commands for all these packages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the final line in the Dockerfile is a CMD, the command to run when
    the container is instantiated. In our case, we use an array with one item, `entrypoint.sh`.
    The array makes it so that you can hit *Ctrl* + *C* to stop the container. The
    `entrypoint.sh` script runs Apache in the container after performing the necessary
    initialization. Also note that we enabled both the `userdir` and `php7.3` modules
    in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a Dockerfile, we need to be able to build the container so
    that we can then use it. This is where the first of our `.sh` scripts comes into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding build.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `build.sh` script is used to build the container. You will need to build
    the container at least once so that we can edit files on the host and see the
    changes in action within the container. You will need to rebuild the container
    each time you want to try the container in production mode and have the latest
    versions of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` flag says to name the container `chapter 2`. The Dockerfile is found
    in the current directory. The output of the `build.sh` script is lengthy, so it
    is omitted here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that each step printed in the output while building the container
    corresponds to a line in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The container is incrementally built, as described by the Dockerfile. Each step
    is built in an image layer denoted with a hash value – those are the hex hash
    values printed. When you build the container again, Docker can start from the
    state of any of those layers' `/` hash values, reducing the need to constantly
    rebuild the container from scratch. Each layer is simply a diff (difference) between
    the current layer's requirements and the state of the previous layer.
  prefs: []
  type: TYPE_NORMAL
- en: The first layer is the Debian image. The next layer is an intermediate image,
    the diff between the result of the `ENV` command in the Dockerfile and the original
    Debian image. The next layer is the diff between this previous intermediate image
    and the result of the `apt-get` installed packages. Note that we use `&&` to pack
    a few `apt-get` commands into one layer in the container. This greatly speeds
    up the build process. The layering continues as each command in the Dockerfile
    is processed by the Docker build command.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is smart about how it caches and works with the layers. It doesn't have
    to download the Debian image each time you build; it can start building from a
    previous intermediate stage if it knows the previous steps have not changed the
    state of the container to that point.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we need to build the container, because we've made changes to the Dockerfile,
    we use the `build.sh` script. Once we have the container built, we have a few
    ways to use it. The `debug.sh` script is probably the most common script you'll
    use during development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding debug.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `debug.sh` script runs the container image that is not in daemon mode.
    You can hit *Ctrl* + *C* to stop the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker run` command takes many optional arguments that are too numerous
    to detail here. For more complete information on all of the possible command-line
    arguments to `docker run`, refer to the `docker run` documentation on the Docker
    site: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
    We''ll only cover the ones used in our scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use `–rm`, which tells Docker to clean up when the container exits,
    removing the container and filesystem for the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` flag tells Docker to map port `80` from the container (HTTP) to port
    `8086` on the host; you can access the HTTP server in the container by using port
    `8086` on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–name` argument names the running container; if you don't provide a name,
    you'll have to use `docker ps` to get the hash that identifies the container to
    stop it using `docker stop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-v` switch mounts volumes in the container. A volume can be a directory
    of a file on the host, a named volume that Docker manages for you. If you want
    to stop and restart the container and retain data that is written to the filesystem
    by the container, you must mount a volume and the container must write to this
    volume. You can mount multiple volumes, if you like. In our `debug.sh` script,
    we mount the current directory with the sources over `/home/app`, so we can modify
    the sources and the container programs see that the files are changed (because
    the file timestamps are newer) as if they were inside the container, too. For
    this demo, you can edit the `index.php` script and reload the page, and you'll
    see the change in action. If you don't mount this volume, then the container will
    access the files copied to `/home/app` by the Dockerfile and the `build.sh` script;
    this is what you want for production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last argument to `docker run` is the name of the container to start – in
    our case, it's `chapter2`, the container image we created using the `build.sh`
    script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We do not persist `/data` in the container. We can do this by adding the `-v`
    switch to map a Docker volume to `/data`, which we will do in the `persist.sh`
    script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running our chapter2 container with debug.sh
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s see the container in action. We run the `build.sh` script and see that
    it succeeds. Then, we use the `debug.sh` script to launch the container in `debug/foreground`
    mode. Note that we did not do any configuration of the hostname for the container,
    so there is a warning message printed by Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On the host, we can use a browser to fetch `http://localhost:8086/~app/index.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we mapped port `8086` to port `80` of the container, we enabled the
    `userdir` module, and, in the Dockerfile, we copied the `index.php` script to
    `/home/app/public_html` (the `userdir` module).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have configured Apache with a default host and copied our files to
    `/var/www` in the Dockerfile and build process. This would have given us a cleaner
    URL, and this is what you would want to do for an actual production site. For
    our purposes, it''s good to see the Apache modules enabled and working within
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Browser showing the output of our program](img/B11641_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Browser showing the output of our program
  prefs: []
  type: TYPE_NORMAL
- en: 'When we reload the page in the browser a few times, we can see that the counter
    is being properly maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Page after we reload](img/B11641_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Page after we reload
  prefs: []
  type: TYPE_NORMAL
- en: Note that we aren't generating any HTML (yet). If you're trying this yourself,
    you can now edit the `index.php` file, change `Counterx:` to `Counter:` and reload
    the page, and you will see that the page prints `Counter:` now.
  prefs: []
  type: TYPE_NORMAL
- en: We are now set up for PHP development.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add, say, MySQL support, we'll have to modify the Dockerfile to
    install the PHP MySQL module, and enable it as we did with `userdir` and `php`.
    If we want to add a PHP framework, we either need to install it within the container
    via the Dockerfile, or add it to the `chapter2/` directory that is copied to the
    container's `/home/app` directory and, for development, mounted/bound in the container
    by replacing `/home/app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check to see that the container is running by using the `docker ps`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can exit or kill the container by pressing *Ctrl* + *C* in the window where
    we started it with `debug.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the container with the `run.sh` script, we don''t see any output
    from the container, not even the Apache warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we use `docker ps` to see that it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Loading the same URL in the browser, we see that the counter is again `1`. Reloading
    a few times, we see the counter increments as we designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can restart the container using `docker restart`. Note that the container
    was first instantiated 3 minutes ago, but since we restarted it, the status is
    `Up 1 second`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the container was only restarted, its filesystem remains intact. Reloading
    the URL in our browser, we see that the counter continues to increment. We can
    stop the container using `docker stop`, or the `stop.sh` script. The `docker ps`
    command shows no containers running. Then we start it up again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we reload in our browser, the counter is reset to `1`. This is because
    we are writing to the container's filesystem. The filesystem goes away when the
    container exits.
  prefs: []
  type: TYPE_NORMAL
- en: If we want the counter to persist between container start/restart, we'd have
    to write it to a volume that is mounted on the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We write to `/data/container.txt`, so we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mount our own `container.txt` on the host to `/data/container.txt` on the guest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount a directory on the host as `/data` on the guest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have Docker create and maintain a named or anonymous volume for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the advent of named volumes, they are the better choice. A named volume
    is created and maintained using the `-v` switch to `docker run` with just the
    name of the directory on the guest; for example, `-v name:/data`. We have a script,
    `persist.sh`, designed to make using the named volume easy.
  prefs: []
  type: TYPE_NORMAL
- en: persist.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `persist.sh` script does the same thing as the `debug.sh` script, except
    that it adds the `-v name:/data` switch to the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we run it and point our browser at `http://localhost:8086/~app/index.php`,
    we see that the counter works, even if we stop and restart the container.
  prefs: []
  type: TYPE_NORMAL
- en: run.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `run.sh` script runs the container in daemon mode – you won''t be able
    to see the application''s output without using the `docker log` command. It also
    does not mount the host directory as a volume in the container. This simulates
    the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `docker run` command, once again, but with slightly different
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The `–detach` flag to Docker Run is what causes the container to run in the
    background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The named volume is used, so the data is persisted between starting and stopping
    the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development working directory is mounted on `/home/app` within the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–restart` switch always tells Docker to restart the container when the
    system is rebooted. This is handy since you won't have to figure out some way
    to automatically start your container(s) when the operating system starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container is only able to run using the files copied to it using the Dockerfile
    and `build.sh`. If you edit files on your host, you will not see the changes within
    the running container, as with `persist.sh`. You will need to run the `build.sh`
    script every time you edit files and want them changed within the container for
    the purposes of `run.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a way to stop our running container. This is where `stop.sh` comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: stop.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `stop.sh` script will stop your `chapter2` container. This is particularly
    useful when you''ve used the `run.sh` script to launch your container in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see `run.sh` and `stop.sh` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shell.sh` script runs the container and starts the Bash shell so that
    you can use command-line programs to diagnose issues with the container as it''s
    built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows the `shell.sh` script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `/data` was created and has world write permissions.
  prefs: []
  type: TYPE_NORMAL
- en: These few `sh` scripts are enough to get you developing and using your own containers.
    As you work with Docker, you'll likely come up with additional scripts of your
    own! However,  we will see in [*Chapter 4*](B11641_04_Final_NM_ePub.xhtml#_idTextAnchor059),
    *Composing Systems Using Containers*, a way to work with Docker without the `sh`
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about how VirtualBox can be used to create
    virtual machines on your workstation and how you can use it to run Windows (or
    Linux or other operating systems) in a virtual machine. We also learned enough
    about Docker to use it to build our first application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was written using Windows 10 running within a VirtualBox virtual
    machine, running on an Arch Linux host. Microsoft Word was used within Windows,
    while the Docker commands and scripts were run and edited on the Arch Linux host.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated how we can build a LAMP-style application, without MySQL, and
    containerize it. We can mount our source code directory from the host to the container
    so that we can edit files and see the changes immediately in the container. We
    learned how to persist data, meaning that stopping and starting the container
    would retain important files and state.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore Docker Hub and build a more complex application
    that requires more than one container.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This URL is for the official Docker documentation:[https://docs.docker.com](https://docs.docker.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL is for the Dockerfile reference:[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL is for the documentation for the Docker `ps` command:[https://docs.docker.com/engine/reference/commandline/ps/](https://docs.docker.com/engine/reference/commandline/ps/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL is for the documentation pertaining to volumes and storage in Docker:[https://docs.docker.com/storage](https://docs.docker.com/storage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL is for the documentation pertaining to the Docker `run` command:[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL is for the documentation pertaining to the Docker `restart` command:[https://docs.docker.com/engine/reference/commandline/restart/](https://docs.docker.com/engine/reference/commandline/restart/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL is for the documentation pertaining to the Docker `stop` command:[https://docs.docker.com/engine/reference/commandline/stop/](https://docs.docker.com/engine/reference/commandline/stop/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
