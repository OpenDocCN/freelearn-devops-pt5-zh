- en: Chapter 4. Configuring Network Devices Using Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。使用 Ansible 配置网络设备
- en: This chapter will focus on some of the most popular networking vendors in the
    market today, namely Cisco, Juniper, and Arista, and look at how each of these
    market leading vendors have developed their own proprietary operating system to
    control network operations. The aim of this book is not to discuss which network
    vendor's solution is better, but instead look at ways network operators can utilize
    configuration management tooling today to manage network devices, now that most
    network vendors have created APIs and SDKs to programmatically control the network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注当今市场上最受欢迎的几个网络供应商，即 Cisco、Juniper 和 Arista，并探讨这些市场领先供应商如何开发自己的专有操作系统来控制网络操作。本书的目的不是讨论哪家网络供应商的解决方案更好，而是探讨网络运营商如何利用现有的配置管理工具来管理网络设备，因为大多数网络供应商已经创建了用于以编程方式控制网络的
    API 和 SDK。
- en: Once the basics of each operating system have been established, we will then
    shift focus to the hugely popular open source configuration management tool from
    Red Hat named Ansible ([https://www.ansible.com/](https://www.ansible.com/)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了每个操作系统的基础知识，我们将转向来自 Red Hat 的非常流行的开源配置管理工具 Ansible（[https://www.ansible.com/](https://www.ansible.com/)）。
- en: We will look at ways it can be used to configure network devices programmatically
    and assist with network operations. This chapter will show practical configuration
    management processes that can be used to manage network devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用它来以编程方式配置网络设备并帮助网络运营。本章将展示可用于管理网络设备的实际配置管理流程。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Network vendors' operating systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络供应商的操作系统
- en: Introduction to Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 简介
- en: Ansible modules currently available for network automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前用于网络自动化的 Ansible 模块
- en: Configuration management processes to manage network devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理网络设备的配置管理流程
- en: Network vendors' operating systems
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络供应商的操作系统
- en: Market leading networking vendors, such as Cisco, Juniper, and Arista, have
    all developed their own operating systems that allow network operators to issue
    a series of commands to network devices via a **command-line interface** (CLI).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 市场领先的网络供应商，如 Cisco、Juniper 和 Arista，都开发了自己的操作系统，允许网络运营商通过命令行界面（CLI）向网络设备发出一系列命令。
- en: 'Each vendor''s CLI is run from their bespoke operating systems:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个供应商的 CLI 都是从他们专门的操作系统运行的：
- en: Cisco Ios and Nxos
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco IOS 和 Nxos
- en: Juniper Junos
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper Junos
- en: Arista Eos
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista Eos
- en: All of these operating systems have meant that it has become easier to programmatically
    control switches, routers, and security devices provided by these vendors, as
    they seek to simplify operating network devices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作系统都使得通过编程方式控制交换机、路由器和安全设备变得更加容易，因为它们试图简化操作网络设备。
- en: The rise of DevOps in industry has also meant that it is no longer acceptable
    to not provide programmatic APIs or SDK to aid automation, with networking vendors
    now integrating with configuration management tooling, such as Puppet, Chef, Ansible,
    and Salt, to plug into DevOps tool chains.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在行业中 DevOps 的兴起也意味着不再可以不提供编程 API 或 SDK 来帮助自动化，现在网络供应商与配置管理工具（如 Puppet、Chef、Ansible
    和 Salt）集成，以插入 DevOps 工具链。
- en: Cisco Ios and Nxos operating system
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cisco IOS 和 Nxos 操作系统
- en: The Cisco IOS operating system when released was the first of its kind, providing
    a set of command lines that network operators could use to mutate the state of
    the network. However, it still had its challenges; it had a monolithic architecture,
    which meant that all processes shared the same memory space, with no protection
    between parallel processes, so it didn't align itself well to parallel updates,
    but at the time it was the clear market leader. This changed network operations
    and meant that network engineers would each individually log onto network switches
    and routers to make updates using its fully featured CLI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Cisco IOS 操作系统发布时，它是首个提供一组命令行的操作系统，网络运营商可以使用这些命令行来改变网络状态。然而，它仍然存在一些挑战；它具有单片架构，意味着所有进程共享相同的内存空间，并且在并行进程之间没有保护，因此它不适合并行更新，但在当时它是明确的市场领导者。这改变了网络操作方式，意味着网络工程师需要分别登录到网络交换机和路由器上，使用其功能齐全的
    CLI 进行更新。
- en: At the time, this greatly reduced the complexity of network operations, and
    Cisco standardized the way the networking industry carried out network operations
    in a data center. Network operators would log onto appliances and run an industry
    standard series of command lines to make changes to routers or switches, and Cisco
    ran certification programs to teach administrators how to operate the equipment
    and learn all the commands.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，这大大减少了网络操作的复杂性，Cisco 规范化了数据中心中网络操作的方式。网络管理员将登录到设备，运行一系列行业标准的命令行来修改路由器或交换机，Cisco
    还开设了认证项目，教授管理员如何操作设备并学习所有命令。
- en: Today with efficiency and cost reductions key to businesses surviving and a
    shift towards more agile processes, this model in the modern data centers has
    an obvious scaling issue with *x* amount of network engineers required per network
    device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在效率和成本削减对于企业生存至关重要且业务流程向更加灵活的方式转变的背景下，这种现代数据中心模型在网络工程师与网络设备的比例上存在明显的扩展问题，*每个网络设备所需的网络工程师数量*。
- en: The emergence of private clouds has meant that the number of network devices
    each network engineer needs to manage has grown dramatically, so automation has
    become key to managing the growing amount of devices in a consistent way. If a
    businesses competitors can put products to market quicker if they have automated
    operational models, then they will be able to put products to market quicker than
    organizations that are doing manual changes. Automation has become a necessity
    to keep up with the rapid churn of change required on the network. As IT is changing
    and evolving, then automation has become a prerequisite to facilitate that evolution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 私有云的出现意味着每个网络工程师需要管理的网络设备数量急剧增加，因此自动化成为了以一致的方式管理大量设备的关键。如果一个企业的竞争对手通过自动化的运营模型能够更快地将产品推向市场，那么他们将能比进行手动更改的组织更快地推出产品。自动化已成为跟上网络快速变化所必需的条件。随着
    IT 的变化和发展，自动化已成为促进这一演变的前提。
- en: Cisco, as the networking market has evolved in recent years, has since developed
    a new operating system named **Nxos**, which has allowed itself to integrate with
    open source technologies and lend itself to automation. The Nxos operating system
    is deployed with all new Nexus switches and routers, and this operating system
    has shifted Cisco towards open and modular standards by integrating with open
    protocols, such as **BGP**, **EVNP**, and **VXLAN**, and the appliances can even
    run **LXC** containers, which is an operating system-level virtualization method
    in order to run multiple isolated processes on a virtual machine or physical server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着近年来网络市场的演变，Cisco 开发了一个新的操作系统 **Nxos**，使其能够与开源技术集成并支持自动化。Nxos 操作系统已部署在所有新的
    Nexus 交换机和路由器上，这一操作系统通过集成开源协议（如 **BGP**、**EVNP** 和 **VXLAN**）将 Cisco 推向开放和模块化的标准，且这些设备甚至可以运行
    **LXC** 容器，这是一种操作系统级虚拟化方法，用于在虚拟机或物理服务器上运行多个隔离的进程。
- en: Cisco have also provided a set of REST APIs that allows network operators to
    run native Linux and bash shells to carry out regular administration commands
    server side. In a world where AWS and OpenStack programmatic APIs are available
    to mutate network infrastructure, networking vendors needed to adapt to survive
    or they risked being left behind, so Cisco have made their own switches and routers
    as easy to configure and operate as the virtual appliances.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco 还提供了一套 REST API，允许网络运营商运行原生 Linux 和 bash shell 来执行常规的服务器端管理命令。在 AWS 和
    OpenStack 提供的编程 API 可以用来变更网络基础设施的时代，网络供应商需要适应才能生存，否则就可能被淘汰。因此，Cisco 将其交换机和路由器的配置和操作简化到与虚拟设备一样容易。
- en: The Nxos operating system allows the use of the Red Hat enterprise Linux rpm
    package manager to control software updates. This means that software updates
    can be done on the Nxos in an industry standard way, the same as patching a Linux
    guest operating system would be carried out by an infrastructure system administrator.
    Consequently, Cisco network devices are now more intuitive to Linux system administrators
    and more like native Linux to end users, which has undoubtedly made them simpler
    to administrate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Nxos 操作系统允许使用 Red Hat 企业版 Linux rpm 包管理器来控制软件更新。这意味着，软件更新可以以行业标准的方式在 Nxos 上进行，就像通过基础设施系统管理员对
    Linux 客户操作系统进行打补丁一样。因此，Cisco 网络设备现在对 Linux 系统管理员来说更加直观，并且对最终用户来说更像原生 Linux，这无疑使得它们的管理变得更简单。
- en: The Cisco Nxos operating system means that the speed that network changes can
    be pushed increases, as operations staff can use their own tool chains and configuration
    management tools to automate updates. The Nxos operating system has become less
    vendor specific; therefore, lowering the barrier to entry to use networking products
    and automation of its product suites have become easier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco Nxos 操作系统意味着网络变更的推送速度得以提升，因为运营人员可以使用他们自己的工具链和配置管理工具来自动化更新。Nxos 操作系统已经变得不那么依赖厂商，因此，使用网络产品和自动化其产品套件的门槛变得更低。
- en: Juniper Junos operating system
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Juniper Junos 操作系统
- en: The Juniper Junos operating systems driver is programmatically controlled to
    control network operations, Junipers Junos operating system was created to provide
    CLI that users can execute to retrieve facts about the running system. The Junos
    operating system is based on a clearly defined hierarchical model as opposed to
    using a series of unrelated configuration files. The hierarchical model also comes
    complete with operational and configuration modes of operation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper Junos 操作系统驱动程序通过程序化控制来控制网络操作，Junos 操作系统的设计旨在提供 CLI，用户可以通过它执行以检索运行系统的相关信息。Junos
    操作系统基于一个明确的层次模型，而不是使用一系列不相关的配置文件。层次模型还完整支持操作模式和配置模式。
- en: Intuitively, operational mode is used to upgrade the operating system, monitor
    the system, and also check the status of juniper devices. Configuration mode,
    on the other hand, allows network operators to configure user access and security,
    interfaces, hardware, and the set of protocols used on the device, which gives
    a clear separation of roles between those installing the system and those operating
    it. The Junos operating system supports all open protocols, such as BGP, VXLAN,
    and EVPN, as well as in-built roll forward and roll back capability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，操作模式用于升级操作系统、监控系统以及检查 Juniper 设备的状态。而配置模式则允许网络管理员配置用户访问和安全性、接口、硬件以及设备上使用的协议集，这为安装系统的人员和操作系统的人员之间提供了清晰的角色分离。Junos
    操作系统支持所有开放协议，如 BGP、VXLAN 和 EVPN，并且具备内建的前滚和回滚功能。
- en: Juniper provide a Python library named **PyEZ** for the Junos operating system
    as well as a PowerShell option for Windows administrators that utilizes PowerShell
    wrapped in Python. The Python library PyEZ can retrieve any configuration information
    using tables and views that allow network operators to script against runtime
    information provided by the Junos operating system. Once a table items have been
    extracted by utilizing a python script using a `get()` method, tables can subsequently
    be treated as a Python dictionary and iterated, which allows users to carry out
    complex scripting if required, allowing network operators to automate all network
    operations. The Junos PYEZ library is also fully extensible and network operators
    can add functionality they deem appropriate using its widget system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper 提供了一款名为**PyEZ**的 Python 库，适用于 Junos 操作系统，并为 Windows 管理员提供了一个 PowerShell
    选项，该选项利用了 Python 中封装的 PowerShell。Python 库 PyEZ 可以通过使用表格和视图来检索任何配置信息，这些表格和视图允许网络管理员根据
    Junos 操作系统提供的运行时信息进行脚本编写。一旦通过利用 `get()` 方法的 Python 脚本提取了表格项，表格可以随后被视为 Python 字典并进行迭代，这使得用户可以在需要时执行复杂的脚本，从而允许网络管理员自动化所有网络操作。Junos
    PYEZ 库也完全可扩展，网络管理员可以使用其小部件系统添加他们认为合适的功能。
- en: Arista EOS operating system
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统
- en: The Arista EOS operating system is based on open standards to promote automation
    of network functions. It relies upon a centralized **CloudVision eXchange** (**CVX**)
    and the CVX servers hold the centralized state of the network. The EOS operating
    system separates the functional control on every switch using **Sysdb**, which
    is the Arista EOS operating systems database. The Arista Sysdb is an in-memory
    database running in user space and contains the complete state of the Arista switch.
    Sysdb is maintained in memory on the device so if an Arista switch is either restarted
    or powered down all information for that switch is lost.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统基于开放标准，旨在促进网络功能的自动化。它依赖于集中式的**CloudVision eXchange**（**CVX**），CVX
    服务器保存网络的集中状态。EOS 操作系统通过 **Sysdb** 来分离每个交换机上的功能控制，Sysdb 是 Arista EOS 操作系统的数据库。Arista
    Sysdb 是一个运行在用户空间的内存数据库，包含 Arista 交换机的完整状态。Sysdb 存储在设备内存中，因此如果 Arista 交换机重新启动或断电，所有与该交换机相关的信息将丢失。
- en: The CVX server acts as an aggregator managing all the state information from
    every switch's Sysdb into a network-wide database depending on what services are
    enabled on the cluster of CVX servers. When state changes occur to Sysdb on a
    switch then the change is pushed to the CVX centralized database, which then updates
    its configuration and notifies agents running on CVX of the change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CVX 服务器作为聚合器，管理从每个交换机的 Sysdb 中收集的所有状态信息，并根据 CVX 服务器集群启用的服务，将信息汇总到网络范围的数据库中。当交换机的
    Sysdb 中发生状态变化时，变化会推送到 CVX 集中数据库，随后更新其配置并通知 CVX 上运行的代理程序。
- en: The Arista EOS operating system supports modern open protocols, such as MLAG,
    ECMP, BGP, and VXLAN. It utilizes overlay technologies such as VXLAN allowing
    applications to be deployed and remain portable in the modern data center. Arista
    heavily promotes the use of the Leaf-Spine architecture with ECMP, which allows
    a scale out model to be implemented; this aligns itself to modern cloud solutions
    such as OpenStack and makes it agnostic to SDN controller solutions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统支持现代开放协议，如 MLAG、ECMP、BGP 和 VXLAN。它利用 VXLAN 等覆盖技术，使得应用能够在现代数据中心中部署并保持可移植性。Arista
    大力推广在 ECMP 下使用 Leaf-Spine 架构，允许实现扩展模型；这一架构与现代云解决方案如 OpenStack 一致，并使其与 SDN 控制器解决方案保持独立。
- en: The Arista EOS operating system is a Linux-based operating system designed to
    be programmatically controlled. The main driver for the EOS operating system is
    to allow network operators to carry out network operations' using a well structured
    set of APIs including the eAPI, CLI command as well as Python, Ruby, and GO libraries
    available as part of its SDK portfolio.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统是一个基于 Linux 的操作系统，旨在被程序化控制。EOS 操作系统的主要驱动力是允许网络操作员使用一套结构化的 API，包括
    eAPI、CLI 命令以及作为其 SDK 产品组合的一部分的 Python、Ruby 和 GO 库，来执行网络操作。
- en: The EOS operating system also allows **Smart System Upgrade** (**SSU**) to allow
    scale out of Arista appliances with live patching and upgrades simplified and
    made more intuitive, this helps to support businesses 99.99% uptime targets. Switches
    can now be racked and cabled in the data center by data center operations teams,
    then handed over to Arista's **Zero Touch Provisioning** (**ZTP**) process that
    automates the initialization of switches and **Zero Touch Replacement** (**ZTR**)
    allows switches to be replaced in the data center.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: EOS 操作系统还支持**智能系统升级**（**SSU**），通过实时修补和升级的简化及更直观的方式，支持 Arista 设备的扩展，这有助于支持企业的
    99.99% 在线时间目标。交换机现在可以由数据中心运营团队在数据中心安装并接线，然后交给 Arista 的**零接触配置**（**ZTP**）过程，自动化交换机初始化，**零接触替换**（**ZTR**）允许交换机在数据中心中进行更换。
- en: The Arista EOS solution CVX product can be used to automate networking workflow
    tasks through the portal if users require a visual view of switches and routers
    and the CVX allows integration with SDN controllers using OVSDB, eAPI, or OpenFlow.
    Like Cisco and Juniper, the EOS API lends due to it having multiple SDK options
    so Arista products can be easily managed by configuration management tools, such
    as Puppet, Chef, Ansible, and Salt, so that no network operation needs to be carried
    out manually.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 解决方案 CVX 产品可以通过门户自动化网络工作流任务，如果用户需要交换机和路由器的可视化视图，CVX 允许通过 OVSDB、eAPI
    或 OpenFlow 与 SDN 控制器集成。像 Cisco 和 Juniper 一样，EOS API 由于提供了多种 SDK 选项，因此 Arista 产品可以通过配置管理工具（如
    Puppet、Chef、Ansible 和 Salt）轻松管理，从而避免手动进行任何网络操作。
- en: Introduction to Ansible
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 简介
- en: Ansible is primarily a push-based configuration management tool that uses a
    single **Ansible Control Host**, and it can connect to multiple Linux guest operating
    systems via SSH to configure them and recently added WinRM support, so it can
    now also configure Windows guests in the same way as Linux-based operating systems.
    As Ansible can connect to multiple servers simultaneously, it aids operators by
    allowing them to carry out uniform operations across multiple Linux or Windows
    servers at the same time. This allows Ansible to help simplify the automation
    of repeatable tasks by defining them in YAML, so they can be consistently executed
    against target servers. Ansible can also be used as a centralized orchestration
    tool that can connect to API endpoints and sequence API operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 主要是一个基于推送的配置管理工具，它使用一个 **Ansible 控制主机**，并且可以通过 SSH 连接到多个 Linux 客户操作系统以对其进行配置，最近还新增了
    WinRM 支持，因此它现在也可以像配置 Linux 系统一样配置 Windows 客户机。由于 Ansible 可以同时连接到多个服务器，它帮助操作员通过允许他们在多个
    Linux 或 Windows 服务器上同时执行统一的操作，从而简化了自动化重复任务的过程。Ansible 还可以作为一个集中式编排工具，连接到 API 端点并对
    API 操作进行排序。
- en: 'Here, we can see an example of the way an Ansible Control Host connects to
    servers or acts as a centralized orchestration tool:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 Ansible 控制主机如何连接到服务器或充当集中式编排工具的示例：
- en: '![Introduction to Ansible](img/5559_04_28.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible 介绍](img/5559_04_28.jpg)'
- en: Every operation that Ansible carries out should be idempotent as a standard,
    meaning that if the desired state is already configured on a server, then Ansible
    will check the intended state from a playbook or role and not take any action
    if a server is already in the correct state. Only if the state is different from
    what is specified in a playbook or role will the operation be executed to mutate
    the state of the server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 执行的每个操作都应该是幂等的，这意味着如果服务器上已经配置了期望的状态，Ansible 将检查来自 playbook 或角色的目标状态，如果服务器已处于正确状态，则不会采取任何操作。只有在状态与
    playbook 或角色中指定的状态不同的情况下，操作才会被执行，从而改变服务器的状态。
- en: Ansible is a Python-based configuration management tool that controls servers
    from a Linux-based Control Host, using YAML files to define and describe desired
    state. Ansible is packaged with a rich set of extensible modules, which are primarily
    written in Python, but can also be written in any language that a user wishes.
    Ansible modules allow Python SDKs or REST API's to be wrapped in Ansible's plug-in
    boilerplate and then utilized from Ansible roles or playbooks in an easy-to-use
    architecture. Before going into more detailed examples, it is important to understand
    some of the Ansible terminology.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个基于 Python 的配置管理工具，它通过一个基于 Linux 的控制主机控制服务器，使用 YAML 文件来定义和描述期望的状态。Ansible
    配备了一组丰富的可扩展模块，这些模块主要是用 Python 编写的，但也可以用任何用户希望的语言编写。Ansible 模块允许 Python SDK 或 REST
    API 被封装在 Ansible 的插件框架中，然后可以通过 Ansible 角色或 playbook 在易于使用的架构中进行调用。在深入了解更详细的示例之前，了解一些
    Ansible 的术语是非常重要的。
- en: Ansible directory structure
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 目录结构
- en: Ansible is made up of a series of YAML files that are laid out in a customizable
    directory structure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 由一系列 YAML 文件组成，这些文件布局在一个可自定义的目录结构中。
- en: 'In this customized structure, the Ansible Controller Node has the following
    directory structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个自定义结构中，Ansible 控制节点具有以下目录结构：
- en: The `inventories` folder holds the Ansible inventory
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inventories` 文件夹包含 Ansible 库存'
- en: The `library` folder holds any custom python plugins
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`library` 文件夹包含任何自定义的 Python 插件'
- en: The `playbooks` folder holds all playbooks
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbooks` 文件夹包含所有的 playbook'
- en: The `roles` folder holds all the Ansible roles
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles` 文件夹包含所有的 Ansible 角色'
- en: 'The overall directory structure is shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目录结构如下所示：
- en: '![Ansible directory structure](img/5559_04_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible 目录结构](img/5559_04_02.jpg)'
- en: This provides logical groupings of all Ansible components, which will be useful
    as the amount of playbooks or roles grow in size. It is best practice to version
    the `ansible` folder structure in a source control management system such as **Git**.
    Git is a distributed open source version control repository, which is designed
    to version control development code to facilitate speed and efficiency ([https://en.wikipedia.org/wiki/Git).](https://en.wikipedia.org/wiki/Git).)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了所有 Ansible 组件的逻辑分组，随着 playbook 或角色的增多，这将非常有用。最好将 `ansible` 文件夹结构在源代码管理系统中进行版本控制，如
    **Git**。Git 是一个分布式的开源版本控制仓库，旨在对开发代码进行版本控制，以提高速度和效率（[https://en.wikipedia.org/wiki/Git）。](https://en.wikipedia.org/wiki/Git)。)
- en: Ansible inventory
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 库存
- en: An Ansible inventory file is simply a set of DNS hostnames or IP addresses defined
    in a YAML file. This allows Ansible to connect to those target hosts and execute
    specific commands on servers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 库存文件实际上是一个在 YAML 文件中定义的 DNS 主机名或 IP 地址的集合。这允许 Ansible 连接到这些目标主机，并在服务器上执行特定命令。
- en: Ansible allows users to use inventory files to group servers into particular
    types or use cases. For example, in networking terms, when utilizing Ansible to
    set up a Leaf-Spine architecture, a network operator could have a group for Leaf
    switches and another for the Spine switches. This is because a different set of
    run-book commands would be required to configure each, so limits can be applied
    upon execution to only execute a command against a small subset of servers limited
    to one particular group.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 允许用户使用库存文件将服务器分组为特定类型或用例。例如，在网络术语中，当使用 Ansible 设置 Leaf-Spine 架构时，网络操作员可以为
    Leaf 交换机创建一个组，为 Spine 交换机创建另一个组。这是因为配置每种交换机所需的运行手册命令不同，因此可以在执行时施加限制，只对特定组中的一小部分服务器执行命令。
- en: 'An example of an inventory file defining Leaf and Spine switches can be found
    in the following image, showing the definition of two groups in the inventory
    file, one for Leaf switches named `leaf` and one for Spine switches named `spine`
    containing all the DNS entries for the switches:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了定义 Leaf 和 Spine 交换机的库存文件示例，显示了在库存文件中定义的两个组，一个是为 Leaf 交换机命名的`leaf`，另一个是为
    Spine 交换机命名的`spine`，包含所有交换机的 DNS 条目：
- en: '![Ansible inventory](img/5559_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible 库存](img/5559_04_03.jpg)'
- en: 'The same inventory can be described in an abbreviated format:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的库存可以用简化的格式描述：
- en: '![Ansible inventory](img/5559_04_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible 库存](img/5559_04_04.jpg)'
- en: Ansible modules
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 模块
- en: An Ansible module is typically written in Python or can be written in any other
    programming language. An Ansible module's code defines a set of operations to
    add or remove functionality from a guest operating system or alternately execute
    a command against an API if it is being used for orchestration. Ansible modules
    can be used to wrap either a simple command line, API call or any other operation
    a user desires that can be coded programmatically. Modules are set up, so they
    can be reused in multiple playbooks or roles in order to promote reusing code
    and the standardization of operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 模块通常是用 Python 编写的，或者也可以用其他编程语言编写。Ansible 模块的代码定义了一组操作，用于向客户操作系统添加或删除功能，或者如果用于编排，它也可以针对
    API 执行命令。Ansible 模块可用于封装简单的命令行、API 调用或用户希望程序化编写的任何其他操作。模块是以可复用的方式设置的，以便在多个剧本或角色中使用，从而促进代码重用和操作标准化。
- en: Code specified in an Ansible module is wrapped in Ansible's module boilerplate,
    which structures the layout of the module. The boilerplate promotes a set of standards,
    so each module is idempotent by design, meaning that the code will first detect
    the state of the system and then determine if a change in state is required or
    not before executing the operation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 模块中指定的代码被封装在 Ansible 的模块模板中，模块模板结构化了模块的布局。该模板推动了一组标准，因此每个模块在设计上都是幂等的，这意味着代码会首先检测系统的状态，然后判断是否需要在执行操作之前更改状态。
- en: When a state change is executed in Ansible, it is donated by a yellow output
    on the console. If no action is taken, it will display the color green to state
    that the operation ran successfully, but no state change was made, whereas a red
    console output indicates a failure on the module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ansible 执行状态更改时，控制台会以黄色输出标明。如果没有进行任何操作，它将显示绿色，表示操作成功运行，但没有更改状态，而红色的控制台输出则表示模块失败。
- en: Ansible modules expose a set of command-line arguments for the module that can
    either be mandatory or optional and can have default values. Modules that adhere
    to the Ansible standard are created with a state variable that contains `present`
    or `absent`, as one of the command-line variables. A module, when set to `present`,
    will add the feature that has been specified by the playbook and when it is set
    to `absent`, it will remove the specified feature. All modules will typically
    have code to deal with both of these use cases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 模块公开了一组命令行参数，这些参数可以是必需的也可以是可选的，并且可以有默认值。遵循 Ansible 标准的模块是通过一个包含 `present`
    或 `absent` 的状态变量创建的，作为命令行变量之一。当模块设置为`present`时，它将添加由剧本指定的功能；而当设置为`absent`时，它将移除指定的功能。所有模块通常都具有处理这两种用例的代码。
- en: Once an Ansible module has been written, it is placed in the `library` folder,
    which means that it is available as a library to the Python interpreter and the
    code can then be utilized by defining it in an Ansible `playbooks` or `roles`.
    Ansible comes with a set of prepackaged core and extras modules that can all be
    accessed by writing some YAML to describe the operation that is required, all
    modules are packaged with documentation that are part of the boilerplate and available
    on the Ansible website.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了Ansible模块，它就会被放置在`library`文件夹中，这意味着它作为库对Python解释器可用，代码可以通过在Ansible的`playbooks`或`roles`中定义来使用。Ansible提供了一组预打包的核心模块和附加模块，所有这些模块都可以通过编写一些YAML来描述所需的操作进行访问，所有模块都附带有文档，文档是模块的样板部分，并且可以在Ansible官网上找到。
- en: Core modules are maintained by the Ansible core team in joint initiatives with
    software vendors and are generally of high quality. Extras modules can also be
    of a good quality but are not maintained by vendors and sometimes maintained by
    users that have committed back the modules to Ansible to help out the open source
    community.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块由Ansible核心团队与软件供应商的联合项目维护，通常具有较高的质量。附加模块也可以具有良好的质量，但不是由供应商维护的，有时是由用户维护的，这些用户将模块提交回Ansible，以帮助开源社区。
- en: 'A simple core `yum` module donated by `yum:` can be seen in the following screenshot
    that takes two command-line variables `name` which is used to specify the rpm
    to install and `state`, which determines whether to install or remove it from
    the target server:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，可以看到一个简单的核心`yum`模块，由`yum:`提供，它带有两个命令行变量`name`，用于指定要安装的rpm，以及`state`，它决定是否在目标服务器上安装或移除该rpm：
- en: '![Ansible modules](img/5559_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible模块](img/5559_04_05.jpg)'
- en: Ansible roles
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible角色
- en: Roles are a further level of abstraction in Ansible and also defined using YAML
    files. Roles can be called from playbooks; this aims to simplify playbooks as
    much as possible. As increased sets of functionality are added to `playbooks`,
    they can become cluttered and difficult to maintain from a single file. So roles
    allow operators to create minimal playbooks that then pull all the information
    from the Ansible directory structure, which then determines the configuration
    steps that need to execute on servers or be run locally.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是Ansible中的进一步抽象层，也使用YAML文件定义。角色可以从剧本中调用；这旨在尽可能简化剧本。随着`playbooks`功能集的增加，它们可能变得杂乱且难以维护。如果将所有功能都放在一个文件中，剧本可能会变得很难管理。所以角色允许操作员创建最小化的剧本，然后从Ansible目录结构中拉取所有信息，从而决定需要在服务器上执行的配置步骤或本地运行的操作。
- en: Ansible roles attempt to strip out repeatable parts of playbooks and group them,
    so they can be used by multiple playbooks if required. Roles are groupings to
    determine what the server profile should actually be, rather than just focusing
    on multiple ad hoc instructions, so a playbook could be named `spine.yml` and
    the playbook could contain a set of modular roles used to define the particular
    Spine switches run-list, when executed this playbook will build the Spine switch
    on each target server specified in the Ansible inventory. If designed correctly
    some of these roles should be modular enough that they can be reused when creating
    Leaf switches.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色试图剥离剧本中的可重复部分并将其分组，以便在需要时可以由多个剧本使用。角色是为了确定服务器配置文件应该是什么，而不仅仅是专注于多个临时指令，因此剧本可以命名为`spine.yml`，并且该剧本可以包含一组模块化的角色，用于定义特定Spine交换机的运行列表，执行此剧本时，它将在Ansible清单中指定的每个目标服务器上构建Spine交换机。如果设计得当，这些角色应该具有足够的模块化，以便在创建Leaf交换机时重复使用。
- en: Ansible playbooks
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible剧本
- en: An Ansible playbook is a YAML file that dictates the run-list to carry out on
    a particular set of host servers that are defined in an inventory file. A playbook
    specifies an ordered set of instructions to execute commands locally from Ansible
    Controller Node or on a target set of hosts specified in the Ansible inventory
    file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible剧本是一个YAML文件，用来指示在Ansible清单文件中定义的特定主机集上执行的运行列表。剧本指定了一组有序的指令，从Ansible控制节点或在Ansible清单文件中指定的目标主机上本地执行命令。
- en: An Ansible playbook can be used to create a run-list that calls out to modules
    or specific roles, which dictate the operations that should be executed against
    a server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible剧本可以用来创建一个运行列表，调用模块或特定的角色，指示应该在服务器上执行的操作。
- en: 'In this example, we see a playbook targeting the `spine` hosts in the inventory
    file and executing multiple `roles` to set up the Spine servers:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到一个针对清单文件中`spine`主机的剧本，并执行多个`roles`来设置Spine服务器：
- en: '![Ansible playbooks](img/5559_04_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible playbooks](img/5559_04_06.jpg)'
- en: 'An alternate playbook could not use roles at all and call Ansible yum core
    module directly to install the apache `httpd-2.2.29` yum package on the inventory
    group named `server`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可行的剧本可能完全不使用角色，直接调用 Ansible 的 yum 核心模块，在名为 `server` 的清单组上安装 apache 的 `httpd-2.2.29`
    yum 包：
- en: '![Ansible playbooks](img/5559_04_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible playbooks](img/5559_04_07.jpg)'
- en: Playbooks can also specify `when` conditions to dictate if an action in the
    playbook should be executed or not based on the output of a proceeding operation.
    The `register` command is used to store JSON output from a task that can then
    be utilized in playbooks or roles by subsequent tasks to validate if they should
    be invoked by reading the result of the JSON and evaluating the when condition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 剧本还可以指定 `when` 条件，以决定是否根据前一个操作的输出执行剧本中的某个操作。`register` 命令用于存储任务的 JSON 输出，后续任务可以通过读取
    JSON 结果并评估 when 条件来验证是否应当执行该任务。
- en: Ansible playbooks from version 2.x onwards can now utilize block rescue functionality
    too. So if an operation nested in a block command fails, then the rescue section
    of the playbook is invoked. This can be useful for doing cleanup of failed actions
    to make playbooks more robust.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.x 版本开始，Ansible 剧本现在也可以使用块式恢复功能。因此，如果嵌套在块命令中的操作失败，则会触发剧本中的恢复部分。这对于清理失败的操作非常有用，使剧本更加健壮。
- en: The usefulness of a block rescue operation shouldn't be underestimated, when
    requiring to copy a large database `dmp` file to a backup location this operation
    could sometimes be error-prone due to the volume of data being copied. So if the
    disk space is too low on the target directory, then that operation could fail
    half way through leaving only part of the file copied and the server in an unusable
    state and the server could run out of disk space. Therefore, a rescue command
    could be used to clean up the copied file immediately, so the server isn't left
    in a bad state if the copy operation fails. After the rescue command has completed,
    the playbook will exit with an error but remain in its original state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不应低估块式恢复操作的有用性，当需要将一个大数据库 `dmp` 文件复制到备份位置时，由于复制的数据量大，这个操作有时可能容易出错。所以，如果目标目录的磁盘空间太低，那么操作可能在中途失败，导致只有部分文件被复制，且服务器处于不可用状态，服务器也可能耗尽磁盘空间。因此，可以使用恢复命令立即清理复制的文件，这样在复制操作失败时，服务器就不会处于不良状态。恢复命令执行完成后，剧本将退出并报告错误，但保持在原始状态。
- en: 'In the following example, we can see a playbook using the copy: module to copy
    the source file `/var/files/db.dmp` to `/backups/db.dmp` and the file: module
    being used to delete the file if the original command fails:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '在以下示例中，我们可以看到一个剧本使用 copy: 模块将源文件 `/var/files/db.dmp` 复制到 `/backups/db.dmp`，如果原始命令失败，file:
    模块将用于删除该文件：'
- en: '![Ansible playbooks](img/5559_04_08.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible playbooks](img/5559_04_08.jpg)'
- en: Executing an Ansible playbook
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 Ansible 剧本
- en: After playbook and inventory files have been created utilizing the specified
    folder structure, it can now be executed by specifying the `ansible-playbook`
    command.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了剧本和清单文件，并使用了指定的文件夹结构后，可以通过指定 `ansible-playbook` 命令来执行它。
- en: 'In the following example, the:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中：
- en: '`ansible-playbook` tells Ansible that a YAML playbook file should be specified'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-playbook` 告诉 Ansible 应该指定一个 YAML 剧本文件'
- en: '`-i` flag is used to specify the inventory file'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i` 标志用于指定清单文件'
- en: '`-l` limits the execution only to the servers under the inventory group (servers)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l` 限制执行仅限于清单组（servers）下的服务器'
- en: '`-e` passes additional variables to the playbook in this example production'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e` 在此示例中传递额外的变量到剧本，例如 production'
- en: '`-v` sets the verbosity of the output:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 设置输出的详细程度：'
- en: '[PRE0]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ansible var files and jinja2 templates
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible var 文件和 jinja2 模板
- en: Ansible `var` files are just another YAML file that specify a set of variables
    that will be substituted into a playbook at runtime using the Ansible `include_vars`
    statement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的 `var` 文件只是另一种 YAML 文件，指定了一组变量，这些变量将在运行时通过 Ansible 的 `include_vars`
    语句被替换到剧本中。
- en: The `var` files are just a way of breaking out variables that are required by
    playbooks or roles at runtime. This means that different `var` files can be passed
    at runtime without having to hardcode variables into playbooks or roles.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 文件只是一种方式，用于分离剧本或角色在运行时所需的变量。这意味着可以在运行时传递不同的 `var` 文件，而无需将变量硬编码到剧本或角色中。'
- en: 'An example of a `var` file syntax is shown in the following screenshot, this
    shows the contents of a `common.yml` `var` file containing one defined variable
    named `cert_name`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了一个 `var` 文件语法示例，内容为包含一个名为 `cert_name` 的定义变量的 `common.yml` `var` 文件：
- en: '![Ansible var files and jinja2 templates](img/5559_04_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible var 文件和 jinja2 模板](img/5559_04_09.jpg)'
- en: 'The following example shows the `common.yml` variable above and other `environment.yml`
    variables , both being loaded into the playbook. The `{{ environment }}` is useful
    as it means that different values could be passed from the `ansible-playbook`
    command line to control the variables that are imported into the playbook using
    the `-e “environment=production”` option at runtime:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了上面提到的 `common.yml` 变量和其他 `environment.yml` 变量，二者都被加载到 playbook 中。`{{
    environment }}` 变量非常有用，因为它意味着可以从 `ansible-playbook` 命令行传递不同的值，通过在运行时使用 `-e “environment=production”`
    选项来控制导入到 playbook 中的变量：
- en: '![Ansible var files and jinja2 templates](img/5559_04_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible var 文件和 jinja2 模板](img/5559_04_10.jpg)'
- en: 'The `common.yml` `var` files variables value cert1 can then be used by specifying
    `{{ cert_name }}` variable in the playbook:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`common.yml` 中的 `var` 文件变量值 cert1 可以通过在 playbook 中指定 `{{ cert_name }}` 变量来使用：'
- en: '![Ansible var files and jinja2 templates](img/5559_04_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible var 文件和 jinja2 模板](img/5559_04_11.jpg)'
- en: Ansible also has the ability to utilize Python jinja2 templates that can be
    transformed at runtime, to populate the configuration files information utilizing
    a set of `var` files; for example, the `{{ environment }}` variable in the preceding
    example can be specified at runtime to load variables that populate unique environment
    information. The jinja2 template once transformed using the template module will
    be parameterized to use the variables specified in the `environment.yml` file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 还具有利用 Python jinja2 模板的能力，这些模板可以在运行时进行转换，以使用一组 `var` 文件填充配置信息；例如，在前面的示例中，`{{
    environment }}` 变量可以在运行时指定，以加载填充唯一环境信息的变量。使用模板模块转换后的 jinja2 模板将被参数化，使用在 `environment.yml`
    文件中指定的变量。
- en: 'In the following example, we can see the Ansible `template:` module being executed
    as part of a role copying a jinja2 template `network_template.j2` and transforming
    it to `/etc/network.conf`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到 Ansible 的 `template:` 模块作为角色的一部分被执行，复制一个 jinja2 模板 `network_template.j2`
    并将其转换为 `/etc/network.conf`：
- en: '![Ansible var files and jinja2 templates](img/5559_04_12.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible var 文件和 jinja2 模板](img/5559_04_12.jpg)'
- en: Prerequisites using Ansible to configure network devices
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 配置网络设备的前提条件
- en: The base constructs covered in the *Introduction to Ansible* section in this
    chapter are all relevant to the Ansible networking modules, and to a networking
    team wishing to utilize Ansible for configuration management. Before starting,
    it is important to check with the networking vendors that the version of the networking
    operating system can be used with Ansible. The next step is to configure a small
    provisioning server to utilize as the Ansible Control Host, this is typically
    created on the management network so it has access appropriate to all switches.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中 *Ansible 入门* 部分介绍的基本构建块与 Ansible 网络模块密切相关，并且适用于希望使用 Ansible 进行配置管理的网络团队。在开始之前，重要的是与网络供应商确认所使用的网络操作系统版本是否能够与
    Ansible 一起使用。下一步是配置一个小型的预配服务器，将其用作 Ansible 控制主机，通常该服务器会创建在管理网络上，以便它能够适当地访问所有交换机。
- en: The provisioning server can be relatively small in size as it will just be required
    to connect over SSH to the Linux-based networking operating systems. Ensure that
    the API command line is enabled on the network device. It is also a good idea
    to create a temporary user account on each of the networking devices, which will
    allow you to set up a public key on the Ansible Control Host and **Secure Copy**
    (**SCP**) the created `id_rsa.pub` to the `authorized_keys` folder on the network
    devices using the temporary account. This will allow Ansible to use that private
    key to connect to all of the hosts without the need for dealing with passwords.
    The temporary password can then be deleted from each of the network devices once
    this setup activity has been completed, you could even use Ansible to do this
    as a first activity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: All being well, the next step would be to create the Ansible folder structure
    on the provisioning server and fill out the Ansible inventory file with all the
    DNS names of all the network devices and finally install Ansible when you are
    ready to start executing playbooks. Ansible is now packaged by Red Hat in rpm
    format, so this should just be a simple yum install as long as the Ansible Control
    Host has outbound Internet access to the Red Hat repositories when using a centos
    image or Red Hat Enterprise Linux. Ansible will of course work on any Linux-based
    operating system as is still available as a PyPi package that can be installed
    on Ubuntu.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a network operator is looking for a start point and not well-versed in coding,
    they could look for examples on Ansible Galaxy, which hosts open source community
    roles that carry out many complex commands.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer can navigate to the Ansible Galaxy repository at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Ansible Galaxy houses thousands of Ansible roles that have been developed by
    the Open Source community.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Some available examples of networking roles are the Arista EOS role that can
    be used to automate Arista switch devices. Alternately, the Cisco EVPN VXLAN Spine
    role can be used to build Spine switches on Cisco devices or the Juniper Junos
    role can be used to automate Juniper network devices. So there is a wide variety
    of modules for a variety of technologies and use cases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following useful links:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Arista EOS ([https://galaxy.ansible.com/arista/eos-system/](https://galaxy.ansible.com/arista/eos-system/))
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco ([https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/](https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/))
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper ([https://galaxy.ansible.com/Juniper/junos/](https://galaxy.ansible.com/Juniper/junos/))
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Users can browse roles and search for a particular networking vendor. In this
    example, a search for Arista has returned the **eos** role, as shown in the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_14.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Each role returned has a link to their corresponding GitHub repository:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个返回的角色都有一个指向其对应 GitHub 仓库的链接：
- en: '![Ansible Galaxy](img/5559_04_15.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible Galaxy](img/5559_04_15.jpg)'
- en: Ansible Galaxy is a very useful tool, where users can take roles as a start
    point and customize them to meet their needs. Rather than just taking from the
    community, any new roles that may be of use to others should be contributed back
    to the Ansible community.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Galaxy 是一个非常有用的工具，用户可以以角色（roles）作为起点，并根据自己的需求进行自定义。而不仅仅是从社区获取，任何可能对其他人有用的新角色都应该回馈到
    Ansible 社区。
- en: Ansible core modules available for network operations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 核心模块可用于网络操作
- en: Since the release of Ansible 2.0, the Ansible configuration management tool
    been packaged with some of the core networking modules from Arista, Citrix, Cumulus,
    and Juniper. Ansible can be used to edit configuration for any network device.
    It isn't restricted to just these modules. Ansible Galaxy has a wide range of
    roles that have been developed by the open source community.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Ansible 2.0 发布以来，Ansible 配置管理工具已经打包了来自 Arista、Citrix、Cumulus 和 Juniper 的一些核心网络模块。Ansible
    可以用于编辑任何网络设备的配置，而不仅仅限于这些模块。Ansible Galaxy 拥有由开源社区开发的各种角色。
- en: 'A subnet of the Ansible 2.x networking modules can be shown in the following
    screenshot focusing upon the Juniper **Junos**, Arista **Eos**, Cisco **Nxos**,
    and **Ios**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 Ansible 2.x 网络模块的一个子集，重点展示了 **Junos**（Juniper）、**Eos**（Arista）、**Nxos**（Cisco）和
    **Ios**（Cisco）：
- en: '![Ansible core modules available for network operations](img/5559_04_16.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible 核心模块可用于网络操作](img/5559_04_16.jpg)'
- en: Ansible 2.x has sought to simplify networking modules by giving them a standard
    set of operations across all modules to make it feel more intuitive to network
    engineers. As many network engineers are not familiar with configuration management
    tooling, having a set of standards across modules simplifies the initial barrier
    to entry. As network engineers are able to see commands that they would utilize
    everyday being used as part of a playbook or a role, so Ansible can initially
    be utilized as a scheduling tool, before network operators delve into more complex
    modules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 2.x 旨在通过为所有模块提供一组标准化的操作，简化网络模块的使用，使网络工程师感觉更加直观。由于许多网络工程师不熟悉配置管理工具，模块间的标准化简化了初次使用的门槛。当网络工程师看到他们日常使用的命令作为
    playbook 或角色的一部分时，Ansible 可以首先作为调度工具使用，然后再深入使用更复杂的模块。
- en: One of the main fears network engineers have when first using configuration
    management tooling is not trusting the system or understanding what is going on
    under the covers. So, being able to easily read playbooks or roles and see the
    operations that are being executed builds confidence in the tooling and makes
    adoption easier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师在初次使用配置管理工具时的主要担忧之一是不信任系统或不了解其背后的运作方式。因此，能够轻松阅读 playbook 或角色，并查看正在执行的操作，有助于建立对工具的信心，并使其更容易被接受。
- en: It is fully expected that more complex networking modules will be built out
    over time by the open source community some of which are already available with
    roles from Arista, Juniper, and Cisco available in Ansible Galaxy. However, the
    following Ansible core modules have been standardized to allow configuration of
    Arista, Cisco, and Juniper network devices in the same way. These modules can
    be used in any playbook or role.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以预见，随着时间的推移，开源社区将构建出更复杂的网络模块，其中一些已经通过 Ansible Galaxy 中的角色提供，例如来自 Arista、Juniper
    和 Cisco 的角色。然而，以下 Ansible 核心模块已经标准化，允许以相同的方式配置 Arista、Cisco 和 Juniper 网络设备。这些模块可以在任何
    playbook 或角色中使用。
- en: The _command module
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: _command 模块
- en: The main module packaged with a vendor's networking modules in Ansible 2.x is
    the `_command` module. This is a conscious choice by Ansible as it is more intuitive
    to network engineers initially to use native network commands when switching to
    configuration management tooling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 2.x 中，主要与供应商的网络模块一起打包的模块是`_command`模块。这是 Ansible 的有意选择，因为网络工程师在初次使用配置管理工具时，使用原生网络命令更加直观。
- en: This module allows Ansible to connect to hosts using SSH as network device's
    operating systems are primarily Linux-based operating systems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块允许 Ansible 使用 SSH 连接到主机，因为网络设备的操作系统主要是基于 Linux 的操作系统。
- en: The `_command` module allows network operators to apply configuration changes
    to switches by connecting from the Ansible Control Host. The syntax used by Ansible
    on this command is identical to what network operators would execute on network
    devices using CLI.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`_command` 模块允许网络操作员通过从 Ansible 控制主机连接应用配置更改。Ansible 在此命令中使用的语法与网络操作员在网络设备上使用
    CLI 执行的语法相同。'
- en: In the following example, the EOS command `show ip bgp summary` is executed
    by the `eos_command`, and it connects to every specified `{{ inventory_hostname
    }}`, which is a special Ansible variable that substitutes the DNS name of every
    node listed in the host group specified in the inventory file. It then registers
    the output of the command in the `eos_command_output` variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，EOS 命令 `show ip bgp summary` 由 `eos_command` 执行，它连接到每个指定的 `{{ inventory_hostname
    }}`，这是一个特殊的 Ansible 变量，会替换为清单文件中指定的主机组中每个节点的 DNS 名称。然后，它将命令的输出注册到 `eos_command_output`
    变量中。
- en: '![The _command module](img/5559_04_17.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![The _command module](img/5559_04_17.jpg)'
- en: Junos syntax is identical. In the following example, a similar network command
    executed on Junos to show interfaces with the JSON output captures in the `junos_command_output`
    variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Junos 语法是相同的。在下面的示例中，执行了一个类似的网络命令，在 Junos 上显示接口，并将 JSON 输出捕获到 `junos_command_output`
    变量中。
- en: '![The _command module](img/5559_04_18.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![The _command module](img/5559_04_18.jpg)'
- en: 'The Cisco example shows Nxos, but the configuration is also the same in IOS.
    The `nxos_command` command issues a `show version` command and places the result
    in the `nxos_command_output` variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco 示例显示的是 Nxos，但配置在 IOS 中也是相同的。`nxos_command` 命令执行 `show version` 命令，并将结果放入
    `nxos_command_output` 变量中：
- en: '![The _command module](img/5559_04_19.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![The _command module](img/5559_04_19.jpg)'
- en: The _config module
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The _config module
- en: The `_config` module is used to configure updates in a deterministic way that
    could be used to implement change requests, by batching up a number of commands.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`_config` 模块用于以确定性方式配置更新，可用于实现变更请求，通过批量执行多个命令。'
- en: This module allows operators to update selected lines or blocks of running configuration
    programmatically on the network device. The module will connect to the device,
    extracting the running configuration before pushing batch updates in a completely
    deterministic way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块允许操作员以编程方式更新网络设备上的运行配置中的选定行或块。该模块将连接到设备，提取运行配置，然后以完全可预测的方式推送批量更新。
- en: In the following example, the Arista switches configuration will be loaded by
    the module. The `no spanning-tree vlan 4094` command will be executed on the EOS
    operating system if the running configuration doesn't match the existing state,
    so the desired end state will be implemented on the switch.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，Arista 交换机的配置将通过该模块加载。如果运行配置与现有状态不匹配，`no spanning-tree vlan 4094` 命令将在
    EOS 操作系统上执行，从而在交换机上实现所需的最终状态。
- en: '![The _config module](img/5559_04_20.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![The _config module](img/5559_04_20.jpg)'
- en: The _template module
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The _template module
- en: The `_template` module is used to update configuration utilizing a jinja2 template
    file. This can be extracted from the running configuration of a network device,
    updated and then pushed back to the device.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`_template` 模块用于利用 jinja2 模板文件更新配置。可以从网络设备的运行配置中提取该模板，进行更新，然后再推送回设备。'
- en: Another use case for the `_template` module would be allowing network administrators
    to extract the running config into a jinja2 template from one network device and
    apply it to other's switches to propagate the same changes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`_template` 模块的另一个使用场景是，允许网络管理员从一个网络设备中提取运行配置到 jinja2 模板，然后将其应用于其他交换机，以传播相同的更改。'
- en: The `_template` module will only push incremental changes unless the force command
    is specified as a command-line variable, which will carry out overwrite.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`_template` 模块只会推送增量更改，除非指定强制命令作为命令行变量，这将执行覆盖操作。'
- en: In the following example, the `eos_config` jinja2 template is pushed to the
    Arista device and will do an incremental change to the configuration if the jinja2
    template has configuration changes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`eos_config` jinja2 模板被推送到 Arista 设备上，并且如果 jinja2 模板中有配置变更，它会对配置进行增量更新。
- en: '![The _template module](img/5559_04_21.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![The _template module](img/5559_04_21.jpg)'
- en: Configuration management processes to manage network devices
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理流程，用于管理网络设备
- en: DevOps is primarily all about people and process, so just focusing on some examples
    of playbooks or roles in isolation against a switch or firewall wouldn't help
    network engineer deal with the real-world networking challenges that they encounter
    every day. Selecting the correct tooling to facilitate processes is also important
    after the actual goals of a project have been established. Tooling should be selected
    after the business requirements have been made clear and not the opposite way
    round.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 主要关注的是人和流程，因此，仅仅专注于一些单独的 playbook 或角色示例来操作交换机或防火墙，并不能帮助网络工程师解决他们每天遇到的现实网络挑战。在明确项目的实际目标后，选择正确的工具来促进流程也很重要。工具的选择应在业务需求明确之后，而不是反过来。
- en: A network engineer could easily type in those commands into a network operating
    system as they could type commands into an Ansible playbook, so it is important
    to look at where the use of a configuration management tool such as Ansible adds
    real business value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师可以像输入命令到 Ansible playbook 一样，轻松地将这些命令输入到网络操作系统中，因此，重要的是要考虑使用像 Ansible 这样的配置管理工具能为业务带来哪些真正的价值。
- en: Implementing a new tool in isolation doesn't really help the network teams improve
    efficiency as a standalone activity, but the modules that have been created in
    Ansible to manage Arista, Juniper, and Cisco are facilitators of process that
    help simplify and standardize processes and approaches. However, it really is
    the process that wraps and utilizes these modules that is the key differentiator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 单独实现一个新工具并不能真正帮助网络团队提升效率，但在 Ansible 中创建的用于管理 Arista、Juniper 和 Cisco 的模块，是简化和标准化流程与方法的促进工具。然而，真正的关键区别在于将这些模块包裹和利用起来的流程。
- en: 'Ansible can be used to help with network operations in many ways, but it is
    good to try and categorize tasks into the following categories:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以以多种方式帮助网络操作，但最好尝试将任务归类为以下几类：
- en: Desired state
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望状态
- en: Change requests
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更请求
- en: Self-service operations
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自助服务操作
- en: Desired state
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期望状态
- en: A day one set of playbooks should be used to set the desired state of the network,
    utilizing a set of roles and modules to build out brand new network devices and
    are and control the network's intended state. An example of a day one playbook
    could be the first time a network engineer needs to configure a Leaf-Spine architecture
    utilizing Arista Leaf and Spine switches, which can seem a pretty daunting activity
    at first. But the beauty is that the state of the whole underlay network could
    be described in Ansible, but the same can be said for a firewall or any other
    device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一天的 playbook 应该用于设置网络的期望状态，利用一组角色和模块来构建全新的网络设备，并控制网络的预期状态。一个第一天的 playbook 示例可能是网络工程师第一次配置使用
    Arista Leaf 和 Spine 交换机的 Leaf-Spine 架构，刚开始时这可能看起来是个相当复杂的任务。但其中的优点是，整个底层网络的状态可以在
    Ansible 中进行描述，同样的道理也适用于防火墙或任何其他设备。
- en: In the case of the Leaf-Spine network, activities will include configuring multiple
    Leaf and Spine switches, so creating a set of roles to abstract the common operations
    and calling them from a playbook is desirable, as the same configuration will
    need to be carried out on multiple servers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Leaf-Spine 网络中，活动将包括配置多个 Leaf 和 Spine 交换机，因此，创建一组角色来抽象常见操作，并在 playbook 中调用它们是可取的，因为相同的配置将需要在多个服务器上执行。
- en: A network engineer will begin by setting up the Ansible Control Host as covered
    in the Ansible prerequisites section. They will then create their inventory file
    for the Leaf-Spine architecture to configure the network devices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师将从设置 Ansible 控制主机开始，如 Ansible 先决条件部分所述。接着，他们将创建自己的清单文件，用于配置 Leaf-Spine
    架构中的网络设备。
- en: 'The network engineer should define the inventory for all the network devices
    they plan to configure. In the following example, we see two host groups containing
    two `spine` switches and four `leaf` switches:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师应定义他们计划配置的所有网络设备的清单。在以下示例中，我们看到两个主机组，包含两个 `spine` 交换机和四个 `leaf` 交换机：
- en: '![Desired state](img/5559_04_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![期望状态](img/5559_04_22.jpg)'
- en: The network operator will also need to specify the playbook containing the roles
    that they wish to execute in the `spine.yml` playbook, as shown in the following
    screenshot, to first build out the Spine switches with the desired configuration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络操作员还需要指定他们希望在 `spine.yml` playbook 中执行的角色，如以下屏幕截图所示，首先使用期望的配置构建 Spine 交换机。
- en: 'In the following example playbook, we see that the playbook targets the Spine
    host group and executes `common`, `interfaces`, `bridging`, `ipv4`, and `bgp`
    roles against the servers:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_23.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'The executed roles carry out the following configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**common role**: This role is used to configure the IP routing table on the
    Spine'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interfaces role**: This role is used to configure interfaces on the Spine'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bridging role**: This role is used to configure all necessary VLANs and switch
    ports on the Spine'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipv4 role**: This role is used to configure the Spine''s IP interfaces'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bgp role**: This role is used to configure BGP protocol to allow the switches
    to be meshed together'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these reusable roles combined will be used to configure the Arista Spine
    switches and utilize the `eos_command` module heavily.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a lot of the same modules can be utilized to configure the Leaf
    switches in the `leaf.yml` playbook, which targets the Leaf host group in the
    inventory and executes `common`, `interfaces`, `bridging`, `ipv4`, `bgp`, `ecmp`,
    and `mlag` roles, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_24.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'The executed roles are used to carry out the following configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**common role**: This role is used to configure the IP routing table on the
    Spine'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interfaces role**: This is used to configure interfaces on the Spine'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridging role**: This is used to configure all necessary VLANs and switch
    ports on the Spine'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipv4 role**: This role is used to configure the Spine''s IP interfaces'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bgp**: This is used to configure BGP protocol to allow the switches to be
    meshed together'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecmp**: This is used to ensure equal cost multipathing is configured in the
    Leaf-Spine topology'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mlag**: This is used to configure the switches redundantly at the top of
    the rack using mlag'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shows that roles can be reused if they are kept granular enough, with `var`
    files providing the necessary configuration changes to the roles, so it is important
    to avoid any hardcoded values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The Leaf-Spine build out is a day one playbook, but why should a network engineer
    be interesting in taking all this time to set this up when it will only be used
    once? This, of course, is a common misconception as playbooks and roles have described
    the whole desired state of the network, and once the initial roles are written,
    going forward they can be used to mutate the desired state of the network at any
    point in the future.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible playbooks and roles could also be used to build the second data
    center in the same way, used as a disaster recovery solution, help to mutate the
    state if a data center re-IP is required, or even scale out more Spine and Leaf
    switches in the data center.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Taking the last example, in terms of scaling out a data center, this would be
    as simple as adding more Spine or Leaf switches to the Ansible inventory. Once
    the additional Arista switches have been zero touch provisioned after being racked
    and cabled by a data center operations team.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The network operator would then only need to make a small update to the `var`
    files to specify the VLANs that need to be used and update the inventory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the infrastructure is scaled to 15 Spine switches
    and 44 Leaf switches by modifying the inventory file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_25.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Although this is a pretty extreme scale out example, it should highlight the
    point and benefits of investing in automation. As such a scale out would take
    a network engineer weeks, whereas Ansible can carry out the same operations in
    minutes once the initial roles have been built out.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: It really is worth the investment, this also means that the switches are built
    out consistently the same way as all the other switches, which alleviates manual
    error and makes the delivery of network changes more precise. Some people believe
    that automation is all about pace, but in networking, it should really be about
    consistency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The same `spine.yml` and `leaf.yml` playbooks could also be executed against
    existing switches during the scale out, as Ansible is idempotent by nature, meaning
    only state changes will be pushed to the switches if the configuration has changed.
    If roles are not idempotent, then the modules being called are at fault.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This idempotency means the same day one playbook forming a `site.yml` that calls
    both `spine.yml` and `leaf.yml` could be run over existing switches and not change
    any configuration and be re-used without having to target just the changed switches.
    It is important to note that all Ansible changes should be tested against a test
    environment before being run in production.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Change requests
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network engineers despite this automation still need a separate process for
    manual change requests, right? The simple answer is no, manual changes would break
    the desired state that has been described in the day one playbooks. All network
    changes going forward should be pushed through the same configuration mechanism;
    there should be no such thing as a separate stream of work or an ad hoc command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Making changes outside the process will only serve to break the Ansible playbooks
    and roles that were used to maintain the desired state and break the automation.
    It is important to note that utilizing network automation is an all or nothing
    approach that needs to be adopted by all team members and no changes should be
    done outside of the process or it breaks the model of repeatability and reliable
    changes. If features are lacking, the day one playbooks should be extended to
    incorporate the changes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Self-service operations
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of Ansible for network operations, one of the typical bottle necks
    is the reluctance for network engineers to give development teams access to carry
    out network changes themselves, so this places a bottle neck on networking teams
    as usually a company will have more developers than network engineers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: This reluctance is because network changes are traditionally complex and a developer's
    forte is to develop code and create applications, not log onto networking devices
    to make firewall changes for their application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: However, if network engineers created a self-service playbook that defined a
    safe set of workflow actions, then developers could use it to interface with network
    devices in a safe way, this opens up a whole world of opportunity to remove that
    bottleneck.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This puts network engineers in the position of a **subject matter expert** (**SME**)
    role to help architect and use their network experience to create network automation
    that embodies networking best practices, to serve the needs of development teams.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This is instead of network engineers carrying out manual actions such as opening
    firewall ports manually when a developer raises a ticket. It is of course a change
    in role, but an automated approach is the way the industry is evolving.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Take the example of a firewall request, a development team have created a new
    application and need a test environment to deploy it in. When configuring the
    test environment, it needs networking, and a network engineer will ask the developer
    the ports they need to open in the firewall.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The developer doesn't know how to answer this question yet as they haven't finalized
    the application and want to start incrementally developing it in the test environment.
    Therefore, each time a new port needs to be opened, it means that a new network
    ticket is required to open the incremental port the development team discovers.
    This is not the optimum use of the network engineer or the developer's time as
    it causes frustration on both sides. A network engineer's time is better spent
    optimizing the network or adding improved alerting, not processing tickets to
    open firewall ports.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Instead Ansible could be used to create a self-service file. A developer could
    create a jinja2 template that could be checked into source control that lists
    the configuration file used to make firewall changes using the `template:` module.
    This shows the existing firewall line items and is available to developers to
    add new line items and submit a pull request to open a port on the firewall.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer then reviews the change and approves or rejects it. Ansible
    upon approval can be automatically triggered to push the change to a test environment;
    this makes sure that the config is valid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we see the playbook that replaces the `firewall.config`
    file with the updated jinja2 `firewall.j2` template and then reloads the firewall
    configuration from the new template:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Self-service operations](img/5559_04_26.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: This allows network teams to enable a self-service model. This speeds up the
    pace of network changes. It also removes the networking team as the bottleneck
    and pushes them to create appropriate tests and controls for network changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得网络团队能够启用自助服务模型。这加快了网络变更的速度。它还消除了网络团队作为瓶颈的角色，并推动他们为网络变更创建适当的测试和控制。
- en: Self-service doesn't mean network engineers are no longer required. This means
    that they become the gatekeepers of the process instead of constantly rushing
    to keep up with the never ending chain of ad hoc requests they receive on a daily
    basis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 自助服务并不意味着网络工程师不再需要。这意味着他们成为流程的守门人，而不再是每天应对接连不断的临时请求。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how Ansible can be used for server-side configuration
    management of network devices and looked at some of the industry leading network
    vendors, such as Arista, Cisco, and Juniper, who have all changed their operational
    models to use open standards and protocols that are well-suited to automation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用Ansible进行网络设备的服务器端配置管理，并查看了一些行业领先的网络厂商，如Arista、Cisco和Juniper，这些厂商已经改变了他们的运营模式，采用了适合自动化的开放标准和协议。
- en: After reading this chapter, you should now be familiar with networking operating
    system from Cisco, Juniper, and Arista. The Ansible configuration management tool
    and concepts, such as Ansible Inventory, Ansible Modules, Ansible Playbooks, Ansible
    Roles, and Ansible var files and Jinja2 templates. Readers should also be familiar
    with Ansible Galaxy, the core Ansible modules available for network automation
    and methodologies to manage network devices using Ansible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您应该已经熟悉来自Cisco、Juniper和Arista的网络操作系统。了解了Ansible配置管理工具及其概念，如Ansible Inventory、Ansible
    Modules、Ansible Playbooks、Ansible Roles、Ansible变量文件和Jinja2模板。读者还应熟悉Ansible Galaxy，这是用于网络自动化的核心Ansible模块，以及通过Ansible管理网络设备的方法。
- en: This chapter gave readers an understanding of use cases where tools such as
    Ansible can be used to automate everyday network operations that are carried out
    by network engineers. It should also give readers an insight into ways they could
    improve their network automation by utilizing configuration management tooling.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让读者了解了可以使用像Ansible这样的工具来自动化网络工程师日常执行的网络操作的用例。同时，它也应当让读者了解到如何通过利用配置管理工具来改进网络自动化。
- en: The key takeaways from this chapter are that configuration management tools
    such as Ansible now support network operations natively and vendors, such as Cisco,
    Juniper, and Arista, have created modules to facilitate automation of network
    operations. There is now no reason not to start automating network operations
    as these methods are fully supported by leading network vendors who understand
    that SDN operations are the future of network operations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要收获是，像Ansible这样的配置管理工具现在本地支持网络操作，并且像Cisco、Juniper和Arista等厂商已经创建了模块来促进网络操作的自动化。现在没有理由不开始自动化网络操作，因为这些方法得到了领先网络厂商的完全支持，他们明白SDN操作是网络操作的未来。
- en: We have witnessed that Ansible is a very flexible tool. One of its main strengths
    is its ability to orchestrate APIs and help schedule software releases. Load balancing
    applications is a fundamental component of the software development release process,
    so in the the following chapter we will look at configuration management principles
    that can help orchestrate load balancers and help networking teams easily maintain
    complex load balancing solutions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见证了Ansible是一个非常灵活的工具。它的主要优点之一是能够编排API并帮助安排软件发布。负载均衡应用程序是软件开发发布过程中的一个基础组成部分，因此在下一章中，我们将探讨能够帮助编排负载均衡器的配置管理原则，帮助网络团队轻松维护复杂的负载均衡解决方案。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Useful links for Ansible network automation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible网络自动化的有用链接：
- en: '[https://www.youtube.com/watch?v=7FphWEFQbac](https://www.youtube.com/watch?v=7FphWEFQbac)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=7FphWEFQbac](https://www.youtube.com/watch?v=7FphWEFQbac)'
- en: '[https://www.youtube.com/watch?v=VYEVjKvMKqU](https://www.youtube.com/watch?v=VYEVjKvMKqU)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=VYEVjKvMKqU](https://www.youtube.com/watch?v=VYEVjKvMKqU)'
- en: 'Useful links for Cisco:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco的有用链接：
- en: '[https://pynet.twb-tech.com/blog/automation/cisco-ios.html](https://pynet.twb-tech.com/blog/automation/cisco-ios.html)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pynet.twb-tech.com/blog/automation/cisco-ios.html](https://pynet.twb-tech.com/blog/automation/cisco-ios.html)'
- en: '[http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html](http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Juniper:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html](https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf](http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Arista:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arista.com/en/products/eos/automation](https://www.arista.com/en/products/eos/automation)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arista.com/docs/Manuals/ConfigGuide.pdf](https://www.arista.com/docs/Manuals/ConfigGuide.pdf)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
