- en: Chapter 4. Configuring Network Devices Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on some of the most popular networking vendors in the
    market today, namely Cisco, Juniper, and Arista, and look at how each of these
    market leading vendors have developed their own proprietary operating system to
    control network operations. The aim of this book is not to discuss which network
    vendor's solution is better, but instead look at ways network operators can utilize
    configuration management tooling today to manage network devices, now that most
    network vendors have created APIs and SDKs to programmatically control the network.
  prefs: []
  type: TYPE_NORMAL
- en: Once the basics of each operating system have been established, we will then
    shift focus to the hugely popular open source configuration management tool from
    Red Hat named Ansible ([https://www.ansible.com/](https://www.ansible.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: We will look at ways it can be used to configure network devices programmatically
    and assist with network operations. This chapter will show practical configuration
    management processes that can be used to manage network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Network vendors' operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible modules currently available for network automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management processes to manage network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network vendors' operating systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Market leading networking vendors, such as Cisco, Juniper, and Arista, have
    all developed their own operating systems that allow network operators to issue
    a series of commands to network devices via a **command-line interface** (CLI).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each vendor''s CLI is run from their bespoke operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Cisco Ios and Nxos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper Junos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arista Eos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these operating systems have meant that it has become easier to programmatically
    control switches, routers, and security devices provided by these vendors, as
    they seek to simplify operating network devices.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of DevOps in industry has also meant that it is no longer acceptable
    to not provide programmatic APIs or SDK to aid automation, with networking vendors
    now integrating with configuration management tooling, such as Puppet, Chef, Ansible,
    and Salt, to plug into DevOps tool chains.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco Ios and Nxos operating system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cisco IOS operating system when released was the first of its kind, providing
    a set of command lines that network operators could use to mutate the state of
    the network. However, it still had its challenges; it had a monolithic architecture,
    which meant that all processes shared the same memory space, with no protection
    between parallel processes, so it didn't align itself well to parallel updates,
    but at the time it was the clear market leader. This changed network operations
    and meant that network engineers would each individually log onto network switches
    and routers to make updates using its fully featured CLI.
  prefs: []
  type: TYPE_NORMAL
- en: At the time, this greatly reduced the complexity of network operations, and
    Cisco standardized the way the networking industry carried out network operations
    in a data center. Network operators would log onto appliances and run an industry
    standard series of command lines to make changes to routers or switches, and Cisco
    ran certification programs to teach administrators how to operate the equipment
    and learn all the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Today with efficiency and cost reductions key to businesses surviving and a
    shift towards more agile processes, this model in the modern data centers has
    an obvious scaling issue with *x* amount of network engineers required per network
    device.
  prefs: []
  type: TYPE_NORMAL
- en: The emergence of private clouds has meant that the number of network devices
    each network engineer needs to manage has grown dramatically, so automation has
    become key to managing the growing amount of devices in a consistent way. If a
    businesses competitors can put products to market quicker if they have automated
    operational models, then they will be able to put products to market quicker than
    organizations that are doing manual changes. Automation has become a necessity
    to keep up with the rapid churn of change required on the network. As IT is changing
    and evolving, then automation has become a prerequisite to facilitate that evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco, as the networking market has evolved in recent years, has since developed
    a new operating system named **Nxos**, which has allowed itself to integrate with
    open source technologies and lend itself to automation. The Nxos operating system
    is deployed with all new Nexus switches and routers, and this operating system
    has shifted Cisco towards open and modular standards by integrating with open
    protocols, such as **BGP**, **EVNP**, and **VXLAN**, and the appliances can even
    run **LXC** containers, which is an operating system-level virtualization method
    in order to run multiple isolated processes on a virtual machine or physical server.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco have also provided a set of REST APIs that allows network operators to
    run native Linux and bash shells to carry out regular administration commands
    server side. In a world where AWS and OpenStack programmatic APIs are available
    to mutate network infrastructure, networking vendors needed to adapt to survive
    or they risked being left behind, so Cisco have made their own switches and routers
    as easy to configure and operate as the virtual appliances.
  prefs: []
  type: TYPE_NORMAL
- en: The Nxos operating system allows the use of the Red Hat enterprise Linux rpm
    package manager to control software updates. This means that software updates
    can be done on the Nxos in an industry standard way, the same as patching a Linux
    guest operating system would be carried out by an infrastructure system administrator.
    Consequently, Cisco network devices are now more intuitive to Linux system administrators
    and more like native Linux to end users, which has undoubtedly made them simpler
    to administrate.
  prefs: []
  type: TYPE_NORMAL
- en: The Cisco Nxos operating system means that the speed that network changes can
    be pushed increases, as operations staff can use their own tool chains and configuration
    management tools to automate updates. The Nxos operating system has become less
    vendor specific; therefore, lowering the barrier to entry to use networking products
    and automation of its product suites have become easier.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper Junos operating system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Juniper Junos operating systems driver is programmatically controlled to
    control network operations, Junipers Junos operating system was created to provide
    CLI that users can execute to retrieve facts about the running system. The Junos
    operating system is based on a clearly defined hierarchical model as opposed to
    using a series of unrelated configuration files. The hierarchical model also comes
    complete with operational and configuration modes of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, operational mode is used to upgrade the operating system, monitor
    the system, and also check the status of juniper devices. Configuration mode,
    on the other hand, allows network operators to configure user access and security,
    interfaces, hardware, and the set of protocols used on the device, which gives
    a clear separation of roles between those installing the system and those operating
    it. The Junos operating system supports all open protocols, such as BGP, VXLAN,
    and EVPN, as well as in-built roll forward and roll back capability.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper provide a Python library named **PyEZ** for the Junos operating system
    as well as a PowerShell option for Windows administrators that utilizes PowerShell
    wrapped in Python. The Python library PyEZ can retrieve any configuration information
    using tables and views that allow network operators to script against runtime
    information provided by the Junos operating system. Once a table items have been
    extracted by utilizing a python script using a `get()` method, tables can subsequently
    be treated as a Python dictionary and iterated, which allows users to carry out
    complex scripting if required, allowing network operators to automate all network
    operations. The Junos PYEZ library is also fully extensible and network operators
    can add functionality they deem appropriate using its widget system.
  prefs: []
  type: TYPE_NORMAL
- en: Arista EOS operating system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arista EOS operating system is based on open standards to promote automation
    of network functions. It relies upon a centralized **CloudVision eXchange** (**CVX**)
    and the CVX servers hold the centralized state of the network. The EOS operating
    system separates the functional control on every switch using **Sysdb**, which
    is the Arista EOS operating systems database. The Arista Sysdb is an in-memory
    database running in user space and contains the complete state of the Arista switch.
    Sysdb is maintained in memory on the device so if an Arista switch is either restarted
    or powered down all information for that switch is lost.
  prefs: []
  type: TYPE_NORMAL
- en: The CVX server acts as an aggregator managing all the state information from
    every switch's Sysdb into a network-wide database depending on what services are
    enabled on the cluster of CVX servers. When state changes occur to Sysdb on a
    switch then the change is pushed to the CVX centralized database, which then updates
    its configuration and notifies agents running on CVX of the change.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista EOS operating system supports modern open protocols, such as MLAG,
    ECMP, BGP, and VXLAN. It utilizes overlay technologies such as VXLAN allowing
    applications to be deployed and remain portable in the modern data center. Arista
    heavily promotes the use of the Leaf-Spine architecture with ECMP, which allows
    a scale out model to be implemented; this aligns itself to modern cloud solutions
    such as OpenStack and makes it agnostic to SDN controller solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista EOS operating system is a Linux-based operating system designed to
    be programmatically controlled. The main driver for the EOS operating system is
    to allow network operators to carry out network operations' using a well structured
    set of APIs including the eAPI, CLI command as well as Python, Ruby, and GO libraries
    available as part of its SDK portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: The EOS operating system also allows **Smart System Upgrade** (**SSU**) to allow
    scale out of Arista appliances with live patching and upgrades simplified and
    made more intuitive, this helps to support businesses 99.99% uptime targets. Switches
    can now be racked and cabled in the data center by data center operations teams,
    then handed over to Arista's **Zero Touch Provisioning** (**ZTP**) process that
    automates the initialization of switches and **Zero Touch Replacement** (**ZTR**)
    allows switches to be replaced in the data center.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista EOS solution CVX product can be used to automate networking workflow
    tasks through the portal if users require a visual view of switches and routers
    and the CVX allows integration with SDN controllers using OVSDB, eAPI, or OpenFlow.
    Like Cisco and Juniper, the EOS API lends due to it having multiple SDK options
    so Arista products can be easily managed by configuration management tools, such
    as Puppet, Chef, Ansible, and Salt, so that no network operation needs to be carried
    out manually.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is primarily a push-based configuration management tool that uses a
    single **Ansible Control Host**, and it can connect to multiple Linux guest operating
    systems via SSH to configure them and recently added WinRM support, so it can
    now also configure Windows guests in the same way as Linux-based operating systems.
    As Ansible can connect to multiple servers simultaneously, it aids operators by
    allowing them to carry out uniform operations across multiple Linux or Windows
    servers at the same time. This allows Ansible to help simplify the automation
    of repeatable tasks by defining them in YAML, so they can be consistently executed
    against target servers. Ansible can also be used as a centralized orchestration
    tool that can connect to API endpoints and sequence API operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see an example of the way an Ansible Control Host connects to
    servers or acts as a centralized orchestration tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Ansible](img/5559_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every operation that Ansible carries out should be idempotent as a standard,
    meaning that if the desired state is already configured on a server, then Ansible
    will check the intended state from a playbook or role and not take any action
    if a server is already in the correct state. Only if the state is different from
    what is specified in a playbook or role will the operation be executed to mutate
    the state of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a Python-based configuration management tool that controls servers
    from a Linux-based Control Host, using YAML files to define and describe desired
    state. Ansible is packaged with a rich set of extensible modules, which are primarily
    written in Python, but can also be written in any language that a user wishes.
    Ansible modules allow Python SDKs or REST API's to be wrapped in Ansible's plug-in
    boilerplate and then utilized from Ansible roles or playbooks in an easy-to-use
    architecture. Before going into more detailed examples, it is important to understand
    some of the Ansible terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible is made up of a series of YAML files that are laid out in a customizable
    directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this customized structure, the Ansible Controller Node has the following
    directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `inventories` folder holds the Ansible inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `library` folder holds any custom python plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `playbooks` folder holds all playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `roles` folder holds all the Ansible roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The overall directory structure is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible directory structure](img/5559_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This provides logical groupings of all Ansible components, which will be useful
    as the amount of playbooks or roles grow in size. It is best practice to version
    the `ansible` folder structure in a source control management system such as **Git**.
    Git is a distributed open source version control repository, which is designed
    to version control development code to facilitate speed and efficiency ([https://en.wikipedia.org/wiki/Git).](https://en.wikipedia.org/wiki/Git).)
  prefs: []
  type: TYPE_NORMAL
- en: Ansible inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ansible inventory file is simply a set of DNS hostnames or IP addresses defined
    in a YAML file. This allows Ansible to connect to those target hosts and execute
    specific commands on servers.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible allows users to use inventory files to group servers into particular
    types or use cases. For example, in networking terms, when utilizing Ansible to
    set up a Leaf-Spine architecture, a network operator could have a group for Leaf
    switches and another for the Spine switches. This is because a different set of
    run-book commands would be required to configure each, so limits can be applied
    upon execution to only execute a command against a small subset of servers limited
    to one particular group.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an inventory file defining Leaf and Spine switches can be found
    in the following image, showing the definition of two groups in the inventory
    file, one for Leaf switches named `leaf` and one for Spine switches named `spine`
    containing all the DNS entries for the switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible inventory](img/5559_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same inventory can be described in an abbreviated format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible inventory](img/5559_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ansible modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ansible module is typically written in Python or can be written in any other
    programming language. An Ansible module's code defines a set of operations to
    add or remove functionality from a guest operating system or alternately execute
    a command against an API if it is being used for orchestration. Ansible modules
    can be used to wrap either a simple command line, API call or any other operation
    a user desires that can be coded programmatically. Modules are set up, so they
    can be reused in multiple playbooks or roles in order to promote reusing code
    and the standardization of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Code specified in an Ansible module is wrapped in Ansible's module boilerplate,
    which structures the layout of the module. The boilerplate promotes a set of standards,
    so each module is idempotent by design, meaning that the code will first detect
    the state of the system and then determine if a change in state is required or
    not before executing the operation.
  prefs: []
  type: TYPE_NORMAL
- en: When a state change is executed in Ansible, it is donated by a yellow output
    on the console. If no action is taken, it will display the color green to state
    that the operation ran successfully, but no state change was made, whereas a red
    console output indicates a failure on the module.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules expose a set of command-line arguments for the module that can
    either be mandatory or optional and can have default values. Modules that adhere
    to the Ansible standard are created with a state variable that contains `present`
    or `absent`, as one of the command-line variables. A module, when set to `present`,
    will add the feature that has been specified by the playbook and when it is set
    to `absent`, it will remove the specified feature. All modules will typically
    have code to deal with both of these use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Once an Ansible module has been written, it is placed in the `library` folder,
    which means that it is available as a library to the Python interpreter and the
    code can then be utilized by defining it in an Ansible `playbooks` or `roles`.
    Ansible comes with a set of prepackaged core and extras modules that can all be
    accessed by writing some YAML to describe the operation that is required, all
    modules are packaged with documentation that are part of the boilerplate and available
    on the Ansible website.
  prefs: []
  type: TYPE_NORMAL
- en: Core modules are maintained by the Ansible core team in joint initiatives with
    software vendors and are generally of high quality. Extras modules can also be
    of a good quality but are not maintained by vendors and sometimes maintained by
    users that have committed back the modules to Ansible to help out the open source
    community.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple core `yum` module donated by `yum:` can be seen in the following screenshot
    that takes two command-line variables `name` which is used to specify the rpm
    to install and `state`, which determines whether to install or remove it from
    the target server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible modules](img/5559_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ansible roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roles are a further level of abstraction in Ansible and also defined using YAML
    files. Roles can be called from playbooks; this aims to simplify playbooks as
    much as possible. As increased sets of functionality are added to `playbooks`,
    they can become cluttered and difficult to maintain from a single file. So roles
    allow operators to create minimal playbooks that then pull all the information
    from the Ansible directory structure, which then determines the configuration
    steps that need to execute on servers or be run locally.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible roles attempt to strip out repeatable parts of playbooks and group them,
    so they can be used by multiple playbooks if required. Roles are groupings to
    determine what the server profile should actually be, rather than just focusing
    on multiple ad hoc instructions, so a playbook could be named `spine.yml` and
    the playbook could contain a set of modular roles used to define the particular
    Spine switches run-list, when executed this playbook will build the Spine switch
    on each target server specified in the Ansible inventory. If designed correctly
    some of these roles should be modular enough that they can be reused when creating
    Leaf switches.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ansible playbook is a YAML file that dictates the run-list to carry out on
    a particular set of host servers that are defined in an inventory file. A playbook
    specifies an ordered set of instructions to execute commands locally from Ansible
    Controller Node or on a target set of hosts specified in the Ansible inventory
    file.
  prefs: []
  type: TYPE_NORMAL
- en: An Ansible playbook can be used to create a run-list that calls out to modules
    or specific roles, which dictate the operations that should be executed against
    a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we see a playbook targeting the `spine` hosts in the inventory
    file and executing multiple `roles` to set up the Spine servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible playbooks](img/5559_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An alternate playbook could not use roles at all and call Ansible yum core
    module directly to install the apache `httpd-2.2.29` yum package on the inventory
    group named `server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible playbooks](img/5559_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Playbooks can also specify `when` conditions to dictate if an action in the
    playbook should be executed or not based on the output of a proceeding operation.
    The `register` command is used to store JSON output from a task that can then
    be utilized in playbooks or roles by subsequent tasks to validate if they should
    be invoked by reading the result of the JSON and evaluating the when condition.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks from version 2.x onwards can now utilize block rescue functionality
    too. So if an operation nested in a block command fails, then the rescue section
    of the playbook is invoked. This can be useful for doing cleanup of failed actions
    to make playbooks more robust.
  prefs: []
  type: TYPE_NORMAL
- en: The usefulness of a block rescue operation shouldn't be underestimated, when
    requiring to copy a large database `dmp` file to a backup location this operation
    could sometimes be error-prone due to the volume of data being copied. So if the
    disk space is too low on the target directory, then that operation could fail
    half way through leaving only part of the file copied and the server in an unusable
    state and the server could run out of disk space. Therefore, a rescue command
    could be used to clean up the copied file immediately, so the server isn't left
    in a bad state if the copy operation fails. After the rescue command has completed,
    the playbook will exit with an error but remain in its original state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see a playbook using the copy: module to copy
    the source file `/var/files/db.dmp` to `/backups/db.dmp` and the file: module
    being used to delete the file if the original command fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible playbooks](img/5559_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing an Ansible playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After playbook and inventory files have been created utilizing the specified
    folder structure, it can now be executed by specifying the `ansible-playbook`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible-playbook` tells Ansible that a YAML playbook file should be specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i` flag is used to specify the inventory file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l` limits the execution only to the servers under the inventory group (servers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e` passes additional variables to the playbook in this example production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v` sets the verbosity of the output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ansible var files and jinja2 templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible `var` files are just another YAML file that specify a set of variables
    that will be substituted into a playbook at runtime using the Ansible `include_vars`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: The `var` files are just a way of breaking out variables that are required by
    playbooks or roles at runtime. This means that different `var` files can be passed
    at runtime without having to hardcode variables into playbooks or roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a `var` file syntax is shown in the following screenshot, this
    shows the contents of a `common.yml` `var` file containing one defined variable
    named `cert_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows the `common.yml` variable above and other `environment.yml`
    variables , both being loaded into the playbook. The `{{ environment }}` is useful
    as it means that different values could be passed from the `ansible-playbook`
    command line to control the variables that are imported into the playbook using
    the `-e “environment=production”` option at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `common.yml` `var` files variables value cert1 can then be used by specifying
    `{{ cert_name }}` variable in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ansible also has the ability to utilize Python jinja2 templates that can be
    transformed at runtime, to populate the configuration files information utilizing
    a set of `var` files; for example, the `{{ environment }}` variable in the preceding
    example can be specified at runtime to load variables that populate unique environment
    information. The jinja2 template once transformed using the template module will
    be parameterized to use the variables specified in the `environment.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see the Ansible `template:` module being executed
    as part of a role copying a jinja2 template `network_template.j2` and transforming
    it to `/etc/network.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prerequisites using Ansible to configure network devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The base constructs covered in the *Introduction to Ansible* section in this
    chapter are all relevant to the Ansible networking modules, and to a networking
    team wishing to utilize Ansible for configuration management. Before starting,
    it is important to check with the networking vendors that the version of the networking
    operating system can be used with Ansible. The next step is to configure a small
    provisioning server to utilize as the Ansible Control Host, this is typically
    created on the management network so it has access appropriate to all switches.
  prefs: []
  type: TYPE_NORMAL
- en: The provisioning server can be relatively small in size as it will just be required
    to connect over SSH to the Linux-based networking operating systems. Ensure that
    the API command line is enabled on the network device. It is also a good idea
    to create a temporary user account on each of the networking devices, which will
    allow you to set up a public key on the Ansible Control Host and **Secure Copy**
    (**SCP**) the created `id_rsa.pub` to the `authorized_keys` folder on the network
    devices using the temporary account. This will allow Ansible to use that private
    key to connect to all of the hosts without the need for dealing with passwords.
    The temporary password can then be deleted from each of the network devices once
    this setup activity has been completed, you could even use Ansible to do this
    as a first activity.
  prefs: []
  type: TYPE_NORMAL
- en: All being well, the next step would be to create the Ansible folder structure
    on the provisioning server and fill out the Ansible inventory file with all the
    DNS names of all the network devices and finally install Ansible when you are
    ready to start executing playbooks. Ansible is now packaged by Red Hat in rpm
    format, so this should just be a simple yum install as long as the Ansible Control
    Host has outbound Internet access to the Red Hat repositories when using a centos
    image or Red Hat Enterprise Linux. Ansible will of course work on any Linux-based
    operating system as is still available as a PyPi package that can be installed
    on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a network operator is looking for a start point and not well-versed in coding,
    they could look for examples on Ansible Galaxy, which hosts open source community
    roles that carry out many complex commands.
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer can navigate to the Ansible Galaxy repository at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ansible Galaxy houses thousands of Ansible roles that have been developed by
    the Open Source community.
  prefs: []
  type: TYPE_NORMAL
- en: Some available examples of networking roles are the Arista EOS role that can
    be used to automate Arista switch devices. Alternately, the Cisco EVPN VXLAN Spine
    role can be used to build Spine switches on Cisco devices or the Juniper Junos
    role can be used to automate Juniper network devices. So there is a wide variety
    of modules for a variety of technologies and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following useful links:'
  prefs: []
  type: TYPE_NORMAL
- en: Arista EOS ([https://galaxy.ansible.com/arista/eos-system/](https://galaxy.ansible.com/arista/eos-system/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco ([https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/](https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper ([https://galaxy.ansible.com/Juniper/junos/](https://galaxy.ansible.com/Juniper/junos/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Users can browse roles and search for a particular networking vendor. In this
    example, a search for Arista has returned the **eos** role, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each role returned has a link to their corresponding GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ansible Galaxy is a very useful tool, where users can take roles as a start
    point and customize them to meet their needs. Rather than just taking from the
    community, any new roles that may be of use to others should be contributed back
    to the Ansible community.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible core modules available for network operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the release of Ansible 2.0, the Ansible configuration management tool
    been packaged with some of the core networking modules from Arista, Citrix, Cumulus,
    and Juniper. Ansible can be used to edit configuration for any network device.
    It isn't restricted to just these modules. Ansible Galaxy has a wide range of
    roles that have been developed by the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subnet of the Ansible 2.x networking modules can be shown in the following
    screenshot focusing upon the Juniper **Junos**, Arista **Eos**, Cisco **Nxos**,
    and **Ios**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible core modules available for network operations](img/5559_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ansible 2.x has sought to simplify networking modules by giving them a standard
    set of operations across all modules to make it feel more intuitive to network
    engineers. As many network engineers are not familiar with configuration management
    tooling, having a set of standards across modules simplifies the initial barrier
    to entry. As network engineers are able to see commands that they would utilize
    everyday being used as part of a playbook or a role, so Ansible can initially
    be utilized as a scheduling tool, before network operators delve into more complex
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main fears network engineers have when first using configuration
    management tooling is not trusting the system or understanding what is going on
    under the covers. So, being able to easily read playbooks or roles and see the
    operations that are being executed builds confidence in the tooling and makes
    adoption easier.
  prefs: []
  type: TYPE_NORMAL
- en: It is fully expected that more complex networking modules will be built out
    over time by the open source community some of which are already available with
    roles from Arista, Juniper, and Cisco available in Ansible Galaxy. However, the
    following Ansible core modules have been standardized to allow configuration of
    Arista, Cisco, and Juniper network devices in the same way. These modules can
    be used in any playbook or role.
  prefs: []
  type: TYPE_NORMAL
- en: The _command module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main module packaged with a vendor's networking modules in Ansible 2.x is
    the `_command` module. This is a conscious choice by Ansible as it is more intuitive
    to network engineers initially to use native network commands when switching to
    configuration management tooling.
  prefs: []
  type: TYPE_NORMAL
- en: This module allows Ansible to connect to hosts using SSH as network device's
    operating systems are primarily Linux-based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The `_command` module allows network operators to apply configuration changes
    to switches by connecting from the Ansible Control Host. The syntax used by Ansible
    on this command is identical to what network operators would execute on network
    devices using CLI.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the EOS command `show ip bgp summary` is executed
    by the `eos_command`, and it connects to every specified `{{ inventory_hostname
    }}`, which is a special Ansible variable that substitutes the DNS name of every
    node listed in the host group specified in the inventory file. It then registers
    the output of the command in the `eos_command_output` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![The _command module](img/5559_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Junos syntax is identical. In the following example, a similar network command
    executed on Junos to show interfaces with the JSON output captures in the `junos_command_output`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![The _command module](img/5559_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Cisco example shows Nxos, but the configuration is also the same in IOS.
    The `nxos_command` command issues a `show version` command and places the result
    in the `nxos_command_output` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The _command module](img/5559_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The _config module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_config` module is used to configure updates in a deterministic way that
    could be used to implement change requests, by batching up a number of commands.
  prefs: []
  type: TYPE_NORMAL
- en: This module allows operators to update selected lines or blocks of running configuration
    programmatically on the network device. The module will connect to the device,
    extracting the running configuration before pushing batch updates in a completely
    deterministic way.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the Arista switches configuration will be loaded by
    the module. The `no spanning-tree vlan 4094` command will be executed on the EOS
    operating system if the running configuration doesn't match the existing state,
    so the desired end state will be implemented on the switch.
  prefs: []
  type: TYPE_NORMAL
- en: '![The _config module](img/5559_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The _template module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_template` module is used to update configuration utilizing a jinja2 template
    file. This can be extracted from the running configuration of a network device,
    updated and then pushed back to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case for the `_template` module would be allowing network administrators
    to extract the running config into a jinja2 template from one network device and
    apply it to other's switches to propagate the same changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `_template` module will only push incremental changes unless the force command
    is specified as a command-line variable, which will carry out overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the `eos_config` jinja2 template is pushed to the
    Arista device and will do an incremental change to the configuration if the jinja2
    template has configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![The _template module](img/5559_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuration management processes to manage network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is primarily all about people and process, so just focusing on some examples
    of playbooks or roles in isolation against a switch or firewall wouldn't help
    network engineer deal with the real-world networking challenges that they encounter
    every day. Selecting the correct tooling to facilitate processes is also important
    after the actual goals of a project have been established. Tooling should be selected
    after the business requirements have been made clear and not the opposite way
    round.
  prefs: []
  type: TYPE_NORMAL
- en: A network engineer could easily type in those commands into a network operating
    system as they could type commands into an Ansible playbook, so it is important
    to look at where the use of a configuration management tool such as Ansible adds
    real business value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a new tool in isolation doesn't really help the network teams improve
    efficiency as a standalone activity, but the modules that have been created in
    Ansible to manage Arista, Juniper, and Cisco are facilitators of process that
    help simplify and standardize processes and approaches. However, it really is
    the process that wraps and utilizes these modules that is the key differentiator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible can be used to help with network operations in many ways, but it is
    good to try and categorize tasks into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Desired state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-service operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desired state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A day one set of playbooks should be used to set the desired state of the network,
    utilizing a set of roles and modules to build out brand new network devices and
    are and control the network's intended state. An example of a day one playbook
    could be the first time a network engineer needs to configure a Leaf-Spine architecture
    utilizing Arista Leaf and Spine switches, which can seem a pretty daunting activity
    at first. But the beauty is that the state of the whole underlay network could
    be described in Ansible, but the same can be said for a firewall or any other
    device.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Leaf-Spine network, activities will include configuring multiple
    Leaf and Spine switches, so creating a set of roles to abstract the common operations
    and calling them from a playbook is desirable, as the same configuration will
    need to be carried out on multiple servers.
  prefs: []
  type: TYPE_NORMAL
- en: A network engineer will begin by setting up the Ansible Control Host as covered
    in the Ansible prerequisites section. They will then create their inventory file
    for the Leaf-Spine architecture to configure the network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The network engineer should define the inventory for all the network devices
    they plan to configure. In the following example, we see two host groups containing
    two `spine` switches and four `leaf` switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The network operator will also need to specify the playbook containing the roles
    that they wish to execute in the `spine.yml` playbook, as shown in the following
    screenshot, to first build out the Spine switches with the desired configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example playbook, we see that the playbook targets the Spine
    host group and executes `common`, `interfaces`, `bridging`, `ipv4`, and `bgp`
    roles against the servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The executed roles carry out the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**common role**: This role is used to configure the IP routing table on the
    Spine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interfaces role**: This role is used to configure interfaces on the Spine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bridging role**: This role is used to configure all necessary VLANs and switch
    ports on the Spine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipv4 role**: This role is used to configure the Spine''s IP interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bgp role**: This role is used to configure BGP protocol to allow the switches
    to be meshed together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these reusable roles combined will be used to configure the Arista Spine
    switches and utilize the `eos_command` module heavily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a lot of the same modules can be utilized to configure the Leaf
    switches in the `leaf.yml` playbook, which targets the Leaf host group in the
    inventory and executes `common`, `interfaces`, `bridging`, `ipv4`, `bgp`, `ecmp`,
    and `mlag` roles, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The executed roles are used to carry out the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**common role**: This role is used to configure the IP routing table on the
    Spine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interfaces role**: This is used to configure interfaces on the Spine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridging role**: This is used to configure all necessary VLANs and switch
    ports on the Spine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipv4 role**: This role is used to configure the Spine''s IP interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bgp**: This is used to configure BGP protocol to allow the switches to be
    meshed together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecmp**: This is used to ensure equal cost multipathing is configured in the
    Leaf-Spine topology'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mlag**: This is used to configure the switches redundantly at the top of
    the rack using mlag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shows that roles can be reused if they are kept granular enough, with `var`
    files providing the necessary configuration changes to the roles, so it is important
    to avoid any hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: The Leaf-Spine build out is a day one playbook, but why should a network engineer
    be interesting in taking all this time to set this up when it will only be used
    once? This, of course, is a common misconception as playbooks and roles have described
    the whole desired state of the network, and once the initial roles are written,
    going forward they can be used to mutate the desired state of the network at any
    point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible playbooks and roles could also be used to build the second data
    center in the same way, used as a disaster recovery solution, help to mutate the
    state if a data center re-IP is required, or even scale out more Spine and Leaf
    switches in the data center.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the last example, in terms of scaling out a data center, this would be
    as simple as adding more Spine or Leaf switches to the Ansible inventory. Once
    the additional Arista switches have been zero touch provisioned after being racked
    and cabled by a data center operations team.
  prefs: []
  type: TYPE_NORMAL
- en: The network operator would then only need to make a small update to the `var`
    files to specify the VLANs that need to be used and update the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the infrastructure is scaled to 15 Spine switches
    and 44 Leaf switches by modifying the inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although this is a pretty extreme scale out example, it should highlight the
    point and benefits of investing in automation. As such a scale out would take
    a network engineer weeks, whereas Ansible can carry out the same operations in
    minutes once the initial roles have been built out.
  prefs: []
  type: TYPE_NORMAL
- en: It really is worth the investment, this also means that the switches are built
    out consistently the same way as all the other switches, which alleviates manual
    error and makes the delivery of network changes more precise. Some people believe
    that automation is all about pace, but in networking, it should really be about
    consistency.
  prefs: []
  type: TYPE_NORMAL
- en: The same `spine.yml` and `leaf.yml` playbooks could also be executed against
    existing switches during the scale out, as Ansible is idempotent by nature, meaning
    only state changes will be pushed to the switches if the configuration has changed.
    If roles are not idempotent, then the modules being called are at fault.
  prefs: []
  type: TYPE_NORMAL
- en: This idempotency means the same day one playbook forming a `site.yml` that calls
    both `spine.yml` and `leaf.yml` could be run over existing switches and not change
    any configuration and be re-used without having to target just the changed switches.
    It is important to note that all Ansible changes should be tested against a test
    environment before being run in production.
  prefs: []
  type: TYPE_NORMAL
- en: Change requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network engineers despite this automation still need a separate process for
    manual change requests, right? The simple answer is no, manual changes would break
    the desired state that has been described in the day one playbooks. All network
    changes going forward should be pushed through the same configuration mechanism;
    there should be no such thing as a separate stream of work or an ad hoc command.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes outside the process will only serve to break the Ansible playbooks
    and roles that were used to maintain the desired state and break the automation.
    It is important to note that utilizing network automation is an all or nothing
    approach that needs to be adopted by all team members and no changes should be
    done outside of the process or it breaks the model of repeatability and reliable
    changes. If features are lacking, the day one playbooks should be extended to
    incorporate the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Self-service operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of Ansible for network operations, one of the typical bottle necks
    is the reluctance for network engineers to give development teams access to carry
    out network changes themselves, so this places a bottle neck on networking teams
    as usually a company will have more developers than network engineers.
  prefs: []
  type: TYPE_NORMAL
- en: This reluctance is because network changes are traditionally complex and a developer's
    forte is to develop code and create applications, not log onto networking devices
    to make firewall changes for their application.
  prefs: []
  type: TYPE_NORMAL
- en: However, if network engineers created a self-service playbook that defined a
    safe set of workflow actions, then developers could use it to interface with network
    devices in a safe way, this opens up a whole world of opportunity to remove that
    bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: This puts network engineers in the position of a **subject matter expert** (**SME**)
    role to help architect and use their network experience to create network automation
    that embodies networking best practices, to serve the needs of development teams.
  prefs: []
  type: TYPE_NORMAL
- en: This is instead of network engineers carrying out manual actions such as opening
    firewall ports manually when a developer raises a ticket. It is of course a change
    in role, but an automated approach is the way the industry is evolving.
  prefs: []
  type: TYPE_NORMAL
- en: Take the example of a firewall request, a development team have created a new
    application and need a test environment to deploy it in. When configuring the
    test environment, it needs networking, and a network engineer will ask the developer
    the ports they need to open in the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: The developer doesn't know how to answer this question yet as they haven't finalized
    the application and want to start incrementally developing it in the test environment.
    Therefore, each time a new port needs to be opened, it means that a new network
    ticket is required to open the incremental port the development team discovers.
    This is not the optimum use of the network engineer or the developer's time as
    it causes frustration on both sides. A network engineer's time is better spent
    optimizing the network or adding improved alerting, not processing tickets to
    open firewall ports.
  prefs: []
  type: TYPE_NORMAL
- en: Instead Ansible could be used to create a self-service file. A developer could
    create a jinja2 template that could be checked into source control that lists
    the configuration file used to make firewall changes using the `template:` module.
    This shows the existing firewall line items and is available to developers to
    add new line items and submit a pull request to open a port on the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer then reviews the change and approves or rejects it. Ansible
    upon approval can be automatically triggered to push the change to a test environment;
    this makes sure that the config is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we see the playbook that replaces the `firewall.config`
    file with the updated jinja2 `firewall.j2` template and then reloads the firewall
    configuration from the new template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Self-service operations](img/5559_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This allows network teams to enable a self-service model. This speeds up the
    pace of network changes. It also removes the networking team as the bottleneck
    and pushes them to create appropriate tests and controls for network changes.
  prefs: []
  type: TYPE_NORMAL
- en: Self-service doesn't mean network engineers are no longer required. This means
    that they become the gatekeepers of the process instead of constantly rushing
    to keep up with the never ending chain of ad hoc requests they receive on a daily
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how Ansible can be used for server-side configuration
    management of network devices and looked at some of the industry leading network
    vendors, such as Arista, Cisco, and Juniper, who have all changed their operational
    models to use open standards and protocols that are well-suited to automation.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should now be familiar with networking operating
    system from Cisco, Juniper, and Arista. The Ansible configuration management tool
    and concepts, such as Ansible Inventory, Ansible Modules, Ansible Playbooks, Ansible
    Roles, and Ansible var files and Jinja2 templates. Readers should also be familiar
    with Ansible Galaxy, the core Ansible modules available for network automation
    and methodologies to manage network devices using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gave readers an understanding of use cases where tools such as
    Ansible can be used to automate everyday network operations that are carried out
    by network engineers. It should also give readers an insight into ways they could
    improve their network automation by utilizing configuration management tooling.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaways from this chapter are that configuration management tools
    such as Ansible now support network operations natively and vendors, such as Cisco,
    Juniper, and Arista, have created modules to facilitate automation of network
    operations. There is now no reason not to start automating network operations
    as these methods are fully supported by leading network vendors who understand
    that SDN operations are the future of network operations.
  prefs: []
  type: TYPE_NORMAL
- en: We have witnessed that Ansible is a very flexible tool. One of its main strengths
    is its ability to orchestrate APIs and help schedule software releases. Load balancing
    applications is a fundamental component of the software development release process,
    so in the the following chapter we will look at configuration management principles
    that can help orchestrate load balancers and help networking teams easily maintain
    complex load balancing solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Useful links for Ansible network automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=7FphWEFQbac](https://www.youtube.com/watch?v=7FphWEFQbac)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=VYEVjKvMKqU](https://www.youtube.com/watch?v=VYEVjKvMKqU)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Cisco:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pynet.twb-tech.com/blog/automation/cisco-ios.html](https://pynet.twb-tech.com/blog/automation/cisco-ios.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html](http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Juniper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html](https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf](http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Arista:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arista.com/en/products/eos/automation](https://www.arista.com/en/products/eos/automation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arista.com/docs/Manuals/ConfigGuide.pdf](https://www.arista.com/docs/Manuals/ConfigGuide.pdf)'
  prefs: []
  type: TYPE_NORMAL
