- en: Chapter 4. Configuring Network Devices Using Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。使用 Ansible 配置网络设备
- en: This chapter will focus on some of the most popular networking vendors in the
    market today, namely Cisco, Juniper, and Arista, and look at how each of these
    market leading vendors have developed their own proprietary operating system to
    control network operations. The aim of this book is not to discuss which network
    vendor's solution is better, but instead look at ways network operators can utilize
    configuration management tooling today to manage network devices, now that most
    network vendors have created APIs and SDKs to programmatically control the network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注当今市场上最受欢迎的几个网络供应商，即 Cisco、Juniper 和 Arista，并探讨这些市场领先供应商如何开发自己的专有操作系统来控制网络操作。本书的目的不是讨论哪家网络供应商的解决方案更好，而是探讨网络运营商如何利用现有的配置管理工具来管理网络设备，因为大多数网络供应商已经创建了用于以编程方式控制网络的
    API 和 SDK。
- en: Once the basics of each operating system have been established, we will then
    shift focus to the hugely popular open source configuration management tool from
    Red Hat named Ansible ([https://www.ansible.com/](https://www.ansible.com/)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了每个操作系统的基础知识，我们将转向来自 Red Hat 的非常流行的开源配置管理工具 Ansible（[https://www.ansible.com/](https://www.ansible.com/)）。
- en: We will look at ways it can be used to configure network devices programmatically
    and assist with network operations. This chapter will show practical configuration
    management processes that can be used to manage network devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用它来以编程方式配置网络设备并帮助网络运营。本章将展示可用于管理网络设备的实际配置管理流程。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Network vendors' operating systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络供应商的操作系统
- en: Introduction to Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 简介
- en: Ansible modules currently available for network automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前用于网络自动化的 Ansible 模块
- en: Configuration management processes to manage network devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理网络设备的配置管理流程
- en: Network vendors' operating systems
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络供应商的操作系统
- en: Market leading networking vendors, such as Cisco, Juniper, and Arista, have
    all developed their own operating systems that allow network operators to issue
    a series of commands to network devices via a **command-line interface** (CLI).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 市场领先的网络供应商，如 Cisco、Juniper 和 Arista，都开发了自己的操作系统，允许网络运营商通过命令行界面（CLI）向网络设备发出一系列命令。
- en: 'Each vendor''s CLI is run from their bespoke operating systems:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个供应商的 CLI 都是从他们专门的操作系统运行的：
- en: Cisco Ios and Nxos
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco IOS 和 Nxos
- en: Juniper Junos
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper Junos
- en: Arista Eos
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista Eos
- en: All of these operating systems have meant that it has become easier to programmatically
    control switches, routers, and security devices provided by these vendors, as
    they seek to simplify operating network devices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作系统都使得通过编程方式控制交换机、路由器和安全设备变得更加容易，因为它们试图简化操作网络设备。
- en: The rise of DevOps in industry has also meant that it is no longer acceptable
    to not provide programmatic APIs or SDK to aid automation, with networking vendors
    now integrating with configuration management tooling, such as Puppet, Chef, Ansible,
    and Salt, to plug into DevOps tool chains.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在行业中 DevOps 的兴起也意味着不再可以不提供编程 API 或 SDK 来帮助自动化，现在网络供应商与配置管理工具（如 Puppet、Chef、Ansible
    和 Salt）集成，以插入 DevOps 工具链。
- en: Cisco Ios and Nxos operating system
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cisco IOS 和 Nxos 操作系统
- en: The Cisco IOS operating system when released was the first of its kind, providing
    a set of command lines that network operators could use to mutate the state of
    the network. However, it still had its challenges; it had a monolithic architecture,
    which meant that all processes shared the same memory space, with no protection
    between parallel processes, so it didn't align itself well to parallel updates,
    but at the time it was the clear market leader. This changed network operations
    and meant that network engineers would each individually log onto network switches
    and routers to make updates using its fully featured CLI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Cisco IOS 操作系统发布时，它是首个提供一组命令行的操作系统，网络运营商可以使用这些命令行来改变网络状态。然而，它仍然存在一些挑战；它具有单片架构，意味着所有进程共享相同的内存空间，并且在并行进程之间没有保护，因此它不适合并行更新，但在当时它是明确的市场领导者。这改变了网络操作方式，意味着网络工程师需要分别登录到网络交换机和路由器上，使用其功能齐全的
    CLI 进行更新。
- en: At the time, this greatly reduced the complexity of network operations, and
    Cisco standardized the way the networking industry carried out network operations
    in a data center. Network operators would log onto appliances and run an industry
    standard series of command lines to make changes to routers or switches, and Cisco
    ran certification programs to teach administrators how to operate the equipment
    and learn all the commands.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，这大大减少了网络操作的复杂性，Cisco 规范化了数据中心中网络操作的方式。网络管理员将登录到设备，运行一系列行业标准的命令行来修改路由器或交换机，Cisco
    还开设了认证项目，教授管理员如何操作设备并学习所有命令。
- en: Today with efficiency and cost reductions key to businesses surviving and a
    shift towards more agile processes, this model in the modern data centers has
    an obvious scaling issue with *x* amount of network engineers required per network
    device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在效率和成本削减对于企业生存至关重要且业务流程向更加灵活的方式转变的背景下，这种现代数据中心模型在网络工程师与网络设备的比例上存在明显的扩展问题，*每个网络设备所需的网络工程师数量*。
- en: The emergence of private clouds has meant that the number of network devices
    each network engineer needs to manage has grown dramatically, so automation has
    become key to managing the growing amount of devices in a consistent way. If a
    businesses competitors can put products to market quicker if they have automated
    operational models, then they will be able to put products to market quicker than
    organizations that are doing manual changes. Automation has become a necessity
    to keep up with the rapid churn of change required on the network. As IT is changing
    and evolving, then automation has become a prerequisite to facilitate that evolution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 私有云的出现意味着每个网络工程师需要管理的网络设备数量急剧增加，因此自动化成为了以一致的方式管理大量设备的关键。如果一个企业的竞争对手通过自动化的运营模型能够更快地将产品推向市场，那么他们将能比进行手动更改的组织更快地推出产品。自动化已成为跟上网络快速变化所必需的条件。随着
    IT 的变化和发展，自动化已成为促进这一演变的前提。
- en: Cisco, as the networking market has evolved in recent years, has since developed
    a new operating system named **Nxos**, which has allowed itself to integrate with
    open source technologies and lend itself to automation. The Nxos operating system
    is deployed with all new Nexus switches and routers, and this operating system
    has shifted Cisco towards open and modular standards by integrating with open
    protocols, such as **BGP**, **EVNP**, and **VXLAN**, and the appliances can even
    run **LXC** containers, which is an operating system-level virtualization method
    in order to run multiple isolated processes on a virtual machine or physical server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着近年来网络市场的演变，Cisco 开发了一个新的操作系统 **Nxos**，使其能够与开源技术集成并支持自动化。Nxos 操作系统已部署在所有新的
    Nexus 交换机和路由器上，这一操作系统通过集成开源协议（如 **BGP**、**EVNP** 和 **VXLAN**）将 Cisco 推向开放和模块化的标准，且这些设备甚至可以运行
    **LXC** 容器，这是一种操作系统级虚拟化方法，用于在虚拟机或物理服务器上运行多个隔离的进程。
- en: Cisco have also provided a set of REST APIs that allows network operators to
    run native Linux and bash shells to carry out regular administration commands
    server side. In a world where AWS and OpenStack programmatic APIs are available
    to mutate network infrastructure, networking vendors needed to adapt to survive
    or they risked being left behind, so Cisco have made their own switches and routers
    as easy to configure and operate as the virtual appliances.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco 还提供了一套 REST API，允许网络运营商运行原生 Linux 和 bash shell 来执行常规的服务器端管理命令。在 AWS 和
    OpenStack 提供的编程 API 可以用来变更网络基础设施的时代，网络供应商需要适应才能生存，否则就可能被淘汰。因此，Cisco 将其交换机和路由器的配置和操作简化到与虚拟设备一样容易。
- en: The Nxos operating system allows the use of the Red Hat enterprise Linux rpm
    package manager to control software updates. This means that software updates
    can be done on the Nxos in an industry standard way, the same as patching a Linux
    guest operating system would be carried out by an infrastructure system administrator.
    Consequently, Cisco network devices are now more intuitive to Linux system administrators
    and more like native Linux to end users, which has undoubtedly made them simpler
    to administrate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Nxos 操作系统允许使用 Red Hat 企业版 Linux rpm 包管理器来控制软件更新。这意味着，软件更新可以以行业标准的方式在 Nxos 上进行，就像通过基础设施系统管理员对
    Linux 客户操作系统进行打补丁一样。因此，Cisco 网络设备现在对 Linux 系统管理员来说更加直观，并且对最终用户来说更像原生 Linux，这无疑使得它们的管理变得更简单。
- en: The Cisco Nxos operating system means that the speed that network changes can
    be pushed increases, as operations staff can use their own tool chains and configuration
    management tools to automate updates. The Nxos operating system has become less
    vendor specific; therefore, lowering the barrier to entry to use networking products
    and automation of its product suites have become easier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco Nxos 操作系统意味着网络变更的推送速度得以提升，因为运营人员可以使用他们自己的工具链和配置管理工具来自动化更新。Nxos 操作系统已经变得不那么依赖厂商，因此，使用网络产品和自动化其产品套件的门槛变得更低。
- en: Juniper Junos operating system
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Juniper Junos 操作系统
- en: The Juniper Junos operating systems driver is programmatically controlled to
    control network operations, Junipers Junos operating system was created to provide
    CLI that users can execute to retrieve facts about the running system. The Junos
    operating system is based on a clearly defined hierarchical model as opposed to
    using a series of unrelated configuration files. The hierarchical model also comes
    complete with operational and configuration modes of operation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper Junos 操作系统驱动程序通过程序化控制来控制网络操作，Junos 操作系统的设计旨在提供 CLI，用户可以通过它执行以检索运行系统的相关信息。Junos
    操作系统基于一个明确的层次模型，而不是使用一系列不相关的配置文件。层次模型还完整支持操作模式和配置模式。
- en: Intuitively, operational mode is used to upgrade the operating system, monitor
    the system, and also check the status of juniper devices. Configuration mode,
    on the other hand, allows network operators to configure user access and security,
    interfaces, hardware, and the set of protocols used on the device, which gives
    a clear separation of roles between those installing the system and those operating
    it. The Junos operating system supports all open protocols, such as BGP, VXLAN,
    and EVPN, as well as in-built roll forward and roll back capability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，操作模式用于升级操作系统、监控系统以及检查 Juniper 设备的状态。而配置模式则允许网络管理员配置用户访问和安全性、接口、硬件以及设备上使用的协议集，这为安装系统的人员和操作系统的人员之间提供了清晰的角色分离。Junos
    操作系统支持所有开放协议，如 BGP、VXLAN 和 EVPN，并且具备内建的前滚和回滚功能。
- en: Juniper provide a Python library named **PyEZ** for the Junos operating system
    as well as a PowerShell option for Windows administrators that utilizes PowerShell
    wrapped in Python. The Python library PyEZ can retrieve any configuration information
    using tables and views that allow network operators to script against runtime
    information provided by the Junos operating system. Once a table items have been
    extracted by utilizing a python script using a `get()` method, tables can subsequently
    be treated as a Python dictionary and iterated, which allows users to carry out
    complex scripting if required, allowing network operators to automate all network
    operations. The Junos PYEZ library is also fully extensible and network operators
    can add functionality they deem appropriate using its widget system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper 提供了一款名为**PyEZ**的 Python 库，适用于 Junos 操作系统，并为 Windows 管理员提供了一个 PowerShell
    选项，该选项利用了 Python 中封装的 PowerShell。Python 库 PyEZ 可以通过使用表格和视图来检索任何配置信息，这些表格和视图允许网络管理员根据
    Junos 操作系统提供的运行时信息进行脚本编写。一旦通过利用 `get()` 方法的 Python 脚本提取了表格项，表格可以随后被视为 Python 字典并进行迭代，这使得用户可以在需要时执行复杂的脚本，从而允许网络管理员自动化所有网络操作。Junos
    PYEZ 库也完全可扩展，网络管理员可以使用其小部件系统添加他们认为合适的功能。
- en: Arista EOS operating system
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统
- en: The Arista EOS operating system is based on open standards to promote automation
    of network functions. It relies upon a centralized **CloudVision eXchange** (**CVX**)
    and the CVX servers hold the centralized state of the network. The EOS operating
    system separates the functional control on every switch using **Sysdb**, which
    is the Arista EOS operating systems database. The Arista Sysdb is an in-memory
    database running in user space and contains the complete state of the Arista switch.
    Sysdb is maintained in memory on the device so if an Arista switch is either restarted
    or powered down all information for that switch is lost.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统基于开放标准，旨在促进网络功能的自动化。它依赖于集中式的**CloudVision eXchange**（**CVX**），CVX
    服务器保存网络的集中状态。EOS 操作系统通过 **Sysdb** 来分离每个交换机上的功能控制，Sysdb 是 Arista EOS 操作系统的数据库。Arista
    Sysdb 是一个运行在用户空间的内存数据库，包含 Arista 交换机的完整状态。Sysdb 存储在设备内存中，因此如果 Arista 交换机重新启动或断电，所有与该交换机相关的信息将丢失。
- en: The CVX server acts as an aggregator managing all the state information from
    every switch's Sysdb into a network-wide database depending on what services are
    enabled on the cluster of CVX servers. When state changes occur to Sysdb on a
    switch then the change is pushed to the CVX centralized database, which then updates
    its configuration and notifies agents running on CVX of the change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CVX 服务器作为聚合器，管理从每个交换机的 Sysdb 中收集的所有状态信息，并根据 CVX 服务器集群启用的服务，将信息汇总到网络范围的数据库中。当交换机的
    Sysdb 中发生状态变化时，变化会推送到 CVX 集中数据库，随后更新其配置并通知 CVX 上运行的代理程序。
- en: The Arista EOS operating system supports modern open protocols, such as MLAG,
    ECMP, BGP, and VXLAN. It utilizes overlay technologies such as VXLAN allowing
    applications to be deployed and remain portable in the modern data center. Arista
    heavily promotes the use of the Leaf-Spine architecture with ECMP, which allows
    a scale out model to be implemented; this aligns itself to modern cloud solutions
    such as OpenStack and makes it agnostic to SDN controller solutions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统支持现代开放协议，如 MLAG、ECMP、BGP 和 VXLAN。它利用 VXLAN 等覆盖技术，使得应用能够在现代数据中心中部署并保持可移植性。Arista
    大力推广在 ECMP 下使用 Leaf-Spine 架构，允许实现扩展模型；这一架构与现代云解决方案如 OpenStack 一致，并使其与 SDN 控制器解决方案保持独立。
- en: The Arista EOS operating system is a Linux-based operating system designed to
    be programmatically controlled. The main driver for the EOS operating system is
    to allow network operators to carry out network operations' using a well structured
    set of APIs including the eAPI, CLI command as well as Python, Ruby, and GO libraries
    available as part of its SDK portfolio.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 操作系统是一个基于 Linux 的操作系统，旨在被程序化控制。EOS 操作系统的主要驱动力是允许网络操作员使用一套结构化的 API，包括
    eAPI、CLI 命令以及作为其 SDK 产品组合的一部分的 Python、Ruby 和 GO 库，来执行网络操作。
- en: The EOS operating system also allows **Smart System Upgrade** (**SSU**) to allow
    scale out of Arista appliances with live patching and upgrades simplified and
    made more intuitive, this helps to support businesses 99.99% uptime targets. Switches
    can now be racked and cabled in the data center by data center operations teams,
    then handed over to Arista's **Zero Touch Provisioning** (**ZTP**) process that
    automates the initialization of switches and **Zero Touch Replacement** (**ZTR**)
    allows switches to be replaced in the data center.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: EOS 操作系统还支持**智能系统升级**（**SSU**），通过实时修补和升级的简化及更直观的方式，支持 Arista 设备的扩展，这有助于支持企业的
    99.99% 在线时间目标。交换机现在可以由数据中心运营团队在数据中心安装并接线，然后交给 Arista 的**零接触配置**（**ZTP**）过程，自动化交换机初始化，**零接触替换**（**ZTR**）允许交换机在数据中心中进行更换。
- en: The Arista EOS solution CVX product can be used to automate networking workflow
    tasks through the portal if users require a visual view of switches and routers
    and the CVX allows integration with SDN controllers using OVSDB, eAPI, or OpenFlow.
    Like Cisco and Juniper, the EOS API lends due to it having multiple SDK options
    so Arista products can be easily managed by configuration management tools, such
    as Puppet, Chef, Ansible, and Salt, so that no network operation needs to be carried
    out manually.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 解决方案 CVX 产品可以通过门户自动化网络工作流任务，如果用户需要交换机和路由器的可视化视图，CVX 允许通过 OVSDB、eAPI
    或 OpenFlow 与 SDN 控制器集成。像 Cisco 和 Juniper 一样，EOS API 由于提供了多种 SDK 选项，因此 Arista 产品可以通过配置管理工具（如
    Puppet、Chef、Ansible 和 Salt）轻松管理，从而避免手动进行任何网络操作。
- en: Introduction to Ansible
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 简介
- en: Ansible is primarily a push-based configuration management tool that uses a
    single **Ansible Control Host**, and it can connect to multiple Linux guest operating
    systems via SSH to configure them and recently added WinRM support, so it can
    now also configure Windows guests in the same way as Linux-based operating systems.
    As Ansible can connect to multiple servers simultaneously, it aids operators by
    allowing them to carry out uniform operations across multiple Linux or Windows
    servers at the same time. This allows Ansible to help simplify the automation
    of repeatable tasks by defining them in YAML, so they can be consistently executed
    against target servers. Ansible can also be used as a centralized orchestration
    tool that can connect to API endpoints and sequence API operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see an example of the way an Ansible Control Host connects to
    servers or acts as a centralized orchestration tool:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Ansible](img/5559_04_28.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Every operation that Ansible carries out should be idempotent as a standard,
    meaning that if the desired state is already configured on a server, then Ansible
    will check the intended state from a playbook or role and not take any action
    if a server is already in the correct state. Only if the state is different from
    what is specified in a playbook or role will the operation be executed to mutate
    the state of the server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a Python-based configuration management tool that controls servers
    from a Linux-based Control Host, using YAML files to define and describe desired
    state. Ansible is packaged with a rich set of extensible modules, which are primarily
    written in Python, but can also be written in any language that a user wishes.
    Ansible modules allow Python SDKs or REST API's to be wrapped in Ansible's plug-in
    boilerplate and then utilized from Ansible roles or playbooks in an easy-to-use
    architecture. Before going into more detailed examples, it is important to understand
    some of the Ansible terminology.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Ansible directory structure
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible is made up of a series of YAML files that are laid out in a customizable
    directory structure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'In this customized structure, the Ansible Controller Node has the following
    directory structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The `inventories` folder holds the Ansible inventory
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `library` folder holds any custom python plugins
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `playbooks` folder holds all playbooks
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `roles` folder holds all the Ansible roles
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The overall directory structure is shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible directory structure](img/5559_04_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: This provides logical groupings of all Ansible components, which will be useful
    as the amount of playbooks or roles grow in size. It is best practice to version
    the `ansible` folder structure in a source control management system such as **Git**.
    Git is a distributed open source version control repository, which is designed
    to version control development code to facilitate speed and efficiency ([https://en.wikipedia.org/wiki/Git).](https://en.wikipedia.org/wiki/Git).)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Ansible inventory
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ansible inventory file is simply a set of DNS hostnames or IP addresses defined
    in a YAML file. This allows Ansible to connect to those target hosts and execute
    specific commands on servers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Ansible allows users to use inventory files to group servers into particular
    types or use cases. For example, in networking terms, when utilizing Ansible to
    set up a Leaf-Spine architecture, a network operator could have a group for Leaf
    switches and another for the Spine switches. This is because a different set of
    run-book commands would be required to configure each, so limits can be applied
    upon execution to only execute a command against a small subset of servers limited
    to one particular group.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an inventory file defining Leaf and Spine switches can be found
    in the following image, showing the definition of two groups in the inventory
    file, one for Leaf switches named `leaf` and one for Spine switches named `spine`
    containing all the DNS entries for the switches:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible inventory](img/5559_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'The same inventory can be described in an abbreviated format:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible inventory](img/5559_04_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Ansible modules
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ansible module is typically written in Python or can be written in any other
    programming language. An Ansible module's code defines a set of operations to
    add or remove functionality from a guest operating system or alternately execute
    a command against an API if it is being used for orchestration. Ansible modules
    can be used to wrap either a simple command line, API call or any other operation
    a user desires that can be coded programmatically. Modules are set up, so they
    can be reused in multiple playbooks or roles in order to promote reusing code
    and the standardization of operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Code specified in an Ansible module is wrapped in Ansible's module boilerplate,
    which structures the layout of the module. The boilerplate promotes a set of standards,
    so each module is idempotent by design, meaning that the code will first detect
    the state of the system and then determine if a change in state is required or
    not before executing the operation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: When a state change is executed in Ansible, it is donated by a yellow output
    on the console. If no action is taken, it will display the color green to state
    that the operation ran successfully, but no state change was made, whereas a red
    console output indicates a failure on the module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules expose a set of command-line arguments for the module that can
    either be mandatory or optional and can have default values. Modules that adhere
    to the Ansible standard are created with a state variable that contains `present`
    or `absent`, as one of the command-line variables. A module, when set to `present`,
    will add the feature that has been specified by the playbook and when it is set
    to `absent`, it will remove the specified feature. All modules will typically
    have code to deal with both of these use cases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Once an Ansible module has been written, it is placed in the `library` folder,
    which means that it is available as a library to the Python interpreter and the
    code can then be utilized by defining it in an Ansible `playbooks` or `roles`.
    Ansible comes with a set of prepackaged core and extras modules that can all be
    accessed by writing some YAML to describe the operation that is required, all
    modules are packaged with documentation that are part of the boilerplate and available
    on the Ansible website.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了Ansible模块，它就会被放置在`library`文件夹中，这意味着它作为库对Python解释器可用，代码可以通过在Ansible的`playbooks`或`roles`中定义来使用。Ansible提供了一组预打包的核心模块和附加模块，所有这些模块都可以通过编写一些YAML来描述所需的操作进行访问，所有模块都附带有文档，文档是模块的样板部分，并且可以在Ansible官网上找到。
- en: Core modules are maintained by the Ansible core team in joint initiatives with
    software vendors and are generally of high quality. Extras modules can also be
    of a good quality but are not maintained by vendors and sometimes maintained by
    users that have committed back the modules to Ansible to help out the open source
    community.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块由Ansible核心团队与软件供应商的联合项目维护，通常具有较高的质量。附加模块也可以具有良好的质量，但不是由供应商维护的，有时是由用户维护的，这些用户将模块提交回Ansible，以帮助开源社区。
- en: 'A simple core `yum` module donated by `yum:` can be seen in the following screenshot
    that takes two command-line variables `name` which is used to specify the rpm
    to install and `state`, which determines whether to install or remove it from
    the target server:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，可以看到一个简单的核心`yum`模块，由`yum:`提供，它带有两个命令行变量`name`，用于指定要安装的rpm，以及`state`，它决定是否在目标服务器上安装或移除该rpm：
- en: '![Ansible modules](img/5559_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Ansible模块](img/5559_04_05.jpg)'
- en: Ansible roles
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible角色
- en: Roles are a further level of abstraction in Ansible and also defined using YAML
    files. Roles can be called from playbooks; this aims to simplify playbooks as
    much as possible. As increased sets of functionality are added to `playbooks`,
    they can become cluttered and difficult to maintain from a single file. So roles
    allow operators to create minimal playbooks that then pull all the information
    from the Ansible directory structure, which then determines the configuration
    steps that need to execute on servers or be run locally.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是Ansible中的进一步抽象层，也使用YAML文件定义。角色可以从剧本中调用；这旨在尽可能简化剧本。随着`playbooks`功能集的增加，它们可能变得杂乱且难以维护。如果将所有功能都放在一个文件中，剧本可能会变得很难管理。所以角色允许操作员创建最小化的剧本，然后从Ansible目录结构中拉取所有信息，从而决定需要在服务器上执行的配置步骤或本地运行的操作。
- en: Ansible roles attempt to strip out repeatable parts of playbooks and group them,
    so they can be used by multiple playbooks if required. Roles are groupings to
    determine what the server profile should actually be, rather than just focusing
    on multiple ad hoc instructions, so a playbook could be named `spine.yml` and
    the playbook could contain a set of modular roles used to define the particular
    Spine switches run-list, when executed this playbook will build the Spine switch
    on each target server specified in the Ansible inventory. If designed correctly
    some of these roles should be modular enough that they can be reused when creating
    Leaf switches.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色试图剥离剧本中的可重复部分并将其分组，以便在需要时可以由多个剧本使用。角色是为了确定服务器配置文件应该是什么，而不仅仅是专注于多个临时指令，因此剧本可以命名为`spine.yml`，并且该剧本可以包含一组模块化的角色，用于定义特定Spine交换机的运行列表，执行此剧本时，它将在Ansible清单中指定的每个目标服务器上构建Spine交换机。如果设计得当，这些角色应该具有足够的模块化，以便在创建Leaf交换机时重复使用。
- en: Ansible playbooks
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible剧本
- en: An Ansible playbook is a YAML file that dictates the run-list to carry out on
    a particular set of host servers that are defined in an inventory file. A playbook
    specifies an ordered set of instructions to execute commands locally from Ansible
    Controller Node or on a target set of hosts specified in the Ansible inventory
    file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible剧本是一个YAML文件，用来指示在Ansible清单文件中定义的特定主机集上执行的运行列表。剧本指定了一组有序的指令，从Ansible控制节点或在Ansible清单文件中指定的目标主机上本地执行命令。
- en: An Ansible playbook can be used to create a run-list that calls out to modules
    or specific roles, which dictate the operations that should be executed against
    a server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible剧本可以用来创建一个运行列表，调用模块或特定的角色，指示应该在服务器上执行的操作。
- en: 'In this example, we see a playbook targeting the `spine` hosts in the inventory
    file and executing multiple `roles` to set up the Spine servers:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到一个针对清单文件中`spine`主机的剧本，并执行多个`roles`来设置Spine服务器：
- en: '![Ansible playbooks](img/5559_04_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'An alternate playbook could not use roles at all and call Ansible yum core
    module directly to install the apache `httpd-2.2.29` yum package on the inventory
    group named `server`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible playbooks](img/5559_04_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Playbooks can also specify `when` conditions to dictate if an action in the
    playbook should be executed or not based on the output of a proceeding operation.
    The `register` command is used to store JSON output from a task that can then
    be utilized in playbooks or roles by subsequent tasks to validate if they should
    be invoked by reading the result of the JSON and evaluating the when condition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks from version 2.x onwards can now utilize block rescue functionality
    too. So if an operation nested in a block command fails, then the rescue section
    of the playbook is invoked. This can be useful for doing cleanup of failed actions
    to make playbooks more robust.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The usefulness of a block rescue operation shouldn't be underestimated, when
    requiring to copy a large database `dmp` file to a backup location this operation
    could sometimes be error-prone due to the volume of data being copied. So if the
    disk space is too low on the target directory, then that operation could fail
    half way through leaving only part of the file copied and the server in an unusable
    state and the server could run out of disk space. Therefore, a rescue command
    could be used to clean up the copied file immediately, so the server isn't left
    in a bad state if the copy operation fails. After the rescue command has completed,
    the playbook will exit with an error but remain in its original state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see a playbook using the copy: module to copy
    the source file `/var/files/db.dmp` to `/backups/db.dmp` and the file: module
    being used to delete the file if the original command fails:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible playbooks](img/5559_04_08.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Executing an Ansible playbook
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After playbook and inventory files have been created utilizing the specified
    folder structure, it can now be executed by specifying the `ansible-playbook`
    command.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible-playbook` tells Ansible that a YAML playbook file should be specified'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i` flag is used to specify the inventory file'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l` limits the execution only to the servers under the inventory group (servers)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e` passes additional variables to the playbook in this example production'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v` sets the verbosity of the output:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ansible var files and jinja2 templates
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible `var` files are just another YAML file that specify a set of variables
    that will be substituted into a playbook at runtime using the Ansible `include_vars`
    statement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The `var` files are just a way of breaking out variables that are required by
    playbooks or roles at runtime. This means that different `var` files can be passed
    at runtime without having to hardcode variables into playbooks or roles.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a `var` file syntax is shown in the following screenshot, this
    shows the contents of a `common.yml` `var` file containing one defined variable
    named `cert_name`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows the `common.yml` variable above and other `environment.yml`
    variables , both being loaded into the playbook. The `{{ environment }}` is useful
    as it means that different values could be passed from the `ansible-playbook`
    command line to control the variables that are imported into the playbook using
    the `-e “environment=production”` option at runtime:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'The `common.yml` `var` files variables value cert1 can then be used by specifying
    `{{ cert_name }}` variable in the playbook:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Ansible also has the ability to utilize Python jinja2 templates that can be
    transformed at runtime, to populate the configuration files information utilizing
    a set of `var` files; for example, the `{{ environment }}` variable in the preceding
    example can be specified at runtime to load variables that populate unique environment
    information. The jinja2 template once transformed using the template module will
    be parameterized to use the variables specified in the `environment.yml` file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see the Ansible `template:` module being executed
    as part of a role copying a jinja2 template `network_template.j2` and transforming
    it to `/etc/network.conf`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible var files and jinja2 templates](img/5559_04_12.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Prerequisites using Ansible to configure network devices
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The base constructs covered in the *Introduction to Ansible* section in this
    chapter are all relevant to the Ansible networking modules, and to a networking
    team wishing to utilize Ansible for configuration management. Before starting,
    it is important to check with the networking vendors that the version of the networking
    operating system can be used with Ansible. The next step is to configure a small
    provisioning server to utilize as the Ansible Control Host, this is typically
    created on the management network so it has access appropriate to all switches.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The provisioning server can be relatively small in size as it will just be required
    to connect over SSH to the Linux-based networking operating systems. Ensure that
    the API command line is enabled on the network device. It is also a good idea
    to create a temporary user account on each of the networking devices, which will
    allow you to set up a public key on the Ansible Control Host and **Secure Copy**
    (**SCP**) the created `id_rsa.pub` to the `authorized_keys` folder on the network
    devices using the temporary account. This will allow Ansible to use that private
    key to connect to all of the hosts without the need for dealing with passwords.
    The temporary password can then be deleted from each of the network devices once
    this setup activity has been completed, you could even use Ansible to do this
    as a first activity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: All being well, the next step would be to create the Ansible folder structure
    on the provisioning server and fill out the Ansible inventory file with all the
    DNS names of all the network devices and finally install Ansible when you are
    ready to start executing playbooks. Ansible is now packaged by Red Hat in rpm
    format, so this should just be a simple yum install as long as the Ansible Control
    Host has outbound Internet access to the Red Hat repositories when using a centos
    image or Red Hat Enterprise Linux. Ansible will of course work on any Linux-based
    operating system as is still available as a PyPi package that can be installed
    on Ubuntu.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a network operator is looking for a start point and not well-versed in coding,
    they could look for examples on Ansible Galaxy, which hosts open source community
    roles that carry out many complex commands.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer can navigate to the Ansible Galaxy repository at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Ansible Galaxy houses thousands of Ansible roles that have been developed by
    the Open Source community.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Some available examples of networking roles are the Arista EOS role that can
    be used to automate Arista switch devices. Alternately, the Cisco EVPN VXLAN Spine
    role can be used to build Spine switches on Cisco devices or the Juniper Junos
    role can be used to automate Juniper network devices. So there is a wide variety
    of modules for a variety of technologies and use cases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following useful links:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Arista EOS ([https://galaxy.ansible.com/arista/eos-system/](https://galaxy.ansible.com/arista/eos-system/))
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco ([https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/](https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/))
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper ([https://galaxy.ansible.com/Juniper/junos/](https://galaxy.ansible.com/Juniper/junos/))
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Users can browse roles and search for a particular networking vendor. In this
    example, a search for Arista has returned the **eos** role, as shown in the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_14.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Each role returned has a link to their corresponding GitHub repository:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible Galaxy](img/5559_04_15.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Ansible Galaxy is a very useful tool, where users can take roles as a start
    point and customize them to meet their needs. Rather than just taking from the
    community, any new roles that may be of use to others should be contributed back
    to the Ansible community.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Ansible core modules available for network operations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the release of Ansible 2.0, the Ansible configuration management tool
    been packaged with some of the core networking modules from Arista, Citrix, Cumulus,
    and Juniper. Ansible can be used to edit configuration for any network device.
    It isn't restricted to just these modules. Ansible Galaxy has a wide range of
    roles that have been developed by the open source community.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'A subnet of the Ansible 2.x networking modules can be shown in the following
    screenshot focusing upon the Juniper **Junos**, Arista **Eos**, Cisco **Nxos**,
    and **Ios**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible core modules available for network operations](img/5559_04_16.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Ansible 2.x has sought to simplify networking modules by giving them a standard
    set of operations across all modules to make it feel more intuitive to network
    engineers. As many network engineers are not familiar with configuration management
    tooling, having a set of standards across modules simplifies the initial barrier
    to entry. As network engineers are able to see commands that they would utilize
    everyday being used as part of a playbook or a role, so Ansible can initially
    be utilized as a scheduling tool, before network operators delve into more complex
    modules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: One of the main fears network engineers have when first using configuration
    management tooling is not trusting the system or understanding what is going on
    under the covers. So, being able to easily read playbooks or roles and see the
    operations that are being executed builds confidence in the tooling and makes
    adoption easier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: It is fully expected that more complex networking modules will be built out
    over time by the open source community some of which are already available with
    roles from Arista, Juniper, and Cisco available in Ansible Galaxy. However, the
    following Ansible core modules have been standardized to allow configuration of
    Arista, Cisco, and Juniper network devices in the same way. These modules can
    be used in any playbook or role.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The _command module
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main module packaged with a vendor's networking modules in Ansible 2.x is
    the `_command` module. This is a conscious choice by Ansible as it is more intuitive
    to network engineers initially to use native network commands when switching to
    configuration management tooling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This module allows Ansible to connect to hosts using SSH as network device's
    operating systems are primarily Linux-based operating systems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The `_command` module allows network operators to apply configuration changes
    to switches by connecting from the Ansible Control Host. The syntax used by Ansible
    on this command is identical to what network operators would execute on network
    devices using CLI.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the EOS command `show ip bgp summary` is executed
    by the `eos_command`, and it connects to every specified `{{ inventory_hostname
    }}`, which is a special Ansible variable that substitutes the DNS name of every
    node listed in the host group specified in the inventory file. It then registers
    the output of the command in the `eos_command_output` variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![The _command module](img/5559_04_17.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Junos syntax is identical. In the following example, a similar network command
    executed on Junos to show interfaces with the JSON output captures in the `junos_command_output`
    variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![The _command module](img/5559_04_18.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'The Cisco example shows Nxos, but the configuration is also the same in IOS.
    The `nxos_command` command issues a `show version` command and places the result
    in the `nxos_command_output` variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![The _command module](img/5559_04_19.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: The _config module
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_config` module is used to configure updates in a deterministic way that
    could be used to implement change requests, by batching up a number of commands.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This module allows operators to update selected lines or blocks of running configuration
    programmatically on the network device. The module will connect to the device,
    extracting the running configuration before pushing batch updates in a completely
    deterministic way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the Arista switches configuration will be loaded by
    the module. The `no spanning-tree vlan 4094` command will be executed on the EOS
    operating system if the running configuration doesn't match the existing state,
    so the desired end state will be implemented on the switch.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![The _config module](img/5559_04_20.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: The _template module
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_template` module is used to update configuration utilizing a jinja2 template
    file. This can be extracted from the running configuration of a network device,
    updated and then pushed back to the device.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Another use case for the `_template` module would be allowing network administrators
    to extract the running config into a jinja2 template from one network device and
    apply it to other's switches to propagate the same changes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `_template` module will only push incremental changes unless the force command
    is specified as a command-line variable, which will carry out overwrite.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the `eos_config` jinja2 template is pushed to the
    Arista device and will do an incremental change to the configuration if the jinja2
    template has configuration changes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![The _template module](img/5559_04_21.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Configuration management processes to manage network devices
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is primarily all about people and process, so just focusing on some examples
    of playbooks or roles in isolation against a switch or firewall wouldn't help
    network engineer deal with the real-world networking challenges that they encounter
    every day. Selecting the correct tooling to facilitate processes is also important
    after the actual goals of a project have been established. Tooling should be selected
    after the business requirements have been made clear and not the opposite way
    round.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: A network engineer could easily type in those commands into a network operating
    system as they could type commands into an Ansible playbook, so it is important
    to look at where the use of a configuration management tool such as Ansible adds
    real business value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a new tool in isolation doesn't really help the network teams improve
    efficiency as a standalone activity, but the modules that have been created in
    Ansible to manage Arista, Juniper, and Cisco are facilitators of process that
    help simplify and standardize processes and approaches. However, it really is
    the process that wraps and utilizes these modules that is the key differentiator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible can be used to help with network operations in many ways, but it is
    good to try and categorize tasks into the following categories:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Desired state
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change requests
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-service operations
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desired state
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A day one set of playbooks should be used to set the desired state of the network,
    utilizing a set of roles and modules to build out brand new network devices and
    are and control the network's intended state. An example of a day one playbook
    could be the first time a network engineer needs to configure a Leaf-Spine architecture
    utilizing Arista Leaf and Spine switches, which can seem a pretty daunting activity
    at first. But the beauty is that the state of the whole underlay network could
    be described in Ansible, but the same can be said for a firewall or any other
    device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Leaf-Spine network, activities will include configuring multiple
    Leaf and Spine switches, so creating a set of roles to abstract the common operations
    and calling them from a playbook is desirable, as the same configuration will
    need to be carried out on multiple servers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: A network engineer will begin by setting up the Ansible Control Host as covered
    in the Ansible prerequisites section. They will then create their inventory file
    for the Leaf-Spine architecture to configure the network devices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The network engineer should define the inventory for all the network devices
    they plan to configure. In the following example, we see two host groups containing
    two `spine` switches and four `leaf` switches:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: The network operator will also need to specify the playbook containing the roles
    that they wish to execute in the `spine.yml` playbook, as shown in the following
    screenshot, to first build out the Spine switches with the desired configuration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example playbook, we see that the playbook targets the Spine
    host group and executes `common`, `interfaces`, `bridging`, `ipv4`, and `bgp`
    roles against the servers:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_23.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'The executed roles carry out the following configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**common role**: This role is used to configure the IP routing table on the
    Spine'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interfaces role**: This role is used to configure interfaces on the Spine'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bridging role**: This role is used to configure all necessary VLANs and switch
    ports on the Spine'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipv4 role**: This role is used to configure the Spine''s IP interfaces'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bgp role**: This role is used to configure BGP protocol to allow the switches
    to be meshed together'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these reusable roles combined will be used to configure the Arista Spine
    switches and utilize the `eos_command` module heavily.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a lot of the same modules can be utilized to configure the Leaf
    switches in the `leaf.yml` playbook, which targets the Leaf host group in the
    inventory and executes `common`, `interfaces`, `bridging`, `ipv4`, `bgp`, `ecmp`,
    and `mlag` roles, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_24.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'The executed roles are used to carry out the following configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**common role**: This role is used to configure the IP routing table on the
    Spine'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interfaces role**: This is used to configure interfaces on the Spine'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridging role**: This is used to configure all necessary VLANs and switch
    ports on the Spine'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipv4 role**: This role is used to configure the Spine''s IP interfaces'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bgp**: This is used to configure BGP protocol to allow the switches to be
    meshed together'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecmp**: This is used to ensure equal cost multipathing is configured in the
    Leaf-Spine topology'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mlag**: This is used to configure the switches redundantly at the top of
    the rack using mlag'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shows that roles can be reused if they are kept granular enough, with `var`
    files providing the necessary configuration changes to the roles, so it is important
    to avoid any hardcoded values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The Leaf-Spine build out is a day one playbook, but why should a network engineer
    be interesting in taking all this time to set this up when it will only be used
    once? This, of course, is a common misconception as playbooks and roles have described
    the whole desired state of the network, and once the initial roles are written,
    going forward they can be used to mutate the desired state of the network at any
    point in the future.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible playbooks and roles could also be used to build the second data
    center in the same way, used as a disaster recovery solution, help to mutate the
    state if a data center re-IP is required, or even scale out more Spine and Leaf
    switches in the data center.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Taking the last example, in terms of scaling out a data center, this would be
    as simple as adding more Spine or Leaf switches to the Ansible inventory. Once
    the additional Arista switches have been zero touch provisioned after being racked
    and cabled by a data center operations team.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The network operator would then only need to make a small update to the `var`
    files to specify the VLANs that need to be used and update the inventory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the infrastructure is scaled to 15 Spine switches
    and 44 Leaf switches by modifying the inventory file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Desired state](img/5559_04_25.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Although this is a pretty extreme scale out example, it should highlight the
    point and benefits of investing in automation. As such a scale out would take
    a network engineer weeks, whereas Ansible can carry out the same operations in
    minutes once the initial roles have been built out.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: It really is worth the investment, this also means that the switches are built
    out consistently the same way as all the other switches, which alleviates manual
    error and makes the delivery of network changes more precise. Some people believe
    that automation is all about pace, but in networking, it should really be about
    consistency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The same `spine.yml` and `leaf.yml` playbooks could also be executed against
    existing switches during the scale out, as Ansible is idempotent by nature, meaning
    only state changes will be pushed to the switches if the configuration has changed.
    If roles are not idempotent, then the modules being called are at fault.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This idempotency means the same day one playbook forming a `site.yml` that calls
    both `spine.yml` and `leaf.yml` could be run over existing switches and not change
    any configuration and be re-used without having to target just the changed switches.
    It is important to note that all Ansible changes should be tested against a test
    environment before being run in production.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Change requests
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network engineers despite this automation still need a separate process for
    manual change requests, right? The simple answer is no, manual changes would break
    the desired state that has been described in the day one playbooks. All network
    changes going forward should be pushed through the same configuration mechanism;
    there should be no such thing as a separate stream of work or an ad hoc command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Making changes outside the process will only serve to break the Ansible playbooks
    and roles that were used to maintain the desired state and break the automation.
    It is important to note that utilizing network automation is an all or nothing
    approach that needs to be adopted by all team members and no changes should be
    done outside of the process or it breaks the model of repeatability and reliable
    changes. If features are lacking, the day one playbooks should be extended to
    incorporate the changes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Self-service operations
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of Ansible for network operations, one of the typical bottle necks
    is the reluctance for network engineers to give development teams access to carry
    out network changes themselves, so this places a bottle neck on networking teams
    as usually a company will have more developers than network engineers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: This reluctance is because network changes are traditionally complex and a developer's
    forte is to develop code and create applications, not log onto networking devices
    to make firewall changes for their application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: However, if network engineers created a self-service playbook that defined a
    safe set of workflow actions, then developers could use it to interface with network
    devices in a safe way, this opens up a whole world of opportunity to remove that
    bottleneck.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This puts network engineers in the position of a **subject matter expert** (**SME**)
    role to help architect and use their network experience to create network automation
    that embodies networking best practices, to serve the needs of development teams.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This is instead of network engineers carrying out manual actions such as opening
    firewall ports manually when a developer raises a ticket. It is of course a change
    in role, but an automated approach is the way the industry is evolving.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Take the example of a firewall request, a development team have created a new
    application and need a test environment to deploy it in. When configuring the
    test environment, it needs networking, and a network engineer will ask the developer
    the ports they need to open in the firewall.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The developer doesn't know how to answer this question yet as they haven't finalized
    the application and want to start incrementally developing it in the test environment.
    Therefore, each time a new port needs to be opened, it means that a new network
    ticket is required to open the incremental port the development team discovers.
    This is not the optimum use of the network engineer or the developer's time as
    it causes frustration on both sides. A network engineer's time is better spent
    optimizing the network or adding improved alerting, not processing tickets to
    open firewall ports.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Instead Ansible could be used to create a self-service file. A developer could
    create a jinja2 template that could be checked into source control that lists
    the configuration file used to make firewall changes using the `template:` module.
    This shows the existing firewall line items and is available to developers to
    add new line items and submit a pull request to open a port on the firewall.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer then reviews the change and approves or rejects it. Ansible
    upon approval can be automatically triggered to push the change to a test environment;
    this makes sure that the config is valid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we see the playbook that replaces the `firewall.config`
    file with the updated jinja2 `firewall.j2` template and then reloads the firewall
    configuration from the new template:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Self-service operations](img/5559_04_26.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: This allows network teams to enable a self-service model. This speeds up the
    pace of network changes. It also removes the networking team as the bottleneck
    and pushes them to create appropriate tests and controls for network changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Self-service doesn't mean network engineers are no longer required. This means
    that they become the gatekeepers of the process instead of constantly rushing
    to keep up with the never ending chain of ad hoc requests they receive on a daily
    basis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how Ansible can be used for server-side configuration
    management of network devices and looked at some of the industry leading network
    vendors, such as Arista, Cisco, and Juniper, who have all changed their operational
    models to use open standards and protocols that are well-suited to automation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should now be familiar with networking operating
    system from Cisco, Juniper, and Arista. The Ansible configuration management tool
    and concepts, such as Ansible Inventory, Ansible Modules, Ansible Playbooks, Ansible
    Roles, and Ansible var files and Jinja2 templates. Readers should also be familiar
    with Ansible Galaxy, the core Ansible modules available for network automation
    and methodologies to manage network devices using Ansible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gave readers an understanding of use cases where tools such as
    Ansible can be used to automate everyday network operations that are carried out
    by network engineers. It should also give readers an insight into ways they could
    improve their network automation by utilizing configuration management tooling.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaways from this chapter are that configuration management tools
    such as Ansible now support network operations natively and vendors, such as Cisco,
    Juniper, and Arista, have created modules to facilitate automation of network
    operations. There is now no reason not to start automating network operations
    as these methods are fully supported by leading network vendors who understand
    that SDN operations are the future of network operations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We have witnessed that Ansible is a very flexible tool. One of its main strengths
    is its ability to orchestrate APIs and help schedule software releases. Load balancing
    applications is a fundamental component of the software development release process,
    so in the the following chapter we will look at configuration management principles
    that can help orchestrate load balancers and help networking teams easily maintain
    complex load balancing solutions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Useful links for Ansible network automation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=7FphWEFQbac](https://www.youtube.com/watch?v=7FphWEFQbac)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=VYEVjKvMKqU](https://www.youtube.com/watch?v=VYEVjKvMKqU)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Cisco:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pynet.twb-tech.com/blog/automation/cisco-ios.html](https://pynet.twb-tech.com/blog/automation/cisco-ios.html)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html](http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Juniper:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html](https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf](http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful links for Arista:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arista.com/en/products/eos/automation](https://www.arista.com/en/products/eos/automation)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arista.com/docs/Manuals/ConfigGuide.pdf](https://www.arista.com/docs/Manuals/ConfigGuide.pdf)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
