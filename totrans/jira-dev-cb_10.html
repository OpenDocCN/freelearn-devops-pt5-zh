<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Dealing with a Database</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extending JIRA DB with custom schema</li><li class="listitem" style="list-style-type: disc">Accessing DB entities from plugins</li><li class="listitem" style="list-style-type: disc">Persisting plugin information in JIRA DB</li><li class="listitem" style="list-style-type: disc">Using Active Objects to store data</li><li class="listitem" style="list-style-type: disc">Accessing JIRA configuration properties</li><li class="listitem" style="list-style-type: disc">Getting database connection for JDBC calls</li><li class="listitem" style="list-style-type: disc">Migrating a custom field from one type to another</li><li class="listitem" style="list-style-type: disc">Retrieving issue information from a database</li><li class="listitem" style="list-style-type: disc">Retrieving custom field details from a database</li><li class="listitem" style="list-style-type: disc">Retrieving permissions on issues from a database</li><li class="listitem" style="list-style-type: disc">Retrieving workflow details from a database</li><li class="listitem" style="list-style-type: disc">Updating issue status in a database</li><li class="listitem" style="list-style-type: disc">Retrieving users and groups from a database</li><li class="listitem" style="list-style-type: disc">Dealing with Change history in a database</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec123"/>Introduction</h1></div></div></div><p>We have already seen in <a class="link" href="ch02.html" title="Chapter 2. Understanding Plugin Framework">Chapter 2</a>, <em>Understanding</em> <em>Plugin</em> <em>Framework</em>, that JIRA uses the Ofbiz suite's Entity Engine module to deal with database operations.</p><p>OfBiz<a id="id1750" class="indexterm"/> stands for Open For Business and the<a id="id1751" class="indexterm"/> OfBiz Entity Engine is a set of tools and patterns used to model and manage entity-specific data.</p><p>As per the definition from the standard entity-relationship modeling concepts of RDBMS<a id="id1752" class="indexterm"/>, an entity<a id="id1753" class="indexterm"/> is a piece of data defined by a set of fields<a id="id1754" class="indexterm"/> and a set of relations<a id="id1755" class="indexterm"/> to other entities.</p><a id="id1756" class="indexterm"/><p>In JIRA, these entities are defined in two files,<a id="id1757" class="indexterm"/> <code class="literal">entitygroup.xml</code> and <code class="literal">entitymodel.xml</code><a id="id1758" class="indexterm"/>, both residing in the <code class="literal">WEB-INF/classes/entitydefs</code> folder. <code class="literal">entitygroup.xml</code> stores the entity names for a previously-defined group. If you look at the file, you will see that, the default group in JIRA is named <code class="literal">default</code>; you will find the same defined in the entity configuration file, which we will see in a moment. <code class="literal">entitymodel.xml</code> holds the actual entity definitions, details of which we will see in the recipes.</p><p>The entity configuration is defined in <code class="literal">entityengine.xml</code>, residing in the <code class="literal">WEB-INF/classes</code> folder. It is in this file that the <code class="literal">datasource</code>, transaction factory, and so on, are defined. The content of this file varies based on the database that we use and the application server. For example, the <code class="literal">datasource</code> definition will be as follows, when the database is MySQL and application server is <code class="literal">tomcat</code>:</p><div><pre class="programlisting">&lt;datasource add-missing-on-start="true" check-fk-indices-on-start="false" check-fks-on-start="false" check-indices-on-start="true" check-on-start="true" field-type-name="mysql" helper-class="org.ofbiz.core.entity.GenericHelperDAO" name="defaultDS" use-foreign-key-indices="false" use-foreign-keys="false"&gt;
        &lt;jndi-jdbc jndi-name="java:comp/env/jdbc/JiraDS" jndi-server-name="default"/&gt;
&lt;/datasource&gt;</pre></div><p>More about connecting to various other databases can be read at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Connecting+JIRA+to+a+Database">http://confluence.atlassian.com/display/JIRA/Connecting+JIRA+to+a+Database</a>.</p><p>For other application servers, the <code class="literal">jndi-server</code> attribute<a id="id1759" class="indexterm"/> in the <code class="literal">jndi-jdbc</code> element<a id="id1760" class="indexterm"/> varies, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Orion format<a id="id1761" class="indexterm"/>: &lt;jndi-jdbc jndi-server-name="default" jndi-name="jdbc/JiraDS"/&gt;</li><li class="listitem" style="list-style-type: disc">JBoss format<a id="id1762" class="indexterm"/>: &lt;jndi-jdbc jndi-server-name="default" jndi-name="java:/JiraDS"/&gt;</li><li class="listitem" style="list-style-type: disc">Weblogic format:<a id="id1763" class="indexterm"/> &lt;jndi-jdbc jndi-server-name="default" jndi-name="JiraDS"/&gt;</li></ul></div><p>The <a id="id1764" class="indexterm"/>
<code class="literal">transaction-factory</code> tag is defined as follows:</p><div><pre class="programlisting">&lt;transaction-factory class="org.ofbiz.core.entity.transaction.JNDIFactory"&gt;
      &lt;user-transaction-jndi jndi-name="java:comp/env/UserTransaction" jndi-server-name="default"/&gt;
      &lt;transaction-manager-jndi jndi-name="java:comp/env/UserTransaction" jndi-server-name="default"/&gt;
 &lt;/transaction-factory&gt;</pre></div><a id="id1765" class="indexterm"/><p>The entity definition XMLs are referenced in the file using the <code class="literal">entity-group-reader</code> and <code class="literal">entity-model-reader</code> attributes that point to <code class="literal">entitygroup.xml</code> and <code class="literal">entitymodel.xml</code>, respectively.</p><div><pre class="programlisting">&lt;entity-model-reader name="main"&gt;
&lt;resource loader="maincp" location="entitydefs/entitymodel.xml"/&gt;
&lt;/entity-model-reader&gt;
&lt;entity-group-reader name="main" loader="maincp" location="entitydefs/entitygroup.xml"/&gt;</pre></div><p>The delegator element is also defined in this file, as follows:</p><div><pre class="programlisting">&lt;delegator entity-group-reader="main" entity-model-reader="main" name="default"&gt;
        &lt;group-map datasource-name="defaultDS" group-name="default"/&gt;
&lt;/delegator&gt;</pre></div><p>The field type mapping XMLs for different databases are also defined in this file. An example of this is:</p><div><pre class="programlisting">&lt;field-type loader="maincp" location="entitydefs/fieldtype-mysql.xml" name="mysql"/&gt;</pre></div><p>Read more about configuring <code class="literal">entityengine.xml</code> at <a class="ulink" href="http://www.atlassian.com/software/jira/docs/latest/entityengine.html">http://www.atlassian.com/software/jira/docs/latest/entityengine.html</a> and about entity modeling concepts at <a class="ulink" href="http://ofbiz.apache.org/docs/entity.html">http://ofbiz.apache.org/docs/entity.html</a>.</p><p>In the recipe, <em>Extending</em> <em>JIRA</em> <em>DB</em> <em>with</em> <em>custom</em> <em>schema</em>, we will also see glimpses of the JIRA database architecture, which is also explained in detail at <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Database+Schema">http://confluence.atlassian.com/display/JIRADEV/Database+Schema</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec124"/>Extending JIRA DB with custom schema</h1></div></div></div><a id="id1766" class="indexterm"/><a id="id1767" class="indexterm"/><p>Now that we know that JIRA scheme definitions are maintained in <code class="literal">WEB-INF/classes/entitydefs/entitygroup.xml</code> and <code class="literal">entitymodel.xml</code>, let us have a look at extending the existing scheme definitions. How would you extend the JIRA scheme if you want to add one or two custom tables into JIRA? Is it just about creating the new tables in our database? We will see that in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec340"/>How to do it...</h2></div></div></div><p>JIRA uses the schema definitions<a id="id1768" class="indexterm"/> entered in the <code class="literal">WEB-INF/classes/entitydefs/entitygroup.xml</code> and <code class="literal">entitymodel.xml</code> files. It makes use of these files not only to validate and create the schema but also during import and export of the JIRA Data backup. JIRA also uses these entity definitions to read and write to a database, using OfBizDelegator<a id="id1769" class="indexterm"/> (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html</a>), details of which we will see in the upcoming recipes.</p><p>The following are quick steps to add a new table into the JIRA schema. Let us assume we are adding a table to hold the details of an employee.</p><div><ol class="orderedlist arabic"><li class="listitem">Identify an entity name for the table. This could be the same as the table name or different from it. This name will be used in the XML backups and also by the OfBizDelegator to read or write data.<p>In our example, let us choose <code class="literal">Employee</code> as the entity name.</p></li><li class="listitem">Modify the <code class="literal">WEB-INF/classes/entitydefs/entitygroup.xml</code> file to include the new entity group definition:<div><pre class="programlisting">&lt;entity-group group="default" entity="Employee"/&gt;</pre></div><p>Here, the <code class="literal">group</code> attribute<a id="id1770" class="indexterm"/> refers to the group name the delegator is associated with. You can find it in the <code class="literal">WEB-INF/classes/entityengine.xml</code>, as shown:</p><div><pre class="programlisting">&lt;delegator name="default" entity-model-reader="main" entity-group-reader="main"&gt;&lt;group-map group-name="default" datasource-name="defaultDS"/&gt;&lt;/delegator&gt;</pre></div><p>The <code class="literal">entity</code> attribute<a id="id1771" class="indexterm"/> holds the name of the entity.</p></li><li class="listitem"><a id="id1772" class="indexterm"/><a id="id1773" class="indexterm"/>Modify the <code class="literal">WEB-INF/classes/entitydefs/entitymodel.xml</code> file to include the new entity definition:<div><pre class="programlisting">&lt;entity entity-name="Employee" table-name="employee" package-name=""&gt;
  &lt;field name="id" type="numeric"/&gt;
  &lt;field name="name" type="long-varchar"/&gt;
  &lt;field name="address" col-name="empaddress" type="long-varchar"/&gt;
  &lt;field name="company" type="long-varchar"/&gt;

  &lt;prim-key field="id"/&gt;
  &lt;index name="emp_entity_name"&gt;
    &lt;index-field name="name"/&gt;
  &lt;/index&gt;
&lt;/entity&gt;</pre></div><p>Here, the <code class="literal">entity-name</code> attribute<a id="id1774" class="indexterm"/> holds the name of the entity we have used in <em>Step</em> <em>2. </em>The <code class="literal">table-name</code> holds the name of the table; it is optional and will be derived from <code class="literal">entity-name</code>, if not present. <code class="literal">package-name</code> can be used if you want to organize and structure the entities' definitions into different packages.</p><a id="id1775" class="indexterm"/><p>The <code class="literal">entity</code> element contains one field element for each column in the table that needs to be created. The <code class="literal">field</code> element has a <code class="literal">name</code> attribute that holds the name of the field. If the column name of the field is different, the <code class="literal">col-name</code> attribute can be used, as in the case with employee address. If <code class="literal">col-name</code> is missing, the name of the field is used. The next important attribute is <code class="literal">type</code>. In our example, <code class="literal">id</code> is <code class="literal">numeric</code> whereas <code class="literal">name</code> and <code class="literal">address</code> are <code class="literal">long-varchar</code>.</p><p>These type definitions of a field are mapped to the appropriate column type for each database type. The <code class="literal">field-type</code> mappings are stored under <code class="literal">WEB-INF/classes/entitydefs/</code> and is declared in <code class="literal">entityengine.xml</code>, as shown next:</p><div><pre class="programlisting">&lt;field-type name="oracle10g" loader="maincp" location="entitydefs/fieldtype-oracle10g.xml"/&gt;</pre></div><p>If you look inside <code class="literal">fieldtype-oracle10g.xml</code>, you will notice that <code class="literal">numeric</code> is mapped to <code class="literal">NUMBER(18,0)</code> and <code class="literal">long-varchar</code> is mapped to <code class="literal">VARCHAR2(255)</code>. You can find out the various mappings and even the related Java data type from the same file.</p><a id="id1776" class="indexterm"/><a id="id1777" class="indexterm"/><p>The <code class="literal">prim-key</code> element is used to define the primary key constraint for the table, as shown previously. In our case, <code class="literal">id</code> is the primary key. It is mandatory to name the primary key as <code class="literal">id</code> for all the new tables we are creating.</p><p>The<a id="id1778" class="indexterm"/> <code class="literal">index</code> element creates a DB index for the field specified for that table. We can specify the index name and the group of the fields that needs to be indexed underneath it.</p><p>You can also define the relationship between entities using the element <code class="literal">relation</code>  as shown next:</p><div><pre class="programlisting">&lt;relation type="one" title="Parent" rel-entity-name="Company"&gt;
  &lt;key-map field-name="company" rel-field-name="id"/&gt;
&lt;/relation&gt;</pre></div><p>Here, we are adding a relationship between the <code class="literal">Employee</code> entity and <code class="literal">Company</code> entity by saying an employee can have only one company. In the above case, <code class="literal">Employee</code> should have a field <code class="literal">company</code> that points to the <code class="literal">id</code> field of a company's record. In other words, the <code class="literal">company</code> field in an employee's record will be the foreign key to the company's record.</p><p>More details of entity definition can be found at <a class="ulink" href="http://ofbiz.apache.org/docs/entity.html#Entity_Modeling">http://ofbiz.apache.org/docs/entity.html#Entity_Modeling</a>.</p></li><li class="listitem">Restart JIRA after the changes are made.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec341"/>How it works...</h2></div></div></div><a id="id1779" class="indexterm"/><a id="id1780" class="indexterm"/><p>When JIRA is restarted with the previous changes, you will notice that a warning message appear in the logs during startup, as shown next:</p><div><img src="img/1803-10-01.jpg" alt="How it works..."/></div><p>Once JIRA recognizes that there is no table corresponding to the new entity name <strong>employee</strong> in the database; it will create one, as shown:</p><div><img src="img/1803-10-02.jpg" alt="How it works..."/></div><p>Even the index information is stored, as shown:</p><div><img src="img/1803-10-03.jpg" alt="How it works..."/></div><p>If you want to add a new column to an existing table, you can add a field definition, as we saw earlier and, on restarting JIRA, the table will be updated to include the column.</p><p>You will notice an error message in the JIRA logs if the database has a table, or a column in the table, that doesn't have a valid entity or field definition in the <code class="literal">entitymodel.xml</code>.</p><a id="id1781" class="indexterm"/><a id="id1782" class="indexterm"/><p>Care must be taken to update the <code class="literal">entitygroup.xml</code> and <code class="literal">entitymodel.xml</code> files when JIRA is upgraded or else the changes will be lost.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec125"/>Accessing DB entities from plugins</h1></div></div></div><a id="id1783" class="indexterm"/><a id="id1784" class="indexterm"/><a id="id1785" class="indexterm"/><p>We have seen how the various entities in the JIRA database are defined and how we can introduce new entities. In this recipe, we will see how we can read and write data from the database using these entity definitions.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec342"/>How to do it...</h2></div></div></div><p>JIRA exposes the OfBizDelegator<a id="id1786" class="indexterm"/> (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html</a>) component, which is a wrapper around <code class="literal">org.ofbiz.core.entity.DelegatorInterface</code>, to communicate with its database using the Ofbiz layer.</p><p>You can get hold of an instance of <code class="literal">OfBizDelegator</code> by injecting it in the constructor or from <code class="literal">ComponentManager</code>, as follows:</p><div><pre class="programlisting">OfBizDelegator delegator = ComponentManager.getInstance().getComponentInstanceOfType(OfBizDelegator.class);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec343"/>Reading from a database</h2></div></div></div><a id="id1787" class="indexterm"/><a id="id1788" class="indexterm"/><p>We can read from the database using the various methods exposed via the above delegator class. For example, all the records in the employee table we defined in the previous recipe can be read as:</p><div><pre class="programlisting">List&lt;GenericValue&gt; employees = delegator.findAll("Employee");</pre></div><p>Here, the <code class="literal">findAll</code> method<a id="id1789" class="indexterm"/> takes the entity name (not the table name) and returns a list of <code class="literal">GenericValue</code> objects, each representing a row in the table. The individual fields can be read from the object using the name of the field (not <code class="literal">col-name</code>), as follows:</p><div><pre class="programlisting">Long id = employees.get(0).getLong("id");
String name = employees.get(0).getString("name");</pre></div><p>The data type to which the field should be converted can be found from the <code class="literal">field-type</code> mapping XML we saw in the previous recipe.</p><a id="id1790" class="indexterm"/><a id="id1791" class="indexterm"/><p>We can read data from a database, when certain conditions are satisfied, using the <code class="literal">findByAnd</code> method<a id="id1792" class="indexterm"/>:</p><div><pre class="programlisting">List&lt;GenericValue&gt; employees = delegator.findByAnd("Employee", EasyMap.build("company","J-Tricks"));</pre></div><p>This will return all the records where company name is <code class="literal">J-Tricks</code>. You can enforce more complex conditions using the <code class="literal">findByCondition</code> method<a id="id1793" class="indexterm"/> and select only the interested fields, as follows:</p><div><pre class="programlisting">List&lt;GenericValue&gt; employees = this.delegator.findByCondition("Employee", new EntityExpr("id",EntityOperator.GREATER_THAN,"15000"), EasyList.build("id","name"));</pre></div><p>Here, we find all employee records with ID greater than <code class="literal">15000 </code>and we retrieve only the ID and name of the employees.</p><p><code class="literal">findListIteratorByCondition</code> (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html#findListIteratorByCondition%28java.lang.String,%20org.ofbiz.core.entity.EntityCondition,%20org.ofbiz.core.entity.EntityCondition,%20java.util.Collection,%20java.util.List,%20org.ofbiz.core.entity.EntityFindOptions%29">http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html#findListIteratorByCondition%28java.lang.String,%20org.ofbiz.core.entity.EntityCondition,%20org.ofbiz.core.entity.EntityCondition,%20java.util.Collection,%20java.util.List,%20org.ofbiz.core.entity.EntityFindOptions%29</a>)</p><p>This method can be used to add more options like the <code class="literal">orderBy</code> clause<a id="id1794" class="indexterm"/>, <code class="literal">EntityFindOptions</code>, <code class="literal">where</code> conditions<a id="id1795" class="indexterm"/>, <code class="literal">having</code> conditions<a id="id1796" class="indexterm"/>, and so on, as follows:</p><div><pre class="programlisting">OfBizListIterator iterator = this.delegator.findListIteratorByCondition("Employee", new EntityExpr("id",EntityOperator.GREATER_THAN,"15000"), null, UtilMisc.toList("name"), UtilMisc.toList("name"), new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, true));
List&lt;GenericValue&gt; employees = iterator.getCompleteList();
iterator.close();</pre></div><p>Here, we search for all records with the ID greater than <code class="literal">15000</code>. We don't have a <code class="literal">having</code> condition in this case and, so, we will leave it null. The next two arguments specify that only the <code class="literal">name</code> field needs to be selected and the records should be ordered by the <code class="literal">name</code> field. The last argument specifies the <code class="literal">EntityFindOptions</code>. Here, we define the EntityFindOptions with four arguments including <code class="literal">TYPE_SCROLL_INSENSTITVE</code> and <code class="literal">CONCUR_READ_ONLY</code>. The first true is for <code class="literal">specifyTypeAndConcur</code> and the last true is for distinct select.</p><p>If <code class="literal">specifyTypeAndConcur</code> is true, the following two parameters will be used to specify <code class="literal">resultSetType</code> and <code class="literal">resultSetConcurrency</code>. If false, the default values of the JDBC driver will be used. In the above case, <code class="literal">specifyTypeAndConcur</code> is true and, hence, <code class="literal">resultSetType</code> is taken as <code class="literal">TYPE_SCROLL_INSENSITIVE</code> and <code class="literal">resultSetConcurrency</code> is taken as <code class="literal">CONCUR_READ_ONLY</code>. More about this and the possible values can be found at <a class="ulink" href="http://download.oracle.com/javase/tutorial/jdbc/basics/retrieving.html">http://download.oracle.com/javase/tutorial/jdbc/basics/retrieving.html</a>.</p><a id="id1797" class="indexterm"/><a id="id1798" class="indexterm"/><p>As discussed before, the last true in the <code class="literal">EntityFindOptions</code> constructor is for selecting distinct values. Apparently, this is the only way to do a distinct select using Entity Engine. You will find more information about this in the entity engine cookbook at <a class="ulink" href="http://www.opensourcestrategies.com/ofbiz/ofbiz_entity_cookbook.txt">http://www.opensourcestrategies.com/ofbiz/ofbiz_entity_cookbook.txt</a>.</p><p>Don't forget to close the iterator, as shown in the previous code snippet.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec61"/>Writing a new record</h3></div></div></div><a id="id1799" class="indexterm"/><a id="id1800" class="indexterm"/><p>Creating a new record in a table using OfBizDelegator is pretty easy, as shown next:</p><div><pre class="programlisting">GenericValue newEmployee = this.delegator.createValue("Employee",EasyMap.build("name","Some Guy", "address","Some Address", "company","J-Tricks"));</pre></div><p>Make sure you don't provide the ID, as it is automatically generated. Also, the missing fields in the map will be set to <code class="literal">null</code>. Data for all the mandatory fields should be provided so as to avoid errors.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec62"/>Updating a record</h3></div></div></div><a id="id1801" class="indexterm"/><a id="id1802" class="indexterm"/><p>Writing a record is done by retrieving the record, modifying the values, and using the <code class="literal">store()</code> method<a id="id1803" class="indexterm"/>. For example, we can retrieve a record with ID <code class="literal">12000</code> and modify it, as follows:</p><div><pre class="programlisting">GenericValue employee = delegator.findByAnd("Employee",   EasyMap.build("id","12000")).get(0);
employee.setString("name","New Name");
employee.store();</pre></div><p>More useful methods can be found in the Java docs at <a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/ofbiz/OfBizDelegator.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec126"/>Persisting plugin information in JIRA DB</h1></div></div></div><a id="id1804" class="indexterm"/><a id="id1805" class="indexterm"/><a id="id1806" class="indexterm"/><p>While developing plugins, we come across many scenarios where we need to store specific information about the plugins, be it configuration detail or metadata for entities. How can we do this without creating a custom schema and going through the pain of editing entity definitions? In this recipe, we will how we can make use of JIRA's existing framework to store information specific to the plugins we develop.</p><p>JIRA uses Open symphony's <code class="literal">PropertySet</code> framework<a id="id1807" class="indexterm"/> to store properties in the database. These properties are a set of key/value pairs and are stored against any entity that the user wants. The key of the property is always a String value; the value can be: String, Long, Date, Boolean, or Double. We have already seen how JIRA uses it in <a class="link" href="ch02.html" title="Chapter 2. Understanding Plugin Framework">Chapter 2</a>, <em>Understanding</em> <em>Plugin</em> <em>Framework</em>. In this recipe, we will see we can use <code class="literal">PropertySet</code> to store our custom data.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec344"/>How to do it...</h2></div></div></div><a id="id1808" class="indexterm"/><a id="id1809" class="indexterm"/><a id="id1810" class="indexterm"/><p>Suppose that we need to store a Boolean value in the database as part of our plugin's configuration and read it later; here are the steps to follow to do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Get an instance of <code class="literal">PropertySet</code>, using <code class="literal">PropertiesManager</code>:<div><pre class="programlisting">PropertySet propertySet = PropertiesManager.getInstance().getPropertySet();</pre></div><p>From JIRA 4.3 onwards, the <code class="literal">PropertiesManager.getInstance()</code> method is deprecated. Instead, you can inject the <code class="literal">PropertiesManager</code> into the constructor, using dependency injection, or retrieve it from <code class="literal">ComponentManager</code>, as follows:</p><div><pre class="programlisting">PropetySet propertySet =  ComponentManager.getComponent(PropertiesManager.class).getPropertySet();</pre></div></li><li class="listitem">Persist the Boolean property using the <code class="literal">setBoolean</code> method:<div><pre class="programlisting">propertySet.setBoolean("mt.custom.key1", new Boolean(true));</pre></div><p>Similarly, String, Long, Double, and Date values can be stored using the respective methods.</p></li><li class="listitem">The property that is stored can be retrieved at any point, as follows:<div><pre class="programlisting">Boolean key = propertySet.getBoolean("mt.custom.key1");</pre></div></li></ol></div><p>However, how do we store a more complex structure, such as a property, to an existing entity? Let us say we want to store the address of a user. JIRA stores the user information against the entity <code class="literal">OSUser</code>, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Retrieve the ID of the user entity we are going to store the address against. For example, if there is a user <code class="literal">jobinkk</code>, we can find the ID of the user from the <code class="literal">OSUser</code> entity that corresponds to the <code class="literal">userbase</code> table in JIRA. Let us assume the ID is <code class="literal">10032</code>.</li><li class="listitem">Get an instance of <code class="literal">PropertySet</code>, using <code class="literal">PropertySetManager</code>, by passing the details of the entity we got:<div><pre class="programlisting">HashMap entityDetails = new HashMap();
entityDetails.put("delegator.name", "default");
entityDetails.put("entityName", "OSUser");
entityDetails.put("entityId", 10032L);
PropertySet userProperties = PropertySetManager.getInstance("ofbiz", entityDetails);</pre></div><p>Here, we create a map with the entity name, that is, <code class="literal">OSUser</code>, and the ID of the user, that is, <code class="literal">10032</code>. We also pass the delegator name as defined in the <code class="literal">entityengine.xml</code>, under the <code class="literal">WEB-INF/classes</code> folder, which is the default in this case. We then retrieve the <code class="literal">PropertySet</code> instance from <code class="literal">PropertySetManager</code>, using <code class="literal">ofbiz</code> as the key.</p></li><li class="listitem">The values can be set as before, depending on the type of the field. In this case, we will have more than one key for state, country, and so on:<div><pre class="programlisting">userProperties.setString("state", "Kerala");
userProperties.setString("country", "India");</pre></div><p>This will then be stored in the appropriate tables.</p></li><li class="listitem">We can retrieve these values later by creating the <code class="literal">PropertySet</code> in a similar manner and using the getter methods:<div><pre class="programlisting">System.out.println("Address:" + userProperties.getString("state")+", "+userProperties.getString("country"));</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec345"/>How it works...</h2></div></div></div><a id="id1811" class="indexterm"/><a id="id1812" class="indexterm"/><a id="id1813" class="indexterm"/><p>When a property is set using <code class="literal">PropertySet</code> instantiated from <code class="literal">PropertiesManager</code> as we did in the case of the Boolean values, it gets stored in the <strong>propertyentry</strong> table with the <code class="literal">ENTITY_NAME</code> as <strong>jira.properties</strong> and <code class="literal">ENTITY_ID</code> as <strong>1</strong>. It will also have a unique ID, which will then be used to store the value in the <strong>propertynumber</strong>, <strong>propertystring</strong>, <strong>propertytext</strong>, or <strong>propertydate</strong> tables, depending on the data type we used.</p><p>In our case, the <strong>propertyentry</strong> table is populated with values, as shown next:</p><div><img src="img/1803-10-04.jpg" alt="How it works..."/></div><p>The first one is the Boolean property we added whereas the second and third are the user properties.</p><p>Boolean values get stored as numbers (<code class="literal">0</code> or <code class="literal">1</code>) and hence, the <strong>propertyentry</strong> table stores the <strong>propertytype</strong> as <strong>1</strong>, which denotes a number value. There is a corresponding entry in the <strong>propertynumber</strong> table, with ID <strong>11303</strong>, for the Boolean property, as shown:</p><div><img src="img/1803-10-05.jpg" alt="How it works..."/></div><a id="id1814" class="indexterm"/><a id="id1815" class="indexterm"/><a id="id1816" class="indexterm"/><p>In our example, the <strong>Boolean</strong> is set to <strong>true</strong> and, hence, the <strong>propertynumber</strong> stores the value <strong>1</strong>. If set to <code class="literal">false</code>, it will store <strong>0</strong>.</p><p>In the case of address, the entity is <strong>OSUser</strong> and it has an <strong>entityId</strong> of <strong>10032</strong>. We have seen two rows with IDs <strong>11304</strong> and <strong>11305</strong>, each with <strong>propertytype</strong> as <strong>5</strong>, which denotes String values. Because they are String values, they are stored in the <strong>propertystring</strong> table, as shown in the following screenshot:</p><div><img src="img/1803-10-06.jpg" alt="How it works..."/></div><p>Hopefully, this gives a fair idea about how we can store attributes against an existing entity record.</p><p>The good thing about the usage of <code class="literal">propertySet</code> is that we don't need to create an extra scheme or entity definition and these properties are exported in the backup XML when JIRA data is exported. So, all configurations stored like this will be retained when the <a id="id1817" class="indexterm"/>
<a id="id1818" class="indexterm"/>
<a id="id1819" class="indexterm"/>data is imported back into another JIRA instance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec127"/>Using active objects to store data</h1></div></div></div><a id="id1820" class="indexterm"/><p>Active objects represent a technology recently used by JIRA to allow per-plugin storage. This gives the plugin developers a real protected database where they can store the data belonging to their plugin and which other plugins won't be able to access. In this recipe, we will see how we can store an address entity in the database using active objects.</p><p>You can read more about active objects at <a class="ulink" href="http://java.net/projects/activeobjects/pages/Home">http://java.net/projects/activeobjects/pages/Home</a>.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec346"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec347"/>How to do it...</h2></div></div></div><a id="id1821" class="indexterm"/><a id="id1822" class="indexterm"/><a id="id1823" class="indexterm"/><p>In order to understand it better, let us look at the simple 'address entity' example that we used in the previous recipe. This will also help in an easy comparison with <code class="literal">PropertySet</code>, if desired Follow the ensuing steps to use active objects in the plugin:</p><div><ol class="orderedlist arabic"><li class="listitem">Include the active objects dependency in <code class="literal">pom.xml</code>. Add the appropriate <code class="literal">ao</code> version:<div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;com.atlassian.activeobjects&lt;/groupId&gt;
  &lt;artifactId&gt;activeobjects-plugin&lt;/artifactId&gt;
  &lt;version&gt;${ao.version}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">Include the active objects plugin artifacts, under the <code class="literal">maven-jira-plugin</code> configuration, in the <code class="literal">pom.xml</code> file as shown:<div><pre class="programlisting">&lt;plugin&gt;
 &lt;groupId&gt;com.atlassian.maven.plugins&lt;/groupId&gt;
 &lt;artifactId&gt;maven-jira-plugin&lt;/artifactId&gt;
 &lt;version&gt;3.0.6&lt;/version&gt;
 &lt;extensions&gt;true&lt;/extensions&gt;
 &lt;configuration&gt;
  &lt;pluginArtifacts&gt;
   &lt;pluginArtifact&gt;
    &lt;groupId&gt;com.atlassian.activeobjects&lt;/groupId&gt;
    &lt;artifactId&gt;activeobjects-plugin&lt;/artifactId&gt;
    &lt;version&gt;${ao.version}&lt;/version&gt;
   &lt;/pluginArtifact&gt;
   &lt;pluginArtifact&gt;
    &lt;groupId&gt;com.atlassian.activeobjects&lt;/groupId&gt;
    &lt;artifactId&gt;activeobjects-jira-spi&lt;/artifactId&gt;
    &lt;version&gt;${ao.version}&lt;/version&gt;
   &lt;/pluginArtifact&gt;
  &lt;/pluginArtifacts&gt;
  &lt;productVersion&gt;${jira.version}&lt;/productVersion&gt;
  &lt;productDataVersion&gt;${jira.data.version}&lt;/productDataVersion&gt;
 &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div></li><li class="listitem">Add the active objects plugin module to the Atlassian plugin descriptor:<div><pre class="programlisting">&lt;ao key="ao-module"&gt;
  &lt;description&gt;The configuration of the Active Objects service&lt;/description&gt;
  &lt;entity&gt;com.jtricks.entity.AddressEntity&lt;/entity&gt;
&lt;/ao&gt;</pre></div><p>As you can see, the module has a unique key and it points to an entity we are going to define later, <code class="literal">AddressEntity</code> in this case.</p></li><li class="listitem">Include a component-import plugin to register <code class="literal">ActiveObjects</code> as a component in the <code class="literal">atlassian-plugin.xml</code> previous with the above module:<div><pre class="programlisting">&lt;component-import key="ao" name="Active Objects components" interface="com.atlassian.activeobjects.external.ActiveObjects"&gt;
  &lt;description&gt;Access to the Active Objects service&lt;/description&gt;
&lt;/component-import&gt;</pre></div></li><li class="listitem"><a id="id1824" class="indexterm"/><a id="id1825" class="indexterm"/><a id="id1826" class="indexterm"/>Define the entity to be used for data storage. The entity should be an interface and should extend the <code class="literal">net.java.ao.Entity</code> interface. All we need to do in this entity interface is to define getter and setter methods for the data that we need to store for this entity.<p>For example, we need to store the name, city and country as part of the address entity. In this case, the <code class="literal">AddressEntity</code> interface will look like the following:</p><div><pre class="programlisting">public interface AddressEntity extends Entity{
  public String getName();
  public void setName(String name);

  public String getState();   
  public void setState(String state);

  public String getCountry();
  public void setCountry(String country);
}</pre></div></li></ol></div><p>By doing this, we have setup the entity to facilitate the storage of all the three attributes. We can now create, modify, or delete the data using the <code class="literal">ActiveObjects</code> component. The component can be instantiated by injecting it into the constructor.</p><div><pre class="programlisting">private ActiveObjects ao;

public ManageProperties(ActiveObjects ao) {
  this.ao = ao;
}</pre></div><a id="id1827" class="indexterm"/><a id="id1828" class="indexterm"/><a id="id1829" class="indexterm"/><p>A new row can be added to the database using the following piece of code:</p><div><pre class="programlisting">AddressEntity addressEntity =  ao.create(AddressEntity.class);
addressEntity.setName(name);
addressEntity.setState(state);
addressEntity.setCountry(country);
addressEntity.save();</pre></div><p>Details can be read either using the <code class="literal">id</code>, which is the primary key, or by querying the data using a <code class="literal">net.java.ao.Query</code> object. Using ID is as simple as is shown next:</p><div><pre class="programlisting">AddressEntity addressEntity = ao.get(AddressEntity.class, id);</pre></div><p>The <code class="literal">Query</code> object can be used as follows:</p><div><pre class="programlisting">AddressEntity[] addressEntities = ao.find(AddressEntity.class, Query.select().where("name = ?", name));
for (AddressEntity addressEntity : addressEntities) {
  System.out.println("Name:"+addressEntity.getName()+", State:"+addressEntity.getState()+", Country:"+addressEntity.getCountry());
}</pre></div><p>Here, we are querying for all records with a given name.</p><p>Once you get hold of an entity by either means, we can edit the contents simply by using the setter method:</p><div><pre class="programlisting">addressEntity.setState(newState);
addressEntity.save();</pre></div><p>Deleting is even simpler!</p><div><pre class="programlisting">ao.delete(addressEntity);</pre></div><p>Hopefully, that gives a fair introduction to active objects.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec348"/>How it works...</h2></div></div></div><a id="id1830" class="indexterm"/><a id="id1831" class="indexterm"/><a id="id1832" class="indexterm"/><p>Behind the scenes, separate tables are created in the JIRA database for every entity that we add. The active objects service interacts with these tables to do the work.</p><p>If you see the database, a table of the name <code class="literal">AO_{SOME_HEX}_MY_OBJECT</code> is created for every entity named <code class="literal">MyObject</code> belonging to a plugin with key <code class="literal">com.example.ao.myplugin</code>, where:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AO</code> is a common prefix</li><li class="listitem" style="list-style-type: disc"><code class="literal">SOME_HEX</code> is a set of the first six characters of the hexadecimal value of the hash of the plugin key <code class="literal">com.example.ao.myplugin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MY_OBJECT</code> is the upper-case translation of the entity class name <code class="literal">MyObject</code></li></ul></div><p>For every attribute with getter method, <code class="literal">getSomeAttribute</code> defined in the entity interface, a column is created in the table with the name <code class="literal">SOME_ATTRIBUTE</code> using the Java Beans naming convention—separating the two words by an underscore and keeping them both in upper case.</p><p>In our <strong>AddressEntity</strong> example, we have the following table, <strong>ao_d6b86e_address_entity</strong>, created:</p><div><img src="img/1803-10-07.jpg" alt="How it works..."/></div><p>And, for our example, the data is stored as shown next:</p><div><img src="img/1803-10-08.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec128"/>Accessing JIRA configuration properties</h1></div></div></div><p>We have seen how to use <code class="literal">PropertySet</code> to store details of plugins in the previous recipes. In this recipe, we will see how we can access the JIRA configuration properties using <code class="literal">PropertySet</code>.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec349"/>How to do it...</h2></div></div></div><a id="id1833" class="indexterm"/><a id="id1834" class="indexterm"/><a id="id1835" class="indexterm"/><p>There are lot of global configurations settings in JIRA which are configured using Administration menus. More on the various options can be read at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+Global+Settings">http://confluence.atlassian.com/display/JIRA/Configuring+Global+Settings</a>. Where does JIRA store this information and how do we access it?</p><p>All these configuration properties, such as, settings under <strong>General</strong> <strong>Configuration</strong>, <strong>Base</strong> <strong>URL</strong>, <strong>Attachments</strong> <strong>path</strong>, <strong>license</strong> <strong>info</strong>, and more, are stored in the <code class="literal">propertyset</code> tables we saw earlier. They are stored against a virtual entity, <code class="literal">jira.properties</code>. This is the same virtual entity that is used when the <code class="literal">PropertySet</code> is retrieved using <code class="literal">PropertiesManager</code>, as we saw while persisting plugin information.</p><p>Here, all the property key entries are stored in the <code class="literal">propertyentry</code> table, with <code class="literal">jira.properties</code> as the entity name and <code class="literal">entityid</code> as <code class="literal">1</code>. The <code class="literal">propertytype</code> for each property varies, depending on what is stored against it. For example, <code class="literal">jira.option.allowattachments</code> is a flag and hence is stored in the <code class="literal">propertynumber</code> table, with a value of either <code class="literal">0</code> or <code class="literal">1</code>. In this case, the <code class="literal">propertytype</code> is <code class="literal">1</code>, denoting the number <code class="literal">value</code>. <code class="literal">jira.path.index</code>, on the other hand, stores a String that holds the index path and will have <code class="literal">5</code> as <code class="literal">propertytype</code>. Here the value is stored in <code class="literal">propertystring</code> table.</p><p>All the properties can be accessed using the following SQL command:</p><div><pre class="programlisting">
<strong>select * from propertyentry where ENTITY_NAME='jira.properties';</strong>
</pre></div><p>If you want to see only String properties and their values, you can get it using the command:</p><div><pre class="programlisting">
<strong>select PROPERTY_KEY, propertyvalue from propertyentry pe, propertystring ps where pe.id=ps.id and pe.ENTITY_NAME='jira.properties' and propertytype='5';</strong>
</pre></div><p>If you want to search for a specific property, you can do that using the following command:</p><div><pre class="programlisting">
<strong>select PROPERTY_KEY, propertyvalue from propertyentry pe, propertynumber pn where pe.id=pn.id and pe.ENTITY_NAME='jira.properties' and pe.PROPERTY_KEY='jira.option.allowattachments';</strong>
</pre></div><p>Note that the appropriate property table should be used, <code class="literal">propertynumber</code> in this case!</p><p>The same things can be achieved in a plugin, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Retrieve the <code class="literal">PropertySet</code> object:<div><pre class="programlisting">PropertySet propertySet = PropertiesManager.getInstance().getPropertySet();</pre></div><p>As said before, from JIRA 4.3, the <code class="literal">PropertiesManager.getInstance()</code> method has been deprecated. Instead, you can inject the <code class="literal">PropertiesManager</code> in the constructor using dependency injection or retrieve it from <code class="literal">ComponentManager</code>, as shown:</p><div><pre class="programlisting">PropetySet propertySet =  ComponentManager.getComponent(PropertiesManager.class).getPropertySet();</pre></div></li><li class="listitem">All property keys can be retrieved as follows:<div><pre class="programlisting">Collection&lt;String&gt; keys = propertySet.getKeys();</pre></div></li><li class="listitem">Similarly, all the properties of a specific type can be accessed as:<div><pre class="programlisting">Collection&lt;String&gt; stringKeys = propertySet.getKeys(5);</pre></div></li><li class="listitem"><a id="id1836" class="indexterm"/><a id="id1837" class="indexterm"/><a id="id1838" class="indexterm"/>The value of a particular key can be accessed as follows:<div><pre class="programlisting">String attachmentHome = propertySet.getString("jira.path.attachments");
boolean attachmentsAllowed = propertySet.getBoolean("jira.option.allowattachments");</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec129"/>Getting database connection for JDBC calls</h1></div></div></div><p>It is not always feasible to use <strong>OfBizDelegator</strong><a id="id1839" class="indexterm"/> to get all the details that we need. What if we need to execute a complex query in the database via JDBC? In this recipe, we will see how we can retrieve the database connection that is defined in <code class="literal">entityengine.xml</code>.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec350"/>How to do it...</h2></div></div></div><a id="id1840" class="indexterm"/><a id="id1841" class="indexterm"/><a id="id1842" class="indexterm"/><p>The database connection lookup is pretty simple if you are familiar with JDBC. Follow these quick steps to retrieve a connection:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">javax.naming.InitialContext</code> object:<div><pre class="programlisting">InitialContext cxt = new InitialContext();</pre></div></li><li class="listitem">Retrieve the database information from the entity configurations using <code class="literal">EntityConfigUtil</code>:<div><pre class="programlisting">DatasourceInfo datasourceInfo = EntityConfigUtil.getDatasourceInfo ("defaultDS");</pre></div><p>Here, <code class="literal">defaultDS</code> is the name of the data source defined in <code class="literal">entityengine.xml</code>.</p></li><li class="listitem">Retrieve the <code class="literal">jndi-name</code> string from the <code class="literal">DataSourceInfo</code> object:<div><pre class="programlisting">String jndiName = datasourceInfo.jndiJdbcElement.getAttribute ( "jndi-name" );</pre></div></li><li class="listitem">Use <code class="literal">jndi-name</code> to look up the <code class="literal">javax.sql.DataSource</code> object:<div><pre class="programlisting">DataSource ds = ( DataSource ) cxt.lookup ( jndiName );</pre></div></li><li class="listitem">Create the <code class="literal">java.sql.Connection</code> object from the DataSource:<div><pre class="programlisting">Connection conn = ds.getConnection();</pre></div></li><li class="listitem">Once you get the connection, it is similar to any other JDBC calls. Create your statements or prepare statements and execute them.</li></ol></div><p>As I write this, JIRA 4.3 is being released, and getting a connection is going to be much simpler. Just do the following:</p><div><pre class="programlisting">Connection conn = new DefaultOfBizConnectionFactory().getConnection();</pre></div><p>Simple, isn't it?</p><p><code class="literal">DataSourceInfo</code> can be accessed as follows:</p><div><pre class="programlisting">DatasourceInfo datasourceInfo = new DefaultOfBizConnectionFactory().getDatasourceInfo();</pre></div><a id="id1843" class="indexterm"/><a id="id1844" class="indexterm"/><a id="id1845" class="indexterm"/><p>Over to you, to write the JDBC calls wisely!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec130"/>Migrating a custom field from one type to another</h1></div></div></div><a id="id1846" class="indexterm"/><a id="id1847" class="indexterm"/><p>Custom fields in JIRA are of different types—text fields, select lists, number fields, and so on. We might come across scenarios where we need to change the type of a field but without losing all the data we have entered until then! Is possible to do that? It is, to a certain extent. In this recipe, we will see how to do it.</p><p>The type of a field can only be changed via the database, as the UI doesn't support that. But, it won't be possible with all the field types. For example, it isn't possible to convert a text field to a number field because all the values that the field already has may not be number fields. However, the reverse is possible, because all number values can be treated as text values. Similarly, you can convert a select field to a text field but you cannot convert a multi-select field to a text field because a multi-select has multiple values, each with a separate row in the <code class="literal">customfieldvalue </code>table.</p><p>So, the first step is to identify whether the conversion is feasible, by looking at the source and target types. If it is feasible, we can go on and modify the type, as described in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec351"/>How to do it...</h2></div></div></div><a id="id1848" class="indexterm"/><a id="id1849" class="indexterm"/><p>The following steps outline how to modify the type of custom field if the source and target types satisfy the condition we discussed earlier:</p><div><ol class="orderedlist arabic"><li class="listitem">Stop the JIRA instance.</li><li class="listitem">Connect to the JIRA DB as the JIRA user.</li><li class="listitem">Modify the custom field key in the <code class="literal">customfield</code> table by executing the SQL script as shown:<div><pre class="programlisting">update customfield set customfieldtypekey = 'com.atlassian.jira.plugin.system.customfieldtypes:textfield' where cfname = 'Old Number Value';</pre></div><p>Here, the type of the custom field named <strong>'Old</strong> <strong>Number</strong> <strong>Value'</strong> is changed to text field. Make sure that the custom field name is unique; if not, use custom field ID in the <code class="literal">where</code> condition<a id="id1850" class="indexterm"/>.</p></li><li class="listitem">Modify the searcher key similarly, with an appropriate searcher. In the previous case, we need to modify the searcher value to text searcher, as shown:<div><pre class="programlisting">update customfield set customfieldsearcherkey = 'com.atlassian.jira.plugin.system.customfieldtypes:textsearcher' where cfname = 'Old Number Value';</pre></div></li><li class="listitem">Commit the changes and disconnect.</li><li class="listitem">Start JIRA.</li><li class="listitem">Do a complete reindexing of the JIRA instance by going to <strong>Administration</strong> | <strong>System</strong> | <strong>Indexing</strong>.</li></ol></div><p>The custom field should now be modified to a text field from the old number field. Add or update values and search them to verify the change.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec131"/>Retrieving issue information from a Database</h1></div></div></div><a id="id1851" class="indexterm"/><a id="id1852" class="indexterm"/><p>Information about an issue is scattered around in multiple tables in the JIRA database. However, a good starting point is the <code class="literal">jiraissue</code> table<a id="id1853" class="indexterm"/>, which is where the issue record is stored. It has foreign keys referencing other tables and, at the same time, the issue ID is referenced in few other tables.</p><p>The following diagram captures the important tables that the <code class="literal">jiraissue</code> table has a parent relationship with:</p><div><img src="img/1803-10-09.jpg" alt="Retrieving issue information from a Database"/></div><a id="id1854" class="indexterm"/><a id="id1855" class="indexterm"/><p>As you can see, critical information about an issue, such as, the project, issue type, status, priority, resolution, security level, workflow, and so on, are all stored in the respective tables but are referenced from the <code class="literal">jiraissue</code> table, using a foreign key. The foreign key points to the ID of the other tables in all cases, but there are no foreign key constraints enforced on any of these tables.</p><a id="id1856" class="indexterm"/><a id="id1857" class="indexterm"/><p>Similarly, the following diagram shows the tables that the <code class="literal">jiraissue</code> table has a child relationship with:</p><div><img src="img/1803-10-10.jpg" alt="Retrieving issue information from a Database"/></div><a id="id1858" class="indexterm"/><a id="id1859" class="indexterm"/><p>Here, the tables <code class="literal">customfieldvalue</code>, <code class="literal">changegroup</code>, <code class="literal">jiraaction</code>, <code class="literal">label</code>, <code class="literal">worklog</code>, <code class="literal">fileattachment</code>, <code class="literal">issuelink</code>, <code class="literal">trackback_ping</code>, and so on, have a foreign key with the name <code class="literal">issueid</code> or <code class="literal">issue</code> (or source or destination) pointing to the relevant issue's ID.</p><p>In this recipe, we will learn how to access some of the issue's information with the help of the previous diagrams.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec352"/>How to do it...</h2></div></div></div><a id="id1860" class="indexterm"/><a id="id1861" class="indexterm"/><p>When there is a parent-child relationship between tables, we can do a join operation to get most of the information we are looking for. For example, all the issues along with their project names can be retrieved by the following query:</p><div><pre class="programlisting">
<strong>select ji.id, ji.pkey, pr.pname from jiraissue ji inner join  project pr on ji.project = pr.id;</strong>
</pre></div><p>Here we do an inner join on the condition that the project's ID is the same as the project column value in the <code class="literal">jiraissue</code> table.</p><p>Similarly, all the comments on an issue can be retrieved by the following query:</p><div><pre class="programlisting">
<strong>select ji.pkey, ja.actionbody, ja.created, ja.author from jiraissue ji left join jiraaction ja on ji.id = ja.issueid;</strong>
</pre></div><p>In the example, we retrieve the comments on issues with their author and created date. The same approach can be used with all tables in the previous diagrams.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec353"/>There's more...</h2></div></div></div><p>Accessing version and component information on an issue is slightly different. Even though you see the <code class="literal">fixfor</code> and <code class="literal">component</code> columns in the <code class="literal">jiraissue</code> table, they are not used anymore!</p><p>Each issue can have multiple versions or components and hence there is a <code class="literal">join</code> table between the <code class="literal">jiraissue</code> and <code class="literal">version</code>/<code class="literal">component</code> tables, called <code class="literal">nodeassociation</code>. The <code class="literal">source_node_entity</code> will be the <code class="literal">ISSUE</code> and the <code class="literal">source_node_id</code> represents the issue ID. The <code class="literal">sink_node_entity</code> will be <strong>Component</strong> or <strong>Version</strong>, in this case, and <code class="literal">sink_node_id</code> will hold the ID of the respective component or version.</p><p>There is a third column, <code class="literal">association_type</code>, which will be <code class="literal">IssueFixVersion</code>, <code class="literal">IssueVersion</code>, or <code class="literal">IssueComponent</code> for fixes for versions, affected versions or components respectively.</p><p>We can access the components of an issue as follows:</p><div><pre class="programlisting">select ji.pkey, comp.cname from nodeassociation na, component comp, jiraissue ji where comp.id = na.sink_node_id and ji.id = na.source_node_id and na.association_type = "IssueComponent" and ji.pkey = 'DEMO-123';</pre></div><p>Here, <code class="literal">DEMO-123</code> is the issue. We can also retrieve the affected versions and fix versions in a similar fashion.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec132"/>Retrieving custom field details from a database</h1></div></div></div><a id="id1862" class="indexterm"/><a id="id1863" class="indexterm"/><a id="id1864" class="indexterm"/><p>In the previous recipe, we have seen how to retrieve the standard fields of an issue from the database. In this recipe, we will see how to retrieve the custom field details of an issue.</p><p>All the custom fields in JIRA are stored in the <code class="literal">customfield</code> table, as we have seen while modifying the custom field types. Some of these custom fields, such as, select fields, multi-select fields, and so on, can have different options configured and they can be found in the <code class="literal">customfieldoption</code> table.</p><p>For each custom field, there can be a set of contexts configured. These contexts specify the projects or a list of issue types the field is associated with. For each such context, an entry is made in the <code class="literal">fieldconfigscheme</code> with a unique ID. For each <code class="literal">fieldconfigscheme</code>, there will be entries in the <code class="literal">configurationcontext</code> and <code class="literal">fieldconfigschemeissuetype</code> tables, <code class="literal">configurationcontext</code> holding the projects the field is associated with in the relevant context, and <code class="literal">fieldconfigschemeissuetype</code> holding the issue types the field is associated with! For fields, such as Select and Multi Select, there can be different options configured for different contexts and this can be found from the <code class="literal">customfieldoption</code> table, using the <code class="literal">customfildconfig</code> column, which points to the respective row in the <code class="literal">fieldconfigscheme</code> table.</p><p>There must always be a record in <code class="literal">configurationcontext</code> and <code class="literal">fieldconfigschemeissuetype</code> for each configuration scheme. If the scheme isn't restricted to any projects or issue types, the <code class="literal">project</code> and <code class="literal">issuetype</code> columns of the respective tables should be <code class="literal">NULL</code>.</p><p>For individual issues, the value(s) of the custom fields are stored in the <code class="literal">customfieldvalue</code> table with a reference to the <code class="literal">jiraissue</code> and <code class="literal">customfield</code> tables. For multi-value fields, such as multiple select, multiple checkboxes, and so on, there will be multiple entries in the <code class="literal">customfieldvalue</code> table.</p><p>We capture this information in a simple diagram like the following:</p><div><img src="img/1803-10-11.jpg" alt="Retrieving custom field details from a database"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec354"/>How to do it...</h2></div></div></div><a id="id1865" class="indexterm"/><a id="id1866" class="indexterm"/><a id="id1867" class="indexterm"/><p>Once a custom field is added, the details of the field can be retrieved from the <code class="literal">customfield</code> table with this simple query:</p><div><pre class="programlisting">
<strong>select * from customfield where cfname = 'CF Name';</strong>
</pre></div><p>If it is a field with multiple options, such as the select field, the options can be retrieved using a simple join, as shown next:</p><div><pre class="programlisting">
<strong>select cf.id, cf.cfname, cfo.customvalue from customfield cf inner join customfieldoption cfo on cf.id = cfo.customfield where cfname = 'CF Name';</strong>
</pre></div><p>The various field configurations can be retrieved from the <code class="literal">fieldconfigscheme</code> table, as follows:</p><div><pre class="programlisting">
<strong>select * from fieldconfigscheme where fieldid = 'customfield_12345';</strong>
</pre></div><p>Here, <code class="literal">12345</code> is the unique ID for the custom field.</p><p>The projects associated with a custom field can be retrieved as follows:</p><div><pre class="programlisting">
<strong>select project.pname from configurationcontext inner join project on configurationcontext.project = project.id where fieldconfigscheme in  (select id from fieldconfigscheme where fieldid = 'customfield_12345');</strong>
</pre></div><p>When the project is <code class="literal">NULL</code>, the field is global and hence available for all projects!</p><a id="id1868" class="indexterm"/><a id="id1869" class="indexterm"/><a id="id1870" class="indexterm"/><p>Similarly, the issue types associated with the field can be retrieved as follows:</p><div><pre class="programlisting">
<strong>select issuetype.pname from fieldconfigschemeissuetype inner join issuetype on fieldconfigschemeissuetype.issuetype = issuetype.id where fieldconfigscheme in (select id from fieldconfigscheme where fieldid = 'customfield_12345');</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec133"/>Retrieving permissions on issues from a database</h1></div></div></div><p>JIRA is quite powerful in enforcing permissions on issues. There are quite a lot of configuration options in controlling who can do what. All these revolve around two different schemes in JIRA, <strong>Permission</strong> <strong>Scheme</strong><a id="id1871" class="indexterm"/> and <strong>Issue</strong> <strong>Security</strong> <strong>Scheme</strong><a id="id1872" class="indexterm"/>.</p><a id="id1873" class="indexterm"/><a id="id1874" class="indexterm"/><p>Permission Scheme enforces project-level security whereas Issue Security Scheme enforces issue-level security. It is possible for you to grant access to view issues in a project and yet hide some of those issues from the user. However, the reverse is not possible, that is, one cannot grant access to certain selected issues when the user originally didn't have access to view the issues in the project.</p><p>The various tables involved in storing permission information in the JIRA database, along with the relations between them, can be depicted as follows:</p><div><img src="img/1803-10-12.jpg" alt="Retrieving permissions on issues from a database"/></div><a id="id1875" class="indexterm"/><a id="id1876" class="indexterm"/><p>As you can see here, both the Permission Schemes and Issue Security Schemes are related to a project via the <code class="literal">nodeassociation</code> table. Here, the <strong>SOURCE_NODE_ENTITY</strong> is <strong>Project</strong> and the corresponding <strong>SOURCE_NODE_ID</strong> holds the ID of the project. The <strong>SINK_NODE_ENTITY</strong> is <code class="literal">PermissionScheme</code> or <code class="literal">IssueSecurityScheme</code> depending on the scheme type. <strong>SINK_NODE_ID</strong> will point to the appropriate scheme. The <strong>ASSOCIATION_TYPE</strong> is <code class="literal">ProjectSheme</code>, in both the cases.</p><p>For each of the permission schemes, there are multiple permissions predefined, such as, <strong>Administer</strong> <strong>Project</strong>, <strong>Browse</strong> <strong>Project</strong>, <strong>Create</strong> <strong>Issues</strong>, and so on. For each of these permissions, the <code class="literal">perm_type</code> and <code class="literal">perm_parameter</code> hold the type of the entity and its value that has the relevant permission. For example, the <code class="literal">perm_type</code> could be group, user, project role, and so on, and <code class="literal">perm_parameter</code> will be the group name, username, or the project role , respectively. Multiple permission types can be granted a single permission.</p><p>Similarly, issue security scheme holds a number of security levels that are stored in the <code class="literal">schemeissuesecuritylevels</code> table. Each of these security levels can have different entities in them, which are also defined using <code class="literal">type</code> and <code class="literal">parameter</code> values; in this case, the column names are <code class="literal">sec_type</code> and <code class="literal">sec_parameter</code>.</p><a id="id1877" class="indexterm"/><a id="id1878" class="indexterm"/><p>The Permission Scheme is enforced on an issue based on the project it resides in, whereas the security scheme is enforced by looking at the security level the issue is assigned. The security column in the <code class="literal">jiraissue</code> table holds this information.</p><p>Let us see how we can retrieve some of this information from an issue, based on the previous diagram.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec355"/>How to do it...</h2></div></div></div><p>It is fairly easy to find out the Permission Scheme associated with a project with the help of the <code class="literal">nodeassociation</code> table, as shown next:</p><div><pre class="programlisting">
<strong>select pr.pname, ps.name from nodeassociation na, project pr, permissionscheme ps where pr.id = na.source_node_id and ps.id = na.sink_node_id and na.association_type = 'ProjectScheme' and na.source_node_entity = 'Project' and na.sink_node_entity = 'PermissionScheme';</strong>
</pre></div><p>Similarly, Issue Security Scheme can be retrieved as follows:</p><div><pre class="programlisting">
<strong>select pr.pname, iss.name from nodeassociation na, project pr, issuesecurityscheme iss  where pr.id = na.source_node_id and iss.id = na.sink_node_id and na.association_type = 'ProjectScheme' and na.source_node_entity = 'Project' and na.sink_node_entity = 'IssueSecurityScheme';</strong>
</pre></div><p>The permissions parameters associated with a specific permission in a permission scheme, with an <code class="literal">id</code> value 9, can be easily retrieved as follows:</p><div><pre class="programlisting">
<strong>select sp.perm_type, sp.perm_parameter from schemepermissions sp inner join permissionscheme ps on sp.scheme = ps.id where ps.id = 9 and sp.permission = 23</strong>
</pre></div><p>Here, <code class="literal">sp.permission = 23</code> denotes<code class="literal"> PROJECT_ADMIN</code> permission. The different permission types can be found in <code class="literal">com.atlassian.jira.security.Permissions</code> class. Here, the <code class="literal">perm_type</code> denotes whether the permission is granted to a group, user, or role; <code class="literal">perm_parameter</code> holds the name of the respective group, user, or role.</p><p>Similarly, queries can be written to retrieve information on the issue security schemes. For example, the security levels and the security type and parameters for each level in a issue security scheme can be retrieved as follows:</p><div><pre class="programlisting">
<strong>select iss.name, sisl.name, sis.sec_type, sis.sec_parameter from issuesecurityscheme iss , schemeissuesecurities sis, schemeissuesecuritylevels sisl where sis.scheme = iss.id and sisl.scheme =iss.id;</strong>
</pre></div><a id="id1879" class="indexterm"/><a id="id1880" class="indexterm"/><p>Writing more complex queries is outside the scope of the book but, hopefully, the previous schema diagram and the sample SQL diagrams give enough information to start with!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec134"/>Retrieving workflow details from a database</h1></div></div></div><a id="id1881" class="indexterm"/><a id="id1882" class="indexterm"/><a id="id1883" class="indexterm"/><p>Other major information that people normally look for in the database is about workflows. What is the current status of an issue? How does one find out which workflow an issue is associated with? Where is the workflow XML stored in the database? In this recipe, we will take a quick tour of the tables related to workflows.</p><p>JIRA workflows, as we have seen in the previous chapters, have statuses, steps, and transitions. There is always a one-to-one mapping between status and step and they are always kept in sync. Then, there are transitions which will move the issue from one step to another and, hence, from one status to another.</p><p>The workflows themselves are stored as XML files in the <code class="literal">jiraworkflows</code> table. JIRA processes these XMLs using the OSWorkflow APIs to retrieve the necessary information for each transition, step, and so on. Any draft workflows are stored in the <code class="literal">jiradraftworkflows</code> table.</p><p>The <code class="literal">jiraissue</code> table holds the ID of its current status and the status details are stored in the <code class="literal">issuestatus</code> table. We can use the status ID in the <code class="literal">jiraissue</code> table to retrieve the corresponding details from the <code class="literal">issuestatus</code> table.</p><p><code class="literal">jiraissue</code> also has another column, <code class="literal">workflow_id</code>, which points to the workflow the issue is associated with and the current step in the workflow the issue is in. The first bit of information, that is, the workflow an issue is associated with, is stored in the <code class="literal">os_wfentry</code> table. Here, the <code class="literal">workflow_id</code> will point to the ID column of the <code class="literal">os_wfentry</code> table. The second bit of information, that is, the current step associated with an issue, is stored in the <code class="literal">os_currentstep</code> table. Here, the <code class="literal">workflow_id</code> points to the <code class="literal">entry_id</code> column in the <code class="literal">os_currentstep</code> table.</p><p>So, for every issue, there is an entry in the <code class="literal">os_wfentry</code> and <code class="literal">os_currentstep</code> tables. And the relations are: <code class="literal">jiraissue.WORKFLOW_ID == OS_WFENTRY.ID</code> and <code class="literal">jiraissue.WORKFLOW_ID == OS_CURRENTSTEP.ENTRY_ID</code>.</p><p>There is another table <code class="literal">os_history</code> step, which holds all the history information of the steps an issue has gone through. Here, again, the <code class="literal">workflow_id</code> points to the <code class="literal">entry_id</code> column in the <code class="literal">os_historystep</code> table. From this table, we can retrieve information on how long an issue remained in a particular step or status.</p><p>The following schema diagram captures the important relations:</p><div><img src="img/1803-10-13.jpg" alt="Retrieving workflow details from a database"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec356"/>How to do it...</h2></div></div></div><a id="id1884" class="indexterm"/><a id="id1885" class="indexterm"/><a id="id1886" class="indexterm"/><p>The status of an issue, <code class="literal">DEMO-123</code>, can be retrieved by a simple query, as shown next:</p><div><pre class="programlisting">
<strong>select istat.pname from issuestatus istat, jiraissue ji where istat.id=ji.issuestatus and ji.pkey='DEMO-123';</strong>
</pre></div><p>The details of the workflow associated with an issue can be retrieved, as follows:</p><div><pre class="programlisting">
<strong>select * from os_wfentry where id=(select workflow_id from jiraissue where pkey='DEMO-123');</strong>
</pre></div><p>You can retrieve the workflow XML for an issue using the following query:</p><div><pre class="programlisting">
<strong>select ji.pkey, wf.descriptor from jiraissue ji, jiraworkflows wf, os_wfentry osw where ji.workflow_id = osw.id and osw.name = wf.workflowname and ji.pkey='DEMO-123';</strong>
</pre></div><p>The current step associated with an issue can be retrieved as follows:</p><div><pre class="programlisting">
<strong>select * from os_currentstep where entry_id = (select workflow_id from jiraissue where pkey = 'DEMO-123');</strong>
</pre></div><a id="id1887" class="indexterm"/><a id="id1888" class="indexterm"/><a id="id1889" class="indexterm"/><p>The history of workflow status (step) changes can be retrieved from the <code class="literal">os_historystep</code>, as shown:</p><div><pre class="programlisting">
<strong>select * from os_historystep where entry_id = (select workflow_id from jiraissue where pkey = 'DEMO-123');</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec135"/>Updating issue status in a database</h1></div></div></div><a id="id1890" class="indexterm"/><a id="id1891" class="indexterm"/><a id="id1892" class="indexterm"/><p>In this recipe, we will quickly see how to update the status of an issue in the JIRA database.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec357"/>Getting ready</h2></div></div></div><p>Go through the previous recipe to understand the workflow related tables in JIRA.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec358"/>How to do it...</h2></div></div></div><p>Refer to the follow steps to update the status of an issue in JIRA:</p><div><ol class="orderedlist arabic"><li class="listitem">Stop the JIRA server.</li><li class="listitem">Connect to JIRA database.</li><li class="listitem">Update the <code class="literal">issuestatus</code> field in <code class="literal">jiraissue</code> table with the status you need:<div><pre class="programlisting">UPDATE jiraissue SET issuestatus = (select id from issuestatus where pname = 'Closed') where pkey = 'DEMO-123';</pre></div></li><li class="listitem">Modify the <code class="literal">step_id</code> in the <code class="literal">os_currentstep</code> table with the step ID linked to the status you used in the previous step. The <code class="literal">step_id</code> can be found in the workflow XML alongside the step name within brackets, as shown in the following screenshot:<div><img src="img/1803-10-14.jpg" alt="How to do it..."/></div><p>As you can see, the status <strong>Closed</strong> in the JIRA default workflow is linked to the <strong>Closed</strong> step with an <code class="literal">id</code> value 6. Now, the <code class="literal">step_id</code> can be updated as follows:</p><div><pre class="programlisting">UPDATE os_currentstep SET step_id = 6 where entry_id = (select workflow_id from jiraissue where pkey = 'DEMO-123');</pre></div><p>Here, we modify the <code class="literal">step_id</code> in <code class="literal">os_currentstep</code> where the <code class="literal">entry_id</code> is the same as the <code class="literal">workflow_id</code> in the <code class="literal">jiraissue</code> table.</p><p>This is very important as the step and status should always be in sync. Updating the status alone will change it on the issue but will prevent further workflow actions on it.</p></li><li class="listitem">Add entries in the <code class="literal">os_historystep</code> field if you want to keep track of the status changes. This is entirely optional. Leaving it out won't cause any issues except that the records won't be available for reporting at a later stage.</li><li class="listitem"><a id="id1893" class="indexterm"/><a id="id1894" class="indexterm"/><a id="id1895" class="indexterm"/>Update the <code class="literal">os_currentstep_prev</code> and <code class="literal">os_historystep_prev</code> tables accordingly. These tables hold the ID of the previous record. This is again optional.</li><li class="listitem">Commit the changes and start JIRA.</li><li class="listitem">Do a full re-index by going to <strong>Administration</strong> | <strong>System</strong> | <strong>Indexing</strong>.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec136"/>Retrieving users and groups from a database</h1></div></div></div><a id="id1896" class="indexterm"/><a id="id1897" class="indexterm"/><a id="id1898" class="indexterm"/><a id="id1899" class="indexterm"/><a id="id1900" class="indexterm"/><p>When external user management is not turned <strong>ON</strong>, we can find all the information about JIRA users and their groups from the database by running a few simple SQL queries. In this recipe, we will see the various tables involved.</p><p>In versions prior to JIRA 4.3, user information is stored in the <code class="literal">userbase</code> table, the group information is stored in the <code class="literal">groupbase</code> table, and the details of which users belong to which groups are stored in the <code class="literal">membershipbase</code> table.</p><p>In those versions, user properties are stored using <code class="literal">PropertySet</code>, as we have seen earlier in one of the recipes (where we added an address against a user). There will be an entry for the user in the <code class="literal">propertyentry</code> table with the <code class="literal">entity_name</code> as <code class="literal">OSUser</code> and <code class="literal">entity_id</code> as the ID of the user in the <code class="literal">userbase</code> table. Examples of properties stored are full name and e-mail address and they are stored as String values in the <code class="literal">propertystring</code> table.</p><p>There is another table, <code class="literal">userassociation</code>, that holds the information about watching an issue and voting on an issue. In this table, the <code class="literal">source_name</code> column holds the unique username and <code class="literal">sink_node_id</code> holds the ID of the issue. <code class="literal">sink_node_entity</code> has the value <code class="literal">Issue</code> and <code class="literal">association_type</code> has values <code class="literal">WatchIssue</code> or <code class="literal">VoteIssue</code>, depending on the operation.</p><p>From version 4.3 onwards, JIRA uses <strong>Embedded</strong> <strong>Crowd</strong> as its user management framework. Here, the users are stored in the <code class="literal">cwd_user</code> table, groups in the <code class="literal">cwd_group</code> table, and the membership details in the <code class="literal">cwd_membership</code> table. It is possible to have group-user membership or group-group membership in versions 4.3+, and this information is also stored in the <code class="literal">cwd_membership</code> table. Also, as opposed to the previous versions, there are separate tables for storing attributes—<code class="literal">cwd_user_attributes</code> to store user attributes and <code class="literal">cwd_group_attributes</code> to store group attributes.</p><p>JIRA versions 4.3+ also have the concept of user directories. A JIRA instance can have multiple directories and different directories can have the same name in it. The directory details are stored in the <code class="literal">cwd_directory</code> table and its attributes in the <code class="literal">cwd_directory_attribute</code> table. There are references in the <code class="literal">cwd_user</code> table and the <code class="literal">cwd_group</code> table, both with name <code class="literal">directory_id</code>, and pointing to the appropriate directory ID. The <code class="literal">cwd_directory_operation</code> table stores the available operations on a directory, based on user permissions.</p><a id="id1901" class="indexterm"/><a id="id1902" class="indexterm"/><a id="id1903" class="indexterm"/><a id="id1904" class="indexterm"/><a id="id1905" class="indexterm"/><p>When there are multiple users with the same name in different directories, JIRA will only recognize the user in the highest-priority directory. The priority is stored in the <code class="literal">directory_position</code> column.</p><p>The table relations prior to 4.3 are too simple to draw ER diagrams from, hence we will draw one for 4.3+ versions:</p><div><img src="img/1803-10-15.jpg" alt="Retrieving users and groups from a database"/></div><a id="id1906" class="indexterm"/><a id="id1907" class="indexterm"/><a id="id1908" class="indexterm"/><a id="id1909" class="indexterm"/><a id="id1910" class="indexterm"/><p>Watches and votes in JIRA versions 4.3+ work in the same way as in the previous versions.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec359"/>How to do it...</h2></div></div></div><p>With the simple layout of table structure, it is quite easy to list the users, groups or their relationships by directly accessing the database. For example, prior to version 4.3, we can find all users in a group by simply running:</p><div><pre class="programlisting">
<strong>select user_name from membershipbase where group_name = 'jira-administrators';</strong>
</pre></div><p>In versions 4.3+, we can do the same, as follows:</p><div><pre class="programlisting">
<strong>select child_name from cwd_membership where parent_name='jira-administrators' and membership_type = 'GROUP_USER' and directory_id = 1;</strong>
</pre></div><p>Here, we consider the directory as well, because we can have the same users and groups in different directories.</p><p>Prior to version 4.3, the properties like full name and e-mail are stored and accessed from <code class="literal">propertystring</code> table, as follows:</p><div><pre class="programlisting">
<strong>select pe.property_key, ps.propertyvalue from propertystring ps inner join propertyentry pe on ps.id = pe.id  where pe.entity_name = 'OSUser' and pe.entity_id = (select id from userbase where userbase.username = 'username'); </strong>
</pre></div><p>In versions 4.3+, these attributes are part of the <code class="literal">cwd_user</code> table, but there can be other attributes stored in the <code class="literal">cwd_user_attributes</code> table, such as, last login time, invalid password attempts, and so on, which are accessed as shown in the command:</p><div><pre class="programlisting">
<strong>select attribute_name, attribute_value from cwd_user_attributes where user_id = (select id from cwd_user where user_name = 'someguy' and directory_id =1);</strong>
</pre></div><a id="id1911" class="indexterm"/><a id="id1912" class="indexterm"/><a id="id1913" class="indexterm"/><a id="id1914" class="indexterm"/><a id="id1915" class="indexterm"/><p>In all the versions, users watching an issue can be retrieved as follows:</p><div><pre class="programlisting">
<strong>select source_name from userassociation where association_type = 'WatchIssue' and sink_node_entity = 'Issue' and sink_node_id = (select id from jiraissue where pkey='DEMO-123');</strong>
</pre></div><p>Similarly, all the issues watched by a user can be retrieved as:</p><div><pre class="programlisting">
<strong>select ji.pkey from jiraissue ji inner join userassociation ua on ua.sink_node_id =  ji.id where ua.association_type = 'WatchIssue' and ua.sink_node_entity = 'Issue' and ua.source_name = 'someuser';</strong>
</pre></div><p>It is the same for votes, except that the association type will be <code class="literal">VoteIssue</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec137"/>Dealing with Change history in a database</h1></div></div></div><a id="id1916" class="indexterm"/><a id="id1917" class="indexterm"/><p>Before we wind up this chapter, let us touch up on the change history tables as well. Change histories on issues hold important information on what was changed and when. It is sometimes very useful for reporting and, sometimes, we find ourselves manually adding change histories in the database to keep record of the changes we made via SQL - for example, updating the status of an issue via SQL as we saw earlier in this chapter.</p><p>A set of changes happening on an issue at a single point of time are grouped together to form a change group. There is an entry for each such change group in the <code class="literal">changegroup</code> table, with the information about the issue on which the change is made, the user who makes the change, and the time at which the changes happened.</p><p>Then, there is an entry for each of those individual changes in the <code class="literal">changeitem</code> table, all pointing to the respective <code class="literal">changegroup</code>. The <code class="literal">changeitem</code> table holds information on what was actually changed—the old value and the new value. There can be both numerical and textual representation in some cases like status where there is a human-readable text (<code class="literal">status</code> <code class="literal">name</code>) as well as a unique ID (<code class="literal">status_id</code>). They are stored in <code class="literal">oldvalue</code> and <code class="literal">oldstring</code>, and <code class="literal">newvalue</code> and <code class="literal">newstring</code> respectively.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec360"/>How to do it...</h2></div></div></div><a id="id1918" class="indexterm"/><a id="id1919" class="indexterm"/><p>Let us have a look at both retrieving change histories and adding them. For a given issue, we can find out the all changes that happened on it using a simple join, as follows:</p><div><pre class="programlisting">
<strong>select  cg.author, cg.created, ci.oldvalue, ci.oldstring, ci.newvalue, ci.newstring  from changegroup cg inner join changeitem ci on cg.id = ci.groupid  where cg.issueid = (select id from jiraissue where pkey = 'DEMO-123') order by cg.created;</strong>
</pre></div><p>It is quite easy to modify this to filter out changes made by a user or during a particular period.</p><p>Now, let us quickly have a look at adding a new change on an issue via the database, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Stop the JIRA server.</li><li class="listitem">Connect to the JIRA database.</li><li class="listitem">Create an entry in the <code class="literal">changegroup</code> table, with the correct ID of the issue, author name, and created time.<div><pre class="programlisting">
<strong>insert into changegroup values (12345,10000,'someguy','2011-06-15');</strong>
</pre></div><p>Make sure the ID value (<code class="literal">12345)</code> is larger than the <code class="literal">max(ID)</code> in the table.</p></li><li class="listitem">Insert a change item for this change group. Let us consider the status change we made in the earlier recipe:<div><pre class="programlisting">insert into changeitem values (11111, 12345, 'jira','status','1','Open','6','Closed');</pre></div></li><li class="listitem">Note that the <code class="literal">groupid</code> here is same as the ID attribute in <em>Step</em> <em>3</em>. The third column holds the field type, which could be JIRA or custom. For all the standard JIRA fields, such as, <code class="literal">summary</code>, <code class="literal">status</code>, and so on, the field type is JIRA. For custom fields, we use the field type as <code class="literal">custom</code>.<p>For fields such as <code class="literal">status</code>, there is a textual representation (the name) and there is a unique ID; hence, both <code class="literal">oldvalue</code> and <code class="literal">oldstring</code> columns are populated. The same is the case with the <code class="literal">newvalue</code> and <code class="literal">newstring</code> columns. For fields such as <code class="literal">Summary</code>, only the <code class="literal">oldstring</code> and <code class="literal">newstring</code> columns needs to be populated.</p><p>Here, also make sure the <code class="literal">id(11111)</code> is larger than <code class="literal">max(id)</code> in the table.</p></li><li class="listitem"><a id="id1920" class="indexterm"/><a id="id1921" class="indexterm"/>Update the <code class="literal">sequence_value_item</code> table to hold a higher value in the <code class="literal">seq_id</code> column for the <code class="literal">ChangeGroup</code> and <code class="literal">ChangeItem</code> entities. In the previous case, we can give a value <code class="literal">12346</code> for <code class="literal">ChangeGroup</code> and <code class="literal">11112</code> for <code class="literal">ChangeItem</code>. Ofbiz normally allocates IDs in batches of ten, so the <code class="literal">SEQ_ID</code> is the next available ID, rounded up to the nearest value <strong>10</strong>, though adding 1 should be enough.<div><pre class="programlisting">
<strong>update sequence_value_item set seq_id = 12346 where seq_name = 'ChangeGroup';</strong>
<strong>update sequence_value_item set seq_id = 11112 where seq_name = 'ChangeItem';</strong>
</pre></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>This step is required whenever a row is inserted into any of the JIRA tables. The <code class="literal">seq_id</code> value in the <code class="literal">sequence_value_item</code> table should be updated for the entity where the new row is added. The new sequence value should be atleast one more than the <code class="literal">max(id)</code> of the entity.</p></div></div></li><li class="listitem">Commit the changes and start JIRA.</li><li class="listitem">Re-index the JIRA instance by going to <strong>Administration</strong> | <strong>System</strong> | <strong>Indexing</strong>.</li></ol></div></div></div></body></html>