- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building upon the Foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we continue to navigate the ever-evolving landscape of cloud computing, it
    is essential to understand the nuances of deploying high-level designs across
    different public cloud providers. In this chapter, we will investigate the differences
    that arise when using cloud-agnostic tools such as Terraform and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: I have found that despite our best efforts to maintain consistency, variations
    will always crop up when deploying designs across different providers. In this
    chapter, I will share some of my own experiences addressing these variations and
    provide some practical approaches for building repeatable deployment processes
    for various applications and environments.
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss the importance of creating modular code, a crucial aspect
    of streamlining deployment efforts and avoiding duplicating code. By implementing
    these techniques, we can efficiently and effectively deploy our designs across
    different public cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cloud-agnostic tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the differences between our two cloud deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the differences between our Terraform and Ansible deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing more variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the code more reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing how cloud-agnostic the tools we have been using are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cloud-agnostic tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268), *Deploying to Amazon
    Web Services*, we use both Terraform and Ansible to target these clouds – so we
    know they work with both cloud providers, but how much of the code did we reuse?
  prefs: []
  type: TYPE_NORMAL
- en: The honest answer is very little.
  prefs: []
  type: TYPE_NORMAL
- en: We used different providers/collections for each of the cloud providers. As
    a result, there were many allowances we needed to make. While conceptually, the
    cloud providers offer like-for-like services at a high level; they have evolved
    in very different ways to achieve the same task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, launching something as simple as a virtual machine requires two
    approaches: deploying services such as networking work requires different considerations
    and configurations as they simply just work differently.'
  prefs: []
  type: TYPE_NORMAL
- en: So why do we call the two tools we have been looking at cloud agnostic? Surely
    that should mean *they* *just work*.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, yes, that should be the case. With the trends in AI tools
    at the time of writing this book in early 2023, we might be close enough to define
    our **Infrastructure-as-Code** (**IaC**) deployments in natural language, with
    some constraints and rules, and have it target our cloud of choice.
  prefs: []
  type: TYPE_NORMAL
- en: While that may be close, it doesn’t exist now.
  prefs: []
  type: TYPE_NORMAL
- en: So back to the here and now with the two tools we have been working with, what
    changes could we make to how we work to make them as cloud agnostic as possible?
  prefs: []
  type: TYPE_NORMAL
- en: As we discovered in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268), *Deploying
    to Amazon Web Services*, both Terraform and Ansible have some useful helper functions,
    tools, and utilities, so the more we can take advantage of these across our deployments,
    the better.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of this chapter, we will look at what we can consistently
    use across our deployments, no matter which cloud we are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to look at the consistencies across our deployment and then
    figure out how we can best take them into account in our deployments by developing
    a more standard approach to writing, managing, and executing our code.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the differences between our Microsoft Azure and Amazon Web Services
    deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s summarize our deployment as we have covered the deployment in four separate
    sets of code across the previous two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: General
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is just a single service here, and as you can see – it is only available
    in one of our target cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service/Function** | **Microsoft Azure** | **Amazon** **Web Services**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Resource Container | Resource group | Not available |'
  prefs: []
  type: TYPE_TB
- en: There isn’t an equivalent of resource groups within Amazon Web Services, though
    some could argue that tagging does the same job. However, tags act more as a way
    of searching for and reporting against your resources rather than collecting them
    all together in a container, which, as we have seen, can be removed or have permissions
    applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next up, we have the network resources; any resources marked with a ***,**
    while available, are not used in our WordPress deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service /** **Function** | **Microsoft Azure** | **Amazon** **Web Services**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Network | Virtual network | **Virtual Private** **Cloud** (**VPC**) |'
  prefs: []
  type: TYPE_TB
- en: '| Subnet | Subnet | Subnet |'
  prefs: []
  type: TYPE_TB
- en: '| Gateway | NAT gateway * | Internet gateway |'
  prefs: []
  type: TYPE_TB
- en: '| Route table | Route table * | Route table |'
  prefs: []
  type: TYPE_TB
- en: '| Security | Network security groups | Security group |'
  prefs: []
  type: TYPE_TB
- en: '| Load balancer | Load Balancer/Application Gateway * | Elastic Load Balancer
    */Application Load Balancer |'
  prefs: []
  type: TYPE_TB
- en: 'From a service point of view, we have an even coverage of services. At the
    same time, they are configured slightly differently between the two cloud services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource name**: All Azure resources require a name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource regions and availability zones**: Both clouds have a concept of
    regions – and in most of those regions, there are multiple availability zones
    though it is worth pointing out that some secondary regions in Microsoft Azure
    – for example, UK West, do not have availability zones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10.0.0.0/24`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subnet addresses**: There were some critical differences between the subnets
    deployed in our two clouds; for example, in Microsoft Azure, we needed to delegate
    a particular service to them, whereas, in AWS, we didn’t need to delegate a service.
    Still, we did pin our subnets to an availability zone within our target region.
    However, outside of this, the information needed for each cloud is roughly the
    same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the network services we are deploying, a few of them would benefit from being
    configured using loops and passing in variables – though this could get a little
    complicated as we will need a little logic for both Terraform and Ansible for
    Azure Services, which may require a service delegated to the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the face of it, this should be simple as we *just* need to launch and configure
    some storage; however, as you may remember from our scripts, there are pretty
    big differences between the two cloud providers in terms of storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service/Function** | **Microsoft Azure** | **Amazon** **Web Services**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Storage (**Network File** **System** (**NFS**)) | Storage account with Azure
    Files enabled | Amazon Elastic File Service |'
  prefs: []
  type: TYPE_TB
- en: '| Private **Domain Name** **System** (**DNS**) | Private DNS zone | Mount targets
    |'
  prefs: []
  type: TYPE_TB
- en: '| Network integration | Private endpoint | Not required |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there are some differences in the way that Microsoft handles
    network integration of its services in Azure – with the key word there being **integration**.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant and consistent difference between the two cloud providers
    is how networking works on their **Platform-as-a-Service** (**PaaS**) services.
  prefs: []
  type: TYPE_NORMAL
- en: I typically explain that Amazon has built its PaaS services from the ground
    up to be deployed within an Amazon VPC network.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, Microsoft has built its PaaS services to allow you to link them
    to your virtual network. In some cases, that link is not always bi-directional,
    so certain PaaS services can only have access to resources within a virtual network
    rather than being able to be consumed within the virtual network – while this
    is not the case for any of the services in our example WordPress deployment, it
    is a consideration you need to make when planning your deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The information required to launch and configure the services is similar, even
    with the differences previously described.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In typical fashion, after explaining that in Microsoft Azure, most PaaS services
    have a level of virtual network integration rather than being launched directly
    into the network, we launch one of the network Azure services that is hosted within
    the virtual network:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service/Function** | **Microsoft Azure** | **Amazon** **Web Services**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Database | Azure Database for MySQL – Flexible Server | Amazon Relational
    Database Service |'
  prefs: []
  type: TYPE_TB
- en: '| Private DNS | Private DNS zone | Subnet group |'
  prefs: []
  type: TYPE_TB
- en: While we don’t need to add a private endpoint when deploying Azure Database
    for MySQL – Flexible Server, we do need to delegate an entire subnet to the service,
    so there are a few considerations still to make when planning the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the bulk of the information required to launch the services is similar
    between the two cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machine (admin)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deploying the admin virtual machine instance, we needed to make a few
    considerations; however, the information required is similar for each of our two
    cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service/Function** | **Microsoft Azure** | **Amazon** **Web Services**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Image | Azure Image from the Azure Marketplace | **Amazon Machine Image**
    (**AMI**) from the AWS Marketplace |'
  prefs: []
  type: TYPE_TB
- en: '| Compute | Azure Virtual Machine | Amazon **Elastic Compute** **Cloud** (**EC2**)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Load Balancer Attachment | Required | Required |'
  prefs: []
  type: TYPE_TB
- en: As you may recall, when we launched our WordPress workload in Amazon Web Services,
    we needed to adjust our cloud-init script slightly to consider the differences
    in how some of the services are consumed. All we needed was to build in a bit
    of logic to check and, if required, wait for our resources to be available.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines with scaling (web)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything we mentioned for deploying the admin virtual machine instance also
    applies here; there is only really one main difference between the two providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service/Function** | **Microsoft Azure** | **Amazon** **Web Services**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Image | Azure Image from the Azure Marketplace | AMI from the AWS Marketplace
    |'
  prefs: []
  type: TYPE_TB
- en: '| Configuration | Not required | Launch configuration |'
  prefs: []
  type: TYPE_TB
- en: '| Compute | Azure Virtual Machine Scale Sets | Amazon EC2 Auto Scaling Group
    |'
  prefs: []
  type: TYPE_TB
- en: '| Load Balancer Attachment | Inline | Inline |'
  prefs: []
  type: TYPE_TB
- en: As you can see, all Azure configurations are inline; however, by contrast, Auto
    Scaling groups in Amazon Web Services require a launch configuration to use as
    the base for our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing it in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, while the two cloud providers work slightly differently, there
    is close-enough feature parity for your deployment to take a similar approach,
    at least at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does all this mean when it comes to being cloud agnostic with a single
    tool?
  prefs: []
  type: TYPE_NORMAL
- en: Well, as we have already discussed at a high level, the approach is similar,
    and while the modules/tasks may differ, you can use some of the same logic when
    it comes to your deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at doing this with Terraform code; the code will create a primary
    network and then use a loop to create four subnets in both Microsoft Azure and
    Amazon Web Services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s look at the variables we are going to be using to achieve
    this – to start with, we have the `name`, `region`, and `default` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only variable that will change between our two cloud providers is `region`,
    as each provider has different region names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we define the address space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Nothing too special here still; however, for the subnets, we define the following,
    from which, while quite lengthy, you should be able to quickly get an idea of
    what is happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are defining a map here as that will give us something we
    can loop through. Now let us move on to the `main.tf` files.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is not the complete code – please see the GitHub repository
    that accompanies this title for the full executable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create the network itself; the following is for AWS, where we are
    creating a VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have the same task, but this time for Azure, which creates a virtual
    network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, they are not too dissimilar, and we are applying the same logic
    of taking the list of tags and adding one using the `merge` function to add the
    resource name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our networks, it’s time to loop over the `subnets` variable
    and add those, starting with AWS again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then the same again, this time for Azure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are using the same approach in both in that we are looping
    through the `var.subnets` variable using a `for_each` loop.
  prefs: []
  type: TYPE_NORMAL
- en: We then use `each.value.name` to name the resource, in Azure’s case, using the
    `name` key, and for AWS, by creating a `Name` tag.
  prefs: []
  type: TYPE_NORMAL
- en: For both, we use the output of creating the network to reference it; for AWS,
    we use `aws_vpc.network.id`; in Azure, we use `azurerm_virtual_network.network.name`.
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that Terraform will only attempt to create the subnets once
    the network they are going to live in has been created.
  prefs: []
  type: TYPE_NORMAL
- en: We can then use the `cidrsubnet` function to take our address space, which again
    is being referenced from the network resource we created using `"${aws_vpc.network.cidr_block}"`
    for AWS and `"${azurerm_virtual_network.network.address_space[0]}"` for Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We then use `each.value.address_prefix_size` to define the CIDR size of each
    subnet, which in our case is `/27`, and `each.value.address_prefix_number` to
    define where within the address space `/27` is placed.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, while the application of variables and functions is slightly
    different between Amazon Web Services and Microsoft Azure, we can use the same
    logic to generate and loop through the subnets.
  prefs: []
  type: TYPE_NORMAL
- en: We can also apply the same logic using Ansible – as we will discuss more in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between our Terraform and Ansible deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed how we can take a cloud-agnostic approach to our deployments
    when using either Terraform or Ansible, as each tool has built-in functions and
    logic for manipulating our variables and the output of running tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Some big differences should have become apparent during the code walk-throughs
    in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft Azure*,
    and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268), *Deploying to Amazon Web
    Services*. I am also sure you are forming an opinion on which of the two tools
    you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: The two tools are very different in their approach, which is to be expected
    as they were designed to do two different tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is primarily designed to manage infrastructure, whereas Ansible manages
    server and state configuration, which also includes a level of infrastructure
    management.
  prefs: []
  type: TYPE_NORMAL
- en: During my day job, I have, and continue to use, both tools – so where does the
    decision to use one or the other come in?
  prefs: []
  type: TYPE_NORMAL
- en: 'If a project requires the repeatable deployment and configuration of several
    PaaS services in either cloud – especially if the resources need to be launched,
    consumed, and then terminated, then I recommend using Terraform; this is for a
    few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it stores everything in its state file, making terminating any workload
    a lot more straightforward as we discovered when terminating our AWS deployment
    using Ansible, we needed to build in quite a lot of logic to make sure that the
    workload was correctly terminated and removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, it plays well into **continuous integration/continuous delivery**
    (**CI/CD**) services such as GitHub Actions, which we will discuss in more detail
    in [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in* *the
    Cloud*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, I find it has much more coverage and support for some of the newer
    services and features the cloud providers are introducing. That’s not to knock
    the Ansible development team; it is just that Ansible, in most cases, appears
    to lag Terraform with new features depending on which of the clouds you are targeting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the reasons to use Terraform are also some of the contributing factors
    when it comes to choosing to use Ansible – for example, as Ansible does not use
    state files and dynamically discovers resources, it is a lot more straightforward
    to manage in-life changes, for instance, ones that are made once the resources
    have been deployed and the service is in production, as you don’t run the risk
    of the tool trying to enforce a state it knows about strictly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Ansible can be used if I need to interact with the host at the resource
    level itself, for example, I need to, **Secure Shell** (**SSH**) into a server
    that has just been launched or target a Windows Server using WinRM to configure
    the host to set Apache or **Internet Information** **Services** (**IIS**).
  prefs: []
  type: TYPE_NORMAL
- en: It is great for working with fixed points, meaning that, let’s say, you have
    been using Ansible to manage the state of the workload, which has been running
    a virtual machine on-premise when you can likely reuse a lot of that code to target
    a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, Ansible will be the tool of choice.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another option – *use both*! That’s right; you can use Ansible
    to run your Terraform code using the `community.general.terraform` task.
  prefs: []
  type: TYPE_NORMAL
- en: In the code repository accompanying this title, you will find a folder called
    `ansible-terraform-azure`. This contains an Ansible playbook, which will use Terraform
    to launch an Azure-hosted virtual machine and then, using Ansible, connect to
    it, install `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task that performs this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are telling the task where our Terraform code is; in this
    case, it is in the `terrform` folder. We are then passing in several variables,
    which overwrite the defaults defined in the `variables.tf` file in the `terraform`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the Terraform execution, we are outputting the public IP address
    and the name of the virtual machine, which we then add to a host group using the
    following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before finally setting some facts using the `ansible.builtin.set_fact` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the playbook, which you can do by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Having Ansible run Terraform](img/Figure_6.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Having Ansible run Terraform
  prefs: []
  type: TYPE_NORMAL
- en: 'If you follow the link given in your output (the one in the previous screenshot
    is no longer active), you should be presented with a web page that looks like
    the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Having Ansible run Terraform](img/Figure_6.02_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Having Ansible run Terraform
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove everything using the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you may have imaged, as we are using Terraform to manage the Azure resources,
    the preceding playbook uses Ansible to run `terraform destroy` rather than us
    having to set each resource to `absent` as we have had to do in previous Ansible
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed how to use both Ansible and Terraform together to
    get the best out of both tools, we need to discuss variables next. As you will
    have noticed, we have used many variables in all our Ansible and Terraform code,
    so let’s now discuss how we can best use them.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing more variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Personally, I try to do everything I can use variables rather than hardcoding
    values into the code itself – while this can take more time when it comes to writing
    your code, I highly recommend it as both tools we have looked at allow you to
    override variables at runtime via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this in Terraform, you can use the following flag when running the `apply`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When running the Terraform code, which we discussed earlier in the chapter,
    we launched a network in Amazon Web Services to change the region from `us-east-1`,
    which is the default set within the code, to `eu-west-1` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add multiple variables; the following example expands on the previous
    one by adding a new address space to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When running Ansible code, for example, in the playbook we executed in the
    last section, you can run the following command to override a top-level variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are changing the host group name to `azure_vms`; you may have noticed
    that I said top-level variable because many of the variables we are using in the
    Ansible playbook are multi-level sub-variables – these look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To override these, we need to pass in multiple variables as JSON; this turns
    our command into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is important to pass in everything if I try and override a single variable,
    for example, `title`, as it replaces the whole block, which means that there is
    no longer a `body` variable, and our playbook run will error.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some of these techniques and more in our next chapter, [*Chapter
    7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in* *the Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of the section, it can sometimes add more time to
    creating your code when trying to use as many variables as possible – especially
    if you have quickly prototyped your code to deploy something and have hardcoded
    some of the values in for ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use tools such as **ChatGPT** and other AI services to help
    add variables to take your code and replace hardcoded values quite quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following prompt to ask ChatGPT to turn some basic Terraform code into
    one with variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: resource "azurerm_resource_group" "example" {
  prefs: []
  type: TYPE_NORMAL
- en: name     = "example"
  prefs: []
  type: TYPE_NORMAL
- en: location = "West Europe"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It gave the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have everything we need to copy and paste into our code –
    at the time of writing, responses from tools such as ChatGPT need to be double-checked,
    but as mentioned earlier in this chapter – as tools like this get more powerful,
    it is fully expected that you will be using them a lot more in your day-to-day
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using variables is that it makes our code more reusable,
    let’s discuss this in a little more detail now.
  prefs: []
  type: TYPE_NORMAL
- en: Making the code more reusable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as using variables, we are also able to reuse *chunks* of code – when
    we discussed Ansible in [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268), *Deploying
    to Amazon Web Services*, we discussed *roles*. In Ansible, roles are designed
    to be called repeatedly, so while we used them to logically split our project
    into more manageable sections, we can go one step further and have them only perform
    a single function.
  prefs: []
  type: TYPE_NORMAL
- en: We can also do the same thing in Terraform. For most of our Azure deployments
    so far, we have been using a module downloaded from the Terraform registry to
    manage the region settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Claranet**, the publisher of that module, also has others – let us look at
    how we can create a virtual network in Azure using only modules (the complete
    executable code can be found in this book’s GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to initialize the region module as we have been doing in
    our other Terraform code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have the region locked in, we can then use the output of that module
    to create a resource group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are using `module.azure_region.location` to define the location.
    Then we are passing in some details about our project – as Claranet is a managed
    service provider, it uses `client_name` and `stack` throughout its modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to create a virtual network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, we can see more of the same information and the CIDR space we want to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part is to create the subnet(s):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, I am using the same logic we used to create the subnets earlier
    in this chapter using the `cidrsubnet` function in a `for_each` loop across the
    `subnets` variable.
  prefs: []
  type: TYPE_NORMAL
- en: So why would you want to do this?
  prefs: []
  type: TYPE_NORMAL
- en: As we saw when we used Terraform to deploy our WordPress workload in Microsoft
    Azure in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we had to build in logic to handle changes in subnet settings – in our
    case, this was to delegate a subnet for use with the Azure Database for MySQL
    – Flexible Server service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module provided by Claranet has this logic built in; for example, the code
    to add this would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Claranet has over 80 other modules for Microsoft Azure and Amazon Web Services
    on Terraform registry, and they are not the only provider to have modules published
    there – both other providers and individuals have modules published there that
    are all free to use.
  prefs: []
  type: TYPE_NORMAL
- en: You can also publish your own modules on the Terraform registry or even host
    them on GitHub as either public or private repositories; the advantage of using
    modules and taking this approach is that it enables you very quickly to develop
    your IaC deployments with consistent reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: So, what about Ansible?
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, you can use roles, which are distributed via Ansible Galaxy
    – there are far fewer roles there compared to the modules available in Terraform
    – but you can publish your own or reuse them locally.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we finish the chapter, let’s have a quick pop quiz:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the name of the function we use to work with CIDR ranges in Terraform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing in variables at runtime, which tools use the `--extra-vars` flag,
    and which one uses `-var`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What key can be used to loop through a list or map of variables in Terraform
    tasks or modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When working with NFS, which of the two public clouds requires a mount target
    to be configured?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Database for MySQL – Flexible Server requires us to do what to a subnet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the answers after the summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the use of variables, modules, or roles, you can quickly build up your
    IaC deployments in a consistent way that can be shared with the rest of your team,
    allowing everyone to build their environments using a set of shared building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of this approach is that you are deploying the same sort of
    infrastructure repeatedly for your project because you have multiple environments
    or multiple customers.
  prefs: []
  type: TYPE_NORMAL
- en: Having a set of variables per deployment changing things such as the **stock
    keeping units** (**SKUs**) or resource names, with everything else being the same,
    will save time and allow you to manage all your deployments centrally. We will
    look at how to centrally manage our deployment in our next chapter, [*Chapter
    7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in* *the Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let us quickly summarize what we have discussed in this chapter.
    We started by clearing up what we mean by cloud-agnostic tools before looking
    at the difference between our Amazon Web Services and Microsoft Azure deployments.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed the differences in the approaches we need to take when choosing
    to use Terraform or Ansible; we also did a bit of a deep dive into how we can
    combine the two tools and use Ansible to manage our Terraform deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more details on the services and documentation we have mentioned
    in this chapter at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform Registry: [https://registry.terraform.io](https://registry.terraform.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Claranet Terraform modules and providers: [https://registry.terraform.io/namespaces/claranet](https://registry.terraform.io/namespaces/claranet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Galaxy: [https://galaxy.ansible.com](https://galaxy.ansible.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Terraform module: [https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.html](https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ChatGPT: [https://openai.com/blog/chatgpt/](https://openai.com/blog/chatgpt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to the pop quiz:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the name of the function we use to work with CIDR ranges in Terraform?
    The answer is `cidrsubnet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing in variables at runtime, which tools use the `--extra-vars` flag,
    and which one uses `-var`? The `--extra-vars` flag is used by Ansible, and `-var`
    is Terraform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What key can be used to loop through a list or map of variables in Terraform
    tasks or modules? The key is `for_each` with the value being the variable you
    wish to loop through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When working with NFS, which of the two public clouds requires a mount target
    to be configured? The answer is Amazon Web Services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Database for MySQL – Flexible Server requires us to do what to a subnet?
    Azure Database for MySQL – Flexible Server must have an entire subnet delegated
    to it using the `delegate` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: CI/CD and Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will look at using **Continuous Integration/Continuous Deployment**
    (**CI/CD**) hosted in the cloud. We will be using GitHub Actions to execute our
    Terraform and Ansible deployments.
  prefs: []
  type: TYPE_NORMAL
- en: We will then move on to discussing best practices and some common troubleshooting
    tips, before finally reviewing a few alternatives to Terraform and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19537_07.xhtml#_idTextAnchor431)*, Leveraging CI/CD in the Cloud*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19537_08.xhtml#_idTextAnchor509)*, Common Troubleshooting Tips
    and Best Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19537_09.xhtml#_idTextAnchor545)*, Exploring Alternative Infrastructure-as-Code
    Tools*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
