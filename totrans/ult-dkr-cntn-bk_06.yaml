- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Code Running in Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to work with stateful containers – that
    is, containers that consume and produce data. We also learned how to configure
    our containers at runtime and at image build time using environment variables
    and config files.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while it’s running in
    a container. With these techniques at hand, you will enjoy a frictionless development
    process for applications running in a container, similar to what you experience
    when developing applications that run natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the topics we’re going to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolving and testing code running in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-restarting code upon changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line-by-line code debugging inside a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumenting your code to produce meaningful logging information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jaeger to monitor and troubleshoot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After finishing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mount source code residing on the host in a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure an application running in a container to auto-restart after a code
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure **Visual Studio Code** (**VS Code**) to debug applications written
    in Java, Node.js, Python, or .NET running inside a container line by line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log important events from your application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure your multi-component application for distributed tracing using the
    OpenTracing standard and a tool such as Jaeger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, if you want to follow along with the code, you will need Docker
    Desktop on macOS or Windows and a code editor – preferably VS Code. The samples
    will also work on a Linux machine with Docker and VS Code installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare your environment for the coming hands-on labs, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please navigate to the folder where you have cloned the sample repository to.
    Normally, this should be `~/The-Ultimate-Docker-Container-Book`, so do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new subfolder called `ch06` and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A complete set of sample solutions for all the examples discussed in this chapter
    can be found in the `sample-solutions/ch06` folder or directly on GitHub: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06).'
  prefs: []
  type: TYPE_NORMAL
- en: Evolving and testing code running in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure you have Node.js and `npm` installed on your computer before you
    continue. On Mac, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When developing code that will eventually be running in a container, the best
    approach is often to run the code in the container from the very beginning, to
    make sure there will be no surprises. But we have to do this in the right way
    so that we don’t introduce any unnecessary friction to our development process.
    First, let’s look at a naïve way we could run and test code in a container. We
    can do this using a basic Node.js sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project folder and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use `npm` to create a new Node.js project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Accept all the defaults. Notice that a `package.json` file is created with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Content of the package.json file of the sample Node.js application](img/B19199_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Content of the package.json file of the sample Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use the `Express.js` library in our Node application; thus, use
    `npm` to install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will install the newest version of `Express.js` on our machine and, because
    of the `–save` parameter, add a reference to our `package.json` file that looks
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that in your case, the version number of `express` may be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start VS Code from within this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In VS Code, create a new file called `index.js` and add this code snippet to
    it. Do not forget to save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Content of the index.js file of the sample Node.js application](img/B19199_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Content of the index.js file of the sample Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: 'From within your terminal window, start the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On Windows and Mac, when you execute the preceding command for the first time,
    a window will pop up, asking you to approve it on the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see this as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This means that the application is running and ready to listen at the `0.0.0.0:3000`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering what the meaning of the host address, `0.0.0.0`, is and
    why we have chosen it. We will come back to this later when we run the application
    inside a container. For the moment, just know that `0.0.0.0` is a reserved IP
    address with a special meaning, similar to the loopback address, `127.0.0.1`.
    The `0.0.0.0` address simply means all IPv4 addresses on the local machine. If
    a host has two IP addresses, say `52.11.32.13` and `10.11.0.1`, and a server running
    on the host listens on `0.0.0.0`, it will be reachable at both of those IPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open a new tab in your favorite browser and navigate to `http://localhost:3000`.
    You should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Sample Node.js application running in a browser](img/B19199_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Sample Node.js application running in a browser
  prefs: []
  type: TYPE_NORMAL
- en: Great – our Node.js application is running on our developer machine. Stop the
    application by pressing *Ctrl* + *C* in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to test the application we have developed so far by running it
    inside a container. To do this, we must create a Dockerfile so that we can build
    a container image, from which we can then run a container. Let’s use VS Code again
    to add a file called `Dockerfile` to our project folder and give it the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Dockerfile for the sample Node.js application](img/B19199_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Dockerfile for the sample Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use this Dockerfile to build an image called `sample-app`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will take a few seconds for the base image to be downloaded and your custom
    image to be built on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building, run the application in the container with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command runs a container called `my-sample-app` from the `sample-app`
    container image and maps the container’s port, `3000`, to the equivalent host
    port. This port mapping is necessary; otherwise, we won’t be able to access the
    application running inside the container from outside the container. We will learn
    more about port mapping in [*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using*
    *Single-Host Networking*. It is similar to when we ran the application directly
    on our host.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh your previous browser tab (or open a new browser tab and navigate to
    `localhost:3000`, if you closed it). You should see that the application still
    runs and produces the same output as when running natively. This is good. We have
    just shown that our application not only runs on our host but also inside a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop and remove the container by pressing *Ctrl* + *C* in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s modify our code and add some additional functionality. We will define
    another `HTTP GET` endpoint at `/hobbies`. Please add the following code snippet
    at the end of your `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can test the new functionality on our host by running the app with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we can navigate to `http://localhost:3000/hobbies` in our browser. We
    should see the expected output – a JSON array with the list of hobbies – in the
    browser window. Don’t forget to stop the application with *Ctrl* + *C* when you’ve
    finished testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to test the code when it runs inside the container. So, first,
    we must create a new version of the container image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, the build should be quicker than the first time we did this since
    the base image is already in our local cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must run a container from this new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can navigate to `http://localhost:3000/hobbies` in our browser and confirm
    that the application works as expected inside the container too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, don’t forget to stop the container when you’re done by pressing
    *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can repeat this sequence of tasks over and over again for each feature we
    add or any existing features we improve. It turns out that this is a lot of added
    friction compared to times when all the applications we developed always ran directly
    on the host.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can do better. In the next section, we will look at a technique
    that allows us to remove most of this friction.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting evolving code into the running container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if, after a code change, we do not have to rebuild the container image
    and rerun a container? Wouldn’t it be great if the changes would immediately,
    as we save them in an editor such as VS Code, be available inside the container
    too? Well, that is possible with volume mapping. In the previous chapter, we learned
    how to map an arbitrary host folder to an arbitrary location inside a container.
    We want to leverage that in this section. In [*Chapter 5*](B19199_05.xhtml#_idTextAnchor109),
    *Data Volumes and Configuration*, we learned how to map host folders as volumes
    in a container. For example, if we want to mount a host folder, `/projects/sample-app`,
    into a container at `/app`, the syntax for this will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `--volume <host-folder>:<container-folder>` line. The path to the
    host folder needs to be an absolute path, which in this example is `/projects/sample-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to run a container from our `sample-app` container image and
    we do that from the project folder, we can map the current folder to the `/app`
    folder of the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please note `$(pwd)` in place of the host folder path. `$(pwd)` equals the absolute
    path of the current folder, which comes in very handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we use the above volume mapping parameter, then whatever was in the
    `/app` folder of the `sample-app` container image will be overridden by the content
    of the mapped host folder, which in our case is the current folder. That’s exactly
    what we want – we want the current source to be mapped from the host into the
    container. Let’s test whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the container if you have started it by pressing *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the following snippet to the end of the `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do not forget to save.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the container again – this time, without rebuilding the image first
    – to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your browser, navigate to `http://localhost:3000/status`. You will see the
    `OK` output in your browser window. Alternatively, instead of using your browser,
    you could use `curl` in another terminal window to probe the `/status` endpoint,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For all those working on Windows and/or Docker Desktop for Windows, you can
    use the PowerShell `Invoke-WebRequest` command or `iwr` for short instead of `curl`.
    In this case, the equivalent to the preceding command would be `PS> iwr -``Url
    http://localhost:3000/status`.
  prefs: []
  type: TYPE_NORMAL
- en: Leave the application in the container running for the moment and make yet another
    change. Instead of just returning `OK` when navigating to `/status`, we want a
    message stating `OK, all good` to be returned. Make your modification and save
    your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, execute the `curl` command again or, if you did use your browser, refresh
    the page. What do you see? Right – nothing happened. The change we made is not
    reflected in the running application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, let’s double-check whether the change has been propagated in the running
    container. To do this, let’s execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This executes the `cat index.js` command inside our already running container.
    We should see something like this – I have shortened the output for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, our changes have been propagated into the container as expected.
    Why, then, are the changes not reflected in the running application? Well, the
    answer is simple: for changes to be applied to the application, the Node.js sample
    application has to be restarted.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try that. Stop the container with the application running by pressing
    *Ctrl* + *C*. Then, re-execute the preceding `docker container run` command and
    use `curl` to probe the `http://localhost:3000/status` endpoint. This time, the
    following new message should b[e displayed:](http://localhost:3000/status)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have significantly reduced the friction in the development process
    by mapping the source code in the running container. We can now add new codeor
    modify existing code and test it without having to build the container image first.
    However, a bit of friction has been left in play. We have to manually restart
    the container every time we want to test some new or modified code. Can we automate
    this? The answer is yes! We will demonstrate exactly this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting code upon changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we showed you how we can massively reduce friction
    by volume mapping the source code folder in the container, thus avoiding having
    to rebuild the container image and rerun the container over and over again. Yet
    we still feel some remaining friction. The application running inside the container
    does not automatically restart when a code change is made. Thus, we have to manually
    stop and restart the container to pick up these new changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how we can containerize our applications written
    in various languages, such as Node.js, Java, Python, and .NET, and have them restart
    automatically whenever a code change is detected. Let’s start with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have been coding for a while, you will certainly have heard about helpful
    tools that can run your applications and restart them automatically whenever they
    discover a change in the code base. For Node.js applications, the most popular
    tool is `nodemon`. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `nodemon` globally on our system with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that `nodemon` is available, instead of starting our application (for example,
    on the host) with `node index.js`, we can just execute `nodemon` and we should
    see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Running our Node.js sample application with nodemon](img/B19199_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Running our Node.js sample application with nodemon
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, from parsing our `package.json` file, `nodemon` has recognized
    that it should use `node index.js` as the starting command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try to change some code. For this example, add the following code snippet
    to the end of `index.js` and then save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at the terminal window. Did you see something happen? You should see this
    additional output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indicates that `nodemon` has recognized some changes and automatically
    restarted the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this out on your browser by navigating to `localhost:3000/colors`. You
    should see the following expected output in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is cool – you got this result without having to manually restart the application.
    This makes us yet another bit more productive. Now, can we do the same within
    the container?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, we can. However, we won’t use the start command, `node index.js`, as defined
    in the last line of our Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will use `nodemon` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Do we have to modify our Dockerfile? Or do we need two different Dockerfiles,
    one for development and one for production?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our original Dockerfile creates an image that unfortunately does not contain
    `nodemon`. Thus, we need to create a new Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file. Let’s call it `Dockerfile.dev`. Its content should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Dockerfile used for developing our Node.js application](img/B19199_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Dockerfile used for developing our Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: Comparing this with our original `Dockerfile`, we have added line 2, where we
    install `nodemon`. We have also changed the last line and are now using `nodemon`
    as our start command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build our development image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note the `-f Dockerfile.dev` command-line parameter. We must use this
    since we are using a Dockerfile with a non-standard name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, while the application is running in the container, change some code, save
    it, and notice that the application inside the container is automatically restarted.
    With this, we have achieved the same reduction in friction while running in a
    container as we did when running directly on the host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *C* when you’re done to exit your container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command to clean up your system and remove all running or
    dangling containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might be wondering, does this only apply to Node.js? No – fortunately, many
    popular languages support similar concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for Java and Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java and Spring Boot are still by far the most popular programming languages
    and libraries when developing **line of business** (**LOB**) type applications.
    Let’s learn how to work as friction-free as possible when developing such an application
    and containerizing it.
  prefs: []
  type: TYPE_NORMAL
- en: For this example to work, you have to have Java installed on your computer.
    At the time of writing, the recommended version is Java 17\. Use your favorite
    package manager to do so, such as Homebrew on Mac or Chocolatey on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also want to make sure you have *Extension Pack for Java* by Microsoft
    installed for VS Code. You can find more details here: [https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the Java 17 SDK installed and ready on your computer, proceed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to bootstrap a Spring Boot application is by using the `Spring
    Web`, and select it (*do not* select **Spring** **Reactive Web**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Bootstrapping a new Java project with Spring Initializr](img/B19199_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Bootstrapping a new Java project with Spring Initializr
  prefs: []
  type: TYPE_NORMAL
- en: Click `ch06/java-springboot-demo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code from within this folder by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Locate the main file of the project, which is called `DemoApplication.java`,
    and click on the `main` method on line 9, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Starting the Java Spring Boot application](img/B19199_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Starting the Java Spring Boot application
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that the application has been compiled and that a terminal window opens.
    Content similar to the following will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Output generated by a running Spring Boot application](img/B19199_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Output generated by a running Spring Boot application
  prefs: []
  type: TYPE_NORMAL
- en: On the second to last line of the preceding output, we can see that the application
    uses the Tomcat web server and is listening at port `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s add an endpoint that we can then try to access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decorate the `DemoApplication` class with a `@``RestController` annotation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `getSpecies` method that returns a list of strings
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Decorate the method with the following annotation:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@``GetMapping("/species")`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget to add the required `import` statements. The complete code will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Complete demo code for the Spring Boot example](img/B19199_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Complete demo code for the Spring Boot example
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `curl` or the `/``species` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Using the Thunder Client plugin to test the Java demo application](img/B19199_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Using the Thunder Client plugin to test the Java demo application
  prefs: []
  type: TYPE_NORMAL
- en: 'To add auto-restart support to our Java Spring Boot application, we need to
    add the so-called dev tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `pom.xml` file in your Java project and open it in the editor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following snippet to the dependencies section of the file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Adding a reference to the Spring Boot dev tools](img/B19199_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Adding a reference to the Spring Boot dev tools
  prefs: []
  type: TYPE_NORMAL
- en: Note that the version node in the dependency definition can be omitted as the
    project uses `spring-boot-starter-parent` as the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Stop and rerun the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify line 20 of the `DemoApplication` class and add `Crocodile` as a fourth
    species to return to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes and observe that the application automatically rebuilds and
    restarts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl` or Thunder Client again to access the `/species` endpoint. This time,
    a list of four species should be returned, including the just-added `Crocodile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great – we have a Java Spring Boot application that automatically re-compiles
    and restarts when we change any code in it. Now, we need to dockerize the whole
    thing, as we did with the Node.js example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Dockerfile` to the root of the project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Dockerfile for the Java Spring Boot demo](img/B19199_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Dockerfile for the Java Spring Boot demo
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `eclipse-temurin` image with the `17-jdk-focal` tag for this
    example since this image, at the time of writing, works on the M1 or M2 processor
    used by modern MacBooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an image using the preceding Dockerfile with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a container from this Docker image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run the container, it will take a while to compile since
    all the Maven dependencies need to be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Try to access the `/species` endpoint, as you did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change some code – for example, add a fifth species to be returned to the
    `getSpecies` method, such as `Penguin`, and then save your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe how the application running inside the container is rebuilt. Verify
    that the change has been incorporated by accessing the `/species` endpoint once
    again and asserting that five species are returned, including `Penguin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’re done playing around, stop the container either via the dashboard
    of Docker Desktop or the Docker plugin in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well, that was quite straightforward, wasn’t it? But let me tell you, setting
    up your development environment this way can make developing containerized applications
    much more enjoyable by eliminating much of the unnecessary friction.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs: []
  type: TYPE_NORMAL
- en: Try to find out how you could map your local Maven cache into the container,
    to accelerate the first startup of the container even further.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to show you how easy it is to do the same exercise in Python.
    Stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at how the same thing works for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example to work, you need to have Python 3.x installed on your computer.
    You can do this using your preferred package manager, such as Homebrew on Mac
    or Chocolatey on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your Mac, use this command to install the latest Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'On your Windows computer, use this command to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this command to verify that the installation was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the author’s case, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new project folder for our sample Python application and navigate
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code from within this folder by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a sample Python application that uses the popular Flask library.
    Thus, add a file to this folder called `requirements.txt` that contains this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a `main.py` file and give it this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Content of the main.py file of our sample Python application](img/B19199_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Content of the main.py file of our sample Python application
  prefs: []
  type: TYPE_NORMAL
- en: This is a sim[ple Hello World-type](http://localhost:5000/) app that implements
    a single RESTful endpoint at `http://localhost:5000/`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `host="0.0.0.0"` parameter in the `app.run` command is needed so that we
    can expose the port on which the Python app is listening (`5000`) to the host.
    We will need this later in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Please also note that some people have reported that, when running on a Mac
    and using port `5000`, an error stating “Address already in use. Port `5000` is
    in use by another program...” is triggered. In this case, just try to use a different
    port, such as `5001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can run and test this application, we need to install the necessary
    dependencies – in our case, Flask. In the terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should install Flask on your host. We are now ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Python, we can also use `nodemon` to have our application auto-restart
    when any changes are made to the code. For example, assume that your command to
    start the Python application is `python main.py`. In this case, you would just
    use `nodemon` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Using nodemon to auto-restart a Python 3 application](img/B19199_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Using nodemon to auto-restart a Python 3 application
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `nodemon` to start and monitor a Python application, we can test
    the application by using `curl`. Open another terminal window and enter this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see this in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s modify the code by adding the following snippet to `main.py`, right
    after the definition of the `/` endpoint (that is, right after line 5), and save
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`nodemon` will discover the changes and restart the Python app, as we can see
    in the output produced in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – nodemon discovering a change in the Python code](img/B19199_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – nodemon discovering a change in the Python code
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, believing is good, but testing is better. Thus, let’s use our friend
    `curl` once again to probe the new endpoint and see what we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Nice – it works! With that, we have covered Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to containerize this application. Add a file called `Dockerfile`
    to the project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Dockerfile for the sample Python application](img/B19199_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Dockerfile for the sample Python application
  prefs: []
  type: TYPE_NORMAL
- en: Note that on line 1, we are using a special base image that contains both Python
    and Node.js code. Then, on line 2, we install the `nodemon` tool before we copy
    the `requirements.txt` file into the container and execute the `pip install` command.
    Next, we copy all other files into the container and define the start command
    for whenever an instance of this image – that is, a container – is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build a Docker image with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run a container from this image with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should have an output similar to what was produced by the application running
    inside the container in *step 6*, where we ran the application natively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Running the containerized Python sample application](img/B19199_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Running the containerized Python sample application
  prefs: []
  type: TYPE_NORMAL
- en: Note how we have mapped the container port, `5000`, to the equivalent host port
    so that we can access the application from outside. We have also mapped the content
    of the sample directory on the host to the `/app` folder inside the running container.
    This way, we can update the code and the containerized application will automatically
    restart.
  prefs: []
  type: TYPE_NORMAL
- en: Try to change the application code, and return a fourth color when the `/colors`
    endpoint is hit. Save the change and observe how the application running inside
    the container is restarted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `curl` command to verify that an array of four colors is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’re done playing with this example, hit *Ctrl* + *C* in the terminal
    window where you have the container running to stop the application and the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we have shown a fully working example for Python that helps you massively
    reduce the friction of working with containers during the development process.
  prefs: []
  type: TYPE_NORMAL
- en: .NET is another popular platform. Let’s see if we can do something like this
    when developing a C# application on .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next candidate is a .NET application written in C#. Let’s look at how dynamic
    code updates and auto-restarts work in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not done so before, please install .NET on your laptop or workstation.
    You can use your favorite package manager, such as Homebrew on Mac or Chocolatey
    on Windows, to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Mac, use this command to install the .NET 7 SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'On a Windows machine, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use this command to verify your installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On the author’s machine, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new terminal window, navigate to this chapter’s folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From within this folder, use the `dotnet` tool to create a new Web API and
    have it placed in the `dotnet` subfolder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to this new project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code from within this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the first time you have opened a .NET project with VS Code, then
    the editor may display a popup asking you to add the missing dependencies for
    our `dotnet` project. Click the **Yes** button in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Request to load missing assets for the .NET sample application](img/B19199_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Request to load missing assets for the .NET sample application
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project Explorer of VS Code, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – The .NET sample application in the VS Code Project Explorer](img/B19199_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – The .NET sample application in the VS Code Project Explorer
  prefs: []
  type: TYPE_NORMAL
- en: Please note the `Controllers` folder with the `WeatherForecastController.cs`
    file in it. Open this file and analyze its content. It contains the definition
    for the `WeatherForecastController` class, which implements a simple RESTful controller
    with a GET endpoint at `/WeatherForecast`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From your terminal, run the application with `dotnet run`. You should see something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Running the .NET sample Web API on the host](img/B19199_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Running the .NET sample Web API on the host
  prefs: []
  type: TYPE_NORMAL
- en: Please note the fourth [line in the above](http://localhost:5080/) output, where
    .NET tells us that the application is listening at `http://localhost:5080`. In
    your case, the port may be a different one. Use the one reported for you for all
    subsequent steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `curl` to test the application, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will output an array of five JSON objects containing random weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Weather data produced by the .NET sample application](img/B19199_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Weather data produced by the .NET sample application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try to modify the code in `WeatherForecastController.cs` and return,
    say, 10 instead of the default 5 items. Change line 24 so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your changes and rerun the `curl` command. Notice how the result does not
    contain the newly added value. This is the same problem that we observed for Node.js
    and Python. To see the newly updated return value, we need to (manually) restart
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, in your terminal, stop the application with *Ctrl* + *C* and restart it
    with `dotnet run`. Try the `curl` command again. The result should now reflect
    your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Luckily for us, the `dotnet` tool has the `watch` command. Stop the application
    by pressing *Ctrl* + *C* and execute this slightly modified command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see output resembling the following (shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Running the .NET sample application with the watch task](img/B19199_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Running the .NET sample application with the watch task
  prefs: []
  type: TYPE_NORMAL
- en: Notice the first line in the preceding output, which states that the running
    application is now watched for changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make another change in `WeatherForecastController.cs`; for example, make the
    `GET` endpoint method return 100 weather items and then save your changes. Observe
    the output in the terminal. It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Auto-restarting the running sample .NET Core application](img/B19199_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Auto-restarting the running sample .NET Core application
  prefs: []
  type: TYPE_NORMAL
- en: 'By automatically restarting the application upon making changes to the code,
    the result is immediately available to us, and we can easily test it by running
    the following `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 100 instead of 10 weather items should be output this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have auto-restart working on the host, we can author a `Dockerfile`
    that does the same for the application running inside a container. In VS Code,
    add a new file called `Dockerfile-dev` to the project and add the following content
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Dockerfile for the .NET sample application](img/B19199_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Dockerfile for the .NET sample application
  prefs: []
  type: TYPE_NORMAL
- en: Note the `--urls` command-line parameter on line 6\. This explicitly tells the
    application to listen on port `5000` at all endpoints inside the container (denoted
    by the special `0.0.0.0` IP address). If we were to leave the default of `localhost`,
    then we wouldn’t be able to reach the application from outside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Port is already in use
  prefs: []
  type: TYPE_NORMAL
- en: Please note that some people have reported that when running on a Mac and using
    port `5000`, an error stating “Address already in use. Port `5000` is in use by
    another program...” is triggered. In this case, just try to use a different port,
    such as `5001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re ready to build the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to build a container image for the .NET sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the image has been built, we can run a container from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should see a similar output to what we saw when running natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the application with our friend, `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should get the array of weather forecast items. No surprises here – it works
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a code change in the controller and save it. Observe what’s
    happening in the terminal window. We should see an output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Hot reloading the .NET sample application running inside a
    container](img/B19199_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 – Hot reloading the .NET sample application running inside a container
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s exactly what we expected. With this, we have removed most of the
    friction that we introduced by using containers when developing a .NET application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re done playing with the .NET sample application, open the dashboard
    of your Docker Desktop application. Locate the `csharp-sample` container and select
    it. Then, click the red **Delete** button to remove it from your system. This
    is the easiest way to do this since, unfortunately, just pressing *Ctrl* + *C*
    in the terminal window where you ran the container does not work. Alternatively,
    you can open another terminal window and use this command to get rid of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it for now. In this section, we explored how we can reduce friction during
    development when working with containerized applications written in Node.js, Python,
    Spring Boot, Java, or .NET. Next, we are going to learn how we can debug an application
    running in a container line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Line-by-line code debugging inside a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into this section about debugging code running inside a container
    line by line, let me make a disclaimer. What you will learn in this section should
    usually be your last resort if nothing else works. Ideally, when following a test-driven
    approach when developing your application, the code is mostly guaranteed to work
    since you have written unit and integration tests for it and run them against
    your code, which also runs in a container. Alternatively, if unit or integration
    tests don’t provide you with enough insight and you need to debug your code line
    by line, you can do so by running your code directly on your host, thus leveraging
    the support of development environments such as VS Code, Eclipse, or IntelliJ,
    to name just a few IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: With all this preparation, you should rarely need to manually debug your code
    as it is running inside a container. That said, let’s see how you can do it anyways!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to concentrate exclusively on how to debug when
    using VS Code. Other editors and IDEs may or may not offer similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Node.js application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start with the easiest one – a Node.js application. We will use our sample
    application in the `~/The-Ultimate-Docker-Container-Book/ch06/node-sample` folder,
    which we worked with earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal window and make sure that you navigate to this project
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code from within this container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the terminal window, from within the project folder, run a container with
    our sample Node.js application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding command, we mapped port `9229` to the host. This port is used
    by the Node.js debugger, and VS Studio will communicate with our Node application
    via this port. Thus, it is important that you open this port – but only during
    a debugging session! Also, note that we overrode the standard start command that
    we defined in the Dockerfile (remember, it was just `node index.js`) with `node
    --inspect=0.0.0.0 index.js`. The `--inspect=0.0.0.0` command-line parameter tells
    Node to run in debug mode and listen on all IPv4 addresses in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to define a VS Code launch task for the scenario at hand –
    that is, our code running inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `.vscode` to your project (please note the leading period
    in the name of the folder). Within this folder, add a file called `launch.json`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.27 – The launch configuration to debug a Node.js application](img/B19199_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – The launch configuration to debug a Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: To open the `launch.json` file, press *cmd* + *Shift* + *P* (or *Ctrl* + *Shift*
    + *P* on Windows) to open the command palette; look for `launch.json` file should
    open in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.js` file and click on the left sidebar on line 25 to set a
    breakpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Setting a breakpoint in our Node.js sample application](img/B19199_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.28 – Setting a breakpoint in our Node.js sample application
  prefs: []
  type: TYPE_NORMAL
- en: Open the Debug view in VS Code by pressing *cmd* + *Shift* + *D* (or *Ctrl*
    + *Shift* + *D* on Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you select the correct launch task in the dropdown next to the green
    start button at the top of the view. Select `launch.json` file. It should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Selecting the correct launch task to debug our Node.js application](img/B19199_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.29 – Selecting the correct launch task to debug our Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: Next, click on the green start button to attach VS Code to the Node.js application
    running in the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In another terminal window, use `curl` to navigate to the `/``colors` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe that the code’s execution stops at the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – The code’s execution stops at the breakpoint](img/B19199_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.30 – The code’s execution stops at the breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see a yellow bar, indicating that the code’s
    execution has stopped at the breakpoint. In the top-right corner, we have a toolbar
    that allows us to navigate through the code step by step. On the left-hand side,
    we can see the **VARIABLES**, **WATCH**, and **CALL STACK** windows, which we
    can use to observe the details of our running application. The fact that we are
    debugging the code running inside the container can be verified by the fact that,
    in the terminal windows where we started the container, we can see that the output
    debugger is attached, which was generated the moment we started debugging inside
    VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the container, enter the following command in the terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to use `nodemon` for even more flexibility, then we have to change
    the `container run` command slightly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note how we use the start command, `nodemon --inspect=0.0.0.0 index.js`. This
    will have the benefit that, upon any code changes, the application running inside
    the container will restart automatically, as we learned earlier in this chapter.
    You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – Starting the Node.js application with nodemon and debugging
    turned on](img/B19199_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.31 – Starting the Node.js application with nodemon and debugging turned
    on
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the consequence of an application restart is that the debugger
    loses its connection with VS Code. But don’t worry – we can mitigate this by adding
    `"restart": true` to our launch task in the `launch.json` file. Modify the task
    so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After saving your changes, start the debugger in VS Code by clicking the green
    start button in the debug window. In the terminal, you should see that the debugger
    is attached, with a message as the output. In addition to that, VS Code will have
    an orange status bar at the bottom, indicating that the editor is in debug mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a different terminal window, use `curl` and try to navigate to `localhost:3000/colors`
    to test that your line-by-line debugging still works. Make sure the code execution
    stops at any breakpoint you have set in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have verified that debugging still works, try to modify some code;
    for example, change the array of returned colors and add yet another color. Save
    your changes. Observe how `nodemon` restarts the application and that the debugger
    is automatically re-attached to the application running inside the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.32 – nodemon restarting the application and the debugger automatically
    re-attaching to the application](img/B19199_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.32 – nodemon restarting the application and the debugger automatically
    re-attaching to the application
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have everything assembled and can now work with code running inside
    a container as if the same code were running natively on the host. We have removed
    pretty much all of the friction that containers brought into the development process.
    We can now just enjoy the benefits of deploying our code in containers.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up, stop the container by pressing *Ctrl* + *C* within the terminal
    window from where you started it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you’ve learned how to debug a Node.js application running in a container
    line by line, let’s learn how to do the same for a .NET application.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a .NET application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we want to give you a quick run-through of how to debug a
    .NET application line by line. We will use the sample .NET application that we
    created earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project folder and open VS Code from within it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open VS Code with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To work with the debugger, we can fully rely on the help of VS Code commands.
    Hit *cmd* + *Shift* + *P* (*Shift* + *Ctrl* + *P* on Windows) to open the command
    palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for `Docker: Add Docker Files to Workspace` and select it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `5000`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have entered all the required information, a `Dockerfile` and a `.dockerignore`
    file will be added to the project. Take a moment to explore both. Notice that
    this `Dockerfile` is defined as a multistage build.
  prefs: []
  type: TYPE_NORMAL
- en: The previous command also added the `launch.json` and `tasks.json` files to
    a new `.vscode` folder in the project. These will be used by VS Code to help it
    define what to do when we ask it to debug our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put a breakpoint in the first `GET` request of the `WeatherForecastController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `.vscode/launch.json` file in the project and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the Docker .NET Core Launch debug configuration and add the snippet
    marked with the red rectangle to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Modifying the Docker Launch configuration](img/B19199_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.33 – Modifying the Docker Launch configuration
  prefs: []
  type: TYPE_NORMAL
- en: The `dockerServerReadyAction` property in the `launch.json` file of a .NET project
    in VS Code is used to specify an action that should be taken when a Docker container
    is ready to accept requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the debug window of VS Code (use *Command* + *Shift* + *D* or *Ctrl*
    + *Shift* + *D* on Linux or Windows to open it, respectively). Make sure you have
    selected the correct debug launch task – its name is Docker .NET Core Launch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.34 – Selecting the correct debug launch task in VS Code](img/B19199_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.34 – Selecting the correct debug launch task in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click the green start button to start the debugger. VS Code will build
    the Docker images, run a container of them, and configure the container for debugging.
    The output will be shown in the terminal window of VS Code. A browser window will
    open and navigate to [http://localhost:5000/wetherforecast](http://localhost:5000/wetherforecast)
    since this is what we defined in the launch configuration (*step 6*). At the same
    time, the breakpoint in the application controller is hit, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.35 – Debugging a .NET Core application running inside a container
    line by line](img/B19199_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.35 – Debugging a .NET Core application running inside a container line
    by line
  prefs: []
  type: TYPE_NORMAL
- en: We can now step through the code, define watches, or analyze the call stack
    of the application, similar to what we did with the sample Node.js application.
    Hit the **Continue** button on the debug toolbar or press *F5* to continue executing
    the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To stop the application, click the red stop button in the debugging toolbar,
    which is visible in the top-right corner of the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know how to debug code running in a container line by line, it is
    time to instrument our code so that it produces meaningful logging information.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting your code to produce meaningful logging information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an application is running in production, it is impossible or strongly discouraged
    to interactively debug the application. Thus, we need to come up with other ways
    to find the root cause when the system is behaving unexpectedly or causing errors.
    The best way is to have the application generate detailed logging information
    that can then be used by the developers that need to track down any errors. Since
    logging is such a common task, all relevant programming languages or frameworks
    offer libraries that make the task of producing logging information inside an
    application straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to categorize the information that’s output by an application
    as logs into so-called severity levels. Here is a list of those severity levels
    with a short description of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Log Level** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| TRACE | Very fine-grained information. At this level, you are looking at
    capturing every detail possible about your application’s behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| DEBUG | Relatively granular and mostly diagnostic information that helps
    you pin down potential problems if they occur. |'
  prefs: []
  type: TYPE_TB
- en: '| INFO | Normal application behavior or milestones, such as startup or shutdown
    information. |'
  prefs: []
  type: TYPE_TB
- en: '| WARNING | The application might have encountered a problem, or you detected
    an unusual situation. |'
  prefs: []
  type: TYPE_TB
- en: '| ERROR | The application encountered a serious issue. This most probably represents
    the failure of an important application task. |'
  prefs: []
  type: TYPE_TB
- en: '| FATAL | The catastrophic failure of your application. The immediate shutdown
    of the application is advised. |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – A list of the severity levels used when generating logging information
  prefs: []
  type: TYPE_NORMAL
- en: Logging libraries usually allow a developer to define different log sinks –
    that is, destinations for the logging information. Popular sinks are file sinks
    or a stream to the console. When working with containerized applications, it is
    strongly recommended that you always direct logging output to the console or `STDOUT`.
    Docker will then make this information available to you via the `docker container
    logs` command. Other log collectors, such as Logstash, Fluentd, Loki, and others,
    can also be used to scrape this information.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting a Python application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s try to instrument our existing Python sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in your terminal, navigate to the project folder and open VS Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `main.py` file and add the following code snippet to the top of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.36 – Defining a logger for our Python sample application](img/B19199_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.36 – Defining a logger for our Python sample application
  prefs: []
  type: TYPE_NORMAL
- en: On line 1, we import the standard logging library. We then define a logger for
    our sample application on line 3\. On line 4, we define the filter for logging
    to be used. In this case, we set it to `WARN`. This means that all logging messages
    produced by the application with a severity equal to or higher than `WARN` will
    be output to the defined logging handlers or sinks, which is what we called them
    at the beginning of this section. In our case, only log messages with a log level
    of `WARN`, `ERROR`, or `FATAL` will be output.
  prefs: []
  type: TYPE_NORMAL
- en: On line 6, we create a logging sink or handler. In our case, it is `StreamHandler`,
    which outputs to `STDOUT`. Then, on line 8, we define how we want the logger to
    format the messages it outputs. Here, the format that we chose will output the
    time and date, the application (or logger) name, the log severity level, and finally,
    the actual message that we developers define in the code. On line 9, we add the
    formatter to the log handler, while on line 10, we add the handler to the logger.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can define more than one handler per logger.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to use the logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s instrument the `hello` function, which is called when we navigate to
    the `/` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.37 – Instrumenting a method with logging](img/B19199_06_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.37 – Instrumenting a method with logging
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, we added line 3 to the preceding snippet,
    where we used the `logger` object to produce a logging message with the `INFO`
    log level. The message is `"Accessing` `endpoint '/'"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s instrument another function and output a message with the `WARN` log
    level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.38 – Generating a warning](img/B19199_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.38 – Generating a warning
  prefs: []
  type: TYPE_NORMAL
- en: This time, we produced a message with the `WARN` log level on line 3 in the
    `colors` function. So far, so good – that wasn’t hard!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the application and see what output we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in your browser, navigate to `localhost:5000/` first and then to `localhost:5000/colors`.
    You should see an output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.39 – Running the instrumented sample Python application](img/B19199_06_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.39 – Running the instrumented sample Python application
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, only the warning is output to the console; the `INFO` message
    is not. This is due to the filter we set when defining the logger. Also, note
    how our logging message is formatted with the date and time at the beginning,
    then the name of the logger, the log level, and finally, the message that was
    defined on line 3 of the snippet shown in *Figure 6**.39*.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done, stop the application by pressing *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve learned how to instrument a Python application, let’s learn how
    to do the same for .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting a .NET C# application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s instrument our sample C# application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to the project folder, from where you’ll open VS Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add a NuGet package containing the logging library to the
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should add the following line to your `dotnet.csproj` project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Program.cs` class and notice that we have the following statement
    on line 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method call, by default, adds a few logging providers to the application,
    among which is the console logging provider. This comes in very handy and frees
    us from having to do any complicated configuration first. You can, of course,
    override the default setting at any time with your own settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `WeatherForecastController.cs` file in the `Controllers` folder
    and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance variable, `logger`, of the `ILogger` type.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor that has a parameter of the `ILogger< WeatherForecastController
    >` type. Assign this parameter to the `logger` instance variable:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.40 – Defining a logger for the Web API controller](img/B19199_06_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.40 – Defining a logger for the Web API controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re ready to use the logger in the controller methods. Let’s instrument
    the `Get` method with an *info* message (line 4 in the following code):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.41 – Logging an INFO message from the API controller](img/B19199_06_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.41 – Logging an INFO message from the API controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a method that implements a `/warning` endpoint right after the
    `Get` method and instrument it (line 4 here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.42 – Logging messages with the WARN log level](img/B19199_06_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.42 – Logging messages with the WARN log level
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the application by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see the following output when in a new browser tab. To do so, we
    must navigate to `localhost:3000/weatherforecast` and then `localhost:3000/warning`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.43 – The log output of our sample .NET application](img/B19199_06_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.43 – The log output of our sample .NET application
  prefs: []
  type: TYPE_NORMAL
- en: We can see the output of our log message, which is of the `info` and `warn`
    types, marked by red arrows. All the other log items have been produced by the
    ASP.NET library. You can see that there is a lot of helpful information available
    if you need to debug the application.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done, end the application with *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned how to instrument code to simplify how we can find
    the root cause of an issue when running in production, next, we will look at how
    we can instrument a distributed application using the Open Tracing standard for
    distributed tracing and then use Jaeger as a tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jaeger to monitor and troubleshoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to monitor and troubleshoot transactions in a complex distributed
    system, we need something a bit more powerful than what we have just learned.
    Of course, we can and should continue to instrument our code with meaningful logging
    messages, yet we need something more on top of that. This *more* is the capability
    to trace a single request or transaction end to end, as it flows through a system
    consisting of many application services. Ideally, we also want to capture other
    interesting metrics, such as the time spent on each component versus the total
    time that the request took.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we do not have to reinvent the wheel. There is battle-tested open source
    software out there that helps us achieve the aforementioned goals. One example
    of such an infrastructure component or softwa[re is Jaeger (https:/](http://www.jaegertracing.io/)
    www.jaegertracing.io/). When using Jaeger, you run a central Jaeger server component
    and each application component uses a Jaeger client that will forward debug and
    tracing information transparently to the Jaeger server component. There are Jaeger
    clients for all major programming languages and frameworks, such as Node.js, Python,
    Java, and .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go into all the intimate details of how to use Jaeger in this book,
    but we will provide a high-level overview of how it works conceptually:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must define a Jaeger tracer object. This object coordinates the whole
    process of tracing a request through our distributed application. We can use this
    tracer object and also create a logger object from it, which our application code
    can use to generate log items, similar to what we did in the previous Python and
    .NET examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we must wrap each method in the code that we want to trace with what Jaeger
    calls a span. This span has a name and provides us with a scope object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at some C# pseudocode that illustrates this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.44 – Defining a span in Jaeger – pseudocode](img/B19199_06_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.44 – Defining a span in Jaeger – pseudocode
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we’re instrumenting the `SayHello` method. With a `using` statement
    creating a span, we’re wrapping the whole application code of this method. We
    have called the span `sayhello`; this will be the ID with which we can identify
    the method in the trace log produced by Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the method calls another nested method, `FormatString`. This method
    will look quite similar to the code needed to instrument it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The span that our tracer object builds in this method will be a child span
    of the calling method. This child span is called `format-string`. Also, note that
    we are using the logger object in the preceding method to explicitly generate
    a log item of the `INFO` log level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.45 – Creating a child span in Jaeger – pseudocode](img/B19199_06_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.45 – Creating a child span in Jaeger – pseudocode
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code included with this chapter, you can find a complete sample application
    written in Java and Spring Boot consisting of a Jaeger server container and two
    application containers called `api` and `inventory` that use the Jaeger client
    library to instrument the code. Follow these steps to rebuild this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the [`api`, as follows:](https://start.spring.io)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[](https://start.spring.io)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Figure 6.46 – Bootstrapping the API component of the Jaeger sample](img/B19199_06_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.46 – Bootstrapping the API component of the Jaeger sample
  prefs: []
  type: TYPE_NORMAL
- en: Note how we are using Spring Boot 2.7.7 for this example since, at the time
    of writing, the Jaeger and Open Tracing integration does not yet work with Spring
    Boot 3\. Also, note how we have added the Spring Web reference to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Click `api.zip` will be downloaded to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the same steps but this time change the `inventory`. Then, click `inventory.zip`
    containing the bootstrap code will be downloaded to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the source folder for this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a subfolder called `jaeger-demo` in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Extract the two ZIP files into the `jaeger-demo` folder. Make sure the subfolders
    are called `api` and `inventory`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open VS Code from within this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a `docker-compose.yml` file in the root with this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.47 – The Docker Compose file for the Jaeger demo](img/B19199_06_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.47 – The Docker Compose file for the Jaeger demo](https://start.spring.io)
  prefs: []
  type: TYPE_NORMAL
- en: '[We will explain what a `docker-compose` file is in detail in](https://start.spring.io)
    [*Chapter 11*](B19199_11.xhtml#_idTextAnchor237), *Managing Containers with* *Docker
    Compose.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Jaeger with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a new browser t[ab, navigate to the Ja](http://localhost:16686)eger UI at
    `http://localhost:16686`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the two `pom.xml` files for the `api` and `inventory` projects in your
    VS Code. Add the Jaeger integration component to each file by adding this snippet
    to their `dependencies` sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.48 – Adding integration with Jaeger to the Java project(s)](img/B19199_06_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.48 – Adding integration with Jaeger to the Java project(s)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `inventory` project, locate the start class, `InventoryApplication`,
    and add a bean to it that generates an instance of `RestTemplate`. We will use
    this to access an external API to download some data. The code snippet should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do the same for the start class of the `api` project, called `ApiApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s go back to the `inventory` project. Add a new file called `Todo.java`
    as a sibling next to the start class. The file will have the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.49 – The Todo class in the api project for the Jaeger demo](img/B19199_06_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.49 – The Todo class in the api project for the Jaeger demo
  prefs: []
  type: TYPE_NORMAL
- en: This is a really simple POJO class that we are using as a data container.
  prefs: []
  type: TYPE_NORMAL
- en: Do the same in the `api` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `inventory` project and add a new file called `TodosController.java`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.50 – The TodosController class for the Jaeger demo](img/B19199_06_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.50 – The TodosController class for the Jaeger demo
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, on line 19, we reach out to the public **JSONPlaceholder API** to
    download a list of todo items and return those items to the caller on line 20\.
    There’s nothing fancy here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `api` project, add a new file called `HelloController.java` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.51 – The HelloController class for the Jaeger demo](img/B19199_06_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.51 – The HelloController class for the Jaeger demo
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the first method, which is listening on the `/hello` endpoint, just
    returns a string. However, the second endpoint, which is listening on the `/todos`
    endpoint, reaches out to the `api` service and its endpoint, `/api/todos`. The
    `api` service will send back the list of todos that it downloaded from the JSON
    Placeholder API. This way, we have a real distributed application ready to demonstrate
    the power of Jaeger and Open Tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not quite done yet. We need to configure both projects via their respective
    `applications.properties` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `application.properties` file in the `api` project and add the following
    line to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines the name of the service and how Jaeger will report
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the same file in the `inventory` project and add the following two lines
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line makes sure the inventory service is listening at port `8090`
    and not at the default port of `8080` to avoid any conflict with the `api` service,
    which will run on the default port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second line defines the name of the service and how Jaeger will report it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the `inventory` and `api` projects from within VS Code by clicking
    the `main` methods of their respective start classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl` or Thunder Client to access the expo[sed endpoint of the inventory
    s](http://localhost:8090/api/todos)ervice at `http://localhost:8090/api/todos`.
    You can also do the same in a new browser tab. You should receive a list of 100
    random todo items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ne[xt, try to access the `api` s](http://localhost:8080/api/todos)ervice at
    the `http://localhost:8080/todos` endpoint. The same list of todos should be returned,
    but this time, they should originate from the `api` service and not directly from
    the JSON Placeholder API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go back to the browser tab where you opened the Jaeger UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you are on the **Search** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Services** drop-down list, select **jaeger-demo:api**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Find Traces**. You should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.52 – Jaeger trace for the api service](img/B19199_06_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.52 – Jaeger trace for the api service
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the trace to expand it. You should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.53 – Details of the Jaeger trace for the api service](img/B19199_06_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.53 – Details of the Jaeger trace for the api service
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see how the call is reaching out from the `api` service to the
    `inventory` service. We can also see the time that’s been spent on each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean up, stop the Jaeger server container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, stop the API with *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this demo, we saw that without any special code, by just adding a component
    that integrates our Spring Boot applications with Jaeger and Open Tracing, we
    have gained a lot of insight. However, we’re only just scratching the surface
    of what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '`api` and `inventory` services using a similar `Dockerfile` for each, as we
    did in the Java demo application earlier in this chapter. The respective `Dockerfile`
    should be in the root of the `api` and `inventory` projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, amend the `docker-compose.yml` file. When you’re done, run the whole
    application with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if you’re not familiar with Docker Compose yet. We will discuss
    this very useful tool in [*Chapter 11*](B19199_11.xhtml#_idTextAnchor237),*Managing
    Containers with* *Docker Compose*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to run and debug Node.js, Python, Java, and
    .NET code running inside a container. We started by mounting the source code from
    the host into the container to avoid the container image being rebuilt each time
    the code changes. Then, we smoothed out the development process further by enabling
    automatic application restarts inside the container upon code changes. Next, we
    learned how to configure VS Code to enable full interactive code debugging when
    code is running inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how we can instrument our applications so that they generate
    logging information that can help us do root cause analysis on failures of misbehaving
    applications or application services running in production. We started by instrumenting
    our code using a logging library. Then, we used the Open Tracing standard for
    distributed tracing and the Jaeger tool to instrument a Java and Spring Boot application
    and gain valuable insight into the application’s inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to show you how using Docker containers can
    supercharge your automation, from running a simple automation task in a container
    to using containers to build a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to answer the following questions to assess your learning progress:'
  prefs: []
  type: TYPE_NORMAL
- en: Name two methods that help reduce the friction in the development process that’s
    introduced by using containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you achieve live code inside a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why would you debug code line by line when running inside a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is instrumenting code with good debugging information paramount?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible answers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Volume-mount your source code in the container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a tool that automatically restarts the app running inside the container
    when code changes are detected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure your container for remote debugging
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mount the folder containing the source code on your host in the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you cannot cover certain scenarios easily with unit or integration tests
    and if the observed behavior of the application cannot be reproduced when the
    application runs on the host. Another scenario is a situation where you cannot
    run the application on the host directly due to a lack of the necessary language
    or framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once an application is running in production, we cannot easily gain access to
    it as developers. If the application shows unexpected behavior or even crashes,
    logs are often the only source of information we have to help us reproduce the
    situation and pinpoint the root cause of the bug.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
