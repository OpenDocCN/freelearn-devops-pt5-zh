- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying to Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this fourth chapter, we are going to look at getting our project deployed
    with the first of the two major public cloud providers we are going to cover in
    this book, **Microsoft Azure**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing our cloud environment for deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing the low-level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform – writing the code and deploying our infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible – reviewing the code and deploying our infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will delve into the world of Microsoft Azure, beginning with an introduction
    to the platform, its key features, and the benefits it offers for cloud-based
    application deployment. We will also explore the different services available
    within Azure and how they fit into our architectural design for our WordPress
    workload.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we will build on our Terraform knowledge and work through the
    code needed to provision and manage our Azure cloud infrastructure. Lastly, we
    will explore Ansible, another essential tool for automating infrastructure deployment
    and configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained an understanding of Microsoft
    Azure and its various components and be equipped with the skills necessary to
    deploy and manage your applications on this cloud platform using Terraform and
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the amount of code needed to deploy our project, when it comes to the
    Terraform and Ansible sections of the chapter, we will not cover every piece of
    code needed to deploy the project. The code repository accompanying this title
    will contain the complete executable code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing and preparing our cloud environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 2008, Microsoft unveiled Windows Azure, a cloud-based data center service
    that had been in development under the internal project name *Project Red Dog*.
    This service included five core components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft SQL Data Services**, a cloud version of the SQL database, which
    aimed to simplify hosting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft .NET Services**, a **Platform as a Service** (**PaaS**), allowed
    developers to deploy their .NET-based applications in a Microsoft-managed runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft SharePoint and Dynamics**, **Software as a Service** (**SaaS**)
    versions of the company’s intranet and customer relationship management products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Azure** is an **Infrastructure-as-a-Service** (**IaaS**) offering
    that enables users to create virtual machines, storage, and networking services
    for their compute workloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the services provided by Microsoft as part of Windows Azure were built upon
    the Red Dog operating system, a specialized version of their Windows NT operating
    system, which had been specifically designed to include a cloud layer to support
    the delivery of data center services.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, the company decided to rebrand the service as Microsoft Azure; as they
    added services, it made sense for them to drop the Windows branding, especially
    as there was a growing number of Linux-based workloads being hosted on the platform.
    This trend continued over the following years, and by 2020, it was reported that
    more than half of Azure’s virtual machine cores and a significant proportion of
    Azure Marketplace images were Linux-based, demonstrating Microsoft’s increasing
    embrace of Linux and open source technologies as the building blocks for some
    of their now core services.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some background knowledge of Microsoft Azure, let’s start preparing
    the cloud environment for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our cloud environment for deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will run the Terraform and Ansible scripts
    locally on our own machine – this makes the deployment a little easier as we will
    be able to piggyback off a signed-in session using the Azure **Command-Line Interface**
    (**CLI**). For details on how to install this, please see the official documentation
    at [https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, make sure you are signed into the account where you would like
    the resources to be deployed; you can do this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, follow the on-screen prompts; if you are already logged in, then you
    can double-check the details of your current login by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our environment prepared, we can now look at the services we
    are going to be deploying.
  prefs: []
  type: TYPE_NORMAL
- en: Producing the low-level design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the deployment we discussed in [*Chapter 3*](B19537_03.xhtml#_idTextAnchor130),
    *Planning the Deployment*, we know we are going to need the following resources
    to run our workload on Microsoft Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – An overview of the resources we are going to launch in Azure](img/Figure_4.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – An overview of the resources we are going to launch in Azure
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Load Balancer**: This is a TCP load balancer as a service – while I
    would have preferred to use **Azure Application Gateway** to terminate our HTTP/HTTPS
    connections, that would have added a little too much complexity to our build for
    this stage of the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual Network**: The core networking service our services will be both
    deployed into or configured to be accessible from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual machine**: We will use a single **Linux virtual machine** as our
    WordPress admin instance – this will be responsible for the initial bootstrapping
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual Machine Scale Set**: This is similar to the Linux virtual machine,
    but this service is designed to manage one to many virtual machines from a single
    resource, allowing us to scale out if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Storage Account/Azure Files**: Our WordPress files will be stored in
    an NFS share, which is only accessible to trusted IP addresses within our Virtual
    Network where our virtual machine and Virtual Machine Scale Set instances are
    running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Database for MySQL - Flexible Server**: Our WordPress installation
    needs a database server; as we are running in a public cloud, a **Database-as-a-Service**
    (**DBaaS**) option makes sense. This service will make a MySQL server and database
    accessible within our Virtual Network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also other services such as **Azure Private DNS**, **private endpoints**,
    **network security groups**, and **public IPs** within the solution to support
    securely accessing the core services we will launch within the Virtual Network.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the services we are launching, we can dive into writing our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform – writing the code and deploying our infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know which services we are going to deploy, we can make a start
    on our Terraform deployment. To make things more manageable, I will split our
    code into several files; they will be named the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`001-setup.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`002-resource-group.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`003-networking.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`004-storage.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`005-database.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`006-vm-admin.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`007-vmss-web.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`098-outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`099-variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vm-cloud-init-admin.yml.tftpl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmss-cloud-init-web.tftpl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have done this to more logically group all the functions around a certain
    part of the deployment code together; for example, all of the networking elements
    can be found in the `003-networking.tf` file and the variables used in the `099-variables.tf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of this chapter, what follows is not 100% of the code
    contained within each of the files, and I will be referencing blocks out of the
    `variables` file in line with blocks from other files.
  prefs: []
  type: TYPE_NORMAL
- en: Without further delay, let’s look at the Terraform code, starting with the setup
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Terraform environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first things we need to do is set up our Terraform environment for
    our deployment. To do this, we need to confirm which version of Terraform to use
    and which providers to download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a configuration block for one of the providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While we are not putting any custom configuration in there, it must be present
    to progress with the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we come to the first task, which uses a module from the **Terraform
    Registry** to come up with all the Microsoft-defined variations of a region name,
    full name, short name, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the module and pass it is the region variable, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `var.location` variable we use is defined in the `099-variables.tf` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting `default` as `West Europe`; don’t worry, if you
    don’t want to launch your resources in that region, we will cover overriding the
    variables when executing the deployment in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350),
    *Building upon* *the Foundations*.
  prefs: []
  type: TYPE_NORMAL
- en: And that covers the `001-setup.tf` file, now that we have all the basics in
    place, we can move on to creating the **resource group**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a resource group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in earlier chapters, my day job sees me doing a lot of work in
    Microsoft Azure, and one of the things I adhere to is the **Cloud Adoption Framework**.
    This is a sensible documented set of recommendations around deploying resources
    into Microsoft Azure, which includes a naming scheme. Accordingly, one of the
    providers we are using helps dynamically create Azure resource names based on
    the information we pass it; we will use this throughout the deployment, as one
    of the provider’s goals is to introduce naming consistency for nearly all of the
    resources we are going to deploy. The code to generate the name of the resource
    group looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are passing several bits of information – three variables
    and dynamically generated bits of information, namely the following two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And also, we are using the output Azure Region module, which will provide a
    short name of whichever region we define in our `variables` file at `099-variables.tf`.
    This is referenced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The other important information we are passing is `resource_type`, which in
    our case, is `azurerm_resource_group`. This will give us an output that looks
    like the following figure, which we can then pass on to our next resource block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Naming our resource group](img/Figure_4.02_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Naming our resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the resource name, we can go ahead and define the resource
    group block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we reference `azurecaf_name.resource_group.result` as the name
    of the resource, and we also use another variation of the region name by using
    `module.azure_region.location_cli`, which will output the name as `westeurope`
    rather than `West Europe` or `euw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final variable we pass in is for `map` rather than `string`. This looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is used throughout the deployment and will add three different tags, `project`,
    `environment`, and `deployed_by`, to each of the resources that use them. This
    is the simplest form of map we will use and is simply a list of keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Things will get a little more complicated with maps as we move on to the next
    section, which is *Networking*, as we start to use maps to introduce a little
    logic into our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as naming all of the resources using the `azurecaf_name` provider,
    we are going to configure and launch the following resources in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Virtual Network**, where we will configure the primary network resource,
    along with three subnets – which is where things start to get complicated with
    the maps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Load Balancer**, as well as the resource itself, we will configure
    a public IP address, backend pool, health probe, and two types of rules – load
    balancing and NAT; there will be more on this later in the section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The network security group**, with two rules to allow secure access to our
    services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dive into something more exciting and look at the Azure Virtual Network.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Virtual Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first part of configuring our underlying network is the Virtual Network
    resource itself. To do this, there are two main variables we are going to use;
    the first is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As can see, this defines the address space we are going to use for the Virtual
    Network as a list containing a single value; this is then called in the following
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too out of the ordinary on the face of it. To ensure that the Virtual
    Network is created after the resource group has been created, by passing in the
    dynamically generated name, the default tags, and the list of address spaces,
    which in our case only contains a single item, we use the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azurerm_resource_group.resource_group.name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azurerm_resource_group.resource_group.location`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second variable is where we define the subnet and is also where things
    get interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines what variables are needed for each of the subnets,
    while the following code sets the default settings that we will use in our deployment,
    starting with the subnet for the virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second subnet will be used for the private endpoints we will deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The third and final subnet we are going to need is the one used for the `database`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a lot is happening here, so let’s break it down a little.
  prefs: []
  type: TYPE_NORMAL
- en: What we are defining here is a map that contains several objects; those objects
    are strings, a Boolean, a list, and finally, a map made up of a map, which contains
    a list of strings!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start simple and look at how we will name the subnets. To do this, we
    use a `for_each` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes the `subnet_name` value from each of our three maps and creates
    three resource names; the following names will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`snet-endpoints-iac-wordpress-prod-euw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snet-vms-iac-wordpress-prod-euw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snet-database-iac-wordpress-prod-euw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will take a similar approach by using a `for_each` loop to create the subnets,
    but this time more of the information in the map object. The code block to create
    the subnets looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As already mentioned, we use the `for_each` argument to iterate over the elements
    in the `vnet_subnets` map. We set the `name` property using the results of the
    `azurecaf_name` loop; each of the three names is referenced using the key, which
    in the map would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual_network_subnets_001`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtual_network_subnets_002`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtual_network_subnets_003`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although, in this instance, we do not have to hardcode each of these values
    so we can use `azurecaf_name.virtual_network_subnets[each.key].result`. The `resource_group_name`
    property is set using the output of `azurerm_resource_group`. The `address_prefixes`
    property is set to a list containing the `address_prefix` value for the current
    subnet’s `vnet_subnets` key.
  prefs: []
  type: TYPE_NORMAL
- en: The `service_endpoints` property is set to the corresponding value for the current
    subnet if it is provided. If the value is not provided, an empty list is used
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `private_endpoint_network_policies_enabled` property is set to
    the corresponding value for the current subnet if it is provided. If the value
    is not provided, an empty list is used instead. Finally, the code includes a nested
    loop over the `service_delegations` property of the current subnet.
  prefs: []
  type: TYPE_NORMAL
- en: A **dynamic block** is a setting block that is evaluated at runtime, allowing
    you to add blocks based on the values of input variables and also outputs from
    other tasks within the Terraform code. Dynamic blocks are helpful when you need
    to create a variable number of blocks based on data that is known only at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic block creates a `delegation` block for each element in the `service_delegations`
    map. The `iterator` argument is set to `item`, representing the current element
    being processed, and the `content` block creates a `service_delegation` block
    with the key as the name and the value as the actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea of what this looks like, if we were to manually define
    the `virtual_network_subnets_002` and `virtual_network_subnets_003` map objects,
    they would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, while it looks complicated, it is an excellent way of writing
    less code with hardcoded values, which makes the block easily reusable.
  prefs: []
  type: TYPE_NORMAL
- en: We will reference the output of the `for_each` loops when we add our network
    security group, and also when we start to attach resources to our subnets when
    we launch resources and place them in the subnets we have just defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next lot of blocks launch and configure the Azure Load Balancer service;
    there is not much going on here that we haven’t already covered, but here is a
    quick overview of each of the blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurerm_public_ip" "load_balancer"` creates a public IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_lb" "load_balancer"` launches the load balancer itself and attaches
    the public IP address we just launched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_lb_backend_address_pool" "load_balancer"`, creates a backend pool;
    when we launch our virtual machine and Virtual Machine Scale Set instances, we
    will attach them to this backend pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_lb_probe" "http_load_balancer_probe"` adds a health probe to check
    that port `80` is open and accessible via a simple TCP test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_lb_rule" "http_load_balancer_rule"` creates a rule to evenly distribute
    incoming requests on port `80`, i.e., HTTP requests, across the instances in the
    backend pool if they are showing as healthy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_lb_nat_rule" "sshAccess"` creates a rule that dynamically maps `2222`
    > `2232` to port `22` on the backend instances, giving us SSH to each of the instances
    in the backend pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final few tasks to do with the network are to create and configure a network
    security group; there is not much going on with the first few tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurerm_network_security_group" "nsg"` creates the network security group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_network_security_rule" "AllowHTTP"` adds a rule to the network security
    group we just created to allow HTTP access on port `80`; this will be open to
    everyone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we need to add a rule to allow SSH access to our hosts, but SSH is not
    a service that you would want to expose to the whole of the internet – even if
    we are going to access the instances using a non-standard port (remember we are
    using a NAT rule on Azure Load Balancer to map ports `2222` > `2232` to port `22`
    on the instances). So, we are going to use a data source to get the public IP
    address of the host that is currently running Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block to get the current IP address uses the HTTP Terraform provider and
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are calling the [https://api.ipify.org/?format=json](https://api.ipify.org/?format=json)
    URL, which returns a blob of JSON containing your current public IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then take this blob and combine this with the `network_trusted_ips`
    variable, which is empty by default, containing a list of other trusted IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the JSON containing our IP address and an optional list of
    other IP addresses we want to allow, we can create the rule itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, everything is happening in the `source_address_prefixes` entry;
    here, we use the built-in `setunion` function, which merges the content of `var.network_trusted_ips`
    – in our case, an empty list – and the JSON returned in the body of the request
    we made using the HTTP provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have updated the relevant code slightly to make it a little easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are using `var.network_trusted_ips` as it is because that is already defined
    as a list; however, our IP address isn’t, so we create a list using `[ ]` and
    then add an inline variable in Terraform; this is defined using `${ something
    here }`. `something here`, in our case, uses the built-in `jsondecode` function,
    which takes the body of the response that is held in `data.http.current_ip.response_body`
    and the value of the `ip` key, which is our public IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our network security group, we need to attach it to the subnet,
    which will host the virtual machine and Virtual Machine Scale Set instances. To
    do this, we need the ID of the subnet. To make this simple, I have created three
    variables with the name of the objects of each of the subnet maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know the name of the object, which is the key name, we can use
    this in the block that associates the network security group with the subnet hosting
    the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the network portion of the deployment, and we now have the underlying
    base to start deploying resources into, starting with storage.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to create a storage account with NFS enabled; most of these tasks are
    pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "sa"` generates the name of the storage account; there is
    a slight difference in that we are telling it to add a random string – we are
    doing this because storage account names must be unique across Azure, so if we
    didn’t add this, the code might error depending on who else has already executed
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "sa_endpoint"` takes the previous result and then generates
    a name for the private endpoint, which will be placed in the Virtual Network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_storage_account" "sa"` creates the storage account itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now need to lock the storage account down so that only the three subnets
    in our Virtual Network and our trusted IP addresses have access – to do this,
    we use a block that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the IP rules use the same logic we employed when adding our
    public IP address to the network security group rule to allow us access to the
    instances using SSH access from a trusted IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The part of the block to get the subnet IDs uses a `for` loop to iterate over
    the `azurerm_subnet.vnet_subnets` list, and for each subnet in the list, it extracts
    the `id` attribute of the subnet and adds it to the list of `virtual_network_subnet_ids`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the network rules in place for the storage account, we can add
    the NFS share itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are use `depends_on` to ensure that the network rules are
    configured. We must declare `depends_on` as there is no output we can reference
    from `"azurerm_storage_account_network_rules" "sa"` when executing `"``azurerm_storage_share"
    "nfs_share"`.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: We will use small number of `depends_on` in the deployment. However, it is considered
    a best practice to keep its usage to a minimum and let Terraform figure out the
    dependencies as much as possible, as overuse of `depends_on` can slow down execution.
  prefs: []
  type: TYPE_NORMAL
- en: The keen-eyed among you may have also noticed that we are doing something different
    when naming this resource; we use the built-in `replace` function, taking the
    contents of the `var.name` variable and stripping out any hyphens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining tasks are all pretty basic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurerm_private_dns_zone" "storage_share_private_zone"` creates a private
    DNS zone for `privatelink.file.core.windows.net`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_private_dns_zone_virtual_network_link" "storage_share_private_zone"`
    takes the private DNS zone we created and attaches it to our Virtual Network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_private_endpoint" "storage_share_endpoint"` creates the private endpoint,
    putting in the subnet defined in the `var.subnet_for_endpoints` variable and registering
    it with the private DNS zone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes the storage; next up, we have the database service.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now starting to get into the stride of things as we come to launch our
    database service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "mysql_flexible_server"` generates the name of the Azure MySQL
    Flexible Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "database"` generates the name of the database we will use
    for WordPress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_private_dns_zone" "mysql_flexible_server"` adds the private DNS zone
    we will use for our Azure MySQL Flexible Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_private_dns_zone_virtual_network_link" "mysql_flexible_server"` registers
    the private DNS with our Virtual Network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we launch the **Azure MySQL Flexible Server**, there is one more thing
    we need to do, and that is to create a password. Rather than passing this using
    a variable, we can use the random provider to generate one based on the parameters
    we provide programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block will generate a random password 16 characters long and
    not use any special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There isn’t too much out of the ordinary with the remaining blocks we use to
    launch and configure our Azure MySQL Flexible Server instance; what follows is
    a brief summary of what each of the blocks does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurerm_mysql_flexible_server" "mysql_flexible_server"` launches the flexible
    server; we use `depends_on` here to ensure that the DNS zone is registered with
    the Virtual Network; otherwise, we could get an error when it came to creating
    the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_mysql_flexible_server_configuration" "require_secure_transport"`
    changes the Azure MySQL Flexible Server parameter to allow non-TLS connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_mysql_flexible_database" "wordpress_database"` creates a database
    hosted on the Azure MySQL Flexible Server; once the parameter has been updated,
    we use `depends_on` to achieve this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our Azure MySQL Flexible Server instance configured and connected
    to the Virtual Network, we are ready to launch our admin virtual machine instance.
  prefs: []
  type: TYPE_NORMAL
- en: The admin virtual machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The admin virtual machine is going to be a single Linux virtual machine instance,
    which will be used to bootstrap our WordPress installation. Firstly, there are
    no new techniques used here, so rather than go into detail, here is an overview
    of what each of the blocks does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "admin_vm"` generates the name of the virtual machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "admin_vm_nic"` generates the name of the network interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_network_interface" "admin_vm"` creates the network interface resource,
    attaching it to the subnet defined in the `var.subnet_for_vms` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"random_password" "wordpress_admin_password"` generates a random password
    for the WordPress admin area – this time, using special characters apart from
    `_%@`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"random_password" "vm_admin_password"` generates the password for the virtual
    machine instances; this time, it’s a little more complicated as virtual machines
    have password strength requirements, so we are going to generate a 16-character
    password with a minimum of two uppercase and two lowercase letters, two special
    characters, excluding `!@#$%&`, and also numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next task, `"azurerm_linux_virtual_machine" "admin_vm"`, launches the virtual
    machine itself, and for the most part, there isn’t much interesting going on with
    it apart from the section where we pass in `user_data`, which is where the `cloud-init`
    script is generated and passed over to Azure to inject when the virtual machine
    is launched. This part of the block looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let us dig into what is going on here a little bit more. First off, we need
    to pass the `cloud-init` script as Base64-encoded; luckily, Terraform has the
    `base64encode` function we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Base64 is a way to encode data into a continuous string of ASCII text; it helps
    post-multi-line scripts or binary data to APIs. It is not a secure way to encode
    data since it can be easily decoded and does not provide any form of encryption.
    If we were to encode `Hello, world!`, it would be encoded as `SGVsbG8sIHdvcmxkIQ==`
    in Base64\. `==` at the end is added to pad the string and make it a multiple
    of four characters since Base64 encoding works with blocks of four characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part uses Terraform’s native `templatefile` function to read a file,
    which in our case, is called `vm-cloud-init-admin.yml.tftpl`. Once that has been
    defined, we pass a list of variables to use within the template and their values
    – here we are passing in details of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Azure MySQL Flexible Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure Files hosted NFS share
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL, which is made up of the public IP address of Azure Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our WordPress installation information, which we have defined as variables in
    our main `variables` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To save confusion, I am prefixing each of the variables we are passing into
    the template file with `tmpl`; this is not a requirement, but I find it helpful
    to distinguish between variables I can use in the main Terraform blocks and ones
    used within the templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'An abridged version of the `cloud-init` template file is given in the following
    code block; it contains the bits that mount the NFS share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax for referencing the variables is slightly different
    from the main Terraform blocks, as we do not have to reference them as a variable
    with `${var.something}` and instead can just use `${something}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fully rendered file is then passed to the virtual machine, and the script
    executes once the virtual machine boots. The full `cloud-init` file performs the
    following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Updates all installed packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs the packages we need to run WordPress – for example, Apache2, PHP,
    and the NFS and MySQL client software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounts the NFS share and adds a line to `/etc/fstab` so it mounts automatically
    after the instance reboots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs the WordPress command-line client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets up the correct permissions on the folders where we will be installing WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloads the latest version of WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a `wp-config.php` file populated with the details of our Azure MySQL
    Flexible Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs WordPress itself using the variables we passed in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweaks the Apache configuration and restarts the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once these steps have been completed, we should have a working WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: A Web Virtual Machine Scale Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have our admin virtual machine instance bootstrapped, we can launch
    a Virtual Machine Scale Set to act as web servers. As we already have a WordPress
    installation running and all the files needed to serve the website on the NFS
    share, these instances only need to have the basic software stack configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as most of the heavy lifting has already been completed, this should
    be straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "web_vmss"` generates the name of the Virtual Machine Scale
    Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurecaf_name" "web_vmss_nic"` generates the name of the network interface
    used by the virtual machine scale set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"azurerm_linux_virtual_machine_scale_set" "web"` creates the virtual machine
    scale set itself; this is in line with the admin virtual machine we launched,
    and we are reusing many of the same variables, with the notable addition of `var.number_of_web_servers`,
    which defines the number of server instances to launch. We are also using a cutdown
    version of the `cloud-init` script called `vmss-cloud-init-web.tftpl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes launching and configuring our Azure resource; there is just a
    small number of blocks left before we are finished.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final file outputs some helpful information about our deployment. As some
    of the output includes information, for example, the results of `random_password`,
    we will need to mark that part of the output as `sensitive`, as we don’t want
    our randomly generated password to be visible when logging our output, which is
    being printed to the screen, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an understanding of what the Terraform code is going to do,
    we can now run it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To deploy the environment, we simply need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When you run the `terraform plan` command, it will give you an overview of what
    resources are going to be deployed, as well as some very basic error-checking
    to make sure that everything is in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the output of the plan, then you can proceed with the deployment
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon completion, you should see something like the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The finished Azure deployment](img/Figure_4.03_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The finished Azure deployment
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the two password outputs have been marked as `sensitive`, but
    we have the URL of the WordPress installation. Now, let’s dive straight into the
    WordPress admin portal, open the URL you have been given in your browser, and
    append `wp-admin` at the end of the URL. For example, for me, the URL was `http://20.23.249.255/wp-admin`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All URLs and passwords used in this chapter have long since been terminated
    and are not valid; please use the details from your own deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should give you a login page that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The WordPress login screen](img/Figure_4.04_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The WordPress login screen
  prefs: []
  type: TYPE_NORMAL
- en: We know that the username for WordPress is `admin`, as we have that set as a
    variable, but how about that password? Well, by default, Terraform will always
    display `sensitive` when you run the `terraform output` command; however, appending
    `-json` at the end of that will give you the full output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the output of me running `terraform output -json` in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Accessing the passwords](img/Figure_4.05_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Accessing the passwords
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon entering the username and password, you should be greeted by the WordPress
    dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The WordPress dashboard](img/Figure_4.06_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The WordPress dashboard
  prefs: []
  type: TYPE_NORMAL
- en: You can also go to the Azure portal and check the resources there; you should
    be able to find them in the `rg-iac-wordpress-prod-euw` resource group (assuming
    that you have kept the variables at their defaults and have not updated them;
    if you have, then you will need to find the group that matches your updates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished, please don’t forget to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, you will incur costs for running resources if you have followed along
    and launched the environment in your own account.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible – reviewing the code and deploying our infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have covered Terraform in detail in this chapter, we will only quickly
    review the Ansible code here as we will go into a lot more detail on an Ansible
    deployment in the next chapter, [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon* *Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Terraform, the Ansible code is split into roles; this makes our `site.yml`
    file look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we load two variable files from the `group_vars` folder and calling eight
    different roles. As we have already discussed, Ansible will execute its tasks
    in the order we call them, so the ordering of the roles is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Playbook roles overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive straight in and look at the first role that is called in the `site.yml`
    file. The **randoms** role has a single function: randomly generating all the
    variables we will need for the deployment. However, this is where we hit our first
    significant difference between Ansible and Terraform. As Ansible is stateless,
    once it has generated a random value and the Ansible execution has stopped, it
    will instantly forget about it. This means that when we next execute our playbook,
    it will regenerate the random values, which, as we are using them in resource
    definitions, could cause a new resource to be launched.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is create a file that contains all the random values, but
    if there is already a file there, then continue without updating them – the process
    we need to follow is visualized in the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Do we need to create a secrets.yml variable file?](img/Figure_4.07_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Do we need to create a secrets.yml variable file?
  prefs: []
  type: TYPE_NORMAL
- en: So, what does this look like as Ansible tasks?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the built-in `stat` module to check for the presence
    of a file in the `group_vars` called `secrets.yml`. We then register the results
    of this task as a variable called `secrets_file`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `secrets_file` variable we registered when the `secrets.yml`
    file doesn’t exist on your filesystem, which it should do, as we are going to
    create the file shortly, look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is a single output called `exists`, which is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our next task will generate the `secrets.yml` file if `exists` is set to
    `false` and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the last line, the task will only run when `secrets_file.stat.exists`
    is equal to `false`; if it returns `true`, then the task will be skipped, as we
    do not need to generate the `secrets.yml` file again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task itself uses the `template` function to take the source template, which
    looks like the following, process it, and then output the rendered output to `group_vars/secrets.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The template uses the `lookup` function to call the `random_string` module to
    generate a short random hash for resource names and various passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While this method works for our deployment, you should look at something more
    secure for a production environment – for example, dynamically loading the secret
    values from a remote key management store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the file is there, as we have just generated it, we can load
    the contents of the file in as variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that our variables are loaded, we can progress with the rest of the playbook
    run.
  prefs: []
  type: TYPE_NORMAL
- en: The resource group role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `azurecaf_name` provider we used in Terraform. Because of this, we have
    defined all the resource names in the `group_var/azure.yml` file using various
    variables and hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual Network role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several tasks in this role, a lot of which use some concepts we have
    yet to cover but will go into more detail in [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon* *Web Services*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_virtualnetwork` creates the Virtual Network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_subnet` loops through and creates the subnets
    that don’t have `database` in the name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_subnet` loops through and creates the subnets
    that have `database` in the name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.general.ipify_facts` gets the current IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.set_fact` takes the preceding output and registers it as a
    fact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.tempfile` creates an empty temporary file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.template` dynamically generates the network security group
    tasks from a template file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.include_tasks` loads and executes the network security group
    tasks we just generated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_publicipaddress` creates a public IP address for
    use with the load balancer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_loadbalancer` creates a load balancer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have all the underlying networking, we can launch the rest of the
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Storage roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tasks executed by this role are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_resourcegroup_info` gets information on the resource
    group we have created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.set_fact` uses some regular expressions to extract the subscription
    ID from the resource group ID and set a fact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.tempfile` generates a temporary file, which will be used for
    the variables for the storage account rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.template` dynamically generates the variables containing the
    storage account network rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.include_vars` loads the variables we just generated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_storageaccount` creates the storage account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_resource` creates the NFS share'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privatednszone` creates a private DNS zone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privatednszonelink` links the private DNS zone
    to our Virtual Network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_subnet_info` gets information on the endpoint
    subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_storageaccount_info` gets info on the storage
    account we just created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privateendpoint` creates a private endpoint using
    all of the information we have just gathered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privateendpointdnszonegroup` attaches the private
    endpoint to the private DNS zone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While that all seems straightforward, the keen-eyed among you may have noticed
    something which appears a little out of place.
  prefs: []
  type: TYPE_NORMAL
- en: When it came to creating the NFS share, the task we used was called `azure.azcollection.azure_rm_resource`,
    even though there is a module called `azure.azcollection.azure_rm_storageshare`;
    what gives?
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the `azure.azcollection.azure_rm_storageshare` module
    does not support the creation of NFS file shares on an Azure Storage account.
    So instead, we dynamically generate a payload and send it to the Azure Resource
    Manager REST API to create the resource. We will look at this in a little more
    detail in the next role.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Flexible Server for MySQL is another Azure service that doesn’t have a
    native Ansible module, so we are going to have to use the REST API to not only
    create the server but also set the `require_secure_transport` parameter and create
    our WordPress database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing any of that, though, we need to create the DNS resources and gather
    a few bits of information on the networking resources we have already launched;
    the following tasks do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privatednszone` creates the private DNS zone for
    the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privatednszonelink` attaches the DNS zone we just
    created to the Virtual Network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_privatednszone_info` gets information on the private
    DNS we just created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_subnet_info` gets information on the subnet we
    have created purely for use with the Azure Flexible Server for MySQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have all the resources and information we need to create the Azure Flexible
    Server for MySQL. The task for doing this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the task, from `api_version` down to `body`, is used to construct
    the URL that we will call. The keys listed under `body` are the parameters and
    options that will be posted to the API endpoint URL, which we have dynamically
    created. The URL we will be posting to looks something like `https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DBforMySQL/flexibleServers/{serverName}?api-version=2021-05-01`.
  prefs: []
  type: TYPE_NORMAL
- en: Simple enough, you may think, but there is quite a large piece of logic that
    Ansible would typically take care of, which we now have to consider for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Ansible is just posting to the REST API, assuming the request is valid,
    it will get a `200` response back to say that the request was successful; it doesn’t
    wait until the resource has been launched before `200` is returned, meaning that
    Ansible will happily move on to the next task, which will fail in our deployment
    because we are immediately making changes to the resource, which will have a state
    of `Creating`. To get around, this we have the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This task will poll the REST API for information on our server every 15 seconds
    a maximum of 50 times until the REST API reports that the server `state` is `Ready`,
    and then it moves on to the next task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_resource` – now the server is ready, we can update
    the `require_secure_transport` parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_resource` – finally, we can create the WordPress
    database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have launched and configured the database resources, we can launch
    some virtual machines – starting with the admin one.
  prefs: []
  type: TYPE_NORMAL
- en: The Admin Virtual Machine role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compared to the Azure Flexible Server for MySQL role, this is quite straightforward
    and uses all Ansible-native Azure modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_networkinterface` creates the network interface
    for use with the Virtual Machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_publicipaddress_info` gets information on the
    public IP address attached to the load balancer we launched – we need this for
    the `cloud-init` script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.tempfile` creates a temporary file, which will store the `cloud-init`
    script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.template` generates the `cloud-init` script for the admin
    server; like our Terraform deployment, this will install the packages and bootstrap
    WordPress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_virtualmachine` launches the virtual machine using
    the resources created and configured previously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our admin virtual machine, let’s look at the web servers.
  prefs: []
  type: TYPE_NORMAL
- en: The Web Virtual Machine Scale Set role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This role contains three tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.builtin.tempfile` creates a temporary file, which will store the `cloud-init`
    script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.builtin.template` generates the `cloud-init` script for the admin
    server, like our Terraform deployment; this will install the packages and not
    touch WordPress as it’s already installed on our admin virtual machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm_virtualmachinescaleset` creates the virtual machine
    scale set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This role simply outputs the details we need to access our WordPress installation;
    unlike Terraform, this information is visible when it runs.
  prefs: []
  type: TYPE_NORMAL
- en: This simple role, which just displays some text when running our playbook, is
    the final role, and we are now ready to run our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Ansible Playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know what everything does, you can run the Ansible Playbook by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once finished, you should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The completed playbook run](img/Figure_4.08_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The completed playbook run
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have looked at WordPress and the Azure resource, you can run the following
    command to remove the resource group and everything contained within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Remember to make sure that all of the resources have been removed by checking
    to see whether they are still listed in the Azure portal, as you could incur unexpected
    costs if the playbook failed for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we did a deep dive into using Terraform to deploy our WordPress
    environment in Microsoft Azure. We discussed the Terraform providers and worked
    through the Terraform code before finally executing it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as part of this walkthrough, we discussed some of the considerations you
    need to make when looping through resources, when it’s appropriate to use `depends_on`,
    and how we can use templates to generate content.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we walked through the Ansible code, which deploys the same set of resources.
    This time, rather than a deep dive, we only went into detail on the Azure-specific
    details, as we will take a closer look at Ansible in [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon* *Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Everything we covered so far should hopefully start to get you thinking about
    how you can apply some of the subjects we have covered to your own Infrastructure-as-Code
    deployments and you should already be starting to get a feel for which of the
    two tools you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at deploying our WordPress installation to
    Amazon Web Services, as well as doing a deeper dive into Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more d[etails on the services and d](https://azure.microsoft.com/)ocumentation
    we have mentioned in this chapter at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft Azure: [https://azure.microsoft.com/](https://azure.microsoft.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Azure REST documentation: [https://learn.microsoft.com/en-us/rest/api/azure/](https://learn.microsoft.com/en-us/rest/api/azure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform providers and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'azurerm: [https://registry.terraform.io/providers/hashicorp/azurerm/latest](https://registry.terraform.io/providers/hashicorp/azurerm/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'azurecaf: [https://registry.terraform.io/providers/aztfmod/azurecaf/latest](https://registry.terraform.io/providers/aztfmod/azurecaf/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'random: [https://registry.terraform.io/providers/hashicorp/random/latest](https://registry.terraform.io/providers/hashicorp/random/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP: [https://registry.terraform.io/providers/hashicorp/http/latest](https://registry.terraform.io/providers/hashicorp/http/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Claranet Azure Region module: [https://registry.terraform.io/modules/claranet/regions/azurerm/latest](https://registry.terraform.io/modules/claranet/regions/azurerm/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A reference for Ansible collections is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure collection: [https://galaxy.ansible.com/azure/azcollection](https://galaxy.ansible.com/azure/azcollection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
