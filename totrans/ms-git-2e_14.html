<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-243"><a id="_idTextAnchor270" class="pcalibre1 pcalibre calibre6"/>11</h1>
<h1 id="_idParaDest-244" class="calibre5"><a id="_idTextAnchor271" class="pcalibre1 pcalibre calibre6"/>Managing Subprojects</h1>
<p class="calibre3">In <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>, we learned how to manage multiple repositories, while <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>, taught us various development techniques utilizing multiple branches, and multiple lines of development in these repositories. Up until now, these multiple repositories were all being developed independently of each other. Repositories of the different projects were autonomous.</p>
<p class="calibre3">This chapter will explain and show different ways to connect different subprojects in one single repository of the framework project, from the strong inclusion by embedding the code of one project in the other (subtrees) to the light connection between projects by nesting repositories (submodules). You will learn how to add a subproject to a master project, how to update the superproject state, and how to update a subproject. We will find out how to send our changes upstream, backport them to the appropriate project, and push them to the appropriate repository. Different techniques of managing subprojects have different advantages and drawbacks here.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">Managing library and framework dependencies</li>
<li class="calibre15">Dependency management tools: managing dependencies outside of Git</li>
<li class="calibre15">Importing code into a superproject as a subtree</li>
<li class="calibre15">Using subtree merges; the <strong class="source-inline1">git-subtree</strong> and <strong class="source-inline1">git-stree</strong> tools</li>
<li class="calibre15">Nested repositories (submodules): a subproject inside a superproject</li>
<li class="calibre15">Internals of submodules: gitlinks, <strong class="source-inline1">.gitmodules</strong>, and the <strong class="source-inline1">.</strong><strong class="source-inline1">git</strong> file</li>
<li class="calibre15">Use cases for subtrees and submodules; comparison of approaches</li>
<li class="calibre15">Alternative third-party solutions and tools/helpers</li>
</ul>
<h1 id="_idParaDest-245" class="calibre5"><a id="_idTextAnchor272" class="pcalibre1 pcalibre calibre6"/>Building a living framework</h1>
<p class="calibre3">There are various reasons to join an external project to your own project. As there are different reasons <a id="_idIndexMarker963" class="pcalibre1 pcalibre calibre6"/>to include a project (let’s call it a <strong class="bold">subproject</strong>, or a <strong class="bold">module</strong>) inside another <a id="_idIndexMarker964" class="pcalibre1 pcalibre calibre6"/>project (let’s call it a <strong class="bold">superproject</strong>, or a <strong class="bold">master project</strong>), there are <a id="_idIndexMarker965" class="pcalibre1 pcalibre calibre6"/>different types of inclusions geared toward different circumstances. They all have their advantages and disadvantages, and it is important to understand these to be able to choose the correct solution for your problem.</p>
<p class="calibre3">Let’s assume that you work on a web application and that your web app uses JavaScript (perhaps working as a single-page app). To make it easier to develop, you probably use some JavaScript library or a web framework, such as React.</p>
<p class="calibre3">Such a library is a separate project. You would want to be able to pin it to a known working version (to avoid problems where future changes to the library would make it stop working for your project), while also being able to review changes and automatically update it to the new version. Perhaps you would want to make your own changes to the library and send the proposed changes to the upstream. Of course, you would want users of your project to be able to use the library with your out-of-tree fixes, even if they are not yet accepted by original developers. Conceivably, you might have customizations and changes that you don’t want to publish (send to the upstream), but you might still make them available.</p>
<p class="calibre3">This is all possible in Git. There are two main solutions for including subprojects: importing code into your <a id="_idIndexMarker966" class="pcalibre1 pcalibre calibre6"/>project with the <strong class="bold">subtree</strong> merge strategy and linking <a id="_idIndexMarker967" class="pcalibre1 pcalibre calibre6"/>subprojects with <strong class="bold">submodules</strong>.</p>
<p class="calibre3">Both submodules and subtrees aim to reuse the code from another project, which usually has its own repository, putting it somewhere inside your own repository’s working directory tree. The goal is usually to benefit from the central maintenance of the reused code across a number of container repositories, without having to resort to clumsy, unreliable manual maintenance (usually by copy-pasting).</p>
<p class="calibre3">Sometimes, it is more complicated. The typical situation in many companies is that they use many in-house produced applications, which depend on the common utility library, or a set of libraries. You would often want to develop each of such applications separately, use it together with others, branch and merge, and apply your own changes and customizations, all in their own separate Git repositories. But there are also advantages to <a id="_idIndexMarker968" class="pcalibre1 pcalibre calibre6"/>having a single <strong class="bold">monolithic repository</strong> (<strong class="bold">monorepo</strong>), such as simplified organizations, dependencies, cross-project changes, and tooling if you can get away with it.</p>
<p class="calibre3">The mechanism used by submodules and subtrees solutions (of having separate Git repositories for each application, framework, or library) is not without problems. The development gets more complex because you now have multiple repositories to interact with. If the library gets improved, you would want to update your subproject and need to test whether this new version correctly works with your code, then decide whether to use it in your superproject. On the other hand, at some point in time, you would want to <a id="_idIndexMarker969" class="pcalibre1 pcalibre calibre6"/>send your changes to the library itself to share their changes with other developers, if only to share the burden of maintaining these features (the out-of-tree patches bring maintenance costs to keep them current).</p>
<p class="calibre3">What to do in those cases? This chapter describes a few strategies used to manage subprojects. For each technique, we will detail how to add such subprojects to superprojects, how to keep them up to date, how to create your own changes, and how to publish selected changes upstream.</p>
<p class="callout-heading">Subdirectory requirement</p>
<p class="callout">Note that all the solutions require that all the files of a subproject be contained in a single subdirectory of a superproject. No currently available solution allows you to mix the subproject files with other files, or have them occupy more than one directory.</p>
<p class="calibre3">However you manage subprojects, be it subtrees, submodules, third-party tools, or dependency management outside Git, you should strive for the module code to remain independent of the particularities of the superproject (or at least, handle such particularities using an external, possibly non-versioned configuration). Using superproject-specific modifications goes against modularization and encapsulation principles, unnecessarily coupling the two projects.</p>
<p class="calibre3">On the other hand, sharing common components, libraries, and tooling, and keeping them the same for all the distinct but related projects might be more important than the autonomy of those projects (for example, if they are all developed by the same company). It might be the case with the polyrepo setup that introducing a new feature always makes it necessary to create multiple commits in multiple repositories, instead of requiring only a single commit. In those cases, monorepo might be a better solution.</p>
<h2 id="_idParaDest-246" class="calibre7"><a id="_idTextAnchor273" class="pcalibre1 pcalibre calibre6"/>Managing dependencies outside of Git</h2>
<p class="calibre3">In many cases, the development <a id="_idIndexMarker970" class="pcalibre1 pcalibre calibre6"/>stack used allows you to simply use <strong class="bold">packaging</strong> and <strong class="bold">formal dependency management</strong>. If it is possible, it is usually preferable <a id="_idIndexMarker971" class="pcalibre1 pcalibre calibre6"/>to go this route. Using dependency management <a id="_idIndexMarker972" class="pcalibre1 pcalibre calibre6"/>solutions lets you split your code base better and avoid a number of side effects, complications, and pitfalls that litter the submodule and subtree solution space (with different complications for different techniques). It removes the version control systems from the managing modules. It also lets you benefit from <a id="_idIndexMarker973" class="pcalibre1 pcalibre calibre6"/>versioning schemes, such as <strong class="bold">semantic versioning</strong>, for your dependencies.</p>
<p class="calibre3">As a reminder, here’s a partial list (in alphabetical order) of the main languages and development stacks, and their dependency management/packaging systems and registries (see the full comparison at <a href="http://www.modulecounts.com" class="pcalibre1 pcalibre calibre6">www.modulecounts.com</a>):</p>
<ul class="calibre16">
<li class="calibre15">Go has GoDoc</li>
<li class="calibre15">Java has Maven Central (Maven and Gradle)</li>
<li class="calibre15">JavaScript has npm (for Node.js) and Bower</li>
<li class="calibre15">.NET has NuGet</li>
<li class="calibre15">Objective-C <a id="_idIndexMarker974" class="pcalibre1 pcalibre calibre6"/>has CocoaPods</li>
<li class="calibre15">Perl has <strong class="bold">Comprehensive Perl Archive Network</strong> (<strong class="bold">CPAN</strong>) and carton</li>
<li class="calibre15">PHP has <a id="_idIndexMarker975" class="pcalibre1 pcalibre calibre6"/>Composer, Packagist, and good old PEAR and PECL</li>
<li class="calibre15">Python has <strong class="bold">Python Package Index</strong> (<strong class="bold">PyPI</strong>) and pip</li>
<li class="calibre15">Ruby has Bundler and RubyGems</li>
<li class="calibre15">Rust has Crates</li>
</ul>
<p class="calibre3">Sometimes, just using the official package registry is not enough. You might need to apply some out-of-tree patches (changes) to customize the module (subproject) for your needs. Sometimes, however, for many reasons, you might be unable to publish these changes upstream to have them accepted. Perhaps the changes are relevant only to your specific project, or the upstream is slow to respond to the proposed changes, or perhaps there <a id="_idIndexMarker976" class="pcalibre1 pcalibre calibre6"/>are license considerations. Maybe the subproject in question is an in-house module that cannot be made public, but which you are required to use for your company projects.</p>
<p class="calibre3">In all these <a id="_idIndexMarker977" class="pcalibre1 pcalibre calibre6"/>cases, you need the <strong class="bold">custom package registry</strong> (the package repository) to be used in addition to the default one, or you need to let subprojects be managed as private packages, which these systems often allow. If there is no support for private packages, a tool to manage the private registry, such as Pinto or CPAN::Mini for Perl, would be also needed.</p>
<h2 id="_idParaDest-247" class="calibre7"><a id="_idTextAnchor274" class="pcalibre1 pcalibre calibre6"/>Manually importing the code into your project</h2>
<p class="calibre3">Sometimes, the library or a tool that you want to include in your project is not available in the package registry (perhaps because of the software stack; for example, package registries <a id="_idIndexMarker978" class="pcalibre1 pcalibre calibre6"/>for C++ such as Conan or vcpkg are quite a new thing).</p>
<p class="calibre3">Therefore, let’s take a look at one of the other possibilities: why don’t we simply import the library into some subdirectory in our project? If you need to bring it up to date, you can just copy the new version as a new set of files. In this approach, the subproject code is embedded inside the code of the superproject.</p>
<p class="calibre3">The simplest solution would be to just overwrite the contents of the subproject’s directory each time we want to update the superproject to use the new version. If the project you <a id="_idIndexMarker979" class="pcalibre1 pcalibre calibre6"/>want to import doesn’t use Git, or if it doesn’t use a <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) at all, or if the repository it uses is not public, this will indeed be the only possible solution.</p>
<p class="callout-heading">Using repositories from a foreign VCS as a remote</p>
<p class="callout">If the project you want to import (to embed) uses a VCS other than Git but there is a good conversion mechanism (for example, with a fast import stream), you can use <strong class="bold">remote helpers</strong> to set <a id="_idIndexMarker980" class="pcalibre1 pcalibre calibre6"/>up a foreign VCS repository as a remote repository (via automatic conversion). You can check <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>, and <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and Extending Git</em>, for more information.</p>
<p class="callout">This can be done, for example, with the Mercurial and Bazaar repositories, thanks to the <strong class="source-inline1">git-remote-hg</strong> and <strong class="source-inline1">git-remote-bzr</strong> helpers.</p>
<p class="calibre3">Moving to the <a id="_idIndexMarker981" class="pcalibre1 pcalibre calibre6"/>new version of the imported library is quite simple (and the mechanism is easy to understand). Remove all the files from the directory, add files from the new version of the library (for example, by extracting them from the archive), then use the <code>git add</code> command to the directory:</p>
<pre class="console">
$ rm -rf mylib/
$ git rm mylib
$ tar -xzf /tmp/mylib-0.5.tar.gz
$ mv mylib-0.5 mylib
$ git add mylib
$ git commit</pre>
<p class="calibre3">This method works quite well in simple cases with the following caveats:</p>
<ul class="calibre16">
<li class="calibre15">In the Git history of your project, you have only the versions of the library at the time of import. On the one hand, this makes your project history clean and easy to understand; on the other hand, you don’t have access to the fine-grained history of a subproject. For example, when using <strong class="source-inline1">git bisect</strong>, you would only be able to find that it was introduced by upgrading the library, but not the exact commit in the history of the library that introduced the bug in question.</li>
<li class="calibre15">If you want to customize the code of the library, fitting it to your project by adding the changes dependent on your application, you would need to reapply that customization in some way after you import a new version. You could extract your changes with <strong class="source-inline1">git diff</strong> (comparing it to the unchanged version at the time of import) and then use <strong class="source-inline1">git apply</strong> after upgrading the library. Or, you could use a rebase, an interactive rebase, or some patch management interface; see <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>. Git won’t do this automatically.</li>
<li class="calibre15">Each importing <a id="_idIndexMarker982" class="pcalibre1 pcalibre calibre6"/>of the new version of the library requires running a specific sequence of commands to update the superproject: removing the old version of files, adding new ones, and committing the change. It is not as easy as running <strong class="source-inline1">git pull</strong>, though you can use scripts or aliases to help.</li>
</ul>
<h1 id="_idParaDest-248" class="calibre5"><a id="_idTextAnchor275" class="pcalibre1 pcalibre calibre6"/>A Git subtree solution for embedding the subproject code</h1>
<p class="calibre3">In a slightly more <a id="_idIndexMarker983" class="pcalibre1 pcalibre calibre6"/>advanced solution, you can use the <strong class="bold">subtree merge</strong> to join the history of a subproject to the history of a superproject. This is only somewhat <a id="_idIndexMarker984" class="pcalibre1 pcalibre calibre6"/>more complicated than an ordinary pull (at least, after the subproject is imported), but provides <a id="_idIndexMarker985" class="pcalibre1 pcalibre calibre6"/>a way to automatically merge changes together.</p>
<p class="calibre3">Depending on your requirements, this method might fit well with your needs. It has the following advantages:</p>
<ul class="calibre16">
<li class="calibre15">You would always have the correct version of the library, never using the wrong library version by accident.</li>
<li class="calibre15">The method is simple to explain and understand, using only the standard (and well-known) Git features. As you will see, the most important and most commonly used operations are easy to do and easy to understand, and it is hard to go wrong.</li>
<li class="calibre15">The repository of your application is always self-contained; therefore, cloning it (with plain old <strong class="source-inline1">git clone</strong>) will always include everything that’s needed. This means that this method is a good fit for the <em class="italic">required dependencies</em>.</li>
<li class="calibre15">It is easy to apply patches (for example, customizations) to the library inside your repository, even if you don’t have the commit rights to the upstream repository.</li>
<li class="calibre15">Creating <a id="_idIndexMarker986" class="pcalibre1 pcalibre calibre6"/>a new branch in your application also creates a new branch for the library; it is the same <a id="_idIndexMarker987" class="pcalibre1 pcalibre calibre6"/>for switching branches. That’s the behavior you expect. This is contrasted with the submodule’s behavior (the other technique for managing subprojects).</li>
<li class="calibre15">If you are using the <strong class="source-inline1">subtree</strong> merge strategy (described shortly in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>,<em class="italic"> Merging Changes Together</em>), for example, with <strong class="source-inline1">git pull -s subtree</strong>, then getting a new library version will be as easy as updating all the other parts of your project.</li>
</ul>
<p class="calibre3">Unfortunately, however, this technique is not without its disadvantages. For many people and for many projects, these disadvantages do not matter. The simplicity of the subtree-based method usually prevails over its faults.</p>
<p class="calibre3">Here are <a id="_idIndexMarker988" class="pcalibre1 pcalibre calibre6"/>the problems with the subtree approach:</p>
<ul class="calibre16">
<li class="calibre15">Each application using the library doubles its files. There is no easy and safe way to share its objects among different projects and different repositories. (See the following callout about the possibility of sharing the Git object database.)</li>
<li class="calibre15">Each application using the library has its files checked out in the working area, though you <a id="_idIndexMarker989" class="pcalibre1 pcalibre calibre6"/>can change it with the help of the <strong class="bold">sparse checkout</strong> (which will be described in the next chapter: <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Handling </em><em class="italic">Large Repositories</em>).</li>
<li class="calibre15">If your application introduces changes to its copy of the library, it is not that easy to publish these changes and send them upstream. Third-party tools such as <strong class="source-inline1">git subtree</strong> or <strong class="source-inline1">git stree</strong> can help here. They have specialized subcommands to extract the subproject’s changes.</li>
<li class="calibre15">Because of the lack of separation between the subproject files and the superproject files, it is quite easy to mix the changes to the library and the changes <a id="_idIndexMarker990" class="pcalibre1 pcalibre calibre6"/>to the application in one commit. In such cases, you might need to rewrite the history (or the copy of a history), as described in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>,<em class="italic"> Keeping </em><em class="italic">History Clean</em>.</li>
</ul>
<p class="calibre3">The first <a id="_idIndexMarker991" class="pcalibre1 pcalibre calibre6"/>two issues mean that <a id="_idIndexMarker992" class="pcalibre1 pcalibre calibre6"/>subtrees are not a good fit to manage the subprojects that are <em class="italic">optional dependencies</em> (needed only for some extra features) or <em class="italic">optional components</em> (such as themes, extensions, or plugins), especially those that are installed by a mere presence in the appropriate place in the filesystem hierarchy.</p>
<p class="callout-heading">Sharing objects between forks (copies) with alternates</p>
<p class="callout">You can mitigate the duplication of objects in the repository with <strong class="bold">alternates</strong> or, in other words, with <strong class="source-inline1">git clone --reference</strong>. However, then you would need to take greater care about garbage collection. The problematic parts are those parts of the history that are referenced in the borrower repository (that is, one with alternates set up), but are not referenced in the lender reference’s repository. The description and explanation of the alternate mechanisms will be presented in <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>, <em class="italic">Git Administration</em>.</p>
<p class="calibre3">There are different technical ways to handle and manage the subtree-imported subprojects. You can use classic Git commands, just using the appropriate options while affecting the subproject, such as <code>--strategy=subtree</code> (or the <code>subtree</code> option to the default <code>recursive</code> merge strategy, <code>--strategy-option=subtree=&lt;path&gt;</code>) for <code>merge</code>, <code>cherry-pick</code>, and related operations. This manual approach works everywhere, is actually quite simple in most cases, and offers the best degree of control over operations. However, it requires a good understanding of the underlying concepts.</p>
<p class="calibre3">In modern Git (since version 1.7.11), there is the <code>git subtree</code> command available among <a id="_idIndexMarker993" class="pcalibre1 pcalibre calibre6"/>installed binaries. It comes <a id="_idIndexMarker994" class="pcalibre1 pcalibre calibre6"/>from the <code>contrib/</code> area and is not fully integrated (for example, with respect to its documentation). This script is well tested and robust, but some of its notions are rather peculiar or confusing, and this command does not support the whole range of possible subtree operations. Additionally, this tool supports only the <em class="italic">import with history</em> workflow (which will be defined later), which some say clutters the history graph.</p>
<p class="calibre3">There are also other third-party scripts that help with subtrees; among them is <code>git-subrepo</code>.</p>
<h2 id="_idParaDest-249" class="calibre7"><a id="_idTextAnchor276" class="pcalibre1 pcalibre calibre6"/>Creating a remote for a subproject</h2>
<p class="calibre3">Usually, while importing a subproject, you would want to be able to update the embedded <a id="_idIndexMarker995" class="pcalibre1 pcalibre calibre6"/>files easily. You would want to <a id="_idIndexMarker996" class="pcalibre1 pcalibre calibre6"/>continue interacting with the subproject. For this, you would add that subproject (for example, the common library) as a <strong class="bold">remote reference</strong> in your own (super)project and fetch it:</p>
<pre class="console">
$ git remote add mylib_repo https://git.example.com/mylib.git
$ git fetch mylib_repo
warning: no common commits
From https://git.example.com/mylib.git
* [new branch]      master     -&gt; mylib_repo/master</pre>
<p class="calibre3">Note that, in this example, progress messages were removed for simplicity.</p>
<p class="calibre3">You can then examine the <code>mylib_repo/master</code> remote-tracking branch, which can be done either by checking it out into the detached <code>HEAD</code> with <code>git checkout mylib_repo/master</code>, or by creating a local branch out of it and checking this local branch out with <code>git checkout -b mylib_branch mylib_repo/master</code>. Alternatively, you can just list its files with <code>git ls-tree -r --abbrev mylib repo/master</code>. You <a id="_idIndexMarker997" class="pcalibre1 pcalibre calibre6"/>will see then that the subproject has a different project root from your superproject. Additionally, as can be seen from the <strong class="bold">warning: no common commits</strong> message, this remote-tracking branch contains a completely different history coming from a separate project.</p>
<h2 id="_idParaDest-250" class="calibre7"><a id="_idTextAnchor277" class="pcalibre1 pcalibre calibre6"/>Adding a subproject as a subtree</h2>
<p class="calibre3">If you are not using specialized tools such as <code>git subtree</code> but a manual approach, the next <a id="_idIndexMarker998" class="pcalibre1 pcalibre calibre6"/>step will be a bit complicated and will require you to use some advanced Git concepts and techniques. Fortunately, it needs to be done only once.</p>
<p class="calibre3">First, if you want to import the <em class="italic">subproject history</em>, you would need to create a merge commit that will import the subproject in question. You need to have the files of the subproject in the given directory in a superproject. Unfortunately (at least, with the current version of Git as of writing this chapter), using the <code>-Xsubtree=mylib/</code> merge strategy option would not work as expected. We would have to do it in two steps: prepare the parents and then prepare the contents.</p>
<p class="calibre3">The first step would then be to prepare a merge commit using the <code>ours</code> merge strategy, but without creating it (writing it to the repository). This strategy joins histories, but takes the current version of the files from the current branch:</p>
<pre class="console">
$ git merge --no-commit --strategy=ours --allow-unrelated-histories mylib_repo/master
Automatic merge went well; stopped before committing as requested</pre>
<p class="calibre3">If you want to have <em class="italic">simple history</em>, similar to the one we get from just copying files, you can skip this step.</p>
<p class="calibre3">We now need to update our index (the staging area for the commits) with the contents of the <code>master</code> branch from the library repository and update our working directory with it. All this needs to happen in the proper subfolder too. This can be done with the low-level (plumbing) <code>git </code><code>read-tree</code> command:</p>
<pre class="console">
$ git read-tree --prefix=mylib/ -u mylib_repo/master
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)
Changes to be committed:
        new file:   mylib/README [...]</pre>
<p class="calibre3">We have <a id="_idIndexMarker999" class="pcalibre1 pcalibre calibre6"/>used the <code>-u</code> option, so the working directory is updated along with the index. We then need simply to finalize the merge with <code>git commit</code>, as Git tells us.</p>
<p class="callout-heading">Important note!</p>
<p class="callout">It is important to not forget the trailing slash in the argument of the <strong class="source-inline1">--prefix</strong> option. Checked-out files are literally prefixed with it.</p>
<p class="calibre3">This set of steps is described in the HOWTO section of the Git documentation, namely, in <strong class="bold">How to use the subtree merge strategy</strong>. This HOWTO is available at <a href="https://kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html" class="pcalibre1 pcalibre calibre6">https://kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html</a>.</p>
<p class="calibre3">It is much easier to use tools such as <code>git subtree</code>:</p>
<pre class="console">
$ git subtree add --prefix=mylib mylib_repo master
git fetch mylib_repo master
From https://git.example.com/mylib.git
* branch          master     -&gt; FETCH_HEAD
Added dir 'mylib'</pre>
<p class="calibre3">The <code>git subtree</code> command would fetch the subtree’s remote when necessary; there’s no need for the manual fetch that you had to perform in the manual solution.</p>
<p class="calibre3">If you examine the history, for example, with <code>git log --oneline --graph --decorate</code>, you will see that this command merged the library’s history with the history of <a id="_idIndexMarker1000" class="pcalibre1 pcalibre calibre6"/>the application (of the superproject). If you don’t want this, tough luck. The <code>--squash</code> option that <code>git subtree</code> offers on its <code>add</code>, <code>pull</code>, and <code>merge</code> subcommands won’t help here. One of the peculiarities <a id="_idIndexMarker1001" class="pcalibre1 pcalibre calibre6"/>of this tool is that this option doesn’t create a <strong class="bold">squash merge</strong>, but simply merges the squashed subproject’s history (as if it were squashed with an interactive rebase). The commit message would look like this: <strong class="bold">Squashed ‘mylib/’ content from commit 5e28a71</strong>. See <em class="italic">Figure 11</em><em class="italic">.2(b)</em> later in this chapter.</p>
<p class="calibre3">If you want a subtree without its history attached to the superproject history, as in <em class="italic">Figure 11</em><em class="italic">.2(c)</em>, consider using the external tool, <code>git-subrepo</code>. It has the additional advantage that it remembers the subtree settings:</p>
<pre class="console">
$ git subrepo clone \
  https://git.example.com/mylib.git mylib/
Subrepo 'https://git.example.com/mylib.git' (master) cloned into 'mylib'.</pre>
<p class="calibre3">The information about the subproject repository URL, the main branch, the original commit, and so on, is stored in the <code>.gitrepo</code> file in the directory with the subproject. All subsequent <code>git subrepo</code> commands refer to the embedded subproject by the name of the directory it is in (which is <code>mylib/</code> in the preceding example).</p>
<p class="calibre3">You can achieve similar results with the external <code>git-stree</code> tool, which was deprecated in favor of <code>git-subrepo</code>.</p>
<h2 id="_idParaDest-251" class="calibre7"><a id="_idTextAnchor278" class="pcalibre1 pcalibre calibre6"/>Cloning and updating superprojects with subtrees</h2>
<p class="calibre3">All right! Now <a id="_idIndexMarker1002" class="pcalibre1 pcalibre calibre6"/>that we have <a id="_idIndexMarker1003" class="pcalibre1 pcalibre calibre6"/>our project with a library embedded as a subtree, what do we need to do to get it? Because the concept behind subtrees is to have just one repository (the container), you can simply clone this repository.</p>
<p class="calibre3">To get an up-to-date repository, you just need a regular pull; this would bring both the superproject (the container) and subproject (the library) up to date. This works regardless <a id="_idIndexMarker1004" class="pcalibre1 pcalibre calibre6"/>of the approach <a id="_idIndexMarker1005" class="pcalibre1 pcalibre calibre6"/>taken, the tool used, and the manner in which the subtree was added. It is a great advantage of the subtrees approach.</p>
<h2 id="_idParaDest-252" class="calibre7"><a id="_idTextAnchor279" class="pcalibre1 pcalibre calibre6"/>Getting updates from subprojects with a subtree merge</h2>
<p class="calibre3">Let’s <a id="_idIndexMarker1006" class="pcalibre1 pcalibre calibre6"/>see what happens if there are some new changes in the subproject since we imported it. It is easy to bring the version embedded in the superproject up to date:</p>
<pre class="console">
$ git pull --strategy subtree mylib_repo master
From https://git.example.com/mylib.git
 * branch            master     -&gt; FETCH_HEAD
Merge made by the 'subtree' strategy.</pre>
<p class="calibre3">You could have fetched and then merged instead, which allows for greater control. Or, you could have rebased instead of merging, if you prefer; that works too.</p>
<p class="callout-heading">Importance of selecting subtree merge strategy</p>
<p class="callout">Don’t forget to select the merge strategy with <strong class="source-inline1">-s subtree</strong> while pulling a subproject. Merging could work even without it because Git does rename detection and would usually be able to discover that the files were moved from the root directory (in the subproject) to a subdirectory (in the superproject we are merging into). The problematic case is when there are conflicting files inside and outside of the subproject. Potential candidates are Makefiles and other standard filenames.</p>
<p class="callout">If there are some problems with Git detecting the correct directory to merge into, or if you need advanced features of an ordinary <strong class="source-inline1">ort</strong> merge strategy (which is the default), you can instead use <strong class="source-inline1">-Xsubtree=&lt;path/to/subproject&gt;</strong>, the <strong class="source-inline1">subtree</strong> option of the <strong class="source-inline1">ort</strong> merge strategy.</p>
<p class="calibre3">You may <a id="_idIndexMarker1007" class="pcalibre1 pcalibre calibre6"/>need to adjust other parts of the application code to work properly with the updated code of the library.</p>
<p class="calibre3">Note that, with this solution, you have a subproject history attached to your application history, as you can see in <em class="italic">Figure 11</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 11.1 – History of a superproject with a subtree-merged subproject inside the ‘maps/’ directory. Subproject history is available ﻿in the superproject via relevant remote-tracking branch" src="img/B21194_11_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.1 – History of a superproject with a subtree-merged subproject inside the ‘maps/’ directory. Subproject history is available in the superproject via relevant remote-tracking branch</p>
<p class="calibre3">If you don’t want to have the history of a subproject entangled in the history of a master project and prefer a simpler-looking history (as shown in <em class="italic">Figure 11</em><em class="italic">.1</em>), you can use the <code>--squash</code> option of the <code>git merge</code> (or <code>git pull</code>) command to squash it:</p>
<pre class="console">
$ git merge -s subtree --squash mylib_repo/master
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
$ git commit -m "Updated the library"</pre>
<p class="calibre3">Squash merge is described in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<p class="calibre3">In this case, in the history, you would have only the fact that the version of the subproject had changed, which has its advantages and disadvantages. You get <em class="italic">simpler</em> history <a id="_idIndexMarker1008" class="pcalibre1 pcalibre calibre6"/>but also <em class="italic">simplified</em> history.</p>
<p class="calibre3">With the <code>git subtree</code> or <code>git subrepo</code> tools, it is enough to use their <code>pull</code> subcommand; they supply the <code>subtree</code> merge strategy themselves. However, currently, <code>git subtree pull</code> requires you to respecify <code>--prefix</code> and the entire subtree settings.</p>
<div><div><img alt="Figure 11.2 – Different types of subtree merges: (a) subtree merge, (b) subtree merge of squashed commits, (c) squashed subtree merge" src="img/B21194_11_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Different types of subtree merges: (a) subtree merge, (b) subtree merge of squashed commits, (c) squashed subtree merge</p>
<p class="calibre3">Note that the <code>git subtree</code> command always merges, even with the <code>--squash</code> option; it simply squashes the subproject commits before merging (such as the <code>squash</code> instruction in the interactive rebase). In turn, <code>git subrepo pull</code> always squashes the merge (such as <code>git merge --squash</code>), which keeps the superproject history and subproject history separated without polluting the graph of the history. All this can be seen in <em class="italic">Figure 11</em><em class="italic">.2</em>. Note that the dotted line in <em class="italic">(c)</em> denotes how commits <strong class="bold">C2</strong> and <strong class="bold">C4</strong> were made, and not that it is the parent commit.</p>
<h2 id="_idParaDest-253" class="calibre7"><a id="_idTextAnchor280" class="pcalibre1 pcalibre calibre6"/>Showing changes between a subtree and its upstream</h2>
<p class="calibre3">To find out the differences between the subproject and the current version in the working <a id="_idIndexMarker1009" class="pcalibre1 pcalibre calibre6"/>directory, you need nontypical selector syntax for <code>git diff</code>. This is because all the files in the subproject (for example, in the <code>mylib_repo/master</code> remote-tracking branch) are in the root directory, while they are in the <code>mylib/</code> directory in the superproject (for example, in <code>master</code>). We need to select the subdirectory to be compared with <code>master</code>, putting it after the revision identifier and the colon (skipping it would mean that it would be compared with the root directory of the superproject).</p>
<p class="calibre3">The command looks as follows:</p>
<pre class="console">
$ git diff master:mylib mylib_repo/master</pre>
<p class="calibre3">Similarly, to check after the subtree merge whether the commit we just created (<code>HEAD</code>) has the same contents in the <code>mylib/</code> directory as the merged in the commit, that is, <code>HEAD^2</code>, we can use the following:</p>
<pre class="console">
$ git diff HEAD:mylib HEAD^2</pre>
<h2 id="_idParaDest-254" class="calibre7"><a id="_idTextAnchor281" class="pcalibre1 pcalibre calibre6"/>Sending changes to the upstream of a subtree</h2>
<p class="calibre3">In some cases, the subtree code of a subproject can only be used or tested inside the container code; most themes and plugins have such constraints. In this situation, you’ll be forced <a id="_idIndexMarker1010" class="pcalibre1 pcalibre calibre6"/>to evolve your subtree code straight inside the master project code base, before you finally backport it to the subproject upstream.</p>
<p class="calibre3">These changes often require adjustments in the rest of the superproject code; though it is recommended to make two separate commits (one for the subtree code change and one for the rest), it is not strictly necessary. You can tell Git to extract only the subproject changes. The problem is with the commit messages of the split changes, as Git is not able to automatically extract relevant parts of the changeset description.</p>
<p class="calibre3">Another common occurrence, which is best avoided but is sometimes necessary, is the need to customize the subproject’s code in a container-specific way (configure it specifically for a master project), usually without pushing these changes back upstream. You should carefully distinguish between both situations, keeping each use case’s changes (backportable and non-backportable) in their own commits.</p>
<p class="calibre3">There are different ways to deal with this issue. You can avoid the problem of extracting changes to be sent upstream by requiring that all the subtree changes have to be done in a separate module-only repository. If it is possible, we can even require that all the subproject changes have to be sent upstream first, and we can get the changes into the container only through upstream acceptance.</p>
<p class="calibre3">If you <a id="_idIndexMarker1011" class="pcalibre1 pcalibre calibre6"/>need to be able to extract the subtree changes, then one possible solution is to utilize <code>git filter-branch --directory-filter</code> (or <code>--index-filter</code> with the appropriate script). Another simple solution is to just use <code>git subtree push</code>. Both of the methods, however, backport <em class="italic">every</em> commit that touches the subtree in question.</p>
<p class="calibre3">If you want to send upstream only a selection of the changes to the subproject of those that made it into the master project repository, then the solution is a bit more complicated. One possibility is to create a local branch meant specifically for backporting out of the subproject remote-tracking branch. Forking it from said subtree-tracking branch means that it has the subtree as the root and it would include only the submodule files.</p>
<p class="calibre3">This branch, intended for backporting changes to the subproject, would need to have the appropriate branch in the remote of the subproject upstream repository as its upstream branch. With such a setup, we would then be able to use <code>git cherry-pick --strategy=subtree</code> the commits we’re interested in sending to the subproject’s upstream onto it. Then, we can simply <code>git push</code> this branch into the subproject’s repository.</p>
<p class="callout-heading">Cherry picking and submodules</p>
<p class="callout">It is prudent to specify <strong class="source-inline1">--strategy=subtree</strong> even if <strong class="source-inline1">cherry-pick</strong> would work without it, to make sure that the files outside the subproject’s directory (outside <strong class="source-inline1">subtree</strong>) will get quietly ignored. This can be used to extract the subtree changes from the mixed commit; without this option, Git will refuse to complete the cherry-pick.</p>
<p class="calibre3">This requires much more steps than ordinary <code>git push</code>. Fortunately, you need to face this problem only while sending the changes made in the superproject repository back to the <a id="_idIndexMarker1012" class="pcalibre1 pcalibre calibre6"/>subproject. As you have seen, fetching changes from the subproject into the superproject is much, much simpler.</p>
<p class="calibre3">Well, using <code>git-stree</code> would make this trivial; you just need to list the commits to be pushed to backport:</p>
<pre class="console">
$ git stree push mylib_repo master~3 master~1
• 5e28a71 [To backport] Support for creating debug symbols
• 5b0aa4b [To backport] Timestamping (requires application tweaks)
✔︎  STree 'mylib_repo' successfully backported local changes to its remote</pre>
<p class="calibre3">In fact, this tool internally uses the same technique, creating and using a backport-specific local branch for the subproject.</p>
<h1 id="_idParaDest-255" class="calibre5"><a id="_idTextAnchor282" class="pcalibre1 pcalibre calibre6"/>The Git submodules solution – a repository inside a repository</h1>
<p class="calibre3">The subtrees method of importing the code (and possibly also the history) of a subproject <a id="_idIndexMarker1013" class="pcalibre1 pcalibre calibre6"/>into the superproject has its disadvantages. In many cases, the subproject and the container are two different projects: your application depends on the library, but it is obvious that they are separate entities. Joining the histories of the two doesn’t look like the best solution.</p>
<p class="calibre3">Additionally, the embedded code and imported history of a subproject are always here. Therefore, the subtrees technique is not a good fit for optional dependencies and components (such as plugins or themes). It also doesn’t allow you to have different access controls for the subproject’s history, with the possible exception of restricting write access to the subproject (actually to the subdirectory of a subproject), by using Git repository management solutions such as <code>gitolite</code> (you can find more in <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>, <em class="italic">Git Administration</em>).</p>
<p class="calibre3">The submodule <a id="_idIndexMarker1014" class="pcalibre1 pcalibre calibre6"/>solution is to keep the subproject code and history in its own repository and to embed this repository inside the working area of a superproject, but not to add its files as superproject files.</p>
<h2 id="_idParaDest-256" class="calibre7"><a id="_idTextAnchor283" class="pcalibre1 pcalibre calibre6"/>Gitlinks, .git files, and the git submodule command</h2>
<p class="calibre3">Git includes the command named <code>git submodule</code>, which is intended to work with submodules. However, to <a id="_idIndexMarker1015" class="pcalibre1 pcalibre calibre6"/>utilize it correctly, you need to understand at least some of the details of its operation. It is a combination of two distinct features: the so-called <code>git submodule</code> tool itself.</p>
<p class="calibre3">Both in the <a id="_idIndexMarker1016" class="pcalibre1 pcalibre calibre6"/>subtree solution and the submodule solution, subprojects need to be contained in their own folder inside the working directory of the superproject. But while, with subtrees, the code of the subproject belongs to the superproject <a id="_idIndexMarker1017" class="pcalibre1 pcalibre calibre6"/>repository, this is not the case for submodules. With submodules, each subproject has instead its own repository somewhere inside its container repository. The code of the submodule belongs to its repository, and the superproject itself simply stores the meta-information required to get appropriate revisions of the subproject files.</p>
<p class="calibre3">In practice, in modern Git, submodules use a simple <code>.git</code> file with a single <code>gitdir:</code> line containing a relative path to the actual repository folder. The submodule repository is actually located inside the superproject’s <code>.git/modules</code> folder (and has <code>core.worktree</code> set up appropriately). This is done mostly to handle the case when the superproject has branches that don’t have a submodule at all. It allows us to avoid having to scrap the submodule’s repository while switching to the superproject revision without it.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can think of the <strong class="source-inline1">.git</strong> file with the <strong class="source-inline1">gitdir:</strong> line as a symbolic reference equivalent for the <strong class="source-inline1">.git</strong> directories, an OS-independent symbolic link replacement. The path to the repository doesn’t need to be a relative path:</p>
<pre class="console">
$ ls -aloF plugins/demo/
total 10
drwxr-xr-x 1 user  0 Jul 13 01:26 ./
drwxr-xr-x 1 user  0 Jul 13 01:26 ../
<strong class="bold1">-rw-r--r-- 1 user 32 Jul 13 01:26 .git</strong>
-rw-r--r-- 1 user  9 Jul 13 01:26 README
[…]
$ cat plugins/demo/.git
gitdir: ../../.git/modules/plugins/demo</pre>
<p class="calibre3">Be that as it may, the contained superproject and the subproject module truly act as (and, in fact, are) independent repositories: they have their own history, their own staging area, and their <a id="_idIndexMarker1018" class="pcalibre1 pcalibre calibre6"/>own current branch. Therefore, you should <a id="_idIndexMarker1019" class="pcalibre1 pcalibre calibre6"/>take care while typing commands, minding whether you’re <a id="_idIndexMarker1020" class="pcalibre1 pcalibre calibre6"/>inside the submodule or outside it, as the context and impact of your commands differ drastically!</p>
<p class="calibre3">The main idea behind the typical use of submodules is that the superproject commit remembers the <em class="italic">exact</em> revision of the subproject; this reference uses the SHA1 identifier of the subproject commit. Instead of using a manifest-like file as in some dependency management tools, the submodules solution stores this information in a tree object using so-called gitlinks. <strong class="bold">Gitlink</strong> is a reference from a <strong class="bold">tree object</strong> (in the superproject repository) to a <strong class="bold">commit object</strong> (usually, in the submodule repository); see <em class="italic">Figure 11</em><em class="italic">.3</em>. The faint shade of submodule files on the left-hand side denotes that they are present as files in the working directory of the superproject, but are not in the superproject repository themselves.</p>
<div><div><img alt="Figure 11.3 – The history of a superproject with a subproject linked as a submodule inside the ‘maps/’ subdirectory. Subproject history is separate" src="img/B21194_11_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The history of a superproject with a subproject linked as a submodule inside the ‘maps/’ subdirectory. Subproject history is separate</p>
<p class="calibre3">Recall that, following the description of the types of objects in the repository database from <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>, each commit object (representing a revision of a project) points exactly to one tree object with the snapshot of the repository contents. Each tree <a id="_idIndexMarker1021" class="pcalibre1 pcalibre calibre6"/>object references blobs and trees, representing <a id="_idIndexMarker1022" class="pcalibre1 pcalibre calibre6"/>file contents and directory contents, respectively. The <a id="_idIndexMarker1023" class="pcalibre1 pcalibre calibre6"/>tree object referenced by the commit object uniquely identifies the set of file contents, filenames, and file permissions contained in a revision associated with the commit object.</p>
<p class="calibre3">Let’s remember <a id="_idIndexMarker1024" class="pcalibre1 pcalibre calibre6"/>that the commit objects themselves are connected with each other, creating the <strong class="bold">Directed Acyclic Graph</strong> (<strong class="bold">DAG</strong>) of revisions. Each commit object references zero or more parent commits, which together describe the history of a project.</p>
<p class="calibre3">Each type of reference mentioned earlier took part in the reachability check. If the object pointed to was missing, it means that the repository is corrupt.</p>
<p class="calibre3">It is not so for gitlinks. Entries in the tree object pointing to the commits refer to the objects in the other separate repository, namely, in the subproject (submodule) repository. The fact that the submodule commit being unreachable is not an error is what allows us to optionally include submodules: no submodule repository, no commit referenced in gitlink.</p>
<p class="calibre3">The results <a id="_idIndexMarker1025" class="pcalibre1 pcalibre calibre6"/>of running <code>git ls-tree --abbrev HEAD</code> on a project with all the types of objects is as follows:</p>
<pre class="console">
040000 tree 573f464    docs
100755 blob f27adc2    executable.sh
100644 blob 1083735    README.txt
040000 tree ef9bcb4    subdirectory
<strong class="bold1">160000 commit 5b0aa4b   submodule</strong>
120000 blob 3295d66    symlink</pre>
<p class="calibre3">Compare it <a id="_idIndexMarker1026" class="pcalibre1 pcalibre calibre6"/>with the <a id="_idIndexMarker1027" class="pcalibre1 pcalibre calibre6"/>contents of the working area (with <code>ls -l -</code><code>o -F</code>):</p>
<pre class="console">
drwxr-xr-x   5 user    12288 06-28 17:18 docs/
-rwxr-xr-x   1 user    36983 02-20 20:11 executable.sh*
-rw-r--r--   1 user     2628 2015-01-03  README.txt
drwxr-xr-x   3 user     4096 06-28 17:19 subdirectory/
drwxr-xr-x  48 user    36864 06-28 17:19 submodule/
lrwxrwxrwx   1 user       32 06-28 17:18 symlink -&gt; docs/toc.html</pre>
<h2 id="_idParaDest-257" class="calibre7"><a id="_idTextAnchor284" class="pcalibre1 pcalibre calibre6"/>Adding a subproject as a submodule</h2>
<p class="calibre3">To <a id="_idIndexMarker1028" class="pcalibre1 pcalibre calibre6"/>manage submodules there is the <code>git submodule</code> command. It was created to help manage the filesystem contents, the metadata, and the configuration of your submodules, as well as inspect their status and update them.</p>
<p class="calibre3">With subtrees, the first step was usually to add a subproject repository as a remote, which meant that objects from the subproject repository were fetched into the <em class="italic">superproject</em> object database.</p>
<p class="calibre3">To add the given repository as a submodule at a specific directory in the superproject, use the <code>add</code> subcommand of the <code>git submodule</code>:</p>
<pre class="console">
$ git submodule add https://git.example.com/demo-plugin.git plugins/demo
Cloning into 'plugins/demo'...
done.</pre>
<p class="callout-heading">Note about adding subprojects via a path to their repository</p>
<p class="callout">While using paths instead of URLs for remotes, you need to remember that the relative paths for remotes are interpreted relative to our main remote, not to the root directory of our repository.</p>
<p class="calibre3">This <a id="_idIndexMarker1029" class="pcalibre1 pcalibre calibre6"/>command stores the information about the submodule, for example, the URL of the repository, in the <code>.gitmodules</code> file. It creates a <code>.gitmodules</code> file if it does not exist:</p>
<pre class="source-code">
[submodule "plugins/demo"]
    url = https://git.example.com/demo-plugin.git</pre>
<p class="calibre3">Note that a submodule gets a name equal to its path. You can set the name explicitly with the <code>--name</code> option (or by editing the configuration); <code>git mv</code> on a submodule directory will change the submodule path but keep the same name.</p>
<p class="callout-heading">Reuse of authentication while fetching submodules</p>
<p class="callout">While storing the URL of a remote repository, it is often acceptable and useful to store the username with the subproject information (for example, storing the username in a URL, such as <strong class="source-inline1">user@git.company.com:mylib.git</strong>).</p>
<p class="callout">However, remembering the username as a part of the URL is undesirable in <strong class="source-inline1">.gitmodules</strong>, as this file must be visible to other developers (which often use different usernames for authentication). Fortunately, the commands that descend into submodules can reuse the authentication from cloning (or fetching) a superproject.</p>
<p class="calibre3">The <code>add</code> subcommand also runs an equivalent of <code>git submodule init</code> for you, assuming that if you have added a submodule, you are interested in it. This adds some submodule-specific settings to the local configuration of the master project:</p>
<pre class="source-code">
[submodule "plugins/demo"]
        url = https://git.example.com/demo-plugin.git</pre>
<p class="calibre3">Why the duplication? Why store the same information in <code>.gitmodules</code> and in <code>.git/ config</code>? Well, because while the <code>.gitmodules</code> file is meant for all developers, we can fit our <a id="_idIndexMarker1030" class="pcalibre1 pcalibre calibre6"/>local configuration to specific local circumstances. The other reason for using two different files is that while the presence of the submodule information in <code>.gitmodules</code> means only that the subproject is available, having it also in <code>.git/ config</code> implies that we are interested in a given submodule (and that we want it to be present).</p>
<p class="calibre3">You can create and edit the <code>.gitmodules</code> file by hand or with <code>git config -</code><code>f .gitmodules</code>.</p>
<p class="calibre3">This file is usually committed to the superproject repository (similar to <code>.gitignore</code> and <code>.gitattributes</code> files), where it serves as the list of possible subprojects.</p>
<p class="calibre3">All the other subcommands require the <code>.gitmodules</code> file to be present; for example, if we would run <code>git submodule update</code> before adding it, we would get the following:</p>
<pre class="console">
$ git submodule update
No submodule mapping found in .gitmodules for path 'plugins/demo'</pre>
<p class="calibre3">That’s why <code>git submodule add</code> stages both the <code>.gitmodules</code> file and the submodule itself:</p>
<pre class="console">
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)
        new file:   .gitmodules
        new file:   plugins/demo</pre>
<p class="calibre3">Note <a id="_idIndexMarker1031" class="pcalibre1 pcalibre calibre6"/>that the whole submodule, which is a directory, looks to <code>git status</code> like the new file. By default, most Git commands are limited to the active container repository only and do not descend to the nested repositories of the submodules. As we will see, this is configurable.</p>
<h2 id="_idParaDest-258" class="calibre7"><a id="_idTextAnchor285" class="pcalibre1 pcalibre calibre6"/>Cloning superprojects with submodules</h2>
<p class="calibre3">One important issue is that, by default, if you clone the superproject repository, you will not <a id="_idIndexMarker1032" class="pcalibre1 pcalibre calibre6"/>get any submodules. All the submodules will be missing from the working duplicated directory; only their base directories are here. This behavior is the basis of the optionality of submodules.</p>
<p class="calibre3">We need then to tell Git that we are interested in a given submodule. This is done by calling the <code>git submodule init</code> command. What this command does is copy the submodule settings from the <code>.gitmodules</code> file into the superproject’s repository configuration, namely, <code>.git/config</code>, registering the submodule:</p>
<pre class="console">
$ git submodule init plugins/demo
Submodule 'plugins/demo' (https://git.example.com/demo-plugin.git) registered for path 'plugins/demo'</pre>
<p class="calibre3">The <code>init</code> subcommand adds the following two lines to the <code>.</code><code>git/config</code> file:</p>
<pre class="source-code">
[submodule "plugins/demo"]
    url = https://git.example.com/demo-plugin.git</pre>
<p class="calibre3">This separate local configuration for the submodules you are interested in allows you also to configure your local submodules to point to a different location URL (perhaps, a per-company reference clone of a subproject’s repository) from the one that is present in the <code>.</code><code>gitmodules</code> file.</p>
<p class="calibre3">This mechanism also makes it possible to provide a new URL if the repository of a subproject has moved. That’s why the local configuration overrides the one that is recorded in <code>.gitmodules</code>; otherwise, you would not be able to fetch from the current URL when switched to the version before the URL change. On the other hand, if the <a id="_idIndexMarker1033" class="pcalibre1 pcalibre calibre6"/>repository moved and the <code>.gitmodules</code> file was updated accordingly, we can re-extract the new URL from <code>.gitmodules</code> into local configuration with <code>git </code><code>submodule sync</code>.</p>
<p class="calibre3">We have told Git that we are interested in the given submodule. However, we have still not fetched the submodule commits from its remote and neither have we checked it out and have its files present in the working directory of the superproject. We can do this with <code>git </code><code>submodule update</code>.</p>
<p class="callout-heading">Shortcut command</p>
<p class="callout">In practice, while dealing with submodules using repositories, we usually group the two commands (<strong class="source-inline1">init</strong> and <strong class="source-inline1">update</strong>) into one with <strong class="source-inline1">git submodule update --init</strong>; unless we need to customize the URL.</p>
<p class="calibre3">If you are interested in all the submodules, you can use <code>git clone --recursive</code> (or <code>git clone --recurse-submodules</code>) to automatically initialize and update each submodule right after cloning.</p>
<p class="calibre3">To temporarily remove a submodule, retaining the possibility of restoring it later, you can mark it as not interesting with <code>git remote deinit</code>. This just affects <code>.git/config</code>. To permanently remove a submodule, you need to first deinitialize it, and then remove it from <code>.gitmodules</code> and from the working area (with <code>git rm</code>).</p>
<h2 id="_idParaDest-259" class="calibre7"><a id="_idTextAnchor286" class="pcalibre1 pcalibre calibre6"/>Updating submodules after superproject changes</h2>
<p class="calibre3">To update the submodule so that the working directory contents reflect the state of a submodule <a id="_idIndexMarker1034" class="pcalibre1 pcalibre calibre6"/>in the current version of the superproject, you need to perform <code>git submodule update</code>. This command updates the files of the subproject or, if necessary, clones the initial submodule repository:</p>
<pre class="console">
$ rm -rf plugins/demo   # clean start for this example
$ git submodule update
Submodule path 'plugins/demo': checked out '5e28a713d8e87…'</pre>
<p class="calibre3">The <code>git submodule update</code> command goes to the repository referenced by <code>.git/config</code>, fetches the ID of the commit found in the index (<code>git ls-tree HEAD -- plugins/demo</code>), and checks out this version into the directory given by <code>.git/config</code>. You can, of course, specify the submodule you want to update, giving the path to the submodule as a parameter.</p>
<p class="calibre3">Because we are here checking out the revision given by gitlink, and not by a branch, <code>git submodule update</code> detaches the subproject’s <code>HEAD</code> (see <em class="italic">Figure 11</em><em class="italic">.3</em>). This command rewinds the subproject straight to the version recorded in the supermodule.</p>
<p class="calibre3">There are a few more things that you need to know:</p>
<ul class="calibre16">
<li class="calibre15">If you are changing the current revision of a superproject in any way, either by changing a branch, importing a branch with <strong class="source-inline1">git pull</strong>, or rewinding the history with <strong class="source-inline1">git reset</strong>, you need to run <strong class="source-inline1">git submodule update</strong> to get the matching content to submodules. This is not done automatically by default, because it could lead to potentially losing your work in a submodule.</li>
<li class="calibre15">Conversely, if you switch to another branch, or otherwise change the current revision in a superproject, and do not run <strong class="source-inline1">git submodule update</strong>, Git would consider that you changed your submodule directory deliberately to point to a new commit (while it is really an old commit that you used before but forgot to update). If, in this situation, you would run <strong class="source-inline1">git commit -a</strong>, then by accident, you will change the gitlink, leading to having an incorrect version of a submodule stored in the superproject history.</li>
<li class="calibre15">You can upgrade the gitlink reference simply by fetching (or switching to) the version of a submodule you want to have by using ordinary Git commands inside the subproject and then committing this version in the supermodule. You don’t need to use the <strong class="source-inline1">git submodule</strong> command here.</li>
</ul>
<p class="calibre3">You can have Git automatically fetch the initialized submodules while pulling the updates from the master project’s remote repository. This behavior can be configured using <code>fetch.recurseSubmodules</code> (or <code>submodule.&lt;name&gt;.fetchRecurseSubmodules</code>). The default value for this configuration is <code>on-demand</code> (to fetch if gitlink changes and the submodule commit that it points to is missing). You can set it to <code>yes</code> or <code>no</code> to turn recursively fetching submodules on or off unconditionally. The corresponding command-line option is <code>--recurse-submodules</code>.</p>
<p class="calibre3">You can <a id="_idIndexMarker1035" class="pcalibre1 pcalibre calibre6"/>pass the <code>--recurse-submodules</code> command-line option to many Git commands, including the <code>git pull</code> command, which would then fetch initialized modules and update working trees of active submodules.</p>
<p class="callout-heading">Always recursing into active submodules</p>
<p class="callout">To make those Git commands that support it use the <strong class="source-inline1">--recurse-submodules</strong> option by default, you can set the <strong class="source-inline1">submodule.recurse</strong> configuration option to <strong class="source-inline1">true</strong>. The <strong class="source-inline1">checkout</strong>, <strong class="source-inline1">fetch</strong>, <strong class="source-inline1">grep</strong>, <strong class="source-inline1">pull</strong>, <strong class="source-inline1">push</strong>, <strong class="source-inline1">read-tree</strong>, <strong class="source-inline1">reset</strong>, <strong class="source-inline1">restore</strong>, and <strong class="source-inline1">switch</strong> commands are supported.</p>
<p class="calibre3">Note that instead of checking out the gitlinked revision on the detached <code>HEAD</code>, we can merge the commit recorded in the superproject into the current branch in the submodule with <code>--merge</code>, or rebase the current branch on top of the gitlink with <code>--rebase</code>, just like with <code>git pull</code>. The submodule repository branch used defaults to <code>master</code>, but the branch name may be overridden by setting the <code>submodule.&lt;name&gt;.branch</code> option in either <code>.gitmodules</code> or <code>.git/config</code>, with the latter taking precedence.</p>
<p class="calibre3">As you can see, using gitlinks and the <code>git submodule</code> command is quite complicated. Fundamentally, the concept of gitlink might fit well with the relationship between subprojects and your super<a id="_idTextAnchor287" class="pcalibre1 pcalibre calibre6"/>project, but using this information correctly is harder than you think. On the other hand, it gives great flexibility and power.</p>
<h2 id="_idParaDest-260" class="calibre7"><a id="_idTextAnchor288" class="pcalibre1 pcalibre calibre6"/>Examining changes in a submodule</h2>
<p class="calibre3">By default, the status, logs, and <code>diff</code> output are based solely on the state of the active repository <a id="_idIndexMarker1036" class="pcalibre1 pcalibre calibre6"/>and do not descend into submodules. This is often problematic; you would need to remember to run <code>git submodule summary</code>. It is easy to miss a regression if you are limited to this view: you can see that the submodule has changed but you can’t see how.</p>
<p class="calibre3">You can, however, set <a id="_idIndexMarker1037" class="pcalibre1 pcalibre calibre6"/>up Git to make it use a <code>status.submoduleSummary</code> configuration variable. If it is set to a nonzero number, this number will provide the <code>--summary-limit</code> restriction; a value of <code>true</code> or <code>-1</code> will mean an unlimited number.</p>
<p class="calibre3">After setting this configuration, you would get something like the following:</p>
<pre class="console">
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)
        new file:   .gitmodules
        new file:   plugins/demo
Submodule changes to be committed:
* plugins/demo 0000000...5e28a71 (3):
  &gt; Fix repository name in a README file</pre>
<p class="calibre3">The status extends the always present information that the submodule changed (<code>plugins/demo</code> got three new commits, and showing the summary for the last one (<code>&gt;</code>) preceding the summary line means that the commit was added, that is, present in the working area but not (yet) in the superproject commit.</p>
<p class="callout-heading">Trivia</p>
<p class="callout">Actually, this added part is just the <strong class="source-inline1">git submodule </strong><strong class="source-inline1">summary</strong> output.</p>
<p class="calibre3">For the <a id="_idIndexMarker1038" class="pcalibre1 pcalibre calibre6"/>submodule in question, a series of commits in the submodule between the submodule version in the given superproject’s commit and the submodule version in the index or the working tree (the former shown by using <code>--cached</code>) are listed. There is also <code>git submodule status</code> for short information about each module.</p>
<p class="calibre3">The <code>git diff</code> command’s default output also doesn’t tell much about the change in the submodule, just that it is different:</p>
<pre class="console">
$ git diff HEAD -- plugins/demo
diff --git a/plugins/demo b/plugins/demo
new file mode 160000
index 0000000..5e28a71
--- /dev/null
+++ b/plugins/demo
@@ -0,0 +1 @@
+Subproject commit 5e28a713d8e875f2cf1060c2580886dec3e5b04c</pre>
<p class="calibre3">Fortunately, there is the <code>--submodule=log</code> command-line option (which you can enable by default with the <code>diff.submodule</code> configuration setting) that lets us see something more useful:</p>
<pre class="console">
$ git diff HEAD --submodule=log -- plugins/demoSubmodule subrepo 0000000...5e28a71 (new submodule)</pre>
<p class="calibre3">Instead <a id="_idIndexMarker1039" class="pcalibre1 pcalibre calibre6"/>of using <code>log</code>, we can use the <code>short</code> format that shows just the names of the commits, which is the default if the format is not given (that is, with just <code>git diff --submodule</code>). Alternatively, we can use the <code>diff</code> format to show an inline <code>diff</code> of the changed contents of the submodule.</p>
<h2 id="_idParaDest-261" class="calibre7"><a id="_idTextAnchor289" class="pcalibre1 pcalibre calibre6"/>Getting updates from the upstream of the submodule</h2>
<p class="calibre3">To remind you, the submodule commits are referenced in gitlinks using the SHA1 identifier, which always resolves to the same revision; it is not a volatile (inconstant) reference <a id="_idIndexMarker1040" class="pcalibre1 pcalibre calibre6"/>such as a branch name. Because of this, a submodule in a superproject does not automatically upgrade (which could possibly be breaking the application). However, sometimes, you may want to update the subproject to its upstream.</p>
<p class="calibre3">Let’s assume that the subproject repository got new revisions published and, for our superproject, we want to update to the new version of a submodule.</p>
<p class="calibre3">To achieve this, we need to update the local repository of a submodule, move the version we want to the working directory of the superproject, and, finally, commit the submodule change in the superproject.</p>
<p class="calibre3">We can do this manually, starting by first changing the current directory to be inside the working directory of the submodule. Then, inside the submodule, we perform <code>git fetch</code> to get the data to the local clone of the repository (in <code>.git/modules/</code> in the superproject). After verifying what we have with <code>git log</code>, we can then update the working directory. If there are no local changes, you can simply check out the desired revision. Finally, you need to create a commit in a superproject.</p>
<p class="calibre3">In addition to the finer-grained control, this approach has the added benefit of working regardless of your current state (whether you are on an active branch or on a detached <code>HEAD</code>).</p>
<p class="calibre3">Another way to go about this would be, working from the container repository, to explicitly upgrade the submodule to its tracked remote branch with <code>git submodule update --remote</code>. Similarly to the ordinary update command, you can choose to merge or rebase instead of checking out a branch; you can configure the default way of updating with the <code>submodule.&lt;name&gt;.update</code> configuration variable, and the default <a id="_idIndexMarker1041" class="pcalibre1 pcalibre calibre6"/>upstream branch with <code>submodule.&lt;name&gt;.branch</code>.</p>
<p class="callout-heading">Variants of git submodule update</p>
<p class="callout">In short, <strong class="source-inline1">submodule update --remote --merge</strong> will merge the upstream’s subproject changes into the submodule, while <strong class="source-inline1">submodule update --merge</strong> will merge the superproject gitlink changes into the submodule.</p>
<p class="calibre3">The <code>git submodule update --remote</code> command would fetch new changes from the submodule remote site automatically unless told not to with <code>--no-fetch</code>.</p>
<h2 id="_idParaDest-262" class="calibre7"><a id="_idTextAnchor290" class="pcalibre1 pcalibre calibre6"/>Sending submodule changes upstream</h2>
<p class="calibre3">One of the major dangers in making changes live directly in a submodule (and not via its standalone repository) is forgetting to push the submodule. A good practice for submodules <a id="_idIndexMarker1042" class="pcalibre1 pcalibre calibre6"/>is to commit changes to the submodule first, push the module changes, and only then get back to the container project, commit it, and push the container changes.</p>
<p class="calibre3">If you only push to the supermodule repository, forgetting about the submodule push, then other developers will get an error while trying to get the updates. Though Git does not complain while fetching the superproject, you would see the problem in the <code>git submodule summary</code> output (and in the <code>git status</code> output, if properly configured) and while trying to update the working area:</p>
<pre class="console">
$ git submodule summary
* plugins/demo 12e3a52...0e90143:
  Warn: plugins/demo doesn't contain commit 12e3a529698c519b2fab790…
$ git submodule update
fatal: reference is not a tree: 12e3a529698c519b2fab790…
Unable to checkout '12e3a529698c519b2fab790…' in submodule path 'plugins/dem<a id="_idTextAnchor291" class="calibre13 pcalibre1 pcalibre"/>o'</pre>
<p class="calibre3">You can <a id="_idIndexMarker1043" class="pcalibre1 pcalibre calibre6"/>plainly see how important it is to remember to push the submodule. You can ask Git to automatically push the submodules while pushing the superproject, if it is necessary, with <code>git push --recurse-submodules=on-demand</code> (the other option is just to check). You can also use the <code>push.</code> <code>recurseSubmodules</code> configuration option.</p>
<h1 id="_idParaDest-263" class="calibre5"><a id="_idTextAnchor292" class="pcalibre1 pcalibre calibre6"/>Transforming a subfolder into a subtree or submodule</h1>
<p class="calibre3">The first issue that comes to mind while thinking of the use cases of subprojects in Git is about <a id="_idIndexMarker1044" class="pcalibre1 pcalibre calibre6"/>having the source code of the base project ready for such division.</p>
<p class="calibre3">Submodules <a id="_idIndexMarker1045" class="pcalibre1 pcalibre calibre6"/>and subtrees are always expressed as subdirectories of the superproject (the master project). You can’t mix files from different subsystems in one directory.</p>
<p class="calibre3">Experience <a id="_idIndexMarker1046" class="pcalibre1 pcalibre calibre6"/>shows that most systems use such <a id="_idIndexMarker1047" class="pcalibre1 pcalibre calibre6"/>a directory hierarchy, even in monolithic repositories, which is a good beginning for modularization efforts. Therefore, transforming a subfolder into a real submodule/subtree is fairly easy and can be done in the following sequence of steps:</p>
<ol class="calibre14">
<li class="calibre15">Move the subdirectory in question outside the working area of a superproject to have it beside the top directory of the superproject. If it is important to keep the history of a subproject, consider using <strong class="source-inline1">git subtree split</strong>, or <strong class="source-inline1">git filter-branch --subdirectory-filter</strong> or its equivalent, perhaps together with tools such as <strong class="source-inline1">reposurgeon</strong> to clean up the history. See <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>, for more details.</li>
<li class="calibre15">Rename the directory with the subproject repository to better express the essence of the extracted component. For example, a subdirectory originally named <strong class="source-inline1">refresh</strong> could be renamed <strong class="source-inline1">refresh-client-app-plugin</strong>.</li>
<li class="calibre15">Create the public repository (upstream) for the subproject as a first-class project (for example, create a new project on GitHub to keep extracted code, either under the same organization as a superproject, or under a specialized organization for application plugins).</li>
<li class="calibre15">Initialize <a id="_idIndexMarker1048" class="pcalibre1 pcalibre calibre6"/>a self-sufficient and standalone plugin as a Git repository with <strong class="source-inline1">git init</strong>. If, in <em class="italic">step 1</em>, you have extracted <a id="_idIndexMarker1049" class="pcalibre1 pcalibre calibre6"/>the history of the subdirectory into some branch, then push this branch into the just-created repository. Set up the public repository created in <em class="italic">step 3</em> as a default remote repository <a id="_idIndexMarker1050" class="pcalibre1 pcalibre calibre6"/>and push the initial commit (or the whole history) to the just-created URL to store the subproject code.</li>
<li class="calibre15">In the <a id="_idIndexMarker1051" class="pcalibre1 pcalibre calibre6"/>superproject, read the subproject you have just extracted but, this time, as a proper submodule or subtree, whichever solution is a better fit and whichever method you prefer to use. Use the URL of the just-created public repository for the subproject.</li>
<li class="calibre15">Commit the changes in the superproject and push them to its public repository, in the case of submodules, including the newly created (or the just modified) <strong class="source-inline1">.</strong><strong class="source-inline1">gitmodules</strong> file.</li>
</ol>
<p class="calibre3">The recommended practice for the transformation of a subdirectory into a standalone submodule is to use a read-only URL for cloning (adding back) a submodule. This means that you can use either the <code>git://</code> protocol (warning: in this case, the server is unauthenticated) or <code>https://</code> without a username. The goal of this recommendation is to enforce separation by moving the work on a submodule code to a standalone separate subproject repository. In order to ensure that the submodule commits are available to all other developers, every change should go through the public repository for a subproject.</p>
<p class="calibre3">If this <a id="_idIndexMarker1052" class="pcalibre1 pcalibre calibre6"/>recommendation (best practice) is met <a id="_idIndexMarker1053" class="pcalibre1 pcalibre calibre6"/>with a categorical refusal, in practice, you could <a id="_idIndexMarker1054" class="pcalibre1 pcalibre calibre6"/>work on the subproject source <a id="_idIndexMarker1055" class="pcalibre1 pcalibre calibre6"/>code directly inside the superproject, though it is more error-prone. You would need to remember to commit and push in the submodule first, doing it from inside of the nested submodule subdirectory; otherwise, other developers would be not able to get the changes. This combined approach might be simpler to use, but it loses the true separation between implementing and consuming changes, which should be better assumed while using submodules.</p>
<h1 id="_idParaDest-264" class="calibre5"><a id="_idTextAnchor293" class="pcalibre1 pcalibre calibre6"/>Subtrees versus submodules</h1>
<p class="calibre3">In general, subtrees are easier to use and less tricky. Many people go with submodules, because <a id="_idIndexMarker1056" class="pcalibre1 pcalibre calibre6"/>of the better built-in tooling (they have their own Git command, namely, <code>git submodule</code>), detailed documentation, and similarity to the <a id="_idIndexMarker1057" class="pcalibre1 pcalibre calibre6"/>Subversion externals, making them feel falsely familiar. Adding a submodule is very simple (just run <code>git submodule add</code>), especially compared to adding a subtree without the help of third-party tools such as <code>git subtree</code> or <code>git subrepo</code>.</p>
<p class="calibre3">The major difference between subtrees and submodules is that, with subtrees, there’s only one repository, which means just one life cycle. Submodules and similar solutions use nested repositories, each with its own lifeline.</p>
<p class="calibre3">Though submodules are easy to set up and fairly flexible, they are also fraught with peril, and you need to practice vigilance while working with them. The fact that the submodules are opt-in also means that the changes touching the submodules demand a manual update by every collaborator. Subtrees are always there, so getting the superproject’s changes means getting the subproject’s too.</p>
<p class="calibre3">Commands such as <code>status</code>, <code>diff</code>, and <code>log</code> display precious little information about submodules, unless properly configured to cross the repository boundary; it is easy to miss a change. With subtrees, <code>status</code> works normally, while <code>diff</code> and <code>log</code> need some care because the subproject commits have a different root directory. The latter assumes that you did not decide to not include the subproject history (by squashing subtree merges). Then, the problem is only with the remote-tracking branches in the subproject’s repository, if any.</p>
<p class="calibre3">Because the life cycles of different repositories are separate, updating a submodule inside its containing project requires two commits and two pushes. Updating a subtree-merged subproject is very simple: only one commit and one push. On the other hand, publishing the <a id="_idIndexMarker1058" class="pcalibre1 pcalibre calibre6"/>subproject changes upstream is much easier with <a id="_idIndexMarker1059" class="pcalibre1 pcalibre calibre6"/>submodules, while it requires changeset extraction with subtrees (here, tools such as <code>git subtree</code> help a lot).</p>
<p class="calibre3">The next major issue, and a source of problems, is that the submodule has two sources of the current revision: the gitlink in the superproject and the branches in the submodule’s clone of the repository. This means that <code>git remote update</code> works a bit like a sideways push into a non-bare repository (see <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>). Submodule heads are, therefore, generally detached, so any local update requires various preparatory actions to avoid creating a lost commit. There is no such issue with subtrees. All the revision changing commands work as usual with subtrees, bringing the subproject directory to the correct version without the requirement of any additional action. Getting changes from the subproject repository is just a subtree merge away. The only difference between ordinary pull is the <code>-s </code><code>subtree</code> option.</p>
<p class="calibre3">Still, sometimes, submodules are the right choice. Compared to subtrees, they allow for a subproject (a module) to be not fetched, which is helpful when your code base is massive. Submodules are also useful when the heavy modularization is not natively handled, or not well natively handled, by the development stack’s ecosystem.</p>
<p class="calibre3">Submodules might also themselves be superprojects for other submodules, creating a hierarchy of subprojects. Using nested submodules is made easier thanks to the <code>git submodule status</code>, <code>update</code>, <code>foreach</code>, and <code>sync</code> subcommands all supporting the <code>--</code><code>recursive</code> switch.</p>
<h2 id="_idParaDest-265" class="calibre7"><a id="_idTextAnchor294" class="pcalibre1 pcalibre calibre6"/>Use cases for subtrees</h2>
<p class="calibre3">With subtrees, there is only one repository (no nested repositories), just like a regular code base. This means that there is just one life cycle. One of the key benefits of subtrees is <a id="_idIndexMarker1060" class="pcalibre1 pcalibre calibre6"/>being able to mix container-specific customizations with general-purpose fixes and enhancements.</p>
<p class="calibre3">Projects can be organized and grouped together in whatever way you find to be most logically consistent. Using a single repository also reduces the overhead of managing dependencies.</p>
<p class="calibre3">The basic example of using subtrees is managing the customized version of a library, a <em class="italic">required dependency</em>. It is easy to get a development environment set up to run builds and tests. Monorepo makes it also viable to have one universal version number for all the projects. Atomic cross-submodule commits are possible; therefore, a repository can always be in a consistent state.</p>
<p class="calibre3">You can also use subtrees for <em class="italic">embedding related projects</em>, such as a GUI or a web interface, inside a superproject. In fact, many use cases for submodules can also apply to the subtrees solution, with the exception of the cases where there is a need for a subproject to be optional, or to have different access permissions than a master project. In those cases, you need to use submodules.</p>
<h2 id="_idParaDest-266" class="calibre7"><a id="_idTextAnchor295" class="pcalibre1 pcalibre calibre6"/>Use cases for monorepo</h2>
<p class="calibre3">If all subprojects are managed by a single organization or a company, then it might be advantageous <a id="_idIndexMarker1061" class="pcalibre1 pcalibre calibre6"/>to have all those inter-related projects in a single repository, which we call monorepo.</p>
<p class="calibre3">One of the advantages is simplified organization. You can group and organize projects in whatever way you find to be most logically consistent. You don’t need to consider how to split them into separate repositories, and how to join them into a superproject. It is also easier to navigate and search the history and the contents if all is in the single repository.</p>
<p class="calibre3">Because atomic cross-project commits are possible with monorepo, the repository can be always in a consistent state. It is easier to ensure that everything uses the same version of a specific component. Making cross-repository/cross-project changes in a polyrepo setting (multiple repositories, one per project, managed with a subtree or submodule strategy) is much more difficult than in a monorepo.</p>
<p class="calibre3">It is also easier to keep <a id="_idIndexMarker1062" class="pcalibre1 pcalibre calibre6"/>consistent tooling and a common <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) infrastructure.</p>
<h2 id="_idParaDest-267" class="calibre7"><a id="_idTextAnchor296" class="pcalibre1 pcalibre calibre6"/>Use cases for submodules</h2>
<p class="calibre3">The strongest argument for the use of submodules is the issue of modularization. Here, the main area of use for submodules is handling plugins and extensions. Some programming <a id="_idIndexMarker1063" class="pcalibre1 pcalibre calibre6"/>ecosystems, such as ANSI C and C++ and also Objectve-C, lack good and standard support for managing version-locked multimodule projects. In this case, a plugin-like code can be included in the application (superproject) using submodules, without sacrificing the ability to easily update to the latest version of a plugin from its repository. The traditional solution of putting instructions about how to copy plugins in the README disconnects it from the historical metadata.</p>
<p class="calibre3">This schema can be extended also to the non-compiled code, such as the Emacs Lisp settings, configuration in dotfiles, (including frameworks such as <code>oh-my-zsh</code>), and themes (also for web applications). In these situations, what is usually needed to use a component is the physical presence of a module code at conventional locations inside the master project tree, which is mandated by the technology or framework being used. For instance, themes and plugins for WordPress, Magento, and so on are often de facto installed this way. In many cases, you need to be in a superproject to test these optional components.</p>
<p class="calibre3">Yet another particular use case for submodules is the division based on <em class="italic">access control and visibility restriction</em> of a complex application. For example, the project might use a cryptographic code with license restrictions, limiting access to it to a small subset of developers. With this code in a submodule with restricted access to its repository, other developers would simply be unable to clone this submodule. In this solution, the common build system needs to be able to skip cryptographic components if it is not available. On the other hand, the dedicated build server can be configured in such a way that the client gets the application built with crypto enabled.</p>
<p class="calibre3">A similar visibility restriction purpose, but in reverse, is making the source code of examples available long before it was to be published. This allows for better code thanks to the social input. The main repository for a book itself can be closed (private), but having an <code>examples/</code> directory contain a submodule intended for a sample source code allows <a id="_idIndexMarker1064" class="pcalibre1 pcalibre calibre6"/>you to make this subrepository public. While generating the book in the PDF and EPUB (and perhaps also MOBI) formats, the build process can then embed these examples (or fragments of them), as if they were ordinary subdirectories.</p>
<h1 id="_idParaDest-268" class="calibre5"><a id="_idTextAnchor297" class="pcalibre1 pcalibre calibre6"/>Third-party subproject management solutions</h1>
<p class="calibre3">If you don’t find a good fit in either <code>git subtree</code> or <code>git submodule</code>, you can try to use <a id="_idIndexMarker1065" class="pcalibre1 pcalibre calibre6"/>one of the many third-party projects to manage dependencies, subprojects, or collections of repositories.</p>
<p class="calibre3">One such <a id="_idIndexMarker1066" class="pcalibre1 pcalibre calibre6"/>tool is <code>repo</code> (<a href="https://android.googlesource.com/tools/repo/" class="pcalibre1 pcalibre calibre6">https://android.googlesource.com/tools/repo/</a>) used by the Android open source project to unify the many Git repositories for cross-network operations.</p>
<p class="calibre3">Another <a id="_idIndexMarker1067" class="pcalibre1 pcalibre calibre6"/>tool is <code>gil</code> (gitlinks) (<a href="https://github.com/chronoxor/gil" class="pcalibre1 pcalibre calibre6">https://github.com/chronoxor/gil</a>) to manage complex recursive repositories dependencies, with cross references and cycles. Compared to submodules, <code>gil</code> avoids including the same dependency multiple times if the superproject and its subproject use the same library as a dependency. This tool also makes it easier to contribute changes upstream than with <code>git subtree</code>.</p>
<p class="calibre3">If you need to split a single monolithic repository into many standalone repositories, besides <code>git subtree split</code>, you can use a third-party <code>splitsh-lite</code> tool. If, on the other hand, you have multiple separate repositories that you want to merge into a single monorepo, you can use the <code>tomono</code> tool.</p>
<p class="calibre3">You can find many other such tools.</p>
<p class="callout-heading">Important consideration</p>
<p class="callout">When choosing between native support and one of the many tools to manage many repositories together, you should check whether the tool in question uses a subtree-like or submodule-like approach to find whether it would be a good fit for your project.</p>
<h1 id="_idParaDest-269" class="calibre5"><a id="_idTextAnchor298" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter provided all the tools you need to manage multicomponent projects with Git, from libraries and graphical interfaces, through plugins and themes, to frameworks.</p>
<p class="calibre3">You learned about the concept behind the subtrees technique and how to use it to manage subprojects. You know how to create, update, examine, and manage subprojects using subtrees.</p>
<p class="calibre3">You got to know the submodule approach of nested repositories for optional dependencies. You learned the ideas behind gitlinks, <code>.gitmodules</code>, and <code>.git</code> files. You encountered the pitfalls and traps for the unwary that you need to be vigilant about while using submodules. You know the reason for these problems and understand the notions behind them. You know how to create, update, examine, and manage subprojects using submodules.</p>
<p class="calibre3">You learned when to use subtrees and submodules, and their advantages and disadvantages. You know a few use cases for each technique.</p>
<p class="calibre3">Now that you know how to use Git effectively in a variety of circumstances and have learned the high-level ideas behind Git behavior that help you understand it, it’s time to tackle how to make Git easier to use in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git</em>.</p>
<h1 id="_idParaDest-270" class="calibre5"><a id="_idTextAnchor299" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">What are subtrees, and what are their advantages and disadvantages?</li>
<li class="calibre15">What are submodules, and what are their advantages and disadvantages?</li>
<li class="calibre15">Why is the information about submodules duplicated between <strong class="source-inline1">.gitmodules</strong> and project configuration?</li>
</ol>
<h1 id="_idParaDest-271" class="calibre5"><a id="_idTextAnchor300" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li class="calibre15">With subtree merging, the history of the subproject (or its summary) is included in the superproject repository, and subproject files are put directly in a subirectory of the superproject and are superproject files. Subtrees can be used only for required dependencies, as they are embedded in a superproject. They are simpler to understand and use.</li>
<li class="calibre15">With submodules, repositories and the histories of superproject and subproject are kept separate. A superproject includes a link to the commit in a subproject. Submodules can be initialized and active, but can also be kept inactive, thus they can be used for optional dependencies. To include a change, you need to make a change in a subproject and to include it in a commit in a superproject.</li>
<li class="calibre15">The information in the project configuration file about submodules is local to the repository and, among others, defines which submodules are active and which are not.</li>
</ol>
<h1 id="_idParaDest-272" class="calibre5"><a id="_idTextAnchor301" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15"><em class="italic">git-submodule</em> – Initialize, update, or inspect submodules: <a href="https://git-scm.com/docs/git-submodule" class="pcalibre1 pcalibre calibre6">https://git-scm.com/docs/git-submodule</a></li>
<li class="calibre15"><em class="italic">git-subtree</em> – Merge subtrees together and split the repository into subtrees: <a href="https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt" class="pcalibre1 pcalibre calibre6">https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt</a></li>
<li class="calibre15">Git documentation HOWTO – <em class="italic">How to use the subtree merge </em><em class="italic">strategy</em>: <a href="https://github.com/git/git/blob/master/Documentation/howto/using-merge-subtree.txt" class="pcalibre1 pcalibre calibre6">https://github.com/git/git/blob/master/Documentation/howto/using-merge-subtree.txt</a></li>
<li class="calibre15">Scott Chacon, Ben Straub: <em class="italic">Pro Git</em>, 2nd Edition (2014) <a href="https://git-scm.com/book/en/v2" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2</a><ul class="calibre18"><li class="calibre15">Chapter <em class="italic">7.11 Git Tools - </em><em class="italic">Submodules</em></li></ul></li>
<li class="calibre15">Eric Pidoux, <em class="italic">Git Best Practices Guide</em> (2014), Packt Publishing Ltd<ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 4</em>, <em class="italic">Going Deeper into Git, Managing </em><em class="italic">Git Submodules</em></li></ul></li>
<li class="calibre15">Johan Abildskov, <em class="italic">Practical Git: Confident Git Through Practice</em> (2020), Apress<ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 8</em>, <em class="italic">Additional Git Features – </em><em class="italic">Git Submodules</em></li></ul></li>
<li class="calibre15">Everything you need to know about monorepos and the tools to build them: <a href="https://monorepo.tools/" class="pcalibre1 pcalibre calibre6">https://monorepo.tools/</a></li>
</ul>
</div>
</body></html>