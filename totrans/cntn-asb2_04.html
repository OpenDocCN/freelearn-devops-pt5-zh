<html><head></head><body>
        

                            
                    <h1 class="header-title">What&amp;#x27;s in a Role?</h1>
                
            
            
                
<p>In <a href="4b15cefb-8d9c-48b7-8927-126501886315.xhtml" target="_blank">Chapter 3</a>, <em>Your First Ansible Container Project</em>, we learned the basics about Ansible Container roles, what they do, and how to download, install, and tweak them from Ansible Galaxy. In this chapter, we will look at writing our own Ansible Container roles that we can use to build custom container images from scratch. You will learn that Ansible provides an easy-to-learn, expressive language for defining desired states, and service configurations. To illustrate how Ansible Container can be used to quickly build services and run containers, over the course of this chapter we will write a role that builds a MariaDB MySQL container that can be run on your local workstation. In this chapter, we will cover:</p>
<ul>
<li class="mce-root">Custom roles with Ansible Container</li>
<li class="mce-root">A brief overview of MariaDB</li>
<li class="mce-root">Initializing an Ansible Container role</li>
<li class="mce-root">What's in a container-enabled role?</li>
<li class="mce-root">Creating the MariaDB project and role</li>
<li class="mce-root">Writing a container-enabled role</li>
<li class="mce-root">Customizing a container-enabled role</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom roles with Ansible Container</h1>
                
            
            
                
<p>One growing theme throughout the course of this book is how much freedom Ansible Container gives you to build and deploy custom container images quickly, efficiently, securely, and reliably. So far, we have looked at using Ansible Container to define and run services from prebuilt community containers, as well as leveraging community-written roles to instantiate, build, and customize our containers. This is an excellent way to get started with Ansible Container and get a head start in familiarizing yourself with the Ansible Container workflow. However, the real power of Ansible Container begins to really show itself when you start writing roles that build custom container images.</p>
<p>If you have experience using Ansible as a configuration management tool, you might be familiar with writing Ansible playbooks and roles already. This will definitely give you a head start with writing containerized roles, but it is not a prerequisite for working through the examples in this chapter. To put everyone on a level playing field, I am going to assume that you have no experience writing Ansible playbooks or roles, and we will essentially start from scratch. For those of you who are Ansible veterans, a lot of this will be a review, but hopefully you may learn something new. For Ansible beginners, I hope this chapter will excite your curiosity, not only to go forward into building more advanced Ansible Container roles but also to go further and explore Ansible Core configuration management concepts as well.</p>
<p>The original motivation behind Ansible was to create a configuration management and orchestration system that is easy for just about anyone to pick up and start working with. Ansible quickly became immensely popular amongst software developers, system administrators, and DevOps engineers as a tool that is not only easy to adopt, but also easy to customize, and even incorporate into existing platforms and configuration management tools. I first started using Ansible because, at the time, I was working on projects that required me to log into numerous bare-metal servers and virtual machines to perform the same set of commands over and over again. At that time, I was trying to hack my way into making this easier by writing flaky shell scripts that would use SSH to push remote commands to the servers. Over the course of my research into how to make these scripts more resilient, I discovered Ansible, which I immediately adopted and it made my work far easier and more reliable then I had imagined. I believe there are two primary reasons that Ansible is so popular in the IT industry:</p>
<ul>
<li>Easy to understand YAML syntax for playbooks and roles. YAML is easy to learn and write, which makes it perfect for Ansible.</li>
<li>Hundreds, if not thousands, of built-in modules that come with Ansible Core. These modules allow us to do almost anything you can imagine, right out of the box.</li>
</ul>
<p>Let's look at these two unique aspects of Ansible and understand how we can leverage this ease of use in our own projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">YAML syntax</h1>
                
            
            
                
<p>YAML is a data serialization format that recursively stands for, <em>YAML Ain't Markup Language</em>. You may have worked with other serialization formats in the past, such as XML or JSON. What makes YAML unique is that it is easy to write, and quite possibly the most human-readable data format currently used. Ansible chose to use YAML as the basis for defining its playbook syntax and language due to the fact that, even if you do not come from a programming background, YAML is super-easy to get started with writing, using, and understanding. YAML is unique in the way that it uses a series of colons (<kbd>:</kbd>), dashes (<kbd>-</kbd>), and indentations (spaces, not tabs) to define key-value pairs. These key-value pairs can be used to define almost every type of computer science data types, such as integers, Booleans, strings, arrays, and hash tables. Following is an example of a YAML document, illustrating some of these constructs:</p>
<pre class="western">---
#This is a Comment in a YAML document. Notice the YAML document starts with a series of three dashes: ---

MyString: "This is a string"

MyArray:
  - "Item1"
  - "Item2"

MyBoolean: true

MyInteger: 10

MyHashTable:
  KeyOne: "ValueOne"
  KeyTwo: "ValueTwo"
  KeyThree: "ValueThree"</pre>
<p>The preceding example demonstrates a simple YAML file consisting of the most basic constructs: a string variable, an array (list of items), a Boolean (true/false) variable, an integer variable, and a hash table holding a series of key-value pairs. This may look quite similar to work we have done previously in this book when modifying the <kbd>container.yml</kbd> files, as well as the Docker Compose files. These formats are also defined in YAML and consist of many of the same constructs.</p>
<p>A few things that I would like to call your attention to in the preceding example (you should also keep in them mind when you begin writing Ansible playbooks and roles) are:</p>
<ul>
<li class="mce-root">All YAML documents begin with three dashes: <kbd>---</kbd>. This is important because you may have multiple YAML documents defined in the same single file. Documents would then be separated using the three dashes.</li>
<li class="mce-root">Comments are defined using the hash sign: <kbd>#</kbd>.</li>
<li class="mce-root">Strings are surrounded by quotation marks. This separates strings from literals, such as Booleans (true or false words without quotation marks), or integers (numbers without quotation marks). If you surrounded the words <em>true</em>/<em>false</em>, or a numerical value with quotation marks, they will be interpreted as strings.</li>
<li class="mce-root">Colons (<kbd>:</kbd>) are used to separate key-value pairs, which define almost everything.</li>
<li class="mce-root">Indentation is indicated by two spaces. Tabs are not recognized in the YAML format. When getting started with writing YAML documents, make sure your text editor is configured to place two spaces into your document when you hit the <em>Tab</em> key. This makes it easy to quickly and naturally indent text as you type.</li>
</ul>
<p>I realize that there is much more to YAML syntax than what I have provided in this example. My goal here is to dig a little deeper than in the earlier chapters to help give the reader a deeper understanding of the YAML format going forward. This is by no means a full description of the entire YAML format. If you want to read more about YAML, I would recommend you check out the official YAML specification website: <a href="http://yaml.org/">http://yaml.org</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible modules</h1>
                
            
            
                
<p>The second part of what makes Ansible so popular and easy to use is the plethora of modules that Ansible can leverage right out of the box, which can do almost anything the user can think of. Think of modules as the building blocks of Ansible, that define what your playbook does. There are Ansible modules that can edit the content of files on remote systems, add or delete users, install service packages, and even interact with APIs for remote applications. Modules themselves are written in Python and get called in a scripted format from YAML playbooks. The playbooks themselves are simply just a series of calls to Ansible modules that perform a specific series of tasks. Let's look at a very simple playbook to understand how this works in practice:</p>
<pre class="western">---
- name: Create User Account
  user:
    name: MyUser
    state: present

- name: Install Vim text editor
  apt:
    name: vim
    state: present</pre>
<p>This simple playbook consists of two separate tasks: creating a user account and installing the Vim text editor. Each task in Ansible calls for exactly one module to perform an action. Tasks in Ansible are defined using YAML dashes, followed by the name of the task, the name of the module, and all of the parameters you want to feed into that module indented as mentioned in the following. In our first task, we are creating a user account by calling the <kbd>user</kbd> module. We are giving the user module two parameters: <kbd>name</kbd> and <kbd>state</kbd>. The <kbd>name</kbd> represents the name of the user we want to create, and the <kbd>state</kbd> represents how we want the desired state on our remote system or container to look. In this case, we want a user to exist called <kbd>MyUser</kbd> and the state we want that user to be in is <kbd>present</kbd>. If this Ansible playbook gets executed and the user called <kbd>MyUser</kbd> already exists, Ansible will take no action since the system is in the desired state.</p>
<p>The second task in this playbook installs the text editor Vim on our remote system or container. To accomplish this, we are going to use the <kbd>apt</kbd> module to install a Debian APT package. If this was a Red Hat or CentOS system, we would similarly use the <kbd>yum</kbd> or <kbd>dnf</kbd> module. The name represents the name of the package we want to install, and the state represents the desired state of the server or container. Thus, we would like the Vim Debian package to be installed. As we mentioned earlier, there are hundreds, if not thousands, of Ansible modules that can be leveraged in playbooks and roles. You can find the full list of Ansible modules by category as well as excellent examples of parameters that the modules take, in the Ansible documentation at <a href="http://docs.ansible.com/ansible/latest/modules_by_category.html">http://docs.ansible.com/ansible/latest/modules_by_category.html</a>.</p>
<p>The <kbd>state</kbd> parameter also takes the value <kbd>absent</kbd> to remove a user, package, or almost anything else that could be defined.</p>
<p>One of the major benefits of Ansible Container is that, in writing container configuration using Ansible roles, you have the entire universe of Ansible modules available to you to choose from. Unfortunately, not all Ansible modules work in the context of a container. A traditional example of this is modules that manage the state of running services, such as the <kbd>service</kbd> module. The <kbd>service</kbd> module does not run in containers, since application containers typically lack traditional init systems that you would find in a full operating system to start, stop, and restart running services. In a containerized context, this is handled by starting your container with a <kbd>CMD</kbd> or <kbd>entrypoint</kbd> statement that directly executes a service binary.</p>
<p>Furthermore, almost any module that manages the orchestration of cloud services or call external APIs will not run in a containerized context. This is pretty straightforward since you would usually not want to orchestrate the state of external services when you are building an independent containerized microservice. Of course, if you are writing an Ansible playbook that deploys a containerized application you previously built using Ansible Container, you can use these orchestration modules to react in certain ways when the container comes online. However, for the purposes of this chapter, we will limit our discussion only to writing roles that build containerized services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A brief overview of MariaDB</h1>
                
            
            
                
<p>Throughout this chapter, we will be writing an Ansible Role that builds a MariaDB database container. MariaDB is a fork of the MySQL relational database server, which provides numerous customizations and optimizations that are not found in vanilla MySQL. Out of the box, MariaDB supports numerous optimizations, such as replication, query optimization, encryption, performance, and speed improvements over standard MySQL, yet remains fully MySQL-compatible, leveraging a free and open source GPL license. MariaDB was chosen for this example due to its relative simplicity to deploy and the free nature of the application itself. In this chapter, we will build a relatively basic single-node MariaDB installation that does not contain a lot of features and performance tweaks that you would find in a production-ready installation. The purpose of this chapter is not how to build a production-ready MariaDB container, but rather to illustrate the concepts of building a containerized service using Ansible Container. If you want to go further with this example, feel free to tweak this code in any way you see fit. Extra credit to those of you who build production-ready containers!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Initializing an Ansible Container role</h1>
                
            
            
                
<p>As discussed previously, Ansible roles are a self-contained, reusable set of playbooks, templates, variables, and other metadata that defines an application or service. Since Ansible roles are designed to work with Ansible Galaxy, Ansible Galaxy command-line tools have built-in functionality to initialize roles that contain all of the proper directories, default files, and scaffolding designed to create a functioning Ansible role with minimal hassle. This works very similarly to the <kbd>ansible container init</kbd> command for creating Ansible Container projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What's in a container-enabled role?</h1>
                
            
            
                
<p>To create a new container-enabled role in Ansible Container, we are going to use the <kbd>ansible-galaxy init</kbd> command with the <kbd>container-enabled</kbd> flag to create the new role directory structure for us. To examine what happens when we use this command, let's initialize a role in the <kbd>/tmp</kbd> directory on our Vagrant VM and see what Ansible creates for us:</p>
<pre class="western"><strong>ubuntu@node01:/tmp$ ansible-galaxy init MyRole --container-enabled
- MyRole was created successfully</strong></pre>
<p>Upon successful execution of the <kbd>init</kbd> command, Ansible should return a message indicating that your new role was <kbd>created successfully</kbd>. If you run the <kbd>ls</kbd> command, you will find a new directory named after the role we just initialized. Everything that comprises of the role resides in this directory, according to the default directory structure. When you call a role from Ansible, Ansible will look in all of the locations you indicated your roles should live in and will look for a directory with the same name as your role. We will see this in more detail later in this chapter. If you navigate inside this directory, you will find a folder structure similar to the following:</p>
<pre class="western">MyRole/
├── defaults
│   └── main.yml
├── handlers
│   └── main.yml
├── meta
│   ├── container.yml
│   └── main.yml
├── README.md
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── ansible.cfg
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml</pre>
<p>Let's take a look at what each of these directories and files does:</p>
<ul>
<li class="mce-root"><kbd>defaults/</kbd>: <kbd>defaults</kbd> is a directory that contains variables specific to your role and has the lowest priority for overriding the values. Any variables that you want to place in your role that you definitely want or require the user to override should go in the <kbd>main.yml</kbd> file of this directory. This is not to be confused with the <kbd>vars/</kbd> directory.</li>
<li class="mce-root"><kbd>handlers/</kbd>: <kbd>handlers</kbd> are a concept in Ansible that defines tasks that should be executed in response to notify events sent from other tasks during a role execution. For example, you may have a task that updates a configuration file in your role. If your service needs to be restarted in response to that configuration file update, you could specify a <kbd>notify:</kbd> the step in your task, as well as the name of your handler. If the parent task executes and resolves a <kbd>CHANGED</kbd> status, Ansible will look inside of the <kbd>handlers/</kbd> directory for the task specified by the notify statement and then execute that task. Please note that handlers do not execute unless another playbook task specifically calls that task using the <kbd>notify:</kbd> statement and results in a changed status. Handlers are not quite as common in container-enabled roles since containers usually aren't dependent on external events and circumstances.</li>
<li class="mce-root"><kbd>meta</kbd>: <kbd>Meta</kbd> is a directory which contains the metadata for Ansible roles. In a container-enabled role, it contains two primary files: <kbd>main.yml</kbd> which contains general metadata about the role, such as dependencies, Ansible Galaxy data, and conditions upon which the role is contingent. For the purposes of this example, we will not do very much with this file. The second file, <kbd>container.yml</kbd>, is more important to us. This <kbd>container.yml</kbd> is specific to container-enabled roles and is critical for specifying the default values that will be injected into the project-level <kbd>container.yml</kbd> file when we call our role. Here, we can specify the container image, volume information, as well as the default command and <kbd>entrypoint</kbd> data that we want our container to run with by default. All of this data can be overridden in our parent <kbd>container.yml</kbd> file if we so choose.</li>
<li class="mce-root"><kbd>tasks</kbd>: The <kbd>tasks</kbd> directory is where we specify the tasks that actually get executed inside our container and build the service. By default, Ansible will execute the <kbd>main.yml</kbd> file and execute all tasks in the order as specified. Any other task files can go into this directory as well and can be executed using the <kbd>include:</kbd> statement from our <kbd>main.yml</kbd> file.</li>
<li class="mce-root"><kbd>templates</kbd>: The templates directory stores the configuration file templates we want to use in our role. Since Ansible is Python-based, it uses the Jinja2 templating engine to place configuration templates into the container and update values based on variables identified in the <kbd>defaults/</kbd> and <kbd>vars/</kbd> directories. All files in this directory should have the <kbd>.j2</kbd> file extension, although this is not required.</li>
<li class="mce-root"><kbd>tests</kbd>: Any automated testing that you would like a CICD tool to perform would go here. Usually, developers would put any custom Ansible configurations, parameters, or inventories that the CI/CD tool will requires as input in the directories and files that are autogenerated in this directory.</li>
<li class="mce-root"><kbd>vars</kbd>: The <kbd>vars/</kbd> directory is the location in which a developer can specify other variables available to the role here. It is important to note that the <kbd>vars/</kbd> directory has a lower precedence than the <kbd>defaults/</kbd> directory, so variables defined here are more difficult to override than the ones specified in <kbd>defaults</kbd>. Usually, when I write a role, I will make all of my variables available in the <kbd>defaults</kbd> directory, as I want the user to have full power to override anything they desire. There might be circumstances in which you may not want your variables as easy to access, in which case they could be specified in the <kbd>vars/</kbd> directory.</li>
</ul>
<p>Any file in your role named, <kbd>main.yml</kbd> indicates that the file is a default and will be executed automatically.</p>
<p>Now that we know what makes up a container-enabled role, we can take this knowledge and create a new Ansible Container project that will build our MariaDB MySQL role. To accomplish this, we are going to initialize a new project and create a subdirectory called <kbd>roles/</kbd>, which will contain the role we will create. When we build our project, Ansible will know to look inside of our <kbd>roles/</kbd> directory and find all of the roles we have specified and created there. Please note that the following sections of this chapter will get quite code-heavy. To make the process of following along easier, the completed example can be found in the official book GitHub repository under the <kbd>AnsibleContainer/mariadb_demo</kbd> directory. However, the best way to learn how to write Ansible code is by repetition and practice, which can only be attained by writing the code yourself. It is strongly suggested that, while it may not be practical to copy the code written in this chapter verbatim, one should obtain practice writing Ansible code by using these examples to create your own project or modifying the example in the Git repository. The more code you write, the better and more fluent of an Ansible developer you will become.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Initializing the MariaDB project and role</h1>
                
            
            
                
<p>Now that we have a feel for how a container-enabled role is structured, we can start our MariaDB container by initializing a new Ansible Container project. In a new directory on your Vagrant host, start a new project as usual by using the <kbd>ansible-container init</kbd> command:</p>
<pre class="western"><strong>ubuntu@node01:$ ansible-container init 
Ansible Container initialized.</strong></pre>
<p class="western">Inside of our <kbd>project</kbd> directory, we can create a directory that will store our roles. In the Ansible Core, the default location for a role is in the <kbd>/etc/ansible/roles</kbd> or a <kbd>roles/</kbd> directory relative to the playbook you are executing. It should be noted, however, that roles can be stored in any location provided the Ansible installation has read access to the path. For the purposes of this demonstration, we are going to create our roles path as a <kbd>child</kbd> directory of our project. Within our <kbd>project</kbd> directory, create a new directory called <kbd>roles</kbd> and initialize our Ansible Container role inside of that directory. We will call our role <kbd>mariadb_role</kbd>:</p>
<pre class="western"><strong>ubuntu@node01:$ mkdir roles/
ubuntu@node01:$ cd roles/
ubuntu@node01:roles$ ansible-galaxy init mariadb_role --container-enabled
- mariadb_role was created successfully</strong></pre>
<p>Now that our role has been created inside of our project, we need to modify our project <kbd>container.yml</kbd> file so that it knows the path we are sourcing our roles from, as well as to create a service that we will build using our role. The roles location can be specified using the <kbd>roles_path</kbd> option as a child parameter of <kbd>settings:</kbd> in the <kbd>container.yml</kbd> file. Here, we can specify the paths we want Ansible to search for roles as list items of <kbd>roles_path</kbd> using the hyphen notation (<kbd>-</kbd>). We will specify the <kbd>roles</kbd> directory we just created. Under the <kbd>services:</kbd> subsection, we can create a new service called <kbd>MySQL_database_container</kbd>. This will leverage the role <kbd>mariadb_role</kbd> that we just created. We also want to make sure that we specify the base image we want to use for our service.  For this example, the MariaDB container will be based on Ubuntu 16.04, so we want to make sure our <kbd>conductor_base</kbd> image is the same to ensure compatibility. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">container.yml</h1>
                
            
            
                
<p>Following is a sample of the <kbd>container.yml</kbd> file that provides these settings:</p>
<pre class="western">version: "2"
settings:
  conductor_base: ubuntu:16.04
  roles_path:
    - ./roles/

services:
services:
  MySQL_database_container:
    roles:
      - role: mariadb_role
registries: {}</pre>
<p>At this point, we could build our project, but it would result in an empty container since our role contains no tasks from which we can build a container image. Let's make things interesting by adding tasks as well as updating the role-specific <kbd>container.yml</kbd> file.</p>
<p>Always remember to use the same conductor base image that your service containers will use. This will ensure maximum compatibility when building your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing a container-enabled role</h1>
                
            
            
                
<p>As we discussed previously, it is quite difficult to walk the reader through writing code from scratch, due to the fact that file paths can get complicated rather quickly, making it easy to lose your place. In this section, I will show what the modified files look like and draw the reader's attention to the parts of the files that require explanation. Since it is quite easy to get lost, I will direct the reader to follow along in the official book GitHub repository located at the following URL: <a href="https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo">https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo</a>.</p>
<p>As developers of a container-enabled role, the most important parts of writing a role is the role-specific <kbd>container.yml</kbd> file, which specifies the default values the container will run with, as well as the tasks that are used to build the container and put all of the pieces in place. The tasks you build the container with will often determine the parameters in the role-specific <kbd>container.yml</kbd> file. When writing a role, developers will often tweak and modify the <kbd>container.yml</kbd> file as they are writing the playbook tasks. When you call a role from the project-specific <kbd>container.yml</kbd> file, the contents of the role-specific <kbd>container.yml</kbd> file will be used to build your container. At any point, a developer can override the role-specific <kbd>container.yml</kbd> file by simply modifying the parameters in the project <kbd>container.yml</kbd>.</p>
<p>It is important as a role developer to write sane defaults for your role's <kbd>container.yml</kbd> to enable other users to leverage your role quickly. For our MariaDB demonstration, we will create a simple role-specific <kbd>container.yml</kbd> file that resembles the following:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">roles/mariadb_role/meta/container.yml</h1>
                
            
            
                
<p>This file is located in the <kbd>meta</kbd> directory of the MariaDB role:</p>
<pre>from: ubuntu:16.04
ports:
  - "3306:3306"
entrypoint: ['/usr/bin/dumb-init']
command: ['/usr/sbin/MySQLd']</pre>
<p>The parameters we are defining in the role-specific <kbd>container.yml</kbd> should immediately jump out at you in the exact same way in which we would define them in the project-specific <kbd>container.yml</kbd> services section. Here, we are using the Ubuntu 16.04 base image, which is the same as our conductor container. In order to make our MySQL service accessible to outside users, we are going to expose the MySQL ports <kbd>3306</kbd> on the host to ports <kbd>3306</kbd> on the container. Finally, we are going to specify a default entry point and command that the container should run when it starts. A common practice among container developers recently is to leverage lightweight init systems to start and manage processes inside of containers. A popular init system for containers is <kbd>dumb-init</kbd>, written by Yelp in 2013 to provide an easy to install, lightweight init binary for managing processes inside of containers. <kbd>dumb-init</kbd> essentially starts as PID 1 inside of the container and takes the container service executable as an argument provided to it. The benefit is that, since <kbd>dumb-init</kbd> is running as PID 1, all kernel signals will first be intercepted by <kbd>dumb-init</kbd> and forwarded to the container service (<kbd>mysqld</kbd>). <kbd>dumb-init</kbd> will also provide reaping services for our child process, should our container be suddenly stopped or restarted ungracefully. Keep in mind, using a container <kbd>init</kbd> system is not a requirement when building containers, but in some cases, it will help with running, stopping, and restarting containers if the processes don't exit cleanly. In this example, we will use <kbd>dumb-init</kbd> as our <kbd>entrypoint</kbd> for the container, and use the <kbd>command:</kbd> parameter to specify the <kbd>/usr/sbin/MySQLd</kbd> command as an argument into it. This will start the <kbd>mysqld</kbd> process under the supervision of <kbd>dumb-init</kbd>, which will intercept all of the POSIX signals and forward them over to <kbd>mysqld</kbd>.</p>
<p>The second most important aspect of a containerized role is actually writing tasks that are executed in our base image to create the project container. All tasks are YAML files in the <kbd>tasks</kbd> directory of the role. Each task has a name and calls a single Ansible module with parameters to perform a unit of work in the container. Although there are no strict requirements on how to name tasks, or which order to place them in, you do want to keep in mind the flow of the playbook in terms of dependencies on other tasks that may come before or after certain steps. You also want to make sure you name tasks in such a way that any user watching the build process has a fairly good idea what is going on, even if they are not an Ansible developer. Named tasks are what give Ansible the reputation of being <em>self-documenting</em>. This means that, as you write code, the code basically documents itself since almost any user reading your code should know immediately what it does based on the naming of the tasks. It should also be noted that, as all services and applications are different, they are all deployed and configured differently as well. With Ansible and containerization, there is no <em>one-size-fits-all</em> approach that can adequately capture the best practices for deploying and configuring your application.  One of the benefits of Ansible is that Ansible provides the tools needed to automate almost any configuration one can think of to ensure applications get built and deployed reliably. The following is the content of the <kbd>tasks/main.yml</kbd> file in the MariaDB role we are in the process of writing. Take a moment and read through the playbook as it is; we will go through each of these tasks one-by-one to provide more detail as to how the playbook runs. As I describe how the playbook works, it would be helpful to glance back at each task as you read the description.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">tasks/main.yml</h1>
                
            
            
                
<p>This file is located in <kbd>roles/mariadb_role/tasks/main.yml</kbd>:</p>
<pre class="western">---
- name: Install Base Packages
  apt:
    name: "{{ item }}"
    state: present
    update_cache: true
  with_items:
    - "ca-certificates"
    - "apt-utils"

- name: Install dumb-init for container init system
  get_url:
    url: https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64
    dest: /usr/bin/dumb-init
    owner: root
    group: root
    mode: 0775

- name: Create MySQL Group
  group:
    name: mysql
    state: present

- name: Create MySQL Users
  user:
    name: mysql
    state: present
    groups: mysql
    append: true


- name: Install MySQL Server
  apt:
    name: mariadb-server
    state: present
    update_cache: true

- name: Change Permissions on directories
  file:
    path: "{{ item }}"
    owner: mysql
    group: mysql
    mode: 0777
    state: directory
    recurse: true
  with_items:
    - "/etc/mysql/"
    - "/var/lib/mysql/"
    - "/var/run/mysql/"

- name: Remove my.cnf
  file:
    path: /etc/mysql/my.cnf
    state: absent

- name: Install MySQL Configuration File
  template:
    src: my.cnf.j2
    dest: /etc/mysql/my.cnf
    owner: mysql
    group: mysql

- name: Initialize Database
  include: initialize_database.yml
  when:
    - initialize_database == true</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Task breakdown (main.yml)</h1>
                
            
            
                
<ul>
<li class="mce-root"><kbd>Install Base Packages</kbd>: Since we are building an Ubuntu 16.04 image, the <kbd>Install Base Packages</kbd> task calls the <kbd>apt</kbd> package module to install two packages: <kbd>ca-certificates</kbd> and <kbd>apt-utils</kbd>, which are required for the preceding tasks. We want the state of these packages to be present and installed in the <kbd>container</kbd> and the <kbd>apt</kbd> database cache to be updated prior to installing the packages as well. We are able to install multiple packages using the <kbd>with_items</kbd> operator. <kbd>with_items</kbd> iterates over the list items specified and run each value through the apt module. Using <kbd>with_items</kbd>, we don't have to create two or more separate tasks to perform the same action repeatedly. In the <kbd>name</kbd> section of the task, we specify <kbd>{{ item }}</kbd>, which is a Jinja2 keyword variable that tells Ansible that it is about to iterate over a list.</li>
<li class="mce-root"><kbd>Install dumb-init for the Container Init System</kbd>: This task leverages the <kbd>get_url</kbd> module in order to download a remote file from the internet into the container. In this particular case, we are downloading the <kbd>dumb-init</kbd> binary and placing it in the container at the destination <kbd>/usr/bin/dumb-init</kbd>. We are changing the permissions so the file will be owned by root, in the root group, and will be executable. Ansible allows us to perform all of these actions in a single module call.</li>
<li class="mce-root"><kbd>Create MySQL User and Group</kbd>: The next two tasks are quite similar. With these tasks, we are starting to lay the groundwork for installing our MariaDB MySQL service. We are calling the <kbd>user</kbd> and <kbd>group</kbd> module to create a user called <kbd>mysql</kbd>, create a group also called <kbd>mysql</kbd>, and add the user to the group. Notice that, in the group module, we specify <kbd>append: true</kbd>. This indicates that whatever groups are already assigned to the <kbd>mysql</kbd> user, we also want to append <kbd>mysql</kbd>. This is a safe option to add to any group declaration so that we don't accidentally remove users from other groups they may need to belong to.</li>
<li class="mce-root"><kbd>Install the MySQL Server</kbd>: This task functions in a very similar way to the first task that we saw in the playbook. However, instead of installing multiple packages, we are calling the apt module to install only one package, the MariaDB server. As usual, we want the package to be installed and present, as well as having the package cache updated. Arguably, we could have added this package to the list of installed packages in our very first task, and that would definitely work. However, as a matter of development style, I like to provide a logical distinction between steps in my playbooks so that things do not get confusing further on. After all, installing the base packages is usually a separate and distinct step from installing the core service package.</li>
<li class="mce-root"><kbd>Change permissions on directories</kbd>: This task is one of the more complex tasks in the playbook. In this task, we have a handful of directory paths that need to have their permissions changed so that the MySQL service can write data to them. The <kbd>file</kbd> module allows us to create, delete, or modify any file present in our container. Similarly to our first task, we are going to call the file module on our <kbd>{{ item }}</kbd> keyword variable so that each list item specified in our <kbd>with_items</kbd> will have the same permissions and attributes applied to it. If the paths specified do not exist, Ansible will create them with the state <kbd>directory</kbd> and apply the appropriate permissions to them. We are also providing the <kbd>recurse: true</kbd> option so that the permissions will apply to all subdirectories from those locations specified.</li>
<li class="mce-root"><kbd>Remove my.cnf</kbd>: <kbd>my.cnf</kbd> is the primary configuration file that is used by MySQL to configure how the database service operates. When MariaDB is first installed, it creates <kbd>my.cnf</kbd> as a symlink, which leads to another configuration file it uses instead. We don't want this behavior; hence, we are going to delete the default <kbd>my.cnf</kbd> file using the file module and set the state value to <kbd>absent</kbd>. We will use our own <kbd>my.cnf</kbd> file instead.</li>
<li class="mce-root"><kbd>Install the MySQL Configuration File</kbd>: Now that the default <kbd>my.cnf</kbd> symlink has been removed, we can call the template module to place a new <kbd>my.cnf</kbd> file in its place. The <kbd>templates</kbd> module works by leveraging the local <kbd>templates</kbd> directory and looking for a file that matches the name of the source file we are specifying, <kbd>my.cnf.j2</kbd>. Templates use the Jinja2 templating language to put the new configuration in place and replace any variables sourced from the role. The location for the new configuration file will be <kbd>/etc/MySQL/my.cnf</kbd> and will have the appropriate permissions applied to it.</li>
<li class="mce-root"><kbd>Initialize the Database</kbd>: The final task in this playbook is known as an <kbd>include</kbd> task. Include statements, logically enough, include other playbook YAML files for execution. Usually, include statements are a great way to break down your playbooks into logically grouped blocks of similar tasks. In this scenario, we want to include the playbook <kbd>initialize_database.yml</kbd>, based on the logical condition that the variable <kbd>initialize_database</kbd> is set to true. In other programming languages constructs such as <em>if, else...if</em>, and <em>else</em> exist, to indicate logical evaluations. Ansible handles this using the keyword <kbd>when</kbd> to list the conditions for <em>when</em> an action will occur. In this case, <em>when</em> the variable <kbd>initialize_database</kbd> is true, the playbook <kbd>initialize_database.yml</kbd> will be executed. If the variable is set to false, it will skip those tasks.</li>
</ul>
<p>Now that we have a good understanding of what the tasks inside of the <kbd>main.yml</kbd> playbook are running, let's take a look at the tasks inside of the <kbd>initialize_database.yml</kbd> playbook to see what will happen if the <kbd>initialize_database</kbd> variable evaluates to true:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">tasks/initialize_database.yml</h1>
                
            
            
                
<p>This file is located in <kbd>roles/mariadb_role/tasks/initialize_database.yml</kbd>.</p>
<pre class="western">---
- name: Temporarily Start MariaDB Server
  shell: MySQLd --user=MySQL &amp;

- name: Create Initial Accounts
  shell: MySQL -e "CREATE USER '{{ default_user }}'@'%' IDENTIFIED BY '{{ default_password }}';"

- name: Grant Privileges to New Account
  shell: MySQL -e "GRANT ALL ON *.* TO '{{ default_user }}'@'%' WITH GRANT OPTION;"

- name: Create Default Databases
  shell: MySQL -e "CREATE DATABASE {{ item }};"
  with_items:
    - "{{ databases }}"

- name: Flush Privileges
  shell: MySQL -e "FLUSH PRIVILEGES;"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Task breakdown (initialize_database.yml)</h1>
                
            
            
                
<ul>
<li class="mce-root"><kbd>Temporarily Start MariaDB Server</kbd>: By default, when MariaDB is first installed, there are no databases created and no users have access to the database. In some cases, we may want to spin up a vanilla MariaDB server and have an external user or tool create the default databases and access credentials. However, there may also be an equal number of circumstances in which we might need to create database instances that come with built-in databases and user credentials. In order to create these defaults, we will first need to start the MySQL server so that it can be accessed from the command line. To start the server temporarily, we will call the <kbd>shell</kbd> module, which evaluates shell commands in a very similar manner, as if you were typing them on a Bash prompt. We will run the command <kbd>mysqld</kbd>, specifying the user to run as <kbd>mysql</kbd>, and force the server to run in the background using the ampersand indicator (<kbd>&amp;</kbd>). The MySQL server will continue to run at this point until the build has completed and the container has been shut down.</li>
<li class="mce-root"><kbd>Create Initial Accounts</kbd>: The create initial accounts step similarly calls the shell module in order to leverage the MySQL command-line client. The <kbd>-e</kbd> flag allows us to pass in executable SQL commands, which will be evaluated by the server. We will use this particular command to create a default username and password that we can use to log in to the database. The default credentials will be sourced from our variables, hence the double curly braces.</li>
<li class="mce-root"><kbd>Grant Privileges to New Account</kbd>: Using the <kbd>shell</kbd> module again, we can call the MySQL client to grant privileges on the new account we created previously. In this example, we will grant all privileges, connecting from any network interface to have access to this MySQL server.</li>
<li class="mce-root"><kbd>Create Default Databases</kbd>: Using our iteration or looping operator <kbd>with_items</kbd>, we can pass in a list of databases we want the MySQL client to create. In our <kbd>defaults/main.yml</kbd> file, we have specified the databases variable as an array or list of items. Ansible will identify the fact that our databases variable is actually a list of strings and iterate over that. The result is that any number of databases we specify as a list item of the databases variable will be iterated over and created in our MySQL container.</li>
<li class="mce-root"><kbd>Flush Privileges</kbd>: One final call to the shell module will allow us to execute the SQL command, <kbd>FLUSH PRIVILEGES</kbd>, which allows the new user accounts to take effect in the database. After this command executes, the container build will have finished, signaling Ansible Container to shut down the intermediate container and commit the final changes to the container we just finished building.</li>
</ul>
<p>Now that we have had a look inside the <kbd>tasks</kbd> directory and learned about how the role executes tasks, let's look inside of the <kbd>templates/</kbd> directory to learn about the templated configuration files we are generating and passing into the container. You will observe that, in the <kbd>roles</kbd> templates directory, there is one file: <kbd>my.cnf.j2</kbd>. This is the template for <kbd>my.cnf</kbd> file that we want Ansible to compile and pass into the container during the build process. It is a best practice to always name your Ansible template file after the destination filename with the <kbd>.j2</kbd> extension. This indicates the file is a Jinja2 template and contains variables and Jinja2 logic for Ansible to evaluate.</p>
<p>Jinja2 is a powerful templating language that can do some pretty neat stuff in your projects. Although not strictly required, having a working understanding of Jinja2 can help you a lot in your Ansible development. You can read more about the Jinja2 language at the official website:  <a href="http://jinja.pocoo.org/">http://jinja.pocoo.org/.</a></p>
<p>The following is the content of the <kbd>my.cnf.j2</kbd> file in the <kbd>templates</kbd> directory:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">templates/my.cnf.j2</h1>
                
            
            
                
<p>This file is located in <kbd>roles/mariadb_role/templates/my.cnf.j2</kbd>:</p>
<pre class="western"># Ansible Container Generated MariaDB Config File
[client]
port            = 3306
socket          = /var/lib/MySQL/MySQL.sock

# The MariaDB server
[MySQLd]
user           = MySQL
port            = 3306
socket          = /var/lib/MySQL/MySQL.sock
datadir         = /var/lib/MySQL
bind-address = 0.0.0.0
skip-external-locking
key_buffer_size = {{ key_buffer_size }}
max_allowed_packet = {{ max_allowed_packet }}
table_open_cache = {{ table_open_cache }}
sort_buffer_size = {{ sort_buffer_size }}</pre>
<p>Notice that, in the first line of the file, we are spelling out to the user in a comment block that the file is an <em>Ansible Container-Generated MariaDB Config File</em>. If you have experience of connecting into remote servers to troubleshoot problems, you will know how handy it is to know exactly where the files come from, where the values are populated from, and which configuration management tool is responsible for putting those files there. While not strictly required, and surely as a matter of taste, I like to place such banners on files that Ansible touches. This way, someone, later on, will know exactly how this container came to be in this state.</p>
<p>The next thing you will notice is that the last four lines of the configuration file have values set to double curly braces with the name of the configuration file key in between them. As we discussed earlier, the double curly braces indicate Jinja2 variable parameters. When Ansible evaluates this template prior to installing it in its destination inside the container, Ansible will parse the file for all Jinja2 blocks and execute the instructions it reads to bring the template into the desired state. This could mean populating the values of variables, evaluating logical conditions, or even sourcing environment information that the template requires. In this case, Ansible will see the double curly braces and replace them with the values defined for those variables. By changing or overriding the variables, Ansible makes it quite easy to change the way containers and applications function. Also, notice that the names of the variables match the configuration option they are modifying. Variable names are purely up to the developer, and as such, the developer may choose what they want the names to be. However, it is usually a best practice to use descriptive variable names so that it is very clear to the user what settings they are overriding or modifying.</p>
<p>Reading through these role files, it is probably very clear to you that variables have a lot to do with how Ansible runs, how templates are populated, and even how tasks are executed and controlled. Let's now take a look at how variables are defined in roles and how we can leverage variables to make roles more flexible and enable their reuse. As stated before, role variables can be stored in two places: the <kbd>defaults/</kbd> directory or the <kbd>vars/</kbd> directory. As the developer, you can choose which location (or both locations) you want to store your variables in. The only difference is the variable precedence in which the variables are evaluated in. The variables stored in <kbd>defaults/</kbd> are the easiest to override. Variables stored in <kbd>vars/</kbd> have a slightly lower precedence and thus are more difficult to override. In this example, I have opted to store all variables in the <kbd>defaults/</kbd> directory in the <kbd>main.yml</kbd> file. Let's see what that file looks like:</p>
<pre class="western">---
# defaults file for MySQL_role
initialize_database: true
default_user: "root"
default_password: "password"
databases:
  - "TestDB1"
  - "TestDB2"
  - "TestDB3"

#MySQL Basic Tuning for my.cnf
key_buffer_size: "16K"
max_allowed_packet: "1M"
table_open_cache: 4
sort_buffer_size: "64K"</pre>
<p>Here, you can see that these are all the variables we have seen before, referenced in the role tasks as well as the templated file for <kbd>my.cnf</kbd>. Variable YAML files are essentially just static YAML files that use exactly the same YAML constructs we explored in the beginning of the chapter. For example, this file is, by default, initializing the database by setting the <kbd>initialize_database</kbd> variable to the Boolean value of true. We also can see that the default credentials that will be created in the database are set to the strings <kbd>root</kbd> and <kbd>password</kbd>, as well as a list of test databases that will get created during the initialize database tasks. Finally, towards the bottom, we have a grouping of variables that define the values that will be incorporated into the template. If we build the role as-is, without providing any variable overrides, we will get a container built with exactly these specifications. However, this book would not be complete without exploring exactly how we can go about customizing the role we just wrote!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the container-enabled role</h1>
                
            
            
                
<p>Before we begin customizing our role, let's first build the role and demonstrate the default functionality using the default variables we specified. Let's go ahead and return to our Ansible Container workflow and execute <kbd>ansible-container build</kbd>, followed by the <kbd>ansible-container run</kbd> commands from the <kbd>root</kbd> directory of our project:</p>
<pre class="western"><strong>ubuntu@node01:$ ansible-container build
Building Docker Engine context...                                                                                                                                                                            
Starting Docker build of Ansible Container Conductor image (please be patient)...                                                                                                                                                                                      
Parsing conductor CLI args.                                                                                                                                                                                  
Docker™ daemon integration engine loaded. Build starting.       project=mariadb_demo                                                                                                                         
Building service...     project=mariadb_demo service=MySQL_database_container                                                                                                                                
                                                                                                                                                                                                             
PLAY [MySQL_database_container] ************************************************                                                                                                                             
                                                                                                                                                                                                             
TASK [Gathering Facts] *********************************************************                                                                                                                             
ok: [MySQL_database_container]                                                                                                                                                                               
                                                                                                                                                                                                             
TASK [mariadb_role : Install Base Packages] ************************************                                                                                                                             
changed: [MySQL_database_container] =&gt;</strong> <strong>(item=[u'ca-certificates', u'apt-utils'])                                                                                                                             
                                                                                                                                                                                                             
TASK [mariadb_role : Install dumb-init for Container Init System] **************                                                                                                                             
changed: [MySQL_database_container]

TASK [mariadb_role : Create MySQL Group] ***************************************
changed: [MySQL_database_container]

TASK [mariadb_role : Create MySQL Users] ***************************************
changed: [MySQL_database_container]

TASK [mariadb_role : Install MySQL Server] *************************************
changed: [MySQL_database_container]

TRUNCATED</strong></pre>
<p>You may note from the build output that Ansible is taking the list items we provided in the task using the <kbd>with_items</kbd> iteration operator and exactly building our image, bringing it into the desired state based on the variables we have provided in our role, which for now, are the default variables.</p>
<p>Let's run our project and attempt to access the MySQL services:</p>
<pre class="western"><strong>ubuntu@node01:$ ansible-container run
Parsing conductor CLI args.
Engine integration loaded. Preparing run.       engine=Docker™ daemon
Verifying service image service=MySQL_database_container

PLAY [localhost] ***************************************************************

TASK [docker_service] **********************************************************
changed: [localhost]

PLAY RECAP *********************************************************************
localhost                  : ok=1    changed=1    unreachable=0    failed=0

All services running.   playbook_rc=0
Conductor terminated. Cleaning up.      command_rc=0 conductor_id=e33fb25670f1bc040a6edd19360ec528be28b9f14d4ccb0d9a8ed34a71d1c561 save_container=False</strong></pre>
<p>Executing <kbd>docker ps -a</kbd> will show that our container is running with port <kbd>3306</kbd> exposed on the host:</p>
<p> </p>
<pre class="western"><strong>ubuntu@node01:~$ docker ps -a
CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES
7cab59c33cfa  mariadb_demo-MySQL_database_container  "/usr/bin/dumb-ini…"  About a minute ago   Up About a minute   0.0.0.0:3306-&gt;3306/tcp   mariadb_demo-MySQL_database_container</strong></pre>
<p>To test to ensure everything is working, we can download and install the <kbd>mariadb-client</kbd> package, or any MySQL client of your choosing:</p>
<p> </p>
<pre class="western"><strong>ubuntu@node01:~$ sudo apt-get install -y mariadb-client</strong></pre>
<p>Once the MariaDB client has been installed, you can use the following command to connect to the MariaDB container exposed on the localhost of the Vagrant VM. If you're unfamiliar with the MySQL client, remember that all flags passed into the client do not have spaces after them. It looks a little strange, but it should drop you into a MySQL console:</p>
<p> </p>
<pre class="western"><strong>ubuntu@node01:~$ MySQL -h127.0.0.1 -uroot -ppassword
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 2
Server version: 10.0.31-MariaDB-0ubuntu0.16.04.2 Ubuntu 16.04

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt; </strong></pre>
<p>Let's run the <kbd>show databases;</kbd> command to see if the test databases we have specified in our default variables are being created:</p>
<pre class="western"><strong>MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| TestDB1            |
| TestDB2            |
| TestDB3            |
| information_schema |
| MySQL              |
| performance_schema |
+--------------------+
6 rows in set (0.00 sec)

MariaDB [(none)]&gt;</strong></pre>
<p>It appears as though everything was created properly and is working as expected. When you are done working in this session, you can exit from the MySQL CLI using the <kbd>exit</kbd> command. Use <kbd>ansible-container destroy</kbd> to reset your environment. Let's make things interesting by customizing our role and sourcing external variable values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Customizing the container-enabled role</h1>
                
            
            
                
<p>As we saw in the previous chapter, it is very easy to abstract away from changes in Ansible Container projects by adding variables directly to the project <kbd>container.yml</kbd> file and rebuilding the project. This provides the added convenience of having all of our configuration changes in a single location and functioning effectively as a single point of truth. This might be sufficient for some use cases, but what about circumstances in which one would need to provide containers configured differently to support multiple environments or locations, such as the development, testing, QA, and production environments? You could simply update the <kbd>container.yml</kbd> file and build separate images for these scenarios. However, Ansible Container provides us with a better way to handle this by providing the ability to source external variable files. A part of the <kbd>ansible-container</kbd> parent command is the <kbd>--var-files</kbd> flag, which provides the option to source an external YAML file for variable definitions. This provides us with an abstraction that allows separate builds to run and exist in parallel using different configuration options. This also allows us to customize our role using separate variable files for almost any circumstance that can be version-controlled along with our project.</p>
<p>To enable this functionality, let's create a directory in the root of our project (the same level as the project-specific <kbd>container.yml</kbd>) called <kbd>variable_files</kbd>. Inside of this directory, we will create three separate files: <kbd>dev.yml</kbd>, <kbd>test.yml</kbd>, and <kbd>prod.yml</kbd> with slightly different configuration options. The following are examples of these three files. Do enjoy my Star Trek references!</p>
<p>Before we begin, it would be a good idea to perform an <kbd>ansible-container destroy</kbd> action before rebuilding the containers using different variables. This way, you can see exactly what is being changed during the build process.</p>
<p>In the development, the primary user of our database will be Yeoman Rand. She will be primarily concerned with Starfleet data:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">variable_files/dev.yml</h1>
                
            
            
                
<p>This file is located in <kbd>&lt;project_root&gt;/variable_files/dev.yml</kbd>:</p>
<pre>---
# Development Defaults for MySQL role
initialize_database: true
default_user: "yeoman_rand"
default_password: "starfleet"
databases:
  - "starfleet_data"</pre>
<p>In <kbd>System Test</kbd>, Mr. Spock will be the primary user of our database. He has slightly more interest in data related to Planet Vulcan, ship ordinances, shuttlecraft, as well as federation data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">variable_files/test.yml</h1>
                
            
            
                
<p>This is located in <kbd>&lt;project_root&gt;/variable_files/test.yml</kbd>:</p>
<pre>---
# System Test Defaults for MySQL role
initialize_database: true
default_user: "MrSpock"
default_password: "theBridge"
databases:
  - "planet_vulcan"
  - "federation_data"
  - "shuttle_crafts"
  - "ship_ordinances"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">variable_files/prod.yml</h1>
                
            
            
                
<p>In production, Captain Kirk is going to need to store vastly different data than the other crew members. We will need to enhance our MySQL configuration from a bit to support the added overhead of storing the Captain's Logs, Enterprise data, as well as federation mandates. This file is located  in: <kbd>&lt;project_root&gt;/variable_files/prod.yml</kbd>:</p>
<pre class="western">---
# defaults file for MySQL_role
initialize_database: true
default_user: "captainkirk"
default_password: "ussenterprise"
databases:
  - "CaptainsLog"
  - "USS_Enterprise"
  - "InterstellarColonies"
  - "FederationMandates"

#MySQL Basic Tuning for my.cnf
key_buffer_size: "128K"
max_allowed_packet: "20M"
table_open_cache: 12
sort_buffer_size: "128K"</pre>
<p>You may also notice that not all variables are being overridden in every example shown here. In cases where variables are not being overridden by the sourced files, Ansible will take the values present in <kbd>defaults/main.yml</kbd> in the role. It is important that your role defaults provide values for all variables, as variables referenced without values will break the build process.</p>
<p>Variable files can be named anything you want. Since we are sourcing these files during the build process, and they are not something that Ansible Container will automatically discover, the naming convention is entirely up to you.</p>
<p>We can build containers based on any of these variables by executing our <kbd>ansible-container build</kbd> command and adding the <kbd>--vars-files</kbd> flag as a parameter of the <kbd>ansible-container</kbd> command. Remember, we always run <kbd>build</kbd> commands in the same directory as the project-specific <kbd>container.yml</kbd> file:</p>
<pre class="western"><strong>ansible-container --vars-files variable_files/dev.yml build</strong></pre>
<p>During the build, you should notice that many of the tasks look slightly different based on the variables we are providing. For example, when sourcing development variables, you will see that only one database gets created: <kbd>starfleet_data</kbd>. This is an indication that the new variables have been sourced and are populated correctly in the build process. Let's perform an <kbd>ansible-container run</kbd> of the new version of our container and try to log in with the same credentials as before:</p>
<p> </p>
<pre class="western"><strong>ubuntu@node01:$ ansible-container run
Parsing conductor CLI args.
Engine integration loaded. Preparing run.       engine=Docker™ daemon
Verifying service image service=MySQL_database_container

PLAY [Deploy mariadb_demo] *****************************************************

TASK [docker_service] **********************************************************
changed: [localhost]

PLAY RECAP *********************************************************************
localhost                  : ok=1    changed=1    unreachable=0    failed=0

All services running.   playbook_rc=0
Conductor terminated. Cleaning up.      command_rc=0 conductor_id=bf5221a710736d238b0995dd4ce42b57bcb9338131225d71c0d7d1b3cef85677 save_container=False</strong></pre>
<p>Now, to log in using the MariaDB client:</p>
<p> </p>
<pre class="western"><strong>ubuntu@node01:$ MySQL -h127.0.0.1 -uroot -ppassword
ERROR 1698 (28000): Access denied for user 'root'@'172.18.0.1'</strong></pre>
<p>It is very clear to see that the default credentials we have in the role defaults are no longer working. Let's try again using the credentials we specified in our development variable file for the Yeoman Rand user:</p>
<p> </p>
<pre class="western"><strong>ubuntu@node01:$ MySQL -h127.0.0.1 -uyeoman_rand -pstarfleet
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.0.31-MariaDB-0ubuntu0.16.04.2 Ubuntu 16.04

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt;</strong></pre>
<p>It looks like our new container is working using the sourced variable files for development. Let's run the <kbd>show databases;</kbd> command to make sure the database was properly created and exists:</p>
<pre class="western"><strong>MariaDB [(none)]&gt; show databases;
'+--------------------+
| Database           |
+--------------------+
| information_schema |
| MySQL              |
| performance_schema |
| starfleet_data     |
+--------------------+
4 rows in set (0.04 sec)

MariaDB [(none)]&gt;</strong></pre>
<p>As you can see, the database <kbd>starfleet_data</kbd> exists alongside the default MariaDB databases such as <kbd>information_schema</kbd>, <kbd>MySQL</kbd>, and <kbd>performance_schema</kbd>. It appears that the container was built properly and is ready for deployment in our development environment (for the purposes of this example). We can now push the image to a container registry of our choosing. For this example, I will add Docker Hub to the <kbd>registries</kbd> section of our project-specific <kbd>container.yml</kbd> file, specifying the namespace as my Docker Hub username (remember to remove the curly braces after the start of the registries stanza). Once that file is saved, let's tag the image as <kbd>dev</kbd> and <kbd>push</kbd> it up to our Docker Hub repository so that we have a build image artifact that we can use to deploy our application:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">container.yml</h1>
                
            
            
                
<p>The project-specific <kbd>container.yml</kbd> file is located in the <kbd>root</kbd> directory of your project:</p>
<pre class="western">registries:
  docker:
    url: https://index.docker.io/v1/
    namespace: username</pre>
<p>Push the image using the <kbd>--push-to</kbd> flag:</p>
<pre class="western"><strong>ubuntu@node01:$ ansible-container push --push-to docker --tag dev
Parsing conductor CLI args.
Engine integration loaded. Preparing push.      engine=Docker™ daemon
Tagging aric49/mariadb_demo-MySQL_database_container
Pushing aric49/mariadb_demo-MySQL_database_container:dev...
The push refers to a repository [docker.io/aric49/mariadb_demo-MySQL_database_container]
Preparing
Waiting
Pushing
Pushed
Pushing
Pushed
Pushing
Pushed
dev: digest: sha256:98d288cfa09acc3f06578532cd6ccd78af0eb65b84ba3b0ee011105e59cfb588 size: 1569
Conductor terminated. Cleaning up.      command_rc=0 conductor_id=323116464d8f687238ae6ab64f86fb54746b6c2f5f0b895754da6ef0ce540d76 save_container=False</strong></pre>
<p>It's not completely necessary to configure Docker Hub as the image registry in the <kbd>container.yml</kbd> file, as Ansible Container will default to using Docker Hub. However, I like to make sure I don't accidentally push images to the wrong registries, so it is best practice to always provide the image repository in the <kbd>container.yml</kbd> file and always push using the <kbd>-–push-to</kbd> flag command to specify the correct repository.</p>
<p>We can do the same build process for our <kbd>test.yml</kbd> configuration as well as our <kbd>prod.yml</kbd> configurations and push those up to the Docker Hub repository (remembering to do a <kbd>destroy</kbd> between builds). Notice that, while uploading a different version of the image, Docker will automatically identify layers of the image that is identical to the previously uploaded version. In this case, Docker will help you to save bandwidth and resources by not pushing layers that are identical, but only the layers that have changed, as shown in the following. Note the <kbd>Layer already exists</kbd> lines:</p>
<pre class="western"><strong>ubuntu@node01:$ ansible-container push --push-to docker --tag test
Parsing conductor CLI args.
Engine integration loaded. Preparing push.      engine=Docker™ daemon
Tagging aric49/mariadb_demo-MySQL_database_container
Pushing aric49/mariadb_demo-MySQL_database_container:test...
The push refers to a repository [docker.io/aric49/mariadb_demo-MySQL_database_container]
Preparing
Waiting
Layer already exists
Pushing
Layer already exists
Pushing
Layer already exists
Pushing
Pushed
test: digest: sha256:1f9604585e50efe360a927f0a5d6614bb960b109ad8060fa3173d4ab259ee904 size: 1569
Conductor terminated. Cleaning up.      command_rc=0 conductor_id=ef42185fab1cfe20de65101059957844bbc4a166a8ab10352fe1b796e7ea5c3d save_container=False</strong></pre>
<p>We should now have three different container image artifacts available to download. These images are available to download and deploy in our imaginary development lab, system test lab, as well as our production environment. These container images are guaranteed to run in these environments in the exact same way as they do in our local workstations. At this point, we can do a final exercise and run all three of these containers on different ports in order to simulate these containers running in different environments with different configurations. To quickly demonstrate this, we will use the native <kbd>docker run</kbd> command to specify our tagged image and the ports we want the container service to use; we also specify that our service should run in the background using the <kbd>-d</kbd> flag. Notice that each instance of our container that we are creating uses the <kbd>dev</kbd>, <kbd>test</kbd>, and <kbd>prod</kbd> tags as well as our user repository address. In my case, it is <kbd>aric49</kbd>:</p>
<pre class="western"><strong>docker run -d --name MySQL_Dev -p 3308:3306 aric49/mariadb_demo-MySQL_database_container:dev

docker run -d --name MySQL_Test -p 3309:3306 aric49/mariadb_demo-MySQL_database_container:test

docker run -d --name MySQL_Prod -p 33010:3306 aric49/mariadb_demo-MySQL_database_container:prod</strong></pre>
<p>Testing the container functionality is exactly the same process as before. We can use the MariaDB client to log into an instance of our containers. This time, however, we will need to specify which port our service is listening on since all three instances cannot listen on the default port <kbd>3306</kbd> on the host networking side. If we wanted to log into our production container, we could specify the credentials for Captain Kirk using port <kbd>33010</kbd> and the <kbd>ussenterprise</kbd> password:</p>
<pre class="western"><strong>ubuntu@node01:$ MySQL -h127.0.0.1 -ucaptainkirk -pussenterprise -P33010
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 2
Server version: 10.0.31-MariaDB-0ubuntu0.16.04.2 Ubuntu 16.04

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt;</strong></pre>
<p>Leveraging the same Ansible Container project and container-enabled role, we were able to use the Ansible Container default primitives in order to build containers with a variety of configurations that are available for use under different circumstances and use cases. This approach enables us to be certain that the build process will remain exactly the same throughout future build iterations, but we will have the flexibility to supply new configuration values into our role without modifying the code we wrote previously. Using container tagging, a snapshot of container configurations can be captured and shared with other users. We now have a tremendously useful and repeatable pipeline to ensure that future versions of our application containers have traceability back to the source roles used to generate them. Even if the container images are accidentally deleted from our image registry, we can easily build and rebuild our containers at any time, since all configuration in our containers is declared as code using the Ansible playbook language. If you have worked in an IT-related DevOps or a systems administrator position for very long, you will understand how valuable it is to have this level of insight into your infrastructure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">References</h1>
                
            
            
                
<ul>
<li><strong>Official YAML Standard Guide</strong>: <a href="http://yaml.org">http://yaml.org</a></li>
<li><strong>Ansible Module Index</strong>: <a href="http://docs.ansible.com/ansible/latest/modules_by_category.html">http://docs.ansible.com/ansible/latest/modules_by_category.html</a></li>
<li><strong>Ansible Playbook Specification</strong>: <a href="http://docs.ansible.com/ansible/latest/playbooks.html">http://docs.ansible.com/ansible/latest/playbooks.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Over the course of this chapter, we looked at how roles not only enable reuse in Ansible Container but are actually the bread and butter of what makes Ansible Container a powerful tool for building and managing containers.</p>
<p>We first looked at how we can use the Ansible Galaxy command-line tools to create the shell for a container-enabled role, all necessary directories, and default YAML files from which we can build our role. From there, we wrote a custom role that builds a MariaDB container using a sane set of default configuration options. Finally, we developed an abstraction layer on top of our role by passing in custom variable configuration options, from which we can customize our container project without modifying any code.</p>
<p>I hope this chapter has effectively demonstrated the raw power available to you using the Ansible Container project. Up until this point, I think it is easy to make the assumption that it is easier to build container images using Dockerfiles and not worrying about the added overhead of Ansible Container. I hope you will now understand that the benefits of using Ansible Container far outweigh the slight layer of additional complexity required. Using Ansible Container, you can create a powerful pipeline for building, running, testing, and pushing container images. By leveraging the easy-to-understand Ansible playbook syntax language, we have a basis from which we can start building a modern, agile, containerized infrastructure that gives us the ability to deploy changes quickly and truly begin to embrace the promise of genuinely modular infrastructure.</p>
<p>Now that we understand how to build and deploy truly custom containers we can start to look at Kubernetes, an open source framework for automating the deployment, orchestration, and management of containers at scale.</p>


            

            
        
    </body></html>