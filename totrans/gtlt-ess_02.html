<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Installing Gitolite</h1></div></div></div><p>The previous chapter showed you how to set up what we might call a <strong>sandbox</strong> installation<a id="id33" class="indexterm"/> of Gitolite, suitable for experimenting with the software and getting comfortable with it. We did that using a script that hid most of the details of the install process so that you could <em>get to the good stuff</em>.</p><p>In this chapter, we will actually perform a proper install of Gitolite. We will start with the prerequisites on the server and move on to the actual install steps. By the end of this chapter, you should have a working installation of Gitolite that is ready to support users and serve up repositories to them securely, enforcing access restrictions as you specify them.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Gitolite users and the hosting user</h1></div></div></div><p>Gitolite provides <a id="id34" class="indexterm"/>access to several Gitolite users, using only one actual user ID on the server. Before we start installing and setting up Gitolite, it's useful to have some knowledge of what is actually going on behind the scenes and how this is achieved.</p><p>Gitolite uses one Unix user called the <a id="id35" class="indexterm"/>
<strong>hosting</strong> <strong>user</strong>
<a id="id36" class="indexterm"/> to provide repository access to many Gitolite users. The hosting user can be any valid user on the system, though by convention it is either git or gitolite. This is the only user ID that is used by Gitolite on the server, and it is within the home directory of this user that Gitolite places its files, its own configuration, as well as the repositories it manages.</p><p>Gitolite can support thousands of Gitolite users on one server. These users are not <em>real</em> users as far as the server operating system is concerned, and they do not get access to the shell command line on the server. A Gitolite user does, however, get access to some of the repositories on the server so that they can run Git commands against them.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Distinguishing users from each other</h2></div></div></div><p>Gitolite <a id="id37" class="indexterm"/>uses ssh to authenticate its users. However, while ssh normally allows authentication using either a password or an ssh key pair, Gitolite requires that a key pair be used for authentication; passwords are not accepted.</p><p>Each Gitolite user has an ssh key pair on their desktop or laptop. A key pair consists of two files, typically called <code class="literal">id_rsa</code> (the private key), and <code class="literal">id_rsa.pub</code> (the public key).</p><p>The public key file contains a single, very long line of text; here's a shortened example:</p><div><pre class="programlisting">ssh-rsa AAAAB3NzaC1[...]LBkU1XGGPnX adam@lab1.example.com</pre></div><p>The key is actually too long to print here, so we removed about 350 characters from the middle, replacing them with ellipsis, but this should still give you a good idea of what it looks like.</p><div><img src="img/2371OS_02_01.jpg" alt="Distinguishing users from each other"/></div><p>The preceding figure illustrates the sequence of events that happens when a user connects to a Gitolite server to access a Git repository, and how this sequence is enabled. First, each user sends their public key to the Gitolite administrator. When the Gitolite administrator adds these users to Gitolite, Gitolite adds the keys to a file called <code class="literal">.ssh/authorized_keys</code> in the home directory of the hosting user. It then prefixes to the beginning of each line a string that looks somewhat like the following line (for the user Adam) and similarly for other users:</p><div><pre class="programlisting">
<strong>command="/home/gitolite/bin/gitolite-shell adam",[...] ssh-rsa [...]</strong>
</pre></div><p>This first step<a id="id38" class="indexterm"/> is what enables the access control. It is a one-time action, and needs to be repeated only when the administrator adds or removes users. Notice the <code class="literal">command</code> option, containing a program name (<code class="literal">gitolite-shell</code> using its full path), and its argument (the username, <code class="literal">adam</code> in this example)—this will be relevant a bit later.</p><p>The second step shows what happens when, say, Bob tries to connect to the server. Bob runs the ssh command, whether directly or via his local git client, in the form of a clone, fetch, or push command. The ssh daemon on the server handles the connection attempt. Bob's ssh client will offer a public key, and the ssh daemon will go looking for it in the authorized keys file, finding it eventually. In our example, it finds a match on the second line.</p><p>Next, the ssh daemon notices the command option on the matched line in the authorized keys file. This tells the ssh daemon that, instead of running the program that the client asked for, it should instead run the command mentioned in that option, including any arguments supplied. This means the <code class="literal">gitolite-shell</code> program is executed with the Gitolite username (in our example, Bob) as the first argument. This is how the <code class="literal">gitolite-shell</code> program knows who is connecting.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>For those who are wondering what happened to the original command that the git client actually wanted, the ssh daemon stores it in an environment variable called <code class="literal">SSH_ORIGINAL_COMMAND</code> and passes it to the <code class="literal">gitolite-shell</code> program, which knows what to do with it.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Preparing the server</h1></div></div></div><p>Gitolite can be<a id="id39" class="indexterm"/> installed on any Unix server. This includes Linux, any of the BSDs, and the legacy Unix servers such as AIX and HP-UX. With that said, here are the requirements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Unix system with a POSIX-compatible sh (shell)</li><li class="listitem" style="list-style-type: disc">Git Version 1.7.1 or higher</li><li class="listitem" style="list-style-type: disc">Perl 5.8.8 or higher</li><li class="listitem" style="list-style-type: disc">OpenSSH 5.0 or higher</li><li class="listitem" style="list-style-type: disc">A dedicated Unix user as the hosting user described previously, whose home directory must be on a filesystem that supports symlinks, and allows executables (that is, it is not mounted with the <code class="literal">noexec</code> mount flag)<div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Ideally, you should use a brand new user ID that has no existing files or directories, except for whatever a newly created user gets (such as the bashrc or similar files). This will ensure that any leftover files don't interfere.</p></div></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Getting the Gitolite source</h1></div></div></div><p>The next <a id="id40" class="indexterm"/>step is to obtain the Gitolite source code. The<a id="id41" class="indexterm"/> simplest way to do this, if your server can connect to the Internet, is to run <code class="literal">git clone</code> <code class="literal">git://github.com/sitaramc/gitolite</code>.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>If you do not have direct access to the Internet, simply use some other machine in between. For example, you could run the previous command on a server that can connect to the Internet. From that intermediate server, you can zip the entire Gitolite repository, bring it over to the Gitolite server, and unzip it.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Installing the code</h1></div></div></div><p>The first step<a id="id42" class="indexterm"/> is to <a id="id43" class="indexterm"/>put the source code where you want it to go. Gitolite is designed in a way that it doesn't require root (except to create the hosting user), so you can (and usually should) put it somewhere within the home directory of the Gitolite hosting user. For our discussion, we will pick <code class="literal">$HOME/bin</code>, because this is usually included in the user's PATH setting.</p><p>Log in as the hosting user, and run the following commands:</p><div><pre class="programlisting">
<strong>cd $HOME</strong>
<strong>mkdir -p $HOME/bin</strong>
<strong>gitolite/install --to $HOME/bin</strong>
</pre></div><p>For people who are familiar with commands such as <code class="literal">make prefix=/usr/local install</code>, this is conceptually not very different.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Setting up Gitolite</h1></div></div></div><p>Now that <a id="id44" class="indexterm"/>the code is in the right place, we need to set it up. Setting it up involves adding an ssh public key for the main administrator of the Gitolite installation. In this book, we will assume the administrator's name is Adam, thus his Gitolite username will be <code class="literal">adam</code>, but as you follow along, please substitute your own name wherever you see references to Adam or <code class="literal">adam</code>.</p><p>Ssh is a powerful and complex tool. To make things simpler in this chapter, we will describe a set of steps that would surely work, along with suitable assumptions and constraints. These constraints are not absolutely necessary, but they do serve to simplify our procedure, as well as remove potential troublespots. If you're very familiar with SSH, you will probably be able to get around them quite easily.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Creating an ssh key pair</h2></div></div></div><p>The administrator <a id="id45" class="indexterm"/>needs to first create an <a id="id46" class="indexterm"/>ssh key pair for themselves at their main workstation. In many cases, there may already be an ssh key pair, possibly generated for some other purpose. You should look in <code class="literal">$HOME/.ssh</code> for a pair of files called <code class="literal">id_rsa</code> and <code class="literal">id_rsa.pub</code>. If you don't find any such files, you can generate a key pair by running the <code class="literal">ssh-keygen</code> command.</p><p>Ideally, you will choose a strong passphrase to protect your private key when generating your ssh key pair. To use it without having to constantly type the passphrase, you will then use the <code class="literal">ssh-agent</code> command or any of its derivatives, such as the keychain package. However, these nuances are out of the scope of this book.</p><p>Similarly, if you had previously created a non-default key type (that is, something other than RSA for ssh protocol 2, which is the default), then it is assumed that you know what you are doing. Gitolite should work fine with DSA and ECDSA key pairs, but will probably not work with RSA protocol 1 keys.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Running the setup command</h2></div></div></div><p>Now that <a id="id47" class="indexterm"/>you have your key pair at your workstation, you will need to get the public key (and <em>only</em> the public key!) over to the Gitolite <a id="id48" class="indexterm"/>hosting user's home directory on the server. One way to do this is to use the <code class="literal">scp</code> command, as in <code class="literal">scp .ssh/id_rsa.pub git@host:adam.pub</code>. You can use any other method available to you, for example rsync, or sftp, or even a USB stick. It doesn't matter how you do it as long as the file gets there and is renamed as <code class="literal">adam.pub</code>.</p><p>A word of warning for ssh experts: do not be tempted to automatically add this key to the Gitolite hosting user's authorized keys file using a command such as <code class="literal">ssh-copy-id</code>.</p><p>Once you have copied the file, you are ready to run the actual setup command, which is as follows:</p><div><pre class="programlisting">
<strong>gitolite setup -pk adam.pub</strong>
</pre></div><p>This command should produce an output similar to the following:</p><div><pre class="programlisting">
<strong>Initialized empty Git repository in /home/gitolite-test/repositories/gitolite-admin.git/ </strong>
<strong>Initialized empty Git repository in /home/gitolite-test/repositories/testing.git/ </strong>
<strong>WARNING: /home/gitolite-test/.ssh/authorized_keys missing; creating a new one </strong>
</pre></div><p>You can ignore<a id="id49" class="indexterm"/> the warning about the<a id="id50" class="indexterm"/> authorized keys file being created—this is quite normal for the first time you do this. And with that, your Gitolite installation and setup are all done.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Checking over your new Gitolite server</h2></div></div></div><p>Very few Gitolite administration<a id="id51" class="indexterm"/> tasks require logging on to the server and using the command line. Most of the day-to-day maintenance tasks (especially adding users and repositories) are done by making changes to a special repository called <code class="literal">gitolite-admin</code>, and pushing those changes to the server; that is, the administrator must perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Clone the <code class="literal">gitolite-admin</code> repository.</li><li class="listitem">Add some files or make changes to existing files.</li><li class="listitem">Commit the changes.</li><li class="listitem">Push them to the server (an administrator is someone who is allowed to push to the <code class="literal">gitolite-admin</code> repo). When the push completes, Gitolite on the server side invokes specific scripts to effect the changes requested.</li></ol></div><p>You should be able to clone the gitolite-admin repository from your workstation by running <code class="literal">git clone</code> <code class="literal">git@server:gitolite-admin</code>. Git will use ssh to connect to the "git" user on the "server". By default, it will look at your <code class="literal">$HOME/.ssh</code> directory, find your ssh key pair, and offer the public key to the server to authenticate you. After that, things proceed pretty much as described in the earlier section on distinguishing users from each other, and Gitolite gives you access to the repository.</p><p>You should now see the usual message from a successful <code class="literal">git clone</code> operation, and you can enter <code class="literal">cd gitolite-admin</code> to see what came in:</p><div><pre class="programlisting">
<strong>$ cd gitolite-admin </strong>
<strong>$ ls -a </strong>
<strong>.  ..  conf  .git  keydir </strong>
<strong>$ ls -a conf keydir </strong>
<strong>conf: </strong>
<strong>.  ..  gitolite.conf </strong>

<strong>keydir: </strong>
<strong>.  ..  adam.pub </strong>
</pre></div><p>You can see where<a id="id52" class="indexterm"/> the public keys are stored. Note that Gitolite's notion of what your Gitolite username is, comes solely from the name of the public key file in the <code class="literal">keydir</code> directory. This is why when you copied the <code class="literal">id_rsa.pub</code> file from your workstation you copied it as <code class="literal">adam.pub</code>.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Ssh experts may note that the comment field inside the public key file is ignored; it would be against the conventional meaning of the word "comment" to use it for anything that causes a behavioral change in a system, despite the number of people on the Internet who appear to think it has a higher purpose.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Adding a user</h2></div></div></div><p>Althoug<a id="id53" class="indexterm"/>h we <a id="id54" class="indexterm"/>will cover adding users in detail in a later chapter, you may want to add a beta user right away. Let's say you want to add Bob; here's how you can do this:</p><div><ol class="orderedlist arabic"><li class="listitem">Get his public key, rename it to <code class="literal">bob.pub</code>.</li><li class="listitem">Copy it to the <code class="literal">keydir</code> directory you saw above (that is, in your local clone of the <code class="literal">gitolite-admin</code> repository).</li><li class="listitem">Add the file, commit, and push.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Adding a repository</h2></div></div></div><p>Looking<a id="id55" class="indexterm"/> inside the <code class="literal">conf/gitolite.conf</code> file<a id="id56" class="indexterm"/> shows us the following:</p><div><pre class="programlisting">
<strong>$ cat conf/gitolite.conf </strong>
<strong>repo gitolite-admin </strong>
<strong>    RW+     =   adam </strong>

<strong>repo testing </strong>
<strong>    RW+     =   @all </strong>
</pre></div><p>To add a new repository, edit this file and add a repo line similar to the ones that were added previously, followed by an access rule line, sticking to the syntax shown previously for now. Save the file, add it, commit the change, and push the commit. You should immediately see the usual response from the remote git for a successful push, but also something<a id="id57" class="indexterm"/> like the following:</p><div><pre class="programlisting">
<strong>remote: Initialized empty Git repository in /home/gitolite-test/repositories/t2.git/ </strong>
</pre></div><p>This indicates that the new repository is ready for use.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we installed Gitolite, learned about the special <code class="literal">gitolite-admin</code> repository and its contents, and added a new user and a new repository. In the next chapter, we will talk about what a Gitolite-managed Git repository server will look like to your users and what they can do with it.</p></div></body></html>