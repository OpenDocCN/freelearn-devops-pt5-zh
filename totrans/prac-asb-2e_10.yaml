- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Automation with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Years ago, the standard practice was to configure every single network device
    by hand. This way of managing devices was possible mainly because the routers
    and switches were routing the traffic of physical servers, so only a little configuration
    was needed on each networking device, and changes were slow-paced. In addition,
    humans were the only ones with enough information on machines to set up networking.
    Everything was very manual in terms of both planning and execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtualization** changed this paradigm, as it has resulted in thousands of
    machines being connected to the same switch or router, each with potentially different
    networking requirements. Changes are fast paced and expected frequently, and with
    virtual infrastructures defined in code, it becomes a full-time job for a human
    administrator just to keep up with the changes to the infrastructure. Virtualization
    orchestration platforms have far better knowledge of the machine’s location and
    can even generate an inventory for us, as we saw in earlier chapters. Practically
    speaking, there is no way a human being can memorize or manage a modern, large-scale,
    virtualized infrastructure. As a result, it becomes clear that automation is required
    when configuring the network infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn more about this and what we can do to automate our network in
    this chapter by covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why automate network management?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Ansible manages networking devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enable network automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available Ansible networking modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables for network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom conditional statements for networking devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.15\. This chapter also assumes that
    you have at least one additional host to test against; ideally, this should be
    Linux-based. Since this chapter is network device-centric, we understand that
    not everyone will have access to specific networking equipment to test on (for
    example, Cisco switches).
  prefs: []
  type: TYPE_NORMAL
- en: Where examples are given, and you have access to such devices, please feel free
    to explore the examples. However, if you do not have access to any network hardware,
    we will give an example using the freely available Cumulus VX, which offers a
    fully-featured demo of Cumulus Networks’ switching environment. Although we will
    give specific examples of hostnames in this chapter, you are free to substitute
    them with your hostname and/or IP address. Details of how to do this will be provided
    in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010).'
  prefs: []
  type: TYPE_NORMAL
- en: Why automate network management?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How we design data centers has radically changed in the last 30 years. In the
    90s, a typical data center was full of physical machines, each with a particular
    purpose. In many companies, the servers were bought from different vendors based
    on the purpose of the machine. This meant that every time there was a need for
    new servers, network devices, and storage devices, those devices were bought,
    provisioned, configured, and delivered.
  prefs: []
  type: TYPE_NORMAL
- en: The big drawback here was the significant lag between identifying the need for
    the server and its delivery. At the time, this was acceptable since most companies
    had very few systems, and they tended to change very rarely. Also, this approach
    was costly as a lot of devices were underutilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the progress of society and companies in the world of technology, it has
    become necessary for companies to get more efficiency from their infrastructure
    and cut their infrastructure deployment time and costs. These new requirements
    paved the way for a new idea: virtualization. By creating a virtualization cluster,
    you do not need physical hosts of the right size, so you can provision a number
    of them upfront, add them to a resource pool, and then create the right-sized
    machines in your virtualization platform. This decoupling means that when a new
    server is needed, you can create it with a few clicks and it will be ready in
    seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: This shift also allowed enterprises to move from a per-project infrastructure,
    with each project being deployed with its unique data center requirements, to
    one large central infrastructure that can have its behavior defined by software
    and configuration. This new architecture means that a single network infrastructure
    can support many projects, regardless of their scale. We call this a **virtual
    data center infrastructure**; in this infrastructure, we use generic design patterns
    as much as possible. The virtual data center infrastructure allows enterprises
    to deploy, switch, and serve infrastructure at a large scale to enable a multitude
    of projects so that they can be successfully implemented by simply subdividing
    them (for example, by creating virtual servers).
  prefs: []
  type: TYPE_NORMAL
- en: Another significant advantage of virtualization is the decoupling of workloads
    and physical hosts. Historically, since a workload was tied to a physical host,
    if the host died, the workload itself died if not correctly replicated on different
    hardware. Virtualization solved this problem since the workload is now tied to
    one or more virtual hosts, but those can be moved freely from one physical host
    to another by the virtualization controller.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to provision servers quickly and the ability to move them from
    one host to another created an issue with networking configuration management.
    Before, it was acceptable for a human to tweak the configuration details while
    installing the new machine, but now, machines move from one host to another (and
    therefore from one physical switch port to another) without any human intervention.
    This peculiarity means that the system needs to update network configurations
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, and for similar reasons, VLANs affirmed their presence in
    networking, which allowed the utilization of network devices to be dramatically
    improved, and its costs to therefore be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we work at an even larger scale, where virtual objects (machines, containers,
    functions, and so on) move in our data centers, fully managed by software systems,
    and where humans are less and less involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this kind of environment, automating the network configuration is a crucial
    part of its success.
  prefs: []
  type: TYPE_NORMAL
- en: Today, some companies (the famous *cloud providers*) work at a scale where manual
    network management is not only impracticable but impossible, even when employing
    huge teams of network engineers. On the other hand, there are many environments
    where it would be technically possible to manage network configurations manually,
    at least partially so, but it’s still impractical.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the time required to configure a network device, the biggest advantage
    – from my perspective – of network automation is the opportunity to drastically
    reduce human errors. If a human has to configure a VLAN on 100 devices, chances
    are they will make a few errors in the process. This is normal but problematic
    since those configurations must be thoroughly tested and amended. Often, the problem
    doesn’t stop here because when a device breaks and needs to be replaced, a human
    has to configure the new device in the same way as the old one was configured.
    Often – over time – the configurations change, and there is very often no clear
    way to trace this, so while replacing a faulty network device, there might be
    problems with some rules that were present in the previous device but are not
    present in the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the need to automate network management, let’s look
    at how to manage networking devices with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: How Ansible manages networking devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows you to manage many different networking devices, including Arista
    EOS, Cisco ASA, Cisco IOS, Cisco IOS XR, Cisco NX-OS, Dell OS 6, Dell OS 9, Dell
    OS 10, Extreme EXOS, Extreme IronWare, Extreme NOS, Extreme SLX-OS, Extreme VOSS,
    F5 BIG-IP, F5 BIG-IQ, Junos OS, Lenovo CNOS, Lenovo ENOS, MikroTik RouterOS, Nokia
    SR OS, Pluribus Netvisor, and VyOS, as well as all OSs that support NETCONF. As
    you can imagine, we can make Ansible communicate with them in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have to remember that Ansible networking modules run on the controller
    host (the one where you issued the `ansible` command), while usually, the Ansible
    modules run on the target host. This difference is crucial because it allows Ansible
    to use different connection mechanisms based on the target device type. Remember
    that even when you have a host with SSH management capabilities (that many switches
    have), Ansible needs Python to be present on the target host to be able to run
    modules on it. Since most switches (and embedded hardware) do not have Python,
    Ansible will often use specific connection protocols. The key ones supported by
    Ansible for network device management are given here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main connection types that Ansible uses for connecting to those
    network devices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.netcommon.network_cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.netcommon.netconf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.netcommon.httpapi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you create a connection with your networking device, you need to choose
    the connection mechanism based on the ones supported by your devices and your
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.netcommon.network_cli` is supported by most modules, and it is the
    most similar to how Ansible usually works with non-networking modules. This mode
    uses a CLI via SSH. This protocol creates a persistent connection at the beginning
    of the execution, which is kept alive for the whole execution so that you don’t
    have to provide credentials for every task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.netcommon.netconf` is supported by some modules. This mode uses XML
    via SSH, so it applies XML-based configurations to the device. This protocol creates
    a persistent connection at the beginning of the execution, which is kept alive
    for the whole execution so that you don’t have to provide credentials for every
    task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.netcommon.httpapi` is supported by a few modules. This mode uses the
    HTTP API that the device publishes. This protocol creates a persistent connection
    at the beginning of the execution, which is kept alive for the whole execution
    so that you don’t have to provide credentials for every task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local` is supported by most devices, but it is a deprecated connection mode.
    This connection mode is vendor-dependent and usually requires some vendor-specific
    packages to be present on Ansible’s execution host. This mode does not create
    a persistent connection, so you must provide the credentials at every task. When
    possible, avoid this mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh` must not be forgotten as an option. Although a large number of devices
    depend upon the connection modes listed before, a new breed of network devices
    is being created that runs Linux natively on **white box** switch hardware. One
    such example is Cumulus Networks (now part of NVIDIA), and as its software is
    Linux-based, all configurations can be performed over SSH as if the switch was
    just another Linux box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing how Ansible connects to and communicates with your networking hardware
    is essential, as it gives you the understanding you need to build your Ansible
    playbooks and debug issues when things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the communication protocols you will come across
    when working with networking hardware. In the next section, we will build on this
    by looking at the fundamentals of starting our network automation journey with
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: How to enable network automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using Ansible for network automation, you must ensure you have everything
    you need. We need different requirements based on the kind of connection method
    we will use. For our example, we will use a Cisco IOS device with `network_cli`
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only requirements for Ansible network automation to work are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible 2.5+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper connectivity with the network device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we need to check the Ansible version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that you have a recent Ansible version, you can run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will tell you the version of your Ansible installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it’s 2.5 or newer, you can issue the following command (with the appropriate
    options) to check the connectivity of your network device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command should return your device’s facts, proving that we can connect.
    As for any other target, Ansible can retrieve facts, which is usually the first
    thing Ansible does when interacting with a target.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we are using the `–k` parameter to inform Ansible that
    we want to be prompted for a password to be used for SSH login.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving facts is a key step since this allows Ansible to know the current
    state of the device and act appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: By running the `cisco.ios.ios_facts` module on our target device, we are just
    executing this first standard step (so no changes are performed), but this confirms
    that Ansible can connect to the device and perform commands on it.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have imagined, you can only run the preceding command and explore
    its behavior if you have access to a network device running Cisco IOS. We understand
    that not everyone has the same networking equipment available for testing purposes
    (or any at all!). Fortunately for us, a new breed of switches is becoming available
    – white box switches. These switches are created by various manufacturers and
    are based on standardized hardware where you can install your network operating
    system. One such operating system is NVIDIA Cumulus Linux, and a freely available
    test version of this, called NVIDIA Cumulus VX, is available for you to download.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the download link for NVIDIA Cumulus VX is [https://www.nvidia.com/en-us/networking/ethernet-switching/cumulus-vx/](https://www.nvidia.com/en-us/networking/ethernet-switching/cumulus-vx/).
    You will need to register to download it, but doing so gives you free access to
    the world of open networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the image appropriate to your hypervisor (for example, VirtualBox)
    and then run it just as you would run any other Linux virtual machine. Once you’ve
    done this, you can connect to the NVIDIA Cumulus VX switch, just like you would
    any other SSH device. For example, to run an ad hoc command to gather facts about
    all the switch port interfaces (that are enumerated as `swp1`, `swp2`, and `swpX`
    on Cumulus VX), you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, this should result in pages of information about the switch
    port interface for your Cumulus VX-powered virtual switch. On my test system,
    the first part of this output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, working with white box switches using an operating system such
    as NVIDIA Cumulus Linux has the advantage that you can connect using the standard
    SSH protocol and even use the `ansible.builtin.setup` module to gather facts about
    it. Working with other proprietary hardware is not much more difficult but requires
    more parameters to be specified, as we showed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the fundamentals of enabling network automation, let’s learn
    how to discover the appropriate networking modules for our desired automation
    task in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The available Ansible networking modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the advent of Galaxy and collections, we have seen a huge increase in
    available Ansible content for networking. Currently, there are more than 150 collections
    and more than 1,000 roles on Galaxy. You can also find the most important collections
    on the official Ansible documentation. To find the collections, you should take
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, check the official documentation. By visiting [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml),
    you can find the different device families and which connection types they use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the device you would like to manage is not on the list, you can search on
    Galaxy by going to [https://galaxy.ansible.com](https://galaxy.ansible.com) and
    using the website’s search feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of collections and modules is way too long and family-specific for
    us to discuss them in depth. Also, those lists are in constant update, and they
    tend to get continuously longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with configuring the device manually, you will quickly
    find the name of the modules reasonably natural, so it will be easy for you to
    understand what they do. However, let’s go through a handful of examples from
    the collection of Cisco IOS modules – specifically, with reference to [https://galaxy.ansible.com/cisco/ios](https://galaxy.ansible.com/cisco/ios):'
  prefs: []
  type: TYPE_NORMAL
- en: '`cisco.ios.ios_banner`: As the name suggests, this module will allow you to
    tweak and modify the login banner (which in many systems is called *motd*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cisco.ios.ios_bgp`: This module allows you to configure BGP routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cisco.ios.ios_command`: This is the IOS equivalent of the `ansible.builtin.command`
    module and it allows you to perform many different commands. As for the `ansible.builtin.command`
    module, this is a very powerful module, but it’s better to use specific modules
    for the operations we are going to perform if they are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cisco.ios.ios_config`: This module allows us to make any changes to the device’s
    configuration file. Similarly to the `cisco.ios.ios_command` module, this is a
    very powerful module, but it’s better to use specific modules for the operation
    we are going to perform if they are available. The idempotency for this module
    is only guaranteed if no abbreviated commands are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cisco.ios.ios_vlan`: This module allows the configuration of VLANs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few examples, but there are many more modules for Cisco IOS,
    and if you cannot find a specific module to perform the operation you want, you
    can always fall back to `cisco.ios.ios_command` and `cisco.ios.ios_config`, which,
    thanks to their flexibility, will allow you to perform any operation you can think
    of.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, if you are working with a Cumulus Linux switch, you’ll find there
    are fewer modules since they are more generic.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the Ansible documentation is your friend, and it should be your first
    port of call when you are learning how to automate commands on a new class of
    devices. In this section, we have demonstrated a simple process for finding out
    which Ansible modules are available for your network device, using Cisco as a
    specific example (though you could apply these principles to any other device).
    Now, let’s look at how Ansible connects to network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, there are some peculiarities in Ansible networking, so specific
    configurations are required.
  prefs: []
  type: TYPE_NORMAL
- en: To manage network devices with Ansible, you need to have at least one to test
    on. Let’s assume we have a Cisco IOS system available to us. It is accepted that
    not everyone will have such a device to test on, so the following is offered as
    a hypothetical example only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going by the [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml)
    page, we can see that the correct `ansible_network_os` for this device is `cisco.ios.ios`
    and that we can connect to it using both `network_cli` and `local`. Since `local`
    is deprecated, we are going to use `network_cli`. Follow these steps to configure
    Ansible so that you can manage IOS devices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the inventory file with our devices in the `routers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To know which connection parameters to use, we will set Ansible’s special connection
    variables so that they define the connection parameters. We’ll do this in a group
    variables subdirectory of our playbook, so we will need to create the `group_vars/routers.yml`
    file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Thanks to these special variables, Ansible will know how to connect to your
    devices. We covered some of these examples earlier in this book, but as a recap,
    Ansible uses the values of those variables to determine their behavior in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_connection`: This variable is used by Ansible to decide how to connect
    to the device. By choosing `network_cli`, we are instructing Ansible to connect
    to the CLI in SSH mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_network_os`: This variable is used by Ansible to understand the device
    family of the device we are going to use. By choosing `cisco.ios.ios`, we are
    instructing Ansible to expect a Cisco IOS device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_become`: This variable is used by Ansible to decide whether to perform
    privilege escalation on the device or not. By specifying `True`, we are telling
    Ansible to perform privilege escalation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_become_method`: There are many different ways to perform privilege
    escalation on the various devices (normally `sudo` on a Linux server – this is
    the default setting), and for Cisco IOS, we must set this to `enable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, you have learned the necessary steps to connect to network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate that the connection is working as expected (assuming you have access
    to a router running Cisco IOS), you can run this simple playbook, called `ios_facts.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this using a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If it returns successfully, this means that your configuration is correct and
    you’ve been able to give Ansible the necessary authorization to manage your IOS
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you wanted to connect to a Cumulus VX device, you could add another
    group variables file called `group_vars/cumulusvx.yml` containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An analogous playbook that returns all the facts about our Cumulus VX switches
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this in a normal manner by using a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, you should see the following output from your playbook run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates the techniques for connecting to two different types of network
    devices in Ansible, including one you can test by yourself without access to any
    special hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s build on this by looking at how to set environment variables for
    network devices in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables for network devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very often, the complexity of networks is high, and the network systems are
    very varied. For those reasons, Ansible has many variables that can help you tweak
    it to make Ansible fit your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose you have two different networks (one for computing and one for
    network devices) that can’t communicate directly but have to pass through a bastion
    host to reach one from the other. Since we have Ansible in the computing network,
    we must jump networks using the bastion host to configure an IOS router in the
    management network. Also, our target switch needs a proxy set to reach the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the IOS router in the management network, we will need to create
    a new group for our network devices, which are on a separate network. For this
    example, this might be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the creation of our updated inventory, we can create a new group
    variables file, such as `group_vars/bastion_routers.yaml`, with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do the same for our Cumulus VX switches if they are behind a bastion
    server by creating a `group_vars/bastion_cumulusvx.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the options we discussed in the previous section, we now have
    two additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_ssh_common_args`: This is a very powerful option that allows us to
    add additional options to the SSH connections to tweak their behavior. These options
    should be pretty straightforward to identify since you are already using them
    in your SSH configurations to simply SSH to the target machine. In this specific
    case, we are adding `ProxyCommand`, which is the SSH directive to perform a jump
    to a host (usually a bastion host) so that we can enter the target host securely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http_proxy`: This option, which is below the `proxy_env` option, is key in
    environments where network isolation is strong, and therefore your machines can’t
    interact with the internet unless they use a proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming you have set up passwordless (for example, SSH key-based) access to
    your bastion host, you should be able to run an ad hoc Ansible `ping` command
    against your Cumulus VX host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that using the bastion server becomes transparent – you can automate with
    Ansible as if you were on the same flat network. If you have access to a Cisco
    IOS-based device, you should be able to run a similar command against the `bastion_routers`
    group and achieve similarly positive results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned the necessary steps to set environment variables for
    network devices and access them with Ansible, even when they are on isolated networks,
    let’s learn how to set conditional statements for networking devices.
  prefs: []
  type: TYPE_NORMAL
- en: Custom conditional statements for networking devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there are no networking-specific Ansible conditionals, conditionals
    frequently come into play in networking-related Ansible usage.
  prefs: []
  type: TYPE_NORMAL
- en: In networking, it’s common to enable and disable ports. To have data be able
    to pass through the cable, both ports at the ends of the cable should be enabled,
    resulting in a connected state (some vendors will use different names for this,
    but the idea is the same).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose we have two Arista Networks EOS devices, and we issued the ON
    status on the ports and need to wait for the connection to be up before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wait for the `Ethernet4` interface to be enabled, we will need to add the
    following task to our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`arista.eos.eos_command` is the module that allows us to issue free-formed
    commands to an Arista Networks EOS device. The command itself needs to be specified
    in an array in the `commands` option. With the `wait_for` option, we can specify
    a condition and Ansible will reiterate on the specified task until the condition
    is satisfied. Since the command’s output is redirected to the `json` utility,
    the output will be a JSON, so we can traverse its structure using Ansible’s ability
    to manipulate JSON data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve similar results on Cumulus VX – for example, we can query the
    facts gathered from the switch to see whether the `swp2` port is enabled. If it
    is not, then we will enable it; however, if it is enabled, we will skip the command.
    We can do this with a simple playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `when` clause in our task, meaning we should only issue
    the configuration directive if `swp2` is not active. If we were to run this playbook
    for the first time on an unconfigured Cumulus Linux switch, we should see an output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `Enable swp2` task, if it is disabled based on the `community.network.nclu`
    module, returned a `changed` state, which means that it changed the switch configuration.
    However, if we were to run the playbook a second time, the output should be more
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time, the task was skipped as the Ansible facts show that the `swp2` port
    is already enabled. This example is elementary, but it shows how you can work
    with conditionals on a network device, as you have already seen conditionals being
    used on Linux servers earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our brief look at network device automation with Ansible – more
    in-depth work would require a look at network configurations and necessitate more
    hardware, which is beyond the scope of this book. However, I hope this information
    demonstrates that Ansible can be used effectively to automate and configure a
    wide array of network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern large-scale infrastructures that change rapidly necessitate the automation
    of network tasks. Fortunately, Ansible supports a wide array of network devices,
    from proprietary hardware such as Cisco IOS-based devices, to open standards such
    as white box switches that run operating systems such as Cumulus Linux. Ansible
    is a powerful and supportive tool to manage your network configuration and allows
    you to implement changes quickly and safely. You can even replace entire devices
    in your network and be confident in your ability to put the correct configuration
    on the new device, thanks to your Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the reasons for automating network management.
    You then looked at how Ansible manages network devices, how to enable network
    automation in Ansible, and how to locate the Ansible modules necessary to perform
    the automation tasks you wish to complete. Then, through practical examples, you
    learned how to connect to network devices, set environment variables (and connect
    to isolated networks via bastion hosts), and apply conditional statements to Ansible
    tasks for network device configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to manage Linux containers and cloud
    infrastructures using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these is NOT one of the four major connection types that Ansible uses
    for connecting to network devices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`netconf`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`network_cli`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`local`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`netstat`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`httpapi`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: The `ansible_network_os` variable is used by Ansible to understand
    the device family of the device we are going to use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: To connect to an IOS router in a separate network, you need
    to specify the special connection variables for the host, possibly as inventory
    group variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation about Ansible networking is available here: [https://docs.ansible.com/ansible/latest/network/index.xhtml](https://docs.ansible.com/ansible/latest/network/index.xhtml).'
  prefs: []
  type: TYPE_NORMAL
