- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1 – Communicating with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container orchestration is a software pattern where multiple containers are
    controlled and scheduled in order to serve an application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kubernetes API server (`kube-apiserver`) handles requests to update Kubernetes
    resources. The scheduler (`kube-scheduler`) decides where to place (schedule)
    containers. The controller manager (`kube-controller-manager`) ensures that the
    desired configuration of Kubernetes resources is reflected in the cluster. `etcd`
    provides a data store for the cluster configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `kube-apiserver` must be started with the `--authorization-mode=ABAC` and
    `--authorization-policy-file=filename` parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For high availability of the control plane, in case of a failure of one of the
    master nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event that a resource has already been created, `kubectl create` will
    fail because the resource already exists, while `kubectl apply` will attempt to
    apply any YAML changes to the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `kubectl use-context` command can be used to switch between multiple contexts
    within a `kubeconfig` file. To change between `kubeconfig` files, the `KUBECONFIG`
    environment variable can be set to the path of the new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imperative commands do not provide a history of changes to a resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2 – Setting Up Your Kubernetes Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube makes it easy to set up a local Kubernetes cluster for development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some cases, there may be a fixed minimum cost for the cluster that is larger
    than a self-provisioned cluster. Some managed options also have license costs
    in addition to the cost of compute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubeadm is agnostic to infrastructure providers, while Kops supports only several
    major providers with deeper integration and compute provisioning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As of the writing of this book, AWS, Google Cloud Platform, Digital Ocean, VMware,
    and OpenStack, in various levels of production readiness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Typically, the cluster components are defined in the `systemd` service definitions,
    which allows the automatic restart of services if a node shuts down and restarts
    at the OS level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3 – Running Application Containers on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you had development, staging, and production environments, you could make
    one namespace for each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Node that the Pod is running in could be in a *broken* state where the control
    plane cannot reach it. Typically, when a Node gracefully exits the cluster, the
    Pod will simply be rescheduled instead of showing an *Unknown* status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent memory-hungry Pods from taking over the entire Node and causing indeterminate
    behavior in other Pods on the Node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should add more delay to the *Startup* probe if you have one. If not, you
    will need to add one, or add a delay to the *Readiness* probe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4 – Scaling and Deploying Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReplicationControllers have less flexibility in how the selector is configured
    – only key-value selectors are allowed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployments allow you to specify how updates are rolled out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jobs work well for batch tasks, or tasks that can be scaled horizontally with
    a clear completion target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: StatefulSets provide an ordinal Pod identity that stays the same when those
    Pods restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to an existing version, a new Deployment can be created with the
    canary version. Then, both versions can be accessed in parallel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5 – Services and Ingress – Communicating with the Outside World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would use a ClusterIP service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the `kubectl describe` command to see what port on the Nodes a NodePort
    service is active on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a cloud environment where you often have to pay per load balancer, Ingress
    allows you to specify multiple routing rules while only having to pay for one
    load balancer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ExternalName services can be used to easily route to other pieces of infrastructure
    in your cloud environment – such as managed databases and object storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6 – Kubernetes Application Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets are stored encoded and optionally encrypted in `etcd`. ConfigMaps are
    stored in plain text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are Base64-encoded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data will be more visible when describing the ConfigMap. The key-value pattern
    is also easier to use when mounting the ConfigMap as an environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on how you set up your cluster, your secrets may not be encrypted
    at all. If a cluster's EncryptionConfiguration is not set, secrets will only be
    Base64-encoded – and they can easily be decoded. By creating your cluster with
    an EncryptionConfiguration, your secrets will be stored encrypted in `etcd`. This
    is not a security panacea, but encryption at rest is certainly necessary to improve
    security for secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7 – Storage on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Volumes are tied to the life cycle of a Pod and are deleted when the Pod is
    deleted. Persistent Volumes will remain until a cluster is deleted, or they are
    specifically deleted themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: StorageClasses define the *type* of a Persistent Volume. They can be used to
    distinguish between different types of storage, such as between faster SSD storage
    and slower hard drives – or different types of cloud storage. StorageClasses determine
    where a PersistentVolumeClaim and Persistent Volume will go to get provisioned
    storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a managed Kubernetes service with integrated storage provisioning or add
    a **cloud-controller-manager** configuration to your cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any application that needs to store state for longer than the life of an individual
    Pod would not work with Volumes. Any application that needs to have state that
    is tolerant to Pod failure needs a Persistent Volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8 – Pod Placement Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node Selectors can be used to match against Node labels and multiple Nodes can
    fulfill the requirements. Using a Node name means that you specify the single
    Node where the Pod must be placed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes implements some default taints to ensure that Pods do not get scheduled
    on Nodes that are malfunctioning or lack resources. In addition, Kubernetes taints
    the master Nodes to prevent scheduling of user applications on the masters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Too many affinities and anti-affinities can slow down the scheduler or cause
    it to become unresponsive. Determining Pod placement in cases with a lot of affinities
    or anti-affinities is very compute-heavy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using anti-affinities, you could prevent Pods from co-existing with like Pods
    in the same failure domain. Nodes in the same failure domain would be labeled
    with a failure domain or zone identifier. Anti-affinity would look for Pods matching
    the specific tier of the application level in the same failure domain, and prevent
    scheduling on Nodes matching that domain. The end result would be each tier of
    the three-tier application being spread out among multiple failure domains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9 – Observability on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metrics correspond to numerical values that present application/compute performance
    and/or usage across many categories, including disk, CPU, memory, latency, and
    so on. Logs correspond to the application, Node, or control plane text logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Grafana UI is highly customizable and can be used to present complex Prometheus
    (or another data source's) queries in an elegant, flexible way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FluentD would need to run on the production cluster in order to collect logs.
    Elasticsearch and Kibana could run on a separate cluster or other infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10 – Troubleshooting Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of Kubernetes is the ability to scale the cluster easily
    by adding nodes or changing Pod placement by using controls such as taints and
    tolerations. In addition, Pod restarts can result in completely different IPs
    for the same application. This means that both the compute and network topologies
    can be ever-changing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `kubelet` is typically run as a Linux service with `systemd`, with control
    available using `systemctl` and logs in `journalctl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a few different methodologies to use, but generally, you would want
    to check whether all Nodes are ready and schedulable; whether there are any Pod
    Placement Controls precluding scheduling of the Pod; and whether there is any
    dependent storage, ConfigMaps, or secrets that do not exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11 – Template Code Generation and CI/CD on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm Charts use templates and variables, while Kustomize uses a patch-based
    strategy. Kustomize is built into recent versions of kubectl, while Helm uses
    a separate CLI tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration should emphasize security, since deploy credentials could
    be used to deploy attacker workloads to your cluster. Using either secure environment
    variables or access management controls on your cloud provider are two good strategies.
    The credentials should absolutely not be placed in any Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In-cluster setups can be preferable since Kubernetes credentials are not required
    to be provided by an external system. Out-of-cluster setups are usually simpler,
    and more synchronous than in-cluster setups, where a control loop determines when
    changes are made to the resource configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12 – Kubernetes Security and Compliance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MutatingAdmissionWebhook and ValidatingAdmissionWebhook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A NetworkPolicy with a blank Pod Selector has the effect of selecting all Pods.
    A NetworkPolicy with all Pods selected, and Ingress and Egress types added without
    any rules, will have the effect of automatically denying all ingress and egress
    to all Pods in the namespace of the NetworkPolicy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We would want to track any API requests where resources are patched or updated,
    because attackers could update a Deployment, Pod, or another resource with malicious
    containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13 – Extending Kubernetes with CRDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stored version is the version that is actually stored in the data store.
    Served versions are any versions that are accepted by the API for read or write
    operations. The served versions are converted into the stored version when stored
    in `etcd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure, Analyze, and Update (typically).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the cloud provider, the **cluster-autoscaler** addon will directly
    update autoscaling groups in order to add or remove Nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14 – Service Meshes and Serverless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A static Envoy configuration refers to an Envoy configuration that is manually
    created or written by a user. A dynamic Envoy configuration (like those provided
    by Istio) will constantly adapt to new containers, as well as new routing and
    filter rules, from an external controller or data plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listeners, Routes, Clusters, and Endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Knative requires many components in order to run. This allows for plenty of
    customization but makes it more difficult to set up and operate than OpenFaaS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15 – Stateful Workloads on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minio is an AWS S3-compatible storage tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: StatefulSets assist self-clustering applications such as distributed databases
    by providing stable, ordinal Pod identities, in addition to Persistent Volume
    stability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Kubernetes, Pods can be short-lived, and stateful applications can be distributed.
    This means that the process of maintaining state between Pods (for instance, the
    database consensus) can become difficult if Pods change identity and storage needs
    to be replicated from scratch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
