<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Understanding VREFs</h1></div></div></div><p>We looked at VREFs briefly in <a class="link" href="ch07.html" title="Chapter 7. Advanced Access Control and Configuration">Chapter 7</a>, <em>Advanced Access Control and Configuration</em>, including a small example to illustrate how Gitolite can allow or reject pushes based on which files have been modified in commits being pushed. In this chapter, we will explore VREFs in much greater detail, since this is one of the most powerful features of Gitolite. We will start small, describing the simplest use for VREFs, then move on to more complex uses.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec64"/>Migrating update hooks</h1></div></div></div><p>Some sites <a id="id214" class="indexterm"/>may already have been using update hooks in their <a id="id215" class="indexterm"/>existing (pre-Gitolite) repository setups. Since Gitolite reserves the update hook for itself, this presents a bit of a problem in terms of switching over.</p><p>If your site has such update hooks, the VREF mechanism can help replace them. Replacing update hooks is one of the simplest uses of VREFs, but understanding how that is done is also a good first step to understanding the full power of Gitolite's VREF mechanism.</p><p>To convert your existing update hooks to VREFs, you first create a directory called VREF within <code class="literal">$HOME/local</code> (we're continuing the convention from <a class="link" href="ch09.html" title="Chapter 9. Customizing Gitolite">Chapter 9</a>, <em>Customizing Gitolite</em>, that the <code class="literal">LOCAL_CODE</code> variable in the <code class="literal">rc</code> file points here). Then, copy each unique update hook into this newly created directory, renaming each update hook in some way.</p><p>As an example, say you had one repository that was frequently worked on by novice users using Windows, and so the update hook was used to make sure there were no line-ending problems. You might rename this to <code class="literal">check-crlf</code>.</p><p>Now, for each repository that needs this check to be made (that is, each repository that had used that specific update hook in the pre-Gitolite setup), add a rule like this:</p><div><pre class="programlisting">
<strong>-  VREF/check-crlf  =  @all</strong>
</pre></div><p>When Gitolite's update hook is processing a push, it will encounter this VREF rule and it will call the <code class="literal">check-crlf</code> program. The first three arguments passed are the same that Git itself has passed to <a id="id216" class="indexterm"/>the update hook, and if the program exits with a non-zero exit <a id="id217" class="indexterm"/>code, Gitolite will reject the push. No changes to the <code class="literal">check-crlf</code> code are needed to make all this happen; it just works.</p><p>Astute readers will have noticed that they could, instead of the rule shown above, use:</p><div><pre class="programlisting">
<strong>-  VREF/check-crlf  =  @junior-developers</strong>
</pre></div><p>This helps to limit the checking to only those users named in the rule. <em>In other words, Gitolite allows a plain old update hook to be selectively applied</em>, which could be very useful.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec65"/>Passing arguments to the VREF code</h1></div></div></div><p>Now let us <a id="id218" class="indexterm"/>suppose we had an update hook (in our pre-Gitolite setup) that <a id="id219" class="indexterm"/>prevented certain users from making changes to certain files. One way would be to write an update hook that checks for such files and use it as a VREF, as shown in the previous section. However, the list or pattern of files to be checked will need to somehow be encoded within the VREF code, or some other method of passing that information needs to be found.</p><p>Gitolite allows you to pass additional arguments to the VREF code. Let's say the VREF used is called <code class="literal">NAME</code>, then instead of merely saying:</p><div><pre class="programlisting">
<strong>-  VREF/NAME           =  @junior-developers</strong>
</pre></div><p>and making sure that the code for the <code class="literal">NAME</code> VREF knows which files we are talking about, you can say:</p><div><pre class="programlisting">
<strong>-  VREF/NAME/.*\.h$    =  @junior-developers</strong>
</pre></div><p>You'll see how this becomes really useful if you later find that another group of users needs to be restricted in a similar way, but for a different set of files. Let's say we have a set of technical writers who are working on the documentation; there's no reason for them to be touching the files that make up the source code:</p><div><pre class="programlisting">
<strong>-  VREF/NAME/.*\.[ch]$    =  @tech-writers</strong>
</pre></div><p>Of course, the VREF code is now not quite the same as it was when it was an update hook. Apart from the first three arguments (which are the same as those listed in man githooks for the <code class="literal">update</code> hook), there are now several other arguments, and the file patterns we just added are one of those (specifically, the eighth argument). The VREF code must get that pattern out of the incoming arguments and use it to decide whether the push is to be allowed or denied.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Using the permission field</h1></div></div></div><p>Let us say we <a id="id220" class="indexterm"/>have several different kinds of source code files, and<a id="id221" class="indexterm"/> listing all of them in the rule for the technical writer is not only cumbersome, but error prone because we might miss something. We do know, however, that technical writers only work on documents, so we'd prefer to simply restrict them to <code class="literal">*.odt</code> files.</p><p>Until now, we have considered the <code class="literal">NAME</code> VREF to behave in a certain way: receive a filename pattern, and if any file has been changed (in the push) that matches that pattern, exit with a non-zero return code to signal Gitolite to reject the push. As you can see, this behavior completely ignores the permission field; that is, even this rule would have the same effect:</p><div><pre class="programlisting">
<strong>RW+    VREF/NAME/.*\.[ch]$  =  @tech-writers</strong>
</pre></div><p>What we need is a way to consider the permission field as well. Our first impulse might be to develop some way to pass this field to the VREF code, perhaps with some new syntax, and let the VREF code reverse the check when required.</p><p>However, this complicates the VREF code, while at the same time not making use of Gitolite's rule processing logic.</p><p>Gitolite processes access control rules based on matching a <em>ref</em> (typically something like <code class="literal">refs/heads/master or refs/tags/v1.0</code>) against each rule in turn. So one way to make use of this is to not have the VREF code actually make a decision, but merely <em>output something</em> that Gitolite can capture and run through its access control rules, just like a normal <em>ref</em> would be.</p><p>You could call this a <em>virtual ref</em>, too!</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>Let us briefly recap the terminology, a VREF is the code that runs, and a virtual ref is what it might send back to Gitolite.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec47"/>Maintaining the update hook function</h2></div></div></div><p>However, we do <a id="id222" class="indexterm"/>not want to affect the behavior of a standard (Git) update hook when used as a VREF, as described earlier in this chapter. This is easy enough—Gitolite treats any lines in the VREF's output as virtual refs only if they start with <code class="literal">VREF/</code>, and even that only if the VREF has exited with zero status.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Default is success</h1></div></div></div><p>At this point we need to change the <code class="literal">NAME</code> VREF. Instead of making a decision, it should merely print all the files that have been changed, each prefixed with <code class="literal">VREF/NAME/</code>.</p><p>Once that is done, it might then seem that the following rule is all we need:</p><div><pre class="programlisting">
<strong>RW+    VREF/NAME/.*\.odt$  =  @tech-writers</strong>
</pre></div><p>However, that's not quite the end of it.</p><p>There's a slight difference in how virtual refs are treated compared to real refs. With real refs, if no access rule matches the ref (and the user, and the actual type of write), the default is to reject the push.</p><p>However, virtual refs are designed as <em>additional</em> rules, adding checks that the normal Gitolite access rules cannot. Thus it makes more sense that if no VREFs match, it should be as if no additional checks <em>apply</em> to this push, and so the default is to <em>allow</em> the push.</p><p>As a result, we need one more rule, which brings our final ruleset to this:</p><div><pre class="programlisting">
<strong>RW+    VREF/NAME/.*\.odt$  =  @tech-writers</strong>
<strong>-      VREF/NAME/          =  @tech-writers</strong>
</pre></div><p>Loosely speaking, what this does is, for each file that has been changed, generate a virtual ref by prefixing <code class="literal">VREF/NAME/</code> to it, and passing that virtual ref through the ruleset. The rest is obvious, for example, changing a file called <code class="literal">foo.c</code> creates a virtual ref called <code class="literal">VREF/NAME/foo.c</code>, which will match only the second rule and this push gets denied. Files whose names end in <code class="literal">.odt</code> will match the first rule and not cause a reject.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Example VREFs and their usage</h1></div></div></div><p>The Gitolite source tree<a id="id223" class="indexterm"/> comes with a few VREFs ready to be used. To use them, you simply add rules similar to the ones we saw at the end of the previous section. We will look at a couple of them to get a feel for how they are used, and then design one from scratch so we know how to add our own.</p><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>If you look in the Gitolite source tree, you won't actually find a VREF called <code class="literal">NAME</code>. This is because <code class="literal">NAME</code> is special and the code for that is built in to Gitolite.</p></div></div><p>Newcomers to Git may sometimes<a id="id224" class="indexterm"/> end up creating a commit that changes a lot more files than are strictly necessary for the change being made. Perhaps they added debugging statements to some other files, or perhaps they accidentally saved some files with a different line-ending (Unix LF versus Windows CRLF), and so on.</p><p>If you are sure that your new developers are given relatively simple tasks, and at no time should any particular task touch more than, say, five files, you can use the <code class="literal">COUNT</code> VREF to prevent them from pushing more, and thus protect the repository from wide-ranging changes of the kind discussed in the previous paragraph. Here's a rule that achieves that:</p><div><pre class="programlisting">
<strong>-  VREF/COUNT/5    =  @new-devs</strong>
</pre></div><p>The <code class="literal">COUNT</code> VREF<a id="id225" class="indexterm"/> essentially <a id="id226" class="indexterm"/>counts all the files changed in the commits that constitute the current push (and do not exist on any other branch or tag).</p><p>If that last bit sounds complicated, consider what happens when a developer merely makes a new branch out of an existing one and pushes it. We don't want the <code class="literal">COUNT</code> VREF to basically see all the files in the branch as changed, simply because the old value of the branch pushed was empty. This is why the <code class="literal">COUNT</code> code looks at commits that do not appear in any other ref.</p><p>The <code class="literal">MAX_NEWBIN_SIZE</code> VREF<a id="id227" class="indexterm"/> is similar in concept. This addresses the issue that sometimes developers unintentionally or unknowingly commit, say, a JAR file or the executable file produced by a build step. Executable files like this tend to be a bit larger than normal source files, so if you have some idea of a reasonable limit, you can use this VREF to enforce it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Writing your own VREF</h1></div></div></div><p>Here's an <a id="id228" class="indexterm"/>example use case where VREFs come in handy. We'll use this to design a very simple VREF, in a way that cannot be done with the existing rules.</p><p>The requirement is simple: for any repository <code class="literal">foo</code>, if a repository called <code class="literal">l10n</code> contains a directory called <code class="literal">foo</code>, then you cannot push any files called <code class="literal">*.po</code> to <code class="literal">foo</code>.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>This has been adapted from a more complex, real-life use case, but for our purposes we don't need more than this. As you might guess, this is a multi-repository system that is gradually moving toward centralizing the local language files so that translators only have to deal with one repository.  Each repository's local language files are moved over when they are deemed ready and from that point on, localization files must go to the single repository that was created for the purpose.</p></div></div><p>Because this is a very specific use case, we can write a simple VREF that does not take any arguments.  Our rule can look like this:</p><div><pre class="programlisting">
<strong>repo @all</strong>
<strong>-  VREF/l10n-check  =  @all</strong>
</pre></div><p>As you can see, we're applying this rule to all repositories. (This is slightly inefficient if you have several repositories for which this will never be true—the VREF will be invoked for each of them, <a id="id229" class="indexterm"/>on every push. If so, replace <code class="literal">@all</code> in the <code class="literal">repo</code> line with a group name that contains only those repositories for which this check is required)</p><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>There may be individual rules for each of those repositories elsewhere—we need not put this VREF rule in each repository section. This is an example of the <em>Rule Accumulation and Delegation</em>, discussed in <a class="link" href="ch06.html" title="Chapter 6. Getting Started with Access Control">Chapter 6</a>, <em>Getting Started with Access Control</em> in action.</p></div></div><p>Here's one way to code this VREF (some familiarity with basic shell syntax and Git concepts is required to understand this code):</p><div><pre class="programlisting">
<strong>#!/bin/bash</strong>

<strong># see Gitolite documentation for arguments and meanings</strong>
<strong>oldtree=$4</strong>
<strong>newtree=$5</strong>
<strong>refex=$7</strong>

<strong># no *.po files changed?  No problem!</strong>
<strong>git diff --name-only $oldtree $newtree | grep '.*\.po$' &gt;/dev/null || exit 0</strong>

<strong>cd $GL_REPO_BASE/l10n.git</strong>
<strong># no directory with the same name as $GL_REPO in the l10n repo?  No problem!</strong>
<strong>git ls-tree master | grep "\s$GL_REPO$" &gt;/dev/null || exit 0</strong>

<strong>echo $refex "sorry, PO files must be added to '$GL_REPO' subdirectory in 'l10n' repo"</strong>
</pre></div><p>As you can see, the first check uses the git diff command to check whether this push has changed any <code class="literal">po</code> files. If not, there's nothing to check and we exit without doing anything. The second check moves to the <code class="literal">l10n</code> repository, then runs an <code class="literal">ls-tree</code> on that repository to check whether it contains a file or directory whose name is the same as the repository that the user is pushing. If it does not, we can exit without complaint.</p><p>If those two checks succeed, we need to signal the error. One way would be to simply <code class="literal">exit 1</code>; Gitolite would catch the VREF code dying and reject the push. On the other hand, we could print the refex itself (which in this case is just <code class="literal">VREF/l10n</code>, but it's a good habit to use the argument instead). It will then match the access rule we set up, and because the permission is "-", the push will be rejected.</p><p>But the VREF feature <a id="id230" class="indexterm"/>offers a little more.  If, after the refex, you print a space and then some explanatory message, this message will be printed when the push is rejected:</p><div><pre class="programlisting">
<strong>$ git push</strong>
<strong>Counting objects: 4, done.</strong>
<strong>Delta compression using up to 4 threads.</strong>
<strong>Compressing objects: 100% (2/2), done.</strong>
<strong>Writing objects: 100% (3/3), 351 bytes | 0 bytes/s, done.</strong>
<strong>Total 3 (delta 0), reused 0 (delta 0)</strong>
<strong>remote: FATAL: W VREF/l10n t2 u1 DENIED by VREF/l10n </strong>
<strong>remote: sorry, PO files must be added to 't2' subdirectory in 'l10n' repo </strong>
<strong>remote: </strong>
<strong>remote: error: hook declined to update refs/heads/master </strong>
<strong>To u1:t2 </strong>
<strong> ! [remote rejected] master -&gt; master (hook declined) </strong>
<strong>error: failed to push some refs to 'u1:t2' </strong>
</pre></div><p>If you write VREFs to catch rarely occurring conditions, then you may find it useful to augment Gitolite's rather spartan error reporting with something in plain English, so your users can scratch their heads a little less!</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, we explored one of Gitolite's most powerful features—the ability to use arbitrary external factors for access control decisions by writing VREFs. The next chapter will conclude our exploration of Gitolite by talking about mirroring—a feature which large multi-site setups could find very useful.</p></div></body></html>