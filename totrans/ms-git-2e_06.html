<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor113" class="pcalibre1 pcalibre calibre6"/>5</h1>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor114" class="pcalibre1 pcalibre calibre6"/>Searching Through the Repository</h1>
<p class="calibre3">After selecting the parts of the project history that you want to search, the next task is to extract the information you want from selected commits. You can limit your search according to the revision metadata, such as the author of the commit, the date that the change was created, or the contents of the commit message. You can look at the changes themselves, or you may be interested in how a given file or subsystem evolved. With access to the project history, you can find who wrote a given section of the code or which commit introduced a regression (first buggy commit).</p>
<p class="calibre3">Another important skill is to format Git output so that it is easy to find the information you want. This task is made possible by various predefined pretty <code>git log</code> output formats and the ability to define and compose one’s own output format.</p>
<p class="calibre3">Here is the list of topics we will cover in this chapter:</p>
<ul class="calibre16">
<li class="calibre15">Limiting the history and history simplification</li>
<li class="calibre15">Searching the history with the pickaxe tool and diff search</li>
<li class="calibre15">Finding bugs with <strong class="source-inline1">git bisect</strong></li>
<li class="calibre15">Line-wise history of file contents with <strong class="source-inline1">git blame</strong> and rename detection</li>
<li class="calibre15">Selecting and formatting output (the pretty formats)</li>
<li class="calibre15">Summarizing contribution with <strong class="source-inline1">git shortlog</strong></li>
<li class="calibre15">Specifying a canonical author name and email with <strong class="source-inline1">.mailmap</strong></li>
<li class="calibre15">Viewing specific revisions, files at revision, and diff output options</li>
</ul>
<p class="calibre3">The purpose of this chapter is to show how to extract information from the project history.</p>
<h1 id="_idParaDest-110" class="calibre5"><a id="_idTextAnchor115" class="pcalibre1 pcalibre calibre6"/>Searching the history</h1>
<p class="calibre3">A huge number and variety of useful options for the <code>git log</code> command are revising limiting options — that is, options that let you <a id="_idIndexMarker348" class="pcalibre1 pcalibre calibre6"/>show only a subset of <a id="_idIndexMarker349" class="pcalibre1 pcalibre calibre6"/>commits. This complements selecting commits to view by passing the appropriate revision range and allows us to search the history for specific versions, utilizing information other than the shape of the graph of revisions.</p>
<h2 id="_idParaDest-111" class="calibre7"><a id="_idTextAnchor116" class="pcalibre1 pcalibre calibre6"/>Limiting the number of revisions</h2>
<p class="calibre3">The most basic way of limiting <code>git log</code> output is to show only the specified number of the most recent<a id="_idIndexMarker350" class="pcalibre1 pcalibre calibre6"/> commits. This is done using the <code>-&lt;n&gt;</code> option (where <code>n</code> is any integer); this can also be written as <code>-n &lt;n&gt;</code>, or in long form as <code>--max-count=&lt;n&gt;</code>. For example, <code>git log -2</code> would show the two last (most recent) commits in the current line of development, starting from the implicit <code>HEAD</code> revision.</p>
<p class="calibre3">You can skip the first few commits shown with <code>--skip=&lt;n&gt;</code>.</p>
<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor117" class="pcalibre1 pcalibre calibre6"/>Matching revision metadata</h2>
<p class="calibre3">History limiting options can be divided into those that check the information stored in the commit object itself (the revision<a id="_idIndexMarker351" class="pcalibre1 pcalibre calibre6"/> metadata) and those that filter commits based on the changeset (based on changes from the parent commit <a id="_idIndexMarker352" class="pcalibre1 pcalibre calibre6"/>or commits).</p>
<h3 class="calibre9">Time-limiting options</h3>
<p class="calibre3">If you are interested in<a id="_idIndexMarker353" class="pcalibre1 pcalibre calibre6"/> commits created within some specific date range, you can use a number of options such as <code>--since</code> and <code>--until,</code> or <code>--before</code> and <code>--after</code>. For example, the following command returns the list of commits made in the last two weeks:</p>
<pre class="console">
$ git log --since=2.weeks</pre>
<p class="calibre3">These options work with various <em class="italic">date</em> formats. You can specify a specific date such as <em class="italic">2008-04-21</em>, or a relative date such as <em class="italic">2 years 3 months 3 days ago</em>; you can also use a dot in place of a space.</p>
<p class="calibre3">When using a specific date, you must remember that if the date does not include a time zone, it will be interpreted in the local time zone. It is important because, in such a situation, Git will not yield identical results when run by colleagues who may be situated in other time zones around the world. For example, <code>--since="2014-04-29 12:00:00"</code> would catch six hours’ worth more commits when issued in Birmingham, England, UK (where it means 2014-04-29Z11:00:00 universal time) than when issued in Birmingham, Alabama, USA (where it means 2014-04-29Z17:00:00). To get the same results, you need to include the time zone in the time limit — for example, <code>-</code><code>‍</code><code>-after="2013-04-29T17:07:22+0200"</code>.</p>
<p class="calibre3">Note that commits in Git are described not by a single date, but by two possibly different dates: the author date and the committer date. Time-limiting options described here examine the <strong class="bold">committer date</strong>, which means the date and time when the revision object was<a id="_idIndexMarker354" class="pcalibre1 pcalibre calibre6"/> created. This might be different from the <strong class="bold">author date</strong>, which means the date and time when a changeset was created (when the change was made).</p>
<p class="calibre3">The date of authorship can be different from the date of committership in a few cases:</p>
<ul class="calibre16">
<li class="calibre15">One case is when the commit was created in one repository, converted to email, and then applied by another person in another repository.</li>
<li class="calibre15">Another way to have those two dates differ is to have the commit recreated while rebasing; by default, this keeps the author date and gets a new committer date (see <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>, the <em class="italic">Rebasing a branch</em> section, and <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>, the <em class="italic">An interactive </em><em class="italic">rebase</em> section).</li>
</ul>
<h3 class="calibre9">Matching commit contents</h3>
<p class="calibre3">If you want to filter <a id="_idIndexMarker355" class="pcalibre1 pcalibre calibre6"/>your commit history to only show those done by a specific author or committer, you can use the <code>--author</code> or <code>--committer</code> options, respectively. For example, let’s say you’re looking for all the commits in the Git source code authored by Linus. You could use something like <code>git log --author=Linus</code>. The search is, by default, case-sensitive, and uses <code>--author=^Linus</code>. Using <code>^</code> here means that the authorship information should start with <strong class="bold">Linus</strong>.</p>
<p class="calibre3">The <code>--grep</code> option lets you search commit messages (which should contain descriptions of the changes). Let’s say<a id="_idIndexMarker356" class="pcalibre1 pcalibre calibre6"/> that you want to find all the security bug fixes that mention <code>git </code><code>log --grep=CVE</code>.</p>
<p class="calibre3">If you specify both <code>--author</code> and <code>--grep</code> options, or more than one <code>--author</code> or <code>--grep</code> option, Git will show commits that match either query. In other words, Git would logically OR all the commit matching options. If you want to find commits that match all the queries, with matching options logically AND-ed, you need to use the <code>--</code><code>all-match</code> option.</p>
<p class="calibre3">There is also a set of options to <a id="_idIndexMarker357" class="pcalibre1 pcalibre calibre6"/>modify the meaning of matching patterns, similar to the ones used by the <code>grep</code> program. To make the search case-insensitive, use the <code>-i</code> / <code>--regexp-ignore-case</code> option. If you want to match simply a substring, you can use <code>-F</code> / <code>--fixed-strings</code> (you might want to do this to avoid having to escape regular expression metacharacters such as <code>.</code> and <code>?</code>). To write more powerful search terms, you can use <code>--extended-regexp</code> or <code>--perl-regexp</code> (you can use the latter only if Git was compiled and linked with the <code>--invert-grep</code>.</p>
<p class="calibre3">When walking reflogs with <code>git log -g</code> (see the <em class="italic">Reflog shortnames</em> section), you can use the <code>--grep-reflog=&lt;regexp&gt;</code> option to show only positions with the matching reflog entry. For example, to show all operations on <code>HEAD</code> that were not a simple commit operation, you can use the following:</p>
<pre class="console">
$ git log -g --invert-grep --grep-reflog="^commit:"</pre>
<h3 class="calibre9">Commit parents</h3>
<p class="calibre3">Git, by default, will follow all<a id="_idIndexMarker358" class="pcalibre1 pcalibre calibre6"/> the parents of each merge commit when walking down the ancestry chain. To make it follow only the first parent, you can use the aptly named <code>--first-parent</code> option. This would show you the main line of history (sometimes called the trunk), assuming that you follow the specific practices with respect to merging changes; you will learn more about this in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>, and <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<p class="calibre3">Consider the following command (this example uses the very nice <code>--graph</code> option that makes an ASCII-art diagram of the history):</p>
<pre class="console">
$ git log -5 --graph --oneline
* 50f84e3 Update draft release notes to 2.1
*   07768e0 Merge branch 'jc/shortlog-ref-exclude'
|\
| * eb07774 shortlog: allow --exclude=&lt;glob&gt; to be passed
* |   251cb96 Merge branch 'mn/sideband-no-ansi'
|\ \
| * | 38de156 sideband.c: do not use ANSI control sequence</pre>
<p class="calibre3">Compare it with this:</p>
<pre class="console">
$ git log -5 --graph --oneline --first-parent
* 50f84e3 Update draft release notes to 2.1
* 07768e0 Merge branch 'jc/shortlog-ref-exclude'
* 251cb96 Merge branch 'mn/sideband-no-ansi'
* d37e8c5 Merge branch 'rs/mailinfo-header-cmp'
* 53b4d83 Merge branch 'pb/trim-trailing-spaces'</pre>
<p class="calibre3">You can filter the list to <a id="_idIndexMarker359" class="pcalibre1 pcalibre calibre6"/>show only the merge commits or only the non-merge commits with the <code>--merges</code> and <code>--no-merges</code> options, respectively. These options can be considered simply shortcuts for more generic options: <code>--min-parents=&lt;number&gt;</code> (<code>--merges</code> is <code>--min-parents=2</code>) and <code>--max-parents=&lt;number&gt;</code> (<code>--no-merges</code> is <code>--max-parents=1</code>).</p>
<p class="calibre3">Let’s say that you want to find the starting point(s) of your project. You can do this with the help of <code>--max-parents=0</code>, which would give all the root commits:</p>
<pre class="console">
$ git log --max-parents=0 --oneline
0ca71b3 basic options parsing and whatnot.
16d6b8a Initial import of a python script...
cb07fc2 git-gui: Initial revision.
161332a first working version
1db95b0 Add initial version of gitk to the CVS repository
2744b23 Start of early patch applicator tools for git.
e83c516 Initial revision of "git", the information manage<a id="_idTextAnchor118" class="calibre13 pcalibre1 pcalibre"/>r from hell</pre>
<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor119" class="pcalibre1 pcalibre calibre6"/>Searching changes in revisions</h2>
<p class="calibre3">Sometimes, searching<a id="_idIndexMarker360" class="pcalibre1 pcalibre calibre6"/> through commit messages and other revision metadata is not enough. Perhaps descriptions of the changes were not detailed enough. Or, what if you are looking for a revision when a function was introduced, or where variable started to be used?</p>
<p class="calibre3">Git allows you to look through the changes that each revision brought (the difference between a commit and its parent). The faster <a id="_idIndexMarker361" class="pcalibre1 pcalibre calibre6"/>option is called a <strong class="bold">pickaxe</strong> search.</p>
<p class="calibre3">With the <code>-S&lt;string&gt;</code> option, Git will look for differences that introduce or remove an instance of a given string. Note that this is different from the string simply appearing in the diff output. You can do a match using a regular expression with the <code>--pickaxe-regex</code> option. Git checks each revision to see whether there are files whose <em class="italic">current</em> side and <em class="italic">parent</em> side have a different number of the specified string, and show the revisions that match.</p>
<p class="calibre3">As a side effect, <code>git log</code> with the <code>-S</code> option would also show the changes that each revision made (as if the <code>--patch</code> option were used), but only those differences that match the query. To show differences for all the files and also differences where the change in number occurred, you need to use the <code>--</code><code>pickaxe-all</code> option:</p>
<pre class="console">
$ git log -S'sub href'
commit 06a9d86b49b826562e2b12b5c7e831e20b8f7dce
Author: Martin Waitz &lt;tali@admingilde.org&gt;
Date:   Wed Aug 16 00:23:50 2006 +0200
    gitweb: provide function to format the URL for an action link.
    Provide a new function which can be used to generate an URL for the CGI.
    This makes it possible to consolidate the URL generation in order to make
    it easier to change the encoding of actions into URLs.
    Signed-off-by: Martin Waitz &lt;tali@admingilde.org&gt;
    Signed-off-by: Junio C Hamano &lt;junkio@cox.net&gt;</pre>
<p class="calibre3">With <code>-G&lt;regex&gt;</code>, Git <a id="_idIndexMarker362" class="pcalibre1 pcalibre calibre6"/>would literally look for differences whose added or removed line matches the given regular expression. Note that the unified diff format (that Git uses) considers the changed line to be a removal of the old version and adding of a new one; refer to <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em> (the <em class="italic">Examining the changes to be committed</em> section) for an explanation of how Git describes changes.</p>
<p class="calibre3">To illustrate the difference between <code>-S&lt;regex&gt; --pickaxe-regex</code> and <code>-G&lt;regex&gt;</code>, consider a commit with the following diff:</p>
<pre class="console">
     if (lstat(path, &amp;st))
-        return error("cannot stat '%s': %s", path,
+        ret = error("cannot stat '%s': %s", path,
                         strerror(errno));</pre>
<p class="calibre3">While <code>git log -G"error\("</code> will show this commit (because the query matches both changed lines), <code>git log -S"error\(" --pickaxe-regex</code> will not (because the number of occurrences of that string did not change).</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you are interested in a single file, it is easier to use <strong class="source-inline1">git blame</strong> (perhaps in a graphical blame browser, like with <strong class="source-inline1">git gui blame</strong>) to check when the given change was introduced. However, <strong class="source-inline1">git blame</strong> can’t be used to find a commit that deleted a line — you need a<a id="_idIndexMarker363" class="pcalibre1 pcalibre calibre6"/> pickaxe search for that.</p>
<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor120" class="pcalibre1 pcalibre calibre6"/>Selecting types of changes</h2>
<p class="calibre3">Sometimes, you might<a id="_idIndexMarker364" class="pcalibre1 pcalibre calibre6"/> want to see only those changes that added or renamed files. With Git, you can do this with <code>git log --diff-filter=AR</code>. You can select any combination of types of changes; see the <code>git-log(1)</code> manpage for details. For example, to find all renames while listing all changed files, you can use <code>--diff-filter=R*</code>, such as in the following example:</p>
<pre class="console">
$ git log --diff-filter=R* --oneline –stat
8b4dbde Rename random.js to gen_random.js
 index.html                           | 2 +-
 scripts/{random.js =&gt; gen_random.js} | 0
 2 files changed, 1 insertion(+), 1 deletion(-)
042a8af Directory structure
 index.html                     | 2 +-
 random.js =&gt; scripts/random.js | 0
 2 files changed, 1 insertion(+), 1 deletion(-)</pre>
<p class="calibre3">The mnemonics for types of changes are the same as those used by <code>git status --short</code> or <code>git </code><code>log --name-status</code>:</p>
<pre class="console">
$ git log -1 --diff-filter=R --oneline --name-status
8b4dbde Rename random.js to gen_random.js
R100    scripts/random.js       scripts/gen_random.js</pre>
<p class="calibre3">Next, we will examine how to search the history based on which files were changed, and later, also how to format the <code>git </code><code>log</code> output.</p>
<h1 id="_idParaDest-115" class="calibre5"><a id="_idTextAnchor121" class="pcalibre1 pcalibre calibre6"/>History of a file</h1>
<p class="calibre3">As described in the <em class="italic">Whole-tree commits</em> section <a id="_idIndexMarker365" class="pcalibre1 pcalibre calibre6"/>at the beginning of the previous chapter, Git revisions are about the state of the whole project as one single entity.</p>
<p class="calibre3">In many cases, especially with larger projects, we are interested only in the history of a single file, or the history limited to the changes in the given directory (in the given subsystem).</p>
<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor122" class="pcalibre1 pcalibre calibre6"/>Path limiting</h2>
<p class="calibre3">To examine the history of a single file, you can simply use <code>git log &lt;pathname&gt;</code>. Git will then only show all <a id="_idIndexMarker366" class="pcalibre1 pcalibre calibre6"/>those revisions that affected the given pathname (a file or a directory), which means those revisions where there was a change to the given file or a change to a file inside the given subdirectory.</p>
<p class="callout-heading">Disambiguation between branch names and path names</p>
<p class="callout">Git usually guesses what you mean<a id="_idIndexMarker367" class="pcalibre1 pcalibre calibre6"/> by writing <strong class="source-inline1">git log foo</strong>; did you mean to ask for the history of the <strong class="source-inline1">foo</strong> branch (the line of development), or for the history of the <strong class="source-inline1">foo</strong> file? However, sometimes, Git can get confused. To prevent confusion between pathnames and branch names, you can use <strong class="source-inline1">--</strong> (two dashes) to separate filename arguments from other options. Everything after <strong class="source-inline1">--</strong> would be taken to be a pathname, and everything before that would be taken to be the branch name or other option.</p>
<p class="callout">For example, writing <strong class="source-inline1">git log -- foo</strong> explicitly asks for the history of the <strong class="source-inline1">foo</strong> path.</p>
<p class="callout">One of the common situations where it is needed, besides when having the same name for a branch and a file, is when examining the <em class="italic">history of a deleted file</em> that is no longer present in a project.</p>
<p class="calibre3">You can specify more than one path; you can even look for changes that affect a given type of file with the help of wildcards (pattern match). For example, to find only changes to Perl scripts (files with the <code>*.pl</code> extension), you can use <code>git log -- '*.pl'</code>. Note that you need to protect the <code>*.pl</code> wildcard from being expanded by the shell before Git sees it — for example, via single quotes as shown here.</p>
<p class="callout-heading">Pathspec magic</p>
<p class="callout">Most commands that accept <strong class="source-inline1">&lt;path&gt;</strong> or <strong class="source-inline1">&lt;pathspec&gt;</strong> as a parameter, such as <strong class="source-inline1">git log</strong>, also support <strong class="bold">pathspec magic</strong>. A <a id="_idIndexMarker368" class="pcalibre1 pcalibre calibre6"/>pathspec that starts with a colon ‘<strong class="source-inline1">:</strong>’ has a special meaning: it is expected that this colon is then followed by either one or more <em class="italic">magic signature</em> letters, or a comma-separated list of zero or more <em class="italic">magic words</em>. An optional colon ‘<strong class="source-inline1">:</strong>’ can be used to separate the magics from the pattern to match them. Here are a few examples: <strong class="source-inline1">:(top):data/</strong> or <strong class="source-inline1">:/data/</strong> would make the pattern match the data/directory at the top directory of the repository, regardless of where we are inside the repository (the current directory). The <strong class="source-inline1">git log :(exclude):*.html</strong> or <strong class="source-inline1">git log :^*.html</strong> command will list all revisions where there was at least one change to the file that is not an HTML file. You can find more magics in the <strong class="source-inline1">gitglossary(7)</strong> manpage, in the <strong class="source-inline1">pathspec</strong> entry.</p>
<p class="calibre3">However, because <a id="_idIndexMarker369" class="pcalibre1 pcalibre calibre6"/>Git uses pathname parameters as <em class="italic">limiters</em> in showing the history of a project, querying for the history of a single file doesn’t automatically <em class="italic">follow renames</em>. You need to use <code>git log --follow &lt;file&gt;</code> to continue listing the history of a file beyond renames. Unfortunately, it doesn’t work in all cases. Sometimes, you need to use either the <code>git blame</code> command (see the <em class="italic">Blame – the line-wise history of a file</em> section), or examine the boundary commits with rename detection turned on (<code>git show -M -C --raw --abbrev &lt;rev&gt;</code>) and follow renames and file moving manually.</p>
<p class="calibre3">In modern Git, you can also trace <em class="italic">the evolution of the line range</em> within the file using <code>git log -L</code>, which is currently limited to the walk starting from a single revision (zero or one positive revision argument) and a single file. The range is given either denoting the start and end of the range with <code>-L &lt;start&gt;,&lt;end&gt;:&lt;file&gt;</code> (where either <code>&lt;start&gt;</code> or <code>&lt;end&gt;</code> can be a line number or a <code>/regexp/</code>), or a function to track with <code>-L :&lt;funcname regexp&gt;:&lt;file&gt;</code>. This technique cannot, however, be used together with the ordinary pathspec-based path limiting. For example, to see the history of the <code>index.html</code> file, limited to the changes in the <code>&lt;head&gt;</code> element, you can use the following command:</p>
<pre class="console">
$ git log -L '/^&lt;head&gt;/','/^&lt;\/head&gt;/':index.html</pre>
<h2 id="_idParaDest-117" class="calibre7"><a id="_idTextAnchor123" class="pcalibre1 pcalibre calibre6"/>History simplification</h2>
<p class="calibre3">By default, when<a id="_idIndexMarker370" class="pcalibre1 pcalibre calibre6"/> requested for the history of a path, Git would <em class="italic">simplify the history</em>, showing only those commits that are required (that are enough) to explain how the files that match the specified paths came to be. Git would exclude those revisions that do not change the given file. Additionally, for non-excluded merge commits, Git would exclude those parents that do not change the file (thus excluding lines of development).</p>
<p class="calibre3">You can control this kind <a id="_idIndexMarker371" class="pcalibre1 pcalibre calibre6"/>of history simplification with the <code>git log</code> options such as <code>--full-history</code> or <code>--simplify-merges</code>. Check the Git documentation for more details, such as the <em class="italic">History simplification</em> section in the <code>git-log(1)</code> manpage.</p>
<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor124" class="pcalibre1 pcalibre calibre6"/>Blame — the line-wise history of a file</h2>
<p class="calibre3">The <code>git blame</code> annotates each line with appropriate line-authorship information.</p>
<p class="calibre3">Git can start annotating from the given revision (useful when browsing the history of a file or examining how an older version of a file came to be), or even limit the search to a given revision range. You can also limit the range of lines annotated to make blame faster — for example, to check only the history of an <code>esc_html</code> function, you can use the following:</p>
<pre class="console">
$ git blame -L '/^sub esc_html {/,/}/' gitweb/gitweb.perl</pre>
<p class="calibre3">What makes the blame operation so useful is that it <em class="italic">follows the history</em> of a file across whole-file renames. It can optionally follow lines that were moved from one file to another (with the <code>-M</code> option), and even follow lines that were copied and pasted from another file (with the <code>-C</code> option); this includes internal code movement.</p>
<p class="calibre3">When following code movement, it is useful to ignore changes in whitespace to find when a given fragment of code was truly introduced and avoid finding when it was just re-indented (for example, due to refactoring repeated code into a function — code movement). This can be done by passing the <a id="_idIndexMarker374" class="pcalibre1 pcalibre calibre6"/>diff-formatting option, <code>–w</code> / <code>--</code><code>ignore-all-space</code>.</p>
<p class="callout-heading">Rename detection</p>
<p class="callout">A good version control system should be able to deal with renaming files and other ways of changing the directory structure of a project. There are two ways to deal with this problem. The first is <strong class="bold">rename tracking</strong>, which means<a id="_idIndexMarker375" class="pcalibre1 pcalibre calibre6"/> that the information about the fact that a file was renamed is saved at the commit time; the version control systems mark renames. This usually requires using the <strong class="source-inline1">rename</strong> and <strong class="source-inline1">move</strong> commands to rename files. For example, you cannot use a file manager that is not version-control aware to move files. However, you can detect the rename when <a id="_idIndexMarker376" class="pcalibre1 pcalibre calibre6"/>creating the revision." It can involve some kind of <strong class="bold">file identity</strong> surviving across renames.</p>
<p class="callout">The second method, and the <a id="_idIndexMarker377" class="pcalibre1 pcalibre calibre6"/>one used by Git, is <strong class="bold">rename detection</strong>. In this case, the <strong class="source-inline1">mv</strong> command is only a shortcut for deleting a file with the old name and adding a file with the same contents and a new name. Rename detection means that the fact that the file was renamed is detected at the time it is needed: when doing a merge, when viewing the line-wise history of a file (if requested), or when showing a diff (if requested or<a id="_idIndexMarker378" class="pcalibre1 pcalibre calibre6"/> configured). This has the advantage that the rename detection algorithm can be improved and is not frozen at the time of commit. It is a more generic solution, allowing it to handle not only the whole-file renames but also the code movement and copying within a single file and across different files, as can be seen in the description of <strong class="source-inline1">git blame</strong>.</p>
<p class="callout">The disadvantage of rename detection, which in Git is based on the heuristic of the similarity of the file contents and the pathname, is that it takes resources to run and that in rare cases, it can fail: not detecting renames, or detecting a rename where there isn’t one.</p>
<p class="callout">Note that, in modern Git, basic rename detection is turned on for diffs by default.</p>
<p class="calibre3">Many graphical interfaces for Git include a graphical version of the blame operation. The <code>git gui blame</code> is an example of such a graphical interface for the blame operation (it is a part of <code>git gui</code>, a Tcl/Tk-based graphical interface). Such graphical interfaces can show the full description of changes and simultaneously show the history with and without considering renames. From such a GUI, it is usually possible to go to a specified commit, browsing the history of the<a id="_idIndexMarker379" class="pcalibre1 pcalibre calibre6"/> lines of a file interactively. In addition, the GUI blame tool makes it very easy to follow files across renames:</p>
<div><div><img alt="Figure 5.1 – ﻿'git gui blame' in action, showing the detection of copying or moving fragments of code" src="img/B21194_05_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – 'git gui blame' in action, showing the detection of copying or moving fragments of code</p>
<h1 id="_idParaDest-119" class="calibre5"><a id="_idTextAnchor125" class="pcalibre1 pcalibre calibre6"/>Finding bugs with git bisect</h1>
<p class="calibre3">Git provides a couple <a id="_idIndexMarker380" class="pcalibre1 pcalibre calibre6"/>of tools to help you debug issues in your projects. These tools can be extremely useful, especially in the case of a software regression — that is, a software bug that makes a feature stop functioning as intended after a certain revision. If you don’t know where the bug can be, and there have been dozens or hundreds of commits since the last state where you know the code worked, you’ll likely turn to <code>git bisect</code> for help.</p>
<p class="calibre3">The <strong class="bold">bisect</strong> command searches <a id="_idIndexMarker381" class="pcalibre1 pcalibre calibre6"/>semi-automatically, step by step, through project history, trying to find the revision that introduced the bug. In each step, it bisects the history into roughly equal parts<a id="_idIndexMarker382" class="pcalibre1 pcalibre calibre6"/> and asks whether there is a bug in the dividing commit. It then uses the answer to eliminate one of the two sections and reduces the size of the revision range where there can be a commit that introduced the bug:</p>
<div><div><img alt="Figure 5.2 –  An example of git bisect in action, finding the buggy commit after ﻿4 steps" src="img/B21194_05_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 –  An example of git bisect in action, finding the buggy commit after 4 steps</p>
<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor126" class="pcalibre1 pcalibre calibre6"/>Starting the git bisect process</h2>
<p class="calibre3">Suppose version 1.14 of your project <a id="_idIndexMarker383" class="pcalibre1 pcalibre calibre6"/>worked, but the release candidate for the new version, 1.15-rc0, crashes. You go back to the 1.15-rc0 version, and it turns out you can <em class="italic">reproduce the issue</em> (this is very important!), but you can’t figure out what is going wrong.</p>
<p class="calibre3">You can bisect the code history to find out. You need to start the bisection process with <code>git bisect start</code>, and then tell Git which version is broken with <code>git bisect bad</code>. Then, you must tell the bisect process the last known good state (or set of states) with <code>git </code><code>bisect good</code>:</p>
<pre class="console">
$ git bisect start
$ git bisect bad  v1.15-rc0
$ git bisect good v1.14
Bisecting: 159 revisions left to test after this (roughly 7 steps)
[7ea60c15cc98ab586aea77c256934acd438c7f95] Merge branch 'mergetool'</pre>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor127" class="pcalibre1 pcalibre calibre6"/>Finding the buggy commit</h2>
<p class="calibre3">Git figured out that about 300 commits <a id="_idIndexMarker384" class="pcalibre1 pcalibre calibre6"/>came between the commit you marked as the last good commit (<code>v1.14</code>) and the bad version (<code>v1.15-rc0</code>), and checked out the<a id="_idIndexMarker385" class="pcalibre1 pcalibre calibre6"/> middle one (<code>7ea60c15</code>) for you. If you run <code>git branch</code> or <code>git status</code> at this point, you’ll see that git has temporarily moved you to <code>(</code><code>no branch)</code>:</p>
<pre class="console">
$ git branch
* (no branch, bisect started on master)
  master
$ git status
HEAD detached at 7ea60c15cc
You are currently bisecting, started from branch 'master'.
  (use "git bisect reset" to get back to the original branch)</pre>
<p class="calibre3">At this point, you need to run your test to check whether the issue is present in the commit currently checked out by the bisect operation. If the program crashes, mark the current commit as bad with <code>git bisect bad</code>. If the issue is not present, mark it as correct with <code>git bisect good</code>. After about seven steps, Git would show the suspect commit:</p>
<pre class="console">
$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800
    secure this thing
:040000 040000 40ee3e7… f24d3c6… M  config</pre>
<p class="calibre3">The last line in the preceding example output is in the so-called <em class="italic">raw</em> diff output, showing which files changed in a commit. You can then examine the suspected commit with <code>git show</code>. From there, you can find the author of the said commit, and ask them for clarification or ask them to fix it (by sending them a bug report). If the good practice of creating small, incremental <a id="_idIndexMarker386" class="pcalibre1 pcalibre calibre6"/>changes was followed during the development of the project, the amount of code to examine after finding the bad commit <a id="_idIndexMarker387" class="pcalibre1 pcalibre calibre6"/>should be small.</p>
<p class="calibre3">If, at any point, you land on a commit that broke something unrelated and is not a good one to test, you can skip such a commit with <code>git bisect skip</code>. You can even skip a range of commits by giving the revision range to the <code>skip</code> subcommand.</p>
<p class="calibre3">When you’re finished, you should run <code>git bisect reset</code> to return you to the branch you started from:</p>
<pre class="console">
$ git bisect reset
Previous HEAD position was b047b02... secure this thing
Switched to branch 'master'</pre>
<p class="calibre3">To finish bisection while staying on the bad commit you found, you can use <code>git bisect </code><code>reset HEAD</code>.</p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor128" class="pcalibre1 pcalibre calibre6"/>Automating testing during the git bisect process</h2>
<p class="calibre3">You can even fully automate <a id="_idIndexMarker388" class="pcalibre1 pcalibre calibre6"/>finding bad revisions with <code>git bisect run</code>. For this, you need to have a script that will test for the presence of a bug and exit with a value of 0 if the project works all right, or a non-0 value if there is a bug. The special exit code, <code>125</code>, should be used when the currently checked-out code cannot be tested. In this case, you also start the <code>bisect</code> operation by providing the known bad and good commits. You can do this by simply listing them with the <code>bisect start</code> command if you want, listing the known bad commit first and the known good commit(s) second. You can even cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters (the double-dash before the path is not strictly necessary, but is helpful). Then, you start automated bisection:</p>
<pre class="console">
$ git bisect start v1.5-rc0 v1.4 -- arch/i386
$ git bisect run ./test-error.sh</pre>
<p class="calibre3">Doing so automatically runs <code>test-error.sh</code> on each checked-out commit until Git finds the first broken<a id="_idIndexMarker389" class="pcalibre1 pcalibre calibre6"/> commit.</p>
<p class="calibre3">If the bug is that the project stopped compiling (a broken build), you can use <code>make</code> as a test script (with <code>git bisect </code><code>run make</code>).</p>
<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor129" class="pcalibre1 pcalibre calibre6"/>Selecting and formatting the git log output</h1>
<p class="calibre3">Now that you know how to select revisions to examine and limit which revisions are shown (selecting those <a id="_idIndexMarker390" class="pcalibre1 pcalibre calibre6"/>that are interesting), it is time to see how to select which part of the<a id="_idIndexMarker391" class="pcalibre1 pcalibre calibre6"/> information is associated with the queried revisions to show, and how to format this output. There is a huge number and variety of options for the <code>git log</code> command available for this.</p>
<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor130" class="pcalibre1 pcalibre calibre6"/>Predefined and user-defined output formats</h2>
<p class="calibre3">A very useful <code>git log</code> option is <code>--pretty</code>. This option changes the format of the log output. There are a few prebuilt <a id="_idIndexMarker392" class="pcalibre1 pcalibre calibre6"/>formats available for you to use. The <code>oneline</code> format prints each commit on a single line, which is useful if you’re looking at a lot<a id="_idIndexMarker393" class="pcalibre1 pcalibre calibre6"/> of commits; there exists the <code>--oneline</code> shorthand for <code>--pretty=oneline --abbrev-commit</code> used together. In addition, the <code>short</code>, <code>medium</code> (the default), <code>full</code>, and <code>fuller</code> formats show the output in roughly the same format, but with less or more information, respectively. The <code>raw</code> format shows commits in internal Git representation, and <code>email</code> or <code>mboxrd</code> in a <code>git format-patch</code>-like format, as an email. The <code>reference</code> format is intended to refer to another commit in a commit message, per the following example:</p>
<pre class="console">
$ git show --no-patch --pretty=reference master^
20cfc7c (Added COPYRIGHT, 2021-05-30)</pre>
<p class="calibre3">It is possible to change the format of dates shown in those verbose, pretty formats with an appropriate <code>--date</code> option: make Git show relative dates such as, for example, <code>--date=relative</code>, dates in your local time zone with <code>--date=local</code>, and so on.</p>
<p class="calibre3">You can also specify your own log output format with <code>--pretty=format:&lt;string&gt;</code> (and its <code>tformat</code> variant, with terminator rather than separator semantics — output for each commit has the newline appended). This is especially useful when<a id="_idIndexMarker394" class="pcalibre1 pcalibre calibre6"/> you’re generating output for machine parsing for <a id="_idIndexMarker395" class="pcalibre1 pcalibre calibre6"/>use in scripts because when you specify the format explicitly, you know it won’t change with updates to Git. The format string works a little bit like in <code>printf</code>:</p>
<pre class="console">
$ git log --pretty="%h - %an, %ar : %s"
50f84e3 - Junio C Hamano, 7 days ago : Update draft release notes
0953113 - Junio C Hamano, 10 days ago : Second batch for 2.1
afa53fe - Nick Alcock, 2 weeks ago : t5538: move http push tests out</pre>
<p class="calibre3">There is a very large number of placeholders. Selected ones of those are listed in the following table:</p>
<table class="no-table-style" id="table001-3">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre17">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Placeholder</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Description </strong><strong class="bold">of output</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%H</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Commit hash (full SHA-1 identifier of revision)</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%h</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Abbreviated commit hash</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%</code><code>an</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Author name</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%</code><code>ae</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Author email</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%</code><code>ar</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Author date, relative</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%</code><code>cn</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Committer name</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%</code><code>ce</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Committer email</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%</code><code>cr</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Committer date, relative</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%s</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">Subject (first line of a commit message, describing revision)</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>%%</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3">A raw <code>%</code></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 5.1 – Placeholders and their description</p>
<p class="callout-heading">Author versus committer</p>
<p class="callout">The <strong class="bold">author</strong> is the person who originally wrote the patch (authored the changes), whereas the <strong class="bold">committer</strong> is the<a id="_idIndexMarker396" class="pcalibre1 pcalibre calibre6"/> person who last applied the patch (created a commit object with those changes, representing the revision in the DAG). So, if you send in a patch to a<a id="_idIndexMarker397" class="pcalibre1 pcalibre calibre6"/> project and one of the core members applies the patch, both of you get credit — you as the author and the core member as the committer. Also, after rebase, for rebased revisions the original author of the commit is kept, while the person performing the rebase is made the committer.</p>
<p class="calibre3">The <code>--oneline</code> format option is <a id="_idIndexMarker398" class="pcalibre1 pcalibre calibre6"/>especially useful together with another <code>git log</code> option called <code>--graph</code>, though the latter can be used with any format. The latter option adds a nice little ASCII graph showing your branch and merge <a id="_idIndexMarker399" class="pcalibre1 pcalibre calibre6"/>history. To see where tags and branches are, you can use an option named <code>--decorate</code> (which in modern Git is now the default):</p>
<pre class="console">
$ git log --graph --decorate --oneline origin/maint
*   bce14aa (origin/maint) Sync with 1.9.4
|\
| * 34d5217 (tag: v1.9.4) Git 1.9.4
| *   12188a8 Merge branch 'rh/prompt' into maint
| |\
| * \   64d8c31 Merge branch 'mw/symlinks' into maint
| |\ \
* | | | d717282 t5537: re-drop http tests
* | | | e156455 (tag: v2.0.0) Git 2.0</pre>
<p class="calibre3">You might want to use a graphical tool to<a id="_idIndexMarker400" class="pcalibre1 pcalibre calibre6"/> visualize your commit history. One such tool is a Tcl/Tk program<a id="_idIndexMarker401" class="pcalibre1 pcalibre calibre6"/> called <code>gitk</code> that is distributed with Git. You can find more information about various types of graphical tools in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git</em>.</p>
<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor131" class="pcalibre1 pcalibre calibre6"/>Including, formatting, and summing up changes</h2>
<p class="calibre3">You can examine a<a id="_idIndexMarker402" class="pcalibre1 pcalibre calibre6"/> single revision with the <code>git show</code> command, which, in addition to the commit metadata, shows changes in the unified diff format, described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>, in the <em class="italic">Unified Git diff format</em> subsection. Sometimes, however, you might want to display changes alongside the selected part of the <a id="_idIndexMarker403" class="pcalibre1 pcalibre calibre6"/>history in the <code>git log</code> output. You can do this with the help of the <code>-p</code> option. This is very helpful for code review, or to quickly browse <a id="_idIndexMarker404" class="pcalibre1 pcalibre calibre6"/>what happened during a series of commits that a collaborator has added.</p>
<p class="calibre3">Ordinarily, Git would not show the changes for a merge commit. To show changes from all parents, you need to use the <code>–c</code> option (or <code>–cc</code> for compressed output), while to show changes from each parent individually, use <code>–m</code>.</p>
<p class="calibre3">Sometimes, it’s easier to review changes on the word level rather than on the line level. The <code>git log</code> accepts various options to change the format of the diff output. One of those options is <code>--word-diff</code> (with <a id="_idIndexMarker405" class="pcalibre1 pcalibre calibre6"/>various variants, including <code>color</code>). This way of viewing differences is useful for examining changes in documents (for example, documentation):</p>
<pre class="console">
commit 06ab60c06606613f238f3154cb27cb22d9723967
Author: Jason St. John &lt;jstjohn@purdue.edu&gt;
Date:   Wed May 21 14:52:26 2014 -0400
    Documentation: use "command-line" when used as a compound adjective, and fix
    Signed-off-by: Jason St. John &lt;jstjohn@purdue.edu&gt;
    Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
diff --git a/Documentation/config.txt b/Documentation/config.txt
index 1932e9b..553b300 100644
--- a/Documentation/config.txt
+++ b/Documentation/config.txt
@@ -381,7 +381,7
        Set the path to the root of the working tree.
        This can be overridden by the GIT_WORK_TREE environment
        variable and the '--work-tree' [-command line-]{+command-line+} option.
        The value can be an absolute path or relative to the path to
       the .git directory, which is either specified by --git-dir
        or GIT_DIR, or automatically discovered.</pre>
<p class="calibre3">Another useful set of options is about ignoring changes in whitespace, including <code>–w</code> / <code>--ignore-all-space</code> to ignore all<a id="_idIndexMarker406" class="pcalibre1 pcalibre calibre6"/> whitespace changes, and <code>-b</code> / <code>--ignore-space-change</code> to ignore <a id="_idIndexMarker407" class="pcalibre1 pcalibre calibre6"/>changes in the amount of whitespace.</p>
<p class="calibre3">With color support, you can<a id="_idIndexMarker408" class="pcalibre1 pcalibre calibre6"/> ask Git to show moved code with <code>--color-moved</code>, possibly ignoring whitespace changes (with <code>--color-moved-ws</code>).</p>
<p class="calibre3">Sometimes, you are interested only in the summary of changes and not the details. There is a series of <code>diff</code> summarizing options that you can use. If you want to know only which files changed, use <code>--names-only</code> (or <code>--raw --abbrev</code>). If you also want to know how much those files changed, you can use the <code>--stat</code> option (or perhaps its machine-parse-friendly version, <code>--numstat</code>) to see some abbreviated stats. If you are interested only in a short summary of changes, use <code>--shortstat</code> or <code>--summary</code>.</p>
<h2 id="_idParaDest-126" class="calibre7"><a id="_idTextAnchor132" class="pcalibre1 pcalibre calibre6"/>Summarizing contributions</h2>
<p class="calibre3">Ever wondered how <a id="_idIndexMarker409" class="pcalibre1 pcalibre calibre6"/>many commits you’ve contributed to a project? Or, perhaps, who the most active developer was during the last month (with respect to the number of commits)? Well, wonder no more, because this is what <code>git shortlog</code> is good for:</p>
<pre class="console">
$ git shortlog -s -n
 13885  Junio C Hamano
  1399  Shawn O. Pearce
  1384  Jeff King
  1108  Linus Torvalds
   743  Jonathan Nieder</pre>
<p class="calibre3">The <code>-s</code> option squashes all of the commit messages into the number of commits; without it, <code>git shortlog</code> would list a summary of all the commits, grouped by the developer. The <code>-n</code> option sorts the list of developers by the number of commits; otherwise, it is sorted alphabetically. You can add an <code>–e</code> option to also show an email address; note, however, that with this option, Git will separate contributions made by the same author under different emails. The <code>git shortlog</code> output can be configured to some extent with a pretty-like <code>--</code><code>format</code> option.</p>
<p class="calibre3">The <code>git shortlog</code> command accepts a revision range and other revision-limiting options such as <code>--since=1.month.ago</code> — anything that <code>git log</code> accepts and makes sense for <code>shortlog</code>. For <a id="_idIndexMarker410" class="pcalibre1 pcalibre calibre6"/>example, to see who contributed what to the last release candidate, you can use the following command:</p>
<pre class="console">
$ git shortlog -e v2.0.0-rc2..v2.0.0-rc3
Jonathan Nieder &lt;jrnieder@gmail.com&gt; (1):
      shell doc: remove stray "+" in example
Junio C Hamano &lt;gitster@pobox.com&gt; (14):
      Merge branch 'cl/p4-use-diff-tree'
      Update draft release notes for 2.0
      Merge branch 'km/avoid-cp-a' into maint
…</pre>
<p class="callout-heading">Tip</p>
<p class="callout">One needs to remember that the number of revisions authored is only one way of measuring contribution. For example, somebody who creates buggy commits only to fix them later would have a larger number of commits than a developer who doesn’t make mistakes (or cleans the history before publishing changes).</p>
<p class="callout">There are other measures<a id="_idIndexMarker411" class="pcalibre1 pcalibre calibre6"/> of programmer productivity — for example, the number of changed lines in authored commits, or the number of surviving lines. Those can be calculated with the help of Git, but there is no built-in command to calculate them.</p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor133" class="pcalibre1 pcalibre calibre6"/>Mapping authors</h2>
<p class="calibre3">One problem with running <code>git shortlog –s -n -e</code> or <code>git blame</code> in Git repositories of long-running <a id="_idIndexMarker412" class="pcalibre1 pcalibre calibre6"/>projects is that an author may change their name or email, or both, during the course of the project, due to many reasons: changing work (and work email), misconfiguration, spelling mistakes, and others. For example, you might have <code>.mailmap</code> file in the top directory of your project. This file allows you to specify <em class="italic">canonical</em> names for contributors, which in its simplest form looks like this:</p>
<pre class="source-code">
Bob Hacker &lt;bob@example.com&gt;</pre>
<p class="calibre3">(Actually, it allows you to specify a canonical name, canonical email, or both name and email, matching by email or by name and email.)</p>
<p class="calibre3">By default, those corrections are applied to all commands: <code>git blame</code>, <code>git shortlog</code>, and <code>git log</code>. With custom <code>log</code> output, you can use placeholders that output the original name or <a id="_idIndexMarker413" class="pcalibre1 pcalibre calibre6"/>corrected name, and the original email or corrected email.</p>
<h2 id="_idParaDest-128" class="calibre7"><a id="_idTextAnchor134" class="pcalibre1 pcalibre calibre6"/>Viewing a revision and a file at revision</h2>
<p class="calibre3">Sometimes, you<a id="_idIndexMarker414" class="pcalibre1 pcalibre calibre6"/> might want to examine a single revision (for example, a commit suspected to be buggy, found with <code>git bisect</code>) in more detail, together with changes <a id="_idIndexMarker415" class="pcalibre1 pcalibre calibre6"/>and their descriptions. Or, perhaps, you want to examine the tag message of an annotated tag together with the commit it points to. Git provides a generic <code>git show</code> command for this; it can be used for any type of object.</p>
<p class="calibre3">For example, to examine the grandparent of the current version, you can use the following command:</p>
<pre class="console">
$ git show HEAD^^
commit ca3cdd6bb3fcd0c162a690d5383bdb8e8144b0d2
Author: Bob Hacker &lt;bob@virtech.com&gt;
Date:   Sun Jun 1 02:36:32 2014 +0200
    Added COPYRIGHT
diff --git a/COPYRIGHT b/COPYRIGHT
new file mode 100644
index 0000000..862aafd
--- /dev/null
+++ b/COPYRIGHT
@@ -0,0 +1,2 @@
+Copyright (c) 2014 VirTech Inc.
+All Rights Reserved</pre>
<p class="calibre3">The <code>git show</code> command can also be used to display directories (trees) and file contents (blobs). To view a file (or a directory), you need to specify where it is from (from which revision) and<a id="_idIndexMarker416" class="pcalibre1 pcalibre calibre6"/> the path to the file, using <code>:</code> to connect them. For example, to view the contents of the <code>src/rand.c</code> file as it was in the version tagged <code>v0.1</code>, use the following:</p>
<pre class="console">
$ git show v0.1:src/rand.c</pre>
<p class="calibre3">This might be more convenient than checking out the required version of the file into the working directory with <code>git checkout v0.1 -- src/rand.c</code>. Before the colon may be anything that names a commit (<code>v0.1</code> here), and after that, it may be any path to a file tracked by Git (<code>src/rand.c</code> here). The pathname here is the full path from the top of the project directory, but you can use <code>./</code> after the colon for relative paths — for example, <code>v0.1:./rand.c</code> if you are in the <code>src/</code> subdirectory.</p>
<p class="calibre3">You can use the same trick to compare arbitrary files at arbitrary revisions; on the other hand, the <code>git show :src/rand.c</code> command (as if with an empty revision) will show the state of the file at the time <code>git add</code> was run — the state of the chosen file in the index (in the staging area).</p>
<p class="calibre3">If you want to find out <a id="_idIndexMarker417" class="pcalibre1 pcalibre calibre6"/>what files are present at a given revision (to select one to examine), you can use <code>git ls-tree &lt;revision&gt;</code>. To find out what files are present in the worktree and in the index, use <code>git ls-files</code> with the appropriate option to select what you want to see.</p>
<h1 id="_idParaDest-129" class="calibre5"><a id="_idTextAnchor135" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter showed us the various ways of exploring project history: selecting and filtering revisions to display, searching through various parts of commit-related data, and formatting the output.</p>
<p class="calibre3">You have learned how to find all the revisions that were made by a given developer, how to search through the commit message and the changes made by the commit, and how to narrow the search to a specific range of time.</p>
<p class="calibre3">We can even try to find bugs in the code by exploring the history: finding when a function was deleted from the code with a <em class="italic">pickaxe search</em>, examining a file for how its code came to be and who wrote it with <code>git blame</code>, and utilizing semi-automatic or automatic search through the project history to find which version introduced a regression with <code>git bisect</code>.</p>
<p class="calibre3">When examining a revision, we can select the format in which the information is shown, even to the point of user-defined formats. There are various ways of summarizing the information, from the statistics of the changed files, to the statistics of the number of commits per author.</p>
<p class="calibre3">In the next chapter, we will examine how Git can help developers work together as a team on a single project.</p>
<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor136" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">How would you list all commits made since yesterday on any remote-tracking branch?</li>
<li class="calibre15">How would you find out who the original author of a given function or class was, to ask for clarification or a code review?</li>
<li class="calibre15">How would you use Git to help find the source of regression — that is, a bug that is present in the new revision of the project, but was not there in older versions?</li>
<li class="calibre15">You have noticed that your colleague made a few commits with a misconfigured email, using <strong class="source-inline1">bob@laptop.company.com</strong> instead of <strong class="source-inline1">bob@company.com</strong>. How would you fix the attribution, assuming that it is not possible to rewrite those commits?</li>
</ol>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor137" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li class="calibre15">Combine time-limiting options with the <strong class="source-inline1">--</strong><strong class="source-inline1">remotes</strong> option:</li>
<li class="calibre15"><strong class="source-inline1">git log --</strong><strong class="source-inline1">since=yesterday --remotes</strong>.</li>
<li class="calibre15">Use the <strong class="source-inline1">git blame</strong> command or an interactive GUI to do this, such as <strong class="source-inline1">git gui blame</strong> (or an integration with your editor or <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>); you can also search through the history of the relevant fragment of a file with <strong class="source-inline1">git </strong><strong class="source-inline1">log -L</strong>.</li>
<li class="calibre15">Use <strong class="source-inline1">git bisect</strong> to find the commit that introduced the bug, perhaps even by automating the search with <strong class="source-inline1">git </strong><strong class="source-inline1">bisect run</strong>.</li>
<li class="calibre15">Add the correct name and email to the <strong class="source-inline1">.</strong><strong class="source-inline1">mailmap</strong> file.</li>
</ol>
<h1 id="_idParaDest-132" class="calibre5"><a id="_idTextAnchor138" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon, Ben Straub, <em class="italic">Pro Git</em>, 2nd Edition (2014), Apress, <em class="italic">Chapter 7</em><em class="italic">.5 Git Tools – </em><em class="italic">Searching</em>: <a href="https://git-scm.com/book/en/v2/Git-Tools-Searching" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2/Git-Tools-Searching</a></li>
<li class="calibre15">Christian Couder, <em class="italic">Fighting regressions with git bisect </em>(slides from the Linux-Kongress 2009 conference): <a href="http://www.linux-kongress.org/2009/slides/fighting_regressions_with_git_bisect_christian_couder.pdf" class="pcalibre1 pcalibre calibre6">http://www.linux-kongress.org/2009/slides/fighting_regressions_with_git_bisect_christian_couder.pdf</a></li>
<li class="calibre15">Junio C Hamano, <em class="italic">Fun with first parent history</em> (2013): <a href="https://git-blame.blogspot.com/2013/09/fun-with-first-parent-history.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2013/09/fun-with-first-parent-history.html</a></li>
<li class="calibre15">Junio C Hamano, <em class="italic">Measuring Project Activities (2)</em> (2013): <a href="https://git-blame.blogspot.com/2013/03/measuring-project-activities-2.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2013/03/measuring-project-activities-2.html</a></li>
<li class="calibre15">Jan Goyvaerts, <em class="italic">Regular Expressions Tutorial - Learn How to Use and Get The Most out of Regular </em><em class="italic">Expressions</em>: <a href="https://www.regular-expressions.info/tutorial.html" class="pcalibre1 pcalibre calibre6">https://www.regular-expressions.info/tutorial.html</a></li>
</ul>
</div>
</body></html>