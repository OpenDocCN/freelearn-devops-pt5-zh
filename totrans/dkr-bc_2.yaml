- en: Chapter 2. Launching Applications Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to be looking at launching more than just a simple
    web server using our local Docker installation. We will look at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker on the command-line to launch applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Docker `build` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose to make multi-container applications easier to launch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then look at using all the techniques above to launch a WordPress and
    Drupal application stack.
  prefs: []
  type: TYPE_NORMAL
- en: Docker terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start learning how to launch containers, we should quickly discuss
    some of the more common terminology we are going to be using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note, the Docker commands in this chapter have been written for use with
    Docker 1.13 and later. Trying to run commands such as `docker image pull nginx`
    in older versions will fail with an error. Please refer to [Chapter 1](ch01.html
    "Chapter 1. Installing Docker Locally"), *Installing Docker Locally* for details
    on how to install the latest version of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker image** is a collection of all the files that make up an executable
    software application. This collection includes the application plus all the libraries,
    binaries, and other dependencies such as deployment descriptors and so on. just
    needed just to run the application everywhere without any hitch or hurdle. These
    files in the Docker image are read-only and hence the content of the image cannot
    be altered. If you choose to alter the content of your image, the only option
    Docker allows is to add another layer with the new changes. In other words, a
    Docker image is made up of layers which you can review using `docker image history`
    subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker image architecture effectively leverages this layering concept to
    seamlessly add additional capabilities to the existing images to meet the varying
    business requirements and increase the reuse of images. In other words, capabilities
    can be added to existing images by adding additional layers on top of that image
    and deriving a new image. The Docker images have a parent/child relationship and
    the bottom-most image is called the **base image**. The base image is the special
    image that doesn''t have any parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker images](img/B06455_02_01A.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous diagram, Ubuntu is a base image and it does not have any parent
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ubuntu Docker image is a minimalist bundle of software libraries and binaries
    that are critical to run an application. It does not include Linux Kernel, Diver
    Drivers, and various other services a full-fledged Ubuntu operating system would
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker images](img/B06455_02_01B.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the above diagram, everything starts with a base image and
    here in this example, it is Ubuntu. Further on, the `wget` capability is added
    to the image as a layer and the `wget` image is referencing Ubuntu image as its
    parent. And in the next layer, an instance of Tomcat application server is added
    and it refers the `wget` image as its parent. Each addition that is made to the
    original base image is stored in a separate layer (a kind of hierarchy gets generated
    here to retain the original identity).
  prefs: []
  type: TYPE_NORMAL
- en: Precisely speaking, any Docker image has to originate from a base image and
    an image gets continuously enriched in its functionality by getting fresh modules
    and this is accomplished by adding an additional module as a new layer on the
    existing Docker image one by one as vividly illustrated in the above diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker platform provides a simple way of building new images or extending
    existing images. You can also download the Docker images that the other people
    have already created and deposited in Docker image repositories (private or public).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker Registry** is a place where Docker images can be stored in order
    to be publicly or privately found, accessed, and used by worldwide software developers
    for quickly crafting fresh and composite applications without any risks. Because,
    all the stored images will have gone through multiple validations, verifications,
    and refinements, the quality of those images are really high.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `dockerimage push` subcommand, you can dispatch your Docker image
    to the registry so that it is registered and deposited. Using the `dockerimage
    pull` subcommand, you can download a Docker image from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Docker Registry could be hosted by a third party as a public or private registry,
    such as one of the following registries:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub ([https://hub.docker.com](https://hub.docker.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quay ([https://quay.io/](https://quay.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Container Registry ([https://cloud.google.com/container-registry](https://cloud.google.com/container-registry))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Container Registry ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every institution, innovator and individual can have their own Docker Registry
    to stock up their images for internal and/or external access and usage.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, when you ran the `dockerimage pull` subcommand, the
    `nginx` image got downloaded mysteriously. In this section, let's unravel the
    mystery around the `docker image pull` subcommand and how the Docker Hub immensely
    contributed toward this unintended success.
  prefs: []
  type: TYPE_NORMAL
- en: The good folks in the Docker community have built a repository of images and
    they have made it publicly available at a default location, `index.docker.io`.
    This default location is called the Docker Hub. The `docker image pull` subcommand
    is programmed to look for the images at this location. Thus, when you `pull` a
    `nginx` image, it is effortlessly downloaded from the default registry. This mechanism
    helps in speeding up the spinning of the Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Hub is the official repository that contains all the painstakingly
    curated images that are created and deposited by the worldwide Docker development
    community. This so-called cure is enacted for ensuring that all the images stored
    in the Docker Hub are secure and safe through a host of quarantine tasks. There
    are additional mechanisms such as creating the image digest and having content
    trust that gives you the ability to verify both the integrity and the publisher
    of all the data received from a registry over any channel.
  prefs: []
  type: TYPE_NORMAL
- en: There are proven verification and validation methods for cleaning up any knowingly
    or unknowingly introduced malware, adware, viruses, and so on, from these Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The digital signature is a prominent mechanism of the utmost integrity of the
    Docker images. Nonetheless, if the official image has been either corrupted, or
    tampered with, then the Docker engine will issue a warning and then continue to
    run the image.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the official repository, the Docker Hub Registry also provides
    a platform for thethird-party developers and providers for sharing their images
    for general consumption. The third-party images are prefixed by the user ID of
    their developers or depositors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `russmckendrick/cluster`is a third-party image, wherein `russmckendrick`
    is the user ID and `cluster` is the image repository name. You can download any
    third-party image by using the `docker image pull` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the preceding repository, the Docker ecosystem also provides a mechanism
    for leveraging the images from any third-party repository hub other than the Docker
    Hub Registry, and it also provides the images hosted by the local repository hubs.
    As mentioned earlier, the Docker engine has been programmed to look for images
    at `index.docker.io` by default, whereas in the case of the third-party or the
    local repository hub, we must manually specify the path from where the image should
    be pulled.
  prefs: []
  type: TYPE_NORMAL
- en: A manual repository path is similar to a URL without a protocol specifier, such
    as `https://`, `http://`and `ftp://`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of pulling an image from a third-party repository hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Controlling Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker engine enables you to `start`, `stop`, and `restart` a container
    with a set of `docker` subcommands. Let's begin with the `docker container stop`
    subcommand, which stops a running container. When a user issues this command,
    the Docker engine sends `SIGTERM (-15)` to the main process, which is running
    inside the container. The **SIGTERM** signal requests the process to terminate
    itself gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the processes would handle this signal and facilitate a graceful exit.
    However, if this process fails to do so, then the Docker engine will wait for
    a grace period. Even after the grace period, if the process has not been terminated,
    then the Docker engine will forcefully terminate the process. The forceful termination
    is achieved by sending `SIGKILL (-9)`.
  prefs: []
  type: TYPE_NORMAL
- en: The **SIGKILL** signal cannot be caught or ignored and hence, it will result
    in an abrupt termination of the process without a proper cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s launch our container and experiment with the `docker container
    stop` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Controlling Docker containers](img/B06455_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Having launched the container, let''s run the `docker container stop` subcommand
    on this container by using the container `ID` that was taken from the prompt.
    Of course, we have to use a second screen/terminal to run this command, and the
    command will always echo back to the container `ID`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Controlling Docker containers](img/B06455_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you switch to the screen/terminal where you were running the container,
    you will notice that the container is being terminated. If you observe a little
    more keenly, then you will also notice the text `exit` next to the container prompt.
    This happened due to the SIGTERM handling mechanism of the bash shell, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling Docker containers](img/B06455_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we take it one step further and run the `docker container ps` subcommand,
    then we will not find this container anywhere in the list. The fact is that the
    `docker container ps` subcommand, by default, always lists the container that
    is in the running state. Since our container is in the stopped state, it was comfortably
    left out of the list. Now, you might ask, how do we see the container that is
    in the stopped state? Well, the `docker container ps` subcommand takes an additional
    argument `-a`, which will list all the containers in that Docker host irrespective
    of its status.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Controlling Docker containers](img/B06455_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's look at the `docker container start` subcommand, which is used for
    starting one or more stopped containers. A container could be moved to the stopped
    state either by the `docker container stop` subcommand or by terminating the main
    process in the container either normally or abnormally. On a running container,
    this subcommand has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the previously stopped container by using the `docker container
    start` subcommand, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `docker container start` subcommand will not attach to the
    container. You can attach it to the container either by using the `-a` option
    in the `docker container start` subcommand or by explicitly using the `docker
    container attach` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Controlling Docker containers](img/B06455_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s run the `docker containerps` command and verify the container''s
    running status, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Controlling Docker containers](img/B06455_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `restart` command is a combination of the `stop` and the `start` functionality.
    In other words, the `restart` command will `stop` a running container by following
    the precise steps followed by the `docker conatiner stop` subcommand and then
    it will initiate the `start` process. This functionality will be executed by default
    through the `docker conatiner restart` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important set of container controlling subcommands are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker container pause`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker container unpause`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker container pause` subcommands will essentially freeze the execution
    of all the processes within that container. Conversely, the `docker container
    unpause` subcommand will unfreeze the execution of all the processes within that
    container and resume the execution from the point where it was frozen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having seen the technical explanation of `pause`/`unpause`, let''s see a detailed
    example for illustrating how this feature works. We have used two screen/terminal
    scenarios. On one terminal, we have launched our container and used an infinite
    while loop for displaying the date and time, sleeping for 5 seconds, and then
    continuing the loop. We will run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are within the container, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our little script has very faithfully printed the date and time every `5` seconds
    apart from when it was paused:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling Docker containers](img/B06455_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the terminal output above, we encountered a delay of around
    30 seconds, because this is when we initiated the `docker container pause` subcommand
    on our container on the second terminal screen, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we paused our container, we looked at the process status by using the
    `docker containerps` subcommand on our container, which was on the same screen,
    and it clearly indicated that the container had been paused, as shown in this
    command result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We continued onto issuing the `docker conatiner unpause` subcommand, which
    unfroze our container, continued its execution, and then started printing the
    date and time, as we saw in the preceding command, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We explained the `pause` and the `unpause` commands at the beginning of this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the container and the script running within it had been stopped by
    using the `docker container stop` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see everything we ran in our second terminal below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling Docker containers](img/B06455_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at doing something a little more complex now.
  prefs: []
  type: TYPE_NORMAL
- en: Running a WordPress container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost everyone at some point will have installed, used, or read about WordPress,
    so for our next example, we will be using the official WordPress container from
    the Docker Hub. You can find details on the container at [https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WordPress is web software that you can use to create a beautiful website, blog,
    or app. We like to say that WordPress is both free and priceless at the same time.
    For more information, check out [https://wordpress.org/](https://wordpress.org/).
  prefs: []
  type: TYPE_NORMAL
- en: To launch WordPress, you will need to download and run two containers, the first
    of which is the database container, for this I recommend using the official MySQL
    container which you can find at [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the latest MySQL container image run the following command on your
    Mac, Windows or Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the pulled a copy of the image you can launch MySQL by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The command above launches (`docker container run`) the MySQL in a detached
    state (using `-d`), meaning that it is running in the background, we are calling
    the container `mysql` (`--namewordpress`) and we are using two different environment
    variables (using `-e`) to set the MySQL root password to `wordpress (-e MYSQL_ROOT_PASSWORD=wordpress`)
    and to create a database called `wordpress` (`-e MYSQL_DATABASE=wordpress`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once launched, you should receive the container ID. You can check the container
    is running as expected by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, at this point, although the container is running that doesn't really mean
    that MySQL is ready. If you were to launch your WordPress container now, you might
    find that it runs for a short while and then stops.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry, this is expected. As there is no MySQL data within the container
    it takes a little while to get itself into a state where it is available to accept
    incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the status of your MySQL container you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Running a WordPress container](img/B06455_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you see the message **mysqld: ready for connections**, you are good to
    launch your WordPress container; you may find yourself having to check the logs
    a few times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we to down the WordPress container image; to do this, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded run the following command to launch the WordPress container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are launching the container in the background (using `-d`), calling
    the container the `wordpress` (with `--name wordpress`). This is where things
    differ slightly between the MySQL and WordPress containers, we need to let the
    WordPress container know where our MySQL container is accessible, to do this are
    using the link flag (in our case by running `--link mysql:mysql`) this will create
    an alias within the WordPress container pointing it at the IP address of the MySQL
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Next up we are opening port `8080` on our machine and mapping it to port `80`
    on the container (using `-p 8080:80`) and then letting WordPress know what the
    password is (with `-e WORDPRESS_DB_PASSWORD=wordpress`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the running containers using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Should show you that you now have two running containers, MySQL and WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a WordPress container](img/B06455_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike the MySQL container, there isn''t much the WordPress container needs
    to do before it is accessible, you can check the logs by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Running a WordPress container](img/B06455_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you open your browser and go to `http://localhost:8080/` you should see
    your WordPress installation sitting at an installation prompt like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a WordPress container](img/B06455_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you like, you can work through the installation and get WordPress up and
    running by clicking on **Continue** and following the onscreen prompts; however,
    the next set of commands we will be running will destroy our two containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove everything we have just launched ahead of the next exercise, run
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So far we have used the Docker client to easily launch, stop, start, pause,
    unpause and remove containers as well as downloading and removing container images
    from the Docker Hub, while this is great to quickly launch a few containers it
    can get complicated to manage once you have more than a few containers running
    at once, this is where the next tool we are going to look at comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were following along with the Linux installation in [Chapter 1](ch01.html
    "Chapter 1. Installing Docker Locally"), *Installing Docker Locally* then you
    should have already installed Docker Compose manually, for those of you that skipped
    that part then you will glad to know that Docker Compose is installed and maintained
    as part of Docker for Mac and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: I am sure that you will agree that so far Docker has proved to be quite intuitive,
    Docker Compose is no different. It started off life as third-party software called
    Fig and was written by Orchard Labs (the project's original website is still available
    at [http://fig.sh/](http://fig.sh/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The original project''s goal was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Provide fast, isolated development environments using Docker"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since Orchard Labs became part of Docker, they haven''t strayed too far from
    the original projects goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Compose is a tool for defining and running multi-container Docker applications.
    With Compose, you use a Compose file to configure your application''s services.Then,
    using a single command, you create and start all the services from your configuration."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before we start looking at Compose files and start containers up, let's think
    of why a tool such as Compose is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Why Compose?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Launching individual containers is as simple as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will launch and then attach to an Ubuntu container. As we have already
    touched upon, there is a little more to it than just launching simple containers
    though. Docker is not here to replace virtual machines, it is here to run a single
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you shouldn't really run an entire LAMP stack in single container,
    instead, you should look at running Apache and PHP in one container, which is
    then linked with a second container running MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: You could take this further, running NGINX container, a PHP-FPM container, and
    a MySQL container. This is where it gets complicated. All of sudden, your simple
    single command for launching a container is now several lines, all of which must
    executed in the correct order with the correct flags to expose ports, link them
    together and configure the services using environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the problem Docker Compose tries to fix. Rather than several
    long commands, you can define your containers using a YAML file. This means that
    you will be able to launch your application with a single command and leave the
    logic of the order in which the containers will be launched to Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**YAML Ain''t Markup Language** (**YAML**) is a human-friendly data serialization
    standard for all programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: It also means that you can ship your application's Compose file with your code
    base or directly to another developer/administrator and they will be able to launch
    your application exactly how you intended it be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Compose files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by getting a launching WordPress again. First of all, if you haven''t
    already clone the GitHub repository which accompanies this book. You can find
    it at the following URL: [https://github.com/russmckendrick/bootcamp](https://github.com/russmckendrick/bootcamp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on how to clone the repository please see the introduction.
    Once you have repo cloned run the following commands from the top level of the
    repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compose-wordpress` folder contains the following `docker-compose.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `docker-compose.yml` file is easy to follow; our initial
    `docker-compose.yml` file is split into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: This tells Docker Compose which file format we are using; the
    current version is 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: These are where our containers are defined, you can define several
    containers here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volumes**: Any volumes for persistent storage are defined here, we will go
    into this in more detail in later chapters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the most part, the syntax is pretty similar to that we used to launch our
    WordPress containers using the Docker command-line client. There are, however
    a few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`volumes`: In the `mysql` container we are taking a volume called `db_data`
    and mounting it to `/var/lib/mysql` within the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: This is set to `always,` meaning that if our containers stop responding
    any reason, like the `wordpress` container will do until the `mysql` container
    is accepting connections, then it will be restarted automatically meaning we don''t
    have to manually intervene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on`: Here we are telling the `wordpress` container not to start until
    the `mysql` container is running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may notice that we are not linking our containers, this is because Docker
    Compose automatically creates a network to launch the services in, each container
    within the network created by Docker Compose automatically has its host file updated
    to include aliases for each of the containers within the service, meaning that
    our WordPress container will be able to connect to our MySQL container using the
    default host of `mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch our WordPress installation, all we need to do is run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using the `-d` flag at the end of the command launches the containers in detached
    mode, this means that they will run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: If we didn't use the `-d` flag, then our containers would have launched in the
    foreground and we would not have been able to carry on using the same terminal
    session without stopping the running containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B06455_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While the containers are up and running, which you can see by running the follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a short while for the MySQL container to be ready to accept connections,
    you may find running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Show you connection errors like the ones below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B06455_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Don''t worry, you should soon see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B06455_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, opening `http://localhost:8080/` in your browser should show you the
    installation screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B06455_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The process above works on Docker for Mac and on Linux; however for Docker
    for Windows you should add`.exe` to your Docker Compose commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B06455_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, opening your browser and going to `http://localhost:8080/` should show
    you the installation screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B06455_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we move into the next section, let''s stop and remove our WordPress
    containers by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you are following using Docker for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have been using images from the Docker Hub, next we will are going
    to take a look at customizing images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker images are the fundamental building blocks of containers. These images
    could be very basic operating environments such, as `alpine` or `Ubuntu`. Or,
    the images could craft advanced application stacks for the enterprise and cloud
    IT environments. An automated approach of crafting Docker images is using a `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: A `Dockerfile` is a text-based build script that contains special instructions
    in a sequence for building the right and the relevant images from the base images.
    The sequential instructions inside the `Dockerfile` can include the base image
    selection, installing the required application, adding the configuration and the
    data files, and automatically running the services as well as exposing those services
    to the external world. Thus, a Dockerfile-based automated build system has remarkably
    simplified the image-building process. It also offers a great deal of flexibility
    in the way in which the build instructions are organized and in the way in which
    they visualize the complete build process.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker engine tightly integrates this build process with the help of the
    `docker build` subcommand. In the client-server paradigm of Docker, the Docker
    server (or daemon) is responsible for the complete build process and the Docker
    command line interface is responsible for transferring the build context, including
    transferring `Dockerfile` to the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: To have a sneak peek into the `Dockerfile` integrated build system in this section,
    we introduce you to a basic `Dockerfile`. Then, we explain the steps for converting
    that `Dockerfile` into an image, and then launching a container from that image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Dockerfile` is made up of two instructions, as shown here (there is also
    a copy in the GitHub repo in the `chapter02/build_basic` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, we cover/discuss the two instructions mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction is for choosing the base image selection. In this example,
    we select the `apline:latest` image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second instruction is for carrying out the command `CMD`, that instructs
    the container to `echo Hello World!!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s proceed towards generating a Docker image by using the preceding
    `Dockerfile` by calling `dockerimagebuild` along with the path of the `Dockerfile`.
    In our example, we will invoke the `dockerimagebuild` subcommand from the directory
    where we have stored the `Dockerfile,` and the path will be specified by the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After issuing the preceding command, the `build` process will begin by sending
    build context to the daemon and then display the text shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending build context to Docker daemon 2.048 kB**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1/2 : FROM alpine:latest**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The build process will continue and after completing itself, it will display
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Successfully built 0080692cf8db**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the image was built with `IMAGE ID0a2abe57c325`.
    Let''s use this image to launch a container by using the `docker container run`
    subcommand as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Cool, isn't it? With very little effort, we have been able to craft an image
    with `alpine` as the base image, and we have been able to extend that image to
    produce `Hello World!!`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple application, but the enterprise-scale images can also be realized
    by using the same methodology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the image details by using the `dockerimage ls` subcommand.
    Here, you may be surprised to see that the `IMAGE` (`REPOSITORY`) and `TAG` name
    have been listed as `<none>`. This is because we did not specify any image or
    any `TAG` name when we built this image. You could specify an `IMAGE` name and
    optionally a `TAG` name by using the `docker image tag` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative approach is to build the image with an image name during the
    `build` time by using the `-t` option for the `docker image build` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since there is no change in the instructions in `Dockerfile`, the Docker engine
    will efficiently reuse the old image that has `ID0a2abe57c325` and update the
    image name to `basicbuild`. By default, the build system would apply `latest`
    as the `TAG` name. This behavior can be modified by specifying the `TAG` name
    after the `IMAGE` name by having a `:` separator placed in between them. That
    is, `<image name>:<tag name>` is the correct syntax for modifying behaviors, wherein
    `<image name>` is the name of the image and `<tag name>` is the name of the tag.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, let's look at the image details by using the `docker image ls` subcommand,
    and you will notice that the image (Repository) name is `basicimage` and the tag
    name is `latest`. Building images with an image name is always recommended as
    the best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Having experienced the magic of `Dockerfile`, in the subsequent sections, we
    will introduce you to the syntax or the format of `Dockerfile` and explain a dozen
    `Dockerfile` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default `docker image build` subcommand uses the `Dockerfile` located at
    the build context. However `–f` option `docker image build` subcommand let's to
    specify an alternate `Dockerfile` in a different path or name.
  prefs: []
  type: TYPE_NORMAL
- en: A quick overview of the Dockerfile's syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we explain the syntax or the format of `Dockerfile`. A `Dockerfile`
    is made up of instructions, comments, parser directives and empty lines, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The instruction line of `Dockerfile` is made up of two components, where the
    instruction line begins with the instruction itself, which is followed by the
    arguments for the instruction. The instruction could be written in any case, in
    other words, it is case-insensitive. However, the standard practice or the convention
    is to use *uppercase* to differentiate it from the arguments. Let''s take a relook
    at the content of `Dockerfile` in our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, `FROM` is an instruction which has taken `apline:latest` as an argument,
    and `CMD` is an instruction which has taken `echo Hello World!!` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: The comment line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The comment line in `Dockerfile` must begin with the `#` symbol. The `#` symbol
    after an instruction is considered as an argument. If the `#` symbol is preceded
    by a whitespace, then the `docker image build` system would consider that as an
    unknown instruction and skip the line. Now, let''s understand the preceding cases
    with the help of an example to get a better understanding of the comment line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A valid `Dockerfile` comment line always begins with a `#` symbol as the first
    character of the line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `#` symbol can be a part of an argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `#` symbol is preceded by a whitespace, then it is considered as an
    unknown instruction by the build system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A sample `Dockerfile` can be found at `/chapter02/build_basic/` in the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `docker image build` system ignores any empty line in the `Dockerfile` and
    hence, the author of `Dockerfile` is encouraged to add comments and empty lines
    to substantially improve the readability of `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: The parser directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name implies, the parser directives instruct the `Dockerfile` parser
    to handle the content of the `Dockerfile` as specified in the directives. The
    parser directives are optional and they must be at the very top of a `Dockerfile`.
    Currently escape is the only supported directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use escape character to escape characters in a line or to extend a single
    line to multiple lines. On a UNIX like platform, `\` is the escape character whereas
    on windows \ is a directory path separator and `''` is the escape character. By
    default, `Dockerfile` parser considers `\` as the escape character and you could
    override this on windows using the escape parser directive as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Dockerfile build instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at the integrated build system, the `Dockerfile` syntax
    and a sample lifecycle, wherein how a sample `Dockerfile` is leveraged for generating
    an image and how a container gets spun off from that image was discussed. In this
    section, we will introduce the `Dockerfile` instructions, their syntax, and a
    few befitting examples.
  prefs: []
  type: TYPE_NORMAL
- en: The FROM instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FROM` instruction is the most important one and it is the first valid instruction
    of a `Dockerfile`. It sets the base image for the build process. The subsequent
    instructions will use this base image and build on top of it. The Docker build
    system lets you flexibly use the images built by anyone. You can also extend them
    by adding more precise and practical features to them. By default, the Docker
    build system looks in the Docker host for the images.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the image is not found in the Docker host, then the Docker build
    system will pull the image from the publicly available Docker Hub Registry. The
    Docker build system will return an error if it cannot find the specified image
    in the Docker host and the Docker Hub Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code statement, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<image>`: This is the name of the image which will be used as the base image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tag>` or`<digest>`: Both tag and digest are optional attributes and you could
    qualify a particular Docker image version using either a tag or a digest. Tag
    `latest` is assumed by default if both tag and digest are not present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the `FROM` instruction with the image name `centos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the Docker build system would implicitly default to tag
    `latest` because neither a tag nor a digest is explicitly added to the image name.
  prefs: []
  type: TYPE_NORMAL
- en: You should be strongly discouraged from using multiple `FROM` instructions in
    a single `Dockerfile`, as damaging conflicts could arise.
  prefs: []
  type: TYPE_NORMAL
- en: The MAINTAINER instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the `MAINTAINER` instruction does is enables the authors' details to set
    the in an image. Docker does not place any restrictions on placing the `MAINTAINER`
    instruction in a `Dockerfile`. However, it is strongly recommended that you should
    place it after the `FROM` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax of the `MAINTAINER` instruction, where `<author''s
    detail>` can be in any text. However, it is strongly recommended that you should
    use the image, author''s name and the e-mail address as shown in this code syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an example of the `MAINTAINER` instruction with the author name, and
    the e-mail address at `/chapter02/build_01_maintainer/` in the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The RUN instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RUN` instruction is the real workhorse during the build time, and it can
    run any command. The general recommendation is to execute the multiple commands
    by using one `RUN` instruction. This reduces the layers in the resulting Docker
    image because the Docker system inherently creates a layer for each time an instruction
    is called in `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RUN` instruction has two types of syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the shell type, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `<command>` is the shell command that has to be executed during the
    build time. If this type of syntax is to be used, then the command is always executed
    by using `/bin/sh -c`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second syntax type is either exec or the JSON array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wherein, the code terms mean the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<exec>`: This is the executable to run during the build time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variables (zero or more) number of the
    arguments for the executable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the first type of syntax, this type does not invoke `/bin/sh -c`. Hence,
    the types of shell processing, such as the variable substitution (`$USER`) and
    the wild card substitution (`*`, `?`), do not happen in this type. If shell processing
    is critical for you, then you are encouraged to use the shell type. However, if
    you still prefer the exec (JSON array type) type, then use your preferred shell
    as the executable and supply the command as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `RUN ["bash", "-c", "rm", "-rf", "/tmp/abc"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a few `RUN` instructions to our `Dockerfile` to install NGINX using
    `apk` and then set some permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are installing NGINX and Supervisor. The `&&` has been added
    so that we can string several commands together on a single line, as each line
    within the `Dockerfile` creates a layer within the image stringing commands together
    like this streamlines your image file.
  prefs: []
  type: TYPE_NORMAL
- en: The COPY instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `COPY` instruction enables you to copy the files from your Docker host
    to the filesystem of the image you are building. The following is the syntax of
    the `COPY` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code terms bear the explanations shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<src>`: This is the source directory, the file in the build context, or the
    directory from where the `docker build` subcommand was invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`...`: This indicates that multiple source files can either be specified directly
    or be specified by wildcards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will get copied. If multiple files have been specified, then
    the destination path must be a directory and it must end with a slash `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an absolute path for the destination directory or a file has been recommended.
    In the absence of an absolute path, the `COPY` instruction will assume that the
    destination path will start from root `/`. The `COPY` instruction is powerful
    enough for creating a new directory and for overwriting the filesystem in the
    newly created image.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `copy` command can be found in the repo ([https://github.com/russmckendrick/bootcamp](https://github.com/russmckendrick/bootcamp))
    at `/chapter02/build_03_copy/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This copies the `start.sh` file to the folder in the Docker image at`/script/`and
    the configuration file from the `files` folder to in place on the image.
  prefs: []
  type: TYPE_NORMAL
- en: The ADD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ADD` instruction is like the `COPY` instruction. However, in addition to
    the functionality supported by the `COPY` instruction, the `ADD` instruction can
    handle the TAR files and the remote URLs. We can annotate the `ADD` instruction
    as `COPY` on steroids.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax of the `ADD` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments of the `ADD` instruction are very similar to those of the `COPY`
    instruction, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<src>`: This is either the source directory or the file that is in the build
    context or in the directory from where the `docker build` subcommand will be invoked.
    However, the noteworthy difference is that the source can either be a `tar` file
    stored in the build context or be a remote URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`...`: This indicates that the multiple source files can either be specified
    directly or be specified by using wildcards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will be copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example for demonstrating the procedure for copying multiple source
    files to the various destination directories in the target image filesystem. In
    this example, we have taken a TAR file (`webroot.tar`) in the source build context
    with the `http` daemon configuration file and the files for the web pages are
    stored in the appropriate directory structure, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ADD instruction](img/B06455_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next line in the `Dockerfile` content has an `ADD` instruction for copying
    the TAR file (`webroot.tar`) to the target image and extracting the TAR file from
    the root directory (`/`) of the target image, as shown here in the example you
    can find in the repo at `/chapter02/build_04_add/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the TAR option of the `ADD` instruction can be used for copying multiples
    files to the target image, also note we have added a second `RUN` instruction
    to set the permissions on the folder we have just created using `ADD`.
  prefs: []
  type: TYPE_NORMAL
- en: The EXPOSE instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction opens up a container network port for communicating
    between the container and the rest of the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `EXPOSE` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the code terms mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<port>`: This is the network port that has to be exposed to the outside world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<proto>`: This is an optional field provided for a specific transport protocol,
    such as TCP and UDP. If no transport protocol has been specified, then TCP is
    assumed to be the transport protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction allows you to specify multiple ports in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `EXPOSE` instruction inside a `Dockerfile`
    exposing port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The ENTRYPOINT instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction will help in crafting an image for running an application
    (entry point) during the complete lifecycle of the container, which would have
    been spun out of the image. When the entry point application is terminated, the
    container would also be terminated along with the application and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the `ENTRYPOINT` instruction would make the container function like an
    executable. Functionally, `ENTRYPOINT` is akin to the `CMD` instruction which
    we will look at next, but the major difference between the two is that the entry
    point application is launched by using the `ENTRYPOINT` instruction, which cannot
    be overridden by using the `docker run` subcommand arguments.
  prefs: []
  type: TYPE_NORMAL
- en: However, these `docker container run` subcommand arguments will be passed as
    additional arguments to the entry point application. Having said this, Docker
    provides a mechanism for overriding the entry point application through the `--entrypoint`
    option in the `docker container run` subcommand. The `--entrypoint` option can
    accept only word as its argument and hence, it has limited functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically, the `ENTRYPOINT` instruction is very similar to the `RUN`, and
    the `CMD` instructions, and it has two types of syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first type of syntax is the shell type, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `<command>` is the shell command, which is executed during the launch
    of the container. If this type of syntax is used, then the command is always executed
    by using `/bin/sh -c`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second type of syntax is `exec` or the JSON array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wherein, the code terms mean the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<exec>`: This is the executable, which has to be run during the container
    launch time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) number of arguments
    for the executable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntactically, you can have more than one `ENTRYPOINT` instruction in a `Dockerfile`.
    However, the build system will ignore all the `ENTRYPOINT` instructions except
    the last one. In other words, in the case of multiple `ENTRYPOINT` instructions,
    only the last `ENTRYPOINT` instruction be effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from when we covered the `RUN` instruction we installed a
    service called `supervisord`, we will be using this for the entry point in our
    image meaning that our `Dockerfile` now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now we could leave it here and the image would be functional, however there
    is one instruction we should pass to our image.
  prefs: []
  type: TYPE_NORMAL
- en: The CMD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CMD` instruction can run any command (or application), which is similar
    to the `RUN` instruction. However, the major difference between those two is the
    time of execution. The command supplied through the `RUN` instruction is executed
    during the build time, whereas the command specified through the `CMD` instruction
    is executed when the container is launched from the newly created image. Thus,
    the `CMD` instruction provides a default execution for this container. However,
    it can be overridden by the `docker run` subcommand arguments. When the application
    terminates, the container will also terminate along with the application and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: On the face of it the `CMD` instruction is very similar to the `RUN` instruction
    in that it can run any command passed to it, however there is a major difference
    between the two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The command passed to the `RUN` instruction is executed at build time and commands
    passed using the `CMD` instruction are executed at run time meaning you can define
    the default execution for the container. This means if no command is passed during
    the `docker container run` command then the CMD will executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CMD` instruction has three types of syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first syntax type is the shell type, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wherein, the `<command>` is the shell command, which has to be executed during
    the launch of the container. If this type of syntax is used, then the command
    is always executed by using `/bin/sh -c`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second type of syntax is exec or the JSON array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wherein, the code terms mean the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<exec>`: This is the executable, which is to be run during the container launch
    time'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) number of the
    arguments for the executable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third type of syntax is also exec or the JSON array, which is similar to
    the previous type. However, this type is used for setting the default parameters
    to the `ENTRYPOINT` instruction, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wherein, the code terms mean the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<arg-1>, ..., <arg-n>`: These are the variables (zero or more) number of the
    arguments for the `ENTRYPOINT` instruction, which will be explained in the next
    section.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntactically, you can add more than one `CMD` instruction in `Dockerfile`.
    However the build system would ignore all the `CMD` instructions except for the
    last one. In other words, in the case of multiple `CMD` instructions, only the
    last `CMD` instruction would be effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, our `Dockerfile` could have been run
    with just the `ENTRYPOINT` instruction defined, however that would give a non-breaking
    error when `supervisiord` starts up so let''s pass a flag which defines where
    our supervisor configuration file is using the `CMD` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now in a position where we can build our image, you can find our completed
    `Dockerfile` in the `/chapter02/` `build_07_cmd/` folder in the repo, to build
    the image simple run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This will kick of the build, as you can see from the following terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CMD instruction](img/B06455_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are 12 steps in the build, it will take a minute or two, but once compete
    you should see something like the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CMD instruction](img/B06455_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have your image built, you can check and then run it by using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![The CMD instruction](img/B06455_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the container is running, opening your browser and going `http://localho`
    `st:8080/` should show you something like the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CMD instruction](img/B06455_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There you have it, we have created an image:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Alpine Linux base (`FROM`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed `NGINX` and `supervisord` using `apk` (`RUN`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copied the configuration from our Docker host to the image (`COPY`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploaded and extracting our web root (`ADD`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the correct ownership of our web root (`RUN`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that port `80` on the container is open (`EXPOSE`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made sure that `supervisord` is the default process (`ENTRYPOINT`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passed the configuration file flag to `supervisord` (`CMD`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before moving onto the next section you can stop and remove the container by
    running the following command making sure you replace the container ID with that
    of yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then remove the image we created by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to go back to our WordPress image and customize it.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing existing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the official images should provide you with a fully functioning usable
    image you may sometimes need to install additional software, in this case we are
    going to look at installing WordPress CLI using the official WordPress image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WordPress CLI is a set of command line tools which allow you to manage your
    WordPress configuration and installation; for more information, see [http://wp-cli.org/](http://wp-cli.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a copy of the `Dockerfile` below in the `/chapter02/wordpress-custom/`
    folder in the repo, as you can see we are just running `RUN` and `COPY`instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can build the image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it has finished building use the following command to check the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as we discovered earlier in this chapter it is easier to launch WordPress
    using Docker Compose, before we do lets remove the image we just built by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Compose can also trigger builds. Our updated `docker-compose.yml` file
    can be found in the `/chapter02/wordpress-custom/` folder and below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is almost exactly the same as our original `docker-compose.yml`
    apart from now we have a line that says `build: ./`" rather than `image: wordpress`".'
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch our WordPress installation, we simply need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This will pull and build the container images, once complete you should see
    something like the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing existing images](img/B06455_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Going to `http://localhost:8080/` should show you the installation screen, however,
    we are going to typing a few commands to configure WordPress using the WordPress
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s check the version of WordPress we are working with by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This will connect to the WordPress service and run the `wp core version` command,
    then return the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing existing images](img/B06455_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are going to install WordPress using the `wp core install` command,
    change the `title`, `admin_user`, `admin_password` and `admin_email` values as
    you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command has finished running you should receive a message saying **Success:
    WordPress installed successfully**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing existing images](img/B06455_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Going to `http://localhost:8080/` should show you a WordPress site rather than
    an installation prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing existing images](img/B06455_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have finished with your WordPress installation you can stop and remove
    it by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to build an image we are going to look at a few different ways
    to share them.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Hub is a central place used for keeping the Docker images either
    in a public or private repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Hub provides features, such as a repository for Docker images, user
    authentications, automated image builds, integration with GitHub or Bitbucket,
    and managing organizations and groups. The Docker Registry component of the Docker
    Hub manages the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with the Docker Hub, you must register an account using the link at
    [https://hub.docker.com/](https://hub.docker.com/).You can update the **Docker
    Hub ID**, **Email Address** and **Password** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing your images](img/B06455_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After completing the **Sign Up** process, you need to complete the verification
    received in an e-mail. After the e-mail verification is completed, you will see
    something similar to the following screenshot, when you login to the Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing your images](img/B06455_02_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, I already have a few automated builds configured, we will get
    to these later on, for now we are going to look at pushing an image from our local
    Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to login to the Docker Hub using the Docker client on the command
    line, to do this simply use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be prompted for your Docker Hub username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing your images](img/B06455_02_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to start committing and pushing images to the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: We'll again create an image using the `Dockerfile` we created earlier in the
    chapter. So, let's create the Docker image using the `Dockerfile` in `/chapter02/build_07_cmd`and
    push the resulting image to the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we build the image locally using the following command making sure to use
    your own Docker Hub username in place of mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Once built, you can check the image is there by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![Sharing your images](img/B06455_02_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we are already logged in all we need to do to push the newly create image
    is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '![Sharing your images](img/B06455_02_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can verify the availability of the image on the Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing your images](img/B06455_02_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is where I should probably issue a warning: as you have just experienced
    it is very easy to publish images to the Docker Hub using the `docker image push`
    command; however, it is very easy to accidentally push content you maybe wouldn''t
    want to be publicly available. For example, with a simple `COPY` or `ADD` instruction
    in your `Dockerfile` it is easy to bake sensitive information such as password
    credentials, certificates keys and non-publicly available code to a publicly accessible
    Docker Image repository.'
  prefs: []
  type: TYPE_NORMAL
- en: It is this reason why I prefer to share a `Dockerfile` or `docker-compose.yml`
    files with my colleagues using private Git repositories and a good set of instructions
    . A also, it allows then to check what it is they are going to be running as they
    are able to review the`Dockerfile` and `docker-compose.yml` files; in fact, they
    can make changes and share them with me.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter. We have used the Docker command line
    client to launch and interact with containers. We also used Docker Compose to
    define multiple container based application, namely WordPress and created and
    published our own Docker images on the Docker Hub. Finally, we customized the
    official WordPress Docker image adding additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: I am sure you will agree that so far using Docker has felt quite intuitive;
    in our next chapter we will move off our local Docker host and interact with Docker
    installations on remote hosts.
  prefs: []
  type: TYPE_NORMAL
