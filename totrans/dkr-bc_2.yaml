- en: Chapter 2. Launching Applications Using Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 使用 Docker 启动应用程序
- en: 'In this chapter, we are going to be looking at launching more than just a simple
    web server using our local Docker installation. We will look at the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何不仅仅使用本地 Docker 安装来启动一个简单的 web 服务器。我们将讨论以下主题：
- en: Using Docker on the command-line to launch applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行中的 Docker 启动应用程序
- en: How to use the Docker `build` command
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Docker `build` 命令
- en: Using Docker Compose to make multi-container applications easier to launch
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 使多容器应用程序的启动更加简单
- en: We will then look at using all the techniques above to launch a WordPress and
    Drupal application stack.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用上述所有技术来启动 WordPress 和 Drupal 应用程序堆栈。
- en: Docker terminology
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 术语
- en: Before we start learning how to launch containers, we should quickly discuss
    some of the more common terminology we are going to be using in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习如何启动容器之前，我们需要快速讨论一下本章中将使用的常见术语。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please note, the Docker commands in this chapter have been written for use with
    Docker 1.13 and later. Trying to run commands such as `docker image pull nginx`
    in older versions will fail with an error. Please refer to [Chapter 1](ch01.html
    "Chapter 1. Installing Docker Locally"), *Installing Docker Locally* for details
    on how to install the latest version of Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章中的 Docker 命令是针对 Docker 1.13 及以后的版本编写的。在旧版本中运行诸如 `docker image pull nginx`
    这样的命令将会失败并显示错误。有关如何安装最新版本 Docker 的详细信息，请参阅 [第 1 章](ch01.html "第 1 章. 本地安装 Docker")，*本地安装
    Docker*。
- en: Docker images
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 镜像
- en: A **Docker image** is a collection of all the files that make up an executable
    software application. This collection includes the application plus all the libraries,
    binaries, and other dependencies such as deployment descriptors and so on. just
    needed just to run the application everywhere without any hitch or hurdle. These
    files in the Docker image are read-only and hence the content of the image cannot
    be altered. If you choose to alter the content of your image, the only option
    Docker allows is to add another layer with the new changes. In other words, a
    Docker image is made up of layers which you can review using `docker image history`
    subcommand.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 镜像**是由构成可执行软件应用程序的所有文件集合组成的。这个集合包括应用程序本身以及所有的库、二进制文件和其他依赖项，如部署描述符等。这些文件仅用于在任何地方顺利运行应用程序，不会有任何阻碍。这些
    Docker 镜像中的文件是只读的，因此镜像的内容不能被修改。如果你选择修改镜像的内容，Docker 唯一允许的做法是添加一个新层以包含新的更改。换句话说，Docker
    镜像是由多个层组成的，你可以使用 `docker image history` 子命令查看这些层。'
- en: 'The Docker image architecture effectively leverages this layering concept to
    seamlessly add additional capabilities to the existing images to meet the varying
    business requirements and increase the reuse of images. In other words, capabilities
    can be added to existing images by adding additional layers on top of that image
    and deriving a new image. The Docker images have a parent/child relationship and
    the bottom-most image is called the **base image**. The base image is the special
    image that doesn''t have any parent:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像架构有效地利用了这一层次化的概念，能够无缝地为现有镜像添加额外的功能，以满足不同的业务需求并增加镜像的复用性。换句话说，功能可以通过在现有镜像上添加额外的层来扩展，从而派生出新的镜像。Docker
    镜像之间有父子关系，最底层的镜像被称为**基础镜像**。基础镜像是没有任何父镜像的特殊镜像：
- en: '![Docker images](img/B06455_02_01A.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 镜像](img/B06455_02_01A.jpg)'
- en: In the previous diagram, Ubuntu is a base image and it does not have any parent
    image.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，Ubuntu 是一个基础镜像，它没有任何父镜像。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Ubuntu Docker image is a minimalist bundle of software libraries and binaries
    that are critical to run an application. It does not include Linux Kernel, Diver
    Drivers, and various other services a full-fledged Ubuntu operating system would
    provide.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu Docker 镜像是一个简化的软件库和二进制文件捆绑包，这些文件对于运行应用程序至关重要。它不包含 Linux 内核、驱动程序和完整 Ubuntu
    操作系统提供的各种其他服务。
- en: '![Docker images](img/B06455_02_01B.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 镜像](img/B06455_02_01B.jpg)'
- en: As you can see in the above diagram, everything starts with a base image and
    here in this example, it is Ubuntu. Further on, the `wget` capability is added
    to the image as a layer and the `wget` image is referencing Ubuntu image as its
    parent. And in the next layer, an instance of Tomcat application server is added
    and it refers the `wget` image as its parent. Each addition that is made to the
    original base image is stored in a separate layer (a kind of hierarchy gets generated
    here to retain the original identity).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上图中所看到的，一切都始于一个基础镜像，在本例中是Ubuntu。进一步，`wget`功能被添加到镜像作为一个层，并且`wget`镜像引用Ubuntu镜像作为其父级。在下一个层中，Tomcat应用服务器的一个实例被添加，并且它将`wget`镜像作为其父级。对原始基础镜像的每次添加都存储在单独的层中（在此处生成了一种层次结构以保留原始身份）。
- en: Precisely speaking, any Docker image has to originate from a base image and
    an image gets continuously enriched in its functionality by getting fresh modules
    and this is accomplished by adding an additional module as a new layer on the
    existing Docker image one by one as vividly illustrated in the above diagram.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，任何Docker镜像都必须源自基础镜像，并且通过逐个添加新模块的方式持续丰富其功能，正如上图所生动展示的那样。
- en: The Docker platform provides a simple way of building new images or extending
    existing images. You can also download the Docker images that the other people
    have already created and deposited in Docker image repositories (private or public).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台提供了一种简单的方式来构建新镜像或扩展现有镜像。您还可以下载其他人已经创建并存储在Docker镜像仓库（私有或公共）中的Docker镜像。
- en: Docker Registry
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker注册表
- en: A **Docker Registry** is a place where Docker images can be stored in order
    to be publicly or privately found, accessed, and used by worldwide software developers
    for quickly crafting fresh and composite applications without any risks. Because,
    all the stored images will have gone through multiple validations, verifications,
    and refinements, the quality of those images are really high.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker注册表**是一个地方，Docker镜像可以被存储，以便全球软件开发人员能够快速创建新鲜和复合应用程序，而不会有任何风险。因为所有存储的镜像都将经过多次验证、确认和完善，这些镜像的质量非常高。'
- en: Using the `dockerimage push` subcommand, you can dispatch your Docker image
    to the registry so that it is registered and deposited. Using the `dockerimage
    pull` subcommand, you can download a Docker image from the registry.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dockerimage push`子命令，您可以将您的Docker镜像分发到注册表，以便注册和存储。使用`dockerimage pull`子命令，您可以从注册表下载Docker镜像。
- en: 'A Docker Registry could be hosted by a third party as a public or private registry,
    such as one of the following registries:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Docker注册表可以由第三方托管为公共或私有注册表，比如以下几个注册表之一：
- en: Docker Hub ([https://hub.docker.com](https://hub.docker.com))
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub（[https://hub.docker.com](https://hub.docker.com)）
- en: Quay ([https://quay.io/](https://quay.io/))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quay（[https://quay.io/](https://quay.io/)）
- en: Google Container Registry ([https://cloud.google.com/container-registry](https://cloud.google.com/container-registry))
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google容器注册表（[https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)）
- en: AWS Container Registry ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS容器注册表（[https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)）
- en: Every institution, innovator and individual can have their own Docker Registry
    to stock up their images for internal and/or external access and usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个机构、创新者和个人都可以拥有自己的Docker注册表，用于存储其镜像以供内部和/或外部访问和使用。
- en: Docker Hub
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Hub
- en: In the previous chapter, when you ran the `dockerimage pull` subcommand, the
    `nginx` image got downloaded mysteriously. In this section, let's unravel the
    mystery around the `docker image pull` subcommand and how the Docker Hub immensely
    contributed toward this unintended success.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，当您运行`dockerimage pull`子命令时，`nginx`镜像神秘地被下载了下来。在本节中，让我们揭开`docker image
    pull`子命令周围的谜团，以及Docker Hub如何极大地促成了这一意外的成功。
- en: The good folks in the Docker community have built a repository of images and
    they have made it publicly available at a default location, `index.docker.io`.
    This default location is called the Docker Hub. The `docker image pull` subcommand
    is programmed to look for the images at this location. Thus, when you `pull` a
    `nginx` image, it is effortlessly downloaded from the default registry. This mechanism
    helps in speeding up the spinning of the Docker containers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 社区的好伙伴们已经构建了一个镜像仓库，并将其公开放置在默认位置 `index.docker.io`。这个默认位置被称为 Docker Hub。`docker
    image pull` 子命令被设计为在这个位置查找镜像。因此，当您拉取 `nginx` 镜像时，它会轻松从默认注册表下载。这种机制有助于加快 Docker
    容器的启动速度。
- en: The Docker Hub is the official repository that contains all the painstakingly
    curated images that are created and deposited by the worldwide Docker development
    community. This so-called cure is enacted for ensuring that all the images stored
    in the Docker Hub are secure and safe through a host of quarantine tasks. There
    are additional mechanisms such as creating the image digest and having content
    trust that gives you the ability to verify both the integrity and the publisher
    of all the data received from a registry over any channel.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是官方仓库，其中包含全球 Docker 开发社区精心策划和存储的所有镜像。所谓的“治愈”是通过一系列隔离任务确保 Docker Hub
    中存储的所有镜像安全可靠。还有额外的机制，如创建镜像摘要和内容信任，使您能够验证从任何通道接收的所有数据的完整性和发布者。
- en: There are proven verification and validation methods for cleaning up any knowingly
    or unknowingly introduced malware, adware, viruses, and so on, from these Docker
    images.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有经过验证的验证和清理方法，用于清除这些 Docker 镜像中可能有意或无意引入的恶意软件、广告软件、病毒等。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The digital signature is a prominent mechanism of the utmost integrity of the
    Docker images. Nonetheless, if the official image has been either corrupted, or
    tampered with, then the Docker engine will issue a warning and then continue to
    run the image.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是 Docker 镜像极度完整性的显著机制。然而，如果官方镜像已被损坏或篡改，那么 Docker 引擎将发出警告，然后继续运行镜像。
- en: In addition to the official repository, the Docker Hub Registry also provides
    a platform for thethird-party developers and providers for sharing their images
    for general consumption. The third-party images are prefixed by the user ID of
    their developers or depositors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了官方仓库外，Docker Hub Registry 还为第三方开发者和提供者提供了一个平台，用于共享他们的镜像供广泛使用。第三方镜像以其开发者或存储者的用户
    ID 作为前缀。
- en: 'For example, `russmckendrick/cluster`is a third-party image, wherein `russmckendrick`
    is the user ID and `cluster` is the image repository name. You can download any
    third-party image by using the `docker image pull` subcommand, as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`russmckendrick/cluster` 是一个第三方镜像，其中 `russmckendrick` 是用户 ID，`cluster` 是镜像仓库名称。您可以使用
    `docker image pull` 子命令下载任何第三方镜像，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apart from the preceding repository, the Docker ecosystem also provides a mechanism
    for leveraging the images from any third-party repository hub other than the Docker
    Hub Registry, and it also provides the images hosted by the local repository hubs.
    As mentioned earlier, the Docker engine has been programmed to look for images
    at `index.docker.io` by default, whereas in the case of the third-party or the
    local repository hub, we must manually specify the path from where the image should
    be pulled.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述仓库之外，Docker 生态系统还提供了一种机制，可以利用来自 Docker Hub Registry 以外的任何第三方仓库中的镜像，并提供由本地仓库托管的镜像。正如前面提到的，Docker
    引擎默认在 `index.docker.io` 查找镜像，而在第三方或本地仓库中，我们必须手动指定从哪个路径拉取镜像。
- en: A manual repository path is similar to a URL without a protocol specifier, such
    as `https://`, `http://`and `ftp://`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 手动仓库路径类似于没有协议说明符的 URL，例如 `https://`、`http://` 和 `ftp://`。
- en: 'Following is an example of pulling an image from a third-party repository hub:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从第三方仓库中拉取镜像的示例：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Controlling Docker containers
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制 Docker 容器
- en: The Docker engine enables you to `start`, `stop`, and `restart` a container
    with a set of `docker` subcommands. Let's begin with the `docker container stop`
    subcommand, which stops a running container. When a user issues this command,
    the Docker engine sends `SIGTERM (-15)` to the main process, which is running
    inside the container. The **SIGTERM** signal requests the process to terminate
    itself gracefully.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎使你能够使用一组 `docker` 子命令来 `启动`、`停止` 和 `重启` 容器。让我们从 `docker container stop`
    子命令开始，它用于停止一个运行中的容器。当用户发出此命令时，Docker 引擎会向容器中正在运行的主进程发送 `SIGTERM (-15)` 信号。**SIGTERM**
    信号请求进程优雅地终止。
- en: Most of the processes would handle this signal and facilitate a graceful exit.
    However, if this process fails to do so, then the Docker engine will wait for
    a grace period. Even after the grace period, if the process has not been terminated,
    then the Docker engine will forcefully terminate the process. The forceful termination
    is achieved by sending `SIGKILL (-9)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数进程会处理此信号并进行优雅退出。然而，如果该进程未能如此操作，则 Docker 引擎将等待一个宽限期。即使在宽限期后，如果进程仍未终止，则 Docker
    引擎将强制终止该进程。强制终止是通过发送 `SIGKILL (-9)` 来实现的。
- en: The **SIGKILL** signal cannot be caught or ignored and hence, it will result
    in an abrupt termination of the process without a proper cleanup.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIGKILL** 信号无法被捕获或忽略，因此，它将导致进程的突然终止，且不会进行适当的清理。'
- en: 'Now, let''s launch our container and experiment with the `docker container
    stop` subcommand, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动容器并尝试 `docker container stop` 子命令，如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Controlling Docker containers](img/B06455_02_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_01.jpg)'
- en: 'Having launched the container, let''s run the `docker container stop` subcommand
    on this container by using the container `ID` that was taken from the prompt.
    Of course, we have to use a second screen/terminal to run this command, and the
    command will always echo back to the container `ID`, as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器后，让我们使用从提示中获取的容器 `ID` 运行 `docker container stop` 子命令。自然，我们必须使用第二个屏幕/终端来运行此命令，且该命令将始终回显容器
    `ID`，如下面所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Controlling Docker containers](img/B06455_02_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_02.jpg)'
- en: 'Now, if you switch to the screen/terminal where you were running the container,
    you will notice that the container is being terminated. If you observe a little
    more keenly, then you will also notice the text `exit` next to the container prompt.
    This happened due to the SIGTERM handling mechanism of the bash shell, as shown
    here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你切换到运行容器的屏幕/终端，你会注意到容器正在被终止。如果你再仔细观察，你还会注意到容器提示符旁边有 `exit` 文本。这是由于 bash
    shell 的 SIGTERM 处理机制，如下所示：
- en: '![Controlling Docker containers](img/B06455_02_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_03.jpg)'
- en: If we take it one step further and run the `docker container ps` subcommand,
    then we will not find this container anywhere in the list. The fact is that the
    `docker container ps` subcommand, by default, always lists the container that
    is in the running state. Since our container is in the stopped state, it was comfortably
    left out of the list. Now, you might ask, how do we see the container that is
    in the stopped state? Well, the `docker container ps` subcommand takes an additional
    argument `-a`, which will list all the containers in that Docker host irrespective
    of its status.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步运行 `docker container ps` 子命令，那么我们将在列表中找不到该容器。事实上，`docker container ps`
    子命令默认情况下只列出处于运行状态的容器。由于我们的容器处于停止状态，因此它被巧妙地排除在列表之外。现在，你可能会问，如何查看处于停止状态的容器呢？其实，`docker
    container ps` 子命令可以接受额外的参数 `-a`，它将列出该 Docker 主机上的所有容器，无论其状态如何。
- en: 'This can be done by running the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过运行以下命令来实现：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Controlling Docker containers](img/B06455_02_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_04.jpg)'
- en: Next, let's look at the `docker container start` subcommand, which is used for
    starting one or more stopped containers. A container could be moved to the stopped
    state either by the `docker container stop` subcommand or by terminating the main
    process in the container either normally or abnormally. On a running container,
    this subcommand has no effect.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `docker container start` 子命令，它用于启动一个或多个已停止的容器。容器可以通过 `docker container
    stop` 子命令或通过正常或异常终止容器中的主进程而进入停止状态。在运行中的容器上，此子命令没有任何效果。
- en: 'Let''s start the previously stopped container by using the `docker container
    start` subcommand, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `docker container start` 子命令来启动先前停止的容器，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, the `docker container start` subcommand will not attach to the
    container. You can attach it to the container either by using the `-a` option
    in the `docker container start` subcommand or by explicitly using the `docker
    container attach` subcommand, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker container start`子命令不会附加到容器。你可以通过在`docker container start`子命令中使用`-a`选项，或者明确使用`docker
    container attach`子命令将其附加到容器，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Controlling Docker containers](img/B06455_02_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_05.jpg)'
- en: 'Now, let''s run the `docker containerps` command and verify the container''s
    running status, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`docker containerps`命令，验证容器的运行状态，如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Controlling Docker containers](img/B06455_02_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_06.jpg)'
- en: The `restart` command is a combination of the `stop` and the `start` functionality.
    In other words, the `restart` command will `stop` a running container by following
    the precise steps followed by the `docker conatiner stop` subcommand and then
    it will initiate the `start` process. This functionality will be executed by default
    through the `docker conatiner restart` subcommand.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart`命令是`stop`和`start`功能的组合。换句话说，`restart`命令将通过执行`docker container stop`子命令的精确步骤来`停止`一个正在运行的容器，然后启动`start`过程。默认情况下，这个功能将通过`docker
    container restart`子命令执行。'
- en: 'The next important set of container controlling subcommands are the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重要的一组容器控制子命令如下：
- en: '`docker container pause`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker container pause`'
- en: '`docker container unpause`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker container unpause`'
- en: The `docker container pause` subcommands will essentially freeze the execution
    of all the processes within that container. Conversely, the `docker container
    unpause` subcommand will unfreeze the execution of all the processes within that
    container and resume the execution from the point where it was frozen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container pause`子命令将基本上冻结容器内所有进程的执行。相反，`docker container unpause`子命令将解冻容器内所有进程的执行，并从冻结的地方继续执行。'
- en: 'Having seen the technical explanation of `pause`/`unpause`, let''s see a detailed
    example for illustrating how this feature works. We have used two screen/terminal
    scenarios. On one terminal, we have launched our container and used an infinite
    while loop for displaying the date and time, sleeping for 5 seconds, and then
    continuing the loop. We will run the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到`pause`/`unpause`的技术解释后，让我们通过一个详细示例来说明这个功能是如何工作的。我们使用了两个屏幕/终端场景。在一个终端上，我们启动了容器，并使用无限循环来显示日期和时间，每隔5秒休眠一次，然后继续循环。我们将运行以下命令：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you are within the container, run the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，运行以下命令：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our little script has very faithfully printed the date and time every `5` seconds
    apart from when it was paused:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小脚本非常忠实地每`5`秒打印一次日期和时间，除非它被暂停：
- en: '![Controlling Docker containers](img/B06455_02_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_07.jpg)'
- en: 'As you can see from the terminal output above, we encountered a delay of around
    30 seconds, because this is when we initiated the `docker container pause` subcommand
    on our container on the second terminal screen, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的终端输出，你可以看到大约有30秒的延迟，因为这时我们在第二个终端屏幕上对容器执行了`docker container pause`子命令，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we paused our container, we looked at the process status by using the
    `docker containerps` subcommand on our container, which was on the same screen,
    and it clearly indicated that the container had been paused, as shown in this
    command result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们暂停容器时，我们通过在相同屏幕上的容器上使用`docker containerps`子命令查看了进程状态，并清楚地指示出容器已被暂停，如下所示的命令结果：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We continued onto issuing the `docker conatiner unpause` subcommand, which
    unfroze our container, continued its execution, and then started printing the
    date and time, as we saw in the preceding command, shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着执行了`docker container unpause`子命令，这个命令解冻了我们的容器，继续执行它，然后开始打印日期和时间，正如我们在前一个命令中看到的，这里展示的是：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We explained the `pause` and the `unpause` commands at the beginning of this
    section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节开始时解释了`pause`和`unpause`命令。
- en: 'Lastly, the container and the script running within it had been stopped by
    using the `docker container stop` subcommand, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，容器和其中运行的脚本通过使用`docker container stop`子命令被停止了，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see everything we ran in our second terminal below:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在第二个终端上执行的所有操作：
- en: '![Controlling Docker containers](img/B06455_02_10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![控制 Docker 容器](img/B06455_02_10.jpg)'
- en: Let's look at doing something a little more complex now.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做点更复杂的操作。
- en: Running a WordPress container
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 WordPress 容器
- en: Almost everyone at some point will have installed, used, or read about WordPress,
    so for our next example, we will be using the official WordPress container from
    the Docker Hub. You can find details on the container at [https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个人在某个时刻都安装过、使用过或读过有关 WordPress 的信息，因此在我们的下一个示例中，我们将使用来自 Docker Hub 的官方 WordPress
    容器。你可以在 [https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/)
    上找到有关该容器的详细信息。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WordPress is web software that you can use to create a beautiful website, blog,
    or app. We like to say that WordPress is both free and priceless at the same time.
    For more information, check out [https://wordpress.org/](https://wordpress.org/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 是一个可以用来创建美丽网站、博客或应用程序的 Web 软件。我们常说 WordPress 既是免费的，也是无价的。如需更多信息，请访问
    [https://wordpress.org/](https://wordpress.org/)。
- en: To launch WordPress, you will need to download and run two containers, the first
    of which is the database container, for this I recommend using the official MySQL
    container which you can find at [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 WordPress，你需要下载并运行两个容器，第一个是数据库容器，建议使用官方的 MySQL 容器，你可以在 [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)
    上找到。
- en: 'To download the latest MySQL container image run the following command on your
    Mac, Windows or Linux machine:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最新的 MySQL 容器镜像，请在你的 Mac、Windows 或 Linux 机器上运行以下命令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that you have the pulled a copy of the image you can launch MySQL by running
    the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拉取了镜像副本，你可以通过运行以下命令启动 MySQL：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The command above launches (`docker container run`) the MySQL in a detached
    state (using `-d`), meaning that it is running in the background, we are calling
    the container `mysql` (`--namewordpress`) and we are using two different environment
    variables (using `-e`) to set the MySQL root password to `wordpress (-e MYSQL_ROOT_PASSWORD=wordpress`)
    and to create a database called `wordpress` (`-e MYSQL_DATABASE=wordpress`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启动了（`docker container run`）MySQL 容器并以分离模式运行（使用 `-d`），意味着它在后台运行，我们将容器命名为
    `mysql`（`--name wordpress`），并且使用两个不同的环境变量（使用 `-e`）将 MySQL 的 root 密码设置为 `wordpress`（`-e
    MYSQL_ROOT_PASSWORD=wordpress`）并创建一个名为 `wordpress` 的数据库（`-e MYSQL_DATABASE=wordpress`）。
- en: 'Once launched, you should receive the container ID. You can check the container
    is running as expected by using the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，你应该会收到容器 ID。你可以通过以下命令检查容器是否按预期运行：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, at this point, although the container is running that doesn't really mean
    that MySQL is ready. If you were to launch your WordPress container now, you might
    find that it runs for a short while and then stops.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然容器正在运行，但这并不意味着 MySQL 已经准备好。如果此时启动你的 WordPress 容器，你可能会发现它运行一段时间后就停止了。
- en: Don't worry, this is expected. As there is no MySQL data within the container
    it takes a little while to get itself into a state where it is available to accept
    incoming connections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，这是预期的。由于容器内没有 MySQL 数据，它需要一些时间才能进入可接受连接的状态。
- en: 'To check the status of your MySQL container you can run the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 MySQL 容器的状态，你可以运行以下命令：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Running a WordPress container](img/B06455_02_11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![运行 WordPress 容器](img/B06455_02_11.jpg)'
- en: 'Once you see the message **mysqld: ready for connections**, you are good to
    launch your WordPress container; you may find yourself having to check the logs
    a few times.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦看到消息 **mysqld: ready for connections**，你就可以启动 WordPress 容器了；你可能需要检查日志几次。'
- en: 'Next up, we to down the WordPress container image; to do this, run the following
    command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要下载 WordPress 容器镜像；为此，请运行以下命令：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once downloaded run the following command to launch the WordPress container:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，运行以下命令启动 WordPress 容器：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, we are launching the container in the background (using `-d`), calling
    the container the `wordpress` (with `--name wordpress`). This is where things
    differ slightly between the MySQL and WordPress containers, we need to let the
    WordPress container know where our MySQL container is accessible, to do this are
    using the link flag (in our case by running `--link mysql:mysql`) this will create
    an alias within the WordPress container pointing it at the IP address of the MySQL
    container.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们是在后台启动容器（使用 `-d`），并将容器命名为 `wordpress`（使用 `--name wordpress`）。在 MySQL
    和 WordPress 容器之间，这里略有不同，我们需要让 WordPress 容器知道我们的 MySQL 容器的可访问位置，为此我们使用了链接标志（在我们的案例中，通过运行
    `--link mysql:mysql`），这将在 WordPress 容器内创建一个别名，将其指向 MySQL 容器的 IP 地址。
- en: Next up we are opening port `8080` on our machine and mapping it to port `80`
    on the container (using `-p 8080:80`) and then letting WordPress know what the
    password is (with `-e WORDPRESS_DB_PASSWORD=wordpress`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在机器上打开 `8080` 端口，并将其映射到容器上的 `80` 端口（使用 `-p 8080:80`），然后让 WordPress 知道密码是什么（使用
    `-e WORDPRESS_DB_PASSWORD=wordpress`）。
- en: 'Check the running containers using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查正在运行的容器：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Should show you that you now have two running containers, MySQL and WordPress:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会显示你现在有两个正在运行的容器，MySQL 和 WordPress：
- en: '![Running a WordPress container](img/B06455_02_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![运行 WordPress 容器](img/B06455_02_12.jpg)'
- en: 'Unlike the MySQL container, there isn''t much the WordPress container needs
    to do before it is accessible, you can check the logs by running the following
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MySQL 容器不同，WordPress 容器在可访问之前需要做的事情不多，你可以通过运行以下命令查看日志：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Running a WordPress container](img/B06455_02_13.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![运行 WordPress 容器](img/B06455_02_13.jpg)'
- en: 'If you open your browser and go to `http://localhost:8080/` you should see
    your WordPress installation sitting at an installation prompt like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器并访问 `http://localhost:8080/`，你应该会看到 WordPress 安装界面，如下所示：
- en: '![Running a WordPress container](img/B06455_02_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![运行 WordPress 容器](img/B06455_02_14.jpg)'
- en: If you like, you can work through the installation and get WordPress up and
    running by clicking on **Continue** and following the onscreen prompts; however,
    the next set of commands we will be running will destroy our two containers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过点击 **继续** 并按照屏幕上的提示完成安装并启动 WordPress；然而，我们接下来要运行的命令会销毁我们的两个容器。
- en: 'To remove everything we have just launched ahead of the next exercise, run
    the following commands:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在下一项练习之前删除我们刚刚启动的所有内容，运行以下命令：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So far we have used the Docker client to easily launch, stop, start, pause,
    unpause and remove containers as well as downloading and removing container images
    from the Docker Hub, while this is great to quickly launch a few containers it
    can get complicated to manage once you have more than a few containers running
    at once, this is where the next tool we are going to look at comes in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Docker 客户端轻松启动、停止、启动、暂停、取消暂停和删除容器，并从 Docker Hub 下载和删除容器镜像。虽然这对于快速启动几个容器来说很不错，但一旦你有多个容器同时运行，它就会变得复杂，这就是我们接下来要介绍的工具派上用场的地方。
- en: Docker Compose
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: If you were following along with the Linux installation in [Chapter 1](ch01.html
    "Chapter 1. Installing Docker Locally"), *Installing Docker Locally* then you
    should have already installed Docker Compose manually, for those of you that skipped
    that part then you will glad to know that Docker Compose is installed and maintained
    as part of Docker for Mac and Windows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟着 [第一章](ch01.html "第1章. 本地安装 Docker")的 Linux 安装步骤一起操作，*本地安装 Docker*，那么你应该已经手动安装了
    Docker Compose；如果你跳过了这一部分，那么你会很高兴地知道，Docker Compose 已作为 Docker for Mac 和 Windows
    的一部分安装和维护。
- en: I am sure that you will agree that so far Docker has proved to be quite intuitive,
    Docker Compose is no different. It started off life as third-party software called
    Fig and was written by Orchard Labs (the project's original website is still available
    at [http://fig.sh/](http://fig.sh/)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你会同意，到目前为止，Docker 已经证明是相当直观的，Docker Compose 也不例外。它最初作为一个名为 Fig 的第三方软件出现，由
    Orchard Labs 编写（该项目的原始网站仍然可以访问：[http://fig.sh/](http://fig.sh/)）。
- en: 'The original project''s goal was the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 原始项目的目标如下：
- en: '"Provide fast, isolated development environments using Docker"'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “使用 Docker 提供快速、隔离的开发环境”
- en: 'Since Orchard Labs became part of Docker, they haven''t strayed too far from
    the original projects goal:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Orchard Labs 已成为 Docker 的一部分，他们并没有偏离原始项目的目标：
- en: '"Compose is a tool for defining and running multi-container Docker applications.
    With Compose, you use a Compose file to configure your application''s services.Then,
    using a single command, you create and start all the services from your configuration."'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。使用 Compose，您可以使用 Compose 文件配置应用程序的服务。然后，通过一个命令，您可以根据配置创建并启动所有服务。”
- en: Before we start looking at Compose files and start containers up, let's think
    of why a tool such as Compose is useful.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看 Compose 文件并启动容器之前，让我们先思考一下为什么像 Compose 这样的工具是有用的。
- en: Why Compose?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 Compose？
- en: 'Launching individual containers is as simple as running the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 启动单独的容器只需要运行以下命令：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will launch and then attach to an Ubuntu container. As we have already
    touched upon, there is a little more to it than just launching simple containers
    though. Docker is not here to replace virtual machines, it is here to run a single
    application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动并连接到一个 Ubuntu 容器。正如我们已经提到的，实际上这不仅仅是启动简单的容器。Docker 不是用来替代虚拟机的，它是用来运行单个应用程序的。
- en: This means that you shouldn't really run an entire LAMP stack in single container,
    instead, you should look at running Apache and PHP in one container, which is
    then linked with a second container running MySQL.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不应该将整个 LAMP 堆栈运行在单个容器中，而应该考虑将 Apache 和 PHP 运行在一个容器中，然后将其与第二个运行 MySQL 的容器链接。
- en: You could take this further, running NGINX container, a PHP-FPM container, and
    a MySQL container. This is where it gets complicated. All of sudden, your simple
    single command for launching a container is now several lines, all of which must
    executed in the correct order with the correct flags to expose ports, link them
    together and configure the services using environment variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步扩展，运行 NGINX 容器、PHP-FPM 容器和 MySQL 容器。这就变得复杂了。突然间，你用来启动容器的简单单行命令变成了好几行，每一行都必须按正确的顺序执行，并带有正确的标志来暴露端口、将它们连接起来并使用环境变量配置服务。
- en: This is exactly the problem Docker Compose tries to fix. Rather than several
    long commands, you can define your containers using a YAML file. This means that
    you will be able to launch your application with a single command and leave the
    logic of the order in which the containers will be launched to Compose.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Docker Compose 尝试解决的问题。你可以使用 YAML 文件定义容器，而不是使用多个长命令。这意味着你只需使用一个命令就能启动应用程序，并将容器启动顺序的逻辑交给
    Compose 来处理。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**YAML Ain''t Markup Language** (**YAML**) is a human-friendly data serialization
    standard for all programming languages.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML 不是标记语言** (**YAML**) 是一种对人类友好的数据序列化标准，适用于所有编程语言。'
- en: It also means that you can ship your application's Compose file with your code
    base or directly to another developer/administrator and they will be able to launch
    your application exactly how you intended it be executed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以将应用程序的 Compose 文件与代码库一起打包，或直接发送给其他开发人员/管理员，他们将能够按照你预期的方式启动你的应用程序。
- en: Compose files
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Compose 文件
- en: 'Let''s start by getting a launching WordPress again. First of all, if you haven''t
    already clone the GitHub repository which accompanies this book. You can find
    it at the following URL: [https://github.com/russmckendrick/bootcamp](https://github.com/russmckendrick/bootcamp)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从再次启动 WordPress 开始。首先，如果你还没有克隆本书附带的 GitHub 仓库，可以在以下 URL 找到它：[https://github.com/russmckendrick/bootcamp](https://github.com/russmckendrick/bootcamp)
- en: 'For more information on how to clone the repository please see the introduction.
    Once you have repo cloned run the following commands from the top level of the
    repo:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解如何克隆仓库的更多信息，请参见简介部分。一旦你克隆了仓库，请从仓库的根目录运行以下命令：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `compose-wordpress` folder contains the following `docker-compose.yml`
    file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose-wordpress` 文件夹包含以下 `docker-compose.yml` 文件：'
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the `docker-compose.yml` file is easy to follow; our initial
    `docker-compose.yml` file is split into three sections:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`docker-compose.yml` 文件易于理解；我们最初的 `docker-compose.yml` 文件分为三个部分：
- en: '**Version**: This tells Docker Compose which file format we are using; the
    current version is 3'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：这告诉 Docker Compose 我们使用的是哪种文件格式；当前版本是 3'
- en: '**Services**: These are where our containers are defined, you can define several
    containers here'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这里定义了我们的容器，你可以在此定义多个容器。'
- en: '**Volumes**: Any volumes for persistent storage are defined here, we will go
    into this in more detail in later chapters'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：所有用于持久存储的卷都在这里定义，我们将在后续章节中详细讲解这一部分。'
- en: 'For the most part, the syntax is pretty similar to that we used to launch our
    WordPress containers using the Docker command-line client. There are, however
    a few changes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，语法与我们使用 Docker 命令行客户端启动 WordPress 容器时非常相似。然而，也有一些变化：
- en: '`volumes`: In the `mysql` container we are taking a volume called `db_data`
    and mounting it to `/var/lib/mysql` within the container'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：在 `mysql` 容器中，我们使用一个名为 `db_data` 的卷，并将其挂载到容器内的 `/var/lib/mysql` 目录。'
- en: '`restart`: This is set to `always,` meaning that if our containers stop responding
    any reason, like the `wordpress` container will do until the `mysql` container
    is accepting connections, then it will be restarted automatically meaning we don''t
    have to manually intervene'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：这个设置为 `always`，意味着如果我们的容器因任何原因停止响应，例如 `wordpress` 容器在 `mysql` 容器接受连接之前会停止运行，它会自动重启，这样我们就不需要手动干预。'
- en: '`depends_on`: Here we are telling the `wordpress` container not to start until
    the `mysql` container is running'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`：在这里，我们告诉 `wordpress` 容器在 `mysql` 容器运行之前不要启动。'
- en: You may notice that we are not linking our containers, this is because Docker
    Compose automatically creates a network to launch the services in, each container
    within the network created by Docker Compose automatically has its host file updated
    to include aliases for each of the containers within the service, meaning that
    our WordPress container will be able to connect to our MySQL container using the
    default host of `mysql`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们没有链接容器，这是因为 Docker Compose 会自动创建一个网络来启动服务，Docker Compose 创建的每个容器都会自动更新主机文件，包括该服务中每个容器的别名，这意味着我们的
    WordPress 容器能够使用默认主机 `mysql` 来连接到 MySQL 容器。
- en: 'To launch our WordPress installation, all we need to do is run the following
    commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的 WordPress 安装，只需要运行以下命令：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the `-d` flag at the end of the command launches the containers in detached
    mode, this means that they will run in the background.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的末尾使用 `-d` 标志会以分离模式启动容器，这意味着它们将在后台运行。
- en: If we didn't use the `-d` flag, then our containers would have launched in the
    foreground and we would not have been able to carry on using the same terminal
    session without stopping the running containers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用 `-d` 标志，那么我们的容器会在前台启动，我们就无法继续使用同一个终端会话，而不停止正在运行的容器。
- en: 'You will see something like the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下输出：
- en: '![Compose files](img/B06455_02_15.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Compose 文件](img/B06455_02_15.jpg)'
- en: 'While the containers are up and running, which you can see by running the follow:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器正在运行时，你可以通过运行以下命令查看：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It will take a short while for the MySQL container to be ready to accept connections,
    you may find running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 容器准备好接受连接会需要一些时间，你可能会发现运行：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Show you connection errors like the ones below:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 会显示类似下面的连接错误：
- en: '![Compose files](img/B06455_02_16.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Compose 文件](img/B06455_02_16.jpg)'
- en: 'Don''t worry, you should soon see something like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，你很快就会看到如下内容：
- en: '![Compose files](img/B06455_02_17.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Compose 文件](img/B06455_02_17.jpg)'
- en: 'Again, opening `http://localhost:8080/` in your browser should show you the
    installation screen:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在浏览器中打开 `http://localhost:8080/` 应该会显示安装界面：
- en: '![Compose files](img/B06455_02_19.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Compose 文件](img/B06455_02_19.jpg)'
- en: 'The process above works on Docker for Mac and on Linux; however for Docker
    for Windows you should add`.exe` to your Docker Compose commands:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程适用于 Docker for Mac 和 Linux；但是对于 Docker for Windows，你需要在 Docker Compose 命令中添加
    `.exe` 后缀：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will give you something like the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你类似以下的输出：
- en: '![Compose files](img/B06455_02_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Compose 文件](img/B06455_02_20.jpg)'
- en: 'Again, opening your browser and going to `http://localhost:8080/` should show
    you the installation screen:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，打开浏览器并访问 `http://localhost:8080/` 应该会显示安装界面：
- en: '![Compose files](img/B06455_02_21.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Compose 文件](img/B06455_02_21.jpg)'
- en: 'Before we move into the next section, let''s stop and remove our WordPress
    containers by running the following commands:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一部分之前，让我们通过运行以下命令停止并删除我们的 WordPress 容器：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or if you are following using Docker for Windows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你正在使用 Docker for Windows：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So far, we have been using images from the Docker Hub, next we will are going
    to take a look at customizing images.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Docker Hub 上的镜像，接下来我们将查看如何自定义镜像。
- en: Docker Build
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 构建
- en: Docker images are the fundamental building blocks of containers. These images
    could be very basic operating environments such, as `alpine` or `Ubuntu`. Or,
    the images could craft advanced application stacks for the enterprise and cloud
    IT environments. An automated approach of crafting Docker images is using a `Dockerfile`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是容器的基本构建块。这些镜像可以是非常基础的操作环境，例如 `alpine` 或 `Ubuntu`。或者，这些镜像也可以为企业和云 IT
    环境构建高级应用栈。自动化构建 Docker 镜像的方法是使用 `Dockerfile`。
- en: A `Dockerfile` is a text-based build script that contains special instructions
    in a sequence for building the right and the relevant images from the base images.
    The sequential instructions inside the `Dockerfile` can include the base image
    selection, installing the required application, adding the configuration and the
    data files, and automatically running the services as well as exposing those services
    to the external world. Thus, a Dockerfile-based automated build system has remarkably
    simplified the image-building process. It also offers a great deal of flexibility
    in the way in which the build instructions are organized and in the way in which
    they visualize the complete build process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 是一个基于文本的构建脚本，包含一系列特殊的指令，用于从基础镜像构建正确且相关的镜像。`Dockerfile` 中的顺序指令可以包括选择基础镜像、安装所需的应用程序、添加配置和数据文件、自动运行服务以及将这些服务暴露给外部世界。因此，基于
    Dockerfile 的自动化构建系统显著简化了镜像构建过程。它还提供了极大的灵活性，能够组织构建指令并可视化整个构建过程。'
- en: The Docker engine tightly integrates this build process with the help of the
    `docker build` subcommand. In the client-server paradigm of Docker, the Docker
    server (or daemon) is responsible for the complete build process and the Docker
    command line interface is responsible for transferring the build context, including
    transferring `Dockerfile` to the daemon.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎通过 `docker build` 子命令紧密集成了这个构建过程。在 Docker 的客户端-服务器模式中，Docker 服务器（或守护进程）负责完整的构建过程，而
    Docker 命令行界面负责传输构建上下文，包括将 `Dockerfile` 传输到守护进程。
- en: To have a sneak peek into the `Dockerfile` integrated build system in this section,
    we introduce you to a basic `Dockerfile`. Then, we explain the steps for converting
    that `Dockerfile` into an image, and then launching a container from that image.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提前了解这一节中集成的 `Dockerfile` 构建系统，我们向您介绍一个基本的 `Dockerfile`。然后，我们将解释如何将该 `Dockerfile`
    转换为镜像，并从该镜像启动容器。
- en: 'Our `Dockerfile` is made up of two instructions, as shown here (there is also
    a copy in the GitHub repo in the `chapter02/build_basic` folder):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Dockerfile` 由两个指令组成，如下所示（在 GitHub 仓库的 `chapter02/build_basic` 文件夹中也有副本）：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following, we cover/discuss the two instructions mentioned earlier:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍/讨论之前提到的两个指令：
- en: The first instruction is for choosing the base image selection. In this example,
    we select the `apline:latest` image.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个指令是选择基础镜像。在这个示例中，我们选择 `apline:latest` 镜像。
- en: The second instruction is for carrying out the command `CMD`, that instructs
    the container to `echo Hello World!!`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个指令是执行 `CMD` 命令，指示容器执行 `echo Hello World!!`。
- en: 'Now, let''s proceed towards generating a Docker image by using the preceding
    `Dockerfile` by calling `dockerimagebuild` along with the path of the `Dockerfile`.
    In our example, we will invoke the `dockerimagebuild` subcommand from the directory
    where we have stored the `Dockerfile,` and the path will be specified by the following
    command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用之前的 `Dockerfile` 来生成 Docker 镜像，方法是调用 `dockerimagebuild` 并指定 `Dockerfile`
    的路径。在我们的示例中，我们将从存储 `Dockerfile` 的目录中调用 `dockerimagebuild` 子命令，路径将由以下命令指定：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After issuing the preceding command, the `build` process will begin by sending
    build context to the daemon and then display the text shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出前面的命令后，`build` 过程将开始，通过将构建上下文发送到守护进程，并显示如下所示的文本：
- en: '**Sending build context to Docker daemon 2.048 kB**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在将构建上下文发送到 Docker 守护进程 2.048 kB**'
- en: '**Step 1/2 : FROM alpine:latest**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 1/2 步：FROM alpine:latest**'
- en: 'The build process will continue and after completing itself, it will display
    the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将继续，完成后将显示以下内容：
- en: '**Successfully built 0080692cf8db**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功构建 0080692cf8db**'
- en: 'In the preceding example, the image was built with `IMAGE ID0a2abe57c325`.
    Let''s use this image to launch a container by using the `docker container run`
    subcommand as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，镜像是使用 `IMAGE ID0a2abe57c325` 构建的。现在让我们使用这个镜像，通过使用 `docker container
    run` 子命令启动一个容器，如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Cool, isn't it? With very little effort, we have been able to craft an image
    with `alpine` as the base image, and we have been able to extend that image to
    produce `Hello World!!`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？通过很少的努力，我们就能以 `alpine` 作为基础镜像构建一个镜像，并且我们已经扩展了这个镜像来输出 `Hello World!!`。
- en: This is a simple application, but the enterprise-scale images can also be realized
    by using the same methodology.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的应用程序，但使用相同的方法也可以实现企业级镜像。
- en: 'Now, let''s look at the image details by using the `dockerimage ls` subcommand.
    Here, you may be surprised to see that the `IMAGE` (`REPOSITORY`) and `TAG` name
    have been listed as `<none>`. This is because we did not specify any image or
    any `TAG` name when we built this image. You could specify an `IMAGE` name and
    optionally a `TAG` name by using the `docker image tag` subcommand, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `docker image ls` 子命令查看镜像的详细信息。在这里，你可能会惊讶地发现 `IMAGE`（`REPOSITORY`）和
    `TAG` 名称显示为 `<none>`。这是因为我们在构建镜像时没有指定任何镜像或 `TAG` 名称。你可以使用 `docker image tag` 子命令来指定
    `IMAGE` 名称，并可选地指定 `TAG` 名称，如下所示：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The alternative approach is to build the image with an image name during the
    `build` time by using the `-t` option for the `docker image build` subcommand,
    as shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在 `build` 期间使用 `-t` 选项通过 `docker image build` 子命令来构建带有镜像名称的镜像，如下所示：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since there is no change in the instructions in `Dockerfile`, the Docker engine
    will efficiently reuse the old image that has `ID0a2abe57c325` and update the
    image name to `basicbuild`. By default, the build system would apply `latest`
    as the `TAG` name. This behavior can be modified by specifying the `TAG` name
    after the `IMAGE` name by having a `:` separator placed in between them. That
    is, `<image name>:<tag name>` is the correct syntax for modifying behaviors, wherein
    `<image name>` is the name of the image and `<tag name>` is the name of the tag.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Dockerfile` 中的指令没有变化，Docker 引擎会高效地复用旧的图像 `ID0a2abe57c325`，并将图像名称更新为 `basicbuild`。默认情况下，构建系统会将
    `latest` 作为 `TAG` 名称。通过在 `IMAGE` 名称和 `TAG` 名称之间添加 `:` 分隔符，可以修改这种行为。也就是说，`<image
    name>:<tag name>` 是修改行为的正确语法，其中 `<image name>` 是镜像的名称，`<tag name>` 是标签的名称。
- en: Once again, let's look at the image details by using the `docker image ls` subcommand,
    and you will notice that the image (Repository) name is `basicimage` and the tag
    name is `latest`. Building images with an image name is always recommended as
    the best practice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `docker image ls` 子命令查看镜像的详细信息，你会注意到镜像（存储库）名称为 `basicimage`，标签名称为 `latest`。最好实践是始终使用镜像名称来构建镜像。
- en: Having experienced the magic of `Dockerfile`, in the subsequent sections, we
    will introduce you to the syntax or the format of `Dockerfile` and explain a dozen
    `Dockerfile` instructions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在体验了 `Dockerfile` 的魔力之后，在接下来的章节中，我们将介绍 `Dockerfile` 的语法或格式，并解释十几条 `Dockerfile`
    指令。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default `docker image build` subcommand uses the `Dockerfile` located at
    the build context. However `–f` option `docker image build` subcommand let's to
    specify an alternate `Dockerfile` in a different path or name.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker image build` 子命令使用位于构建上下文中的 `Dockerfile`。但是，`–f` 选项允许 `docker
    image build` 子命令指定一个路径或名称不同的替代 `Dockerfile`。
- en: A quick overview of the Dockerfile's syntax
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 语法概述
- en: 'In this section, we explain the syntax or the format of `Dockerfile`. A `Dockerfile`
    is made up of instructions, comments, parser directives and empty lines, as shown
    here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释 `Dockerfile` 的语法或格式。一个 `Dockerfile` 由指令、注释、解析器指令和空行组成，如下所示：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The instruction line of `Dockerfile` is made up of two components, where the
    instruction line begins with the instruction itself, which is followed by the
    arguments for the instruction. The instruction could be written in any case, in
    other words, it is case-insensitive. However, the standard practice or the convention
    is to use *uppercase* to differentiate it from the arguments. Let''s take a relook
    at the content of `Dockerfile` in our previous example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 的指令行由两个部分组成，指令行以指令本身开始，后面跟着该指令的参数。指令可以用任何大小写书写，换句话说，它对大小写不敏感。然而，标准做法或约定是使用
    *大写字母* 来区分指令和参数。让我们重新查看之前示例中 `Dockerfile` 的内容：'
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `FROM` is an instruction which has taken `apline:latest` as an argument,
    and `CMD` is an instruction which has taken `echo Hello World!!` as an argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`FROM` 是一个指令，它以 `apline:latest` 作为参数，而 `CMD` 是一个指令，它以 `echo Hello World!!`
    作为参数。
- en: The comment line
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释行
- en: 'The comment line in `Dockerfile` must begin with the `#` symbol. The `#` symbol
    after an instruction is considered as an argument. If the `#` symbol is preceded
    by a whitespace, then the `docker image build` system would consider that as an
    unknown instruction and skip the line. Now, let''s understand the preceding cases
    with the help of an example to get a better understanding of the comment line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 中的注释行必须以 `#` 符号开始。指令后的 `#` 符号被视为参数。如果 `#` 符号前有空格，则 `docker image
    build` 系统会将其视为未知指令并跳过该行。现在，让我们通过一个示例来理解前述情况，以更好地理解注释行：'
- en: 'A valid `Dockerfile` comment line always begins with a `#` symbol as the first
    character of the line:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的 `Dockerfile` 注释行总是以 `#` 符号作为行首字符：
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `#` symbol can be a part of an argument:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#` 符号可以是参数的一部分：'
- en: '[PRE40]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the `#` symbol is preceded by a whitespace, then it is considered as an
    unknown instruction by the build system:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `#` 符号前有空格，则构建系统会将其视为未知指令：
- en: '[PRE41]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A sample `Dockerfile` can be found at `/chapter02/build_basic/` in the repo:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在仓库中的 `/chapter02/build_basic/` 找到一个示例 `Dockerfile`：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `docker image build` system ignores any empty line in the `Dockerfile` and
    hence, the author of `Dockerfile` is encouraged to add comments and empty lines
    to substantially improve the readability of `Dockerfile`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image build` 系统会忽略 `Dockerfile` 中的空行，因此，建议 `Dockerfile` 的作者添加注释和空行，以大幅提升
    `Dockerfile` 的可读性。'
- en: The parser directives
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器指令
- en: As the name implies, the parser directives instruct the `Dockerfile` parser
    to handle the content of the `Dockerfile` as specified in the directives. The
    parser directives are optional and they must be at the very top of a `Dockerfile`.
    Currently escape is the only supported directive.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，解析器指令指示 `Dockerfile` 解析器按指令中指定的方式处理 `Dockerfile` 的内容。解析器指令是可选的，并且必须位于
    `Dockerfile` 的最顶部。目前，转义是唯一支持的指令。
- en: 'We use escape character to escape characters in a line or to extend a single
    line to multiple lines. On a UNIX like platform, `\` is the escape character whereas
    on windows \ is a directory path separator and `''` is the escape character. By
    default, `Dockerfile` parser considers `\` as the escape character and you could
    override this on windows using the escape parser directive as shown below:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用转义字符来转义一行中的字符，或将一行扩展为多行。在类似 UNIX 的平台中，`\` 是转义字符，而在 Windows 中，`\` 是目录路径分隔符，`'`
    是转义字符。默认情况下，`Dockerfile` 解析器将 `\` 视为转义字符，您也可以在 Windows 上使用转义解析器指令来覆盖这一行为，如下所示：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Dockerfile build instructions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Dockerfile` 构建指令'
- en: So far, we have looked at the integrated build system, the `Dockerfile` syntax
    and a sample lifecycle, wherein how a sample `Dockerfile` is leveraged for generating
    an image and how a container gets spun off from that image was discussed. In this
    section, we will introduce the `Dockerfile` instructions, their syntax, and a
    few befitting examples.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了集成的构建系统、`Dockerfile` 语法和示例生命周期，其中讨论了如何利用示例 `Dockerfile` 生成镜像，以及如何从该镜像启动容器。在本节中，我们将介绍
    `Dockerfile` 指令、它们的语法以及一些适用的示例。
- en: The FROM instruction
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`FROM` 指令'
- en: The `FROM` instruction is the most important one and it is the first valid instruction
    of a `Dockerfile`. It sets the base image for the build process. The subsequent
    instructions will use this base image and build on top of it. The Docker build
    system lets you flexibly use the images built by anyone. You can also extend them
    by adding more precise and practical features to them. By default, the Docker
    build system looks in the Docker host for the images.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令是最重要的，它是 `Dockerfile` 中的第一个有效指令。它为构建过程设置了基础镜像。随后的指令将以此基础镜像为基础进行构建。Docker
    构建系统允许灵活使用任何人构建的镜像。您还可以通过为它们添加更精确和实用的功能来扩展它们。默认情况下，Docker 构建系统会在 Docker 主机中查找镜像。'
- en: However, if the image is not found in the Docker host, then the Docker build
    system will pull the image from the publicly available Docker Hub Registry. The
    Docker build system will return an error if it cannot find the specified image
    in the Docker host and the Docker Hub Registry.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在 Docker 主机中找不到镜像，则 Docker 构建系统将从公开的 Docker Hub 仓库拉取该镜像。如果在 Docker 主机和
    Docker Hub 仓库中都找不到指定的镜像，Docker 构建系统将返回错误。
- en: 'The `FROM` instruction has the following syntax:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令的语法如下：'
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code statement, note the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码语句中，注意以下几点：
- en: '`<image>`: This is the name of the image which will be used as the base image.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<image>`：这是将用作基础镜像的镜像名称。'
- en: '`<tag>` or`<digest>`: Both tag and digest are optional attributes and you could
    qualify a particular Docker image version using either a tag or a digest. Tag
    `latest` is assumed by default if both tag and digest are not present.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tag>` 或 `<digest>`：标签和摘要都是可选属性，您可以使用标签或摘要来指定特定的 Docker 镜像版本。如果标签和摘要都不存在，则默认假定标签为
    `latest`。'
- en: 'Here is an example of the `FROM` instruction with the image name `centos`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用镜像名称 `centos` 的 `FROM` 指令的示例：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the above example, the Docker build system would implicitly default to tag
    `latest` because neither a tag nor a digest is explicitly added to the image name.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，Docker 构建系统会隐式地默认标签为 `latest`，因为镜像名称中既没有标签也没有摘要。
- en: You should be strongly discouraged from using multiple `FROM` instructions in
    a single `Dockerfile`, as damaging conflicts could arise.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议不要在单个 `Dockerfile` 中使用多个 `FROM` 指令，因为可能会引起破坏性冲突。
- en: The MAINTAINER instruction
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAINTAINER 指令
- en: All the `MAINTAINER` instruction does is enables the authors' details to set
    the in an image. Docker does not place any restrictions on placing the `MAINTAINER`
    instruction in a `Dockerfile`. However, it is strongly recommended that you should
    place it after the `FROM` instruction.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `MAINTAINER` 指令所做的就是允许将作者的详细信息设置为一个镜像。Docker 不会对在 `Dockerfile` 中放置 `MAINTAINER`
    指令的位置施加任何限制。但是，强烈建议在 `FROM` 指令之后放置它。
- en: 'The following is the syntax of the `MAINTAINER` instruction, where `<author''s
    detail>` can be in any text. However, it is strongly recommended that you should
    use the image, author''s name and the e-mail address as shown in this code syntax:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `MAINTAINER` 指令的语法，其中 `<author's detail>` 可以是任何文本。然而，强烈建议使用如下代码语法中显示的镜像、作者姓名和电子邮件地址：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There is an example of the `MAINTAINER` instruction with the author name, and
    the e-mail address at `/chapter02/build_01_maintainer/` in the repo:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 repo 中的 `/chapter02/build_01_maintainer/` 下有一个带有作者姓名和电子邮件地址的 `MAINTAINER`
    指令示例：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The RUN instruction
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RUN 指令
- en: The `RUN` instruction is the real workhorse during the build time, and it can
    run any command. The general recommendation is to execute the multiple commands
    by using one `RUN` instruction. This reduces the layers in the resulting Docker
    image because the Docker system inherently creates a layer for each time an instruction
    is called in `Dockerfile`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 指令是构建时的真正工作马，可以运行任何命令。一般建议使用一个 `RUN` 指令执行多个命令。这样可以减少生成的 Docker 镜像中的层数，因为
    Docker 系统会为 `Dockerfile` 中每次调用指令创建一个层。'
- en: 'The `RUN` instruction has two types of syntax:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 指令有两种语法：'
- en: 'The first is the shell type, as shown here:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是 shell 类型，如下所示：
- en: '[PRE48]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the `<command>` is the shell command that has to be executed during the
    build time. If this type of syntax is to be used, then the command is always executed
    by using `/bin/sh -c`.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`<command>` 是在构建时执行的 shell 命令。如果要使用这种语法类型，则始终使用 `/bin/sh -c` 执行命令。
- en: 'The second syntax type is either exec or the JSON array, as shown here:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语法类型可以是 exec 或 JSON 数组，如下所示：
- en: '[PRE49]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Wherein, the code terms mean the following:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，代码术语的含义如下：
- en: '`<exec>`: This is the executable to run during the build time.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exec>`：这是在构建时运行的可执行文件。'
- en: '`<arg-1>, ..., <arg-n>`: These are the variables (zero or more) number of the
    arguments for the executable.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是可执行文件的变量（零个或多个）数目的参数。'
- en: Unlike the first type of syntax, this type does not invoke `/bin/sh -c`. Hence,
    the types of shell processing, such as the variable substitution (`$USER`) and
    the wild card substitution (`*`, `?`), do not happen in this type. If shell processing
    is critical for you, then you are encouraged to use the shell type. However, if
    you still prefer the exec (JSON array type) type, then use your preferred shell
    as the executable and supply the command as an argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一种语法类型不同，这种类型不会调用 `/bin/sh -c`。因此，不会发生像变量替换（`$USER`）和通配符替换（`*`，`?`）这样的 shell
    处理。如果对 shell 处理非常重要，请使用 shell 类型。但是，如果您仍然喜欢 exec（JSON 数组类型），那么请使用您偏爱的 shell 作为可执行文件，并将命令作为参数提供。
- en: For example, `RUN ["bash", "-c", "rm", "-rf", "/tmp/abc"]`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`RUN ["bash", "-c", "rm", "-rf", "/tmp/abc"]`。
- en: 'Let''s add a few `RUN` instructions to our `Dockerfile` to install NGINX using
    `apk` and then set some permissions:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的 `Dockerfile` 添加一些 `RUN` 指令，使用 `apk` 安装 NGINX，然后设置一些权限：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, we are installing NGINX and Supervisor. The `&&` has been added
    so that we can string several commands together on a single line, as each line
    within the `Dockerfile` creates a layer within the image stringing commands together
    like this streamlines your image file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在安装 NGINX 和 Supervisor。已添加 `&&` 以便将多个命令合并成一行，因为 `Dockerfile` 中的每一行都会在镜像中创建一个层，将命令合并在一起可以简化你的镜像文件。
- en: The COPY instruction
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`COPY` 指令'
- en: 'The `COPY` instruction enables you to copy the files from your Docker host
    to the filesystem of the image you are building. The following is the syntax of
    the `COPY` instruction:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令允许你将文件从 Docker 主机复制到你正在构建的镜像的文件系统中。以下是 `COPY` 指令的语法：'
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding code terms bear the explanations shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码术语有如下解释：
- en: '`<src>`: This is the source directory, the file in the build context, or the
    directory from where the `docker build` subcommand was invoked.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>`：这是源目录，构建上下文中的文件，或者是执行 `docker build` 子命令的目录。'
- en: '`...`: This indicates that multiple source files can either be specified directly
    or be specified by wildcards.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...`：这表示可以直接指定多个源文件，也可以通过通配符指定。'
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will get copied. If multiple files have been specified, then
    the destination path must be a directory and it must end with a slash `/`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dst>`：这是新镜像中的目标路径，源文件或目录将被复制到该路径。如果指定了多个文件，则目标路径必须是一个目录，并且必须以斜杠 `/` 结尾。'
- en: Using an absolute path for the destination directory or a file has been recommended.
    In the absence of an absolute path, the `COPY` instruction will assume that the
    destination path will start from root `/`. The `COPY` instruction is powerful
    enough for creating a new directory and for overwriting the filesystem in the
    newly created image.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用绝对路径作为目标目录或文件。如果没有使用绝对路径，`COPY` 指令将假定目标路径从根目录 `/` 开始。`COPY` 指令足够强大，能够创建新目录并覆盖新创建镜像中的文件系统。
- en: 'An example of the `copy` command can be found in the repo ([https://github.com/russmckendrick/bootcamp](https://github.com/russmckendrick/bootcamp))
    at `/chapter02/build_03_copy/`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 命令的示例可以在仓库（[https://github.com/russmckendrick/bootcamp](https://github.com/russmckendrick/bootcamp)）中的
    `/chapter02/build_03_copy/` 找到：'
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This copies the `start.sh` file to the folder in the Docker image at`/script/`and
    the configuration file from the `files` folder to in place on the image.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `start.sh` 文件复制到 Docker 镜像中的 `/script/` 文件夹，并将 `files` 文件夹中的配置文件直接复制到镜像中。
- en: The ADD instruction
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ADD` 指令'
- en: The `ADD` instruction is like the `COPY` instruction. However, in addition to
    the functionality supported by the `COPY` instruction, the `ADD` instruction can
    handle the TAR files and the remote URLs. We can annotate the `ADD` instruction
    as `COPY` on steroids.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 指令类似于 `COPY` 指令。然而，除了支持 `COPY` 指令的功能外，`ADD` 指令还可以处理 TAR 文件和远程 URL。我们可以将
    `ADD` 指令注释为“增强版的 `COPY`”。'
- en: 'The following is the syntax of the `ADD` instruction:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `ADD` 指令的语法：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The arguments of the `ADD` instruction are very similar to those of the `COPY`
    instruction, as shown here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 指令的参数与 `COPY` 指令非常相似，如下所示：'
- en: '`<src>`: This is either the source directory or the file that is in the build
    context or in the directory from where the `docker build` subcommand will be invoked.
    However, the noteworthy difference is that the source can either be a `tar` file
    stored in the build context or be a remote URL.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>`：这是构建上下文中的源目录或文件，或者是执行 `docker build` 子命令的目录。然而，值得注意的区别是，源文件可以是构建上下文中的
    `tar` 文件，也可以是远程 URL。'
- en: '`...`: This indicates that the multiple source files can either be specified
    directly or be specified by using wildcards.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...`：这表示多个源文件可以通过直接指定或使用通配符指定。'
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will be copied.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dst>`：这是新镜像中的目标路径，源文件或目录将被复制到该路径。'
- en: 'Here is an example for demonstrating the procedure for copying multiple source
    files to the various destination directories in the target image filesystem. In
    this example, we have taken a TAR file (`webroot.tar`) in the source build context
    with the `http` daemon configuration file and the files for the web pages are
    stored in the appropriate directory structure, as shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示如何将多个源文件复制到目标镜像文件系统的各个目标目录中。在此示例中，我们使用了一个 TAR 文件（`webroot.tar`），其中包含了
    `http` 守护进程配置文件和存储在适当目录结构中的网页文件，如下所示：
- en: '![The ADD instruction](img/B06455_02_25.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![ADD 指令](img/B06455_02_25.jpg)'
- en: 'The next line in the `Dockerfile` content has an `ADD` instruction for copying
    the TAR file (`webroot.tar`) to the target image and extracting the TAR file from
    the root directory (`/`) of the target image, as shown here in the example you
    can find in the repo at `/chapter02/build_04_add/`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 中的下一行包含 `ADD` 指令，用于将 TAR 文件（`webroot.tar`）复制到目标镜像并从目标镜像的根目录（`/`）提取该
    TAR 文件，如下所示，你可以在仓库中的 `/chapter02/build_04_add/` 找到此示例：'
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Thus, the TAR option of the `ADD` instruction can be used for copying multiples
    files to the target image, also note we have added a second `RUN` instruction
    to set the permissions on the folder we have just created using `ADD`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ADD` 指令的 TAR 选项可以用于将多个文件复制到目标镜像中，同时请注意，我们已经添加了第二个 `RUN` 指令，用于设置我们刚刚使用 `ADD`
    创建的文件夹的权限。
- en: The EXPOSE instruction
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令'
- en: The `EXPOSE` instruction opens up a container network port for communicating
    between the container and the rest of the network.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令打开一个容器网络端口，用于容器与其他网络之间的通信。'
- en: 'The syntax of the `EXPOSE` instruction is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令的语法如下：'
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, the code terms mean the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码术语的含义如下：
- en: '`<port>`: This is the network port that has to be exposed to the outside world.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<port>`：这是需要暴露给外界的网络端口。'
- en: '`<proto>`: This is an optional field provided for a specific transport protocol,
    such as TCP and UDP. If no transport protocol has been specified, then TCP is
    assumed to be the transport protocol.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<proto>`：这是一个可选字段，用于指定特定的传输协议，如 TCP 和 UDP。如果未指定传输协议，则默认使用 TCP 协议。'
- en: The `EXPOSE` instruction allows you to specify multiple ports in a single line.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令允许你在一行中指定多个端口。'
- en: 'The following is an example of the `EXPOSE` instruction inside a `Dockerfile`
    exposing port `80`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `Dockerfile` 中使用 `EXPOSE` 指令暴露 `80` 端口的示例：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The ENTRYPOINT instruction
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 指令'
- en: The `ENTRYPOINT` instruction will help in crafting an image for running an application
    (entry point) during the complete lifecycle of the container, which would have
    been spun out of the image. When the entry point application is terminated, the
    container would also be terminated along with the application and vice versa.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 指令有助于在容器的整个生命周期内构建运行应用程序（入口点）的镜像，该容器是从该镜像中创建的。当入口点应用程序终止时，容器也会与应用程序一起终止，反之亦然。'
- en: Thus, the `ENTRYPOINT` instruction would make the container function like an
    executable. Functionally, `ENTRYPOINT` is akin to the `CMD` instruction which
    we will look at next, but the major difference between the two is that the entry
    point application is launched by using the `ENTRYPOINT` instruction, which cannot
    be overridden by using the `docker run` subcommand arguments.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ENTRYPOINT` 指令使得容器像可执行文件一样运行。从功能上讲，`ENTRYPOINT` 类似于接下来要讲解的 `CMD` 指令，但两者的主要区别在于，使用
    `ENTRYPOINT` 指令启动的入口点应用程序不能通过 `docker run` 子命令的参数来覆盖。
- en: However, these `docker container run` subcommand arguments will be passed as
    additional arguments to the entry point application. Having said this, Docker
    provides a mechanism for overriding the entry point application through the `--entrypoint`
    option in the `docker container run` subcommand. The `--entrypoint` option can
    accept only word as its argument and hence, it has limited functionality.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些 `docker container run` 子命令的参数将作为额外的参数传递给入口点应用程序。话虽如此，Docker 提供了一种机制，可以通过
    `docker container run` 子命令中的 `--entrypoint` 选项覆盖入口点应用程序。`--entrypoint` 选项只能接受一个单词作为其参数，因此功能有限。
- en: 'Syntactically, the `ENTRYPOINT` instruction is very similar to the `RUN`, and
    the `CMD` instructions, and it has two types of syntax, as shown here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上看，`ENTRYPOINT` 指令与 `RUN` 和 `CMD` 指令非常相似，且具有两种语法形式，如下所示：
- en: 'The first type of syntax is the shell type, as shown here:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种语法是 shell 类型，如下所示：
- en: '[PRE57]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, `<command>` is the shell command, which is executed during the launch
    of the container. If this type of syntax is used, then the command is always executed
    by using `/bin/sh -c`.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`<command>` 是容器启动时执行的 shell 命令。如果使用这种语法，则命令总是通过 `/bin/sh -c` 执行。
- en: 'The second type of syntax is `exec` or the JSON array, as shown here:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语法是 `exec` 或 JSON 数组，如下所示：
- en: '[PRE58]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Wherein, the code terms mean the following:'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，代码术语表示以下内容：
- en: '`<exec>`: This is the executable, which has to be run during the container
    launch time.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exec>`：这是可执行文件，它需要在容器启动时运行。'
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) number of arguments
    for the executable.'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是可执行文件的可变（零个或多个）参数。'
- en: Syntactically, you can have more than one `ENTRYPOINT` instruction in a `Dockerfile`.
    However, the build system will ignore all the `ENTRYPOINT` instructions except
    the last one. In other words, in the case of multiple `ENTRYPOINT` instructions,
    only the last `ENTRYPOINT` instruction be effective.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上看，你可以在 `Dockerfile` 中有多个 `ENTRYPOINT` 指令。然而，构建系统只会忽略除最后一个之外的所有 `ENTRYPOINT`
    指令。换句话说，如果有多个 `ENTRYPOINT` 指令，只有最后一个 `ENTRYPOINT` 指令会生效。
- en: 'As you may recall from when we covered the `RUN` instruction we installed a
    service called `supervisord`, we will be using this for the entry point in our
    image meaning that our `Dockerfile` now looks like the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，我们在介绍 `RUN` 指令时安装了一个名为 `supervisord` 的服务，我们将使用这个服务作为镜像的入口点，这意味着我们的 `Dockerfile`
    现在看起来如下：
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now we could leave it here and the image would be functional, however there
    is one instruction we should pass to our image.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把它留在这里，镜像就可以正常工作了，不过我们应该传递给镜像一个指令。
- en: The CMD instruction
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CMD` 指令'
- en: The `CMD` instruction can run any command (or application), which is similar
    to the `RUN` instruction. However, the major difference between those two is the
    time of execution. The command supplied through the `RUN` instruction is executed
    during the build time, whereas the command specified through the `CMD` instruction
    is executed when the container is launched from the newly created image. Thus,
    the `CMD` instruction provides a default execution for this container. However,
    it can be overridden by the `docker run` subcommand arguments. When the application
    terminates, the container will also terminate along with the application and vice
    versa.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 指令可以运行任何命令（或应用程序），这与 `RUN` 指令类似。然而，这两者之间的主要区别在于执行时间。通过 `RUN` 指令传递的命令在构建时执行，而通过
    `CMD` 指令指定的命令在从新创建的镜像启动容器时执行。因此，`CMD` 指令为容器提供了默认的执行方式。然而，可以通过 `docker run` 子命令的参数覆盖该默认行为。当应用程序终止时，容器也会随着应用程序一起终止，反之亦然。'
- en: On the face of it the `CMD` instruction is very similar to the `RUN` instruction
    in that it can run any command passed to it, however there is a major difference
    between the two instructions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，`CMD` 指令与 `RUN` 指令非常相似，因为它们都可以运行传递给它的任何命令，然而，这两个指令之间有一个主要区别。
- en: The command passed to the `RUN` instruction is executed at build time and commands
    passed using the `CMD` instruction are executed at run time meaning you can define
    the default execution for the container. This means if no command is passed during
    the `docker container run` command then the CMD will executed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `RUN` 指令传递的命令在构建时执行，而通过 `CMD` 指令传递的命令在运行时执行，这意味着你可以为容器定义默认的执行命令。这意味着如果在执行
    `docker container run` 命令时没有传递命令，则会执行 `CMD`。
- en: 'The `CMD` instruction has three types of syntax, as shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 指令有三种语法类型，如下所示：'
- en: 'The first syntax type is the shell type, as shown here:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种语法类型是 shell 类型，如下所示：
- en: '[PRE60]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Wherein, the `<command>` is the shell command, which has to be executed during
    the launch of the container. If this type of syntax is used, then the command
    is always executed by using `/bin/sh -c`.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，`<command>` 是需要在容器启动时执行的 shell 命令。如果使用这种语法，则命令总是通过 `/bin/sh -c` 执行。
- en: 'The second type of syntax is exec or the JSON array, as shown here:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语法是 exec 或 JSON 数组，如下所示：
- en: '[PRE61]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Wherein, the code terms mean the following:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，代码术语表示以下内容：
- en: '`<exec>`: This is the executable, which is to be run during the container launch
    time'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exec>`：这是需要在容器启动时运行的可执行文件。'
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) number of the
    arguments for the executable'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是可执行文件的可变（零个或多个）参数。'
- en: 'The third type of syntax is also exec or the JSON array, which is similar to
    the previous type. However, this type is used for setting the default parameters
    to the `ENTRYPOINT` instruction, as shown here:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种语法类型也是exec或JSON数组，类似于前一种类型。然而，这种类型用于为`ENTRYPOINT`指令设置默认参数，如下所示：
- en: '[PRE62]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Wherein, the code terms mean the following:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，代码术语的含义如下：
- en: '`<arg-1>, ..., <arg-n>`: These are the variables (zero or more) number of the
    arguments for the `ENTRYPOINT` instruction, which will be explained in the next
    section.'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是`ENTRYPOINT`指令的变量（零个或多个）参数，将在下一节中解释。'
- en: Syntactically, you can add more than one `CMD` instruction in `Dockerfile`.
    However the build system would ignore all the `CMD` instructions except for the
    last one. In other words, in the case of multiple `CMD` instructions, only the
    last `CMD` instruction would be effective.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，你可以在`Dockerfile`中添加多个`CMD`指令。然而，构建系统会忽略所有`CMD`指令，除了最后一个。换句话说，在多个`CMD`指令的情况下，只有最后一个`CMD`指令会生效。
- en: 'As mentioned in the previous section, our `Dockerfile` could have been run
    with just the `ENTRYPOINT` instruction defined, however that would give a non-breaking
    error when `supervisiord` starts up so let''s pass a flag which defines where
    our supervisor configuration file is using the `CMD` instruction:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，我们的`Dockerfile`本来只需要定义`ENTRYPOINT`指令就可以运行，但这会在`supervisord`启动时产生一个非致命错误，因此我们通过`CMD`指令传递一个标志，来定义我们的supervisor配置文件的位置：
- en: '[PRE63]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We are now in a position where we can build our image, you can find our completed
    `Dockerfile` in the `/chapter02/` `build_07_cmd/` folder in the repo, to build
    the image simple run the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建我们的镜像，你可以在仓库的`/chapter02/` `build_07_cmd/`文件夹中找到我们完成的`Dockerfile`，要构建镜像，只需运行以下命令：
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This will kick of the build, as you can see from the following terminal:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始构建，如下所示的终端输出：
- en: '![The CMD instruction](img/B06455_02_26.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![CMD指令](img/B06455_02_26.jpg)'
- en: 'There are 12 steps in the build, it will take a minute or two, but once compete
    you should see something like the following terminal output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 构建中有12个步骤，可能需要一两分钟，但是一旦完成，你应该会看到类似以下的终端输出：
- en: '![The CMD instruction](img/B06455_02_27.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![CMD指令](img/B06455_02_27.jpg)'
- en: 'Once you have your image built, you can check and then run it by using the
    following commands:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建好镜像，你可以通过以下命令检查并运行它：
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![The CMD instruction](img/B06455_02_28.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![CMD指令](img/B06455_02_28.jpg)'
- en: 'Now the container is running, opening your browser and going `http://localho`
    `st:8080/` should show you something like the following page:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在容器正在运行，打开浏览器并访问`http://localho` `st:8080/`，应该会显示类似以下的页面：
- en: '![The CMD instruction](img/B06455_02_29.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![CMD指令](img/B06455_02_29.jpg)'
- en: 'There you have it, we have created an image:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们创建了一个镜像：
- en: Using the Alpine Linux base (`FROM`)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Alpine Linux基础镜像（`FROM`）
- en: Installed `NGINX` and `supervisord` using `apk` (`RUN`)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`apk`安装了`NGINX`和`supervisord`（`RUN`）
- en: Copied the configuration from our Docker host to the image (`COPY`)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置从我们的Docker主机复制到镜像中（`COPY`）
- en: Uploaded and extracting our web root (`ADD`)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传并提取我们的网页根目录（`ADD`）
- en: Set the correct ownership of our web root (`RUN`)
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置了我们网页根目录的正确所有权（`RUN`）
- en: Ensured that port `80` on the container is open (`EXPOSE`)
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保容器的`80`端口是开放的（`EXPOSE`）
- en: Made sure that `supervisord` is the default process (`ENTRYPOINT`)
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`supervisord`是默认进程（`ENTRYPOINT`）
- en: Passed the configuration file flag to `supervisord` (`CMD`)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置文件标志传递给`supervisord`（`CMD`）
- en: 'Before moving onto the next section you can stop and remove the container by
    running the following command making sure you replace the container ID with that
    of yours:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，你可以通过运行以下命令停止并删除容器，确保将容器ID替换为你自己的ID：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then remove the image we created by running:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令删除我们创建的镜像：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, we are going to go back to our WordPress image and customize it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到我们的WordPress镜像并对其进行自定义。
- en: Customizing existing images
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义现有镜像
- en: While the official images should provide you with a fully functioning usable
    image you may sometimes need to install additional software, in this case we are
    going to look at installing WordPress CLI using the official WordPress image.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然官方镜像应该为你提供一个完全可用的镜像，但有时你可能需要安装额外的软件，在这种情况下，我们将使用官方WordPress镜像来安装WordPress
    CLI。
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WordPress CLI is a set of command line tools which allow you to manage your
    WordPress configuration and installation; for more information, see [http://wp-cli.org/](http://wp-cli.org/).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress CLI 是一组命令行工具，允许您管理 WordPress 配置和安装；欲了解更多信息，请参见 [http://wp-cli.org/](http://wp-cli.org/)。
- en: 'You can find a copy of the `Dockerfile` below in the `/chapter02/wordpress-custom/`
    folder in the repo, as you can see we are just running `RUN` and `COPY`instructions:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在仓库中的`/chapter02/wordpress-custom/`文件夹中找到`Dockerfile`的副本，如您所见，我们只是在运行`RUN`和`COPY`指令：
- en: '[PRE68]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can build the image using the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令构建镜像：
- en: '[PRE69]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Once it has finished building use the following command to check the image:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，使用以下命令检查镜像：
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'However, as we discovered earlier in this chapter it is easier to launch WordPress
    using Docker Compose, before we do lets remove the image we just built by running:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在本章早些时候发现的，使用 Docker Compose 启动 WordPress 更为简单，在我们执行此操作之前，先通过运行以下命令删除我们刚刚构建的镜像：
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Docker Compose can also trigger builds. Our updated `docker-compose.yml` file
    can be found in the `/chapter02/wordpress-custom/` folder and below:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 还可以触发构建。我们更新后的`docker-compose.yml`文件位于`/chapter02/wordpress-custom/`文件夹中，见下文：
- en: '[PRE72]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, it is almost exactly the same as our original `docker-compose.yml`
    apart from now we have a line that says `build: ./`" rather than `image: wordpress`".'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，它与我们原始的`docker-compose.yml`几乎完全相同，唯一的不同是现在我们有一行代码`build: ./`，而不是`image:
    wordpress`。'
- en: 'To launch our WordPress installation, we simply need to run the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的 WordPress 安装，我们只需运行以下命令：
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This will pull and build the container images, once complete you should see
    something like the following in your terminal:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拉取并构建容器镜像，完成后，您应该在终端看到类似以下的输出：
- en: '![Customizing existing images](img/B06455_02_32.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![自定义现有图片](img/B06455_02_32.jpg)'
- en: Going to `http://localhost:8080/` should show you the installation screen, however,
    we are going to typing a few commands to configure WordPress using the WordPress
    CLI.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/`应该会显示安装屏幕，但我们将输入一些命令来通过 WordPress CLI 配置 WordPress。
- en: 'First, let''s check the version of WordPress we are working with by running:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过运行以下命令检查我们正在使用的 WordPress 版本：
- en: '[PRE74]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This will connect to the WordPress service and run the `wp core version` command,
    then return the output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接到 WordPress 服务并运行`wp core version`命令，然后返回输出：
- en: '![Customizing existing images](img/B06455_02_33.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![自定义现有图片](img/B06455_02_33.jpg)'
- en: 'Next, we are going to install WordPress using the `wp core install` command,
    change the `title`, `admin_user`, `admin_password` and `admin_email` values as
    you like:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`wp core install`命令安装WordPress，并根据需要更改`title`、`admin_user`、`admin_password`和`admin_email`的值：
- en: '[PRE75]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Once the command has finished running you should receive a message saying **Success:
    WordPress installed successfully**:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令运行完成后，您应该会收到一条消息，显示**成功：WordPress 安装成功**：
- en: '![Customizing existing images](img/B06455_02_34.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![自定义现有图片](img/B06455_02_34.jpg)'
- en: 'Going to `http://localhost:8080/` should show you a WordPress site rather than
    an installation prompt:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/`应该会显示一个 WordPress 网站，而不是安装提示：
- en: '![Customizing existing images](img/B06455_02_35.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![自定义现有图片](img/B06455_02_35.jpg)'
- en: 'Once you have finished with your WordPress installation you can stop and remove
    it by running:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 WordPress 安装后，您可以通过运行以下命令停止并删除它：
- en: '[PRE76]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now we know how to build an image we are going to look at a few different ways
    to share them.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何构建镜像了，我们将探讨几种不同的共享方法。
- en: Sharing your images
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享你的镜像
- en: The Docker Hub is a central place used for keeping the Docker images either
    in a public or private repository.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是一个中央平台，用于将 Docker 镜像保存在公有或私有仓库中。
- en: The Docker Hub provides features, such as a repository for Docker images, user
    authentications, automated image builds, integration with GitHub or Bitbucket,
    and managing organizations and groups. The Docker Registry component of the Docker
    Hub manages the repository.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 提供了多个功能，如 Docker 镜像的仓库、用户身份验证、自动化镜像构建、与 GitHub 或 Bitbucket 的集成，以及组织和小组管理。Docker
    Hub 的 Docker Registry 组件管理着这些仓库。
- en: 'To work with the Docker Hub, you must register an account using the link at
    [https://hub.docker.com/](https://hub.docker.com/).You can update the **Docker
    Hub ID**, **Email Address** and **Password** as shown in the following screenshot:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker Hub，您必须通过 [https://hub.docker.com/](https://hub.docker.com/) 提供的链接注册一个帐户。您可以更新**Docker
    Hub ID**、**电子邮件地址**和**密码**，如下所示：
- en: '![Sharing your images](img/B06455_02_37.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![共享你的镜像](img/B06455_02_37.jpg)'
- en: 'After completing the **Sign Up** process, you need to complete the verification
    received in an e-mail. After the e-mail verification is completed, you will see
    something similar to the following screenshot, when you login to the Docker Hub:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 完成**注册**过程后，你需要完成通过电子邮件收到的验证。电子邮件验证完成后，当你登录 Docker Hub 时，你将看到类似于以下截图的内容：
- en: '![Sharing your images](img/B06455_02_38.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![共享你的图片](img/B06455_02_38.jpg)'
- en: As you can see, I already have a few automated builds configured, we will get
    to these later on, for now we are going to look at pushing an image from our local
    Docker host.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我已经配置了一些自动构建，我们稍后会详细讲解，暂时我们将来看一下如何从本地 Docker 主机推送镜像。
- en: 'First, we need to login to the Docker Hub using the Docker client on the command
    line, to do this simply use the following command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用命令行中的 Docker 客户端登录到 Docker Hub，执行以下命令：
- en: '[PRE77]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You should be prompted for your Docker Hub username and password:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会提示你输入 Docker Hub 用户名和密码：
- en: '![Sharing your images](img/B06455_02_39.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![共享你的图片](img/B06455_02_39.jpg)'
- en: Now we are ready to start committing and pushing images to the Docker Hub.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始将镜像提交并推送到 Docker Hub。
- en: We'll again create an image using the `Dockerfile` we created earlier in the
    chapter. So, let's create the Docker image using the `Dockerfile` in `/chapter02/build_07_cmd`and
    push the resulting image to the Docker Hub.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用本章早些时候创建的`Dockerfile`来创建镜像。现在，让我们使用`/chapter02/build_07_cmd`中的`Dockerfile`创建
    Docker 镜像，并将生成的镜像推送到 Docker Hub。
- en: 'Now we build the image locally using the following command making sure to use
    your own Docker Hub username in place of mine:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用以下命令在本地构建镜像，确保用你自己的 Docker Hub 用户名替换我的用户名：
- en: '[PRE78]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Once built, you can check the image is there by using:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，你可以通过使用以下命令检查镜像是否存在：
- en: '[PRE79]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Sharing your images](img/B06455_02_40.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![共享你的图片](img/B06455_02_40.jpg)'
- en: 'As we are already logged in all we need to do to push the newly create image
    is run the following command:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经登录，所需做的只是运行以下命令来推送新创建的镜像：
- en: '[PRE80]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '![Sharing your images](img/B06455_02_41.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![共享你的图片](img/B06455_02_41.jpg)'
- en: 'Finally, we can verify the availability of the image on the Docker Hub:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以验证镜像在 Docker Hub 上的可用性：
- en: '![Sharing your images](img/B06455_02_42.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![共享你的图片](img/B06455_02_42.jpg)'
- en: 'This is where I should probably issue a warning: as you have just experienced
    it is very easy to publish images to the Docker Hub using the `docker image push`
    command; however, it is very easy to accidentally push content you maybe wouldn''t
    want to be publicly available. For example, with a simple `COPY` or `ADD` instruction
    in your `Dockerfile` it is easy to bake sensitive information such as password
    credentials, certificates keys and non-publicly available code to a publicly accessible
    Docker Image repository.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我可能需要发出一个警告：正如你刚刚体验过的，使用`docker image push`命令将镜像推送到 Docker Hub 非常容易；然而，非常容易不小心推送一些你可能不希望公开的内容。例如，通过在你的`Dockerfile`中使用简单的`COPY`或`ADD`指令，很容易将敏感信息（如密码凭证、证书密钥和非公开代码）打包到一个公开可访问的
    Docker 镜像仓库中。
- en: It is this reason why I prefer to share a `Dockerfile` or `docker-compose.yml`
    files with my colleagues using private Git repositories and a good set of instructions
    . A also, it allows then to check what it is they are going to be running as they
    are able to review the`Dockerfile` and `docker-compose.yml` files; in fact, they
    can make changes and share them with me.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我更倾向于通过私有 Git 仓库与同事分享`Dockerfile`或`docker-compose.yml`文件，并提供一套好的指引。这样，他们可以查看自己将要运行的内容，甚至可以修改文件并与我分享。
- en: Summary
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot in this chapter. We have used the Docker command line
    client to launch and interact with containers. We also used Docker Compose to
    define multiple container based application, namely WordPress and created and
    published our own Docker images on the Docker Hub. Finally, we customized the
    official WordPress Docker image adding additional functionality.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们已经覆盖了很多内容。我们使用 Docker 命令行客户端启动并与容器交互。我们还使用 Docker Compose 定义了基于多个容器的应用程序，即
    WordPress，并在 Docker Hub 上创建并发布了我们自己的 Docker 镜像。最后，我们自定义了官方的 WordPress Docker 镜像，添加了额外的功能。
- en: I am sure you will agree that so far using Docker has felt quite intuitive;
    in our next chapter we will move off our local Docker host and interact with Docker
    installations on remote hosts.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你会同意，到目前为止，使用 Docker 感觉非常直观；在我们的下一章中，我们将不再局限于本地 Docker 主机，而是与远程主机上的 Docker
    安装进行交互。
