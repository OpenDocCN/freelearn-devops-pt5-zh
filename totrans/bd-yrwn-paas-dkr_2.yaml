- en: Chapter 2. Exploring Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading this chapter, you will find yourself more comfortable talking
    about and using Docker. The following topics will be covered here:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Registry Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find these topics important when building your PaaS, and you will use
    and interact with all of them throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the beginning, it can be hard to understand the difference between a Docker
    image and a Docker (or Linux) container.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that our Linux kernel is layer zero. Whenever we run a Docker image,
    a layer is put on top of our kernel layer. This image, layer one, is a read-only
    image and cannot be changed or cannot hold a state.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker image can build on top of another Docker image that builds on top of
    another Docker image and so on. The first image layer is called a **base image**,
    and all other layers except the last image layer are called **parent images**.
    They inherit all the properties and settings of their parent images and add their
    own configuration in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker images are identified by an image ID, which is a 64-character long hexadecimal
    string, but when working with images, we will almost never reference an image
    by this ID but use the image names instead. To list all our locally available
    Docker images, we use the `docker images` command. Take a look at the following
    image to see how the images are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker image](img/3946_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Images can be distributed with different versions for us to choose from, and
    the mechanism for this is called **tags**. The preceding screenshot illustrates
    this with the **neo4j** image that has a **latest** and a **2.1.5** tag. This
    is how the command used to pull a specific tag looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Docker container is created the moment we execute `docker run imagename`.
    A writeable layer is added on top of all the image layers. This layer has processes
    running on the CPU and can have two different states: running or exited. This
    is the container. When we start a container with the Docker run command, it enters
    the running state until it, for some reason, stops by itself or is stopped by
    us and then enters the exited state.'
  prefs: []
  type: TYPE_NORMAL
- en: When we have a container running, all the changes we make to its filesystem
    are permanent between start and stop. Remember that changes made to the container's
    filesystem are not written to the underlying Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: We can start as many instances of running containers as we want from the same
    image; they will all live side by side, totally separated by each other. All the
    changes we make to a container are limited to that container only.
  prefs: []
  type: TYPE_NORMAL
- en: If changes are made to the container's underlying image, the running container
    is unaffected and there is no autoupdate happening. If we want to update our container
    to a newer version of its image, we have to be careful and make sure that we have
    set up the data structure in a correct way, otherwise we have the risk of losing
    all the data in the container. Later in this book, I will show you where to keep
    important data without the risk of losing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding screenshot is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker container](img/3946_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A 64-character long hexadecimal string called **container ID** identifies Docker
    containers. This ID can be used when interacting with the container, and depending
    on how many containers we have running, we will usually only have to type the
    first four characters of the container ID. We can use the container name as well,
    but it's often easier to type the beginning of the ID.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command line interface is where we communicate with the daemon using the
    Docker command. The Docker daemon is the background process that receives the
    commands that are typed by us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we ran a few Docker commands to start and stop containers
    as well as to list containers and images. Now, we are going to learn a few more
    that will help us when handling containers for our PaaS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker logs <container-ID|name>`: Everything that is written to the `STDOUT`
    containers will end up in the file that can be accessed via this command. This
    is a very handy way to output information from within a container, as shown here:![The
    Docker command-line interface](img/3946_02_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker export <container-ID|name>`: If you have a container that holds data
    that you want to export, this is the command to be used. This creates a tar archive
    and sends it to `STDOUT`:![The Docker command-line interface](img/3946_02_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker cp CONTAINER:PATH HOSTPATH`: If you don''t want the whole file system
    from a container but just one directory or a file, you can use `docker cp` instead
    of `export`, as shown in the following screenshot:![The Docker command-line interface](img/3946_02_05.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Registry Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important part of Docker's popularity is its community and the ease with
    which you can share, find, and extend Docker images. The central place for this
    is the Docker Registry Hub that can be found at [https://hub.docker.com/](https://hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Browsing repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we can search and, in many ways, browse for image repositories to find
    exactly what we're after. If we take a look at the popular ones, we will see what
    others are using the most.
  prefs: []
  type: TYPE_NORMAL
- en: If we click on the Ubuntu repository, we will see lots of information about
    the image, the tags that are available, users' comments, the number of stars it
    has, and when it was updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing repositories](img/3946_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we click on a tag in the main view, we'll see something called the `Dockerfile`.
    This is the image description that runs when an image is being created. Further
    in this book, we'll write our own.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in an image in the Docker hub, I recommend that you read
    the Information/README as well as the other users' comments. Often, you will find
    valuable information there that will help you to choose the right image and show
    you how to run it in the way the maintaining developer intended to.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you will find images that almost fit your needs since most images are
    quite general, but as a developer, you might need specific settings or services
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring published images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take the official WordPress Docker image, for example ([https://registry.hub.docker.com/_/wordpress/](https://registry.hub.docker.com/_/wordpress/)).
    You'll find it on the Docker hub's browse page or you can search for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s forget about these shortcomings for now and see what the information
    page says:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring published images](img/3946_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This image reads the settings from the Docker container's environment variables.
    This means that image has to be started with the environment variables injected
    using the `docker run –e` command, or you can `--link` another container to it
    that injects these variables. We'll discuss container linking more later in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we''ll get if we were to pull this image. Click on the link
    to the Dockerfile in the apache directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ok, we see that it builds on Debian Wheezy and installs Apache2, PHP5, and some
    other stuff. After that, it sets a bunch of environment variables and then downloads
    WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see a few lines starting with the command `COPY`. This means that files
    are shipped with the Docker image and are copied to the inside of the container
    when it''s started. This is how the `docker-apache.conf` file shipped with the
    WordPress image looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code tells Apache where to look for files.
  prefs: []
  type: TYPE_NORMAL
- en: What about the `docker-entrypoint.sh` file?
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` keyword tells the Docker daemon that if nothing else is specified,
    this file should be executed whenever the container is run. It is as if the whole
    container is an executable file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at what is present inside this file, we''ll see that it basically
    sets up the connection to the MySQL database and configures `.htaccess` and WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that is done is to check whether the user has set environment
    variables for the MySQL connection. If not, it exits and writes some info to `STDERR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t you try and see whether you can trigger the MySQL error that writes
    **error: missing MYSQL_PORT_3306_TCP environment variable** to the `STDERR`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Exploring published images](img/3946_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `--name some-wordpress` command names the container, so we can reference
    it by this name later. Also, the `–d` argument tells the container to run in detached
    mode, which means that it does not listen to commands from where we started it
    anymore. The last `wordpress` argument is the name of the Docker image we want
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the log for our new container, we''ll see what the screenshot shows
    us: the expected error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a MySQL container and see whether we can get it to work. Navigate
    to [https://registry.hub.docker.com/_/mysql/](https://registry.hub.docker.com/_/mysql/)
    in order to get to the official MySQL docker repository on the Docker registry
    hub. Here, it states that in order to start a MySQL instance, we need to invoke
    **docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql**
    in the shell. Since we are doing this for educational purposes at the moment,
    we don''t have to choose a strong root user password. After some dependent images
    are downloaded, we should be able to see our running container when we execute
    `docker ps`. If we do, have a look at the installation log by running `docker
    logs some-mysql`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring published images](img/3946_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Great, now we have a running MySQL container that is needed to start a WordPress
    instance. Let''s start a new WordPress instance with the MySQL link in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `--link` parameter exposes the `some-mysql` containers' environment variables,
    interface, and exposed ports via the environment variables injected to the `some-wordpress`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: To open a port that can be reached from the outside, port 80 is exposed via
    the `–p 80` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get an error message saying **Error response from daemon: Conflict,
    The name some-wordpress is already assigned to a11c101cacaf.**, you have to delete
    (or rename) that container to be able to assign `some-wordpress` to a container
    again. You need to give the new container a new name or delete the old (failing)
    WordPress container. Invoke `docker rm some-wordpress` to delete the old container
    using the desired name.'
  prefs: []
  type: TYPE_NORMAL
- en: When you have the container running, invoke `docker ps` command to find out
    which of our ports was assigned to the container's private port 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can either look at the ports column in the container list, or we can invoke
    `docker port some-wordpress 80` to explicitly find it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring published images](img/3946_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In my case, it was port **49155**.
  prefs: []
  type: TYPE_NORMAL
- en: Enter your Docker hosts' **ip:port** in your web browser to see whether you
    can reach it. If you're on your local computer running Windows or OS X, you can
    find your Docker IP by invoking `boot2docker ip`. If you're on a local Linux,
    **127.0.0.1** should be fine.
  prefs: []
  type: TYPE_NORMAL
- en: I'm doing this on Amazon EC2, so I have to go to the EC2 Management console
    to get my public IP or public DNS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Point your web browser to `http://yourip:yourport` (in my case, `http://myamazon-dns.com:49155`)
    and you should be presented with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring published images](img/3946_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default Amazon AWS security policy is to block the default Docker public
    ports, so we have to change this in the **Security Groups** section in the EC2
    dashboard. See the *Docker on Amazon EC2* section in [Chapter 1](ch01.html "Chapter 1. Installing
    Docker"), *Installing Docker,* for how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful, it works!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker image can be seen as a read-only template for containers, specifying
    what's supposed to be installed, copied, configured, and exposed when a container
    is started.
  prefs: []
  type: TYPE_NORMAL
- en: We learned more about how we can interact with the Docker daemon and with individual
    Docker containers to read logs, copy files, and export the complete filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker hub was introduced and we looked at what the official WordPress Docker
    image consisted of and how they configured the OS in the Dockerfile as well as
    in an `ENTRYPOINT` file to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: We downloaded and ran the WordPress image that failed as expected, and we fixed
    it by linking the required MySQL container to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a Dockerfile and publish a Docker image
    to the Docker registry hub so that we have a way to get our customized Docker
    images to wherever we decide to place our PaaS.
  prefs: []
  type: TYPE_NORMAL
