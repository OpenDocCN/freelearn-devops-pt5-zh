<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Building Your Own Plugin</h1></div></div></div><p>Along with providing the core tools, Docker also documents an API that allows the core Docker engine to talk to the plugin services written by third-party developers. At the moment, this API allows you to hook your own storage and networking engines into Docker.</p><p>This may seem like it is limiting you to a very niche set of plugins, and it is. However, there is a good reason that Docker has taken this decision.</p><p>Let's have a look at some of the plugins that we have already installed in the previous chapters; however, rather than covering the functionality, we will take a look at what goes on behind the scenes.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Third-party plugins</h1></div></div></div><p>The first page about<a id="id221" class="indexterm"/> plugins on the Docker documentation site lists a lot of third-party plugins. As already mentioned, let's get an idea of what's going on in the background of the plugins that we have already installed and used in <a class="link" href="ch03.html" title="Chapter 3. Volume Plugins">Chapter 3</a>, <em>Volume Plugins</em>, and <a class="link" href="ch04.html" title="Chapter 4. Network Plugins">Chapter 4</a>, <em>Network Plugins</em>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Convoy</h2></div></div></div><p>Convoy was the <a id="id222" class="indexterm"/>first third-party plugin we looked at in <a class="link" href="ch03.html" title="Chapter 3. Volume Plugins">Chapter 3</a>, <em>Volume Plugins</em>. To install it, we launched a Docker host in DigitalOcean as we needed a more<a id="id223" class="indexterm"/> complete underlying operating system than is provided by the Boot2Docker operating system, which is favored by Docker Machine.</p><p>To install Convoy, we downloaded a release file from GitHub. This tar archive contained the static binaries required to run Convoy on a Linux system, once the static binaries were in place, we created a Docker plugin folder and then added a symbolic link to the socket file that Convoy creates when it is first executed.</p><p>We then went on to configure a loopback device that we created on a volume. We then instructed Convoy to use the newly created volume by launching Convoy as a daemon using the <a id="id224" class="indexterm"/>Convoy static binary that we downloaded.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>In multitasking computer operating systems, a <a id="id225" class="indexterm"/>daemon is a computer program that runs as a background process, rather than being under the direct <a id="id226" class="indexterm"/>control of an interactive user:</p><p>
<a class="ulink" href="https://en.wikipedia.org/wiki/Daemon(computing)">https://en.wikipedia.org/wiki/Daemon(computing)</a>.</p></div></div><p>As far as Docker is<a id="id227" class="indexterm"/> concerned, for each request it gets when the <code class="literal">--volume-driver=convoy</code> flag is used to launch a container, it will simply offload anything to do with volume the daemonized Convoy process.</p><p>If you review the <em>Convoy</em> section of <a class="link" href="ch03.html" title="Chapter 3. Volume Plugins">Chapter 3</a>, <em>Volume Plugins</em>, you will notice that all of our interaction with Convoy is using the <code class="literal">convoy</code> command and not the <code class="literal">docker</code> one, in fact, the Convoy client is using the same socket file as we symbolically linked to the <code class="literal">Docker plugins</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec39"/>REX-Ray</h2></div></div></div><p>Next up, we installed REX-Ray. To do this, we ran a command, which downloaded and executed a bash<a id="id228" class="indexterm"/> script from <a class="ulink" href="https://dl.bintray.com/emccode/rexray/install">https://dl.bintray.com/emccode/rexray/install</a>.</p><p>This script <a id="id229" class="indexterm"/>works out the operating system you are running and then <a id="id230" class="indexterm"/>downloads and installs either the DEB or RPM file. These packages, as you may have already guessed, install the correct static binaries for your operating system.</p><p>REX-Ray goes one step further by also installing init, upstart, or systemd service scripts for the daemon, meaning that you can start and stop it as you would with any other services on your Docker host.</p><p>Again, once we have installed REX-Ray, the only interaction we had with the tool is by using the <code class="literal">rexray</code> command.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec40"/>Flocker</h2></div></div></div><p>Flocker went<a id="id231" class="indexterm"/> one step further, rather than installing an installation script, we<a id="id232" class="indexterm"/> used the AWS CloudFormation templates supplied by Cluster HQ to bootstrap the environment for us.</p><p>This did the obvious task of launching the Docker host, setting up the security groups, and installing and configuring both Docker and Flocker.</p><p>Flocker goes one step further than Convoy and REX-Ray by installing an agent that interacts with the<a id="id233" class="indexterm"/> remotely-hosted web API, the volume hub.</p><p>Also, as mentioned<a id="id234" class="indexterm"/> in this chapter, Flocker existed before the concept of volume plugins existed. So again, a lot of interaction with Flocker is done outside of Docker; in fact, Cluster HQ wrote their own wrapper for Docker so that you could easily create Flocker volumes before the option existed within Docker.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Weave</h2></div></div></div><p>This was the <a id="id235" class="indexterm"/>only third-party network plugin we looked at. Like Flocker, Weave <a id="id236" class="indexterm"/>existed before Docker launched its plugin functionality.</p><p>Weave is slightly different from the other third-party tools that we have looked at. In this, what is downloaded is actually a bash script rather than a static binary.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>This script is <a id="id237" class="indexterm"/>used to configure the host and download containers from the Weaveworks Docker Hub account, which can be found at <a class="ulink" href="https://hub.docker.com/u/weaveworks/">https://hub.docker.com/u/weaveworks/</a>.</p></div></div><p>The script launches and configures the containers with enough permissions to interact with the host machine. The script is also responsible for sending commands via the <code class="literal">docker exec</code> command to the running containers and also configure <code class="literal">iptables</code> on the host machine.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>The commonalities among the plugins</h2></div></div></div><p>As you can see, and <a id="id238" class="indexterm"/>as you have experienced, all of these plugins have scripts and binaries that are external to Docker itself.</p><p>They are also pretty much all written in the same language as Docker:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Plugin</p>
</th><th style="text-align: left" valign="bottom">
<p>Language</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Convoy</p>
</td><td style="text-align: left" valign="top">
<p>Go</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>REX-Ray</p>
</td><td style="text-align: left" valign="top">
<p>Go</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Flocker</p>
</td><td style="text-align: left" valign="top">
<p>Python</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Weave</p>
</td><td style="text-align: left" valign="top">
<p>Go</p>
</td></tr></tbody></table></div><p>Majority of the services are written in Go, the only exception is Flocker, which is mostly written in Python:</p><div><blockquote class="blockquote"><p><em>Go is expressive, concise, clean, and efficient. Its concurrency mechanisms make it <a id="id239" class="indexterm"/>easy to write programs that get the most out of multicore and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It's a<a id="id240" class="indexterm"/> fast, statically typed, compiled language that feels like a dynamically typed, interpreted language. <a class="ulink" href="https://golang.org/">https://golang.org/</a>.</em></p></blockquote></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Understanding a plugin</h1></div></div></div><p>So far, we have <a id="id241" class="indexterm"/>established that all the plugins that we have installed have actually nothing to do with Docker directly, so what does a plugin do?</p><p>Docker describes a plugin as:</p><div><blockquote class="blockquote"><p><em>"Docker plugins are out-of-process extensions which add capabilities to the Docker Engine."</em></p></blockquote></div><p>This is exactly what we have seen when installing third-party tools, they all run alongside Docker as separate daemons.</p><p>Let's assume that we are going to be creating a volume plugin called <code class="literal">mobyfs</code> for the remainder of this chapter. The mobyfs plugin is a fictional service which is written in Go and it runs as a daemon.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Discovery</h2></div></div></div><p>Typically, a plugin <a id="id242" class="indexterm"/>will be installed on the same host as the Docker binary. We can register our mobyfs plugin with Docker by creating the following files in either <code class="literal">/run/docker/plugins</code> if it's a Unix socket file, or <code class="literal">/etc/docker/plugins</code> or <code class="literal">/usr/lib/docker/plugins</code> if it is one of the other two files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mobyfs.sock</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mobyfs.spec</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mobyfs.json</code></li></ul></div><p>Plugins that use a Unix socket file must run on the same hosts as your Docker installation. Ones which use either a <code class="literal">.spec</code> or <code class="literal">.json</code> file can run on external hosts if your daemon supports TCP connections.</p><p>If you were using a .spec file, your file would just contain a single URL to either a TCP host and port or local socket file. Any of the following three examples are valid:</p><div><pre class="programlisting">tcp://192.168.1.1:8080
tcp://localhost:8080
unix:///other.sock</pre></div><p>If you wanted to use a <code class="literal">.json</code> file, it must look something similar to the following code:</p><div><pre class="programlisting">{
  "Name": "mobyfs",
  "Addr": "https:// 192.168.1.1:8080",
  "TLSConfig": {
    "InsecureSkipVerify": false,
    "CAFile": "/usr/shared/docker/certs/example-ca.pem",
    "CertFile": "/usr/shared/docker/certs/example-cert.pem",
    "KeyFile": "/usr/shared/docker/certs/example-key.pem",
  }
}</pre></div><p>The <code class="literal">TLSConfig</code> section <a id="id243" class="indexterm"/>of the JSON file is optional; however, if you are running your service on host other than your Docker host, I would recommend using HTTPS for communication between Docker and your plugin.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Startup order</h2></div></div></div><p>Ideally, your <a id="id244" class="indexterm"/>plugin service should be started before Docker. If you are running a host, which has <code class="literal">systemd</code> installed, this can be achieved by using a <code class="literal">systemd</code> service file similar to the following one, which should be called <code class="literal">mobyfs.service</code>:</p><div><pre class="programlisting">[Unit]
Description= mobyfs
Before=docker.service

[Service]
EnvironmentFile=/etc/mobyfs/mobyfs.env
ExecStart=/usr/bin/mobyfs start -p 8080
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process

[Install]
WantedBy=docker.service</pre></div><p>This will ensure that your plugin service is always started before the main Docker service.</p><p>If you are hosting your Plugin service on an external host, you may have to restart Docker for Docker to start communicating with your plugin service.</p><p>It is possible to package your plugin inside a container. To get around Docker having to be started before the plugin service, each activation request will retry several times over 30 seconds.</p><p>This will give the container enough time to start and to run the plugin service run though any bootstrapping processes before binding itself to a port on the container.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Activation</h2></div></div></div><p>Now that the plugin <a id="id245" class="indexterm"/>service has started, and we need to let Docker know where it should send requests to if the plugin service is called. According to our example, service is a volume plugin and we should run something similar to the following command:</p><div><pre class="programlisting">
<strong>docker run -ti -v volumename:/data --volume-driver=mobyfs russmckendrick/base bash</strong>
</pre></div><p>This will mount the <code class="literal">volumename</code> volume, which we have already configured in our plugin service to <code class="literal">/data</code> in a container, which runs my base container image and attaches us to a shell.</p><p>When the mobyfs volume driver is called, Docker will search through the three plugin directories that we covered in the <em>Discovery</em> section. By default, Docker will always look for a socket file, then either a <code class="literal">.spec</code> or <code class="literal">.json</code> file. The plugin name must match the filename in front of the file extension. If it is doesn't, the plugin will not be recognized by Docker.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>API calls</h2></div></div></div><p>Once the plugin has been called, the Docker daemon will make a post request using RPC-style JSON over HTTP to the plugin service using either the socket file or the URL defined in the <code class="literal">.spec</code> or <code class="literal">.json</code> file.</p><p>This means <a id="id246" class="indexterm"/>that your plugin service must implement an HTTP server and bind itself to the socket or port that you defined in the Discovery section.</p><p>The first request that is made by Docker will be to <code class="literal">/Plugin.Activate</code>. Your plugin service must respond to one of three responses. As mobyfs is a volume plugin, the response would be as follows:</p><div><pre class="programlisting">{
    "Implements": ["VolumeDriver"]
}</pre></div><p>If it was a network driver, then the response our plugin service should give would be as follows:</p><div><pre class="programlisting">{
    "Implements": ["NetworkDriver"]
}</pre></div><p>The final response of plugin service is as shown in the following code:</p><div><pre class="programlisting">{
    "Implements": ["authz"]
}</pre></div><p>Any other<a id="id247" class="indexterm"/> responses will be rejected and the activation will fail. Now that Docker has activated the plugin, it will continue to make post requests to the plugin service depending on the response it got when calling <code class="literal">/Plugin.Activate</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Writing your plugin service</h1></div></div></div><p>As mentioned in<a id="id248" class="indexterm"/> the previous section, Docker will interact with your plugin service by making HTTP calls. These calls are documented on the following pages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Volume </strong><a id="id249" class="indexterm"/><strong>Driver Plugins</strong>: <a class="ulink" href="https://docs.docker.com/engine/extend/plugins_volume/">https://docs.docker.com/engine/extend/plugins_volume/</a></li><li class="listitem" style="list-style-type: disc"><strong>Network </strong><a id="id250" class="indexterm"/><strong>Driver Plugins</strong>: <a class="ulink" href="https://docs.docker.com/engine/extend/plugins_network/">https://docs.docker.com/engine/extend/plugins_network/</a></li><li class="listitem" style="list-style-type: disc"><strong>Authorization </strong><a id="id251" class="indexterm"/><strong>Plugins</strong>: <a class="ulink" href="https://docs.docker.com/engine/extend/plugins_authorization/">https://docs.docker.com/engine/extend/plugins_authorization/</a></li></ul></div><p>Docker also provides an SDK as a <a id="id252" class="indexterm"/>collection for Go helpers, these can be found at the following URL:</p><p>
<a class="ulink" href="https://github.com/docker/go-plugins-helpers">https://github.com/docker/go-plugins-helpers</a>
</p><p>Each helper comes with examples, as well as links to open source projects, which serve as further examples on how to implement the helper.</p><p>These API requests should not be confused with the Docker Remote API, which is documented at the following URL:</p><p>
<a class="ulink" href="https://docs.docker.com/engine/reference/api/docker_remote_api/">https://docs.docker.com/engine/reference/api/docker_remote_api/</a>
</p><p>This is the API, which allows<a id="id253" class="indexterm"/> your applications to interact with Docker, and not Docker to interact with your application.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Summary</h1></div></div></div><p>As you can see, we only discussed how Docker will interact with the plugin service that you have written and didn't cover how you can actually write a plugin service.</p><p>The reason for this is that due to the plugin service that we would have had to cover, we would also need the following features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To be written in Go</li><li class="listitem" style="list-style-type: disc">To be able run as a daemon</li><li class="listitem" style="list-style-type: disc">To contain an HTTP server bound to a Unix socket or TCP port</li><li class="listitem" style="list-style-type: disc">To be able to accept and answer requests made to it by the Docker daemon</li><li class="listitem" style="list-style-type: disc">To translate the API requests that Docker is making to a filesystem or network service</li></ul></div><p>As you can imagine, this has the potential of being an entire book by itself.</p><p>Also, building your own plugin is quite an undertaking as you already have to have the foundations of a service written. While it seems like there are a lot of Docker plugins out there, searching GitHub for Docker plugins only returns a few dozen plugins that have been written to use the Docker plugin API.</p><p>The other projects returned are all tools or plugins for third-party services (such as Jenkins, Maven, and so on) that communicate with the Docker Remote API.</p><p>In the next chapter, we are going to look at third-party tools to extend your infrastructure past using Docker Machine.</p></div></body></html>