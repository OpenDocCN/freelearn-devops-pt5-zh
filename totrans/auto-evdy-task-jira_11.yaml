- en: '*Chapter 8*: Integrating with DevOps Tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core tenets of DevOps, beyond cultivating the associated culture
    within your organization, is the practice of automating and optimizing processes
    through the use of technology. Using automation rules in Jira, we can optimize
    the process of software development by connecting DevOps tools such as Bitbucket
    and GitHub to issues in Jira, thereby allowing us to synchronize the status of
    issues automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond keeping issue statuses automatically synchronized to code commits, we
    can also make use of automation to keep track of and synchronize pull requests,
    create tasks to track these, and send notifications to the team to ensure maximum
    visibility of the process. All of this enables developers to spend more time focused
    on writing and delivering software and less time managing administrative tasks.
  prefs: []
  type: TYPE_NORMAL
- en: While integration with certain DevOps processes has been (and still is) possible
    in Jira using workflow triggers, in this chapter we will look at how automation
    rules can be used to create more flexible integrations than what has previously
    been possible. This will keep your workflow configuration clean and prevent lengthy
    workflow updates, especially when the workflow affects a large number of issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing issues and Git commits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically releasing versions using GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing deployments with sprint completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jira Cloud environment**: If you don''t already have access to Jira, you
    can create a free Jira Cloud account at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)
    and ensure that you have both Jira Software and Jira Service Management selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jira Server environment**: If you are using Jira Server (available from [https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)),
    ensure that you have licenses for both Jira Software and Jira Service Management.
    In addition, you will also need to ensure that you install the *Automation for
    Jira* app, available from the Atlassian Marketplace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Jira, you will need to have at least **Project Administrator** access to
    a Scrum Software project and be able to follow the examples in this chapter. For
    the examples in this chapter, we have used the *Scrum project template* to create
    the software project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need access to the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitbucket Cloud**: Bitbucket Cloud is a hosted Git-based version control
    service from Atlassian. You can sign up for a Bitbucket account at [https://bitbucket.org](https://bitbucket.org)
    or by using the application switcher from your Jira Cloud account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: GitHub is a hosted software development and Git-based version control
    service from Microsoft. You can sign up for a GitHub account at [https://github.com](https://github.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**: Jenkins is a popular free, open source automation server that
    is used to facilitate **Continuous Integration** (**CI**) and **Continuous Delivery**
    (**CD**) by automating the building, testing, and deploying of software projects.
    You can download Jenkins from [https://www.jenkins.io](https://www.jenkins.io).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can download the latest code samples for this chapter from this book''s
    official GitHub repository at [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira).
    Please visit the following link to check the CiA videos: [https://bit.ly/2XWeuW7](https://bit.ly/2XWeuW7)'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing issues and Git commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the normal course of writing software, developers will normally move a story
    or task to an **In Progress** state, do the actual work of writing the code, commit
    the changes to a source repository such as Bitbucket or GitHub, and then switch
    back to Jira to move the story or task to the next status in the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: All of this manual work requires unnecessary context switching, and because
    the process requires the developer to remember to switch between the various tools,
    it is very likely that sometimes issues are not updated, which makes it harder
    to track actual progress on the project.
  prefs: []
  type: TYPE_NORMAL
- en: Jira has, for some time, had the ability to integrate with tools such as Bitbucket
    and GitHub by allowing administrators to configure the underlying Jira workflows
    with triggers on various transitions.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach does allow for automation of the process and frees up the
    developer from having to manually update their task statuses, it is limited to
    the transition on which the trigger is configured. Additionally, making adjustments
    to workflows is not always a straightforward task.
  prefs: []
  type: TYPE_NORMAL
- en: By using automation rules instead, we gain a lot more flexibility in how we
    synchronize code commits with their corresponding Jira issues.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how we can leverage automation rules to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to transition issues on code commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we will create a rule that listens for a commit created using
    Bitbucket Cloud and transitions the corresponding issue to **In Progress** if
    it is not already in that status.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will send a message for every commit to the *#sprint-updates*
    Slack channel, which we set up in [*Chapter 4*](B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080),
    *Sending Automated Notifications*. In reality though, you would probably not want
    to spam the developers with commit notifications and rather wait for a more significant
    event, such as the creation of a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For automation rules to recognize the issue that needs to be updated, the commit
    message needs to include the issue key as part of the message.If your developers
    create a branch for each issue they work on, the issue key needs to be a part
    of the branch name.In both instances, the issue key must follow the standard Jira
    format of the project key, followed by a dash and then the issue number. For example,
    if the project key is PROJ and the issue number is 123, the issue key will be
    *PROJ-123*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s firstly take a look at the rule in *Jira Cloud* using the DevOps triggers
    available to automation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Commit created** trigger and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you do not already have a Git provider configured for your project, the commit
    created trigger will prompt you to create a connection, which you can do by clicking
    on the **Connect now** link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll send a Slack message to the `#sprint-updates`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, we'll add a condition to check that the current status of the
    issue is not `Status`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`does not equal`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`In Progress`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, if the condition from *step 4* is satisfied, we'll transition the issue
    to **In Progress**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New action** and then select **Transition issue**. Set the **Destination**
    field to **In Progress** and then click **Save**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your rule should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Using the DevOps trigger to synchronize commits'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.1 – Using the DevOps trigger to synchronize commits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, name the rule `Transition to In Progress on commit` and click **Turn
    it on** to save and publish the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automation rules for Jira Server and Data Center do not currently include DevOps
    triggers, and so we need to make use of the incoming webhook trigger to achieve
    a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll first set up the incoming webhook automation rule in
    Jira, after which we'll copy the generated webhook URL, which we'll need to set
    up the outgoing webhook in the Bitbucket Cloud repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at how we build this rule in *Jira Server* or *Jira
    Data Center*:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Project automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitbucket Cloud sends a *push* webhook when a commit is created and sends a
    webhook payload, which you can read more about at [https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository](https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we are assuming that the issue key is present in the commit
    message rather than the branch name. We will need to extract the issue key from
    the commit message in order to look up the correct Jira issue. Based on the Bitbucket
    payload structure detailed in the preceding link, we can find the commit message
    and extract the issue key using the following smart value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are using branches per issue and the issue key is encoded in the branch
    name, you can extract the issue key from the branch name with the following smart
    value instead: `{{webhookData.push.changes.first().new.target.name.match("([A-Z][A-Z0-9]+-\d+)")}}`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the `Issues provided by running the following JQL search`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`key = {{webhookData.push.changes.first().new.target.message.match("([A-Z][A-Z0-9]+-\d+)")}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll send a Slack message to the `#sprint-updates`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, we'll add a condition to check that the current status of the
    issue is not `Status`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`does not equal`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`In Progress`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, if the condition from *step 4* is satisfied, we'll transition the issue
    to **In Progress**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New action** and then select **Transition issue**. Set the **Destination**
    field to **In Progress** and then click **Save**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your rule should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Using an incoming webhook trigger to synchronize commits'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.2 – Using an incoming webhook trigger to synchronize commits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Name the rule `Transition to In Progress on commit` and click **Turn it on**
    to save and publish the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to configure the outgoing webhook in Bitbucket Cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to your repository in Bitbucket Cloud and click on `Transition Jira
    issue on commit` and paste the Incoming webhook URL, which was generated in step
    2, into the **URL** field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leave the rest of the fields set to their default values and click **Save**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your Bitbucket Cloud webhook should look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Configuring the push webhook in Bitbucket Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Configuring the push webhook in Bitbucket Cloud
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed the webhook setup in Bitbucket Cloud, any commits
    pushed to the Bitbucket repository will send a request to the **Webhook URL**
    that was autogenerated in *step 2*, causing our automation rule to fire and transition
    the issue related to the commit.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to use the DevOps triggers available in
    Jira Cloud to automatically keep issues in Jira in sync with commits to a Git
    repository hosted in Bitbucket Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps triggers such as Commit created in Jira Cloud work with most major
    Git repositories, including Bitbucket Cloud, GitHub, and Gitlab, and the example
    we have looked at using Jira Cloud will work unchanged for any of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can achieve a similar result for Jira Server and Jira
    Data Center using an incoming webhook for Bitbucket Cloud using issue keys in
    commit messages specifically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at how to use automation rules to keep track
    of pull requests created in Git-based repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of pull requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common feature of DevOps practices is the use of the so-called trunk-based
    development method, which is a key enabler for the application of **Continuous
    Integration**and **Continuous Delivery** or **Development (CI/CD)** to the software
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to achieve this is by making use of short-lived branches taken
    from the master (or trunk) branch to perform development tasks. Jira facilitates
    this by allowing developers to automatically create branches for each development
    task when a source control repository such as Bitbucket or GitHub is configured
    for the software project.
  prefs: []
  type: TYPE_NORMAL
- en: These short-lived branches are usually merged back into the master/trunk branch
    by way of pull requests, which allow developers to review the changes introduced
    into the software before merging them into the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how using automation rules allows us to keep track
    of these pull requests, which typically happen directly inside the source control
    repository, and to automatically synchronize and transition the affected issues
    in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also see how to create automated tasks to track pull requests. These tracking
    tasks will allow product owners and the team to quickly see which issues have
    been merged without pull requests, or which issues have outstanding pull requests
    without leaving Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the first rule, which will synchronize the development
    issue and create the tracking task.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to track new pull requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, the first thing we want to achieve when managing pull requests
    is to transition the corresponding development issue into a **Waiting for review**
    status and then create a tracking task in Jira that is linked to the development
    issue under review.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The **Waiting for review** status will need to be added to your workflow for
    this example to work correctly. If you have used the default workflow from the
    *Scrum software project template*, you can do this by adding a new column to your
    scrum board through the board configuration. If you have a custom workflow, you
    will need to edit the workflow to add this status.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we'll send a Slack message to the team to notify them that a new
    pull request task has been created. This will allow any member of the development
    team to pick up and review the pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we build this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the project settings menu, and then click **Create rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Pull request created** trigger and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we want to transition the development issue to the **Waiting for review**
    status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New action**, followed by **Transition issue** and then, in the **Destination
    status** field, select the **Waiting for review** option and then click **Save**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we need to create the Jira task to track this pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Same project`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Review PR: {{pullRequest.title}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Review is required for PR: {{pullRequest.title}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Source branch: {{pullRequest.sourceBranch}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Destination branch: {{pullRequest.destinationBranch}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Access the PR here: {{pullRequest.url}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`blocks`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Trigger issue`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To send a notification to the team via Slack, we''ll select `:bellhop_bell:
    A new pull request has been created and is ready for review <{{createdIssue.url}}|{{createdIssue.key}}>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#slack-updates`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your rule should look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Rule to track new pull requests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.4 – Rule to track new pull requests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, name the rule `Track new pull requests` and click **Turn it on** to
    save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, we have learned how to use the built in DevOps triggers available
    in Jira Cloud to trigger rules when new pull requests are created in connected
    Git tools such as Bitbucket and GitHub, provided these tools are configured in
    Jira and connected to the software project.
  prefs: []
  type: TYPE_NORMAL
- en: The second rule we'll look at in this section will complete the loop of managing
    pull requests by handling the case when a pull request has been approved and merged.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to manage merged pull requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we'll create an automation rule that will trigger when a pull
    request is merged. At this point, we want to transition the development issue
    from **Waiting for review** to **Waiting for deploy**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The **Waiting for deploy** status will need to be added to your workflow in
    order for this example to work correctly. If you have used the default workflow
    from the *Scrum software project template*, you can do this by adding a new column
    to your scrum board through the board configuration. If you have a custom workflow,
    you will need to edit the workflow to add this status.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we also want to automatically transition the tracking task that
    we created in the **Track new pull requests** rule to **Done**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how we can build a rule to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Pull request merged** trigger and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we only want to transition the issue if it is in *Waiting for review* status,
    we need to have a condition to check for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Status`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`equals`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Waiting for review`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, select **New action** followed by **Transition issue** and then, in the
    **Destination status** field, select **Waiting for deploy** and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we want to automatically transition the tracking task that we created in
    the *Creating a rule to track new pull requests* section to `Linked issues`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`is blocked by`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As there might be other tasks linked to this issue using the same link type,
    we want to ensure that we only automatically transition the tracking task, so
    we'll need another condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Summary`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`starts with`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Review PR:`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now select **New action** followed by **Transition issue**. In the **Destination
    status** field, select **Done** and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The rule should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Rule to manage pull request merges'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.5 – Rule to manage pull request merges
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, name the rule `Manage pull request merges` and click **Turn it on**
    to save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now know how to integrate pull requests with Jira using automation rules.
    Firstly, to ensure that the development issues are synchronized with the actual
    work being done by the development team, and secondly, to keep track of which
    issues have been or still need to be merged into the master branch. In the next
    section, we'll see how to specifically use automation rules to integrate with
    the release functionality available in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically releasing versions using GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version control tools allow developers to tag specific revisions of their source
    code, which, in effect, creates a snapshot of the repository at a point in time.
    The most common use for tags is to identify the source components and files that
    make up a particular version or release of the software and tools such as GitHub
    and GitLab take this a step further by allowing developers to create a release
    based on a particular tag. These typically consist of the list of changes applicable
    to this particular release in the form of release notes. They can also include
    links to the list of assets that make up the release, which are typically downloadable
    binary packages.
  prefs: []
  type: TYPE_NORMAL
- en: Releases can be created using the tool's user interface, but most commonly are
    created automatically by build tools such as Bitbucket Pipelines or Jenkins upon
    the successful completion of a deployment build. These tools can, in turn, fire
    webhook events to notify other tools when a release has been created.
  prefs: []
  type: TYPE_NORMAL
- en: With automation rules in Jira, we can use incoming webhooks to receive these
    notifications and automatically release the corresponding version in Jira and
    simultaneously transition all the affected issues linked to that version to *Done*.
    Let's now take a look at a rule that will allow us to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to synchronize version releases to GitHub releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this rule, we'll create an incoming webhook that can be called by GitHub
    when a release is created. The GitHub release webhook contains a JSON payload
    from which we'll be able to extract the name of the tag that identifies the release.
    In turn, this tag name should correspond to the versions in your Jira Software
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the GitHub release payload is similar to the following, and
    we''ll be using the `action` and `tag_name` fields in our rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read more about the event payload at the following URL: [https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release](mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also learn more about GitHub webhooks and events in general at the
    following URL: [https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks](mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the steps required to build an automation rule to synchronize
    the release of a Jira version when a version is released from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Incoming webhook** trigger and, in the **Execute this automation
    rule with** field, select the **No issues from the webhook** option and then click
    **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to copy the webhook URL that was automatically generated as we'll
    need this later to configure the GitHub webhook.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GitHub will send a webhook event for different states of the release; however,
    for this rule, we are only interested in acting on the event when the release
    is published, which we can check by looking at the `{{webhookData.action}}`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`equals`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`published`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first thing we want to do if the condition in *step 3* matches is to automatically
    transition all the issues that belong to the release and are currently waiting
    to be deployed to `JQL`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fixVersion = {{webhookData.release.tag_name}} AND status = "Waiting for deploy"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we select **New action**, followed by **Transition issue**, and set the
    **Destination status** field to **Done** before clicking **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we want to release the Jira version that corresponds to the tag name of
    the GitHub release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to do this outside the `{{webhookData.release.tag_name}}` and then click
    **Save**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rule should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Automatically releasing a Jira version from GitHub'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.6 – Automatically releasing a Jira version from GitHub
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, name the rule `Synchronize versions with GitHub releases` and click
    **Turn it on** to save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the automation rule in Jira, we will need to complete the configuration
    in GitHub using the webhook URL generated previously in *step 2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now configure our GitHub repository to send release notifications to
    our automation rule in Jira:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your repository in GitHub, click on **Settings**, select the **Webhooks**
    tab from the menu on the left, and then click on the **Add webhook** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the webhook fields as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Enable SSL verification`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To ensure that we receive the correct event in the automation rule, select the
    **Let me select individual events** option in the **Which events would you like
    to trigger this webhook** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to deselect the **Pushes** option, select the **Releases** option,
    and then click **Add webhook**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your GitHub configuration should look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Configuring the releases webhook in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Configuring the releases webhook in GitHub
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to integrate Jira with GitHub releases and how we can
    use automation rules to release the corresponding version in Jira after transitioning
    all the affected development tasks to **Done**. In the next section, we'll look
    at how to automatically kick off deployment builds using Jenkins when a sprint
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing deployments with sprint completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Agile scrum, one of the artifacts created during a sprint is the **Product
    increment**, which is the deliverable produced by completion of the product backlog
    tasks during a sprint. In this section, we'll learn how to integrate with Jenkins
    using automation rules to automatically initiate the final deployment build when
    the sprint in Jira is closed.
  prefs: []
  type: TYPE_NORMAL
- en: During a sprint, in a trunk-based development model, developers will commit
    code to the branch in the source repository associated with the development task,
    which will generally initiate automated tests to verify that the new code does
    not negatively affect the build process. When pull requests are created and merged,
    further automated tests can be initiated followed by automated deployments to
    QA or staging servers. By the time the sprint is completed, all these processes
    result in the final task of deploying the resultant product increment to production,
    or by using a tool such as GitHub to create a release.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how this is achievable using automation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to start a deployment build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we'll create a rule that will initiate a production build of
    a software project each time a sprint is completed. To achieve this, we first
    need to configure the job in Jenkins to allow builds to be triggered remotely
    by scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you do not already have a Jenkins instance, you can sign up for an AWS account
    at [https://aws.amazon.com](https://aws.amazon.com) and launch a new EC2 instance
    based on the *Jenkins Certified by Bitnami* AMI. This AMI contains full instructions
    on how to get up and running with Jenkins in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by navigating to the project in Jenkins. In the project's **Configuration**
    screen, select the **Build Triggers** tab and then select the **Trigger builds
    remotely** option. Jenkins requires an authentication token to be provided to
    ensure that only remote systems that know this token can kick off the build job.
  prefs: []
  type: TYPE_NORMAL
- en: 'This token can be any text string of your choosing. In our example, we''re
    going to use `MY_SECURE_AUTH_TOKEN` as the **Authentication Token**. Once you
    have configured Jenkins, the **Build Triggers** section should look similar to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Configuring Jenkins to allow the triggering of builds remotely'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Configuring Jenkins to allow the triggering of builds remotely
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have Jenkins configured, let''s build the automation rule to initiate
    deployment when our sprint is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Sprint completed** trigger and, in the **Boards** field, select
    the Scrum board for your project and then click **Save**. In this example, we'll
    select **My Application Scrum Board**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sending API requests to Jenkins requires us to acquire an API crumb from the
    Jenkins crumb issuer service. This service returns a crumb that we later need
    to use to interact with the API in the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To do this, select `https://<your_jenkins_host>/crumbIssuer/api/json`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Authorization`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Basic <your base64-encoded credentials>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Empty`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{{webhookResponse}}` smart value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we need to make the call to the Jenkins API to kick off the deployment
    build that we configured in Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also need to send the Jenkins crumb that we retrieved in *step 3* in
    the *Jenkins-Crumb* header.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Again, select `https://<your_jenkins_host>/job/<your_job_name>/build?token=<YOUR_AUTHORIZATION_TOKEN>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill the following in the first `Authorization`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Basic <your base64-encoded credentials>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the following second `Jenkins-Crumb`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{{webhookResponse.body.crumb}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Empty`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{{webhookResponse}}` smart value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the build is successfully kicked off in Jenkins, we want to transition all
    the issues in the sprint that were waiting for deployment to `{{webhookResponse}}`
    smart value will always contain the response from the latest `{{webhookResponses}}`
    list, which will contain the responses in order of the web request actions, starting
    from position zero (0). Also note that responses will only be added to this list
    if you have checked the `{{webhookResponse.status}}`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exactly matches regular expression`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2\d\d`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, select **Branch rule / related issues** followed by **Issues in the sprint**
    in the **Type of related issues** field and then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select `Status`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`equals`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Waiting for deploy`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we need to transition the issues if they match the condition in *step 7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New action** followed by **Transition issue**. In the **Destination
    status** field, select **Done** and then click **Save**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your rule should look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Rule to start Jenkins deployment upon sprint closure'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_8.9.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.9 – Rule to start Jenkins deployment upon sprint closure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, name the rule `Start deployment on sprint closure` and click **Turn
    it on** to save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This concludes the final section of this chapter, in which we have learned how
    to use automation rules to integrate with Jenkins to automatically kick off deployment
    builds when a sprint is completed and to transition all the affected development
    tasks to **Done**.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how using automation rules can help us with
    DevOps practices by optimizing our development and operations processes.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how to use the built-in DevOps automation triggers available
    in Jira Cloud to integrate with our source repositories, such as Bitbucket or
    GitHub. This allows us to keep development issues in Jira in sync with the code
    as it is committed to the source repository.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have also learned how we can achieve similar integrations when
    using Jira Server or Data Center by using incoming webhooks in our rules in place
    of the DevOps triggers available to Jira Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how we could use the DevOps pull request triggers available
    in Jira Cloud to automatically synchronize the development tasks in Jira. We also
    learned how to create and manage tracking tasks, which provide greater visibility
    into the overall development process within Jira.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how, when using GitHub to manage software releases, we can also
    use automation rules to release transition the affected issues in Jira to **Done**
    and how to automatically keep the version in Jira in sync when creating a GitHub
    release. Finally, we learned how to automatically initiate a deployment build
    of a software project in Jenkins whenever a sprint in Jira is completed.
  prefs: []
  type: TYPE_NORMAL
- en: By introducing automation rules into our Jira processes, we can streamline our
    DevOps processes and drastically reduce the amount of time developers need to
    perform tasks in multiple tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be exploring some best practices to follow when
    creating automation rules in Jira.
  prefs: []
  type: TYPE_NORMAL
