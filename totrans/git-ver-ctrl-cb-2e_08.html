<html><head></head><body>
        

                            
                    <h1 class="header-title">Recovering from Mistakes</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Undo – Remove a commit completely</li>
<li>Undo – Remove a commit and retain changes to files</li>
<li>Undo – Remove a commit and retain changes in the staging area</li>
<li>Undo – Working with a dirty area</li>
<li>Redo – Recreate the latest commit with new changes</li>
<li>Revert – Undo the changes introduced by a commit</li>
<li>Reverting a merge</li>
<li>Viewing past Git actions with git reflog</li>
<li>Finding lost changes with git fsck</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>It is possible to correct mistakes made in Git with git push context (without exposing them if the mistake is found before sharing or publishing the change). If the mistake has already been pushed, it is still possible to undo the changes made to the commit that introduced the mistake.</p>
<p>We will look at the <kbd>reflog</kbd> command and how we can use that and <kbd>git fsck</kbd> to recover lost information.</p>
<p>There is no git undo command in core Git, one of the reasons being ambiguity on what needs to be undone, for example, and the last commit, the added file. If you want to undo the last commit, how should that be done? Should the changes introduced to the files by the commit be deleted? For instance, do you just roll back to the last known good commit, or should they be kept so that it could be changed for a better commit? Should the commit message simply be reworded? In this chapter, we'll explore the possibilities for undoing a commit in several ways, depending on what we want to achieve. We'll explore four ways to undo a commit:</p>
<ul>
<li>Undo everything, just remove the last commit as if it never happened</li>
<li>Undo the commit and unstage the files; this takes us back to where we were before we started to add the files</li>
<li>Undo the commit, but keep the files in the index or staging area so that we can just perform some minor modifications and then complete the commit</li>
<li>Undo the commit with the dirty work area</li>
</ul>
<p>The <kbd>undo</kbd> and <kbd>redo</kbd> commands in this chapter are performed on commits that are already published in the example repository. You should usually not perform the undo and redo commands on commits that are already published in a public repository, as you will be rewriting history. However, in the following recipes, we'll use an example repository and execute the operations on published commits so that everyone has the same experience.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Undo – Remove a commit completely</h1>
                
            
            
                
<p>In this example, we'll learn how we can undo a commit as if it had never happened. We'll learn how we can use the reset command to effectively discard the commit and thereby reset our branch to the desired state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this example, we'll use the example of the <kbd>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</kbd> repository, clone the repository, and change our working directory to the cloned one:</p>
<pre class="mce-root"><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-</strong></pre>
<pre class="mce-root"><strong>Edition_hello_world_cookbook.git </strong><br/><strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we'll try to undo the latest commit in the repository as though it never happened:</p>
<ol>
<li> We'll make sure that our working directory is clean, no files are in the modified state, and nothing is added to the index:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong> 

<strong>nothing to commit, working directory clean</strong> </pre>
<ol start="2">
<li>Also, check what is in our working tree:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ls</strong> 
<strong>HelloWorld.java Makefile        hello_world.c</strong> </pre>
<ol start="3">
<li>If all works well, we'll check the log to see the history of the repository. We'll use the <kbd>--oneline</kbd> switch to limit the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --oneline</strong> 
<strong>3061dc6 Adds Java version of 'hello world'</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> </pre>
<ol start="4">
<li>The most recent commit is the <kbd>3061dc6 Adds Java version of 'hello world'</kbd> commit. We will now undo the commit as though it never happened, and the history won't show it:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard HEAD^</strong> 

<strong>HEAD is now at 9c7532f Fixes compiler warnings</strong> </pre>
<ol start="5">
<li>Check the log, status, and filesystem, so that you can see what actually happened:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --oneline</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> 

<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.</strong> 

<strong>  (use "git pull" to update your local branch)</strong>
 
<strong>nothing to commit, working directory clean</strong> 

<strong>$ ls</strong> 
<strong>hello_world.c</strong> </pre>
<ol start="6">
<li>The commit is now gone, along with all the changes it introduced (<kbd>Makefile</kbd> and <kbd>HelloWorld.java</kbd>).</li>
</ol>
<p>In the last output of the <kbd>git status</kbd> command, you can see that our master branch is one behind <kbd>origin/master</kbd>. This is similar to what we mentioned at the beginning of the chapter, because we are removing and undoing commits that are already published. Also, as mentioned, you should only perform the undo and redo (<kbd>git reset</kbd>) operations on commits that are not shared yet. Here, we only show it on the published commits to make the example easy to reproduce.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">Effectively, we are just changing the pointer of the master branch to point to the previous commit <strong>HEAD</strong>, which means the first parent of <strong>HEAD</strong>. Now, the branch will point to <strong>9c7532f</strong>, instead of the commit we removed, <strong>35b29ae</strong>. This is shown in the following diagram:</p>
<div><img class="alignnone size-full wp-image-295 image-border" src="img/6bc11ec6-a125-4d99-8567-48ab1e4e0b93.png" style="width:35.42em;height:16.17em;"/></div>
<p>The preceding diagram also shows that the original <strong>3061dc6</strong> commit is still present in the repository, but new commits on the master branch will start from <strong>9c7532f</strong>; the <strong>3061dc6</strong> commit is called a dangling commit.</p>
<p>You should only perform this undo operation on commits you haven't shared (pushed) yet, since when you create new commits following undo or reset, those commits form a new history that will diverge from the original history of the repository.</p>
<p>When the reset command is executed, Git looks at the commit pointed to by <strong>HEAD</strong> and finds the parent commit from this. The current branch, master, and the <strong>HEAD</strong> pointer, are then reset to the parent commit, as are the staging area and working tree.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Undo – Remove a commit and retain changes to files</h1>
                
            
            
                
<p>Instead of performing the hard reset and thereby losing all the changes the commit introduced, the reset can be performed so that the changes are retained in the working directory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll again use the example of the hello world repository. Make a fresh clone of the repository, or reset the master branch if you have already cloned one.</p>
<p>You can make a fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong> 
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>You can reset the existing clone as follows:</p>
<pre><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><br/><strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll check whether we have made any changes to files in the working tree (just for the clarity of the example) and the history of the repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong> 

<strong>nothing to commit, working directory clean</strong> 

<strong>$ git log --oneline</strong> 
<strong>3061dc6 Adds Java version of 'hello world'</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> </pre>
<ol start="2">
<li>Now, we'll undo the commit and retain the changes introduced to the working tree:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --mixed HEAD^</strong>  

<strong>$ git log --oneline</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> 

<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.</strong> 

<strong>  (use "git pull" to update your local branch)</strong>  

<strong>Untracked files:</strong> 

<strong>  (use "git add &lt;file&gt;..." to include in what will be committed)</strong> 
 
<strong>    HelloWorld.java</strong> 
<strong>    Makefile</strong> 

<strong>nothing added to commit but untracked files present (use "git add" to track)</strong> </pre>
<p>We can see that our commit has been undone, but the changes to the file are preserved in the working tree, so more work can be done in order to create a proper commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">From the parent commit pointed to by the commit at <strong>HEAD</strong>, Git resets the branch pointer and <strong>HEAD</strong> to point to the parent commit. The staging area is reset, but the working tree is kept as it was before the reset, so the files affected by the <kbd>undone</kbd> commit will be in a modified state. This is illustrated in the following diagram:</p>
<div><img class="alignnone size-full wp-image-296 image-border" src="img/e13784eb-69eb-47d4-8e68-60a67c7ce54f.png" style="width:49.67em;height:22.92em;"/></div>
<p>The <kbd>--mixed</kbd> option is the default behavior of <kbd>git reset</kbd>, so it can be omitted: <kbd>git reset HEAD^</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Undo – Remove a commit and retain changes in the staging area</h1>
                
            
            
                
<p>Of course, it is also possible to undo the commit, but keep the changes to the files in the index or the staging area so that you are ready to recreate the commit with, for example, some minor modifications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll still use the example of the hello world repository. Make a fresh clone of the repository, or reset the master branch if you have already cloned one.</p>
<p>Create a fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git<br/></strong><strong>$ cd G</strong><strong>it-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>We can reset the existing clone as follows:</p>
<pre> <strong>$ git checkout master</strong> <br/><strong> $ git reset --hard origin/master</strong> <br/><br/><strong> HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Check whether we have any files in the modified state and check the log:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong>  

<strong>nothing to commit, working directory clean</strong> 

<strong>$ git log --oneline</strong> 
<strong>3061dc6 Adds Java version of 'hello world'</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> </pre>
<ol start="2">
<li>Now, we can undo the commit, while retaining the changes in the index:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --soft HEAD^</strong> 

<strong>$ git log --oneline</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> 

<strong>$ git status</strong> 
<strong>On branch master</strong> 

<strong>Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.</strong> 

<strong>  (use "git pull" to update your local branch)</strong> 

<strong>Changes to be committed:</strong> 

<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong> 

<strong>    new file:   HelloWorld.java</strong> 
<strong>    new file:   Makefile</strong> </pre>
<p>You can now make minor (or major) changes to the files you need, add them to the staging area, and create a new commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Again, Git will reset the branch pointer and <strong>HEAD</strong> to point to the previous commit. However, with the <kbd>--soft</kbd> option, the index and working directories are not reset, that is, they have the same state as they had before we created the now undone commit.</p>
<p class="mce-root CDPAlignLeft CDPAlign">The following diagram shows the Git state before and after the undo:</p>
<div><img class="alignnone size-full wp-image-297 image-border" src="img/4bc521cd-e084-4f77-a755-a04c4fcb7677.png" style="width:48.00em;height:21.92em;"/></div>
<div><h1 class="header-title">Undo – Working with a dirty area</h1>
                
            
            
                
<p>In the previous examples, we assumed that the working tree was clean, that is, no tracked files were in the modified state. However, this is not always the case, and if a hard reset is carried out, the changes to the modified files will be lost. Fortunately, Git provides a smart way to quickly put stuff away so that it can be retrieved later using the <kbd>git stash</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the example of the hello world repository. Make a fresh clone of the repository, or reset the master branch if you have already cloned one.</p>
<p>We can create the fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git<br/></strong><strong>$ cd </strong><strong>G</strong><strong>it-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>We can reset the existing clone as follows:</p>
<pre><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><br/><strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>
<p>We'll also need to have some files in the working condition, so we'll change <kbd>hello_world.c</kbd> to the following:</p>
<pre><strong>#include &lt;stdio.h&gt;</strong> 
<br/><strong>void say_hello(void) {</strong> 
<strong>  printf("hello, worldn");</strong> 
<strong>}</strong> 

<strong>int main(void){</strong> 
<strong>  say_hello();</strong> 
<strong>  return 0;</strong> 
<strong>}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In order to not accidentally delete any changes you have in your working tree when you are about to undo a commit, you can have a look at the current state of your working directory with <kbd>git status</kbd> command (as we already saw). If you have changes and you want to keep them, you can stash them away before undoing the commit and retrieve them afterward. Git provides a stash command that can put unfinished changes away, so it is easy to make quick context switches without losing work. The stash functionality is described further in <a href="ea1a1df3-bda4-4d35-b7de-67e38d18bcb0.xhtml">Chapter 11</a>, <em>Tips and Tricks</em>. For now, you can think of the stash command as a stack where you can put your changes and pop them later.</p>
<p>With the <kbd>hello_world.c</kbd> file in the working directory modified to the preceding state, we can try to do a hard reset on the <kbd>HEAD</kbd> commit, keeping our changes to the file by stashing them away before the reset and applying them again later:</p>
<ol>
<li>First, check the history:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --oneline</strong> 
<strong>3061dc6 Adds Java version of 'hello world'</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> </pre>
<ol start="2">
<li>Then, check the status:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong>

<strong>Changes not staged for commit:</strong> 

<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong> 

<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong> 
 
<strong>  modified:   hello_world.c</strong> 

<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong> </pre>
<ol start="3">
<li> As expected, <kbd>hello_world.c</kbd> was in the modified state; so, stash it away, check the status, and perform the reset:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git stash</strong> 
<strong>Saved working directory and index state WIP on master: 3061dc6 Adds Java version of 'hello world'</strong> 

<strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong> 
 
<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong>  
<strong>nothing to commit, working directory clean</strong>  

<strong>$ git reset --hard HEAD^</strong> 
<strong>HEAD is now at 9c7532f Fixes compiler warnings</strong> 

<strong>$ git log --oneline</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> </pre>
<ol start="4">
<li>The reset is done, and we got rid of the commit we wanted. Let's resurrect the changes we stashed away and check the file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git stash pop</strong> 
<strong>On branch master</strong> 
<strong>Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.</strong> 

<strong>  (use "git pull" to update your local branch)</strong> 

<strong>Changes not staged for commit:</strong> 
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong> 
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong> <br/><strong>modified:   hello_world.c</strong> 
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong> 
<strong>Dropped refs/stash@{0} (e56b68a1f5a0f72afcfd064ec13eefcda7a175ca)</strong> 

<strong>$ cat hello_world.c</strong> 

<strong>#include &lt;stdio.h&gt;</strong> 
<strong>void say_hello(void) {</strong> 
<strong>  printf("hello, worldn");</strong> 
<strong>}</strong> 
<strong>int main(void){</strong> 
<strong>  say_hello();</strong> 
<strong>  return 0;</strong> 
<strong>}</strong> </pre>
<p>So, the file is back to the state it was in before the reset, and we got rid of the unwanted commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The reset command works as explained in the previous examples but, combined with the stash command, it forms a very useful tool that corrects mistakes even though you have already starting working on something else. The stash command works by saving the current state of your working directory and the staging area. Then, it reverts your working directory to a clean state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Redo – Recreate the latest commit with new changes</h1>
                
            
            
                
<p>As with undo, redo can mean a lot of things. In this context, redoing a commit will mean creating almost the same commit again with the same parent(s) as the previous commit, but with different content and/or different commit messages. This is quite useful if you've just created a commit, but have perhaps forgotten to add a necessary file to the staging area before you committed, or if you need to reword the commit message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the hello world repository. Make a fresh clone of the repository, or reset the master branch if you have already cloned one.</p>
<p>We can create a fresh clone as follows:</p>
<pre><strong>$ git https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong> 
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>We can reset an existing clone as follows:</p>
<pre><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><strong><br/>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's pretend we need to redo the latest commit because we need to reword the commit message to include a reference to the issue tracker.</p>
<ol>
<li>Let's first take a look at the latest commit and make sure the working directory is clean:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong> 

<strong>commit 3061dc6cf7aeb2f8cb3dee651290bfea85cb4392</strong> 
<strong>Author: </strong><strong>John Doe &lt;john.doe@example.com&gt;</strong> 
<strong>Date:   Sun Mar 9 14:12:45 2014 +0100</strong> 
<strong>    Adds Java version of 'hello world'</strong> 
<strong>    Also includes a makefile</strong> 

<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong> 
<strong>nothing to commit, working directory clean</strong> </pre>
<ol start="2">
<li>Now, we can redo the commit and update the commit message with the git commit <kbd>--amend</kbd> command. This will bring up the default editor, and we can add a reference to the issue tracker in the commit message (<kbd>Fixes: RD-31415</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --amend</strong> 
<strong>Adds Java version of 'hello world'</strong> 
<strong>Also includes a makefile</strong> 
<strong>Fixes: RD-31415</strong> 

<strong># Please enter the commit message for your changes. Lines starting</strong> 
<strong># with '#' will be ignored, and an empty message aborts the commit.</strong> 
<strong>#</strong> 
<strong># Author:   </strong><strong> John Doe &lt;john.doe@example.com&gt;</strong> 
<strong>#</strong> 
<strong># On branch master</strong> 
<strong># Your branch is up-to-date with 'origin/master'.</strong> 
<strong>#</strong> 
<strong># Changes to be committed:</strong> 
<strong>#       new file:   HelloWorld.java</strong> 
<strong>#       new file:   Makefile</strong> 
<strong>#</strong> 

<strong>~</strong> 
<strong>~</strong> 
<strong>[master 75a41a2] Adds Java version of 'hello world'</strong> 
<strong> Author:</strong><strong> John Doe &lt;john.doe@example.com&gt;</strong> 
<strong> 2 files changed, 19 insertions(+)</strong> 
<strong> create mode 100644 HelloWorld.java</strong> 
<strong> create mode 100644 Makefile</strong></pre>
<ol start="3">
<li> Now, let's check the log again to see whether everything worked:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong> 

<strong>commit 75a41a2f550325234a2f5f3ba41d35867910c09c</strong> 

<strong>Author: </strong> <strong>John Doe &lt;john.doe@example.com&gt;<br/></strong><strong>Date: Sun Mar 9 14:12:45 2014 +0100</strong> <strong> Adds Java version of 'hello world'</strong> <strong> Also includes a makefile</strong> <strong> Fixes: RD-31415</strong></pre>
<ol start="4">
<li>We can see that the commit message has changed, but we can't verify from the log output that the parent of the commit is the same as in the original commit, and so on, as we saw in the first commit we did. To check this, we can use the <kbd>git cat-file</kbd> command we learned about in <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>. First, let's see how the original commit looked:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git cat-file -p 3061dc6</strong> 

<strong>tree d3abe70c50450a4d6d70f391fcbda1a4609d151f</strong> 
<strong>parent 9c7532f5e788b8805ffd419fcf2a071c78493b23</strong> 

<strong>author </strong><strong>John Doe &lt;john.doe@example.com&gt; </strong><strong>1394370765 +0100</strong> <br/><strong>committer John Doe &lt;john.doe@example.com&gt; 1394569447 +0100</strong> <strong>Adds Java version of 'hello world'</strong> <strong>Also includes a makefile</strong></pre>
<p style="padding-left: 60px">The parent commit is <kbd>b8c39bb35c4c0b00b6cfb4e0f27354279fb28866</kbd>, and the root tree is <kbd>d3abe70c50450a4d6d70f391fcbda1a4609d151f</kbd>.</p>
<ol start="5">
<li>Let's check the data from the new commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git cat-file -p HEAD</strong> 

<strong>tree d3abe70c50450a4d6d70f391fcbda1a4609d151f</strong> 
<strong>parent 9c7532f5e788b8805ffd419fcf2a071c78493b23</strong> 
<strong>author John Doe &lt;john.doe@example.com&gt; 1394370765 +0100</strong> 
<strong>committer John Doe &lt;john.doe@example.com&gt; 1394655225 +0100</strong> 
<br/><strong>Adds Java version of 'hello world'</strong> 
<strong>Also includes a makefile</strong> 
<strong>Fixes: RD-31415</strong></pre>
<p style="padding-left: 60px">The parent is the same, that is, <kbd>9c7532f5e788b8805ffd419fcf2a071c78493b23</kbd> and the root tree is also the same, that is, <kbd>d3abe70c50450a4d6d70f391fcbda1a4609d151f</kbd>. This is what we expected as we only changed the commit message. If we had added some changes to the staging area and executed <kbd>git commit--amend</kbd>, we would have included those changes in the commit and the root-tree SHA1 ID would have been different, but the parent commit ID still the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>--amend</kbd> option to git commit is roughly equivalent to performing <kbd>git reset --soft HEAD^</kbd>, followed by fixing the files needed and adding those to the staging area. Then, we will run git commit reusing the commit message from the previous commit (<kbd>git commit -c ORIG_HEAD</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can also use the <kbd>--amend</kbd> method to add missing files to our latest commit. Let's say you needed to add the <kbd>README.md</kbd> file to your latest commit in order to get the documentation up to date, but you have already created the commit, though you have not pushed it yet.</p>
<p>You then add the file to the index as you would while starting to craft a new commit. You can check with git status that only the <kbd>README.md</kbd> file is added:</p>
<pre><strong>$ git add README.md</strong> 

<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch and 'origin/master' have diverged,</strong> 
<strong>and have 1 and 1 different commit each, respectively.</strong> 
<strong>  (use "git pull" to merge the remote branch into yours)</strong> 

<strong>Changes to be committed:</strong> 
<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong> 

<strong>  new file:   README.md</strong></pre>
<p>Now, you can amend the latest commit with <kbd>git commit --amend</kbd>. The command will include files in the index in the new commit and you can, as with the last example, reword the commit message if needed. It is not needed in this example, so we'll pass the <kbd>--no-edit</kbd> option to the command:</p>
<pre><strong>$ git commit --amend --no-edit</strong> 

<strong>[master f09457e] Adds Java version of 'hello world'</strong> 
<strong> Author: John Doe &lt;john.doe@example.com&gt;</strong> 
<strong> 3 files changed, 20 insertions(+)</strong> 
<strong> create mode 100644 HelloWorld.java</strong> 
<strong> create mode 100644 Makefile</strong> 
<strong> create mode 100644 README.md</strong> </pre>
<p>You can see from the output of the commit command that three files were changed and <kbd>README.md</kbd> was one of them.</p>
<p>You can also reset the author information (name, email, and timestamp) with the commit <kbd>--amend</kbd> command. Just pass along the <kbd>--reset-author</kbd> option and Git will create a new timestamp and read author information from the configuration or environment, instead of the using information from the old commit object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Revert – Undo the changes introduced by a commit</h1>
                
            
            
                
<p>Revert can be used to undo a commit in history that has already been published (pushed), whereas this can't be done with the amend or reset options without rewriting history.</p>
<p>Revert works by applying the anti-patch introduced by the commit in question. A revert will, by default, create a new commit in history with a commit message that describes which commit has been reverted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the hello world repository. Make a fresh clone of the repository, or reset the master branch if you have already cloned one.</p>
<p>We can create a fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong> 
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>We can reset the existing clone as follows:</p>
<pre><strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook<br/></strong><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll list the commits in the repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --oneline</strong> 
<strong>3061dc6 Adds Java version of 'hello world'</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world </strong> </pre>
<ol start="2">
<li>We'll revert the second commit, <kbd>9c7532f</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git revert 9c7532f</strong> 

<strong>Revert "Fixes compiler warnings"</strong> 
<strong>This reverts commit 9c7532f5e788b8805ffd419fcf2a071c78493b23.</strong> 

<strong># Please enter the commit message for your changes. Lines starting</strong> 
<strong># with '#' will be ignored, and an empty message aborts the commit.</strong> 
<strong># On branch master</strong> 
<strong># Your branch is up-to-date with 'origin/master'.</strong> 
<strong>#</strong> 
<strong># Changes to be committed:</strong> 
<strong>#       modified:   hello_world.c</strong> 
<strong>#</strong> 
<strong>~</strong> 
<strong>~</strong> 
<strong>~</strong> 
<strong>"~/john.doe/packt/repos/</strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong><strong>/.git/COMMIT_EDITMSG" 12L, 359C</strong> <strong>[master 9b94515] Revert "Fixes compiler warnings"</strong> <strong> 1 file changed, 1 insertion(+), 5 deletions(-)</strong></pre>
<ol start="3">
<li>When we check the log, we can see that a new commit has been made:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --oneline</strong> 
<strong>9b94515 Revert "Fixes compiler warnings"</strong> 
<strong>3061dc6 Adds Java version of 'hello world'</strong> 
<strong>9c7532f Fixes compiler warnings</strong> 
<strong>5b5d692 Initial commit, K&amp;R hello world</strong> </pre>
<p style="padding-left: 60px">We can take a closer look at the two commits with <kbd>git show</kbd> if we want a closer investigation of what happened.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>git revert</kbd> command applies the anti-patch of the commit in question to the current <kbd>HEAD</kbd> pointer. It will generate a new commit with the anti-patch and a commit message that describes the reverted commit(s).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's possible to revert more than one commit in a single revert, for example, <kbd>git revert master~6..master~2</kbd> will revert the commits from the sixth commit from the bottom in the master to the third commit from the bottom in the master (both included).</p>
<p>It is also possible not to create a commit while reverting; passing the <kbd>-n</kbd> option to <kbd>git revert</kbd> will apply the needed patched, but only to the working tree and the staging area.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reverting a merge</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">Merge commits are a special case when it comes to revert. In order to be able to revert a merge commit, you'll have to specify which parent side of the merge you want to keep. However, when you revert a merge commit, you should keep in mind that though reverting will undo changes to files, it doesn't undo history. This means that when you revert a merge commit, you declare that you will not have any of the changes introduced by the merge in the target branch.</p>
<p class="mce-root CDPAlignLeft CDPAlign">The effect of this is that the subsequent merges from the other branch will only bring in changes of commits that are not ancestors of the reverted merge commit.</p>
<div><img class="alignnone size-full wp-image-298 image-border" src="img/8e5563b1-ec5c-4e9f-a13b-89d952260338.png" style="width:137.58em;height:50.92em;"/></div>
<p>In this example, we will learn how to revert a merge commit, and we'll learn how we can merge the branch again, merging all of the changes by reverting to the reverted merge commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the hello world repository. Make a fresh clone of the repository, or reset the master branch if you have already cloned one.</p>
<p>We can create a fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong> 
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>We can reset the existing clone as follows:</p>
<pre><strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook<br/></strong><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><br/><strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>
<p>In this example, we also need to use some of the other branches in the repository, so we need to create them locally:</p>
<pre><strong>$ git branch -f feature/p-lang origin/feature/p-lang</strong> 
<strong>Branch feature/p-lang set up to track remote branch feature/p-lang from origin.</strong> 

<strong>$ git checkout develop</strong> 
<strong>Switched to branch 'develop'</strong> 
<strong>Your branch is up-to-date with 'origin/develop'.</strong> 

<strong>$ git reset --hard origin/develop</strong> 
<strong>HEAD is now at a95abc6 Adds Groovy hello world</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>On the develop branch, we have just checked that there is a merge commit that introduces hello world programs from languages that start with P.</p>
<p>Unfortunately, the Perl version doesn't run:</p>
<pre><strong>$ perl hello_world.pl</strong> 

<strong>Can't find string terminator '"' anywhere before EOF at hello_world.pl line 3.</strong> </pre>
<p>The following steps will help you revert a merge:</p>
<ol>
<li>Let's take a look at the history, the latest five commits, and find the merge commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --oneline --graph -5</strong> 
<strong>* a95abc6 Adds Groovy hello world</strong> 
<strong>*   5ae3beb Merge branch 'feature/p-lang' into develop</strong> 

<strong>|</strong> 
<strong>| * 7b29bc3 php version added</strong> 
<strong>| * 9944417 Adds perl hello_world script</strong> 
<strong>* | ed9af38 Hello world shell script</strong> 
<strong>|/</strong></pre>
<p style="padding-left: 60px">The commit we are looking for is <kbd>5ae3beb Merge branch 'feature/p-lang' into develop</kbd>; this adds the commits for hello world in Perl and PHP to the develop branch. We would like the fix of the Perl version to happen on the feature branch, and then merge it to develop when ready. In order to keep <kbd>develop</kbd> stable, we need to revert the merge commit that introduced the faulty Perl version. Before we perform the merge, let's just have a look at the content of <kbd>HEAD</kbd>:</p>
<pre style="padding-left: 60px"><strong>$ git ls-tree --abbrev HEAD</strong> 

<strong>100644 blob 28f40d8    helloWorld.groovy</strong> 
<strong>100644 blob 881ef55    hello_world.c</strong> 
<strong>100644 blob 5dd01c1    hello_world.php</strong> 
<strong>100755 blob ae06973    hello_world.pl</strong> 
<strong>100755 blob f3d7a14    hello_world.py</strong> 
<strong>100755 blob 9f3f770    hello_world.sh</strong> </pre>
<ol start="2">
<li>Revert the merge, keeping the history of the first parent:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git revert -m 1 5ae3beb</strong> 

<strong>[develop e043b95] Revert "Merge branch 'feature/p-lang' into develop"</strong> 

<strong> 2 files changed, 4 deletions(-)</strong> 
<strong> delete mode 100644 hello_world.php</strong> 
<strong> delete mode 100755 hello_world.pl</strong> </pre>
<ol start="3">
<li>Let's have a look at the content of our new <kbd>HEAD</kbd> state:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git ls-tree --abbrev HEAD</strong> 

<strong>100644 blob 28f40d8    helloWorld.groovy</strong> 
<strong>100644 blob 881ef55    hello_world.c</strong> 
<strong>100755 blob f3d7a14    hello_world.py</strong> 
<strong>100755 blob 9f3f770    hello_world.sh</strong> </pre>
<p>The Perl and PHP files introduced in the merge are gone, so the revert did its job.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The revert command will take the patches introduced by the commit you want to revert and apply the reverse/anti-patch to the working tree. If all goes well, that is, there are no conflicts, a new commit will be made. While reverting a merge commit, only the changes introduced in the mainline (the <kbd>-m</kbd> option) will be kept, and all the changes introduced in the other side of the merge will be reverted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Though it is easy to revert a merge commit, you might run into issues if you later want to the branch again because the issues on the merge have not been fixed. While reverting the merge commit, you actually tell Git that you do not want any of the changes that the other branch introduced in this branch. So, when you try to merge in the branch again, you will only get the changes from the commits that are not ancestors of the reverted merge commit.</p>
<p>We will see this in action by trying to merge the <kbd>feature/p-lang</kbd> branch with the develop branch again:</p>
<pre><strong>$ git merge --no-edit feature/p-lang</strong> 

<strong>CONFLICT (modify/delete): hello_world.pl deleted in HEAD and modified in feature/p-lang. Version feature/p-lang of hello_world.pl left in tree.</strong> 

<strong>Automatic merge failed; fix conflicts and then commit the result.</strong> </pre>
<p>We can solve the conflict just by adding <kbd>hello_world.pl</kbd>:</p>
<pre><strong>$ git add hello_world.pl</strong> 

<strong>$ git commit</strong> 
<strong>[develop 2804731] Merge branch 'feature/p-lang' into develop</strong> </pre>
<p>Let's check the tree to see whether everything seems alright:</p>
<pre><strong>$ git ls-tree --abbrev HEAD</strong> 

<strong>100644 blob 28f40d8    helloWorld.groovy</strong> 
<strong>100644 blob 881ef55    hello_world.c</strong> 
<strong>100755 blob 6611b8e    hello_world.pl</strong> 
<strong>100755 blob f3d7a14    hello_world.py</strong> 
<strong>100755 blob 9f3f770    hello_world.sh</strong> </pre>
<p>The <kbd>hello_world.php</kbd> file is missing, but this makes sense as the change that introduced it was reverted in the reverted merge commit.</p>
<p>To perform a proper re-merge, we first have to revert the reverting merge commit; this might seem a bit weird, but it is the way to get the changes from before the revert back into our tree. Then, we can perform another merge of the branch, and we'll end up with all the changes introduced by the branch we're merging in. However, we first have to discard the merge commit we just made with a hard reset:</p>
<pre><strong>$ git reset --hard HEAD^</strong> 

<strong>HEAD is now at c46deed Revert "Merge branch 'feature/p-lang' into develop"</strong> </pre>
<p>Now, we can revert the reverting merge and re-merge the branch:</p>
<pre><strong>$ git revert HEAD</strong> 

<strong>[develop 9950c9e] Revert "Revert "Merge branch 'feature/p-lang' into develop""</strong> 
<strong> 2 files changed, 4 insertions(+)</strong> 
<strong> create mode 100644 hello_world.php</strong> 
<strong> create mode 100755 hello_world.pl</strong> 

<strong>$ git merge feature/p-lang</strong> 

<strong>Merge made by the 'recursive' strategy.</strong> 
<strong> hello_world.pl | 2 +-</strong> 
<strong> 1 file changed, 1 insertion(+), 1 deletion(-)</strong> </pre>
<p>Let's check the tree for the Perl and PHP files, and see whether the Perl file has been fixed:</p>
<pre><strong>$ git ls-tree --abbrev HEAD</strong> 

<strong>100644 blob 28f40d8    helloWorld.groovy</strong> 
<strong>100644 blob 881ef55    hello_world.c</strong> 
<strong>100644 blob 5dd01c1    hello_world.php</strong> 
<strong>100755 blob 6611b8e    hello_world.pl</strong> 
<strong>100755 blob f3d7a14    hello_world.py</strong> 
<strong>100755 blob 9f3f770    hello_world.sh</strong> 

<strong>$ perl hello_world.pl</strong> 
<strong>Hello, world!</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more information on reverting merges, refer to the following articles:</p>
<ul>
<li>The <em>How To Revert a Faulty Merge</em> article at <a href="https://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.html">https://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.html</a></li>
<li>The <em>Undoing Merges</em> article at <a href="http://git-scm.com/blog/2010/03/02/undoing-merges.html">http://git-scm.com/blog/2010/03/02/undoing-merges.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Viewing past Git actions with git reflog</h1>
                
            
            
                
<p>The <kbd>reflog</kbd> command stores information on updates to the tip of the branches in Git, where the normal <kbd>git log</kbd> command shows the ancestry chain from <kbd>HEAD</kbd>, and the <kbd>reflog</kbd> command shows what <kbd>HEAD</kbd> has pointed to in the repository. This is your history in the repository, which tells you how you have moved between branches, created your commits and resets, and so on. Basically, anything that makes <kbd>HEAD</kbd> point to something new is recorded in the <kbd>reflog</kbd>. This means that, by going through the <kbd>reflog</kbd> command, you can find lost commits that none of your branches or other commits point to. This makes the <kbd>reflog</kbd> command a good starting point for trying to find a lost commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the hello world repository. If you make a fresh clone, make sure to run the scripts for this chapter so that there will be some entries in the <kbd>reflog</kbd> command.</p>
<p>The scripts can be found on the book's home page. If you just reset the master branch to <kbd>origin/master</kbd> after performing the recipes in this chapter, everything will be ready.</p>
<p>We can create a fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong>
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_</strong><strong>hello_world_cookbook</strong></pre>
<p>We can reset an existing clone as follows:</p>
<pre><strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_</strong><strong>hello_world_cookbook<br/></strong><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's try to run the <kbd>reflog</kbd> command and limit ourselves to just the latest seven entries:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reflog -7</strong> 

<strong>3061dc6 HEAD@{0}: checkout: moving from develop to master</strong> 
<strong>d557284 HEAD@{1}: merge feature/p-lang: Merge made by the 'recursive' strategy.</strong> 
<strong>9950c9e HEAD@{2}: revert: Revert "Revert "Merge branch 'feature/p-lang' into develop""</strong> 
<strong>c46deed HEAD@{3}: reset: moving to HEAD^</strong> 
<strong>2804731 HEAD@{4}: commit (merge): Merge branch 'feature/p-lang' into develop</strong> 
<strong>c46deed HEAD@{5}: revert: Revert "Merge branch 'feature/p-lang' into develop"</strong> 
<strong>a95abc6 HEAD@{6}: checkout: moving from master to develop</strong> </pre>
<p>In your repository, the commits will have different SHA-1 hashes due to the fact that the commits generated in the examples will have slightly different content, specifically your username and email address, but the order should be approximately the same.</p>
<p style="padding-left: 60px">We can see the actions we performed in the last example by reverting, committing, and resetting. We can see the merge commit, <kbd>2804731</kbd>, that we abandoned. It didn't merge in all the changes we wanted it to due to the previous merge and its revert.</p>
<ol start="2">
<li>We can take a closer look at the commit with <kbd>git show</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show 2804731</strong> 
<strong>commit 2804731c3abc4824cdab66dc7567bed4cddde0d3</strong> 
<strong>Merge: c46deed 32fa2cd</strong> 
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong> 
<strong>Date:   Thu Mar 13 23:20:21 2014 +0100</strong> 

<strong>    Merge branch 'feature/p-lang' into develop</strong> 

<strong>   Conflicts:</strong> 
<strong>        hello_world.pl</strong> </pre>
<p style="padding-left: 60px">Indeed, this was the commit we chose to abandon in the previous example. We can also look at the tree of the commit, just as we did in the previous example, and check whether they are the same:</p>
<pre style="padding-left: 60px"><strong>$ git ls-tree --abbrev 2804731</strong> 

<strong>100644 blob 28f40d8    helloWorld.groovy</strong> 
<strong>100644 blob 881ef55    hello_world.c</strong> 
<strong>100755 blob 6611b8e    hello_world.pl</strong> 
<strong>100755 blob f3d7a14    hello_world.py</strong> 
<strong>100755 blob 9f3f770    hello_world.sh</strong> </pre>
<p style="padding-left: 60px">From here, there are various ways to resurrect the changes. You can either check out the commit and create a branch; then, you'll have a pointer so that you can easily find it again. You can also check out specific files from the commit with <kbd>git checkout</kbd> – <kbd>path/to/file SHA-1</kbd>, or you can use the <kbd>git show</kbd> or <kbd>git cat-file</kbd> commands to view the files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>For every movement of the <kbd>HEAD</kbd> pointer in the repository, Git stores the commit pointed to and the action for getting there. This can be commit, checkout, reset, revert, merge, rebase, and so on. The information is local to the repository and is not shared on pushes, fetches, and clones. Using the <kbd>reflog</kbd> command to find the lost commits is fairly easy if you know what you are searching for and the approximate time when you created the commit you are searching for. If you have a lot of reflog history, many commits, switching branches, and so on, it can be hard to search through the <kbd>reflog</kbd> command due to the amount of noise from the many updates to <kbd>HEAD</kbd>. The output of the <kbd>reflog</kbd> command can be a lot of options and, among them, there are options you can also pass on to the normal <kbd>git log</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding lost changes with git fsck</h1>
                
            
            
                
<p>Another tool exists in Git that can help you find and recover lost commits and even blobs (files), which is <kbd>git fsck</kbd>. The <kbd>fsck</kbd> command tests the object database and verifies the SHA-1 ID of the objects and the connections they make. This command can also be used to find objects that are not reachable from any named reference, as it tests all the objects found in the database, which are in the <kbd>.git/objects</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we'll use the hello world repository. If you make a fresh clone, make sure to run the scripts for this chapter (<kbd>04_undo_dirty.sh</kbd>), so there will be some objects for <kbd>git fsck</kbd> to consider. The scripts can be found on the book's home page. If you just reset the master branch after performing the other recipes in the chapter, everything will be ready.</p>
<p>We can create the fresh clone as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook.git</strong> 
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook</strong></pre>
<p>We can reset an existing clone as follows:</p>
<pre><strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook<br/></strong><strong>$ git checkout master</strong> <br/><strong>$ git reset --hard origin/master</strong> <br/><strong>HEAD is now at 3061dc6 Adds Java version of 'hello world'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's look for the unreachable objects in the database:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fsck --unreachable</strong> 

<strong>Checking object directories: 100% (256/256), done.</strong> 
<strong>unreachable commit 147240ad0297f85c9ca3ed513906d4b75209e83d</strong> 
<strong>unreachable blob b16cf63ab66605f9505c17c5affd88b34c9150ce</strong> 
<strong>unreachable commit 4c3b1e10d8876cd507bcf2072c85cc474f7fb93b</strong> </pre>
<p>The object's ID, the SHA-1 hash, will not be the same if you perform the example on your computer, as the committer, author, and timestamp will be different.</p>
<ol start="2">
<li>We found two commits and one blob. Let's take a closer look at each of them; the blob first:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show b16cf63ab66605f9505c17c5affd88b34c9150ce</strong> 

<strong>#include &lt;stdio.h&gt;</strong> 
<strong>void say_hello(void) {</strong> 
<strong>  printf("hello, worldn");</strong> 
<strong>}</strong> 
 
<strong>int main(void){</strong> 
<strong>  say_hello();</strong> 
<strong>   return 0;</strong> 
<strong>}</strong> </pre>
<p style="padding-left: 60px">So, the blob is the <kbd>hello_world.c</kbd> file from the example, which stashes away your changes before resetting a commit. Here, we stashed away the file, performed a reset, and resurrected the file from the stash, but we never actually performed a commit. The stash command, however, did add the file to the database, so it could find it again, and the file will continue to be there until the garbage collection kicks in, or forever if it is referenced by a commit in the general history.</p>
<ol start="3">
<li>Let's look more closely at the two commits:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show 147240ad0297f85c9ca3ed513906d4b75209e83d</strong> 

<strong>commit 147240ad0297f85c9ca3ed513906d4b75209e83d</strong> 
<strong>Merge: 3061dc6 4c3b1e1</strong> 
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong> 
<strong>Date:   Thu Mar 13 23:19:37 2014 +0100</strong> 
 <strong>    WIP on master: 3061dc6 Adds Java version of 'hello world'</strong> 

<strong>diff --cc hello_world.c</strong> 
<strong>index 881ef55,881ef55..b16cf63</strong> 
<strong>--- a/hello_world.c</strong> 
<strong>+++ b/hello_world.c</strong> 
<strong>@@@ -1,7 -1,7 +1,10 @@@</strong> 
<br/><strong>  #include &lt;stdio.h&gt;</strong> 

<strong>--int main(void){</strong> 
<strong>  ++void say_hello(void) {</strong> 
<strong>    printf("hello, worldn");</strong> 
<strong>++}</strong> 

<strong>++int main(void){</strong> 
<strong>  ++  say_hello();</strong> 
<strong>  return 0;</strong> 
<strong>--}</strong> 
<strong>++}</strong> 

<strong>$ git show 4c3b1e10d8876cd507bcf2072c85cc474f7fb93b</strong> 

<strong>commit 4c3b1e10d8876cd507bcf2072c85cc474f7fb93b</strong> 
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong> 
<strong>Date:   Thu Mar 13 23:19:37 2014 +0100</strong> 
<strong>    index on master: 3061dc6 Adds Java version of 'hello world'</strong> </pre>
<p>Both of the commits are actually commits we made when we stashed away our changes in the previous example. The stash command creates a commit object with the content of the staging area, and a merge commit merging <kbd>HEAD</kbd> and the commit with the index with the content of the working directory (tracked files only). As we resurrected our stashed changes in the previous example, we no longer have any reference pointing at the preceding commits; therefore, they are found by <kbd>git fsck</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>git fsck</kbd> command will test all the objects found in the <kbd>.git/objects</kbd> folder. When the <kbd>--unreachable</kbd> option is given, it will report the objects found that can't be reached from another reference; a reference can be a branch, a tag, a commit, a tree, the <kbd>reflog</kbd>, or changes that have been stashed away.</p>


            

            
        
    </body></html>