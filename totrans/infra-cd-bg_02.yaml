- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible and Terraform beyond the Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next phase in our journey to **Infrastructure as Code** (**IaC**) is to
    take a look at **Terraform**, an IaC tool from HashiCorp, and **Ansible**, an
    IaC and configuration management tool from *Red Hat*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also compare the advantages and disadvantages of using them, set them
    up on macOS, Windows 11, and Ubuntu Linux, and look at using Visual Studio Code
    as an **integrated development environment** (**IDE**) to write our code, plus
    look at which recommended extensions to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is important when choosing a tool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Visual Studio Code, the open source IDE from Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start looking at the tools we will be using throughout this title,
    let’s quickly discuss a checklist I use to choose which tools to use in a project.
  prefs: []
  type: TYPE_NORMAL
- en: What is important when choosing a tool?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you have a new project – you know which cloud provider you will use, and
    your development team has given you an overview of their application – meaning
    you already have a good idea of the resources you will deploy and manage. You
    have been given free rein to choose which IaC tool to use – so how do you choose?
  prefs: []
  type: TYPE_NORMAL
- en: Personally, my approach is always to use the best tool for the job rather than
    trying to fit the job to the tool – that, in my experience, always ends up causing
    issues when it comes to deploying the code and managing the deployment once it
    has been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Let us discuss some of the key things you will need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two main types of deployment I come across, with the first being using
    IaC to repeatedly deploy the same resources in a predictable and consistent way.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case for this approach is for dev, test, and other lower
    environments, not production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to integrate with your developer’s build, release, and test pipelines
    so that when they push their code changes for one of the environment branches
    mentioned, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The push triggers the deployment of the resources using your IaC scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the resources have been deployed, your IaC pipeline hands back over to
    developers’ pipelines for them to build their code and deploy it to the resources
    that have just been launched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the application code has been deployed, run the developer’s automated testing
    or notify someone within the team that the newly pushed code is ready for manual
    testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, with testing complete, after the results are stored and either by an
    automated or manual decision gate in the pipeline, the resources deployed at the
    start of the process are terminated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process above is repeated for each push – with multiple deployments sometimes
    being executed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of taking an approach like this is that you not only get cost
    savings, but you are only running resources while they are needed. Additionally,
    configuration drift is avoided as you are launching the resources from scratch
    with each deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration drift occurs when someone with the best intentions quickly tweaks
    a setting somewhere manually to get something working and doesn’t document it
    anywhere. In this case, ad-hoc fixes would need to be rolled into your code for
    them to persist through to the next deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The next deployment type is to launch and manage your resources using your IaC
    scripts. As you may have guessed, this approach is used in longer-running environments
    such as production.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first think about this type of deployment, it is easy to assume that
    it is quite close to the first deployment type – however, in fact, the first deployment
    type is only executed once per deployment, whereas this type is executed multiple
    times against the same deployment which can introduce some interesting challenges,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the resource type, where is the line drawn between what is configured
    and managed by your IaC scripts and the application deployment?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you are dealing with long-running resources, what additional logic or error
    checking do you need to build into your IaC scripts so that the execution of your
    code is terminated rather than the resources you are running the code against?
    After all, you don’t want to cause an outage, no matter how easy it is to recreate
    your infrastructure!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are you managing the state of your infrastructure? As we will learn in the
    next section of this chapter, having a consistent state is important for one of
    the tools we will cover in this book – so where is it stored long term?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we will be talking a lot about IaC in this book, which I am hoping if
    you have made it this far shouldn’t be a surprise, where is the line drawn between
    your IaC scripts and the deployment/configuration of the application?
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this is when your project involves deploying **Infrastructure
    as a Service** (**IaaS**) resources such as virtual machines. Let’s say you need
    to deploy two Linux servers and then install NGINX along with a scripting language
    such as PHP on there; how will you achieve that?
  prefs: []
  type: TYPE_NORMAL
- en: Most public cloud providers allow you to attach and execute a script when launching
    a virtual machine using a service such as cloud-init – while this should cover
    most basic use cases, using this approach does add a level of abstraction that
    could cause problems – for example, does your cloud provider provide any details
    on the execution of the script – and will your IaC execution know if that has
    failed?
  prefs: []
  type: TYPE_NORMAL
- en: If you need more granular control or visibility of the commands being run as
    part of the deployment, then this will dictate which tool you choose as a pure
    IaC tool may not be enough for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: This will also influence the next decision.
  prefs: []
  type: TYPE_NORMAL
- en: External interactions and secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned at the end of the last section, if your IaC script needs to interact
    with a resource using a service outside of a publicly accessible API – such as
    **Secure Shell** (**SSH**) or **Windows Remote Management** (**WinRM)** to run
    scripts on a virtual machine or an internally hosted API such as the vSphere API
    used to manage resources hosted in VMWare environments, then you will carefully
    need to choose where your IaC is executed from as you will need line of sight
    to the resource you are interacting with.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, depending on how you manage secrets within your IaC scripts for things
    such as passwords or certificates for services you are launching, you will also
    need line of sight, by which I mean direct access, of your secret storage or a
    way of securely injecting them into your scripts because as storing them as *hardcoded
    values in plain text within your IaC is never an* *option, ever!*
  prefs: []
  type: TYPE_NORMAL
- en: This means that you will need to assess where and how you execute your scripts,
    considering things such as firewalls plus access to resources and credentials
    – all without exposing any secrets.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover all of this when we roll up our sleeves and start building up
    our deployment in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Ease of use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final consideration is simply how easy the tool is to use.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to get swept up in the latest shiny new technologies, but if you
    are the only person in your team who has any experience with it, you will be adding
    complications as not only will you need to up-skill the rest of the team so they
    can also work with the code but also you will need to deal the issues that can
    occur from being an early adopter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything we have discussed in this section should be at the forefront of your
    mind when approaching any IaC project. By the end of this book, you will have
    both the answers and experience to all of the questions and considerations raised
    during this section to be able to choose the right tool for the job rather than
    trying to fit your project to the tool, or what sometimes can only be described
    as fitting a square peg in a round hole.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time I hope you have been waiting for; we will look at our two main
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first of the two tools we will look at is Terraform by HashiCorp.
  prefs: []
  type: TYPE_NORMAL
- en: Hashicorp Terraform is an enterprise-ready cloud and virtualization management
    tool. It helps you manage your resources and deploy new instances with ease. Terraform
    is an open source tool for managing the cloud infrastructure, allowing you to
    not only efficiently configure and deploy your resources but also help you maintain
    your infrastructure while evolving it over time.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform has a unique architecture in that it uses a state machine to manage
    resources and it is fully modular, and you can scale the service as per your needs.
    Finally, it is also integrated with many third-party tools and services.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform uses the **Hashicorp Configuration Language** (**HCL**). You could
    be mistaken at first glance for thinking it is for JSON or YAML, but it’s a syntax
    and API designed by HashiCorp for building structured configuration formats, whereas
    YAML and JSON are just formats that define data structures in human- and machine-readable
    formats respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than going into any more detail about HCL – let’s take a look at an HCL
    example.
  prefs: []
  type: TYPE_NORMAL
- en: An HCL example – creating a resource group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I personally do a lot of my day-to-day work with Microsoft Azure, so I will
    target that with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to follow along; if you need assistance installing Terraform, then
    there are links to the relevant documentation in the *Further reading* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure has a concept of resource groups that act as a logical container for
    your resources, so let us start by creating one of those:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main sections we need in our Terraform, the first of which
    tells Terraform which version of Terraform our code is compatible with and also
    which external providers we need to use. In the case of creating a resource group,
    this looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One of the biggest selling points of Terraform is that it is both machine- and
    human-readable – I am sure you will agree from the small preceding snippet of
    code that it is easy to figure out what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have said that `required_version` of Terraform should be greater or
    equal to `1.0`. Next up, we have `required_providers`; a provider is an external
    library that extends the functionality – in this example, we are telling Terraform
    to download and use the latest version of the `3.0` release of the `azurerm` provider
    from `hashicorp/azurerm`, which is where the official provider releases should
    be sourced from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section configures the providers. For our example, we won’t do any
    additional configuration, so this just looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up is the final section of our example; this is where we configure our
    resource group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there is not much to it – we simply define what we want the
    resource to be called by providing `name` and also which Azure region we would
    like the resource group to be placed in using `location`.
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding code is placed in a file called `terraform.tf` in an empty
    folder. Before we can create the resource group, we will need to initialize Terraform;
    this will download the `azurerm` provider and create a few supporting files, such
    as `locks`, which are needed to execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the resource group, we first need to run the following command to
    prepare our local environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give something like the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So now that Terraform is ready, we can run it – first of all, we need to run
    a plan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us an idea of what Terraform is going to do when we apply
    our configuration; in my case, this gave the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What Terraform has done here are some basic flight checks, discovering that
    it doesn’t know about a resource group called `rg-example-uks` in the `uksouth`
    region and, therefore, it needs to add it, and because we are only creating a
    single resource there is `1` to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the resource group, we need to run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When doing so, it will give us the same output as when running `terraform plan`,
    but this time, as usual, if we want to proceed, answering `yes` will then deploy
    the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There we have it; our resource group has been created. Running the `terraform
    apply` command again gives the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, no changes are needed – now let’s add another resource – how about a storage
    account?
  prefs: []
  type: TYPE_NORMAL
- en: Adding more resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a storage account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we simply need the following resource at the end of the `terraform.tf`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running `terraform apply` now gives the following output, which I have truncated
    as the total amount of lines has gone from 13 to 166 lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer `yes` to get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, we now have our storage account – great, let’s destroy it and run it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of this command will tell us what is going to be removed (again,
    the output has been truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer `yes`, and that will, as you may have guessed, destroy the resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now running the script again using `terraform apply` tells us that two resources
    are going to be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, when you say `yes` and try to proceed, it will give an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why did it error? Let’s take a look at the error and figure out what happened.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, why are we getting the error?
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, in the previous chapter, we discussed the differences between
    imperative and declarative; this is an example of what happens if you don’t plan
    your deployment right with an imperative tool.
  prefs: []
  type: TYPE_NORMAL
- en: As the storage account is attached to a resource group, and at the time of execution,
    the resource group didn’t exist, and the storage account couldn’t be created.
  prefs: []
  type: TYPE_NORMAL
- en: However, the resource group had no dependency failures as part of the Terraform
    run, meaning if you were to run `terraform apply` again, the storage account would
    be created – so how do we get around this so that it works the first time we run
    `terraform apply`?
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that Terraform refers to the two resources we are creating
    as `azurerm_resource_group.example` and `azurerm_storage_account.example`; these
    are internal references that we can use in our own code. Also, for most of these
    references, some outputs are only populated once the resource has been created.
    Some of these references are only known after the resource has been created because
    it is a return value of the resource being created in Azure, such as a unique
    ID, while for others, they are ones which we have defined – but are only populated
    once the resource has been launched. In the case of `azurerm_resource_group`,
    the name and location are populated as an output value once the group has been
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reference these in our `azurerm_storage_account` block by referring
    to the resource; this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What this will do is wait for the resource group to be deployed before Terraform
    will attempt to create the storage account – rather than just attempting to create
    both resources at the point of execution and failing.
  prefs: []
  type: TYPE_NORMAL
- en: While I wouldn’t describe scenarios like this as errors or faults, they are
    more like quirks that you won’t discover until you attempt something. Because
    of this, as we progress through the book, I will call out quite a few examples
    of this and other similar approaches because the more complex your deployment
    code is, the more considerations you will need to make when writing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the resources deployed in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The deployed resources within the Azure portal](img/Figure_2.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The deployed resources within the Azure portal
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clean up the resources you have launched by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This permanently deletes the resource group and storage account, so please ensure
    that you are happy to proceed before saying `Yes`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned a little about Terraform, let’s look at the other tool
    we will be using in the book, Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second tool we cover in detail in this book is Ansible by Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a popular configuration management tool that enables users to automate
    the deployment and management of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: It uses a hub-and-spoke model where a controlling machine instructs other machines
    to perform tasks. You can use it to manage your servers, deploy applications,
    or configure your network devices. One of the biggest advantages over other agentless
    devices is you don’t need to install anything on the target device you’re managing.
  prefs: []
  type: TYPE_NORMAL
- en: It supports YAML and JSON for writing playbooks, the main configuration file,
    meaning that it is language-agnostic when managing your remote systems and their
    state.
  prefs: []
  type: TYPE_NORMAL
- en: There is no one-size-fits-all solution when it comes to your IaC solution, and
    Ansible allows you to choose from various modules to achieve your desired result,
    providing a great deal of flexibility when managing your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: An Ansible example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take the same example we used for Terraform and recreate it in Ansible,
    creating an Azure resource group and placing an Azure storage account in it:'
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Again, feel free to follow along; if you need assistance installing Ansible,
    there are links provided in the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following code in a blank file on your local machine called `playbook.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: As this is a YAML file, the indentation is extremely important – before attempting
    to execute the playbook, I would reco[mmend using an online too](https://www.yamllint.com/)l
    such as [https://www.yamllint.com/](https://www.yamllint.com/) to quickly validate
    your file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are ready to run your playbook, you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the first run, this gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first two warnings can be ignored; however, the error is something we will
    need to take care of before we can run our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the introduction of this section, Ansible is modular – these
    modules are known as collections. As you can see from the code, we are using the
    `azure.azcollection` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install it, we need to run two commands; the first downloads the collection
    itself, and the second installs the required Python dependencies needed for the
    collection to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, rerun the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should result in the following output (I have removed the warnings this
    time; as already mentioned, they can be ignored for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, everything went as planned this time, and of the three tasks
    executed (the first being a check on `localhost`), two show changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the command again results in a play recap showing three OKs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may have also noticed that it just ran the first time – if you ignore installing
    the prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Terraform, Ansible, when executed this way, is declarative. This means
    that it ran the tasks in order and waited for each of them to complete before
    progressing to the next task in the playbook file. This means that we didn’t find
    ourselves in a situation where Ansible was trying to launch resources linked to
    other resources that don’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: Another key difference between Ansible and Terraform is that Ansible is stateless
    – which means Ansible does not track or store the state of your resources in a
    file and instead looks at each resource at the time of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I think this is one of the critical differences between Terraform
    and Ansible, as I have lost count of the times that I have had to debug problems
    because someone or something has made a change to a resource outside of Terraform,
    which Terraform has then struggled to reconcile between the resources that are
    actually there and ones that it thinks are there.
  prefs: []
  type: TYPE_NORMAL
- en: Finding yourself in this situation is dangerous territory if you don’t pay attention.
  prefs: []
  type: TYPE_NORMAL
- en: You may find that the only way Terraform can get its state back to how it thinks
    it should be deployed is to start terminating and redeploying resources – which
    would cause all sorts of chaos if you were in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, because Ansible does not keep track of the state of the resources
    it manages, it won’t know about a resource’s state or configuration until you
    execute the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 99% of the time, running an Ansible playbook will execute tasks that launch
    or update existing resources, so Ansible not keeping track of the state is not
    an issue – in fact, it could be a benefit as it is not trying to enforce a state
    it knows about.
  prefs: []
  type: TYPE_NORMAL
- en: The one downside to this is that because it doesn’t know what resources are
    present, there is not an Ansible equivalent of the `terraform destroy` command.
    When you run this command in Terraform, it simply removes the resources present
    within the state file giving a convenient way of removing everything Terraform
    is managing.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this with Ansible, I normally provide a second playbook that sets
    the state of all or just some of the resources to `absent` – given the default
    state for most resources is `present`, this will remove the resources listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example we have just covered, the playbook to remove the resources looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed an empty line (`---`) at the end of the code block; it
    is important that these are present.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we are setting the `force_delete_nonempty` flag to
    `true` in the preceding code snippet. Please be careful when using that flag as
    you will not be asked if you are sure, and this overrides the default action of
    failing because there are resources within the resource group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the preceding code in a file called `destroy.yml` and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will delete the resource group. Because the storage account is a child
    resource within the resource group and we have instructed Ansible to remove resource
    groups even if they are not empty, it will also be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about Ansible, let’s look at a tool we can use to write
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final tool I am going to introduce isn’t an IaC tool but an IDE, which is
    used to write the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is a powerful code editor perfect for most development languages,
    including your IaC projects. It is feature-rich, fast, and highly customizable,
    making it the ideal choice no matter which of the tools you decide to go with.
  prefs: []
  type: TYPE_NORMAL
- en: The best part is that Visual Studio Code is completely free and open source.
    Whether you’re a professional web developer, system administrator, or DevOps practitioner,
    Visual Studio Code has everything you need to create well-structured code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is it something I use on a daily basis – as you can see from the following
    screenshot, via the use of extensions, you get features such as syntax highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Our Terraform example opened in Visual Studio Code](img/Figure_2.02_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Our Terraform example opened in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'But beyond syntax highlighting, with extensions you can also get powerful features
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inline error checking**: This is where your code is checked for syntax errors
    and general issues, such as referencing a variable or output that does not exist,
    and makes you aware of them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto-complete**: This functionality varies between extensions, but they can
    fill in details as you type, suggesting which flags/keywords and values could
    be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatting**: As already mentioned, formatting is really important when it
    comes to both HCL and YAML; there are extensions for both languages that will
    check your formatting as you type and auto-correct if there are problems, which
    should hopefully save you from having to use an online tool such as the one linked
    in the Ansible section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Control and continuous integration/continuous delivery (CI/CD)**:
    There is a built-in integration with Git, as well as extensions for services such
    as GitHub, Azure DevOps, and other popular version control and CI/CD tools and
    services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it is not essential to use an IDE such as Visual Studio Code, I think
    you will miss out on a lot of functionality and troubleshooting help if you don’t.
  prefs: []
  type: TYPE_NORMAL
- en: For details on where to get Visual Studio Code from as well as recommended extensions
    that will be helpful throughout this book, please see the *Further* *reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got a very quick feel for the approach and considerations
    when it comes to choosing the right IaC tool for your project.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at both Terraform and Ansible and some of the small differences
    between the two tools before discussing Visual Studio Code, which I hope you will
    install and make use of.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which is the last chapter of *Part 1* of this book, we
    will look at the example project, which we will execute throughout the remainder
    of the book and get our teeth into both Terraform and Ansible on the two major
    public cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some resources to help you delve deeper into Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Main website: [https://www.terraform.io/](https://www.terraform.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download and install guides: [https://developer.hashicorp.com/terraform/downloads](https://developer.hashicorp.com/terraform/downloads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Resource Manager provider: [https://registry.terraform.io/providers/hashicorp/azurerm/latest](https://registry.terraform.io/providers/hashicorp/azurerm/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some resources to help you delve deeper into Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Main website: [https://www.ansible.com/](https://www.ansible.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download and install guides: [https://docs.ansible.com/ansible/latest/installation_guide/index.html](https://docs.ansible.com/ansible/latest/installation_guide/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure collection: [https://galaxy.ansible.com/azure/azcollection](https://galaxy.ansible.com/azure/azcollection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some resources to help you delve deeper into Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Main Website: [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downloads: [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HashiCorp Terraform extension: [https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform](https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red Hat Ansible extension: [https://marketplace.visualstudio.com/items?itemName=redhat.ansible](https://marketplace.visualstudio.com/items?itemName=redhat.ansible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub Repositories extension: [https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub](https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
