<html><head></head><body>
        

                            
                    <h1 class="header-title">Git Fundamentals - Niche Concepts, Configurations, and Commands</h1>
                
            
            
                
<p>This chapter is a collection of short but useful tricks to make our Git experience more comfortable. In the first three chapters, we learned all the concepts we need to take the first steps into versioning systems using the Git tool; now it's time to go a little bit in depth to discover some other powerful weapons in the Git arsenal, and how to use them (without shooting yourself in the foot, preferably).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dissecting Git configuration</h1>
                
            
            
                
<p>In the first part of this chapter, you will learn how to enhance our Git configuration to better fit your needs and speed up the daily work: it's time to become familiar with configuration internals.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration architecture</h1>
                
            
            
                
<p>Configuration options are stored in plain text files. The <kbd>git config</kbd> command is just a convenient tool to edit these files without the hassle of remembering where they are stored and opening them in a text editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration levels</h1>
                
            
            
                
<p>In Git, we have <em>three configuration levels</em>:</p>
<ul>
<li>System</li>
<li>Global (user-wide)</li>
<li>Repository</li>
</ul>
<p>There are different configuration files for every different configuration level.</p>
<p>You can basically set every parameter at every level, according to your needs. If you set the same parameters at different levels, the lowest-level parameter hides the top-level ones; so, for example, if you set <kbd>user.name</kbd> at the global level, it will hide the one eventually set up at the system level, and if you set it at the repository level, it will hide the one specified at the global level and the one eventually set up at the system level.</p>
<p>The following figure will help you to better understand these levels:</p>
<div><img height="366" width="251" class=" image-border" src="img/d7680d0a-e844-4de0-8210-f85631aea0b5.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">System level</h1>
                
            
            
                
<p>The system level contains <strong>system-wide configurations</strong>; if you edit the configuration at this level, <em>every user and every user's repository will be affected</em>.</p>
<p>This configuration is stored in the <kbd>gitconfig</kbd> file usually located in:</p>
<ul>
<li>Windows: <kbd>C:\Program Files\Git\etc\gitconfig</kbd></li>
<li>Linux: <kbd>/etc/gitconfig</kbd></li>
<li>macOS: <kbd>/usr/local/git/etc/gitconfig</kbd></li>
</ul>
<p>To edit parameters at this level, you have to use the <kbd>--system</kbd> option; please note that it requires administrative privileges (for example, root permission on Linux and macOS).<br/>
Anyway, as a rule of thumb, <em>editing the configuration at system level is discouraged</em>, in favor of per user configuration modification.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Global level</h1>
                
            
            
                
<p>The global level contains <strong>user-wide configurations</strong>; if you edit the configuration at this level, <em>every user's repository will be affected</em>.</p>
<p>This configuration is stored in the <kbd>.gitconfig</kbd> file usually located in:</p>
<ul>
<li>Windows: <kbd>C:\Users\&lt;UserName&gt;\.gitconfig</kbd></li>
<li>Linux: <kbd>~/.gitconfig</kbd></li>
<li>macOS: <kbd>~/.gitconfig</kbd></li>
</ul>
<p>To edit parameters at this level, you have to use the <kbd>--global</kbd> option.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Repository level</h1>
                
            
            
                
<p>The repository level contains <strong>repository only configurations</strong>; if you edit the configuration at this level, <em>only the repository in use will be affected</em>.</p>
<p>This configuration is stored in the <kbd>config</kbd> file located in the <kbd>.git</kbd> repository subfolder:</p>
<ul>
<li>Windows: <kbd>C:\&lt;MyRepoFolder&gt;\.git\config</kbd></li>
<li>Linux: <kbd>~/&lt;MyRepoFolder&gt;/.git/config</kbd></li>
<li>macOS: <kbd>~/&lt;MyRepoFolder&gt;/.git/config</kbd></li>
</ul>
<p>To edit parameters at this level, you can use the <kbd>--local</kbd> option or simply avoid using any option, as this is the default one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing configurations</h1>
                
            
            
                
<p>To get a list of all the configurations currently in use, you can run the <kbd>git config --list</kbd> command; if you are inside a repository, it will show all the configurations, from repository to system level. To filter the list, append optionally <kbd>--system</kbd>, <kbd>--global</kbd> or <kbd>--local</kbd> options to obtain only the desired level configurations:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --list --local 
core.repositoryformatversion=0 
core.filemode=false 
core.bare=false 
core.logallrefupdates=true 
core.symlinks=false 
core.ignorecase=true 
user.name=Ferdinando Santacroce 
user.email=ferdinando.santacroce@gmail.com</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Editing configuration files manually</h1>
                
            
            
                
<p>Even if it is generally discouraged, you can modify Git configurations directly by editing the files. Git configuration files are quite easy to understand, so when you look on the internet for a particular configuration you want to set, it is not unusual to find just the right corresponding text lines; the only little foresight in such cases is to back up files before editing them, just in case you mess with them. In the following paragraphs, we will try to make some changes in this manner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up some other environment configurations</h1>
                
            
            
                
<p>Using Git can be a painful experience if you are not able to place it conveniently inside your work environment. Let's start to shape some rough edges using a bunch of custom configurations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic configurations</h1>
                
            
            
                
<p>In previous chapters, we have seen that we can change a Git variable value using the <kbd>git config</kbd> with the <kbd>&lt;variable.name&gt; &lt;value&gt;</kbd> syntax. In this section, we will make use of the <kbd>config</kbd> command to vary some Git behaviors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Typos autocorrection</h1>
                
            
            
                
<p>So, let's try to fix an annoying question about typing command: <em>typos</em>. I often find myself re-typing the same command two or more times; Git can help us with embedded <em>autocorrection</em>, but we first have to enable it. To enable it, you have to modify the <kbd>help.autocorrection</kbd> parameter, defining how many tenths of a second Git will wait before running the assumed command; so giving a <kbd>help.autocorrect 10</kbd>, Git will wait for a second:</p>
<pre><strong>[2] ~/grocery (master) 
$ git config --global help.autocorrect 10 
 
[3] ~/grocery (master) 
$ git chekcout 
WARNING: You called a Git command named 'chekcout', which does not exist. 
Continuing under the assumption that you meant 'checkout' 
in 1.0 seconds automatically...</strong> </pre>
<p>To abort the auto-correction, simply type <em>Ctrl</em>+<em>C</em>.</p>
<p>Now that we know about configuration files, you can note that the parameters we set by the command line are in this form: <kbd>section.parameter_name</kbd>. You can see the section names within <kbd>[]</kbd> if you look in the configuration file; for example, in <kbd>C:\Users\&lt;UserName&gt;\.gitconfig</kbd>:</p>
<div><img class=" image-border" src="img/2c3bbdd3-ff34-48e6-9d10-366af70ee2cb.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Push default</h1>
                
            
            
                
<p>We already talked about the <kbd>git push</kbd> command and its default behavior. To avoid annoying issues, it is good practice to set a more convenient default behavior for this command.</p>
<p>There are two ways we can do this. First one: set Git to ask us the name of the branch we want to push every time, so a simple <kbd>git push</kbd> will have no effect. To obtain this, set <kbd>push.default</kbd> to <kbd>nothing</kbd>:</p>
<pre><strong>[1] ~/grocery-cloned (master) 
$ git config --global push.default nothing 
 
[2] ~/grocery-cloned (master) 
$ git push 
fatal: You didn't specify any refspecs to push, and push.default is "nothing".</strong> </pre>
<p>As you can see, now Git pretends that you specify the target branch at every push.</p>
<p>This is maybe too restrictive, but at least you can avoid common mistakes such as pushing some personal local branches to the remote, thus generating confusion in the team.</p>
<p>Another way to save yourself from this kind of mistake is to set the <kbd>push.default</kbd> parameter to <kbd>simple</kbd>, allowing Git to push only when there is a remote branch with the same name as the local one:</p>
<pre><strong>[3] ~/grocery-cloned (master) 
$ git config --global push.default simple 
 
[4] ~/grocery-cloned (master) 
$ git push 
Everything up-to-date</strong> </pre>
<p>This will push the local tracked branch to the remote.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the default editor</h1>
                
            
            
                
<p>Some people really don't like <kbd>vim</kbd>, even only for writing commit messages; if you are one of them, there is good news: you can change it by setting the <kbd>core.default</kbd> config parameter:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --global core.editor notepad</strong> </pre>
<p>Obviously, you can set nearly all available text editors on the market. If you are a Windows user, remember that the full path of the editor has to be in the <kbd>PATH</kbd> environment variable; basically, if you can run your preferred editor by typing its executable name in a DOS shell, you can use it even in a Bash shell with Git.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other configurations</h1>
                
            
            
                
<p>You can browse a wide list of other configuration variables at <a href="http://git-scm.com/docs/git-config">git-scm.com/docs/git-config</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git aliases</h1>
                
            
            
                
<p>We already mentioned Git aliases and their purpose; in this section, I will suggest only a few more, to help make things easier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shortcuts to common commands</h1>
                
            
            
                
<p>One thing you may find useful is to <em>shorten common commands</em> such as <kbd>git checkout</kbd> and so on; therefore, useful aliases can include the following:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --global alias.co checkout 
 
[2] ~/grocery (master) 
$ git config --global alias.br branch 
 
[3] ~/grocery (master) 
$ git config --global alias.ci commit 
 
[4] ~/grocery (master) 
$ git config --global alias.st status</strong> </pre>
<p>Another common practice is to shorten a command, adding one or more options you use all the time; for example, set a <kbd>git cm &lt;commit message&gt;</kbd> command shortcut to the alias <kbd>git commit -m &lt;commit message&gt;</kbd>:</p>
<pre><strong>[5] ~/grocery (master) 
$ git config --global alias.cm "commit -m" 
 
[6] ~/grocery (master) 
$ git cm "My commit message" 
On branch master 
nothing to commit, working tree clean</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating commands</h1>
                
            
            
                
<p>Another common way to customize your Git experience is to <em>create commands</em> you think should exist.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">git unstage</h1>
                
            
            
                
<p>The classic example is the <kbd>git unstage</kbd> alias:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --global alias.unstage 'reset HEAD --'</strong> </pre>
<p>With this alias, you can remove a file from the index in a more meaningful way, compared to the equivalent <kbd>git reset HEAD -- &lt;file&gt;</kbd> syntax:</p>
<pre class="mce-root"><strong>[2] ~/grocery (master)<br/>$ git unstage myFile.txt</strong></pre>
<p class="mce-root">Now behaves the same as:</p>
<pre class="mce-root"><strong>[3] ~/grocery (master) <br/>$ git reset HEAD -- myFile.txt</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">git undo</h1>
                
            
            
                
<p>Want a fast way to revert the last ongoing commit? Create a <kbd>git undo</kbd> alias:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --global alias.undo 'reset --soft HEAD~1'</strong> </pre>
<p>You can obviously use <kbd>--hard</kbd> instead of <kbd>--soft</kbd>, or go with the default <kbd>--mixed</kbd> option.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">git last</h1>
                
            
            
                
<p>A <kbd>git last</kbd> alias is useful to read about your last commit:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --global alias.last 'log -1 HEAD' 
 
[2] ~/grocery (master) 
$ git last</strong>
<strong>commit b25ffa60f44f6fc50e81181cab87ed3dbf3b172c 
Author: Ferdinando Santacroce &lt;ferdinando.santacroce@gmail.com&gt; 
Date:   Thu Jul 27 15:12:48 2017 +0200</strong> 
 
    <strong>Add an apricot</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">git difflast</h1>
                
            
            
                
<p>With the <kbd>git difflast</kbd> alias, you can see a <kbd>diff</kbd> against your last commit:</p>
<pre><strong>[1] ~/grocery (master) 
$ git config --global alias.difflast 'diff --cached HEAD^' 
 
[2] ~/grocery (master) 
$ git difflast 
diff --git a/shoppingList.txt b/shoppingList.txt 
index d362b98..08e7361 100644 
--- a/shoppingList.txt 
+++ b/shoppingList.txt 
@@ -4,3 +4,4 @@ orange 
 peach 
 grape 
 blackberry 
+apricot</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced aliases with external commands</h1>
                
            
            
                
<p>If you want the alias to run external shell commands, instead of a Git sub-command, you have to prefix the alias with a <kbd>!</kbd>:</p>
<pre><strong>$ git config --global alias.echo !echo</strong></pre>
<p>Suppose you are annoyed by the canonical <kbd>git add &lt;file&gt;</kbd> plus <kbd>git commit &lt;file&gt;</kbd> sequence of commands, and you want to do it in a single shot; you can call the <kbd>git</kbd> command twice in sequence by creating this alias:</p>
<pre><strong>$ git config --global alias.cm '!git add -A &amp;&amp; git commit -m'</strong></pre>
<p>With this alias you commit a file, adding it before if necessary.</p>
<p>Have you noted that I set the <kbd>cm</kbd> alias again? If you set an already configured alias, the previous alias will be overwritten.</p>
<p>There are also aliases that define and use complex functions or scripts, but I'll leave it to the curiosity of the reader to explore these aliases. If you are looking for inspiration, take a look at this GitHub repository at <a href="https://github.com/GitAlias/gitalias">https://github.com/GitAlias/gitalias</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing an alias</h1>
                
            
            
                
<p>Removing an alias is quite easy; you have to use the <kbd>--unset</kbd> option, specifying the alias to remove. For example, if you want to remove the <kbd>cm</kbd> alias, you have to run:</p>
<pre><strong>$ git config --global --unset alias.cm</strong> </pre>
<p>Note that you have to specify the configuration level with the appropriate option; in this case, we are removing the alias from the user (<kbd>--global</kbd>) level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aliasing the git command itself</h1>
                
            
            
                
<p>I've already said I'm a bad typist; if you are too, you can alias the git command itself (using the default <kbd>alias</kbd> command in Bash):</p>
<pre><strong>$ alias gti='git'</strong> </pre>
<p>In this manner, you will save some other keyboard strokes. Note that this is not a Git alias, but a Bash shell alias.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Useful techniques</h1>
                
            
            
                
<p>In this section, we will improve our skills, learning some techniques that will come in handy in different situations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git stash - putting changes temporally aside</h1>
                
            
            
                
<p class="mce-root">It sometimes happens that you need to switch branches for a moment, but some changes are in progress in the current branch. To put aside those changes for a while, we can use the <kbd>git stash</kbd> command: let's give it a try in our <kbd>grocery</kbd> repository.</p>
<p>Append a new fruit to the shopping list, then try to switch branch; Git won't allow you to do so, because with the checkout you would lose your local (not yet committed) changes to the <kbd>shoppingList.txt</kbd> file. So, type the <kbd>git stash</kbd> command; your changes will be set apart and removed from your current branch, letting you switch to another one (<kbd>berries</kbd>, in this case):</p>
<pre><strong>[1] ~/grocery (master) 
$ echo "plum" &gt;&gt; shoppingList.txt 
 
[2] ~/grocery (master) 
$ git status 
On branch master 
Changes not staged for commit: 
  (use "git add &lt;file&gt;..." to update what will be committed) 
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) 
 
        modified:   shoppingList.txt 
 
no changes added to commit (use "git add" and/or "git commit -a") 
 
[3] ~/grocery (master) 
$ git checkout berries 
error: Your local changes to the following files would be overwritten by checkout: 
        shoppingList.txt 
Please commit your changes or stash them before you switch branches. 
Aborting 
 
[4] ~/grocery (master) 
$ git stash 
Saved working directory and index state WIP on master: b25ffa6 Add an apricot 
HEAD is now at b25ffa6 Add an apricot 
 
[5] ~/grocery (master) 
$ git checkout berries 
Switched to branch 'berries'</strong> </pre>
<p>How does <kbd>git stash</kbd> work? Actually, <kbd>git stash</kbd> is a fairly complex command. It basically saves from two up to three different commits:</p>
<ul>
<li>A new <em>WIP commit</em> containing the actual state of the working copy; it contains all the tracked files, and their modifications.</li>
<li>An <em>index commit</em>, as a parent of the WIP commit. This contains stuff added to the staging area.</li>
<li>An optional third commit, let's call it an <em>untracked files commit</em>, which contains untracked files (using the <kbd>--include-untracked</kbd> option) or untracked plus previously ignored files (using the <kbd>--all</kbd> option).</li>
</ul>
<p>Let's take a look at the actual situation in our repository using the <kbd>git log</kbd> command:</p>
<pre><strong>[6] ~/grocery (berries) 
$ git log --oneline --graph --decorate --all 
*   fedc4cf (refs/stash) WIP on master: b25ffa6 Add an apricot 
|\ 
| * 7312ff0 index on master: b25ffa6 Add an apricot 
|/ 
* b25ffa6 (master) Add an apricot 
* 280e7a8 Cherry picked the blackberry 
* 5dc3352 Add a grape 
* de8bcb9 Add a peach 
| * 362f8ec (HEAD -&gt; berries) Add a strawberry 
| * f037469 (melons) Add a watermelon 
| * af9b640 Add a blackberry 
|/ 
* 00404b4 Add an orange 
* f583fdc Add an apple 
* 40d865b Add a banana to the shopping list</strong></pre>
<p>As you can see, in this case there are only two commits. The <em>WIP commit</em>, <kbd>fedc4cf</kbd>, is the one with the message starting with <em>WIP on master</em>, where <kbd>master</kbd> is of course the branch where <kbd>HEAD</kbd> was at the time of the <kbd>git stash</kbd> command run. The <em>index commit</em>, <kbd>7312ff0</kbd>, is the one with the message starting with <em>index on master</em>.</p>
<p>The <em>WIP commit</em> contains the unstaged changes made to tracked files; as you can see, the <em>WIP commit</em> has two parents: one is the <em>index commit</em>, containing staged changes, the other is the last commit on the <kbd>master</kbd> branch, where <kbd>HEAD</kbd> was and where we run the <kbd>git stash</kbd> command.</p>
<p>With all this shelved information, Git can then re-apply your work on top of the <kbd>master</kbd> branch when you finish your job on the <kbd>berries</kbd> branch; a stash can be applied wherever you want, and more than once if you like.</p>
<p>Using the <kbd>git stash</kbd> command, we actually used the <kbd>git stash save</kbd> subcommand, the default option. The <kbd>save</kbd> subcommand saves changes to tracked files only, using a default set of messages for these <em>special commits</em> we see.</p>
<p>To retrieve a stash, the command is <kbd>git stash apply &lt;stash&gt;</kbd>; it applies changes within the two commits, eventually modifying your working copy and staging area. The stash will not be deleted after the apply; you can do it manually using the <kbd>git stash drop &lt;stash&gt;</kbd> subcommand. Another way implies the <kbd>git stash pop &lt;stash&gt;</kbd> subcommand: it applies the stash and then deletes it.</p>
<p>While using these subcommands, you can refer to the various stashes you did in the past using different notations; the most common is <kbd>stash@{0}</kbd>, where <kbd>0</kbd> means <em>the last stash you did</em>. To retrieve the penultimate, you can use <kbd>stash@{1}</kbd> and so on.</p>
<p>To make a complete example, let's drop the actual stash without applying it, and then do a new one following these steps:</p>
<ol>
<li>Drop the last stash created using <kbd>git stash drop</kbd> (<kbd>git stash clear</kbd> drops all the stashes).</li>
<li>Append a new fruit to the shopping list (for example, a plum) and add it to the staging area.</li>
<li>Then add another one (for example, a pear) but avoid adding it to the staging area.</li>
<li>Now create a new untracked file (for example, <kbd>notes.txt</kbd>).</li>
<li>Finally, create a new stash using <kbd>-u</kbd> (the <kbd>--include-untracked</kbd> option).</li>
</ol>
<p>Here is the complete list of commands:</p>
<pre><strong>[1] ~/grocery (master) 
$ echo "plum" &gt;&gt; shoppingList.txt 
 
[2] ~/grocery (master) 
$ git add . 
 
[3] ~/grocery (master) 
$ echo "pear" &gt;&gt; shoppingList.txt 
 
[4] ~/grocery (master) 
$ echo "Reserve some tropical fruit for next weekend" &gt; notes.txt 
 
[5] ~/grocery (master) 
$ git status 
On branch master 
Changes to be committed: 
  (use "git reset HEAD &lt;file&gt;..." to unstage) 
 
        modified:   shoppingList.txt 
 
Changes not staged for commit: 
  (use "git add &lt;file&gt;..." to update what will be committed) 
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) 
 
        modified:   shoppingList.txt 
 
Untracked files: 
  (use "git add &lt;file&gt;..." to include in what will be committed) 
 
        notes.txt 
 
[6] ~/grocery (master) 
$ git stash -u 
Saved working directory and index state WIP on master: b25ffa6 Add an apricot 
HEAD is now at b25ffa6 Add an apricot</strong> </pre>
<p>OK, let's see what happened using the <kbd>git log</kbd> command:</p>
<pre><strong> 
[7] ~/grocery (master) 
$ git log --oneline --graph --decorate --all 
*-.   87b1d8b (refs/stash) WIP on master: b25ffa6 Add an apricot 
|\ \ 
| | * b07c304 untracked files on master: b25ffa6 Add an apricot 
| * ad2efef index on master: b25ffa6 Add an apricot 
|/ 
* b25ffa6 (HEAD -&gt; master) Add an apricot 
* 280e7a8 Cherry picked the blackberry 
* 5dc3352 Add a grape 
* de8bcb9 Add a peach 
| * 362f8ec (berries) Add a strawberry 
| * f037469 (melons) Add a watermelon 
| * af9b640 Add a blackberry 
|/ 
* 00404b4 Add an orange 
* f583fdc Add an apple 
* 40d865b Add a banana to the shopping list</strong> </pre>
<p>As you can see, this time there is one more commit, the <em>untracked files</em> one: this commit contains the <kbd>notes.txt</kbd> file, and figures as an additional parent for the <em>WIP commit</em>.</p>
<p>Summarizing, you basically use the <kbd>git stash save</kbd> command (with the <kbd>-u</kbd> or <kbd>--all</kbd> option if needed) to shelve your modification and then <kbd>git stash apply</kbd> to retrieve them; I suggest using <kbd>git stash apply</kbd> and then <kbd>git stash drop</kbd> instead of <kbd>git pop</kbd> to have a chance to redo your stash application when needed, or when your stash is not as trivial as usual.</p>
<p>To take a look at all the options for this command, please refer to the <kbd>git stash --help</kbd> output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git commit amend - modify the last commit</h1>
                
            
            
                
<p>This trick is for people that don't double-check what they're doing. If you have pressed the enter key too early, there's a way to modify the last commit message or add that file you forgot, using the <kbd>git commit</kbd> command with the <kbd>--amend</kbd> option:</p>
<pre><strong>$ git commit --amend -m "New commit message"</strong></pre>
<p>Please note that with the <kbd>--amend</kbd> option, you are actually re-doing the commit, which will have a new hash; if you already pushed the previous commit, changing the last commit is not recommended - rather, it is deplorable.</p>
<p>If you amend an already pushed commit, then push the new one, you are basically discarding the latest commit on a branch, replacing it with the newly amended one: for those who will pull the branch, this can lead to some confusion, as they will see their local branch losing the last commit, replaced by a new one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git blame - tracing changes in a file</h1>
                
            
            
                
<p>Working on source code in a team, it is not uncommon to have the need to look at the last modifications made to a particular file to better understand how it evolved over time. To achieve this result, we can use the <kbd>git blame &lt;filename&gt;</kbd> command.</p>
<p>Let's try it inside the <kbd>Spoon-Knife</kbd> repository to see changes made to the <kbd>README.md</kbd> file during a specific time:</p>
<pre><strong>[1] ~/Spoon-Knife (master) 
$ git blame README.md 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 1) ### Well hello there! 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 2) 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 3) This repository is meant to provide an example for *forking* a repository on GitHub. 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 4) 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 5) Creating a *fork* is producing a personal copy of someone else's project. Forks act as a sort of bridge between the original repository and your personal copy. You can submit *Pull Requests* to help make other people's projects better by offering your changes up to the original project. Forking is at the core of social coding at GitHub. 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 6) 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 7) After forking this repository, you can make some changes to the project, and submit [a Pull Request](https://github.com/octocat/Spoon-Knife/pulls) as practice. 
bb4cc8d3 (The Octocat 2014-02-04 14:38:36 -0800 8) 
d0dd1f61 (The Octocat 2014-02-12 15:20:44 -0800 9) For some more information on how to fork a repository, [check out our guide, "Forking Projects""](http://guides.github.com/overviews/forking/). Thanks! :sparkling_heart:</strong> </pre>
<p>As you can see, the result reports all the affected lines of the <kbd>README.md</kbd> file; for every line, you can see the commit hash, the author, the date, and the row number of the text file lines.</p>
<p>Suppose now you found that the modification you are looking for is the one made in the <kbd>d0dd1f61</kbd> commit; to see what happened there, type the <kbd>git show d0dd1f61</kbd> command:</p>
<pre><strong>[2] ~/Spoon-Knife (master) 
$ git show d0dd1f61 
commit d0dd1f61b33d64e29d8bc1372a94ef6a2fee76a9 
Author: The Octocat &lt;octocat@nowhere.com&gt; 
Date:   Wed Feb 12 15:20:44 2014 -0800 
 
    Pointing to the guide for forking 
 
diff --git a/README.md b/README.md 
index 0350da3..f479026 100644 
--- a/README.md 
+++ b/README.md 
@@ -6,4 +6,4 @@ Creating a *fork* is producing a personal copy of someone else's project. Forks 
 
 After forking this repository, you can make some changes to the project, and submit [a Pull Request](https://github.com/octocat/Spoon-Knife/pulls) as practice. 
 
-For some more information on how to fork a repository, [check out our guide, "Fork a Repo"](https://help.github.com/articles/fork-a-repo). Thanks! :sparkling_heart: 
+For some more information on how to fork a repository, [check out our guide, "Forking Projects""](http://guides.github.com/overviews/forking/). Thanks! :sparkling_heart:</strong></pre>
<p>The <kbd>git show</kbd> command is a multi-purpose command that can show to you one or more objects; in this case, we have used it to show the modification made in a particular commit using the <kbd>git show &lt;commit-hash&gt;</kbd> format.</p>
<p>The <kbd>git blame</kbd> and <kbd>git show</kbd> commands have a quite long list of options; the purpose of this section is to only point the reader to the way they can trace changes on a file; you can inspect other possibilities using the ever-useful <kbd>git &lt;command&gt; --help</kbd> command.</p>
<p>The last tip I want to suggest is to use the Git GUI:</p>
<pre><strong>[3] ~/Spoon-Knife (master) 
$ git gui blame README.md</strong> </pre>
<div><img class=" image-border" src="img/3c4f9e4e-bdb1-4280-a6b9-c95c0f2d379b.png"/></div>
<p>With the help of the GUI, things are even easier to understand.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tricks</h1>
                
            
            
                
<p>In this section, I would like to suggest just a bunch of tips and tricks I have found useful in the past.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bare repositories</h1>
                
            
            
                
<p>Bare repositories are repositories that do not contain working copy files, but only the <kbd>.git</kbd> folder. A bare repository is essentially <em>for sharing</em>: if you use Git in a centralized way, pushing and pulling to a common remote (a local server, a GitHub repository, and so on), you will agree that the remote has no interest in checking out files you work on; the scope of that remote is only to be a central point of contact for the team, so having working copy files in it is only a waste of space as no one will edit them directly on the remote.</p>
<p>If you want to set up a bare repository, you only have to use the <kbd>--bare</kbd> option:</p>
<pre><strong>$ git init --bare NewRepository.git</strong></pre>
<p>As you may have noticed, I called it <kbd>NewRepository.git</kbd>, using a <kbd>.git</kbd> extension; this is not mandatory, but is a common way to identify bare repositories. If you pay attention, you will note that even in GitHub every repository ends with a <kbd>.git</kbd> extension.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting a regular repository to a bare one</h1>
                
            
            
                
<p>It can happen that you start working on a project in a local repository, and then you feel the need to move it to a centralized server to make it available for other people or from other locations.</p>
<p>You can easily convert a regular repository to a bare one using the <kbd>git clone</kbd> command with the same <kbd>--bare</kbd> option:</p>
<pre><strong>$ git clone --bare my_project my_project.git</strong></pre>
<p>In this manner, you have a 1:1 copy of your repository in another folder, but in a bare version, ready to be pushed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Backup repositories</h1>
                
            
            
                
<p>If you need a backup, there are two commands you can use: one for archiving only files and one for backing up the entire bundle, including versioning information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Archiving the repository</h1>
                
            
            
                
<p>To archive the repository without including versioning information, you can use the <kbd>git archive</kbd> command; there are many output formats but the classic one is the <kbd>.zip</kbd> one:</p>
<pre><strong>$ git archive master --format=zip --output=../repoBackup.zip</strong> </pre>
<p>Please note that using this command is not the same as backing up folders in a filesystem; as you will have noticed, the <kbd>git archive</kbd> command can produce archives in a smarter way, including only files in a branch or even in a single commit; for example, by doing this you are archiving only the last commit:</p>
<pre><strong>$ git archive HEAD --format=zip --output=../headBackup.zip</strong> </pre>
<p>Archiving files in this way can be useful if you have to share your code with people that don't have Git installed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bundling the repository</h1>
                
            
            
                
<p>Another interesting command is the <kbd>git bundle</kbd> command. With <kbd>git bundle</kbd>, you can export a snapshot from your repository and then restore it wherever you want.<br/>
Suppose you want to clone your repository on another computer, and the network is down or absent; with this command, you can create a <kbd>repo.bundle</kbd> file of the <kbd>master</kbd> branch:</p>
<pre><strong>$ git bundle create ../repo.bundle master</strong> </pre>
<p>With this other command, we can restore the bundle in the other computer using the <kbd>git clone</kbd> command:</p>
<pre><strong>$ cd /OtherComputer/Folder 
$ git clone repo.bundle repo -b master</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we enhanced our knowledge about Git and its wide set of commands. We discovered how configuration levels work, and how to set our preferences using Git by, for example, adding useful command aliases to the shell. Then we looked at how Git deals with stashes, providing the way to shelve then and reapply changes.</p>
<p>Furthermore, we added some other techniques to our skill set, learning some things we will use as soon as we start to use Git extensively. Some simple tricks provide a way to stimulate the curiosity of the reader: Git has a lot more commands to explore.</p>
<p>In the next chapter, we will leave the console for a while, and talk about strategies to better organize our repositories. We will try to learn how to make significant commits, and we will get to know some of the adoptable flows to reconcile Git with our way of working.</p>


            

            
        
    </body></html>