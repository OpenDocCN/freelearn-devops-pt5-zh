<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Larger Projects</h1></div></div></div><p>Until now we have been looking at single plays in one playbook file. This approach will work for simple infrastructures, or when using Ansible as a simple deployment mechanism. However, if you have a large and complicated infrastructure, then you will need to take actions to prevent things from going out of control. This chapter will include the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Separating your playbooks into different files, and including them from some other location</li><li class="listitem">Using roles to include multiple files that perform a similar function</li><li class="listitem">Methods for increasing the speed at which Ansible configures your machines</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Includes</h1></div></div></div><p>One of the first issues <a id="id167" class="indexterm"/>you will face with a complex infrastructure is that your playbooks will rapidly increase in size. Large playbooks can become difficult to read and maintain. Ansible allows you to combat this problem by way of includes.</p><p>Includes allow you to split your plays into multiple sections. You can then include each section from other plays. This allows you to have several different parts built for a different purpose, all included in a main play.</p><p>There are four types of includes, namely, variable includes, playbook includes, task includes, and handler includes. Including variables from an external <code class="literal">vars_file</code> files has been discussed already in <a class="link" title="Chapter 2. Simple Playbooks" href="part0020.xhtml">Chapter 2</a>, <em>Simple Playbooks</em>. The following is a description of what each includes does:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Variable includes</strong>: They <a id="id168" class="indexterm"/>allow you to put your <a id="id169" class="indexterm"/>variables in external YAML files</li><li class="listitem"><strong>Playbook includes</strong>: They <a id="id170" class="indexterm"/>are used to include <a id="id171" class="indexterm"/>plays from other files in a single play</li><li class="listitem"><strong>Task includes</strong>: They <a id="id172" class="indexterm"/>let you put common tasks in other files and <a id="id173" class="indexterm"/>include them wherever required</li><li class="listitem"><strong>Handler includes</strong>: They <a id="id174" class="indexterm"/>let you put all your <a id="id175" class="indexterm"/>handlers at one place</li></ul></div><p>We will be looking at these includes in the following section; however, including variables from an external <code class="literal">vars_file</code> files has been discussed already in <a class="link" title="Chapter 2. Simple Playbooks" href="part0020.xhtml">Chapter 2</a>, <em>Simple Playbooks</em>, so we will not be discussing it in detail.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Task includes</h2></div></div></div><p>Task includes can be used <a id="id176" class="indexterm"/>when you have a lot of common tasks that will be repeated. For example, you may have a set of tasks that removes a machine from monitoring and a load balancer before you can configure it. You can put these tasks in a separate YAML file, and then include them from your main task.</p><p>Task includes inherit the facts from the play they are included from. You can also provide your own variables, which are passed into the task and are available for use.</p><p>Finally, task includes can have conditionals applied to them. If you do this, conditionals will separately be added to each included task by Ansible automatically. The tasks are all still included. In most cases, this is not an important distinction; however, in circumstances where variables may change, it is.</p><p>The file to include as a task includes contains a list of tasks. If you assume the existence of any variables, hosts, or groups, then you should state them in comments at the top of the file. This makes it easier for people who wish to reuse the file later.</p><p>So, if you wanted to create a bunch of users and set up their environment with their public keys, you would split out the tasks that do a single user to one file. This file will look similar to the following code:</p><div><pre class="programlisting">---
# Requires a user variable to specify user to setup
- name: Create user account
  user:
    name: "{{ user }}"
    state: present

- name: Make user SSH config dir
  file:
    path: "/home/{{ user }}/.ssh"
    owner: "{{ user }}"
    group: "{{ user }}"
    mode: 0600
    state: directory

- name: Copy in public key
  copy:
    src: "keys/{{ user }}.pub"
    dest: "/home/{{ user }}/.ssh/authorized_keys"
    mode: 0600
    owner: "{{ user }}"
    group: "{{ user }}"</pre></div><p>We expect that a variable named <code class="literal">user</code> will be passed to us, and that their public key will be in the <code class="literal">keys</code> directory. The <a id="id177" class="indexterm"/>account is created, the <code class="literal">ssh config</code> directory is made, and finally we can copy this in their public key. The easiest way to use this <code class="literal">config</code> file would be to include it with the <code class="literal">with_items</code> keyword you learned about in <a class="link" title="Chapter 3. Advanced Playbooks" href="part0028.xhtml">Chapter 3</a>, <em>Advanced Playbooks</em>. This will look similar to the following code:</p><div><pre class="programlisting">---
- hosts: ansibletest
  user: root
  tasks:
    - include: usersetup.yml user={{ item }}
      with_items:
        - mal
        - dan
        - kate</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Handler includes</h2></div></div></div><p>When writing Ansible <a id="id178" class="indexterm"/>playbooks, you will constantly find yourself reusing the same handlers multiple times. For instance, a handler used to restart MySQL is going to look the same everywhere. To make this easier, Ansible allows you to include other files in the handlers section. Handler includes look the same as task includes. You should make sure to include a name on each of your handlers; otherwise, you will not be able to refer to them easily in your tasks. A handler includes file looks similar to the following code:</p><div><pre class="programlisting">---
- name: config sendmail
  command: make -C /etc/mail
  notify: reload sendmail

- name: config aliases
  command: newaliases
  notify: reload sendmail

- name: reload sendmail
  service:
    name: sendmail
    state: reloaded

- name: restart sendmail
  service:
    name: sendmail
    state: restarted</pre></div><p>This file provides several common tasks that you would want to handle after configuring <code class="literal">sendmail</code>. By including the following handlers in their own files, you can easily reuse them whenever you need to change the <code class="literal">sendmail</code> configuration:</p><div><ul class="itemizedlist"><li class="listitem">The first handler regenerates the <code class="literal">sendmail</code> database's <code class="literal">config</code> file and triggers a <code class="literal">reload</code> file of <code class="literal">sendmail</code> later</li><li class="listitem">The second handler initializes the <code class="literal">aliases</code> database, and also schedules a <code class="literal">reload</code> file of <code class="literal">sendmail</code></li><li class="listitem">The third handler reloads <code class="literal">sendmail</code>; it may be triggered by the previous two jobs, or it may be triggered directly from a task</li><li class="listitem">The fourth handler <a id="id179" class="indexterm"/>restarts <code class="literal">sendmail</code> when triggered; this is useful if you upgrade <code class="literal">sendmail</code> to a new version</li></ul></div><div><h3 class="title"><a id="note15"/>Note</h3><p>Handlers can trigger other handlers provided they only trigger the ones specified later, instead of the triggered ones. This means you can set up a series of cascading handlers that call each other. This saves you from having long lists of handlers in the notify section of tasks.</p></div><p>Using the preceding handler file is easy now. We simply need to remember that if we change a <code class="literal">sendmail</code> configuration file, then we should trigger <code class="literal">config sendmail</code>, and if we change the <code class="literal">aliases</code> file, we should trigger <code class="literal">config aliases</code>. The following code shows us an example of this:</p><div><pre class="programlisting">---
  hosts: mailers
  tasks:
    - name: update sendmail
      yum:
        name: sendmail
        state: latest
      notify: restart sendmail

    - name: configure sendmail
      template:
        src: templates/sendmail.mc.j2 dest: /etc/mail/sendmail.mc
      notify: config sendmail

  handlers:
    - include: sendmailhandlers.yml</pre></div><p>This playbook makes sure <code class="literal">sendmail</code> is installed. If it isn't installed, or if it isn't running the latest version, then it installs it or updates it. After it is updated, it schedules a restart so that we can be <a id="id180" class="indexterm"/>confident that the latest version will be running once the playbook is done. In the next step, we replace the <code class="literal">sendmail</code> configuration file with our template. If the <code class="literal">config</code> file was changed by the template, then the <code class="literal">sendmail</code> configuration files will be regenerated, and finally <code class="literal">sendmail</code> will be reloaded.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Playbook includes</h2></div></div></div><p>Playbook includes <a id="id181" class="indexterm"/>should be used when you want to include a whole set of tasks designated for a set of machines. For example, you may have a play that gathers the host keys of several machines and builds a <code class="literal">known_hosts</code> file to copy to all the machines.</p><p>While task includes allows you to include tasks, playbook includes allows you to include whole plays. This allows you to select the hosts you wish to run on, and provide handlers for notify events. Because you are including whole playbook files, you can also include multiple plays.</p><p>Playbook includes allows you to embed fully self-contained files. It is for this reason that you should provide any variables that it requires. If they depend on any particular set of hosts or groups, this should be noted in a comment at the top of the file.</p><p>This is handy when you wish to run multiple different actions at once. For example, let's say we have a playbook that switches to our DR site, named <code class="literal">drfailover.yml</code>, another named <code class="literal">upgradeapp.yml</code> that upgrades the app, another named <code class="literal">drfailback.yml</code> that fails back, and finally <code class="literal">drupgrade.yml</code>. All these playbooks might be valid to use separately; however, when performing a site upgrade, you will probably want to perform them all at once. You can do this as shown in the following code:</p><div><pre class="programlisting">---
- include "drfailover.yml"
- include "upgradeapp.yml"
- include "drfailback.yml"

- name: Notify management
  hosts: local
  tasks:
    - mail
        to: "mgmt-team@example.com"
        msg: 'The application has been upgraded and is now live'

- include "drupgrade.yml"</pre></div><p>As you can see, you <a id="id182" class="indexterm"/>can put full plays in the playbooks that you are including other playbooks into.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Roles</h1></div></div></div><p>If your playbooks start <a id="id183" class="indexterm"/>expanding beyond what includes can help you solve, or you start gathering a large number of templates, you may want to use roles. Roles in Ansible allow you to group files together in a defined structure. They are essentially an extension to includes that handles a few things automatically, and this helps you organize them inside your repository.</p><p>Roles allow you to place your variables, files, tasks, templates, and handlers in a folder, and then easily include them. You can also include other roles from within roles, which effectively creates a tree of dependencies. Similar to task includes, they can have variables passed to them. Using these features, you should be able to build self-contained roles that are easy to share with others.</p><p>Roles are commonly <a id="id184" class="indexterm"/>set up to manage services provided by machines, but they can also be daemons, options, or simply characteristics. Things you may want to configure in a role are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Web servers, such as Nginx or Apache</li><li class="listitem">Messages of the day customized for the security level of the machine</li><li class="listitem">Database servers running PostgreSQL or MySQL</li></ul></div><p>To manage roles in <a id="id185" class="indexterm"/>Ansible, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a folder <a id="id186" class="indexterm"/>named roles with your playbooks.</li><li class="listitem">In the <code class="literal">roles</code> folder, make a folder for each role that you would like.</li><li class="listitem">In the folder for each role, make folders named <code class="literal">files</code>, <code class="literal">handlers</code>, <code class="literal">meta</code>, <code class="literal">tasks</code>, <code class="literal">templates</code>, and finally <code class="literal">vars</code>. If you aren't going to use all these, you can leave out the ones you don't need. Ansible will silently ignore any missing files or directories when using roles.</li><li class="listitem">In your playbooks, add the keyword roles followed by a list of roles that you would like to apply to the hosts.</li><li class="listitem">For example, if you had the <code class="literal">common</code>, <code class="literal">apache</code>, <code class="literal">website1</code>, and <code class="literal">website2</code> roles, your directory structure would look similar to the following example. The <code class="literal">site.yml</code> file is for reconfiguring the entire site, and the <code class="literal">webservers1.yml</code> and <a id="id187" class="indexterm"/><code class="literal">webservers2.yml</code> <a id="id188" class="indexterm"/>files are for configuring each web server farm.<div><img src="img/image00105.jpeg" alt="Roles"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div><p>The following file is <a id="id189" class="indexterm"/>what could be in <code class="literal">website1.yml</code>. It shows a playbook that applies the <code class="literal">common</code>, <code class="literal">apache</code>, and <code class="literal">website1</code> roles to the <code class="literal">website1</code> group in the <a id="id190" class="indexterm"/>inventory. The <code class="literal">website1</code> role is included using a more <a id="id191" class="indexterm"/>verbose format that allows us to pass variables to the role, as follows:</p><div><pre class="programlisting">---
- name: Setup servers for website1.example.com
  hosts: website1
  roles:
    - common
    - apache
    - { role: website1, port: 80 }</pre></div><p>For the role named <code class="literal">common</code>, Ansible will then try to load <code class="literal">roles/common/tasks/main.yml</code> as a task include, <code class="literal">roles/common/handlers/main.yml</code> as a handler include, and <code class="literal">roles/common/vars/main.yml</code> as a variable file include. If all of these files are missing, Ansible will throw an error; however, if one of the files exists, then the others, if missing, will be ignored. The following directories are used by a default install of Ansible (other directories may be used by different modules):</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Directory</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">tasks</code>
</p>
</td><td valign="top">
<p>The <code class="literal">tasks</code> <a id="id192" class="indexterm"/>folder should contain a <code class="literal">main.yml</code> file, which should include a list of the tasks for this role. Any task includes that are contained in these roles will look for their files in this folder also. This <a id="id193" class="indexterm"/>allows you to split a large number of tasks into separate files, and use other features of task includes.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">files</code>
</p>
</td><td valign="top">
<p>The <code class="literal">files</code> <a id="id194" class="indexterm"/>folder is the default location for files in the roles that are used by the copy or the script module.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">templates</code>
</p>
</td><td valign="top">
<p>The <code class="literal">templates</code> <a id="id195" class="indexterm"/>directory is the location where the template module will automatically look for the jinja2 templates included in the roles.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">handlers</code>
</p>
</td><td valign="top">
<p>The <code class="literal">handlers</code> <a id="id196" class="indexterm"/>folder should contain a <code class="literal">main.yml</code> file, which specifies the handlers for the roles, and any includes in that folder will also look for the files in the same location.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">vars</code>
</p>
</td><td valign="top">
<p>The <code class="literal">vars</code> folder <a id="id197" class="indexterm"/>should contain a <code class="literal">main.yml</code> file, which contains the variables for this role.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">meta</code>
</p>
</td><td valign="top">
<p>The <code class="literal">meta</code> folder <a id="id198" class="indexterm"/>should contain a <code class="literal">main.yml</code> file. This file can contain settings for the role, and a list of its dependencies. This feature is available only in Ansible 1.3 and above.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">default</code>
</p>
</td><td valign="top">
<p>You should use <a id="id199" class="indexterm"/>the <code class="literal">default</code> folder if you are expecting variables to be sent to this role, and you want to make them optional. A <code class="literal">main.yml</code> file in this folder is read, to get the initial values for variables that can be overridden by variables, which are passed from the playbook <a id="id200" class="indexterm"/>calling the role. This feature is only available in Ansible 1.3 and above.</p>
</td></tr></tbody></table></div><p>When using roles, the behavior of the copy, the template, and the script modules is slightly altered. In addition to searching for files by looking from the directory in which the playbook file is located, Ansible will also look for the files in the location of the role. For example, if you are using a role named <code class="literal">common</code>, these modules will change to the following behavior:</p><div><ul class="itemizedlist"><li class="listitem">The copy module will look for files in <code class="literal">roles/common/files</code>.</li><li class="listitem">The template module will first look for templates in <code class="literal">roles/common/templates</code>.</li><li class="listitem">The script module will first look for files in <code class="literal">roles/common/files</code>.</li><li class="listitem">The other modules might decide to look for their data in other folders inside <code class="literal">roles/common/</code>. The documentation for modules can be retrieved using <code class="literal">ansible-doc</code>, as was discussed in the <em>Module help</em> section of <a class="link" title="Chapter 1. Getting Started with Ansible" href="part0014.xhtml">Chapter 1</a>, <em>Getting Started with Ansible</em>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Role metadata</h1></div></div></div><p>Using role <a id="id201" class="indexterm"/>metadata allows us to specify that our role depends on other roles. For example, if the application you are deploying needs to send an e-mail, your role could depend on a Postfix role. This would mean that before the application is set up and installed, Postfix will be installed and set up.</p><p>The <code class="literal">meta/main.yml</code> file will look similar to the following code:</p><div><pre class="programlisting">---
allow_duplicates: no
dependencies:
  - apache</pre></div><p>The <code class="literal">allow_duplicates</code> line is set to <code class="literal">no</code>, which is the default. If you set this to <code class="literal">no</code>, Ansible will not run a role the second time, if it is included twice with the same arguments. If you set it to <code class="literal">yes</code>, it will repeat the role even if it has run before. You can leave it <code class="literal">off</code> instead of setting it to <code class="literal">no</code>.</p><p>Dependencies are specified in the same format as roles. This means you can pass variables here; either static values or variables that are passed to the current role.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Role defaults</h1></div></div></div><p>The second feature <a id="id202" class="indexterm"/>included with Ansible 1.3 is variable default values. If you place a <code class="literal">main.yml</code> file in the defaults directory for the role, these variables will be read into the role; however, they can be overridden by variables in the <code class="literal">vars/main.yml</code> file, or the variables that are passed to the role when it is included. This allows you to make passing variables to the role optional. These files look exactly like other variable files. For example, if you used a variable named <code class="literal">port</code> in your role, and you want to default it to port <code class="literal">80</code>, your <code class="literal">defaults/main.yml</code> file will look similar to the following code:</p><div><pre class="programlisting">---
port: 80</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Speeding things up</h1></div></div></div><p>As you add more and more machines and services to your Ansible configuration, you will find things getting slower and slower. Fortunately, there are several tricks you can use to make Ansible work on a bigger scale.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Provisioning</h2></div></div></div><p>Ansible isn't just limited <a id="id203" class="indexterm"/>to being able to configure our machines; we can also use it to create the machines that we will be configuring. We are also not limited to just making the machines to be configured, we can also make networks, load balancers, DNS entries, or even your whole infrastructure. You can even have this automatically happen before you provision the machine by using the <code class="literal">group</code>, <code class="literal">group_by</code> and <code class="literal">add_host</code> modules.</p><p>In the following example, we use Google Compute to create two machines, and then install and start MySQL server on them:</p><div><pre class="programlisting">---
- name: Setup MySQL Infrastructure
  hosts: localhost
  connection: local
  tasks:
    - name: Start GCE Nodes
      gce:
        image: centos-6
        name: "mysql-{{ item }}"
        tags: mysql
        zone: us-central1-a
      with_sequence: count=2
      register: nodes
      when: '"mysql-{{ item }}" not in groups.all'

    - name: Wait for the nodes to start
      wait_for:
          host: "{{ item.instance_data[0].public_ip }}"
          port: 22
      with_items: nodes.results
      when: not item|skipped

    - name: Register the hosts in a group
      add_host:
          name: "{{ item.instance_data[0].name }}"
          ansible_ssh_host: "{{ item.instance_data[0].public_ip }}"
          groups: "tag_mysql"
      with_items: nodes.results
      when: not item|skipped

- name: Setup MySQL
  hosts: tag_mysql
  tasks:
    - name: Install MySQL
      yum:
        name: mysql
        state: present

    - name: Start MySQL
      service:
        name: mysqld
        state: started
        enabled: yes</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Tags</h2></div></div></div><p>Ansible tags are <a id="id204" class="indexterm"/>features that allow you to select the parts of a playbook that you need <a id="id205" class="indexterm"/>to run, and which should be skipped. While Ansible modules are idempotent and will automatically skip if there are no changes, this often requires a connection to the remote hosts. The yum module is often quite slow in determining whether a module is the latest, as it will need to refresh all the repositories.</p><p>If you know you don't need certain actions to be run, you can select to run only those tasks that have been tagged with a particular tag. This doesn't even try to run the tasks, it simply skips over it. This will save time on almost all the modules even if there is nothing to be done.</p><p>Let's say you have a machine that has a large number of shell accounts, but also several services set up to run on it. Now, imagine that a single user's SSH key has been compromised and needs to be removed immediately. Instead of running the entire playbook, or rewriting the playbooks to only include the steps necessary to remove that key, you could simply run the existing playbooks with the SSH keys tag, and it would only run the steps necessary to copy out the new keys, instantly skipping anything else.</p><p>This is particularly useful if <a id="id206" class="indexterm"/>you have a playbook with playbook includes in it that covers <a id="id207" class="indexterm"/>your whole infrastructure. With this setup, you can quickly deploy security patches, change passwords, and revoke keys across your entire infrastructure as quickly as possible.</p><p>Tagging tasks is really easy; simply add a key named <code class="literal">tag</code>, and set its value to a list of the tags you want to give it. The following code shows us how to do this:</p><div><pre class="programlisting">---
- name: Install and setup our webservers
  hosts: webservers
  tasks:
  - name: install latest software
    yum
      name: "{{ item }}"
      state: latest
    notify: restart apache
    tags:
      - patch
    with_items:
    - httpd
    - webalizer

  - name: Create subdirectories
    file
      dest: "/var/www/html/{{ item }}"
      state: directory
      mode: 755 owner: apache
      group: apache
    tags:
      - deploy
    with_items:
      - pub

  - name: Copy in web files
    copy
      src: "website/{{ item }}"
      dest: "/var/www/html/{{ item }}"
      mode: 0755
      owner: apache
      group: apache
    tags:
      - deploy
    with_items:
      - index.html
      - logo.png
      - style.css
      - app.js
      - pub/index.html

  - name: Copy webserver config
    tags:
      - deploy
      - config
    copy
      src: website/httpd.conf
      dest: /etc/httpd/conf/httpd.conf
      mode: 0644
      owner: root
      group: root
    notify: reload apache

  - name: set apache to start on startup
    service
      name: httpd
      state: started
      enabled: yes

  handlers:
  - name: reload apache
    service: name=httpd state=reloaded

  - name: restart apache
    service: name=httpd state=restarted</pre></div><p>This play defines the <a id="id208" class="indexterm"/>
<code class="literal">patch</code>, <code class="literal">deploy</code>, and <code class="literal">config</code> tags. If you know which operation you <a id="id209" class="indexterm"/>wish to do in advance, you can run Ansible with the correct argument, only running the operations you choose. If you don't supply a tag on the command line, the default is to run every task. For example, if you want Ansible to only run the tasks tagged as <code class="literal">deploy</code>, you will run the following command:</p><div><pre class="programlisting">
<strong>$ ansible-playbook webservers.yml --tags deploy</strong>
</pre></div><p>In addition to working on discrete tasks, tags are also available to roles, which make Ansible apply only the roles for the tags that have been supplied on the command line. You apply them similarly to the way they are applied to tasks. For example, refer to the following code:</p><div><pre class="programlisting">---
- hosts: website1
  roles:
    - common
    - { role: apache, tags: ["patch"] }
    - { role: website2, tags: ["deploy", "patch"] }</pre></div><p>In the preceding code, the <code class="literal">common</code> role does not get any tags, and will not be run if there are any tags applied. If <a id="id210" class="indexterm"/>the <code class="literal">patch</code> tag is applied, the <code class="literal">apache</code> and <code class="literal">website2</code> roles will be <a id="id211" class="indexterm"/>applied, but not <code class="literal">common</code>. If the <code class="literal">deploy</code> tag is applied; only the <code class="literal">website2</code> tag will be run. This will shorten the time required to patch servers or run deployments, as the unnecessary steps will be completely skipped.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Ansible's pull mode</h2></div></div></div><p>Ansible includes a <a id="id212" class="indexterm"/>pull mode that can drastically improve the scalability of your playbooks. So far we have only covered using Ansible to configure another machine over SSH. This is a contrast to Ansible's pull mode, which runs on the host that you wish to configure. Since <code class="literal">ansible-pull</code> runs on the machine that it is configuring, it doesn't need to make connections to other machines and runs much faster. In this mode, you provide your configuration in a git repository that Ansible downloads and uses to configure your machine.</p><p>You should use Ansible's <a id="id213" class="indexterm"/>pull mode in the following situations:</p><div><ul class="itemizedlist"><li class="listitem">Your node might not be available when configuring them, such as members of auto-scaling server farms</li><li class="listitem">You have a large amount of machines to configure and even with large values of forks, it would take a long time to configure them all</li><li class="listitem">You want machines to update their configuration automatically when the repository changes</li><li class="listitem">You want to run Ansible on a machine that may not have network access yet, such as in a kick start post install</li></ul></div><p>However, the pull mode does have the following disadvantages that make it unsuitable for certain circumstances:</p><div><ul class="itemizedlist"><li class="listitem">To connect to other machines and gather variables, or to copy a file, you need to have credentials on the managed nodes</li><li class="listitem">You need to co-ordinate the running of the playbook across a server farm; for example, if you could only take three servers offline at a time</li><li class="listitem">The servers are behind strict firewalls that don't allow incoming SSH connections from <a id="id214" class="indexterm"/>the nodes you used to configure them for Ansible</li></ul></div><p>The pull mode doesn't require anything special in your playbooks, but it does require some setup on the nodes you want configured. In some circumstances, you can do this using Ansible's normal <a id="id215" class="indexterm"/>push mode. Here is a small play to setup pull mode on <a id="id216" class="indexterm"/>a machine:</p><div><pre class="programlisting">---
- name: Ansible Pull Mode
  hosts: pullhosts
  tasks:
    - name: Setup EPEL
      command: "rpm -ivh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm"
      args: creates=/etc/yum.repos.d/epel.repo

    - name: Install Ansible + Dependencies
      yum:
        name: "{{ item }}"
        state: latest
        enablerepo: epel
      with_items:
      - ansible
      - git-core

    - name: Make directory to put downloaded playbooks in
      file:
        state: directory
        path: /opt/ansiblepull

    - name: Setup cron
      cron:
        name: "ansible-pull"
        user: root
        minute: "*/5"
        state: present
        job: "ansible-pull -U https://git.int.example.com.com/gitrepos/ansiblepull.git -D /opt/ansiblepull {{ inventory_hostname_short }}.yml"</pre></div><p>In this example, we performed the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First we installed and set up <strong>EPEL</strong>. This is a repository with extra software for CentOS. Ansible is available in the EPEL repository.</li><li class="listitem">Next we installed Ansible, making sure to enable the EPEL repository.</li><li class="listitem">Then we created a directory for Ansible's pull mode to put the playbooks in. Keeping these files around means you don't need to download the whole git repository all the time; only updates are required.</li><li class="listitem">Finally we set <a id="id217" class="indexterm"/>up a cron job that will try to run the <code class="literal">ansible-pull</code> <a id="id218" class="indexterm"/>mode config every five minutes.</li></ol><div></div><div><h3 class="title"><a id="note16"/>Note</h3><p>The preceding code downloads the repository off an internal HTTPS git server. If you want to download the repository instead of SSH, you will need to add a step to install SSH keys, or generate keys and copy them to the git machine.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Storing secrets</h1></div></div></div><p>Eventually, you <a id="id219" class="indexterm"/>will need to include sensitive data in your Ansible recipes. All the recipes that we have discussed so far have to be stored on the disk in plain text; if you are also storing it in source control, then third parties may even have access to this data. This is risky and may be in violation of your corporate policies.</p><p>This can be avoided using Ansible vaults. Vaults are files that are encrypted and can be decrypted by Ansible transparently. You can use them for includes, variable files, tasks lists in roles and any other YAML formatted file that Ansible uses. You can also use it with both JSON and YAML files included with the <code class="literal">-e</code> command-line argument to ansible-playbook. Vault files are managed with the <code class="literal">ansible-vault</code> command and can be used as if they were not encrypted at all.</p><p>The <code class="literal">ansible-vault</code> command has several modes, which are given as the first argument. This table describes the modes:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Mode</p>
</th><th valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">Create</code>
</p>
</td><td valign="top">
<p>This starts your default editor to create a new encrypted file</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Encrypt</code>
</p>
</td><td valign="top">
<p>This encrypts an existing file, turning it into a vault</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Edit</code>
</p>
</td><td valign="top">
<p>This edits a vault allowing you to change the content</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Rekey</code>
</p>
</td><td valign="top">
<p>This changes the password that is used to encrypt the vault</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Decrypt</code>
</p>
</td><td valign="top">
<p>This decrypts the vault turning it back into a regular file</p>
</td></tr></tbody></table></div><p>For example, to create a new variable file for your staging environment you would run:</p><div><pre class="programlisting">
<strong>$ ansible-vault create vars/staging.yml</strong>
</pre></div><p>This command will prompt you for a password, ask you to confirm it, and then open your editor so that you can add the content; finally, the encrypted content will be saved in <code class="literal">vars/staging.yml</code>.</p><p>When using a vault file, you <a id="id220" class="indexterm"/>need to provide the password so that they can be decrypted. This can be done in one of three ways. You can give the <code class="literal">--ask-vault-pass</code> argument to Ansible, which will cause Ansible to prompt for the password every time it starts. You can also use the <code class="literal">--vault-password-file</code> argument, which points to a file containing the password. Finally, you can add <code class="literal">vault_password_file</code> to the <code class="literal">ansible.cfg</code> file to automatically make Ansible use the vault password file for every command. It is important to note that only one password can be supplied for each Ansible run, so you can't include several different files with different passwords.</p><p>In order to have Ansible prompt for a password to run a playbook that is encrypted, you will do the following:</p><div><pre class="programlisting">
<strong>$ ansible-playbook --ask-vault-pass encrypted.yml</strong>
</pre></div><div><h3 class="title"><a id="note17"/>Note</h3><p>The password file can also be an executable. To print to the screen print to standard error, to read from the user you can use <code class="literal">stdin</code> as usual and finally the script needs to print the password to <code class="literal">stdout</code> before it exits.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we have covered the techniques required when moving from a simple setup to a larger deployment. We discussed how to separate your playbook into multiple parts using includes. We then looked at how we can package related includes and automatically include them all at once using roles. Finally, we discussed the pull mode, which allows you to automate the deployment of playbooks on the remote node itself.</p><p>In the next chapter, we will cover writing your own modules. We start this by building a simple module using bash scripting. We then look at how Ansible searches for modules, and how to make it find your own custom ones. Then, we take a look at how you can use Python to write more advanced modules using features that Ansible provides. Finally we will write a script that configures Ansible to pull its inventory from an external source.</p></div></body></html>