<html><head></head><body><div><div><p id="_idParaDest-77" class="chapter-number"><a id="_idTextAnchor133"/><em class="italic">Chapter 4</em></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor134"/>Managing Containers</h1>
			<p>So far, we have been concentrating on how to build, store, and distribute our Docker images. Now we are going to look at how we can launch containers, and also how we can use the Docker command-line client to manage and interact with them.</p>
			<p>We will be revisiting the commands we used in <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a>, <em class="italic">Docker Overview</em>, by going into a lot more detail, before delving deeper into the commands that are available. Once we are familiar with the container commands, we will look at Docker networks and Docker volumes.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Understanding Docker container commands</li>
				<li>Docker networking and volumes</li>
				<li>Docker Desktop Dashboard</li>
			</ul>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor135"/>Technical requirements</h1>
			<p>In this chapter, we will continue to use our local Docker installation. The screenshots in this chapter will be from my preferred operating system, macOS, but the Docker commands we will be running will work on all three of the operating systems on which we have installed Docker so far; however, some of the supporting commands, which will be few and far between, may only be applicable to macOS- and Linux-based operating systems.</p>
			<p>Check out the following video to see the Code in Action:<a href="https://bit.ly/3m1Wtk4">https://bit.ly/3m1Wtk4</a></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor136"/>Understanding Docker container commands</h1>
			<p>Before we dive into the<a id="_idIndexMarker256"/> more complex Docker commands, let's review and go into a little more detail on the commands we have used in previous chapters.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor137"/>The basics</h2>
			<p>In <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a>, <em class="italic">Docker Overview</em>, we <a id="_idIndexMarker257"/>launched the most basic container of all, the <code>hello-world</code> container, using the following command:</p>
			<pre>$ docker container run hello-world</pre>
			<p>As you may recall, this command pulls a <code>1.84</code> KB image from the Docker Hub. You can find the Docker Hub page for the image at <a href="https://hub.docker.com/images/hello-world/">https://hub.docker.com/images/hello-world/</a>, and, as per the following <code>Dockerfile</code>, it runs an executable called <code>hello:</code></p>
			<pre>FROM scratch
COPY hello /
CMD ["/hello"]</pre>
			<p>The <code>hello</code> executable prints the <code>Hello from Docker!</code> text to the Terminal, and then the process exits. As you can see from the full message text in the following Terminal output, the <code>hello</code> binary also lets you know exactly what steps have just occurred:</p>
			<div><div><img src="img/Figure_4.01_B15659.jpg" alt="Figure 4.1 – Running hello-world&#13;&#10;" width="1571" height="1007"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 4.1 – Running hello-world</p>
			<p>As the process exits, our <a id="_idIndexMarker258"/>container also stops. This can be seen by running the following command:</p>
			<pre>$ docker container ls -a</pre>
			<div><div><img src="img/Figure_4.02_B15659.jpg" alt="Figure 4.2 – Listing our containers&#13;&#10;" width="1650" height="422"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 4.2 – Listing our containers</p>
			<p>You may notice in the Terminal output that I first ran <code>docker container ls</code> with and without the <code>-a</code> flag. This is shorthand for <code>--all</code>, as running it without the flag does not show any exited containers.</p>
			<p>You may have noticed that we didn't have to name our container. This is because it wasn't going to be around long enough for us to care what it was called. Docker automatically assigns names for containers, though, and in my case, you can see that it was called <code>awesome_jackson</code>.</p>
			<p>You will notice throughout your use of Docker that it comes up with some really interesting names for your containers if you choose to let it generate them for you. It created the name<a id="_idIndexMarker259"/> from a wordlist for the left-hand word, and for the right-hand word, from the names of notable scientists and hackers. Although this is slightly off topic, the code to generate the names can be found in <code>names-generator.go</code>. Right at the end of the source code, it has the following <code>if</code> statement:</p>
			<pre>if name == "boring_wozniak" /* Steve Wozniak is not boring */ { goto begin }</pre>
			<p>This means there will never be a container called boring_wozniak (and quite rightly, too).</p>
			<p class="callout-heading">Information:</p>
			<p class="callout">Steve Wozniak is an inventor, electronics engineer, programmer, and entrepreneur who co-founded Apple Inc. with Steve Jobs. He is known as a pioneer of the personal computer revolution of the 70s and 80s, and is definitely not boring!</p>
			<p>We can remove the container with a status of <code>exited</code> by running the following command, making sure that you replace the name of the container with your own container name:</p>
			<pre>$ docker container rm awesome_jackson</pre>
			<p>Also, at the end of <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a>, <em class="italic">Docker Overview</em>, we launched a container using the official NGINX image by using the following command:</p>
			<pre>$ docker container run -d --name nginx-test -p 8080:80 nginx</pre>
			<p>As you may remember, this downloads the image and runs it, mapping port <code>8080</code> on our host machine<a id="_idIndexMarker260"/> to port <code>80</code> on the container, and calls it <code>nginx-test</code>:</p>
			<div><div><img src="img/Figure_4.03_B15659.jpg" alt="Figure 4.3 – Running an NGINX container&#13;&#10;" width="1594" height="494"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Running an NGINX container</p>
			<p>As you can see, running the Docker image <code>ls</code> shows us that we now have two images downloaded and also running. The following command shows us that we have a running container:</p>
			<pre>$ docker container ls</pre>
			<p>The following Terminal output shows that mine had been up for 5 minutes when I ran the command:</p>
			<div><div><img src="img/Figure_4.04_B15659.jpg" alt="Figure 4.4 – Viewing the running containers&#13;&#10;" width="1627" height="287"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Viewing the running containers</p>
			<p>As you can see from our <code>docker container run</code> command, we introduced three flags. One of them was <code>-d</code>, which is shorthand for <code>--detach</code>. If we hadn't added this flag, then our container would have executed in the foreground, which means that our Terminal would have been frozen until we passed the process an escape command by pressing <em class="italic">Ctrl + C</em>.</p>
			<p>We can see this in action by running the following command to launch a second NGINX container to run alongside the container we have already launched:</p>
			<pre>$ docker container run --name nginx-foreground -p 9090:80 nginx</pre>
			<p>Once launched, open a<a id="_idIndexMarker261"/> browser and enter <code>http://localhost:9090/</code>. As you load the page, you will notice that your page visit is printed to the screen. Hitting refresh in your browser will display more hits, until you press <em class="italic">Ctrl + C</em> back in the Terminal:</p>
			<div><div><img src="img/Figure_4.05_B15659.jpg" alt="Figure 4.5 – Viewing the output of running the container in the foreground&#13;&#10;" width="1650" height="696"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Viewing the output of running the container in the foreground</p>
			<p>Running <code>docker container ls -a</code> shows that you have two containers, one of which has exited:</p>
			<div><div><img src="img/Figure_4.06_B15659.jpg" alt="Figure 4.6 – Listing the running containers&#13;&#10;" width="1650" height="334"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Listing the running containers</p>
			<p>So, what happened? When we removed the <code>detach</code> flag, Docker connected us to the NGINX process directly within the container, meaning that we had visibility of <strong class="bold">stdin</strong>, <strong class="bold">stdout</strong>, and <strong class="bold">stderr</strong> for that process. When we used <em class="italic">Ctrl + C</em>, we actually sent an instruction to the NGINX process to terminate it. As that was the process that was keeping our <a id="_idIndexMarker262"/>container running, the container exited immediately once there was no longer a running process.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Standard input</strong> (<strong class="bold">stdin</strong>) is the handle that our process reads to get information from the end user. <strong class="bold">Standard output</strong> (<strong class="bold">stdout</strong>) is where the process writes normal information. <strong class="bold">Standard error</strong> (<strong class="bold">stderr</strong>) is where the process writes error messages.</p>
			<p>Another <a id="_idIndexMarker263"/>thing <a id="_idIndexMarker264"/>you may have noticed when<a id="_idIndexMarker265"/> we launched the <code>nginx-foreground</code> container is that we gave it a different name using the <code>--name</code> flag.</p>
			<p>This is because you cannot have two containers with the same name, since Docker gives you the option of interacting with your containers using both the <code>CONTAINER ID or NAME</code> values. This is the reason the name generator function exists: to assign a random name to containers you do not wish to name yourself, and also to ensure that we never call Steve Wozniak boring.</p>
			<p>The final thing to mention is that when we launched <code>nginx-foreground</code>, we asked Docker to map port <code>9090</code> to port <code>80</code> on the container. This was because we cannot assign more than one process to a port on a host machine, so if we attempted to launch our second container with the same port as the first, we would have received an error message:</p>
			<pre>docker: Error response from daemon: driver failed programming external connectivity on endpoint nginx-foreground (3f5b355607f24e03f09a60ee688645f223bafe4492f807459e4a 2b83571f23f4): Bind for 0.0.0.0:8080 failed: port is already allocated.</pre>
			<p>Also, since we are running the container in the foreground, you may receive an error from the NGINX process, as it failed to start:</p>
			<pre>ERRO[0003] error getting events from daemon: net/http: request cancelled</pre>
			<p>However, you may also notice that we are mapping to port <code>80</code> on the container – why no error there?</p>
			<p>Well, as explained in <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a>, <em class="italic">Docker Overview</em>, the containers themselves are isolated resources, which means that we can launch as many containers as we like with port <code>80</code> remapped, and <a id="_idIndexMarker266"/>they will never clash with other containers; we only run into problems when we want to route to the exposed container port from our Docker host.</p>
			<p>Let's keep our NGINX container running for the next section, where we will explore more ways of interacting with the container.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor138"/>Interacting with your containers</h2>
			<p>So far, our containers<a id="_idIndexMarker267"/> have been running a single process. Docker provides you with a few tools that enable you to both fork additional processes and interact with them, and we will be covering those tools in the following sections:</p>
			<h3>attach</h3>
			<p>The first way of<a id="_idIndexMarker268"/> interacting with your running container is to attach to the running process. We still have our <code>nginx-test</code> container running, so let's connect to that by running this command:</p>
			<pre>$ docker container attach nginx-test</pre>
			<p>Opening your browser and going to <code>http://localhost:8080/</code> will print the NGINX access logs to the screen, just like when we launched the <code>nginx-foreground</code> container. Pressing <em class="italic">Ctrl + C</em> will terminate the process and return your Terminal to normal. However, as before, we would have terminated the process that was keeping the container running:</p>
			<div><div><img src="img/Figure_4.07_B15659.jpg" alt="Figure 4.7 – Attaching to our container&#13;&#10;" width="1650" height="370"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Attaching to our container</p>
			<p>We can start our container back up by running the following command:</p>
			<pre>$ docker container start nginx-test</pre>
			<p>This will start the container back up in the detached state, meaning that it is running in the background again, as this was the state that the container was originally launched in. Going to <code>http://localhost:8080/</code> will show you the NGINX welcome page again.</p>
			<p>Let's reattach to our process, but this time with an additional option:</p>
			<pre>$ docker container attach --sig-proxy=false nginx-test</pre>
			<p>Hitting the container's URL a few times and then pressing <em class="italic">Ctrl + C</em> will detach us from the NGINX process, but this time, rather than terminating the NGINX process, it will just return us to our Terminal, leaving the container in a detached state that can be seen by running docker container ls:</p>
			<div><div><img src="img/Figure_4.08_B15659.jpg" alt="Figure 4.8 – Disconnecting from our container&#13;&#10;" width="1650" height="370"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Disconnecting from our container</p>
			<p>This is a great way of quickly attaching to a running container to debug issues while keeping the <a id="_idIndexMarker269"/>container's main process up and running.</p>
			<h3>exec</h3>
			<p>The <code>attach</code> command<a id="_idIndexMarker270"/> is useful if you need to connect to the process your container is running, but what if you need something that is a little more interactive?</p>
			<p>You can use the <code>exec</code> command. This spawns a second process within the container that you can interact with. For example, to see the contents of the <code>/etc/debian_version</code> file, we can run the following command:</p>
			<pre>$ docker container exec nginx-test cat /etc/debian_version</pre>
			<p>This will spawn a second process, the <code>cat</code> command in this case, which prints the contents of <code>/etc/debianversion to stdout</code>. The second process will then terminate, leaving our container as it was before the <code>exec</code> command was executed:</p>
			<div><div><img src="img/Figure_4.09_B15659.jpg" alt="Figure 4.9 – Executing a command against our container&#13;&#10;" width="1246" height="186"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Executing a command against our container</p>
			<p>We can take this one step further by running the following command:</p>
			<pre>$ docker container exec -i -t nginx-test /bin/bash</pre>
			<p>This time, we are forking a bash process and using the <code>-i</code> and <code>-t</code> flags to keep open console access to our container. The <code>-i</code> flag is shorthand for <code>--interactive</code>, which instructs Docker to keep <code>stdin</code> open so that we can send commands to the process. The <code>-t</code> flag is short for <code>–tty</code> and <a id="_idIndexMarker271"/>allocates a pseudo-TTY to the session.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Early user terminals connected to computers were called <strong class="bold">teletypewriters</strong>. While these devices are no longer used today, the acronym TTY has continued to be used to described text-only consoles in modern computing.</p>
			<p>What this<a id="_idIndexMarker272"/> means is that you will be able to interact with the container as if you had a remote Terminal session, like SSH:</p>
			<div><div><img src="img/Figure_4.10_B15659.jpg" alt="Figure 4.10 – Opening an interactive session to our container&#13;&#10;" width="1071" height="494"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Opening an interactive session to our container</p>
			<p>While this is extremely useful, as you can interact with the container as if it were a virtual machine, I do not recommend making any changes to your containers as they are running using the pseudo-TTY. It is more than likely that those changes will not persist and will be lost when your container is removed. We will go into the thinking behind this in more detail in <a href="B15659_15_Final_JM_ePub.xhtml#_idTextAnchor823"><em class="italic">Chapter 15</em></a>, <em class="italic">Docker Workflows</em>.</p>
			<p>Now that we have covered the various methods you can connect to and interact with your containers, we are going to look at some of the tools provided by Docker that mean you shouldn't <a id="_idIndexMarker273"/>have to.</p>
			<p>Logs and process information</p>
			<p>So far, we have<a id="_idIndexMarker274"/> been attaching to either the process in our<a id="_idIndexMarker275"/> container, or to the container itself, in order to view information. Docker provides the commands that we are going to cover in this section that allow you to view information about your containers without having to use either the <code>attach</code> or <code>exec</code> commands. </p>
			<p>Let's start by looking at how you c view the output being generated by the process within the container without having to run it in the foreground.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor139"/>logs</h2>
			<p>The <code>logs</code> command is<a id="_idIndexMarker276"/> pretty self-explanatory. It allows you to interact with the <code>stdout</code> stream of your containers, which Docker is keeping track of in the background. For example, to view the last entries written to <code>stdout</code> for our <code>nginx-test</code> container, you just need to use the following command:</p>
			<pre>$ docker container logs --tail 5 nginx-test</pre>
			<p>The output of the command is shown here:</p>
			<div><div><img src="img/Figure_4.11_B15659.jpg" alt="Figure 4.11 – Tailing the logs&#13;&#10;" width="1650" height="477"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Tailing the logs</p>
			<p>To view the logs in real time, I simply need to run the following:</p>
			<pre>$ docker container logs -f nginx-test</pre>
			<p>The <code>-f</code> flag is shorthand for <code>--follow</code>. I can also, for example, view everything that has been logged since a certain time by running the following command:</p>
			<pre>$ docker container logs --since 2020-03-28T15:52:00 nginx-test</pre>
			<p>The output of the command is shown here:</p>
			<div><div><img src="img/Figure_4.12_B15659.jpg" alt="Figure 4.12 – Checking the logs after a certain time&#13;&#10;" width="1649" height="478"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Checking the logs after a certain time</p>
			<p>If you notice that the<a id="_idIndexMarker277"/> timestamp in the access log is different to that which you are searching for, that is due to the logs command that shows the timestamps of stdout as recorded by Docker, and not the time within the container. An example of this would be the hours' time difference between the host machine and the container due to <strong class="bold">British Summer Time (BST)</strong>.</p>
			<p>Luckily, to save confusion, you can add <code>-t</code> to your <code>logs</code> command:</p>
			<pre>$ docker container logs --since 2020-03-28T15:52:00 -t nginx-test</pre>
			<p>The <code>-t</code> flag is short for <code>--timestamp</code>; this option prepends the time the output was captured by Docker:</p>
			<div><div><img src="img/Figure_4.13_B15659.jpg" alt="Figure 4.13 – Viewing the logs and with the time the entry was logged&#13;&#10;" width="1617" height="645"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Viewing the logs and with the time the entry was logged</p>
			<p>Now what we have<a id="_idIndexMarker278"/> looked at the ways we can view the output of the processes running in our containers, let's examine how we get more detail on the process itself.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor140"/>top</h2>
			<p>The <code>top</code> command is<a id="_idIndexMarker279"/> quite a simple one; it lists the processes running within the container that you specify, and is used as follows:</p>
			<pre>$ docker container top nginx-test</pre>
			<p>The output of the command is shown here:</p>
			<div><div><img src="img/Figure_4.14_B15659.jpg" alt="Figure 4.14 – Running the top command&#13;&#10;" width="1443" height="318"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Running the top command</p>
			<p>As you can see from the following Terminal output, we have two processes running, both of which<a id="_idIndexMarker280"/> are NGINX, which is to be expected.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor141"/>stats</h2>
			<p>The <code>stats</code> command<a id="_idIndexMarker281"/> provides real-time information on either the specified container or, if you don't pass a <code>NAME</code> or <code>ID</code> container, on all running containers:</p>
			<div><div><img src="img/Figure_4.15_B15659.jpg" alt="Figure 4.15 – Viewing the real-time stats of a single container&#13;&#10;" width="1449" height="274"/>
				</div>
			</div>
			<p class="figure-caption">Fig<a id="_idTextAnchor142"/>u<a id="_idTextAnchor143"/>r<a id="_idTextAnchor144"/>e 4.15 – Viewing the real-time stats of a single container</p>
			<p>As you can see from the following Terminal output, we are given information on <code>CPU</code>, <code>RAM</code>, <code>NETWORK</code>, <code>DISK IO</code>, and <code>PIDS</code> for the specified container:</p>
			<div><div><img src="img/Figure_4.16_B15659.jpg" alt="Figure 4.16 – Viewing the real-time stats of all running containers&#13;&#10;" width="1575" height="362"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – Viewing the real-time stats of all running containers</p>
			<p>However, as you can see from the preceding output, if the container isn't running, there aren't any resources being utilized, so it doesn't really add any value, other than giving you a visual representation of how many containers you have running and where the resources are being used.</p>
			<p>It is also worth pointing out that the information displayed by the <code>stats</code> command is real time only; Docker does not record the resource utilization and make it available in the same way that the <code>logs</code> command does. We will be looking at more long-term storage options for<a id="_idIndexMarker282"/> resource utilization in later chapters.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor145"/>Resource limits</h2>
			<p>The <code>stats</code> command <a id="_idIndexMarker283"/>we ran showed us the resource utilization of our containers. By default, when launched, a container will be allowed to consume all the available resources on the host machine if it so requires. We can put limits on the resources our containers can consume. Let's start by updating the resource allowances of our nginx-test container.</p>
			<p>Typically, we would have set the limits when we launched our container using the <code>run</code> command; for example, to halve the CPU priority and set a memory limit of <code>128M</code>, we would have used the following command:</p>
			<pre>$ docker container run -d --name nginx-test --cpu-shares 512 --memory 128M -p 8080:80 nginx</pre>
			<p>However, we didn't launch our nginx-test container with any resource limits, meaning that we need to update our already running container. To do this, we can use the <code>update</code> command. Now, you may have thought that this should just entail running the following command:</p>
			<pre>$ docker container update --cpu-shares 512 --memory 128M nginx-test</pre>
			<p>But actually, running the preceding command will produce an error:</p>
			<pre>Error response from daemon: Cannot update container 662b6e5153ac77685f25a1189922d7f49c2df6b2375b3635a37eea 4c8698aac2: Memory limit should be smaller than already set memoryswap limit, update the memoryswap at the same time</pre>
			<p>So, what is the <code>memoryswap</code> limit currently set to? To find this out, we can use the <code>inspect</code> command to display all of the configuration data for our running container; just run the following command:</p>
			<pre>$ docker container inspect nginx-test</pre>
			<p>If you are following along, then you will see that running the preceding command, there is a lot of configuration data that will be displayed, too much to display here. When I ran the command, a <code>199 </code><code>line JSON</code> array was returned. Let's use the <code>grep</code> command to filter out just the lines that contain the word <code>memory</code>:</p>
			<pre>$ docker container inspect nginx-test | grep -i memory</pre>
			<p>This returns the following configuration data:</p>
			<pre>            "Memory": 0,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,</pre>
			<p>Everything is set<a id="_idIndexMarker284"/> to <code>0</code>, so how can <code>128M</code> be smaller than 0?</p>
			<pre>$ docker container update --cpu-shares 512 --memory 128M --memory-swap 256M nginx-test</pre>
			<p>In the context of the configuration of the resources, <code>0</code> is actually the default value and means that there are no limits. Notice the lack of <code>M</code> after each numerical value. This means that our<a id="_idIndexMarker285"/> <code>update</code> command should actually read as the preceding command.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Paging</strong> is a memory management scheme in which the kernel stores and retrieves, or swaps, data from secondary storage for use in the main memory. This allows processes to exceed the size of physical memory available.</p>
			<p>By default, when you set <code>--memory</code> as part of the <code>run</code> command, Docker will set <code>--memory-swap size</code> to be twice that of <code>--memory</code>. If you run <code>docker container stats nginx-test</code> now, you should see our limits in place:</p>
			<div><div><img src="img/Figure_4.17_B15659.jpg" alt="Figure 4.17 – Using stats to view the limits&#13;&#10;" width="1380" height="274"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – Using stats to view the limits</p>
			<p>Also, re-running <code>docker container inspect nginx-test | grep -i memory</code> will show the changes as follows:</p>
			<pre>            "Memory": 134217728,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 268435456,
            "MemorySwappiness": null,</pre>
			<p>You will notice that <a id="_idIndexMarker286"/>while we defined the values in MB, they are displayed here in bytes, so they are<a id="_idTextAnchor146"/> <a id="_idTextAnchor147"/>correct.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The values when running <code>docker container inspect</code> are all shown in bytes rather than megabytes (MB).</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor148"/>Container states and miscellaneous commands</h2>
			<p>For the final <a id="_idIndexMarker287"/>part of this section, we are going to <a id="_idIndexMarker288"/>look at the various states your containers could be in, along with the few remaining commands we have yet to cover as part of the <code>docker container</code> command.</p>
			<p>Running <code>docker container ls -a</code> should show something similar to the following Terminal output:</p>
			<div><div><img src="img/Figure_4.18_B15659.jpg" alt="Figure 4.18 – Listing all of the containers, including those that have exited&#13;&#10;" width="1650" height="353"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – Listing all of the containers, including those that have exited</p>
			<p>As you can see, we <a id="_idIndexMarker289"/>have two containers; one<a id="_idIndexMarker290"/> has the status of <code>Up</code> and the other has <code>Exited</code>. Before we continue, let's launch five more containers. To do this quickly, run the following command:</p>
			<pre>$ for i in {1..5}; do docker container run -d --name nginx$(printf "$i") nginx; done </pre>
			<p>You should see something like the following output:</p>
			<div><div><img src="img/Figure_4.19_B15659.jpg" alt="Figure 4.19 – Launching five containers quickly&#13;&#10;" width="1650" height="342"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – Launching five containers quickly</p>
			<p>When running <code>docker container ls -a</code>, you should see your five new containers, named <code>nginx1</code> through to <code>nginx5</code>:</p>
			<div><div><img src="img/Figure_4.20_B15659.jpg" alt="Figure 4.20 – Viewing our five new containers&#13;&#10;" width="1627" height="686"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – Viewing our five new containers</p>
			<p>Now that we<a id="_idIndexMarker291"/> have the additional containers up<a id="_idIndexMarker292"/> and running, let's look at how we can their states.</p>
			<h3>pause and unpause</h3>
			<p>Let's look at <a id="_idIndexMarker293"/>pausing<a id="_idIndexMarker294"/> <code>nginx1</code>. To do this, simply run the following:</p>
			<pre>$ docker container pause nginx1</pre>
			<p>Running <code>docker container ls</code> will show that the container has a status of <code>Up</code>, but it also says <code>Paused</code>:</p>
			<div><div><img src="img/Figure_4.21_B15659.jpg" alt="Figure 4.21 – Pausing a container&#13;&#10;" width="1650" height="696"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.21 – Pausing a container</p>
			<p>Note that we didn't have to use the <code>-a</code> flag to see information about the container as the process <a id="_idIndexMarker295"/>has not been terminated; instead, it has been <a id="_idIndexMarker296"/>suspended using the <code>cgroups</code> freezer. With the <code>cgroups</code> freezer, the process is unaware it has been suspended, meaning that it can be resumed.</p>
			<p>As you will have probably already guessed, you can resume a paused container using the <code>unpause</code> command, as follows:</p>
			<pre>$ docker container unpause nginx1</pre>
			<p>This command is useful if you need to freeze the state of a container; for example, maybe one of your containers is going haywire and you need to do some investigation later, but don't want it to have a negative impact on your other running containers.</p>
			<p>Now, let's look at how you can properly stop and remove containers.</p>
			<h3>stop, start, restart, and kill</h3>
			<p>Next up, we<a id="_idIndexMarker297"/> have <a id="_idIndexMarker298"/>the <code>stop</code>, <code>start</code>, <code>restart</code>, and <code>kill</code> commands. We <a id="_idIndexMarker299"/>have <a id="_idIndexMarker300"/>already used the <code>start</code> command to resume a container with a status of <code>Exited</code>. The <code>stop</code> command works exactly the same way as when we used <em class="italic">Ctrl + C</em> to detach from your container running in the foreground. </p>
			<p>Run the following command:</p>
			<pre>$ docker container stop nginx2</pre>
			<p>With this, a request is sent to the process for it to terminate, called <code>SIGTERM</code>. If the process has not terminated itself within a grace period, then a kill signal, called <code>SIGKILL</code>, is sent. This will immediately terminate the process, not giving it any time to finish whatever is causing the delay; for example, committing the results of a database query to disk.</p>
			<p>Because this could be bad, Docker gives you the option of overriding the default grace period, which is 10 seconds, by<a id="_idIndexMarker301"/> using the <code>-t</code> flag; this is short for <code>--time</code>. For example, running the<a id="_idIndexMarker302"/> following command will wait up to 60 seconds <a id="_idIndexMarker303"/>before sending a <code>SIGKILL</code> command, in the event that it needs<a id="_idIndexMarker304"/> to be sent to kill the process:</p>
			<pre>$ docker container stop -t 60 nginx3</pre>
			<p>The <code>start</code> command, as we have already seen, will start the process back up; however, unlike the <code>pause</code> and <code>unpause</code> commands, the process, in this case, starts from scratch using the flags that originally launched it, rather than starting from where it left off:</p>
			<pre>$ docker container start nginx2 nginx3</pre>
			<p>The <code>restart</code> command is a combination of the following two commands; it stops and then starts the <code>ID</code> or <code>NAME</code> container you pass it. Also, as with <code>stop</code>, you can pass the <code>-t </code>flag:</p>
			<pre>$ docker container restart -t 60 nginx4</pre>
			<p>Finally, you also have the option of sending a <code>SIGKILL</code> command immediately to the container by running the <code>kill</code> command:</p>
			<pre>$ docker container kill nginx5</pre>
			<p>There is one more thing need to cover, and that is removing the containers.</p>
			<h3>Removing containers</h3>
			<p>Let's check the status of <a id="_idIndexMarker305"/>containers we have been using by the <code>docker container ls -a</code> command. When I run the command, I can see that I have two containers with an <code>Exited</code> status and all of the others are running:</p>
			<div><div><img src="img/Figure_4.22_B15659.jpg" alt="Figure 4.22 – Viewing the state of all of our containers&#13;&#10;" width="1650" height="716"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22 – Viewing the state of all of our containers</p>
			<p>To remove the two exited containers, I can simply run the <code>prune</code> command:</p>
			<pre>$ docker container prune</pre>
			<p>When doing so, a warning pops up asking you to confirm whether you are really sure, as seen in the following screenshot:</p>
			<div><div><img src="img/Figure_4.23_B15659.jpg" alt="Figure 4.23 – Pruning the containers&#13;&#10;" width="1304" height="450"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23 – Pruning the containers</p>
			<p>You can choose which container you want to remove using the <code>rm</code> command, an example of which is shown here:</p>
			<pre>$ docker container rm nginx4</pre>
			<p>Another alternative would be to string the <code>stop</code> and <code>rm</code> commands together:</p>
			<pre>$ docker container stop nginx3 &amp;&amp; docker container rm nginx3</pre>
			<p>However, given that you<a id="_idIndexMarker306"/> can use the <code>prune</code> command now, this is probably way too much effort, especially as you are trying to remove the containers and probably don't care too much how gracefully the process is terminated.</p>
			<p>Feel free to remove the remainder of your containers using whichever method you like.</p>
			<p>Before we wrap up this section of the chapter, we are going to look at a few more useful commands that can't be really grouped together.</p>
			<h3>Miscellaneous commands</h3>
			<p>For the final part of <a id="_idIndexMarker307"/>this section, we are going to look at a few commands that you probably won't use too much during your day-to-day use of Docker. The first of these is <code>create</code>. The <code>create</code> command is pretty similar to the <code>run</code> command, except that it does not start the container, but instead prepares and configures one:</p>
			<pre>$ docker container create --name nginx-test -p 8080:80 nginx</pre>
			<p>You can check the status of your created container by running <code>docker container ls -a</code>, and then starting the container with <code>docker container start nginx-test</code>, before checking the status again:</p>
			<div><div><img src="img/Figure_4.24_B15659.jpg" alt="Figure 4.24 – Creating and then running a container&#13;&#10;" width="1633" height="616"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24 – Creating and then running a container</p>
			<p>The next command we are going to quickly look at is the <code>port</code> command; this displays the <code>port</code> number <a id="_idIndexMarker308"/>along with any port mappings for the container:</p>
			<pre>$ docker container port nginx-test</pre>
			<p>It should return the following:</p>
			<pre>    80/tcp -&gt; 0.0.0.0:8080</pre>
			<p>We already know this, as it is what we configured. Also, the ports are listed in the <code>docker container ls</code> output.</p>
			<p>The next command we are going to look at quickly is the <code>diff</code> command. This command prints a list of all of the files that have been added (<code>A</code>) or changed (<code>C</code>) since the container was started – so basically, a list of the differences in the filesystem between the original image we used to launch the container and what files are present now.</p>
			<p>Before we run the command, let's create a blank file within the <code>nginx-test</code> container using the <code>exec</code> command:</p>
			<pre>$ docker container exec nginx-test touch /tmp/testing</pre>
			<p>Now that we have a file called <code>testing</code> in <code>/tmp</code>, we can view the differences between the original image and the running container using the following command:</p>
			<pre>$ docker container diff nginx-test</pre>
			<p>This will return a list of files. As you can see from the following list, our testing file is there, along with <a id="_idIndexMarker309"/>the files that were created when NGINX started:</p>
			<pre>    C /run
    A /run/nginx.pid
    C /tmp
    A /tmp/testing
    C /var
    C /var/cache
    C /var/cache/nginx
    A /var/cache/nginx/client_temp
    A /var/cache/nginx/fastcgi_temp
    A /var/cache/nginx/proxy_temp
    A /var/cache/nginx/scgi_temp
    A /var/cache/nginx/uwsgi_temp</pre>
			<p>It is worth pointing out that once we stop and remove the container, these files will be lost. In the next section of this chapter, we will look at Docker volumes and learn how we can persist data. Before we move on though, let's get a copy of the file we just created using the <code>cp</code> command.</p>
			<p>To do this, we can run the following:</p>
			<pre>$ docker container cp nginx-test:/tmp/testing testing </pre>
			<p>As you can see from the command, we are providing the container name followed by <code>:</code> and the full path to the file we want to copy. What follows is the local path. Here, you can see that we are simply calling the file <code>testing</code> and it will be copied to the current folder: </p>
			<div><div><img src="img/Figure_4.25_B15659.jpg" alt="Figure 4.25 – Copying a file to a container&#13;&#10;" width="1298" height="230"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.25 – Copying a file to a container</p>
			<p>As the file does <a id="_idIndexMarker310"/>not contain any data, lets add some and then copy it back to the container:</p>
			<pre>$ echo "This is a test of copying a file from the host machine to the container" &gt; testing
$ docker container cp testing nginx-test:/tmp/testing
$ docker container exec nginx-test cat /tmp/testing</pre>
			<p>Notice that in the second command, we are swapping the paths around. This time, we are providing the path of the local file and the container name and path:</p>
			<div><div><img src="img/Figure_4.26_B15659.jpg" alt="Figure 4.26 – Copying a file with contents to the container&#13;&#10;" width="1650" height="241"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.26 – Copying a file with contents to the container</p>
			<p>The other thing of note is that while we are overwriting an existing file, Docker did not warn us or give an option to back out of the command – it went ahead and overwrote the file immediately, so please be careful when using <code>docker container cp</code>.</p>
			<p>If you are following along, you should remove any running containers launched during this section using the command of your choice before moving on.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor149"/>Docker networking and volumes</h1>
			<p>Next up, we are<a id="_idIndexMarker311"/> going to take a look at the basics of Docker networking and Docker<a id="_idIndexMarker312"/> volumes using the default drivers. Let's take a look at networking first.</p>
			<p>Docker networking</p>
			<p>So far, we have<a id="_idIndexMarker313"/> been launching our containers on a single flat shared network. Although we have not talked about it yet, this means the containers we have been launching would have been able to communicate with each other without having to use any of the host networking.</p>
			<p>Rather than going into detail now, let's work through an example. We are going to be running a two-container application; the first container will be running Redis, and the second, our application, which uses the Redis container to store a system state.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Redis is an in-memory data structure store that can be used as a database, cache, or message broker. It supports different levels of on-disk persistence.</p>
			<p>Before we launch our application, let's download the container images we will be using, and also create the network:</p>
			<pre>$ docker image pull redis:alpine
$ docker image pull russmckendrick/moby-counter
$ docker network create moby-counter</pre>
			<p>You should see something similar to the following Terminal output:</p>
			<div><div><img src="img/Figure_4.27_B15659.jpg" alt="Figure 4.27 – Pulling the images we need and creating the network&#13;&#10;" width="1600" height="1198"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.27 – Pulling the images we need and creating the network</p>
			<p>Now that we have <a id="_idIndexMarker314"/>our images pulled and our network created, we can launch our containers, starting with the Redis one:</p>
			<pre>$ docker container run -d --name redis --network moby-counter redis:alpine</pre>
			<p>As you can see, we used the <code>--network</code> flag to define the network that our container was launched in. Now that the Redis container is launched, we can launch the application container by running the following command:</p>
			<pre>$ docker container run -d --name moby-counter --network moby-counter -p 8080:80 russmckendrick/moby-counter</pre>
			<p>Again, we launched the container on the <code>moby-counter</code> network. This time, we mapped port <code>8080</code> to port <code>80</code> on the container. Note that we did not need to worry about exposing any ports of the Redis container. That is because the Redis image comes with some defaults that expose the default port, which is <code>6379</code> for us. This can be seen by running <code>docker container ls</code>:</p>
			<div><div><img src="img/Figure_4.28_B15659.jpg" alt="Figure 4.28 – Listing the containers needed for our application&#13;&#10;" width="1636" height="356"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28 – Listing the containers needed for our application</p>
			<p>All that remains now is<a id="_idIndexMarker315"/> to access the application. To do this, open your browser and go to <code>http://localhost:8080/</code>. You should be greeted by a mostly blank page, with the message <strong class="bold">Click to add logos…</strong>:</p>
			<div><div><img src="img/Figure_4.29_B15659.jpg" alt="Figure 4.29 – Our application is ready to go&#13;&#10;" width="1009" height="356"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29 – Our application is ready to go</p>
			<p>Clicking anywhere on the page will add Docker logos, so click away:</p>
			<div><div><img src="img/Figure_4.30_B15659.jpg" alt="Figure 4.30 – Adding some logos to the page&#13;&#10;" width="1297" height="436"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.30 – Adding some logos to the page</p>
			<p>So, what is happening? The application that is being served from the <code>moby-counter</code> container is making a connection to the <code>redis</code> container, and using the service to store the onscreen coordinates of each of the logos that you place on the screen by clicking.</p>
			<p>How is the <code>moby-counter</code> application connecting to the <code>redis</code> container? Well, in the <code>server.js</code> file, the<a id="_idIndexMarker316"/> following default values are being set:</p>
			<pre>var port = opts.redis_port || process.env.USE_REDIS_PORT || 6379
var host = opts.redis_host || process.env.USE_REDIS_HOST || 'redis'</pre>
			<p>This means that the <code>moby-counter</code> application is looking to connect to a host called <code>redis</code> on port <code>6379</code>. Let's try using the <code>exec</code> command to ping the <code>redis</code> container from the <code>moby-counter </code>application and see what we get:</p>
			<pre>$ docker container exec moby-counter ping -c 3 redis</pre>
			<p>You should see something similar to the following output:</p>
			<div><div><img src="img/Figure_4.31_B15659.jpg" alt="Figure 4.31 – Pinging the redis container using the container name&#13;&#10;" width="1157" height="494"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.31 – Pinging the redis container using the container name</p>
			<p>As you can see, the <code>moby-counter</code> container resolves <code>redis</code> to the IP address of the <code>redis</code> container, which is <code>172.18.0.2</code>. You may be thinking that the application's host file contains an entry for the <code>redis</code> container; let's take a look using the following command:</p>
			<pre>$ docker container exec moby-counter cat /etc/hosts</pre>
			<p>This returns the <a id="_idIndexMarker317"/>content of <code>/etc/hosts</code>, which, in my case, looks like the following:</p>
			<pre>    127.0.0.1	localhost
    ::1	localhost ip6-localhost ip6-loopback
    fe00::0	ip6-localnet
    ff00::0	ip6-mcastprefix
    ff02::1	ip6-allnodes
    ff02::2	ip6-allrouters
    172.18.0.3	e7335ca1830d</pre>
			<p>Other than the entry at the end, which is actually the IP address resolving to the hostname of the local container, <code>e7335ca1830d</code> is the ID of the container; there is no sign of an entry for <code>redis</code>. Next, let's check <code>/etc/resolv.conf</code> by running the following command:</p>
			<pre>$ docker container exec moby-counter cat /etc/resolv.conf</pre>
			<p>This returns what we are looking for. As you can see, we are using a local <code>nameserver</code>:</p>
			<pre>nameserver 127.0.0.11
options ndots:0</pre>
			<p>Let's perform a DNS lookup on <code>redis</code> against <code>127.0.0.11</code> using the following command:</p>
			<pre>$ docker container exec moby-counter nslookup redis 127.0.0.11</pre>
			<p>This returns the <a id="_idIndexMarker318"/>IP address of the <code>redis</code> container:</p>
			<pre>    Server:    127.0.0.11
    Address 1: 127.0.0.11
    
    Name:      redis
    Address 1: 172.18.0.2 redis.moby-counter</pre>
			<p>Let's create a second network and launch another application container:</p>
			<pre>$ docker network create moby-counter2
$ docker run -itd --name moby-counter2 --network moby-counter2 -p 9090:80 russmckendrick/moby-counter</pre>
			<p>Now that we have the second application container up and running, let's try pinging the <code>redis</code> container from it:</p>
			<pre>$ docker container exec moby-counter2 ping -c 3 redis</pre>
			<p>In my case, I get the following error:</p>
			<div><div><img src="img/Figure_4.32_B15659.jpg" alt="Figure 4.32 – Isolating our applications in different networks&#13;&#10;" width="1650" height="332"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.32 – Isolating our applications in different networks</p>
			<p>Let's check the <code>resolv.conf</code> file to see whether the same <code>nameserver</code> is being used already, as follows:</p>
			<pre>$ docker container exec moby-counter2 cat /etc/resolv.conf</pre>
			<p>As you can see from the following output, the <code>nameserver</code> is indeed in use already:</p>
			<pre>    nameserver 127.0.0.11
    options ndots:0</pre>
			<p>As we have launched the <code>moby-counter2</code> container in a different network to that where the container<a id="_idIndexMarker319"/> named <code>redis</code> is running, we cannot resolve the hostname of the container:</p>
			<pre>$ docker container exec moby-counter2 nslookup redis 127.0.0.11</pre>
			<p> So, it returns a bad address error:</p>
			<pre>    Server:    127.0.0.11
    Address 1: 127.0.0.11
    nslookup: can't resolve 'redis': Name does not resolve</pre>
			<p>Let's look at launching a second Redis server in our second network. As we have already discussed, we cannot have two containers with the same name, so let's creatively name it <code>redis2</code>. As our application is configured to connect to a container that resolves to <code>redis</code>, does this mean we will have to make changes to our application container? No, Docker has you covered.</p>
			<p>While you cannot have two containers with the same name, as we have already discovered, our second network is running completely isolated from our first network, meaning that we can still use the DNS name of <code>redis</code>. To do this, we need to add the <code>-network-alias</code> flag as follows:</p>
			<pre>$ docker container run -d --name redis2 --network moby-counter2 --network-alias redis redis:alpine</pre>
			<p>As you can see, we have named the container <code>redis2</code>, but set <code>--network-alias</code> to be <code>redis</code>:</p>
			<pre>$ docker container exec moby-counter2 nslookup redis 127.0.0.1</pre>
			<p>This means that <a id="_idIndexMarker320"/>when we perform the lookup, we see the correct IP address returned:</p>
			<pre>Server:    127.0.0.1
Address 1: 127.0.0.1 localhost
Name:      redis
Address 1: 172.19.0.3 redis2.moby-counter2</pre>
			<p>As you can see, <code>redis</code> is actually an alias for <code>redis2.moby-counter2</code>, which then resolves to <code>172.19.0.3</code>.</p>
			<p>Now we should have two applications running side by side in their own isolated networks on your local Docker host, accessible at <code>http://localhost:8080/</code> and <code>http://localhost:9090/</code>. Running <code>docker network ls</code> will display all of the networks configured on your Docker host, including the default networks:</p>
			<div><div><img src="img/Figure_4.33_B15659.jpg" alt="Figure 4.33 – Listing our networks&#13;&#10;" width="948" height="368"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.33 – Listing our networks</p>
			<p>You can find out more information about the configuration of the networks by running the following <code>inspect</code> command:</p>
			<pre>$ docker network inspect moby-counter</pre>
			<p>Running the preceding command returns the following JSON array. It starts by giving us some general<a id="_idIndexMarker321"/> information on the network:</p>
			<pre>[
    {
        "Name": "moby-counter",
        "Id": "c9d98376f13ccd556d84b708e132350900036fb4 cfecf275dcbd8657dc69b22c",
        "Created": "2020-03-29T13:06:03.3911316Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,</pre>
			<p>Next up is the configuration used by the IP Address Management system. It shows the subnet range and gateway IP address:</p>
			<pre>        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },</pre>
			<p>What follows <a id="_idIndexMarker322"/>next is the remainder of the general configuration:</p>
			<pre>        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,</pre>
			<p>Then, we have details pertaining to the containers, which are attached to the network. This is where we can find the IP address and MAC address of each container:</p>
			<pre>        "Containers": {
            "e7335ca1830da66d4bdc2915a6a35e83e 546cbde63cd97ab48bfd3ca06ae99ae": {
                "Name": "moby-counter",
                "EndpointID": "fb405fac3e0814e3ab7f1b8e2c4 2bbfe09d751982c502ff196ac794e382bbb2a",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "f3b6a0d45f56fe2a0b54beb4b89d6094aaf 42598e11c3080ef0a21b78f0ec159": {
                "Name": "redis",
                "EndpointID": "817833e6bba40c73a3a349fae 53205b1c9e19d73f3a8d5e296729ed5876cf648",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },</pre>
			<p>Finally, we have <a id="_idIndexMarker323"/>the last bit of the configuration:</p>
			<pre>        "Options": {},
        "Labels": {}
    }
]</pre>
			<p>As you can see, it contains information on the network address being used in the IPAM section, along with details on each of the two containers running in the network.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><code>IPAM</code> has both <code>DNS</code> and <code>DHCP</code> services, so each service is notified of changes in the other. For example, <code>DHCP</code> assigns an address to <code>container2</code>. The <code>DNS</code> service is then updated to return the IP address assigned by <code>DHCP</code> whenever a lookup is made against <code>container2</code>.</p>
			<p>Before we progress to the next section, we should remove one of the applications and associated networks. To do this, run the following commands:</p>
			<pre>$ docker container stop moby-counter2 redis2
$ docker container prune
$ docker network prune</pre>
			<p>These will remove<a id="_idIndexMarker324"/> the containers and network, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.34_B15659.jpg" alt="Figure 4.34 – Removing unused networks with the prune command&#13;&#10;" width="1183" height="698"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.34 – Removing unused networks with the prune command</p>
			<p>As mentioned at the start of this section, this is only the default network driver, meaning that we are restricted to our networks being available only on a single Docker host. In later chapters, we will look at how we can expand our Docker network across multiple hosts<a id="_idIndexMarker325"/> and even providers.</p>
			<p>Now that we know the basics around Docker networking, let's take a look at how we can work with additional storage for our containers.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor150"/>Docker volumes</h2>
			<p>If you have been following<a id="_idIndexMarker326"/> along with the network example from the previous section, you should have two containers running, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.35_B15659.jpg" alt="Figure 4.35 – Listing the running containers&#13;&#10;" width="1650" height="344"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.35 – Listing the running containers</p>
			<p>When you go to the application in a browser (at <code>http://localhost:8080/</code>), you will probably see that there already are Docker logos on screen. Let's stop and then remove the Redis container and see what happens. To do this, run the following commands:</p>
			<pre>$ docker container stop redis
$ docker container rm redis</pre>
			<p>If you have your browser open, you may notice that the Docker icons have faded into the background and there is an animated loader in the center of the screen. This is basically to show that the application is waiting for the connection to the Redis container to be re-established:</p>
			<div><div><img src="img/Figure_4.36_B15659.jpg" alt="Figure 4.36 – The application can no longer connect to Redis&#13;&#10;" width="1302" height="447"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.36 – The application can no longer connect to Redis</p>
			<p>Relaunch the Redis container using the following command:</p>
			<pre>$ docker container run -d --name redis --network moby-counter redis:alpine</pre>
			<p>This restores connectivity. However, when you start to interact with the application, your previous icons disappear and you are left with a clean slate. Quickly add some more logos to the <a id="_idIndexMarker327"/>screen, this time placed in a different pattern, as I have done here:</p>
			<div><div><img src="img/Figure_4.37_B15659.jpg" alt="Figure 4.37 – Adding more logos&#13;&#10;" width="1047" height="362"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.37 – Adding more logos</p>
			<p>Once you have a pattern, let's remove the Redis container again by running the following commands:</p>
			<pre>$ docker container stop redis
$ docker container rm redis</pre>
			<p>As we discussed earlier in the chapter, losing the data in the container is to be expected. However, as we used the official Redis image, we haven't, in fact, lost any of our data.</p>
			<p>The Dockerfile for the <a id="_idIndexMarker328"/>official Redis image that we used looks like the following:</p>
			<pre>FROM alpine:3.11
RUN addgroup -S -g 1000 redis &amp;&amp; adduser -S -G redis -u 999 redis
RUN apk add --no-cache \
		'su-exec&gt;=0.2' \
		tzdata
ENV REDIS_VERSION 5.0.8
ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-5.0.8.tar.gz
ENV REDIS_DOWNLOAD_SHA f3c7eac42f433326a8d981b50dba0169 fdfaf46abb23fcda2f933a7552ee4ed7</pre>
			<p>The preceding steps prepare the container by adding a group and user, installing a few packages, and setting some environment variables. The following steps install the prerequisites needed to run Redis:</p>
			<pre>RUN set -eux; \
	\
	apk add --no-cache --virtual .build-deps \
		coreutils \
		gcc \
		linux-headers \
		make \
		musl-dev \
		openssl-dev \
	; \
	\</pre>
			<p>Now, the Redis source code is downloaded and copied to the right place on the image:</p>
			<pre>	wget -O redis.tar.gz "$REDIS_DOWNLOAD_URL"; \
	echo "$REDIS_DOWNLOAD_SHA *redis.tar.gz" | sha256sum -c -; \
	mkdir -p /usr/src/redis; \
	tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1; \
	rm redis.tar.gz; \
	\</pre>
			<p>Now that the source<a id="_idIndexMarker329"/> for Redis is in the image, the configuration is applied:</p>
			<pre>	grep -q '^#define CONFIG_DEFAULT_PROTECTED_MODE 1$' /usr/src/redis/src/server.h; \
	sed -ri 's!^(#define CONFIG_DEFAULT_PROTECTED_MODE) 1$!\1 0!' /usr/src/redis/src/server.h; \
	grep -q '^#define CONFIG_DEFAULT_PROTECTED_MODE 0$' /usr/src/redis/src/server.h; \
	\</pre>
			<p>Now, Redis is compiled and tested:</p>
			<pre>	make -C /usr/src/redis -j "$(nproc)" all; \
	make -C /usr/src/redis install; \
	\
	serverMd5="$(md5sum /usr/local/bin/redis-server | cut -d' ' -f1)"; export serverMd5; \
	find /usr/local/bin/redis* -maxdepth 0 \
		-type f -not -name redis-server \
		-exec sh -eux -c ' \
			md5="$(md5sum "$1" | cut -d" " -f1)"; \
			test "$md5" = "$serverMd5"; \
		' -- '{}' ';' \
		-exec ln -svfT 'redis-server' '{}' ';' \
	; \
	\</pre>
			<p>The <code>build</code> directory is <a id="_idIndexMarker330"/>then removed and the packages that are no longer needed are removed:</p>
			<pre>	rm -r <a id="_idTextAnchor151"/>/<a id="_idTextAnchor152"/>usr/src/redis; \
	\
	runDeps="$( \
		scanelf --needed --nobanner --format '%n#p' --recursive /usr/local \
			| tr ',' '\n' \
			| sort -u \
			| awk 'system("[ -e /usr/local/lib/" $1 " ]") == 0 { next } { print "so:" $1 }' \
	)"; \
	apk add --no-network --virtual .redis-rundeps $runDeps; \
	apk del --no-network .build-deps; \
	\</pre>
			<p>Now that Redis is built and the packages and build artifacts tided up, a final test is run. If it fails here, the build will also fail:</p>
			<pre>	redis-cli --version; \
	redis-server --version</pre>
			<p>With everything <a id="_idIndexMarker331"/>installed, the final set of image configuration can take place:</p>
			<pre>RUN mkdir /data &amp;&amp; chown redis:redis /data
VOLUME /data
WORKDIR /data
COPY docker-entrypoint.sh /usr/local/bin/
ENTRYPOINT ["docker-entrypoint.sh"]
EXPOSE 6379
CMD ["redis-server"]</pre>
			<p>If you notice, during the last part of the file, there are the <code>VOLUME</code> and <code>WORKDIR</code> directives declared; this means that when our container was launched, Docker actually created a volume and then run <code>redis-server</code> from within the volume. We can see this by running the following command:</p>
			<pre>$ docker volume ls</pre>
			<p>This should show at least two volumes, as seen in the following screenshot:</p>
			<div><div><img src="img/Figure_4.38_B15659.jpg" alt="Figure 4.38 – Listing the volumes&#13;&#10;" width="1547" height="274"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.38 – Listing the volumes</p>
			<p>As you can see, the volume name is not very friendly at all. In fact, it is the unique ID of the volume. So how can we use the volume when we launch our Redis container? We know from the Dockerfile that the volume was mounted at <code>/data</code> within the container, so all we have to do is tell Docker which volume to use and where it should be mounted at runtime.</p>
			<p>To do this, run the following command, making sure you replace the volume ID with that of your own:</p>
			<pre>$ docker container run -d --name redis -v 45c4cb295fc831c085c49963a01f8e0f79534b9 f0190af89321efec97b9d051f:/data -network moby-counter redis:alpine</pre>
			<p>If your application page looks like it is still trying to reconnect to the Redis container once you have launched your Redis container, then you may need to refresh your browser. Failing that, restarting<a id="_idIndexMarker332"/> the application container by running <code>docker container restart moby-counter</code> and then refreshing your browser again should work.</p>
			<p>You can view the contents of the volume by running the following command to attach the container and list the files in <code>/data</code>:</p>
			<pre>$ docker container exec redis ls -lhat /data</pre>
			<p>This will return something that looks like the following:</p>
			<pre>    total 12K
    drwxr-xr-x    1 root     root        4.0K Mar 29 13:51 ..
    drwxr-xr-x    2 redis    redis       4.0K Mar 29 13:35 .
    -rw-r--r--    1 redis    redis        210 Mar 29 13:35 dump.rdb</pre>
			<p>You can also remove your running container and relaunch it, but this time using the ID of the second volume. As you can see from the application in your browser, the two different patterns you originally created are intact.</p>
			<p>Let's remove the <code>Redis</code> container again:</p>
			<pre>$ docker container stop redis
$ docker container rm redis</pre>
			<p>Finally, you can override the volume with your own. To create a volume, we need to use the <code>volume</code> command:</p>
			<pre>$ docker volume create redis_data</pre>
			<p>Once created, we will<a id="_idIndexMarker333"/> be able to use the <code>redis_data</code> volume to store our <code>Redis</code> by running the following command after removing the <code>redis</code> container, which is probably already running:</p>
			<pre>$ docker container run -d --name redis -v redis_data:/data --network moby-counter redis:alpine</pre>
			<p>We can then reuse the volume as needed. The following screen shows the volume being created, attached to a container that is then removed and finally reattached to a new container:</p>
			<div><div><img src="img/Figure_4.39_B15659.jpg" alt="Figure 4.39 – Creating a volume and attaching it to a container&#13;&#10;" width="1650" height="493"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.39 – Creating a volume and attaching it to a container</p>
			<p>Like the <code>network</code> command, we can view more information on the volume using the <code>inspect</code> command, as follows:</p>
			<pre>$ docker volume inspect redis_data</pre>
			<p>The preceding command will produce something like the following output:</p>
			<pre>[
    {
        "CreatedAt": "2020-03-29T14:01:05Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/redis_data/_data",
        "Name": "redis_data",
        "Options": {},
        "Scope": "local"
    }
]</pre>
			<p>You can see that <a id="_idIndexMarker334"/>there is not much to a volume when using the local driver. One interesting thing to note is that the path to where the data is stored on the Docker host machine is <code>/var/lib/docker/volumes/redis_data/_data</code>. If you are using Docker for Mac or Docker for Windows, then this path will be your Docker host virtual machine, and not your local machine, meaning that you do not have direct access to the data inside the volume.</p>
			<p>Don't worry though; we will be looking at Docker volumes and how you can interact with data in later chapters. Before we tidy up our containers, networks, and volume, if you are running Docker Desktop, then we should take a look at the Docker Desktop Dashboard.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor153"/>Docker Desktop Dashboard</h1>
			<p>If you are running either<a id="_idIndexMarker335"/> Docker for Mac or Docker for Windows, then there is an option within the main menu to open a dashboard that will display information on your running containers:</p>
			<div><div><img src="img/Figure_4.40_B15659.jpg" alt="Figure 4.40 – Opening the Docker Desktop Dashboard&#13;&#10;" width="1156" height="686"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.40 – Opening the Docker Desktop Dashboard</p>
			<p>Once open, you should see something like the following screen. As you can see, we have our <code>redis</code> and <code>moby-counter</code> containers listed:</p>
			<div><div><img src="img/Figure_4.41_B15659.jpg" alt="Figure 4.41 – Viewing the running containers&#13;&#10;" width="1169" height="567"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.41 – Viewing the running containers</p>
			<p>Selecting the <code>redis</code> container<a id="_idIndexMarker336"/> will take you to an overview screen that defaults to the <code>Logs</code> output:</p>
			<div><div><img src="img/Figure_4.42_B15659.jpg" alt="Figure 4.42 – Overview screen of the Logs output&#13;&#10;" width="1650" height="905"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.42 – Overview screen of the Logs output</p>
			<p>Let's start at the top<a id="_idIndexMarker337"/> of the screen. To the right here, you can see four blue icons; these are as follows, from left to right:</p>
			<ul>
				<li><strong class="bold">Connect to container</strong>: This will open your default Terminal application and connect to the currently selected container.</li>
				<li><strong class="bold">Stop the currently connected container</strong>: When stopped, the icon will change to a <strong class="bold">Start</strong> icon.</li>
				<li>Next, we have the <strong class="bold">Restart icon</strong>. Clicking this will, well you guessed it right?! It will restart the currently selected container.</li>
				<li>The final <strong class="bold">Trash icon</strong> will terminate the currently selected container.</li>
			</ul>
			<p>Next, we have the menu items on the left-hand side of the screen. We have already seen the <strong class="bold">Logs</strong> output; this is updated in real time and you also have the option of searching through the log output. Below that we have <strong class="bold">Inspect</strong>; this displays some basic information about the<a id="_idIndexMarker338"/> container:</p>
			<div><div><img src="img/Figure_4.43_B15659.jpg" alt="Figure 4.43 – Getting information on the container using inspect&#13;&#10;" width="1535" height="984"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.43 – Getting information on the container using inspect</p>
			<p>The final item is <code>Stats</code>; this – as you may have already figured out, gives us the same output as the <code>docker container stats redis</code> command:</p>
			<div><div><img src="img/Figure_4.44_B15659.jpg" alt="Figure 4.44 – Viewing the real-time stats&#13;&#10;" width="1152" height="631"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.44 – Viewing the real-time stats</p>
			<p>Going to the <code>moby-counter</code> container <a id="_idIndexMarker339"/>adds an additional icon to the start of the top menu:</p>
			<div><div><img src="img/Figure_4.45_B15659.jpg" alt="Figure 4.45 – Viewing the additional icon&#13;&#10;" width="1519" height="775"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.45 – Viewing the additional icon</p>
			<p>This will open your<a id="_idIndexMarker340"/> default browser and take you to the externally exposed port, which in this case is <a href="http://localhost:8080">http://localhost:8080</a>.</p>
			<p>You have noticed that there are some features, such as the ability to create containers, in the dashboard. However, as new versions are released, I am sure that more management features will be added.</p>
			<p>Now, we should tidy up. First of all, remove the two containers and network:</p>
			<pre>$ docker container stop redis moby-counter
$ docker container prune
$ docker network prune</pre>
			<p>Then, we can remove the volumes by running the following command:</p>
			<pre>$ docker volume prune</pre>
			<p>You should see something similar to the following Terminal output:</p>
			<div><div><img src="img/Figure_4.46_B15659.jpg" alt="Figure 4.46 – Removing everything we have launched&#13;&#10;" width="1574" height="1159"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.46 – Removing everything we have launched</p>
			<p>We are now back to<a id="_idIndexMarker341"/> having a clean slate, so we can progress to the next chapter.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor154"/>Summary</h1>
			<p>In this chapter, we looked at how you can use the Docker command-line client to both manage individual containers and launch multi-container applications in their own isolated Docker networks. We also discussed how we can persist data on the filesystem using Docker volumes. So far, in this and previous chapters, we have covered in detail the majority of the available commands that we will use in the following sections:</p>
			<pre>$ docker container [command]
$ docker network [command]
$ docker volume [command]
$ docker image [command]</pre>
			<p>Now that we have covered the four main areas of using Docker locally, we can start to look at how to create more complex applications. In the next chapter, we will take a look at another core Docker tool, called <strong class="bold">Docker Compose</strong>.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor155"/>Questions</h1>
			<ol>
				<li>Which flag do you have to append to <code>docker container ls</code> to view all the containers, both running and stopped?</li>
				<li>True or false: the <code>-p 8080:80</code> flag will map port <code>80</code> on the container to port <code>8080</code> on the host.</li>
				<li>Explain the difference between what happens when you use <em class="italic">Ctrl + C</em> to exit a container you have attached, compared to using the <code>attach</code> command with <code>--sig-proxy=false</code>.</li>
				<li>True or false: The <code>exec</code> command attaches you to the running process.</li>
				<li>Which flag would you use to add an alias to a container so that it responds to DNS requests, when you already have a container running with the same DNS name in another network?</li>
				<li>Which command would you use to find out details on a Docker volume?</li>
			</ol>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor156"/>Further reading</h1>
			<p>You can find out more about some of the topics we have discussed in this chapter at the following links:</p>
			<ul>
				<li>The names generator code: <a href="https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go">https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go</a> </li>
				<li>The <code>cgroups</code> freezer function: <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx">https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.tx</a>t</li>
				<li>Redis: <a href="https://redis.io/">https://redis.io/</a></li>
			</ul>
		</div>
	</div>



  </body></html>