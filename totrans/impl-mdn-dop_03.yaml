- en: Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: For many years, the contact point between development and operations has been
    always a source of problems when deploying a new version of an application to
    production. Different languages generate different types of artifacts (war or
    JAR for Java, the source code for Node.js.), which led to heterogeneity in the
    procedures when rolling out new versions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，开发和运维之间的接触点一直是将新版本应用程序部署到生产环境时的一个问题源。不同的编程语言生成不同类型的制品（Java的war或JAR，Node.js的源代码），这导致了在推出新版本时程序的异构性。
- en: This heterogeneity led into bespoke solutions to roll out versions, which are
    pretty much sorceries with weird habits, such as deploying at 4 a.m. to avoid
    an outage in the system and creating error-prone bash scripts that are harder
    to maintain than the software itself. The problem, aside from the complexity,
    is that new hires need to ramp up into your systems, and this always introduces
    a level of risk that we are not aware of for the majority of the time until something
    goes very wrong.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异构性导致了定制化的版本发布解决方案，这些解决方案往往像是巫术，带有奇怪的习惯，例如凌晨4点发布以避免系统中断，或创建容易出错的bash脚本，这些脚本比软件本身更难维护。问题除了复杂性外，还在于新员工需要适应你的系统，这总是引入我们大多数时候未意识到的风险，直到某些事情出错。
- en: '**Docker** came to the rescue. With Docker, we can generate a deployable artifact,
    which is not only the software that you built but also its runtime. If you are
    deploying a Java application, with Docker, you will bundle the application plus
    the version of Java that is going to be running your application.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker** 来拯救我们。有了Docker，我们可以生成一个可部署的制品，这不仅仅是你构建的软件，还有它的运行时。如果你要部署一个Java应用程序，通过Docker，你将打包应用程序和将要运行你的应用程序的Java版本。'
- en: 'This sounds like a dream: a controlled environment that gets promoted as an
    artifact from development to QA and later production (sometimes stopping in preproduction
    for a sanity check) that is repeatable and the only thing that changes across
    environments is the configuration, usually injected via environment variables.
    It is not a dream; it is the reality in 2017, and in this chapter, we are going
    to accelerate from 0 to the speed of light on when it comes to running containers
    in Docker and building images.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是一个梦想：一个受控环境，从开发到QA，再到生产（有时会在预生产环境进行检查）作为一个制品被推广，这个过程是可重复的，唯一在不同环境间变化的是配置，通常是通过环境变量注入的。这不是梦想；这是2017年的现实，在本章中，我们将快速学习如何在Docker中运行容器并构建镜像，速度快得如同光速。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: The Docker architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker架构
- en: The Docker client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端
- en: Building `docker images`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`docker images`
- en: Docker registries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册中心
- en: Volumes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷（Volumes）
- en: Docker networking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网络
- en: Docker Compose
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: 'We will also stop at `docker-compose`, a tool used to run several containers
    in combination, so we can compose our system in the development machine, simulating
    our production configuration or, at the very least, approaching the interconnection
    of components, but before that, we are going to also dive deep into Docker networking:
    how can we choose the most appropriate networking for our system and what are
    the main differences between the different networks that Docker offers?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍`docker-compose`，这是一个用于组合多个容器的工具，这样我们就可以在开发机器上组成我们的系统，模拟生产配置，或者至少接近组件间的连接，但在此之前，我们还将深入探讨Docker网络：我们如何选择最合适的网络来支持我们的系统，以及Docker提供的不同网络之间的主要区别是什么？
- en: 'Another interesting feature of Docker is how the images get built: basically,
    we choose a base image (we will look at how to build one), and with a reduced
    set of commands, we can build a Docker file which is basically a script that instructs
    Docker on how to build our image with the configuration that we need.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的另一个有趣特点是镜像的构建方式：基本上，我们选择一个基础镜像（我们将了解如何构建一个），然后通过一组精简的命令，我们可以构建一个Docker文件，这基本上是一个脚本，用于指导Docker根据我们需要的配置来构建我们的镜像。
- en: Docker architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker架构
- en: One of my preferred ways of learning is through experimentation. In order to
    explain the Docker architecture, we are going to show an example, but first, we
    need to install Docker itself. In this case, I am working with Mac, but at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/),
    you can find the distribution that suits your needs with a very clear set of instructions
    (usually a package that needs to be installed).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我学习的一种偏好方式是通过实验。为了说明 Docker 架构，我们将展示一个示例，但首先，我们需要安装 Docker 本身。在这个案例中，我正在使用 Mac，但在[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)上，你可以找到适合你需求的发行版，并且有一套非常清晰的安装说明（通常是需要安装的包）。
- en: 'Once you have installed Docker, run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 后，运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once it finishes, the output should be very similar to the following one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，输出应该和以下内容非常相似：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This message shows that your installation appears to be working correctly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息显示你的安装似乎工作正常。
- en: 'To generate this message, Docker took the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这条消息，Docker 执行了以下步骤：
- en: The Docker client contacted the Docker daemon.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 客户端联系了 Docker 守护进程。
- en: The Docker daemon pulled the `hello-world` image from the Docker Hub.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程从 Docker Hub 拉取了 `hello-world` 镜像。
- en: The Docker daemon created a new container from that image, which runs the executable
    that produces the output you are currently reading.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程从该镜像创建了一个新容器，运行生成当前输出的可执行文件。
- en: The Docker daemon streamed that output to the Docker client, which sent it to
    your Terminal.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程将输出流传输到 Docker 客户端，然后客户端将其发送到你的终端。
- en: 'To try something more ambitious, you can run an Ubuntu container with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试更具挑战性的操作，可以运行一个 Ubuntu 容器，命令如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Share images, automate workflows, and more with a free Docker ID at [https://cloud.docker.com/](https://cloud.docker.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用免费的 Docker ID，在[https://cloud.docker.com/](https://cloud.docker.com/)上分享镜像，自动化工作流，等等。
- en: 'For more examples and ideas, visit: [https://docs.docker.com/engine/userguide/](https://docs.docker.com/engine/userguide/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更多示例和想法，访问：[https://docs.docker.com/engine/userguide/](https://docs.docker.com/engine/userguide/)。
- en: As you can see, the `hello-world` image gives you some insights into what is
    going on when running the preceding command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`hello-world` 镜像向你展示了运行前面命令时发生的情况。
- en: 'Some new concepts have been introduced here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入了一些新概念：
- en: '**Docker Hub**: This is a central repository, which is public and private,
    where users can push images that they build locally. A Docker registry is used
    to carry the images across different stages of the deployment pipeline (or even
    between systems).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：这是一个中央仓库，既有公共也有私有部分，用户可以将本地构建的镜像推送到这里。Docker 镜像库用于在不同的部署阶段（甚至在不同系统之间）传输镜像。'
- en: '**Layer**: Docker images are composed of layers. A layer is basically an ordered
    filesystem difference. A Docker image is a stack of these layers leading into
    the final image. When you change a file in an existing image, a new layer is created,
    but the rest of the layers of the images are reused so we can save a lot (believe
    me, a lot) of space.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**：Docker 镜像由层组成。层基本上是有序的文件系统差异。Docker 镜像是这些层的堆叠，最终形成镜像。当你更改一个已有镜像中的文件时，会创建一个新层，但镜像的其余层会被复用，因此我们可以节省大量（相信我，真的是很多）空间。'
- en: '**Docker daemon**: Docker follows a client-server architecture. In this case,
    the Docker daemon is the server part that can be operated via a **Representational
    State Transfer** (**REST**) API.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 守护进程**：Docker 遵循客户端-服务器架构。在这种情况下，Docker 守护进程是服务器端，可以通过**表现状态转移**（**REST**）API
    进行操作。'
- en: '**Docker client**: Docker client is a **Command-Line Interface** (**CLI**)
    used to operate a Docker daemon. It might be a local daemon or a remote one.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 客户端**：Docker 客户端是一个**命令行接口**（**CLI**），用于操作 Docker 守护进程。它可以是本地的，也可以是远程的。'
- en: 'The last three concepts are the key for drafting the architecture of Docker.
    Take a look at the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个概念是草拟 Docker 架构的关键。请查看以下图示：
- en: '![](img/02249a9d-ef9a-4679-a2f1-ea2bc975c9e4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02249a9d-ef9a-4679-a2f1-ea2bc975c9e4.png)'
- en: The client/server architecture predominates the software. You might think that
    this is an overkill for a system such as Docker, but it actually gives you a lot
    of flexibility. For example, in the previous diagram, we can see how the Docker
    CLI (the client) is able to manage a local instance of the Docker daemon but is
    also able to talk to a remote daemon by setting an environment variable called
    `DOCKER_HOST`, in this case, to the value of `62.112.42.57`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器架构在软件中占主导地位。你可能认为这种架构对于像 Docker 这样的系统来说是过度设计，但它实际上为你提供了很多灵活性。例如，在前面的图示中，我们可以看到
    Docker CLI（客户端）如何管理本地的 Docker 守护进程实例，同时也能通过设置一个名为 `DOCKER_HOST` 的环境变量与远程守护进程通信，在此案例中，`DOCKER_HOST`
    的值为 `62.112.42.57`。
- en: One of the key points of Docker is that it completely leverages the virtualization
    to the Linux kernel, making it impossible to run (as of today) Docker on Windows
    or even Mac as it uses the capabilities of the Linux kernel. The solution to this
    is to create a virtual machine with Linux that runs the Docker daemon, and the
    CLI will talk to the virtual machine to run Docker commands.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的一个关键点是它完全利用了 Linux 内核的虚拟化，使得目前无法在 Windows 或 Mac 上运行 Docker（因为它使用了 Linux
    内核的能力）。解决方案是创建一个运行 Linux 的虚拟机来运行 Docker 守护进程，CLI 会与虚拟机通信来执行 Docker 命令。
- en: In Mac, for example, the old versions of Docker use a distribution called `Boot2Docker`
    that runs the Docker daemon, whereas the newer versions of Docker use something
    called **HyperKit**, which is a lightweight virtualization solution for Mac.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Mac 上，Docker 的旧版本使用名为 `Boot2Docker` 的分发版来运行 Docker 守护进程，而 Docker 的新版本则使用名为
    **HyperKit** 的轻量级虚拟化解决方案。
- en: Docker for Windows uses a different type of virtualization that is equivalent
    to the one in Mac so all the assumptions made for Mac are valid for Windows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker for Windows 使用一种与 Mac 上相同的虚拟化技术，因此对于 Mac 所做的所有假设也适用于 Windows。
- en: Docker internals
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 内部结构
- en: Up until now, we have seen how Docker works regarding the overall architecture,
    but what happens at the operating system level in the Docker daemon?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 Docker 在整体架构方面的工作原理，但 Docker 守护进程在操作系统层面上发生了什么呢？
- en: 'Roughly explained, Docker provides you with only a runtime for your applications:
    you can limit the number of cores and the amount of memory to be used by the container,
    but at the end of the day, the kernel running your container is going to be the
    same as the kernel running your host machine.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，Docker 为你的应用程序提供了一个运行时环境：你可以限制容器使用的核心数量和内存量，但归根结底，运行容器的内核和运行宿主机的内核是一样的。
- en: 'The proof of that is in the way Docker organizes images: it calculates filesystem
    differences and packs them in layers that can be reused. Let''s pull a fairly
    big image (not the hello-world from the preceding example):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 证明这一点的是 Docker 组织镜像的方式：它计算文件系统的差异，并将其打包成可以重用的层。我们来拉取一个相当大的镜像（不是前面示例中的 hello-world）：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will produce the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, Docker has pulled five layers, which basically tells us that
    the Ubuntu image was built in five steps (not quite true, but it is a good approach).
    Now we are going to run an instance of Ubuntu. In Docker, an instance of an image
    is what we call a container, and the main difference between an image and a container
    is the top writable layer (layers in Docker are stacked in the read-only mode
    to compose the image, such as the diffs in several patch files). Let''s demonstrate
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Docker 已经拉取了五个层次，这基本上告诉我们 Ubuntu 镜像是通过五个步骤构建的（虽然不完全正确，但这是一个很好的方式）。现在，我们将运行一个
    Ubuntu 实例。在 Docker 中，镜像的一个实例就是我们所说的容器，镜像和容器之间的主要区别是顶部的可写层（在 Docker 中，层是以只读模式堆叠起来组成镜像的，就像几个补丁文件中的差异）。让我们来演示一下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command runs `/bin/bash` in an instance of the Ubuntu image.
    The `i` and `t` flags allow you to use the container as if it were a virtual machine
    allocating a virtual TTY (`t` flag) and creating the interactive session (`i`
    flag). Now, you can see how your prompt has changed to something like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在 Ubuntu 镜像的实例中运行 `/bin/bash`。`i` 和 `t` 标志让你像使用虚拟机一样使用容器，分配一个虚拟终端（`t` 标志）并创建交互式会话（`i`
    标志）。现在，你可以看到你的提示符已经变成了如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It does not necessarily have to be the same, but it should be similar. Note
    that your prompt is now a root prompt, but don't get too excited; it is just inside
    the container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它不一定完全相同，但应该相似。请注意，你的提示符现在是一个 root 提示符，但不要太兴奋；它仅仅是在容器内。
- en: 'Create a file to alter the filesystem:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件来更改文件系统：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you can disconnect from the container with the `exit` command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用`exit`命令断开与容器的连接。
- en: 'As you can see, the prompt is back to your system prompt, and if you run `docker
    ps`, you can see that there are no running containers, but if you run `docker
    ps -a` (show all the containers, not just the running ones), you should see something
    similar to this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，提示符已返回到您的系统提示符，如果您运行`docker ps`，您会看到没有正在运行的容器，但是如果您运行`docker ps -a`（显示所有容器，而不仅仅是正在运行的容器），您应该看到类似以下内容：
- en: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
- en: 'This is a container that has been created from an image but is not running
    anymore. As we said earlier, the only difference between this container and the
    image is the top writable layer. In order to prove this, we are going to create
    a new image out of the container that we ran a few minutes ago:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个已从镜像创建但不再运行的容器。正如我们之前所说，此容器与镜像之间唯一的区别是顶层可写层。为了证明这一点，我们将从几分钟前运行的容器中创建一个新的镜像：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, I am using the reference `329b`. because it is the one shown
    in the preceding image (the output of `docker ps -a`), but you need to change
    the hash to the one shown in your output. In fairness, you don''t need to type
    it all; just few characters will do the job. If everything went well, the command
    should output a `SHA256` checksum and return the control to you. Now run `docker`
    images (to list the images in your Docker) and the output should be similar to
    the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我正在使用引用`329b`。因为它是前面图片（`docker ps -a`的输出）中显示的，但您需要将哈希更改为您的输出中显示的哈希。公平地说，您不需要全部输入，只需几个字符即可完成任务。如果一切顺利，该命令应输出一个`SHA256`校验和，并将控制权返回给您。现在运行`docker
    images`（列出Docker中的镜像），输出应类似于以下内容：
- en: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
- en: As you can see, there is a new image called `my-ubuntu` that we just created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这里有一个名为`my-ubuntu`的新镜像，我们刚刚创建。
- en: Now we want to check the difference between the `ubuntu` image and the `my-ubuntu`
    image. In order to do that, we need to inspect the layers for each image and see
    the difference. The command we are going to use to accomplish this task is `docker
    history`, with the name of the image as the third parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要检查`ubuntu`镜像和`my-ubuntu`镜像之间的差异。为了做到这一点，我们需要检查每个镜像的层并查看差异。我们要使用的命令是`docker
    history`，并将镜像名称作为第三个参数。
- en: 'First, for the `ubuntu` image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于`ubuntu`镜像：
- en: '![](img/b70edb84-d97b-41f8-af1d-9a670f12f85c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70edb84-d97b-41f8-af1d-9a670f12f85c.png)'
- en: 'Then for `my-ubuntu`: image (just created from `ubuntu`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对于`my-ubuntu`：镜像（刚从`ubuntu`创建）：
- en: '![](img/a5668bcc-dbb3-4aef-a354-7d165e8f7a8a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5668bcc-dbb3-4aef-a354-7d165e8f7a8a.png)'
- en: 'Quite illuminating. The image `my-ubuntu` ;is the same image as `ubuntu` except
    for the top writable layer that we just created by logging in to the machine and
    creating a file. This is very smart because even though both of the two images
    use around 130 MB of space, the only extra space used for the second image is
    the top layer that, in this case, uses only 5 bytes, leading to a usage of 130
    MB and 5 bytes for the two images. This also has a side-effect in line with what
    we talked earlier: a container is the exact same thing as an image but with a
    different top writable layer, so running an instance of the container uses only
    5 bytes of space. As you can see, the engineers that created Docker thought about
    everything!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有启发性。镜像`my-ubuntu`与`ubuntu`完全相同，只是顶层可写层我们刚刚通过登录到机器并创建文件创建的。这非常聪明，因为尽管这两个镜像都使用大约130
    MB的空间，但第二个镜像额外使用的空间只是在本例中使用的顶层，仅为5字节，导致这两个镜像使用的是130 MB和5字节的空间。这也产生了我们之前讨论过的副作用：容器与镜像完全相同，只是顶层可写层不同，因此运行容器的实例只使用5字节的空间。正如您所看到的，创建Docker的工程师考虑到了一切！
- en: 'The way in which how Docker stores the images in the hard drive is the responsibility
    of the storage driver: Docker can make use of different drivers and store the
    images in different ways (and places, such as S3 in AWS), but the most common
    use case, the default driver, stores the images on the hard drive, creating one
    file per layer with the checksum of the layer as the name of the file.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docker如何将镜像存储在硬盘上的方式是存储驱动程序的责任：Docker可以使用不同的驱动程序以不同的方式（以及位置，例如AWS中的S3）存储镜像，但是最常见的用例，即默认驱动程序，将镜像存储在硬盘上，并为每个层创建一个文件，文件名为层的校验和。
- en: Docker client
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker客户端
- en: We have made use of the Docker client already in the previous section, but we
    need to go a bit deeper into the options that the Docker CLI can offer. My favorite
    way of learning is through experimentation, and what we are going to be doing
    through this section is building concepts from top to bottom (more decomposing,
    than building), so I advise you to read the full section in the order without
    skipping parts, as the latter examples will be based on the previous ones.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中已经使用了 Docker 客户端，但我们需要深入了解 Docker CLI 可以提供的选项。我最喜欢的学习方式是通过实验，而我们将在这一节中从上到下建立概念（更多是拆解，而非构建），所以我建议你按顺序完整阅读这一节，不要跳过任何部分，因为后面的示例将会基于前面的内容。
- en: 'If you have dug into Docker a bit before, you can see that the commands are
    **quite** verbose and not as intuitive as you might think. The most common use
    case is the following combination:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前稍微了解过 Docker，你会发现这些命令**非常**冗长，并不像你想象的那么直观。最常见的用例是以下组合：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command basically does one simple thing: it runs a container in the interactive
    mode and allocates `pseudo-tty`. This allows us to interact with the container
    executing the commands (not on every image, but it is true for all the base images
    of Linux distributions). Let''s see what that means:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令基本上做了一件简单的事：它以交互模式运行一个容器并分配`伪终端`。这使得我们能够与容器交互并执行命令（并非每个镜像都适用，但对于所有 Linux
    发行版的基础镜像来说是成立的）。让我们看看这意味着什么：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should return a prompt similar to the following one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会返回一个类似于以下的提示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What just happened? The prompt changed to root with a strange number in the
    host section. We are in the container. Basically, now we can run commands that
    are going to be run within the container. To exit the container, just type exit
    and the control should be returned in the terminal to your host machine, leaving
    the container running in the background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？提示符变成了 root，并且主机部分有一个奇怪的数字。我们现在在容器内。基本上，现在我们可以运行将在容器内执行的命令。要退出容器，只需键入`exit`，控制权将返回到主机的终端，容器会继续在后台运行。
- en: 'The majority of the time, the preceding command suits our needs, but sometimes,
    we want to run the container in the background: imagine that you spin up a Jenkins
    server and you don''t want to have your Terminal attached to it. In order to do
    that, we just need to add the `-d` option (daemon) and drop `-i` and `-t`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，前面的命令就能满足我们的需求，但有时我们希望将容器运行在后台：假设你启动了一个 Jenkins 服务器，并且不想让终端一直挂在它上面。为了做到这一点，我们只需要添加`-d`选项（守护进程模式），并去掉`-i`和`-t`选项：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the image is pulled and it starts running, the control is returned to
    your Terminal. The last line in the output, and it should be a long string of
    characters similar to the following one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像被拉取并开始运行，控制权就会返回到你的终端。输出的最后一行应该是类似下面的一串长字符：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the hash of the running container. If you execute `docker ps` , the
    following output (similar) will be produced:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正在运行的容器的哈希值。如果你执行`docker ps`，将会产生类似的输出：
- en: '![](img/f06a6c21-8fd5-4617-ac26-01ff8b807043.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f06a6c21-8fd5-4617-ac26-01ff8b807043.png)'
- en: Note that the value under `CONTAINER ID` in the screenshot matches the first
    few digits of the hash from the preceding command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，截图中`CONTAINER ID`下的值与前一个命令的哈希值的前几位数字相匹配。
- en: Now in theory, we have a running instance of Jenkins that, as you can see in
    the preceding image, is listening on port `8080` and port `50000`. Let's try to
    browse `http://localhost:8080` with an internet browser. Nothing. Basically, our
    browser cannot open that URL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们已经运行了一个 Jenkins 实例，如前面的图片所示，它正在监听端口`8080`和端口`50000`。让我们尝试用浏览器访问`http://localhost:8080`。没有反应。基本上，我们的浏览器无法打开该
    URL。
- en: This is because we haven't told to Docker to bind the container ports to the
    local ports of the host machine. In order to do that, we need to first stop the
    container and then start it again with a special parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有告诉 Docker 将容器端口绑定到主机机器的本地端口。为了做到这一点，我们需要先停止容器，然后带上一个特殊的参数重新启动它。
- en: 'Time to learn how to stop containers. We have two options here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何停止容器了。我们这里有两个选项：
- en: '**Stop the container**: With the stop option, we send `SIGTERM` to the main
    process within the container and wait for it to finish (for a grace period). Then,
    we send `SIGKILL`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止容器**：通过停止选项，我们向容器中的主进程发送`SIGTERM`信号，并等待它完成（有一个宽限期）。然后，我们发送`SIGKILL`信号。'
- en: '**Kill the container**: With the kill option, we send `SIGKILL` to the main
    process in the container, which forces an immediate exit without being able to
    save the state.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, which one you choose is irrelevant, but please be careful. When
    you are running in a production environment, make sure it''s fine to kill a container
    before doing that, as with the stop option, we are giving the running software
    the option to save the current transactions and exit gracefully. In this case,
    I am going to kill the container:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Docker is smart. I did not need to specify the full container identifier, as
    with only a few characters, Docker is able to identify the container (or the image
    in other commands) and kill it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from previous examples, when we kill a container, we have a
    layer left that leads into a `dead` container that we can explore, adding the
    `-a` option to the `docker ps` command. For this example, we are going to remove
    this layer as well with the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. The container never existed in our host.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, going back to the Jenkins example, we want to run Jenkins in a way that
    we can access the running instance from our browser. Let''s modify the preceding
    command and explain why:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After a few seconds, if we go to `http://localhost:8080` in a browser, we should
    see the initial configuration for Jenkins, which asks for the initial password
    to be able to proceed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain the previous command first. We can see a new option: `-p`. As
    you can guess, `-p` comes from the port. In fairness, you could change `-p` for
    `--port`, and everything will work as expected. With the `-p` option, we map ports
    from the host, your machine, to the container. In this case, we are mapping port
    `8080` from the host to port `8080` and port `50000` of the host to port `50000`
    of the container, but how can we map a different port in the host? Well, it is
    fairly simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After running the preceding command, we have two instances of Jenkins running:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The first one is exposed in port `8080` of your machine
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is exposed in port `80801` of your machine
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that even though we don't use port `50000`, I have changed it to `50001`
    as your machine's port `50000` is already busy with the first instance of Jenkins
    that we ran earlier on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Jenkins is asking for a password, and the initial web page
    in `http://localhost:8080` states that this password is in the logs or in the
    filesystem. Focusing on the logs, with Docker, we can fetch the logs for any container
    registered by the daemon at any time. Let''s try this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In my case, the running instance of Jenkins on port `80801` has an ID that starts
    with `11872`. Executing the previous command should retrieve the starting log
    of Jenkins that we can use for troubleshooting or, in this case, to recover the
    password to initialize Jenkins.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting and common option in Docker is passing environment variables
    to an application running inside the container. If you think about it, there are
    only three ways in which we can configure an application within a Docker container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中另一个有趣且常见的选项是将环境变量传递给容器内运行的应用程序。如果你仔细想想，配置 Docker 容器内的应用程序只有三种方式：
- en: Environment variables
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: A volume with data
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含数据的卷
- en: Fetching the configuration from the network
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络获取配置
- en: 'Let''s take a look at the official MySQL image from the Docker Hub:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下来自 Docker Hub 的官方 MySQL 镜像：
- en: '[https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)'
- en: 'MySQL is a popular database server that has also been `dockerized`. If you
    read a bit through the documentation, one of the config options is the root password
    for the MySQL database. In fairness, the quick start example points to the right
    direction:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个流行的数据库服务器，它也已经被 `dockerized`（容器化）。如果你稍微浏览一下文档，你会发现其中的一个配置选项是 MySQL
    数据库的 root 密码。公平地说，快速入门示例指向了正确的方向：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The new option here is **`-e`**. This option allows you to pass an environment
    variable to the container with the value that you want to specify after `=`. After
    running the preceding command, we are going to run another command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新选项是 **`-e`**。这个选项允许你将环境变量传递给容器，并指定你希望设置的值，格式为 `=` 后跟值。运行完前面的命令后，我们将执行另一个命令：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, `caa40cc7d45f` is the ID that results from running MySQL on my
    machine (yours should be different). There should be a huge JSON output in the
    terminal, but one section in particular, Config, has a subsection called `Env`
    , which should look very similar to the following one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`caa40cc7d45f` 是在我的机器上运行 MySQL 时得到的 ID（你可能会得到不同的 ID）。终端中应该会输出一个巨大的 JSON，但其中有一个特别的部分，Config，里面有一个子部分叫做
    `Env`，它应该与以下内容非常相似：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There it is. The preceding environment variable that we passed, `MYSQL_ROOT_PASSWORD`,
    is now accessible from within the container as the environment variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们之前传递的环境变量 `MYSQL_ROOT_PASSWORD` 现在可以作为环境变量在容器内访问。
- en: 'In the `docker inspect` command, there is a lot of very valuable information.
    Just have a read through, as you might be surprised with how familiar you are
    with the majority of the info: it is mainly Linux terminology.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker inspect` 命令中，有很多非常有价值的信息。只要浏览一下，你可能会对其中的大部分信息感到熟悉：它主要是 Linux 术语。
- en: So far, we have visited the most common commands as of January 2017\. As you
    know, the software evolves very quickly, and by the time you are reading this
    book, new versions (such as secrets) have already been added to Docker. The best
    way to check what is going on is through the documentation on [http://www.docker.com](http://www.docker.com),
    which, in my opinion, is quite comprehensive. There is also a reference of the
    commands of your current Docker installation available under the `docker help`
    command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经浏览了截至 2017 年 1 月最常见的命令。如你所知，软件的发展非常迅速，到你阅读这本书时，Docker 已经加入了新的版本（比如
    secrets）。检查当前情况的最佳方式是通过 [http://www.docker.com](http://www.docker.com) 上的文档，在我看来，它相当全面。你当前
    Docker 安装的命令参考也可以通过 `docker help` 命令获得。
- en: Building Docker images
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'In the previous sections, we built an image using the commit command of Docker.
    Although it works, I can see a big problem with it: it is not repeatable. There
    is no easy way of rebuilding the image once and over again when the software installed
    in the image is patched due to new vulnerabilities or versions.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 Docker 的 commit 命令构建了一个镜像。虽然这方法可行，但我看到一个大问题：它不可重复。当镜像中的软件由于新漏洞或版本更新被修补时，没有一种简单的方法可以反复重建镜像。
- en: 'In order to solve this problem, Docker provides a better way of building images:
    Dockerfiles.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Docker 提供了一种更好的构建镜像的方式：Dockerfile。
- en: 'A Dockerfile is a file that contains a set of ordered commands required to
    leave the image, ready to be used. Things such as installing software or upgrading
    the version of the kernel as well as adding users are common activities that can
    be carried in a Dockerfile. Let''s look at an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个包含一组有序命令的文件，这些命令可以将镜像准备好以供使用。诸如安装软件、升级内核版本以及添加用户等常见操作都可以在 Dockerfile
    中进行。让我们来看一个例子：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you have been in the IT field for a few years, you really don''t need an
    explanation on what it is going on, but let''s make sure that we are all on the
    same page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We are creating our image based on the latest Node.js image.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new folder is created in `/app`. Our application will be installed there.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The working directory is set to this new folder.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy `package.json` and install the Node.js dependencies. Remember that we have
    already set up the working directory to `/app`, so the RUN command will be run
    in the `/app` folder.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the rest of the source code.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose port `8080` to the outer world.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `npm start`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is very simple once you have done it few times. One thing to keep in mind
    that might drive beginners crazy is this: `CMD` versus `RUN`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding Dockerfile, sometimes, we use `RUN`, and sometimes, we use
    `CMD`, but both of them seem to do the same thing: run a command. There is one
    difference:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN`: This will run the command when building the image'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`: This will run the command when the container based on the generated
    image starts'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, `RUN` (generally) creates a new layer, whereas `CMD` uses the writable
    layer of the container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to test the Dockerfile from earlier. Before building the image,
    we need to build a small Node.js application that is going to be used as the software
    running in the image. Create a new folder with three files:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.js`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile (the one from before)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The content of `package.json` will be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The content of `index.js` will be as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And now, with the preceding files and the Dockerfile described before in the
    same folder, run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After a few seconds, your image would be ready for use. Let''s check it. If
    you list your images with the `docker images` command, you should see an image
    called `my-node-app`. Now create a container based on the image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see something similar to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the highlighted section, the output of running our application
    is here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile reference
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in the previous section, Dockerfiles are very simple, and if
    you have any queries, the official documentation for the Dockerfile language is
    very comprehensive.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In general, the language used for creating Dockerfiles is very similar to the
    batch processing language of windows (`.bat` files) from a few years ago.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the most used commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '| `FROM` | This instruction is used to specify the base image. Every single
    Docker image is created starting from a base image (you can create base images
    from a running Linux distribution). |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `COPY` | As you can guess, `COPY` allows you to copy files and folders inside
    the image. For example, we could copy our application, a war file, or any other
    artifact that will be packed with the image once it is distributed. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `ADD` | This does the exactly the same thing as `COPY` but with three differences:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The origin of the files could be a URL that gets downloaded before copying
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origin of the files could be a packed file (such as a TAR file) that will
    be unpacked in the image filesystem
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '| `RUN` | This runs a command in the image. For example, it can be used to
    install software in the image. It always creates a new layer in the Docker image,
    so be careful and keep the `RUN` commands to a minimum. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `CMD` | This is the default command to be run when the image gets instantiated
    as a container. As you can see in the preceding example, we are using `CMD` to
    execute `npm start`, which runs `node index.js` (refer to `package.json`). It
    does not create a new layer as it uses the top writable layer to store the changes.
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `ENTRYPOINT` | `ENTRYPOINT` is similar to `CMD`, but it overrides the default
    command on a docker image that is `/bin/sh -c`. In order to override an specified
    entry point, you need to pass the `--entrypoint` flag when running an instance
    of the image. `ENTRYPOINT` is ideal for configuring containers as command-line
    tools, as you can pack a fairly complex command with a fairly complex setup in
    a single container. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `MAINTAINER` | With `MAINTAINER`, you can specify who is the maintainer of
    the image (also specify the email). |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE` | This exposes the port specified in the first parameter so that
    the container can listen to it. It actually does not expose the port in the `docker`
    client host, forcing the user to pass the `-p` flag in order to access the given
    port. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: With these commands, you can build pretty much anything that you want, and particularly
    with `RUN`, this allows the user to run any command within the container that
    enables us to run scripts (`python`, `bash`, and `ruby`.) or even install software
    using package managers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the preceding instructions, the Dockerfile language also comes with
    support for adding environment variables, volumes, and a few other features that
    make it quite powerful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Docker registries
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a new image with our application installed
    and ready to be used (in this case, a very simple `Hello world` Node.js application).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to distribute the image so it can be installed in all the stages
    of our deployment pipeline or even used by other developers. Docker is interesting
    for running applications but it is also a very interesting choice to create command-line
    tools that other developers can benefit from.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to distribute images, we have to rely on exporting/importing the image
    or using a registry. A registry is basically a software that allows us to store
    and distribute Docker images. There are two types of registries:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Public registries
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private registries
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the different registry types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Public registries
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most known of the public registries is Docker Hub. It is the official and
    default registry that every Docker installation knows of. Also, it offers private
    repositories, but the most interesting feature is the fact that all the official
    images are available on Docker Hub.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how can we use it. First, you need to create an account. Once you
    are registered, create a new repository:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e20dfccf-d186-422b-b4bc-f5a6c8e20a53.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'This repository hosts an image called `modern-devops`, and we are going to
    push one image into it. Once it is created, you can see that Docker Hub suggests
    that you pull the image with the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In your case, `dagonzadub` will need to be replaced with your username. Obviously,
    we are not going to pull an image that is not there yet, so let''s push an image.
    In the previous section, we created an image called `my-node-app`. We are going
    to use this image to test Docker Hub. Docker relies on a tag system to know where
    to push the image or where to pull from. As we are working with the `default`
    registry, we don''t need to specify the URL, but we need to specify the user and
    the repository name. If you haven''t deleted the image created in the previous
    section, run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then, run this command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After a few seconds (depending on your upload speed, even minutes), your image
    is available on Docker Hub. As we marked it as `public`, everybody can pull and
    use your image.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Private registries
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what happens if we want to store our images in our private registry within
    our infrastructure?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Well, we have some options. If we are using cloud providers, such as Google
    Cloud Platform or Amazon Web Services, they provide a Docker registry that is
    only accessible from within your account, and you can specify the region in which
    your images live (remember, the type of data that we are handling might be under
    strict compliance rules about where we should store the data).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In AWS, the container registry is called **EC2 Container Registry** (**ECR**),
    and in GCP, it is called a container registry. If your infrastructure is in one
    of these private clouds, I encourage you to use it as you can leverage the access
    to the access controls provided by the platforms.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we might find ourselves in a situation where we cannot use a cloud
    provider as our system has to be built on premises. This is when we need to use
    a private on-premises Docker registry.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, there are quite a few options, but it is highly likely that the market
    widens in the coming months or years as the companies are using Docker more and
    more.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'From all the range of registries, there are three that I find particularly
    interesting:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Quay**: This is a complete registry in the current market (at the time of
    writing this). It has some interesting features, but the one that is probably
    the most interesting is the ability to scan the images searching for security
    vulnerabilities in the installed software. It can also build images based on changes
    in your git repository, so if your Dockerfile is altered in GitHub, Quay will
    automatically trigger a build and deploy the new version of the image. Quay is
    not free, so a license has to be paid in order to use it.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**Registry**: This is the plain name for a plain concept. It is the official
    implementation of the registry API and comes packed in a container. It has no
    interface or access controls by default, but it does the job. It also provides
    storage management drivers, so we can deploy our images to S3 or Google Cloud
    Storage buckets as well as many other options. Registry is free and can be pulled
    from Docker Hub.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Trusted Registry: This is part of the enterprise version of Docker.
    Like pretty much any other commercial registry, it provides static container analysis
    as well as storage management drivers. **Docker Trusted Registry** (**DTR**) is
    not free, so a license has to be paid for in order to use it.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to create images, how to store the images in a registry,
    and how Docker images work in general (layers and containers versus images).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: An important part of any application is the storage. In general, Docker applications
    should be stateless, but with the new orchestration software, such as Kubernetes,
    Docker Swarm, and similar, every day, more and more engineers are moving toward
    containerized databases.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker solves this problem in a very elegant way: you can mount a folder from
    the local machine into the container as if it were a normal folder.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful abstraction as it leverages the ability to push data
    out of the container to be saved into a **Network Attached Storage** (**NAS**)
    or any other storage technology (it is possible to use a bucket in the Google
    Cloud Storage or S3 as the volume mounted in a container).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basics. Just run a MySQL database:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works. It actually does what is expected: it launches a container with
    a mysql instance in it. The problem is that all the data is going to be written
    to **`/var/lib/mysql`** and this folder is mapped to the top writable layer of
    the container (remember, in the previous section, we explained the difference
    between a container and an image). The only way to save data is actually committing
    the changes and create a new image that is not manageable and, of course, this
    not the way you want to do it. Think about it: if you remove a file in Docker,
    you are doing it in the top layer, which is the only one writable, so in reality,
    you are not removing the file; you are just hiding it. The file is in one of the
    layers using the space but it is not visible. Docker records differences and a
    layer itself is a set of differences from the previous stacked layers (think about
    how Git works; it is the same principle).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of committing the changes into a new image, we are going to mount a
    folder from our docker host into the container. Let''s alter the previous command
    a bit:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we have a new flag, `-v`, followed by the `data:/var/lib/mysql` value.
    The meaning of the command is very simple: mount the `/home/david/data` folder
    into the `/var/lib/mysql` path of my container.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can guess, the data folder, in my case, `/home/david/data`, should be
    present in your current directory, so if it wasn''t present, create it or modify
    the path to suit your setup and launch the container. This use case can only be
    achieved through the `-v` flag: mount a selected folder from the host into the
    container.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute `ls` inside the data folder (in the Docker host):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see how `mysql` has actually written data files corresponding to the
    databases created in bootstrap.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes are not limited to one per container, so you can replicate the
    **`-v`** flag as many times as you need in order to match your requirements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of mounting a shared folder between the container and the host
    is just specifying the path inside the container:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command will mount a folder from our Docker host into the container, but
    the folder in the `docker` host will be managed by the storage driver and `docker`
    itself:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is familiar. We have seen it before in the previous sections, but
    now we are looking for different information. We are actually looking for a section
    called `Mounts`, which looks like this (at least similar to it):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is also possible through the `VOLUME` instruction in a Dockerfile.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding JSON is telling us which local folder is going to be mounted
    in the container (the `Source` value of the JSON) and provides an interesting
    insight: the volume has been named by `docker` (the `Name` value of the JSON).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that Docker tracks the volumes that are (or have been) mounted in
    any container and can be listed through an API call:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should produce output similar to the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can guess, we can also create volumes through an `api` call:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This volume is created in the same way as the previous example: it is up to
    Docker to decide which folder on the local machine is going to be mounted in the
    specified path in the container, but in this case, first, we are creating the
    volume and then mounting it to a container. You can even inspect the volume:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And this should return you something similar to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use this named resource and mount it into our containers, just referencing
    the name:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The last (but not least) interesting use case in volumes helps us share the
    configuration across different containers. Just imagine that you have a fairly
    complex setup that leads to a gigantic Docker command with several `-v`. Docker
    provides us with a much simpler way of sharing volume configuration across containers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is very simple and intuitive: `my-mysql-5` will spawn with the volume
    configuration of `my-mysql-4`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Networking is an important part of Docker. By default, Docker comes with three
    networks that we can inspect by executing the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This should produce output similar to the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d45651ef-61a5-4658-8040-8f9b1144dd2b.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explain the different networks:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`bridge`: This is the default network. It is an entirely different stack from
    the host machine with a different IP range in the `bridge` mode (the host machine
    acts as a `router` for the containers in this network). The containers created
    without specifying the network are attached to the default bridge network.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: In this network, containers share the network stack with the Docker
    host. If you inspect the configuration in the container, you will find that it
    is the exactly the same as in the Docker host.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: This is easy to guess; the container gets attached to no network: just
    the loopback interface in the container.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it is time to look at some examples. We are going to use `busybox`, which
    is the `swiss` army knife of the Docker images. It has several Unix tools that
    we could benefit from, but in this case, the characteristic that is going to benefit
    us is the fact that it is a functional Linux on a reduced space.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you have followed the previous sections, by now, you can understand the
    outcome: we gain root access to a running container.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to execute `ifconfig` inside the container. It should give
    us two interfaces:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`- eth0 - 172.17.0.2`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`- lo - 127.0.0.1`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The IP might change, but you should see these two interfaces. Comparing the
    IP with the IP in your Docker host, we can validate the fact that the container
    is running in the bridge network as the IP and network are completely different;
    in my case, the IP on my Docker host is `10.0.0.12`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s spawn another container with `busybox` in a different terminal:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By now, we should have two `busybox` instances running, and they should have
    consecutive IPs, in my case, `172.17.0.2` and `172.17.0.3`. If you go back to
    the terminal of the first instance of `busybox`, you can ping the second container
    by IP. This is because they both belong (or are connected to) the same network,
    which is the default bridge one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In order to run the containers in the host network, we just need to pass `--network=host
    flag` to the `docker run` command and that's it; our container is sharing the
    network stack with the Docker host, but be careful, if you are on Mac or Windows.
    The Docker host is a virtual machine so don't attempt to access it through localhost;
    you will need to find the IP of the virtual machine running `docker`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: User-defined networks
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also possible to create custom and isolated networks in Docker. This is
    interesting from the security point of view, as it enables us to segregate different
    containers on the network level so we can enforce a higher level of access control.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a network, we just need to execute the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And that's it. Well, that is a simplistic approach, but it works as expected.
    As you know, networking is a complicated subject, so Docker provides options to
    customize ranges, masks, and other parameters. The user-defined networks are of
    the type bridge.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the network is created, you can run new containers in that network, as
    follows (on a new terminal):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As expected, these containers will be isolated from the other networks. In this
    case, the two containers are launched in the `bridge` network. In my case, the
    third container (the one just launched) has the IP `172.19.0.2`, whereas the two
    launched in the bridge network are `172.17.0.2` and `172.17.0.3`. Issuing a ping
    command between containers in different networks results in 100% packet loss.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of the time, Docker is synonymous to microservices. Running a big
    monolithic application in Docker does not make too much sense as the whole Docker
    Engine is thought to be running big applications split into different and smaller
    services. There is no technical limitation to running a monolithic app on Docker,
    but when the orchestration software comes into place (in the following chapters),
    it really defeats the purpose of containerization.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with microservices, it is very common to have several services
    running at the same time when developing, as the new services will lean on the
    existing ones to execute operations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this setup, Docker facilitates a tool called `docker-compose`
    that, by creating a YAML file with the definition of our containers, can spawn
    a full ecosystem of containers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose used to be very popular in the beginning of Docker. Nowadays,
    it is still widely used, but its space has been slowly reduced to development
    stages as the container orchestration tools in Kubernetes have taken over the
    production space.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how Docker Compose works:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding YAML file is a `docker-compose` definition. As you can guess,
    there are two components:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: A web application (the current folder)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database (postgres)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the file to a folder with the name `docker-compose.yaml`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a typical case of an application connecting to a database. In order
    to simplify this, our application is just going to be a dummy application (no
    database connection) with the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And our Dockerfile is very simple:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This Dockerfile will install the required dependencies and run `npm start` in
    the root of our app folder.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the application is very simple, and it only tries to resolve
    the name `db` instead of connecting to the database (in fairness, we didn''t even
    specify the ports for connecting to it). We are going to demonstrate how `docker-compose`
    wires up the containers. By now, there should be four files in the work folder:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose.yaml`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going back to our `docker-compose` file, we can see that in the `my_app` definition,
    we ask to build the current folder (build the image described by the Dockerfile),
    and we specify that the container itself is dependent on another container called
    `db`. This makes Docker take action and connect the two containers, being able
    to reach `db` from `my-app` by name. In order to achieve this, there is an entry
    created in `/etc/hosts` with the IP of `db`, so we `my-app` will be able to resolve
    it. Docker compose is very easy to understand: it is nearly self-explanatory,
    and the fact that it makes use of YAML makes everything so much more readable.
    Now we need to run it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once it finishes, there should be a quite a long output, but there are some
    lines that indicate our success:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The highlighted section tells us that `my_app` is able to reach db by IP as
    they are on the same bridge network. Let''s see what happened here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Docker built the image for the current folder (as specified in `my_app`) from
    the Dockerfile
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker pulled the `postgres` image from the Docker Hub
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker started the images in order: first `db` and second `my_app`, as specified
    in the dependencies'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are going to give a special emphasis to orchestration technologies,
    and then we will come back to Docker Compose in [Chapter 5](820e2d41-3917-4d4c-ad80-461fc133740b.xhtml),
    *Infrastructure as Code,* where we will take a deep dive into Docker Swarm, which
    is where compose becomes really helpful.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through Docker from the internals to the command-line
    interface to operate a Docker host. Now, we have enough knowledge to understand
    the consequences and benefits of running Docker in production. We have not looked
    into how to develop Docker plugins as well as different storage drivers, as unfortunately,
    we have a limited amount of space in this book to introduce the most interesting
    concepts, but we have dived deep enough into Docker to be able to learn more from
    the resources (official documentation, videos, and so on) available to us on the
    Internet.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will have a look on how to automate tasks around our
    software: running tests, building images and many other tasks that shouldn''t
    be done manually. This automation is called **continuous integration** because
    allows our team to integrate new features on a seamless way.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
