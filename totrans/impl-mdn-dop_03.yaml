- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, the contact point between development and operations has been
    always a source of problems when deploying a new version of an application to
    production. Different languages generate different types of artifacts (war or
    JAR for Java, the source code for Node.js.), which led to heterogeneity in the
    procedures when rolling out new versions.
  prefs: []
  type: TYPE_NORMAL
- en: This heterogeneity led into bespoke solutions to roll out versions, which are
    pretty much sorceries with weird habits, such as deploying at 4 a.m. to avoid
    an outage in the system and creating error-prone bash scripts that are harder
    to maintain than the software itself. The problem, aside from the complexity,
    is that new hires need to ramp up into your systems, and this always introduces
    a level of risk that we are not aware of for the majority of the time until something
    goes very wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** came to the rescue. With Docker, we can generate a deployable artifact,
    which is not only the software that you built but also its runtime. If you are
    deploying a Java application, with Docker, you will bundle the application plus
    the version of Java that is going to be running your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds like a dream: a controlled environment that gets promoted as an
    artifact from development to QA and later production (sometimes stopping in preproduction
    for a sanity check) that is repeatable and the only thing that changes across
    environments is the configuration, usually injected via environment variables.
    It is not a dream; it is the reality in 2017, and in this chapter, we are going
    to accelerate from 0 to the speed of light on when it comes to running containers
    in Docker and building images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building `docker images`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also stop at `docker-compose`, a tool used to run several containers
    in combination, so we can compose our system in the development machine, simulating
    our production configuration or, at the very least, approaching the interconnection
    of components, but before that, we are going to also dive deep into Docker networking:
    how can we choose the most appropriate networking for our system and what are
    the main differences between the different networks that Docker offers?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting feature of Docker is how the images get built: basically,
    we choose a base image (we will look at how to build one), and with a reduced
    set of commands, we can build a Docker file which is basically a script that instructs
    Docker on how to build our image with the configuration that we need.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my preferred ways of learning is through experimentation. In order to
    explain the Docker architecture, we are going to show an example, but first, we
    need to install Docker itself. In this case, I am working with Mac, but at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/),
    you can find the distribution that suits your needs with a very clear set of instructions
    (usually a package that needs to be installed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed Docker, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it finishes, the output should be very similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This message shows that your installation appears to be working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate this message, Docker took the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client contacted the Docker daemon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon pulled the `hello-world` image from the Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon created a new container from that image, which runs the executable
    that produces the output you are currently reading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon streamed that output to the Docker client, which sent it to
    your Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To try something more ambitious, you can run an Ubuntu container with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Share images, automate workflows, and more with a free Docker ID at [https://cloud.docker.com/](https://cloud.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For more examples and ideas, visit: [https://docs.docker.com/engine/userguide/](https://docs.docker.com/engine/userguide/).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `hello-world` image gives you some insights into what is
    going on when running the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some new concepts have been introduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is a central repository, which is public and private,
    where users can push images that they build locally. A Docker registry is used
    to carry the images across different stages of the deployment pipeline (or even
    between systems).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer**: Docker images are composed of layers. A layer is basically an ordered
    filesystem difference. A Docker image is a stack of these layers leading into
    the final image. When you change a file in an existing image, a new layer is created,
    but the rest of the layers of the images are reused so we can save a lot (believe
    me, a lot) of space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker daemon**: Docker follows a client-server architecture. In this case,
    the Docker daemon is the server part that can be operated via a **Representational
    State Transfer** (**REST**) API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker client**: Docker client is a **Command-Line Interface** (**CLI**)
    used to operate a Docker daemon. It might be a local daemon or a remote one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last three concepts are the key for drafting the architecture of Docker.
    Take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02249a9d-ef9a-4679-a2f1-ea2bc975c9e4.png)'
  prefs: []
  type: TYPE_IMG
- en: The client/server architecture predominates the software. You might think that
    this is an overkill for a system such as Docker, but it actually gives you a lot
    of flexibility. For example, in the previous diagram, we can see how the Docker
    CLI (the client) is able to manage a local instance of the Docker daemon but is
    also able to talk to a remote daemon by setting an environment variable called
    `DOCKER_HOST`, in this case, to the value of `62.112.42.57`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key points of Docker is that it completely leverages the virtualization
    to the Linux kernel, making it impossible to run (as of today) Docker on Windows
    or even Mac as it uses the capabilities of the Linux kernel. The solution to this
    is to create a virtual machine with Linux that runs the Docker daemon, and the
    CLI will talk to the virtual machine to run Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: In Mac, for example, the old versions of Docker use a distribution called `Boot2Docker`
    that runs the Docker daemon, whereas the newer versions of Docker use something
    called **HyperKit**, which is a lightweight virtualization solution for Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Windows uses a different type of virtualization that is equivalent
    to the one in Mac so all the assumptions made for Mac are valid for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Docker internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have seen how Docker works regarding the overall architecture,
    but what happens at the operating system level in the Docker daemon?
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly explained, Docker provides you with only a runtime for your applications:
    you can limit the number of cores and the amount of memory to be used by the container,
    but at the end of the day, the kernel running your container is going to be the
    same as the kernel running your host machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof of that is in the way Docker organizes images: it calculates filesystem
    differences and packs them in layers that can be reused. Let''s pull a fairly
    big image (not the hello-world from the preceding example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Docker has pulled five layers, which basically tells us that
    the Ubuntu image was built in five steps (not quite true, but it is a good approach).
    Now we are going to run an instance of Ubuntu. In Docker, an instance of an image
    is what we call a container, and the main difference between an image and a container
    is the top writable layer (layers in Docker are stacked in the read-only mode
    to compose the image, such as the diffs in several patch files). Let''s demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command runs `/bin/bash` in an instance of the Ubuntu image.
    The `i` and `t` flags allow you to use the container as if it were a virtual machine
    allocating a virtual TTY (`t` flag) and creating the interactive session (`i`
    flag). Now, you can see how your prompt has changed to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It does not necessarily have to be the same, but it should be similar. Note
    that your prompt is now a root prompt, but don't get too excited; it is just inside
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file to alter the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now you can disconnect from the container with the `exit` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the prompt is back to your system prompt, and if you run `docker
    ps`, you can see that there are no running containers, but if you run `docker
    ps -a` (show all the containers, not just the running ones), you should see something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a container that has been created from an image but is not running
    anymore. As we said earlier, the only difference between this container and the
    image is the top writable layer. In order to prove this, we are going to create
    a new image out of the container that we ran a few minutes ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, I am using the reference `329b`. because it is the one shown
    in the preceding image (the output of `docker ps -a`), but you need to change
    the hash to the one shown in your output. In fairness, you don''t need to type
    it all; just few characters will do the job. If everything went well, the command
    should output a `SHA256` checksum and return the control to you. Now run `docker`
    images (to list the images in your Docker) and the output should be similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is a new image called `my-ubuntu` that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to check the difference between the `ubuntu` image and the `my-ubuntu`
    image. In order to do that, we need to inspect the layers for each image and see
    the difference. The command we are going to use to accomplish this task is `docker
    history`, with the name of the image as the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, for the `ubuntu` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70edb84-d97b-41f8-af1d-9a670f12f85c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then for `my-ubuntu`: image (just created from `ubuntu`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5668bcc-dbb3-4aef-a354-7d165e8f7a8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Quite illuminating. The image `my-ubuntu` ;is the same image as `ubuntu` except
    for the top writable layer that we just created by logging in to the machine and
    creating a file. This is very smart because even though both of the two images
    use around 130 MB of space, the only extra space used for the second image is
    the top layer that, in this case, uses only 5 bytes, leading to a usage of 130
    MB and 5 bytes for the two images. This also has a side-effect in line with what
    we talked earlier: a container is the exact same thing as an image but with a
    different top writable layer, so running an instance of the container uses only
    5 bytes of space. As you can see, the engineers that created Docker thought about
    everything!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way in which how Docker stores the images in the hard drive is the responsibility
    of the storage driver: Docker can make use of different drivers and store the
    images in different ways (and places, such as S3 in AWS), but the most common
    use case, the default driver, stores the images on the hard drive, creating one
    file per layer with the checksum of the layer as the name of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made use of the Docker client already in the previous section, but we
    need to go a bit deeper into the options that the Docker CLI can offer. My favorite
    way of learning is through experimentation, and what we are going to be doing
    through this section is building concepts from top to bottom (more decomposing,
    than building), so I advise you to read the full section in the order without
    skipping parts, as the latter examples will be based on the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have dug into Docker a bit before, you can see that the commands are
    **quite** verbose and not as intuitive as you might think. The most common use
    case is the following combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command basically does one simple thing: it runs a container in the interactive
    mode and allocates `pseudo-tty`. This allows us to interact with the container
    executing the commands (not on every image, but it is true for all the base images
    of Linux distributions). Let''s see what that means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return a prompt similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What just happened? The prompt changed to root with a strange number in the
    host section. We are in the container. Basically, now we can run commands that
    are going to be run within the container. To exit the container, just type exit
    and the control should be returned in the terminal to your host machine, leaving
    the container running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The majority of the time, the preceding command suits our needs, but sometimes,
    we want to run the container in the background: imagine that you spin up a Jenkins
    server and you don''t want to have your Terminal attached to it. In order to do
    that, we just need to add the `-d` option (daemon) and drop `-i` and `-t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image is pulled and it starts running, the control is returned to
    your Terminal. The last line in the output, and it should be a long string of
    characters similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the hash of the running container. If you execute `docker ps` , the
    following output (similar) will be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f06a6c21-8fd5-4617-ac26-01ff8b807043.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the value under `CONTAINER ID` in the screenshot matches the first
    few digits of the hash from the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: Now in theory, we have a running instance of Jenkins that, as you can see in
    the preceding image, is listening on port `8080` and port `50000`. Let's try to
    browse `http://localhost:8080` with an internet browser. Nothing. Basically, our
    browser cannot open that URL.
  prefs: []
  type: TYPE_NORMAL
- en: This is because we haven't told to Docker to bind the container ports to the
    local ports of the host machine. In order to do that, we need to first stop the
    container and then start it again with a special parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to learn how to stop containers. We have two options here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stop the container**: With the stop option, we send `SIGTERM` to the main
    process within the container and wait for it to finish (for a grace period). Then,
    we send `SIGKILL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kill the container**: With the kill option, we send `SIGKILL` to the main
    process in the container, which forces an immediate exit without being able to
    save the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, which one you choose is irrelevant, but please be careful. When
    you are running in a production environment, make sure it''s fine to kill a container
    before doing that, as with the stop option, we are giving the running software
    the option to save the current transactions and exit gracefully. In this case,
    I am going to kill the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Docker is smart. I did not need to specify the full container identifier, as
    with only a few characters, Docker is able to identify the container (or the image
    in other commands) and kill it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from previous examples, when we kill a container, we have a
    layer left that leads into a `dead` container that we can explore, adding the
    `-a` option to the `docker ps` command. For this example, we are going to remove
    this layer as well with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The container never existed in our host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, going back to the Jenkins example, we want to run Jenkins in a way that
    we can access the running instance from our browser. Let''s modify the preceding
    command and explain why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, if we go to `http://localhost:8080` in a browser, we should
    see the initial configuration for Jenkins, which asks for the initial password
    to be able to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain the previous command first. We can see a new option: `-p`. As
    you can guess, `-p` comes from the port. In fairness, you could change `-p` for
    `--port`, and everything will work as expected. With the `-p` option, we map ports
    from the host, your machine, to the container. In this case, we are mapping port
    `8080` from the host to port `8080` and port `50000` of the host to port `50000`
    of the container, but how can we map a different port in the host? Well, it is
    fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, we have two instances of Jenkins running:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is exposed in port `8080` of your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is exposed in port `80801` of your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that even though we don't use port `50000`, I have changed it to `50001`
    as your machine's port `50000` is already busy with the first instance of Jenkins
    that we ran earlier on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Jenkins is asking for a password, and the initial web page
    in `http://localhost:8080` states that this password is in the logs or in the
    filesystem. Focusing on the logs, with Docker, we can fetch the logs for any container
    registered by the daemon at any time. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In my case, the running instance of Jenkins on port `80801` has an ID that starts
    with `11872`. Executing the previous command should retrieve the starting log
    of Jenkins that we can use for troubleshooting or, in this case, to recover the
    password to initialize Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting and common option in Docker is passing environment variables
    to an application running inside the container. If you think about it, there are
    only three ways in which we can configure an application within a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A volume with data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching the configuration from the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the official MySQL image from the Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL is a popular database server that has also been `dockerized`. If you
    read a bit through the documentation, one of the config options is the root password
    for the MySQL database. In fairness, the quick start example points to the right
    direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The new option here is **`-e`**. This option allows you to pass an environment
    variable to the container with the value that you want to specify after `=`. After
    running the preceding command, we are going to run another command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `caa40cc7d45f` is the ID that results from running MySQL on my
    machine (yours should be different). There should be a huge JSON output in the
    terminal, but one section in particular, Config, has a subsection called `Env`
    , which should look very similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There it is. The preceding environment variable that we passed, `MYSQL_ROOT_PASSWORD`,
    is now accessible from within the container as the environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `docker inspect` command, there is a lot of very valuable information.
    Just have a read through, as you might be surprised with how familiar you are
    with the majority of the info: it is mainly Linux terminology.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have visited the most common commands as of January 2017\. As you
    know, the software evolves very quickly, and by the time you are reading this
    book, new versions (such as secrets) have already been added to Docker. The best
    way to check what is going on is through the documentation on [http://www.docker.com](http://www.docker.com),
    which, in my opinion, is quite comprehensive. There is also a reference of the
    commands of your current Docker installation available under the `docker help`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Building Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we built an image using the commit command of Docker.
    Although it works, I can see a big problem with it: it is not repeatable. There
    is no easy way of rebuilding the image once and over again when the software installed
    in the image is patched due to new vulnerabilities or versions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this problem, Docker provides a better way of building images:
    Dockerfiles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dockerfile is a file that contains a set of ordered commands required to
    leave the image, ready to be used. Things such as installing software or upgrading
    the version of the kernel as well as adding users are common activities that can
    be carried in a Dockerfile. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have been in the IT field for a few years, you really don''t need an
    explanation on what it is going on, but let''s make sure that we are all on the
    same page:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating our image based on the latest Node.js image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new folder is created in `/app`. Our application will be installed there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The working directory is set to this new folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy `package.json` and install the Node.js dependencies. Remember that we have
    already set up the working directory to `/app`, so the RUN command will be run
    in the `/app` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the rest of the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose port `8080` to the outer world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `npm start`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is very simple once you have done it few times. One thing to keep in mind
    that might drive beginners crazy is this: `CMD` versus `RUN`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding Dockerfile, sometimes, we use `RUN`, and sometimes, we use
    `CMD`, but both of them seem to do the same thing: run a command. There is one
    difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN`: This will run the command when building the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`: This will run the command when the container based on the generated
    image starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, `RUN` (generally) creates a new layer, whereas `CMD` uses the writable
    layer of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to test the Dockerfile from earlier. Before building the image,
    we need to build a small Node.js application that is going to be used as the software
    running in the image. Create a new folder with three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile (the one from before)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The content of `package.json` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `index.js` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, with the preceding files and the Dockerfile described before in the
    same folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, your image would be ready for use. Let''s check it. If
    you list your images with the `docker images` command, you should see an image
    called `my-node-app`. Now create a container based on the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the highlighted section, the output of running our application
    is here.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in the previous section, Dockerfiles are very simple, and if
    you have any queries, the official documentation for the Dockerfile language is
    very comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the language used for creating Dockerfiles is very similar to the
    batch processing language of windows (`.bat` files) from a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the most used commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `FROM` | This instruction is used to specify the base image. Every single
    Docker image is created starting from a base image (you can create base images
    from a running Linux distribution). |'
  prefs: []
  type: TYPE_TB
- en: '| `COPY` | As you can guess, `COPY` allows you to copy files and folders inside
    the image. For example, we could copy our application, a war file, or any other
    artifact that will be packed with the image once it is distributed. |'
  prefs: []
  type: TYPE_TB
- en: '| `ADD` | This does the exactly the same thing as `COPY` but with three differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The origin of the files could be a URL that gets downloaded before copying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origin of the files could be a packed file (such as a TAR file) that will
    be unpacked in the image filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `RUN` | This runs a command in the image. For example, it can be used to
    install software in the image. It always creates a new layer in the Docker image,
    so be careful and keep the `RUN` commands to a minimum. |'
  prefs: []
  type: TYPE_TB
- en: '| `CMD` | This is the default command to be run when the image gets instantiated
    as a container. As you can see in the preceding example, we are using `CMD` to
    execute `npm start`, which runs `node index.js` (refer to `package.json`). It
    does not create a new layer as it uses the top writable layer to store the changes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRYPOINT` | `ENTRYPOINT` is similar to `CMD`, but it overrides the default
    command on a docker image that is `/bin/sh -c`. In order to override an specified
    entry point, you need to pass the `--entrypoint` flag when running an instance
    of the image. `ENTRYPOINT` is ideal for configuring containers as command-line
    tools, as you can pack a fairly complex command with a fairly complex setup in
    a single container. |'
  prefs: []
  type: TYPE_TB
- en: '| `MAINTAINER` | With `MAINTAINER`, you can specify who is the maintainer of
    the image (also specify the email). |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE` | This exposes the port specified in the first parameter so that
    the container can listen to it. It actually does not expose the port in the `docker`
    client host, forcing the user to pass the `-p` flag in order to access the given
    port. |'
  prefs: []
  type: TYPE_TB
- en: With these commands, you can build pretty much anything that you want, and particularly
    with `RUN`, this allows the user to run any command within the container that
    enables us to run scripts (`python`, `bash`, and `ruby`.) or even install software
    using package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the preceding instructions, the Dockerfile language also comes with
    support for adding environment variables, volumes, and a few other features that
    make it quite powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Docker registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a new image with our application installed
    and ready to be used (in this case, a very simple `Hello world` Node.js application).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to distribute the image so it can be installed in all the stages
    of our deployment pipeline or even used by other developers. Docker is interesting
    for running applications but it is also a very interesting choice to create command-line
    tools that other developers can benefit from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to distribute images, we have to rely on exporting/importing the image
    or using a registry. A registry is basically a software that allows us to store
    and distribute Docker images. There are two types of registries:'
  prefs: []
  type: TYPE_NORMAL
- en: Public registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the different registry types.
  prefs: []
  type: TYPE_NORMAL
- en: Public registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most known of the public registries is Docker Hub. It is the official and
    default registry that every Docker installation knows of. Also, it offers private
    repositories, but the most interesting feature is the fact that all the official
    images are available on Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how can we use it. First, you need to create an account. Once you
    are registered, create a new repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e20dfccf-d186-422b-b4bc-f5a6c8e20a53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This repository hosts an image called `modern-devops`, and we are going to
    push one image into it. Once it is created, you can see that Docker Hub suggests
    that you pull the image with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In your case, `dagonzadub` will need to be replaced with your username. Obviously,
    we are not going to pull an image that is not there yet, so let''s push an image.
    In the previous section, we created an image called `my-node-app`. We are going
    to use this image to test Docker Hub. Docker relies on a tag system to know where
    to push the image or where to pull from. As we are working with the `default`
    registry, we don''t need to specify the URL, but we need to specify the user and
    the repository name. If you haven''t deleted the image created in the previous
    section, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds (depending on your upload speed, even minutes), your image
    is available on Docker Hub. As we marked it as `public`, everybody can pull and
    use your image.
  prefs: []
  type: TYPE_NORMAL
- en: Private registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what happens if we want to store our images in our private registry within
    our infrastructure?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we have some options. If we are using cloud providers, such as Google
    Cloud Platform or Amazon Web Services, they provide a Docker registry that is
    only accessible from within your account, and you can specify the region in which
    your images live (remember, the type of data that we are handling might be under
    strict compliance rules about where we should store the data).
  prefs: []
  type: TYPE_NORMAL
- en: In AWS, the container registry is called **EC2 Container Registry** (**ECR**),
    and in GCP, it is called a container registry. If your infrastructure is in one
    of these private clouds, I encourage you to use it as you can leverage the access
    to the access controls provided by the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we might find ourselves in a situation where we cannot use a cloud
    provider as our system has to be built on premises. This is when we need to use
    a private on-premises Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, there are quite a few options, but it is highly likely that the market
    widens in the coming months or years as the companies are using Docker more and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'From all the range of registries, there are three that I find particularly
    interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quay**: This is a complete registry in the current market (at the time of
    writing this). It has some interesting features, but the one that is probably
    the most interesting is the ability to scan the images searching for security
    vulnerabilities in the installed software. It can also build images based on changes
    in your git repository, so if your Dockerfile is altered in GitHub, Quay will
    automatically trigger a build and deploy the new version of the image. Quay is
    not free, so a license has to be paid in order to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registry**: This is the plain name for a plain concept. It is the official
    implementation of the registry API and comes packed in a container. It has no
    interface or access controls by default, but it does the job. It also provides
    storage management drivers, so we can deploy our images to S3 or Google Cloud
    Storage buckets as well as many other options. Registry is free and can be pulled
    from Docker Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Trusted Registry: This is part of the enterprise version of Docker.
    Like pretty much any other commercial registry, it provides static container analysis
    as well as storage management drivers. **Docker Trusted Registry** (**DTR**) is
    not free, so a license has to be paid for in order to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to create images, how to store the images in a registry,
    and how Docker images work in general (layers and containers versus images).
  prefs: []
  type: TYPE_NORMAL
- en: An important part of any application is the storage. In general, Docker applications
    should be stateless, but with the new orchestration software, such as Kubernetes,
    Docker Swarm, and similar, every day, more and more engineers are moving toward
    containerized databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker solves this problem in a very elegant way: you can mount a folder from
    the local machine into the container as if it were a normal folder.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful abstraction as it leverages the ability to push data
    out of the container to be saved into a **Network Attached Storage** (**NAS**)
    or any other storage technology (it is possible to use a bucket in the Google
    Cloud Storage or S3 as the volume mounted in a container).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basics. Just run a MySQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This works. It actually does what is expected: it launches a container with
    a mysql instance in it. The problem is that all the data is going to be written
    to **`/var/lib/mysql`** and this folder is mapped to the top writable layer of
    the container (remember, in the previous section, we explained the difference
    between a container and an image). The only way to save data is actually committing
    the changes and create a new image that is not manageable and, of course, this
    not the way you want to do it. Think about it: if you remove a file in Docker,
    you are doing it in the top layer, which is the only one writable, so in reality,
    you are not removing the file; you are just hiding it. The file is in one of the
    layers using the space but it is not visible. Docker records differences and a
    layer itself is a set of differences from the previous stacked layers (think about
    how Git works; it is the same principle).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of committing the changes into a new image, we are going to mount a
    folder from our docker host into the container. Let''s alter the previous command
    a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a new flag, `-v`, followed by the `data:/var/lib/mysql` value.
    The meaning of the command is very simple: mount the `/home/david/data` folder
    into the `/var/lib/mysql` path of my container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can guess, the data folder, in my case, `/home/david/data`, should be
    present in your current directory, so if it wasn''t present, create it or modify
    the path to suit your setup and launch the container. This use case can only be
    achieved through the `-v` flag: mount a selected folder from the host into the
    container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute `ls` inside the data folder (in the Docker host):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see how `mysql` has actually written data files corresponding to the
    databases created in bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes are not limited to one per container, so you can replicate the
    **`-v`** flag as many times as you need in order to match your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of mounting a shared folder between the container and the host
    is just specifying the path inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will mount a folder from our Docker host into the container, but
    the folder in the `docker` host will be managed by the storage driver and `docker`
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is familiar. We have seen it before in the previous sections, but
    now we are looking for different information. We are actually looking for a section
    called `Mounts`, which looks like this (at least similar to it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is also possible through the `VOLUME` instruction in a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding JSON is telling us which local folder is going to be mounted
    in the container (the `Source` value of the JSON) and provides an interesting
    insight: the volume has been named by `docker` (the `Name` value of the JSON).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that Docker tracks the volumes that are (or have been) mounted in
    any container and can be listed through an API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can guess, we can also create volumes through an `api` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This volume is created in the same way as the previous example: it is up to
    Docker to decide which folder on the local machine is going to be mounted in the
    specified path in the container, but in this case, first, we are creating the
    volume and then mounting it to a container. You can even inspect the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And this should return you something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this named resource and mount it into our containers, just referencing
    the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The last (but not least) interesting use case in volumes helps us share the
    configuration across different containers. Just imagine that you have a fairly
    complex setup that leads to a gigantic Docker command with several `-v`. Docker
    provides us with a much simpler way of sharing volume configuration across containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very simple and intuitive: `my-mysql-5` will spawn with the volume
    configuration of `my-mysql-4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Networking is an important part of Docker. By default, Docker comes with three
    networks that we can inspect by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d45651ef-61a5-4658-8040-8f9b1144dd2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explain the different networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bridge`: This is the default network. It is an entirely different stack from
    the host machine with a different IP range in the `bridge` mode (the host machine
    acts as a `router` for the containers in this network). The containers created
    without specifying the network are attached to the default bridge network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: In this network, containers share the network stack with the Docker
    host. If you inspect the configuration in the container, you will find that it
    is the exactly the same as in the Docker host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: This is easy to guess; the container gets attached to no network: just
    the loopback interface in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it is time to look at some examples. We are going to use `busybox`, which
    is the `swiss` army knife of the Docker images. It has several Unix tools that
    we could benefit from, but in this case, the characteristic that is going to benefit
    us is the fact that it is a functional Linux on a reduced space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have followed the previous sections, by now, you can understand the
    outcome: we gain root access to a running container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to execute `ifconfig` inside the container. It should give
    us two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- eth0 - 172.17.0.2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`- lo - 127.0.0.1`'
  prefs: []
  type: TYPE_NORMAL
- en: The IP might change, but you should see these two interfaces. Comparing the
    IP with the IP in your Docker host, we can validate the fact that the container
    is running in the bridge network as the IP and network are completely different;
    in my case, the IP on my Docker host is `10.0.0.12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s spawn another container with `busybox` in a different terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: By now, we should have two `busybox` instances running, and they should have
    consecutive IPs, in my case, `172.17.0.2` and `172.17.0.3`. If you go back to
    the terminal of the first instance of `busybox`, you can ping the second container
    by IP. This is because they both belong (or are connected to) the same network,
    which is the default bridge one.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run the containers in the host network, we just need to pass `--network=host
    flag` to the `docker run` command and that's it; our container is sharing the
    network stack with the Docker host, but be careful, if you are on Mac or Windows.
    The Docker host is a virtual machine so don't attempt to access it through localhost;
    you will need to find the IP of the virtual machine running `docker`.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also possible to create custom and isolated networks in Docker. This is
    interesting from the security point of view, as it enables us to segregate different
    containers on the network level so we can enforce a higher level of access control.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a network, we just need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. Well, that is a simplistic approach, but it works as expected.
    As you know, networking is a complicated subject, so Docker provides options to
    customize ranges, masks, and other parameters. The user-defined networks are of
    the type bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the network is created, you can run new containers in that network, as
    follows (on a new terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As expected, these containers will be isolated from the other networks. In this
    case, the two containers are launched in the `bridge` network. In my case, the
    third container (the one just launched) has the IP `172.19.0.2`, whereas the two
    launched in the bridge network are `172.17.0.2` and `172.17.0.3`. Issuing a ping
    command between containers in different networks results in 100% packet loss.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of the time, Docker is synonymous to microservices. Running a big
    monolithic application in Docker does not make too much sense as the whole Docker
    Engine is thought to be running big applications split into different and smaller
    services. There is no technical limitation to running a monolithic app on Docker,
    but when the orchestration software comes into place (in the following chapters),
    it really defeats the purpose of containerization.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with microservices, it is very common to have several services
    running at the same time when developing, as the new services will lean on the
    existing ones to execute operations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this setup, Docker facilitates a tool called `docker-compose`
    that, by creating a YAML file with the definition of our containers, can spawn
    a full ecosystem of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose used to be very popular in the beginning of Docker. Nowadays,
    it is still widely used, but its space has been slowly reduced to development
    stages as the container orchestration tools in Kubernetes have taken over the
    production space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how Docker Compose works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding YAML file is a `docker-compose` definition. As you can guess,
    there are two components:'
  prefs: []
  type: TYPE_NORMAL
- en: A web application (the current folder)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database (postgres)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the file to a folder with the name `docker-compose.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a typical case of an application connecting to a database. In order
    to simplify this, our application is just going to be a dummy application (no
    database connection) with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And our Dockerfile is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile will install the required dependencies and run `npm start` in
    the root of our app folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the application is very simple, and it only tries to resolve
    the name `db` instead of connecting to the database (in fairness, we didn''t even
    specify the ports for connecting to it). We are going to demonstrate how `docker-compose`
    wires up the containers. By now, there should be four files in the work folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose.yaml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going back to our `docker-compose` file, we can see that in the `my_app` definition,
    we ask to build the current folder (build the image described by the Dockerfile),
    and we specify that the container itself is dependent on another container called
    `db`. This makes Docker take action and connect the two containers, being able
    to reach `db` from `my-app` by name. In order to achieve this, there is an entry
    created in `/etc/hosts` with the IP of `db`, so we `my-app` will be able to resolve
    it. Docker compose is very easy to understand: it is nearly self-explanatory,
    and the fact that it makes use of YAML makes everything so much more readable.
    Now we need to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it finishes, there should be a quite a long output, but there are some
    lines that indicate our success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted section tells us that `my_app` is able to reach db by IP as
    they are on the same bridge network. Let''s see what happened here:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker built the image for the current folder (as specified in `my_app`) from
    the Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker pulled the `postgres` image from the Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker started the images in order: first `db` and second `my_app`, as specified
    in the dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are going to give a special emphasis to orchestration technologies,
    and then we will come back to Docker Compose in [Chapter 5](820e2d41-3917-4d4c-ad80-461fc133740b.xhtml),
    *Infrastructure as Code,* where we will take a deep dive into Docker Swarm, which
    is where compose becomes really helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through Docker from the internals to the command-line
    interface to operate a Docker host. Now, we have enough knowledge to understand
    the consequences and benefits of running Docker in production. We have not looked
    into how to develop Docker plugins as well as different storage drivers, as unfortunately,
    we have a limited amount of space in this book to introduce the most interesting
    concepts, but we have dived deep enough into Docker to be able to learn more from
    the resources (official documentation, videos, and so on) available to us on the
    Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will have a look on how to automate tasks around our
    software: running tests, building images and many other tasks that shouldn''t
    be done manually. This automation is called **continuous integration** because
    allows our team to integrate new features on a seamless way.'
  prefs: []
  type: TYPE_NORMAL
