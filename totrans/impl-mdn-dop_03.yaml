- en: Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: For many years, the contact point between development and operations has been
    always a source of problems when deploying a new version of an application to
    production. Different languages generate different types of artifacts (war or
    JAR for Java, the source code for Node.js.), which led to heterogeneity in the
    procedures when rolling out new versions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，开发和运维之间的接触点一直是将新版本应用程序部署到生产环境时的一个问题源。不同的编程语言生成不同类型的制品（Java的war或JAR，Node.js的源代码），这导致了在推出新版本时程序的异构性。
- en: This heterogeneity led into bespoke solutions to roll out versions, which are
    pretty much sorceries with weird habits, such as deploying at 4 a.m. to avoid
    an outage in the system and creating error-prone bash scripts that are harder
    to maintain than the software itself. The problem, aside from the complexity,
    is that new hires need to ramp up into your systems, and this always introduces
    a level of risk that we are not aware of for the majority of the time until something
    goes very wrong.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异构性导致了定制化的版本发布解决方案，这些解决方案往往像是巫术，带有奇怪的习惯，例如凌晨4点发布以避免系统中断，或创建容易出错的bash脚本，这些脚本比软件本身更难维护。问题除了复杂性外，还在于新员工需要适应你的系统，这总是引入我们大多数时候未意识到的风险，直到某些事情出错。
- en: '**Docker** came to the rescue. With Docker, we can generate a deployable artifact,
    which is not only the software that you built but also its runtime. If you are
    deploying a Java application, with Docker, you will bundle the application plus
    the version of Java that is going to be running your application.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker** 来拯救我们。有了Docker，我们可以生成一个可部署的制品，这不仅仅是你构建的软件，还有它的运行时。如果你要部署一个Java应用程序，通过Docker，你将打包应用程序和将要运行你的应用程序的Java版本。'
- en: 'This sounds like a dream: a controlled environment that gets promoted as an
    artifact from development to QA and later production (sometimes stopping in preproduction
    for a sanity check) that is repeatable and the only thing that changes across
    environments is the configuration, usually injected via environment variables.
    It is not a dream; it is the reality in 2017, and in this chapter, we are going
    to accelerate from 0 to the speed of light on when it comes to running containers
    in Docker and building images.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是一个梦想：一个受控环境，从开发到QA，再到生产（有时会在预生产环境进行检查）作为一个制品被推广，这个过程是可重复的，唯一在不同环境间变化的是配置，通常是通过环境变量注入的。这不是梦想；这是2017年的现实，在本章中，我们将快速学习如何在Docker中运行容器并构建镜像，速度快得如同光速。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: The Docker architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker架构
- en: The Docker client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端
- en: Building `docker images`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`docker images`
- en: Docker registries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册中心
- en: Volumes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷（Volumes）
- en: Docker networking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网络
- en: Docker Compose
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: 'We will also stop at `docker-compose`, a tool used to run several containers
    in combination, so we can compose our system in the development machine, simulating
    our production configuration or, at the very least, approaching the interconnection
    of components, but before that, we are going to also dive deep into Docker networking:
    how can we choose the most appropriate networking for our system and what are
    the main differences between the different networks that Docker offers?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍`docker-compose`，这是一个用于组合多个容器的工具，这样我们就可以在开发机器上组成我们的系统，模拟生产配置，或者至少接近组件间的连接，但在此之前，我们还将深入探讨Docker网络：我们如何选择最合适的网络来支持我们的系统，以及Docker提供的不同网络之间的主要区别是什么？
- en: 'Another interesting feature of Docker is how the images get built: basically,
    we choose a base image (we will look at how to build one), and with a reduced
    set of commands, we can build a Docker file which is basically a script that instructs
    Docker on how to build our image with the configuration that we need.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的另一个有趣特点是镜像的构建方式：基本上，我们选择一个基础镜像（我们将了解如何构建一个），然后通过一组精简的命令，我们可以构建一个Docker文件，这基本上是一个脚本，用于指导Docker根据我们需要的配置来构建我们的镜像。
- en: Docker architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker架构
- en: One of my preferred ways of learning is through experimentation. In order to
    explain the Docker architecture, we are going to show an example, but first, we
    need to install Docker itself. In this case, I am working with Mac, but at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/),
    you can find the distribution that suits your needs with a very clear set of instructions
    (usually a package that needs to be installed).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我学习的一种偏好方式是通过实验。为了说明 Docker 架构，我们将展示一个示例，但首先，我们需要安装 Docker 本身。在这个案例中，我正在使用 Mac，但在[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)上，你可以找到适合你需求的发行版，并且有一套非常清晰的安装说明（通常是需要安装的包）。
- en: 'Once you have installed Docker, run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 后，运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once it finishes, the output should be very similar to the following one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，输出应该和以下内容非常相似：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This message shows that your installation appears to be working correctly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息显示你的安装似乎工作正常。
- en: 'To generate this message, Docker took the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这条消息，Docker 执行了以下步骤：
- en: The Docker client contacted the Docker daemon.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 客户端联系了 Docker 守护进程。
- en: The Docker daemon pulled the `hello-world` image from the Docker Hub.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程从 Docker Hub 拉取了 `hello-world` 镜像。
- en: The Docker daemon created a new container from that image, which runs the executable
    that produces the output you are currently reading.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程从该镜像创建了一个新容器，运行生成当前输出的可执行文件。
- en: The Docker daemon streamed that output to the Docker client, which sent it to
    your Terminal.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 守护进程将输出流传输到 Docker 客户端，然后客户端将其发送到你的终端。
- en: 'To try something more ambitious, you can run an Ubuntu container with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试更具挑战性的操作，可以运行一个 Ubuntu 容器，命令如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Share images, automate workflows, and more with a free Docker ID at [https://cloud.docker.com/](https://cloud.docker.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用免费的 Docker ID，在[https://cloud.docker.com/](https://cloud.docker.com/)上分享镜像，自动化工作流，等等。
- en: 'For more examples and ideas, visit: [https://docs.docker.com/engine/userguide/](https://docs.docker.com/engine/userguide/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更多示例和想法，访问：[https://docs.docker.com/engine/userguide/](https://docs.docker.com/engine/userguide/)。
- en: As you can see, the `hello-world` image gives you some insights into what is
    going on when running the preceding command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`hello-world` 镜像向你展示了运行前面命令时发生的情况。
- en: 'Some new concepts have been introduced here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入了一些新概念：
- en: '**Docker Hub**: This is a central repository, which is public and private,
    where users can push images that they build locally. A Docker registry is used
    to carry the images across different stages of the deployment pipeline (or even
    between systems).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：这是一个中央仓库，既有公共也有私有部分，用户可以将本地构建的镜像推送到这里。Docker 镜像库用于在不同的部署阶段（甚至在不同系统之间）传输镜像。'
- en: '**Layer**: Docker images are composed of layers. A layer is basically an ordered
    filesystem difference. A Docker image is a stack of these layers leading into
    the final image. When you change a file in an existing image, a new layer is created,
    but the rest of the layers of the images are reused so we can save a lot (believe
    me, a lot) of space.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**：Docker 镜像由层组成。层基本上是有序的文件系统差异。Docker 镜像是这些层的堆叠，最终形成镜像。当你更改一个已有镜像中的文件时，会创建一个新层，但镜像的其余层会被复用，因此我们可以节省大量（相信我，真的是很多）空间。'
- en: '**Docker daemon**: Docker follows a client-server architecture. In this case,
    the Docker daemon is the server part that can be operated via a **Representational
    State Transfer** (**REST**) API.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 守护进程**：Docker 遵循客户端-服务器架构。在这种情况下，Docker 守护进程是服务器端，可以通过**表现状态转移**（**REST**）API
    进行操作。'
- en: '**Docker client**: Docker client is a **Command-Line Interface** (**CLI**)
    used to operate a Docker daemon. It might be a local daemon or a remote one.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 客户端**：Docker 客户端是一个**命令行接口**（**CLI**），用于操作 Docker 守护进程。它可以是本地的，也可以是远程的。'
- en: 'The last three concepts are the key for drafting the architecture of Docker.
    Take a look at the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个概念是草拟 Docker 架构的关键。请查看以下图示：
- en: '![](img/02249a9d-ef9a-4679-a2f1-ea2bc975c9e4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02249a9d-ef9a-4679-a2f1-ea2bc975c9e4.png)'
- en: The client/server architecture predominates the software. You might think that
    this is an overkill for a system such as Docker, but it actually gives you a lot
    of flexibility. For example, in the previous diagram, we can see how the Docker
    CLI (the client) is able to manage a local instance of the Docker daemon but is
    also able to talk to a remote daemon by setting an environment variable called
    `DOCKER_HOST`, in this case, to the value of `62.112.42.57`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器架构在软件中占主导地位。你可能认为这种架构对于像 Docker 这样的系统来说是过度设计，但它实际上为你提供了很多灵活性。例如，在前面的图示中，我们可以看到
    Docker CLI（客户端）如何管理本地的 Docker 守护进程实例，同时也能通过设置一个名为 `DOCKER_HOST` 的环境变量与远程守护进程通信，在此案例中，`DOCKER_HOST`
    的值为 `62.112.42.57`。
- en: One of the key points of Docker is that it completely leverages the virtualization
    to the Linux kernel, making it impossible to run (as of today) Docker on Windows
    or even Mac as it uses the capabilities of the Linux kernel. The solution to this
    is to create a virtual machine with Linux that runs the Docker daemon, and the
    CLI will talk to the virtual machine to run Docker commands.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的一个关键点是它完全利用了 Linux 内核的虚拟化，使得目前无法在 Windows 或 Mac 上运行 Docker（因为它使用了 Linux
    内核的能力）。解决方案是创建一个运行 Linux 的虚拟机来运行 Docker 守护进程，CLI 会与虚拟机通信来执行 Docker 命令。
- en: In Mac, for example, the old versions of Docker use a distribution called `Boot2Docker`
    that runs the Docker daemon, whereas the newer versions of Docker use something
    called **HyperKit**, which is a lightweight virtualization solution for Mac.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Mac 上，Docker 的旧版本使用名为 `Boot2Docker` 的分发版来运行 Docker 守护进程，而 Docker 的新版本则使用名为
    **HyperKit** 的轻量级虚拟化解决方案。
- en: Docker for Windows uses a different type of virtualization that is equivalent
    to the one in Mac so all the assumptions made for Mac are valid for Windows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker for Windows 使用一种与 Mac 上相同的虚拟化技术，因此对于 Mac 所做的所有假设也适用于 Windows。
- en: Docker internals
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 内部结构
- en: Up until now, we have seen how Docker works regarding the overall architecture,
    but what happens at the operating system level in the Docker daemon?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 Docker 在整体架构方面的工作原理，但 Docker 守护进程在操作系统层面上发生了什么呢？
- en: 'Roughly explained, Docker provides you with only a runtime for your applications:
    you can limit the number of cores and the amount of memory to be used by the container,
    but at the end of the day, the kernel running your container is going to be the
    same as the kernel running your host machine.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，Docker 为你的应用程序提供了一个运行时环境：你可以限制容器使用的核心数量和内存量，但归根结底，运行容器的内核和运行宿主机的内核是一样的。
- en: 'The proof of that is in the way Docker organizes images: it calculates filesystem
    differences and packs them in layers that can be reused. Let''s pull a fairly
    big image (not the hello-world from the preceding example):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 证明这一点的是 Docker 组织镜像的方式：它计算文件系统的差异，并将其打包成可以重用的层。我们来拉取一个相当大的镜像（不是前面示例中的 hello-world）：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will produce the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, Docker has pulled five layers, which basically tells us that
    the Ubuntu image was built in five steps (not quite true, but it is a good approach).
    Now we are going to run an instance of Ubuntu. In Docker, an instance of an image
    is what we call a container, and the main difference between an image and a container
    is the top writable layer (layers in Docker are stacked in the read-only mode
    to compose the image, such as the diffs in several patch files). Let''s demonstrate
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Docker 已经拉取了五个层次，这基本上告诉我们 Ubuntu 镜像是通过五个步骤构建的（虽然不完全正确，但这是一个很好的方式）。现在，我们将运行一个
    Ubuntu 实例。在 Docker 中，镜像的一个实例就是我们所说的容器，镜像和容器之间的主要区别是顶部的可写层（在 Docker 中，层是以只读模式堆叠起来组成镜像的，就像几个补丁文件中的差异）。让我们来演示一下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command runs `/bin/bash` in an instance of the Ubuntu image.
    The `i` and `t` flags allow you to use the container as if it were a virtual machine
    allocating a virtual TTY (`t` flag) and creating the interactive session (`i`
    flag). Now, you can see how your prompt has changed to something like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在 Ubuntu 镜像的实例中运行 `/bin/bash`。`i` 和 `t` 标志让你像使用虚拟机一样使用容器，分配一个虚拟终端（`t` 标志）并创建交互式会话（`i`
    标志）。现在，你可以看到你的提示符已经变成了如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It does not necessarily have to be the same, but it should be similar. Note
    that your prompt is now a root prompt, but don't get too excited; it is just inside
    the container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它不一定完全相同，但应该相似。请注意，你的提示符现在是一个 root 提示符，但不要太兴奋；它仅仅是在容器内。
- en: 'Create a file to alter the filesystem:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件来更改文件系统：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you can disconnect from the container with the `exit` command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用`exit`命令断开与容器的连接。
- en: 'As you can see, the prompt is back to your system prompt, and if you run `docker
    ps`, you can see that there are no running containers, but if you run `docker
    ps -a` (show all the containers, not just the running ones), you should see something
    similar to this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，提示符已返回到您的系统提示符，如果您运行`docker ps`，您会看到没有正在运行的容器，但是如果您运行`docker ps -a`（显示所有容器，而不仅仅是正在运行的容器），您应该看到类似以下内容：
- en: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
- en: 'This is a container that has been created from an image but is not running
    anymore. As we said earlier, the only difference between this container and the
    image is the top writable layer. In order to prove this, we are going to create
    a new image out of the container that we ran a few minutes ago:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个已从镜像创建但不再运行的容器。正如我们之前所说，此容器与镜像之间唯一的区别是顶层可写层。为了证明这一点，我们将从几分钟前运行的容器中创建一个新的镜像：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, I am using the reference `329b`. because it is the one shown
    in the preceding image (the output of `docker ps -a`), but you need to change
    the hash to the one shown in your output. In fairness, you don''t need to type
    it all; just few characters will do the job. If everything went well, the command
    should output a `SHA256` checksum and return the control to you. Now run `docker`
    images (to list the images in your Docker) and the output should be similar to
    the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我正在使用引用`329b`。因为它是前面图片（`docker ps -a`的输出）中显示的，但您需要将哈希更改为您的输出中显示的哈希。公平地说，您不需要全部输入，只需几个字符即可完成任务。如果一切顺利，该命令应输出一个`SHA256`校验和，并将控制权返回给您。现在运行`docker
    images`（列出Docker中的镜像），输出应类似于以下内容：
- en: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dec430ca-9bf9-47d4-a45d-56044f125ac9.png)'
- en: As you can see, there is a new image called `my-ubuntu` that we just created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这里有一个名为`my-ubuntu`的新镜像，我们刚刚创建。
- en: Now we want to check the difference between the `ubuntu` image and the `my-ubuntu`
    image. In order to do that, we need to inspect the layers for each image and see
    the difference. The command we are going to use to accomplish this task is `docker
    history`, with the name of the image as the third parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要检查`ubuntu`镜像和`my-ubuntu`镜像之间的差异。为了做到这一点，我们需要检查每个镜像的层并查看差异。我们要使用的命令是`docker
    history`，并将镜像名称作为第三个参数。
- en: 'First, for the `ubuntu` image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于`ubuntu`镜像：
- en: '![](img/b70edb84-d97b-41f8-af1d-9a670f12f85c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70edb84-d97b-41f8-af1d-9a670f12f85c.png)'
- en: 'Then for `my-ubuntu`: image (just created from `ubuntu`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对于`my-ubuntu`：镜像（刚从`ubuntu`创建）：
- en: '![](img/a5668bcc-dbb3-4aef-a354-7d165e8f7a8a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5668bcc-dbb3-4aef-a354-7d165e8f7a8a.png)'
- en: 'Quite illuminating. The image `my-ubuntu` ;is the same image as `ubuntu` except
    for the top writable layer that we just created by logging in to the machine and
    creating a file. This is very smart because even though both of the two images
    use around 130 MB of space, the only extra space used for the second image is
    the top layer that, in this case, uses only 5 bytes, leading to a usage of 130
    MB and 5 bytes for the two images. This also has a side-effect in line with what
    we talked earlier: a container is the exact same thing as an image but with a
    different top writable layer, so running an instance of the container uses only
    5 bytes of space. As you can see, the engineers that created Docker thought about
    everything!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有启发性。镜像`my-ubuntu`与`ubuntu`完全相同，只是顶层可写层我们刚刚通过登录到机器并创建文件创建的。这非常聪明，因为尽管这两个镜像都使用大约130
    MB的空间，但第二个镜像额外使用的空间只是在本例中使用的顶层，仅为5字节，导致这两个镜像使用的是130 MB和5字节的空间。这也产生了我们之前讨论过的副作用：容器与镜像完全相同，只是顶层可写层不同，因此运行容器的实例只使用5字节的空间。正如您所看到的，创建Docker的工程师考虑到了一切！
- en: 'The way in which how Docker stores the images in the hard drive is the responsibility
    of the storage driver: Docker can make use of different drivers and store the
    images in different ways (and places, such as S3 in AWS), but the most common
    use case, the default driver, stores the images on the hard drive, creating one
    file per layer with the checksum of the layer as the name of the file.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docker如何将镜像存储在硬盘上的方式是存储驱动程序的责任：Docker可以使用不同的驱动程序以不同的方式（以及位置，例如AWS中的S3）存储镜像，但是最常见的用例，即默认驱动程序，将镜像存储在硬盘上，并为每个层创建一个文件，文件名为层的校验和。
- en: Docker client
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker客户端
- en: We have made use of the Docker client already in the previous section, but we
    need to go a bit deeper into the options that the Docker CLI can offer. My favorite
    way of learning is through experimentation, and what we are going to be doing
    through this section is building concepts from top to bottom (more decomposing,
    than building), so I advise you to read the full section in the order without
    skipping parts, as the latter examples will be based on the previous ones.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中已经使用了 Docker 客户端，但我们需要深入了解 Docker CLI 可以提供的选项。我最喜欢的学习方式是通过实验，而我们将在这一节中从上到下建立概念（更多是拆解，而非构建），所以我建议你按顺序完整阅读这一节，不要跳过任何部分，因为后面的示例将会基于前面的内容。
- en: 'If you have dug into Docker a bit before, you can see that the commands are
    **quite** verbose and not as intuitive as you might think. The most common use
    case is the following combination:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前稍微了解过 Docker，你会发现这些命令**非常**冗长，并不像你想象的那么直观。最常见的用例是以下组合：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command basically does one simple thing: it runs a container in the interactive
    mode and allocates `pseudo-tty`. This allows us to interact with the container
    executing the commands (not on every image, but it is true for all the base images
    of Linux distributions). Let''s see what that means:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令基本上做了一件简单的事：它以交互模式运行一个容器并分配`伪终端`。这使得我们能够与容器交互并执行命令（并非每个镜像都适用，但对于所有 Linux
    发行版的基础镜像来说是成立的）。让我们看看这意味着什么：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should return a prompt similar to the following one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会返回一个类似于以下的提示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What just happened? The prompt changed to root with a strange number in the
    host section. We are in the container. Basically, now we can run commands that
    are going to be run within the container. To exit the container, just type exit
    and the control should be returned in the terminal to your host machine, leaving
    the container running in the background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？提示符变成了 root，并且主机部分有一个奇怪的数字。我们现在在容器内。基本上，现在我们可以运行将在容器内执行的命令。要退出容器，只需键入`exit`，控制权将返回到主机的终端，容器会继续在后台运行。
- en: 'The majority of the time, the preceding command suits our needs, but sometimes,
    we want to run the container in the background: imagine that you spin up a Jenkins
    server and you don''t want to have your Terminal attached to it. In order to do
    that, we just need to add the `-d` option (daemon) and drop `-i` and `-t`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，前面的命令就能满足我们的需求，但有时我们希望将容器运行在后台：假设你启动了一个 Jenkins 服务器，并且不想让终端一直挂在它上面。为了做到这一点，我们只需要添加`-d`选项（守护进程模式），并去掉`-i`和`-t`选项：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the image is pulled and it starts running, the control is returned to
    your Terminal. The last line in the output, and it should be a long string of
    characters similar to the following one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像被拉取并开始运行，控制权就会返回到你的终端。输出的最后一行应该是类似下面的一串长字符：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the hash of the running container. If you execute `docker ps` , the
    following output (similar) will be produced:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正在运行的容器的哈希值。如果你执行`docker ps`，将会产生类似的输出：
- en: '![](img/f06a6c21-8fd5-4617-ac26-01ff8b807043.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f06a6c21-8fd5-4617-ac26-01ff8b807043.png)'
- en: Note that the value under `CONTAINER ID` in the screenshot matches the first
    few digits of the hash from the preceding command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，截图中`CONTAINER ID`下的值与前一个命令的哈希值的前几位数字相匹配。
- en: Now in theory, we have a running instance of Jenkins that, as you can see in
    the preceding image, is listening on port `8080` and port `50000`. Let's try to
    browse `http://localhost:8080` with an internet browser. Nothing. Basically, our
    browser cannot open that URL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们已经运行了一个 Jenkins 实例，如前面的图片所示，它正在监听端口`8080`和端口`50000`。让我们尝试用浏览器访问`http://localhost:8080`。没有反应。基本上，我们的浏览器无法打开该
    URL。
- en: This is because we haven't told to Docker to bind the container ports to the
    local ports of the host machine. In order to do that, we need to first stop the
    container and then start it again with a special parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有告诉 Docker 将容器端口绑定到主机机器的本地端口。为了做到这一点，我们需要先停止容器，然后带上一个特殊的参数重新启动它。
- en: 'Time to learn how to stop containers. We have two options here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何停止容器了。我们这里有两个选项：
- en: '**Stop the container**: With the stop option, we send `SIGTERM` to the main
    process within the container and wait for it to finish (for a grace period). Then,
    we send `SIGKILL`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止容器**：通过停止选项，我们向容器中的主进程发送`SIGTERM`信号，并等待它完成（有一个宽限期）。然后，我们发送`SIGKILL`信号。'
- en: '**Kill the container**: With the kill option, we send `SIGKILL` to the main
    process in the container, which forces an immediate exit without being able to
    save the state.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**杀死容器**：使用 kill 选项时，我们向容器中的主进程发送 `SIGKILL` 信号，这会强制容器立即退出，而无法保存状态。'
- en: 'In this case, which one you choose is irrelevant, but please be careful. When
    you are running in a production environment, make sure it''s fine to kill a container
    before doing that, as with the stop option, we are giving the running software
    the option to save the current transactions and exit gracefully. In this case,
    I am going to kill the container:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，选择哪个并不重要，但请小心。当你在生产环境中运行时，确保在执行此操作前可以安全地停止容器，因为使用停止选项时，我们允许正在运行的软件保存当前的事务并优雅地退出。在这种情况下，我将要杀死容器：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Docker is smart. I did not need to specify the full container identifier, as
    with only a few characters, Docker is able to identify the container (or the image
    in other commands) and kill it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 很聪明。我不需要指定完整的容器标识符，仅用几个字符，Docker 就能识别容器（或在其他命令中识别镜像）并将其杀死。
- en: 'If you remember from previous examples, when we kill a container, we have a
    layer left that leads into a `dead` container that we can explore, adding the
    `-a` option to the `docker ps` command. For this example, we are going to remove
    this layer as well with the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得之前的例子，当我们杀死一个容器时，会留下一个层，进入一个 `dead` 状态的容器，我们可以通过添加 `-a` 选项来探索它，使用 `docker
    ps` 命令。对于这个例子，我们也将使用以下命令删除这个层：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. The container never existed in our host.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。容器在我们的主机中从未存在过。
- en: 'Now, going back to the Jenkins example, we want to run Jenkins in a way that
    we can access the running instance from our browser. Let''s modify the preceding
    command and explain why:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 Jenkins 的例子，我们希望以一种能够从浏览器访问正在运行实例的方式来运行 Jenkins。让我们修改一下前面的命令并解释原因：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After a few seconds, if we go to `http://localhost:8080` in a browser, we should
    see the initial configuration for Jenkins, which asks for the initial password
    to be able to proceed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，如果我们在浏览器中访问 `http://localhost:8080`，我们应该能看到 Jenkins 的初始配置页面，它会要求输入初始密码才能继续。
- en: 'Let''s explain the previous command first. We can see a new option: `-p`. As
    you can guess, `-p` comes from the port. In fairness, you could change `-p` for
    `--port`, and everything will work as expected. With the `-p` option, we map ports
    from the host, your machine, to the container. In this case, we are mapping port
    `8080` from the host to port `8080` and port `50000` of the host to port `50000`
    of the container, but how can we map a different port in the host? Well, it is
    fairly simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释一下前面的命令。我们可以看到一个新选项：`-p`。如你所料，`-p` 是来自端口。实际上，你可以将 `-p` 改为 `--port`，一切照常运行。使用
    `-p` 选项，我们将主机（你的机器）上的端口映射到容器中。在这个例子中，我们将主机的端口 `8080` 映射到容器的端口 `8080`，将主机的端口 `50000`
    映射到容器的端口 `50000`，但如果我们想映射不同的主机端口，该怎么做呢？嗯，这其实非常简单：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After running the preceding command, we have two instances of Jenkins running:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，我们有两个 Jenkins 实例在运行：
- en: The first one is exposed in port `8080` of your machine
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个实例暴露在你机器的端口 `8080` 上。
- en: The second one is exposed in port `80801` of your machine
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个实例暴露在你机器的端口 `80801` 上。
- en: Note that even though we don't use port `50000`, I have changed it to `50001`
    as your machine's port `50000` is already busy with the first instance of Jenkins
    that we ran earlier on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们没有使用端口 `50000`，我将其更改为 `50001`，因为你的机器上的端口 `50000` 已经被我们之前运行的第一个 Jenkins
    实例占用。
- en: 'As you can see, Jenkins is asking for a password, and the initial web page
    in `http://localhost:8080` states that this password is in the logs or in the
    filesystem. Focusing on the logs, with Docker, we can fetch the logs for any container
    registered by the daemon at any time. Let''s try this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Jenkins 要求输入密码，而 `http://localhost:8080` 的初始网页上写明密码可以在日志或文件系统中找到。重点是日志，使用
    Docker，我们可以随时提取由守护进程注册的任何容器的日志。让我们尝试一下：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In my case, the running instance of Jenkins on port `80801` has an ID that starts
    with `11872`. Executing the previous command should retrieve the starting log
    of Jenkins that we can use for troubleshooting or, in this case, to recover the
    password to initialize Jenkins.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，运行在端口 `80801` 上的 Jenkins 实例的 ID 以 `11872` 开头。执行上述命令应该能提取 Jenkins 的启动日志，我们可以用来进行故障排除，或者在此情况下，恢复用于初始化
    Jenkins 的密码。
- en: 'Another interesting and common option in Docker is passing environment variables
    to an application running inside the container. If you think about it, there are
    only three ways in which we can configure an application within a Docker container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中另一个有趣且常见的选项是将环境变量传递给容器内运行的应用程序。如果你仔细想想，配置 Docker 容器内的应用程序只有三种方式：
- en: Environment variables
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: A volume with data
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含数据的卷
- en: Fetching the configuration from the network
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络获取配置
- en: 'Let''s take a look at the official MySQL image from the Docker Hub:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下来自 Docker Hub 的官方 MySQL 镜像：
- en: '[https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)'
- en: 'MySQL is a popular database server that has also been `dockerized`. If you
    read a bit through the documentation, one of the config options is the root password
    for the MySQL database. In fairness, the quick start example points to the right
    direction:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个流行的数据库服务器，它也已经被 `dockerized`（容器化）。如果你稍微浏览一下文档，你会发现其中的一个配置选项是 MySQL
    数据库的 root 密码。公平地说，快速入门示例指向了正确的方向：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The new option here is **`-e`**. This option allows you to pass an environment
    variable to the container with the value that you want to specify after `=`. After
    running the preceding command, we are going to run another command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新选项是 **`-e`**。这个选项允许你将环境变量传递给容器，并指定你希望设置的值，格式为 `=` 后跟值。运行完前面的命令后，我们将执行另一个命令：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, `caa40cc7d45f` is the ID that results from running MySQL on my
    machine (yours should be different). There should be a huge JSON output in the
    terminal, but one section in particular, Config, has a subsection called `Env`
    , which should look very similar to the following one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`caa40cc7d45f` 是在我的机器上运行 MySQL 时得到的 ID（你可能会得到不同的 ID）。终端中应该会输出一个巨大的 JSON，但其中有一个特别的部分，Config，里面有一个子部分叫做
    `Env`，它应该与以下内容非常相似：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There it is. The preceding environment variable that we passed, `MYSQL_ROOT_PASSWORD`,
    is now accessible from within the container as the environment variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们之前传递的环境变量 `MYSQL_ROOT_PASSWORD` 现在可以作为环境变量在容器内访问。
- en: 'In the `docker inspect` command, there is a lot of very valuable information.
    Just have a read through, as you might be surprised with how familiar you are
    with the majority of the info: it is mainly Linux terminology.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker inspect` 命令中，有很多非常有价值的信息。只要浏览一下，你可能会对其中的大部分信息感到熟悉：它主要是 Linux 术语。
- en: So far, we have visited the most common commands as of January 2017\. As you
    know, the software evolves very quickly, and by the time you are reading this
    book, new versions (such as secrets) have already been added to Docker. The best
    way to check what is going on is through the documentation on [http://www.docker.com](http://www.docker.com),
    which, in my opinion, is quite comprehensive. There is also a reference of the
    commands of your current Docker installation available under the `docker help`
    command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经浏览了截至 2017 年 1 月最常见的命令。如你所知，软件的发展非常迅速，到你阅读这本书时，Docker 已经加入了新的版本（比如
    secrets）。检查当前情况的最佳方式是通过 [http://www.docker.com](http://www.docker.com) 上的文档，在我看来，它相当全面。你当前
    Docker 安装的命令参考也可以通过 `docker help` 命令获得。
- en: Building Docker images
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'In the previous sections, we built an image using the commit command of Docker.
    Although it works, I can see a big problem with it: it is not repeatable. There
    is no easy way of rebuilding the image once and over again when the software installed
    in the image is patched due to new vulnerabilities or versions.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 Docker 的 commit 命令构建了一个镜像。虽然这方法可行，但我看到一个大问题：它不可重复。当镜像中的软件由于新漏洞或版本更新被修补时，没有一种简单的方法可以反复重建镜像。
- en: 'In order to solve this problem, Docker provides a better way of building images:
    Dockerfiles.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Docker 提供了一种更好的构建镜像的方式：Dockerfile。
- en: 'A Dockerfile is a file that contains a set of ordered commands required to
    leave the image, ready to be used. Things such as installing software or upgrading
    the version of the kernel as well as adding users are common activities that can
    be carried in a Dockerfile. Let''s look at an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个包含一组有序命令的文件，这些命令可以将镜像准备好以供使用。诸如安装软件、升级内核版本以及添加用户等常见操作都可以在 Dockerfile
    中进行。让我们来看一个例子：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you have been in the IT field for a few years, you really don''t need an
    explanation on what it is going on, but let''s make sure that we are all on the
    same page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 IT 领域工作了几年，实际上你不需要解释发生了什么，但我们还是确保大家都在同一页面：
- en: We are creating our image based on the latest Node.js image.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是基于最新的 Node.js 镜像创建镜像。
- en: A new folder is created in `/app`. Our application will be installed there.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/app` 中创建了一个新文件夹。我们的应用将安装在那里。
- en: The working directory is set to this new folder.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录被设置为这个新文件夹。
- en: Copy `package.json` and install the Node.js dependencies. Remember that we have
    already set up the working directory to `/app`, so the RUN command will be run
    in the `/app` folder.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制 `package.json` 并安装 Node.js 依赖项。记住，我们已经将工作目录设置为 `/app`，所以 `RUN` 命令将在 `/app`
    文件夹中执行。
- en: Copy the rest of the source code.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制剩余的源代码。
- en: Expose port `8080` to the outer world.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将端口 `8080` 暴露给外部世界。
- en: Run `npm start`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `npm start`。
- en: 'It is very simple once you have done it few times. One thing to keep in mind
    that might drive beginners crazy is this: `CMD` versus `RUN`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦做几次就会变得非常简单。需要记住的一点，可能会让初学者抓狂的是：`CMD` 和 `RUN` 的区别。
- en: 'In the preceding Dockerfile, sometimes, we use `RUN`, and sometimes, we use
    `CMD`, but both of them seem to do the same thing: run a command. There is one
    difference:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Dockerfile 中，我们有时使用 `RUN`，有时使用 `CMD`，但它们似乎执行相同的操作：运行一个命令。其实有一个区别：
- en: '`RUN`: This will run the command when building the image'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：在构建镜像时运行此命令。'
- en: '`CMD`: This will run the command when the container based on the generated
    image starts'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：这将在基于生成的镜像启动的容器中运行该命令。'
- en: Also, `RUN` (generally) creates a new layer, whereas `CMD` uses the writable
    layer of the container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`RUN`（通常）会创建一个新的层，而 `CMD` 使用容器的可写层。
- en: 'Now, it''s time to test the Dockerfile from earlier. Before building the image,
    we need to build a small Node.js application that is going to be used as the software
    running in the image. Create a new folder with three files:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试之前的 Dockerfile 了。在构建镜像之前，我们需要构建一个小的 Node.js 应用程序，这个程序将作为镜像中运行的软件。创建一个新文件夹并添加以下三个文件：
- en: '`package.json`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '`index.js`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`'
- en: Dockerfile (the one from before)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile（之前的那个）
- en: 'The content of `package.json` will be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`的内容如下：'
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The content of `index.js` will be as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 的内容如下：'
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And now, with the preceding files and the Dockerfile described before in the
    same folder, run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将之前的文件和之前描述的 Dockerfile 放在同一个文件夹中，运行以下命令：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After a few seconds, your image would be ready for use. Let''s check it. If
    you list your images with the `docker images` command, you should see an image
    called `my-node-app`. Now create a container based on the image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您的镜像将准备好使用。让我们检查一下。如果您使用`docker images`命令列出您的镜像，应该可以看到一个名为`my-node-app`的镜像。现在基于这个镜像创建一个容器：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see something similar to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的内容：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the highlighted section, the output of running our application
    is here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在高亮部分，我们的应用程序输出显示在这里。
- en: Dockerfile reference
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 参考
- en: As you can see in the previous section, Dockerfiles are very simple, and if
    you have any queries, the official documentation for the Dockerfile language is
    very comprehensive.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Dockerfile 非常简单，如果有任何疑问，Dockerfile 语言的官方文档非常详尽。
- en: In general, the language used for creating Dockerfiles is very similar to the
    batch processing language of windows (`.bat` files) from a few years ago.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，创建 Dockerfile 使用的语言非常类似于几年前 Windows 的批处理语言（`.bat` 文件）。
- en: 'Let''s look at the most used commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下最常用的命令：
- en: '| `FROM` | This instruction is used to specify the base image. Every single
    Docker image is created starting from a base image (you can create base images
    from a running Linux distribution). |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` | 该指令用于指定基础镜像。每个 Docker 镜像都是从基础镜像开始创建的（您可以从正在运行的 Linux 发行版创建基础镜像）。
    |'
- en: '| `COPY` | As you can guess, `COPY` allows you to copy files and folders inside
    the image. For example, we could copy our application, a war file, or any other
    artifact that will be packed with the image once it is distributed. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `COPY` | 如你所料，`COPY` 允许你将文件和文件夹复制到镜像中。例如，我们可以将我们的应用程序、war 文件或任何其他将在镜像分发时一起打包的工件复制进去。
    |'
- en: '| `ADD` | This does the exactly the same thing as `COPY` but with three differences:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ADD` | 这个指令与 `COPY` 完全相同，但有三个不同之处：'
- en: The origin of the files could be a URL that gets downloaded before copying
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的来源可以是一个在复制之前下载的 URL。
- en: The origin of the files could be a packed file (such as a TAR file) that will
    be unpacked in the image filesystem
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的来源可以是一个打包文件（例如TAR文件），该文件将在镜像文件系统中解压。
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `RUN` | This runs a command in the image. For example, it can be used to
    install software in the image. It always creates a new layer in the Docker image,
    so be careful and keep the `RUN` commands to a minimum. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `RUN` | 该命令在镜像中运行一个命令。例如，它可以用来在镜像中安装软件。它每次都会在Docker镜像中创建一个新的层，因此要小心，并尽量将`RUN`命令保持在最低限度。
    |'
- en: '| `CMD` | This is the default command to be run when the image gets instantiated
    as a container. As you can see in the preceding example, we are using `CMD` to
    execute `npm start`, which runs `node index.js` (refer to `package.json`). It
    does not create a new layer as it uses the top writable layer to store the changes.
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `CMD` | 这是当镜像实例化为容器时运行的默认命令。正如在前面的例子中所看到的，我们使用`CMD`来执行`npm start`，该命令会运行`node
    index.js`（参考`package.json`）。它不会创建新层，因为它使用顶部的可写层来存储更改。 |'
- en: '| `ENTRYPOINT` | `ENTRYPOINT` is similar to `CMD`, but it overrides the default
    command on a docker image that is `/bin/sh -c`. In order to override an specified
    entry point, you need to pass the `--entrypoint` flag when running an instance
    of the image. `ENTRYPOINT` is ideal for configuring containers as command-line
    tools, as you can pack a fairly complex command with a fairly complex setup in
    a single container. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` | `ENTRYPOINT`类似于`CMD`，但它会覆盖docker镜像中的默认命令`/bin/sh -c`。为了覆盖指定的入口点，你需要在运行镜像实例时传递`--entrypoint`标志。`ENTRYPOINT`非常适合将容器配置为命令行工具，因为你可以将一个相当复杂的命令和复杂的设置打包在一个容器中。
    |'
- en: '| `MAINTAINER` | With `MAINTAINER`, you can specify who is the maintainer of
    the image (also specify the email). |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `MAINTAINER` | 使用`MAINTAINER`，你可以指定镜像的维护者（还可以指定电子邮件）。 |'
- en: '| `EXPOSE` | This exposes the port specified in the first parameter so that
    the container can listen to it. It actually does not expose the port in the `docker`
    client host, forcing the user to pass the `-p` flag in order to access the given
    port. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` | 该命令暴露了第一个参数指定的端口，以便容器可以监听该端口。实际上，它并不会在`docker`客户端主机上暴露该端口，因此用户必须传递`-p`标志才能访问指定的端口。
    |'
- en: With these commands, you can build pretty much anything that you want, and particularly
    with `RUN`, this allows the user to run any command within the container that
    enables us to run scripts (`python`, `bash`, and `ruby`.) or even install software
    using package managers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些命令，你几乎可以构建任何你想要的内容，尤其是`RUN`命令，它允许用户在容器内运行任何命令，使我们能够运行脚本（如`python`、`bash`和`ruby`）或使用包管理器安装软件。
- en: Aside from the preceding instructions, the Dockerfile language also comes with
    support for adding environment variables, volumes, and a few other features that
    make it quite powerful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述指令外，Dockerfile语言还支持添加环境变量、卷以及其他一些功能，使其功能非常强大。
- en: Docker registries
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 仓库
- en: In the previous section, we created a new image with our application installed
    and ready to be used (in this case, a very simple `Hello world` Node.js application).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个安装并准备好使用的全新镜像（在这个例子中，是一个非常简单的`Hello world` Node.js应用程序）。
- en: Now, we need to distribute the image so it can be installed in all the stages
    of our deployment pipeline or even used by other developers. Docker is interesting
    for running applications but it is also a very interesting choice to create command-line
    tools that other developers can benefit from.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要分发这个镜像，以便它可以在我们部署管道的所有阶段安装，或者甚至供其他开发者使用。Docker不仅适用于运行应用程序，它也是一个非常有趣的选择，用来创建其他开发者也能受益的命令行工具。
- en: 'In order to distribute images, we have to rely on exporting/importing the image
    or using a registry. A registry is basically a software that allows us to store
    and distribute Docker images. There are two types of registries:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分发镜像，我们必须依赖导出/导入镜像或使用仓库。仓库基本上是一种软件，允许我们存储和分发Docker镜像。仓库有两种类型：
- en: Public registries
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共仓库
- en: Private registries
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有仓库
- en: Let's take a look at the different registry types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的仓库类型。
- en: Public registries
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共仓库
- en: The most known of the public registries is Docker Hub. It is the official and
    default registry that every Docker installation knows of. Also, it offers private
    repositories, but the most interesting feature is the fact that all the official
    images are available on Docker Hub.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的公共仓库是Docker Hub。它是每个Docker安装都默认知道的官方仓库。此外，它还提供私有仓库，但最有趣的功能是所有官方镜像都可以在Docker
    Hub上获取。
- en: 'Let''s see how can we use it. First, you need to create an account. Once you
    are registered, create a new repository:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用它。首先，您需要创建一个账户。注册后，创建一个新的仓库：
- en: '![](img/e20dfccf-d186-422b-b4bc-f5a6c8e20a53.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e20dfccf-d186-422b-b4bc-f5a6c8e20a53.png)'
- en: 'This repository hosts an image called `modern-devops`, and we are going to
    push one image into it. Once it is created, you can see that Docker Hub suggests
    that you pull the image with the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库托管了一个名为`modern-devops`的镜像，我们将向其中推送一个镜像。一旦创建完成，您可以看到Docker Hub建议您使用以下命令来拉取镜像：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In your case, `dagonzadub` will need to be replaced with your username. Obviously,
    we are not going to pull an image that is not there yet, so let''s push an image.
    In the previous section, we created an image called `my-node-app`. We are going
    to use this image to test Docker Hub. Docker relies on a tag system to know where
    to push the image or where to pull from. As we are working with the `default`
    registry, we don''t need to specify the URL, but we need to specify the user and
    the repository name. If you haven''t deleted the image created in the previous
    section, run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的情况下，`dagonzadub`需要替换成您的用户名。显然，我们不会拉取一个还不存在的镜像，所以我们先推送一个镜像。在前面的部分，我们创建了一个名为`my-node-app`的镜像。我们将使用这个镜像来测试Docker
    Hub。Docker依赖标签系统来知道将镜像推送到哪里或从哪里拉取。由于我们正在使用`default`注册表，因此无需指定URL，但需要指定用户和仓库名称。如果您没有删除之前创建的镜像，请运行以下命令：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then, run this command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行这个命令：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After a few seconds (depending on your upload speed, even minutes), your image
    is available on Docker Hub. As we marked it as `public`, everybody can pull and
    use your image.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后（根据您的上传速度，可能几分钟），您的镜像就会出现在Docker Hub上。由于我们将其标记为`public`，任何人都可以拉取并使用您的镜像。
- en: Private registries
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有注册表
- en: But what happens if we want to store our images in our private registry within
    our infrastructure?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想将镜像存储在我们基础设施中的私有注册表里会发生什么呢？
- en: Well, we have some options. If we are using cloud providers, such as Google
    Cloud Platform or Amazon Web Services, they provide a Docker registry that is
    only accessible from within your account, and you can specify the region in which
    your images live (remember, the type of data that we are handling might be under
    strict compliance rules about where we should store the data).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们有一些选择。如果我们使用云服务提供商，例如Google Cloud Platform或Amazon Web Services，它们提供的Docker注册表仅在您的账户内可以访问，您还可以指定镜像所在的区域（记住，我们处理的数据类型可能需要遵守严格的合规规则，规定我们应该存储数据的位置）。
- en: In AWS, the container registry is called **EC2 Container Registry** (**ECR**),
    and in GCP, it is called a container registry. If your infrastructure is in one
    of these private clouds, I encourage you to use it as you can leverage the access
    to the access controls provided by the platforms.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中，容器注册表被称为**EC2容器注册表**（**ECR**），在GCP中，它被称为容器注册表。如果您的基础设施在这些私有云平台之一，我鼓励您使用它，因为您可以利用平台提供的访问控制。
- en: Sometimes, we might find ourselves in a situation where we cannot use a cloud
    provider as our system has to be built on premises. This is when we need to use
    a private on-premises Docker registry.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会发现自己处于无法使用云服务提供商的情况，因为我们的系统必须部署在本地。这时，我们就需要使用一个私有的本地Docker注册表。
- en: Nowadays, there are quite a few options, but it is highly likely that the market
    widens in the coming months or years as the companies are using Docker more and
    more.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，市场上有很多选项，但很可能随着越来越多的公司使用Docker，未来几个月或几年市场会进一步扩大。
- en: 'From all the range of registries, there are three that I find particularly
    interesting:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的注册表选项中，有三个我特别感兴趣：
- en: '**Quay**: This is a complete registry in the current market (at the time of
    writing this). It has some interesting features, but the one that is probably
    the most interesting is the ability to scan the images searching for security
    vulnerabilities in the installed software. It can also build images based on changes
    in your git repository, so if your Dockerfile is altered in GitHub, Quay will
    automatically trigger a build and deploy the new version of the image. Quay is
    not free, so a license has to be paid in order to use it.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quay**：这是目前市场上的一个完整注册表（截至本文写作时）。它有一些有趣的功能，其中可能最有趣的是能够扫描镜像，寻找已安装软件的安全漏洞。它还可以根据您的git仓库中的变化构建镜像，因此如果您的Dockerfile在GitHub中被修改，Quay会自动触发构建并部署新的镜像版本。Quay并非免费，使用它需要购买许可证。'
- en: '**Registry**: This is the plain name for a plain concept. It is the official
    implementation of the registry API and comes packed in a container. It has no
    interface or access controls by default, but it does the job. It also provides
    storage management drivers, so we can deploy our images to S3 or Google Cloud
    Storage buckets as well as many other options. Registry is free and can be pulled
    from Docker Hub.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册表**：这是一个普通概念的简单名称。它是注册表API的官方实现，并以容器的形式打包。它默认没有界面或访问控制，但它完成了工作。它还提供存储管理驱动程序，因此我们可以将镜像部署到S3或Google
    Cloud Storage的存储桶中，以及许多其他选项。Registry是免费的，可以从Docker Hub拉取。'
- en: 'Docker Trusted Registry: This is part of the enterprise version of Docker.
    Like pretty much any other commercial registry, it provides static container analysis
    as well as storage management drivers. **Docker Trusted Registry** (**DTR**) is
    not free, so a license has to be paid for in order to use it.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Trusted Registry：这是Docker企业版的一部分。像几乎所有其他商业注册表一样，它提供静态容器分析以及存储管理驱动程序。**Docker
    Trusted Registry**（**DTR**）不是免费的，因此需要支付许可证费用才能使用。
- en: Docker volumes
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker数据卷
- en: So far, we have seen how to create images, how to store the images in a registry,
    and how Docker images work in general (layers and containers versus images).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何创建镜像，如何将镜像存储到注册表中，以及Docker镜像的工作原理（层和容器与镜像的区别）。
- en: An important part of any application is the storage. In general, Docker applications
    should be stateless, but with the new orchestration software, such as Kubernetes,
    Docker Swarm, and similar, every day, more and more engineers are moving toward
    containerized databases.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的一个重要部分就是存储。通常情况下，Docker应用程序应该是无状态的，但随着新的编排软件的出现，例如Kubernetes、Docker Swarm等，越来越多的工程师正在朝着容器化数据库的方向发展。
- en: 'Docker solves this problem in a very elegant way: you can mount a folder from
    the local machine into the container as if it were a normal folder.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Docker以一种非常优雅的方式解决了这个问题：你可以像使用普通文件夹一样，将本地机器中的文件夹挂载到容器中。
- en: This is a very powerful abstraction as it leverages the ability to push data
    out of the container to be saved into a **Network Attached Storage** (**NAS**)
    or any other storage technology (it is possible to use a bucket in the Google
    Cloud Storage or S3 as the volume mounted in a container).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的抽象，因为它利用了将数据从容器中推送出来并保存到**网络附加存储**（**NAS**）或任何其他存储技术的能力（可以使用Google
    Cloud Storage或S3中的存储桶作为容器中挂载的数据卷）。
- en: 'Let''s start with the basics. Just run a MySQL database:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始。先运行一个MySQL数据库：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works. It actually does what is expected: it launches a container with
    a mysql instance in it. The problem is that all the data is going to be written
    to **`/var/lib/mysql`** and this folder is mapped to the top writable layer of
    the container (remember, in the previous section, we explained the difference
    between a container and an image). The only way to save data is actually committing
    the changes and create a new image that is not manageable and, of course, this
    not the way you want to do it. Think about it: if you remove a file in Docker,
    you are doing it in the top layer, which is the only one writable, so in reality,
    you are not removing the file; you are just hiding it. The file is in one of the
    layers using the space but it is not visible. Docker records differences and a
    layer itself is a set of differences from the previous stacked layers (think about
    how Git works; it is the same principle).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。它实际上做到了预期的功能：它启动了一个包含mysql实例的容器。问题是，所有数据都将写入**`/var/lib/mysql`**，而这个文件夹被映射到容器的顶部可写层（记住，在前一节中，我们解释了容器和镜像的区别）。保存数据的唯一方法实际上是提交更改并创建一个新的镜像，但这并不可管理，当然，这不是你想要的做法。想一想：如果你在Docker中删除了一个文件，实际上是在顶部层进行的操作，而这个层是唯一可写的，因此实际上你并没有删除文件；你只是把它隐藏了。文件依然存在于某一层中，占用了空间，但不可见。Docker记录的是差异，每一层本身就是上一层的差异集（想一想Git是如何工作的；原理是一样的）。
- en: 'Instead of committing the changes into a new image, we are going to mount a
    folder from our docker host into the container. Let''s alter the previous command
    a bit:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算将更改提交到新的镜像中，而是将docker主机中的一个文件夹挂载到容器中。让我们稍微修改一下之前的命令：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we have a new flag, `-v`, followed by the `data:/var/lib/mysql` value.
    The meaning of the command is very simple: mount the `/home/david/data` folder
    into the `/var/lib/mysql` path of my container.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新的标志`-v`，后面跟着`data:/var/lib/mysql`的值。命令的含义非常简单：将`/home/david/data`文件夹挂载到我的容器的`/var/lib/mysql`路径下。
- en: 'As you can guess, the data folder, in my case, `/home/david/data`, should be
    present in your current directory, so if it wasn''t present, create it or modify
    the path to suit your setup and launch the container. This use case can only be
    achieved through the `-v` flag: mount a selected folder from the host into the
    container.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，数据文件夹，在我的例子中是`/home/david/data`，应该存在于你当前的目录中，因此如果它不存在，请创建它或修改路径以适应你的设置，然后启动容器。这个用例只能通过`-v`标志实现：将主机中的选定文件夹挂载到容器中。
- en: 'Now, execute `ls` inside the data folder (in the Docker host):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在数据文件夹中执行`ls`命令（在 Docker 主机中）：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see how `mysql` has actually written data files corresponding to the
    databases created in bootstrap.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`mysql`实际上已经写入了与启动时创建的数据库对应的数据文件。
- en: Docker volumes are not limited to one per container, so you can replicate the
    **`-v`** flag as many times as you need in order to match your requirements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷不限于每个容器一个，因此你可以根据需要多次使用**`-v`**标志，以满足你的需求。
- en: 'Another way of mounting a shared folder between the container and the host
    is just specifying the path inside the container:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种挂载容器与主机之间共享文件夹的方式是直接指定容器内的路径：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command will mount a folder from our Docker host into the container, but
    the folder in the `docker` host will be managed by the storage driver and `docker`
    itself:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将会从我们的 Docker 主机挂载一个文件夹到容器中，但在 Docker 主机中的文件夹将由存储驱动程序和`docker`本身管理：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is familiar. We have seen it before in the previous sections, but
    now we are looking for different information. We are actually looking for a section
    called `Mounts`, which looks like this (at least similar to it):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是熟悉的。我们之前在前面的章节中见过它，但现在我们要寻找不同的信息。我们实际上在寻找一个名为`Mounts`的部分，类似下面这样（至少类似）：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is also possible through the `VOLUME` instruction in a Dockerfile.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过 Dockerfile 中的`VOLUME`指令实现。
- en: 'The preceding JSON is telling us which local folder is going to be mounted
    in the container (the `Source` value of the JSON) and provides an interesting
    insight: the volume has been named by `docker` (the `Name` value of the JSON).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 JSON 告诉我们哪个本地文件夹将被挂载到容器中（JSON 的`Source`值），并提供了一个有趣的洞察：卷已经被`docker`命名（JSON
    的`Name`值）。
- en: 'This means that Docker tracks the volumes that are (or have been) mounted in
    any container and can be listed through an API call:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Docker 跟踪所有（或曾经）挂载在任何容器中的卷，并且可以通过 API 调用列出它们：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should produce output similar to the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似以下的输出：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can guess, we can also create volumes through an `api` call:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，我们也可以通过`api`调用创建卷：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This volume is created in the same way as the previous example: it is up to
    Docker to decide which folder on the local machine is going to be mounted in the
    specified path in the container, but in this case, first, we are creating the
    volume and then mounting it to a container. You can even inspect the volume:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个卷的创建方式与前一个例子相同：由 Docker 来决定将本地机器上的哪个文件夹挂载到容器中的指定路径，但在这种情况下，我们首先创建卷，然后将其挂载到容器。你甚至可以检查这个卷：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And this should return you something similar to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回类似下面的内容：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use this named resource and mount it into our containers, just referencing
    the name:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个命名资源并将其挂载到我们的容器中，只需引用名称即可：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The last (but not least) interesting use case in volumes helps us share the
    configuration across different containers. Just imagine that you have a fairly
    complex setup that leads to a gigantic Docker command with several `-v`. Docker
    provides us with a much simpler way of sharing volume configuration across containers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个（但同样重要的）有趣用例是在卷中帮助我们在不同的容器间共享配置。想象一下，你有一个相当复杂的设置，导致 Docker 命令非常庞大，带有多个`-v`。Docker
    为我们提供了一个更简单的方式来跨容器共享卷配置：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is very simple and intuitive: `my-mysql-5` will spawn with the volume
    configuration of `my-mysql-4`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单直观：`my-mysql-5`将以`my-mysql-4`的卷配置启动。
- en: Docker networking
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络
- en: 'Networking is an important part of Docker. By default, Docker comes with three
    networks that we can inspect by executing the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是 Docker 的一个重要部分。默认情况下，Docker 提供了三个网络，我们可以通过执行以下命令来查看它们：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This should produce output similar to the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似以下的输出：
- en: '![](img/d45651ef-61a5-4658-8040-8f9b1144dd2b.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d45651ef-61a5-4658-8040-8f9b1144dd2b.png)'
- en: 'Let''s explain the different networks:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下不同的网络：
- en: '`bridge`: This is the default network. It is an entirely different stack from
    the host machine with a different IP range in the `bridge` mode (the host machine
    acts as a `router` for the containers in this network). The containers created
    without specifying the network are attached to the default bridge network.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge`: 这是默认网络。它与主机机器完全不同，具有不同的 IP 范围，在桥接模式下（主机机器作为容器的“路由器”）。创建时未指定网络的容器会附加到默认的桥接网络。'
- en: '`host`: In this network, containers share the network stack with the Docker
    host. If you inspect the configuration in the container, you will find that it
    is the exactly the same as in the Docker host.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`: 在这个网络中，容器与 Docker 主机共享网络堆栈。如果您检查容器中的配置，您会发现它与 Docker 主机中的配置完全相同。'
- en: '`none`: This is easy to guess; the container gets attached to no network: just
    the loopback interface in the container.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 这很容易猜到；容器未连接到任何网络，只连接到容器中的回环接口。'
- en: Now it is time to look at some examples. We are going to use `busybox`, which
    is the `swiss` army knife of the Docker images. It has several Unix tools that
    we could benefit from, but in this case, the characteristic that is going to benefit
    us is the fact that it is a functional Linux on a reduced space.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是看一些示例的时候了。我们将使用 `busybox`，它是 Docker 映像的“瑞士军刀”。它有几个 Unix 工具，我们可以从中受益，但在这种情况下，我们将从中受益的特性是它是一个功能齐全的
    Linux，并且占用空间较小。
- en: 'Let''s run the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you have followed the previous sections, by now, you can understand the
    outcome: we gain root access to a running container.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经按照前面的部分操作，现在您应该能够理解结果：我们获得了正在运行的容器的 root 访问权限。
- en: 'The next step is to execute `ifconfig` inside the container. It should give
    us two interfaces:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是在容器内部执行 `ifconfig` 命令。它应该会给我们两个接口：
- en: '`- eth0 - 172.17.0.2`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`- eth0 - 172.17.0.2`'
- en: '`- lo - 127.0.0.1`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`- lo - 127.0.0.1`'
- en: The IP might change, but you should see these two interfaces. Comparing the
    IP with the IP in your Docker host, we can validate the fact that the container
    is running in the bridge network as the IP and network are completely different;
    in my case, the IP on my Docker host is `10.0.0.12`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: IP 可能会改变，但您应该看到这两个接口。将 IP 与 Docker 主机上的 IP 进行比较，我们可以验证容器正在桥接网络中运行，因为 IP 和网络完全不同；在我的情况下，我的
    Docker 主机上的 IP 是 `10.0.0.12`。
- en: 'Now, let''s spawn another container with `busybox` in a different terminal:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在另一个终端中使用 `busybox` 来生成另一个容器：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By now, we should have two `busybox` instances running, and they should have
    consecutive IPs, in my case, `172.17.0.2` and `172.17.0.3`. If you go back to
    the terminal of the first instance of `busybox`, you can ping the second container
    by IP. This is because they both belong (or are connected to) the same network,
    which is the default bridge one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有两个正在运行的 `busybox` 实例，并且它们应该具有连续的 IP 地址，在我的情况下是 `172.17.0.2` 和 `172.17.0.3`。如果您回到第一个
    `busybox` 实例的终端，您可以通过 IP 地址对第二个容器进行 ping 测试。这是因为它们都属于（或连接到）相同的网络，即默认的桥接网络。
- en: In order to run the containers in the host network, we just need to pass `--network=host
    flag` to the `docker run` command and that's it; our container is sharing the
    network stack with the Docker host, but be careful, if you are on Mac or Windows.
    The Docker host is a virtual machine so don't attempt to access it through localhost;
    you will need to find the IP of the virtual machine running `docker`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主机网络中运行容器，我们只需将 `--network=host` 标志传递给 `docker run` 命令，就可以了；这样我们的容器将与 Docker
    主机共享网络堆栈，但是要注意，如果您使用的是 Mac 或 Windows，则 Docker 主机是一个虚拟机，所以不要尝试通过 localhost 访问它；您需要找到运行
    `docker` 的虚拟机的 IP 地址。
- en: User-defined networks
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的网络
- en: It is also possible to create custom and isolated networks in Docker. This is
    interesting from the security point of view, as it enables us to segregate different
    containers on the network level so we can enforce a higher level of access control.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中也可以创建自定义的隔离网络。从安全角度来看，这是很有意思的，因为它使我们能够在网络层面上隔离不同的容器，从而可以强制执行更高级别的访问控制。
- en: 'In order to create a network, we just need to execute the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建网络，我们只需执行以下命令：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And that's it. Well, that is a simplistic approach, but it works as expected.
    As you know, networking is a complicated subject, so Docker provides options to
    customize ranges, masks, and other parameters. The user-defined networks are of
    the type bridge.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这是一个简单的方法，但效果如预期。正如您所知，网络是一个复杂的主题，因此 Docker 提供了自定义范围、掩码和其他参数的选项。用户定义的网络类型为桥接。
- en: 'Once the network is created, you can run new containers in that network, as
    follows (on a new terminal):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网络创建完成，你可以在该网络中运行新的容器，如下所示（在一个新终端中）：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As expected, these containers will be isolated from the other networks. In this
    case, the two containers are launched in the `bridge` network. In my case, the
    third container (the one just launched) has the IP `172.19.0.2`, whereas the two
    launched in the bridge network are `172.17.0.2` and `172.17.0.3`. Issuing a ping
    command between containers in different networks results in 100% packet loss.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，这些容器将与其他网络隔离。在这种情况下，这两个容器是启动在 `bridge` 网络中的。以我的情况为例，第三个容器（刚刚启动的那个）IP 地址是
    `172.19.0.2`，而启动在桥接网络中的两个容器分别是 `172.17.0.2` 和 `172.17.0.3`。在不同网络的容器之间执行 ping 命令会导致
    100% 丢包。
- en: Docker Compose
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: The majority of the time, Docker is synonymous to microservices. Running a big
    monolithic application in Docker does not make too much sense as the whole Docker
    Engine is thought to be running big applications split into different and smaller
    services. There is no technical limitation to running a monolithic app on Docker,
    but when the orchestration software comes into place (in the following chapters),
    it really defeats the purpose of containerization.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，Docker 就是微服务的代名词。在 Docker 中运行一个大型单体应用没有太大意义，因为整个 Docker 引擎是为了运行拆分成不同小服务的大型应用程序而设计的。虽然在
    Docker 上运行单体应用没有技术限制，但当容器编排软件介入时（在后续章节中介绍），这就真的违背了容器化的目的。
- en: When dealing with microservices, it is very common to have several services
    running at the same time when developing, as the new services will lean on the
    existing ones to execute operations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理微服务时，开发过程中通常会同时运行多个服务，因为新服务需要依赖现有服务来执行操作。
- en: In order to achieve this setup, Docker facilitates a tool called `docker-compose`
    that, by creating a YAML file with the definition of our containers, can spawn
    a full ecosystem of containers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一设置，Docker 提供了一个名为 `docker-compose` 的工具，通过创建一个定义容器的 YAML 文件，它可以启动一个完整的容器生态系统。
- en: Docker compose used to be very popular in the beginning of Docker. Nowadays,
    it is still widely used, but its space has been slowly reduced to development
    stages as the container orchestration tools in Kubernetes have taken over the
    production space.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 曾在 Docker 初期非常流行。如今，它仍然被广泛使用，但随着 Kubernetes 容器编排工具接管了生产环境的工作，它的使用范围逐渐缩小至开发阶段。
- en: 'Let''s look at how Docker Compose works:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 Docker Compose 是如何工作的：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding YAML file is a `docker-compose` definition. As you can guess,
    there are two components:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 YAML 文件是一个 `docker-compose` 定义。如你所见，它包含了两个组件：
- en: A web application (the current folder)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 web 应用程序（当前文件夹）
- en: A database (postgres)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库（postgres）
- en: Save the file to a folder with the name `docker-compose.yaml`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存到名为 `docker-compose.yaml` 的文件夹中。
- en: 'This is a typical case of an application connecting to a database. In order
    to simplify this, our application is just going to be a dummy application (no
    database connection) with the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用程序连接数据库的典型案例。为了简化起见，我们的应用程序将只是一个虚拟应用（没有数据库连接），代码如下：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And our Dockerfile is very simple:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们的 Dockerfile 非常简单：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This Dockerfile will install the required dependencies and run `npm start` in
    the root of our app folder.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 会安装所需的依赖并在我们的应用文件夹根目录下运行 `npm start`。
- en: 'As you can see, the application is very simple, and it only tries to resolve
    the name `db` instead of connecting to the database (in fairness, we didn''t even
    specify the ports for connecting to it). We are going to demonstrate how `docker-compose`
    wires up the containers. By now, there should be four files in the work folder:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，应用程序非常简单，它仅仅尝试解析名称 `db`，而不是连接到数据库（公平地说，我们甚至没有指定连接数据库的端口）。我们将演示 `docker-compose`
    如何连接容器。到目前为止，工作文件夹中应该有四个文件：
- en: '`index.js`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`'
- en: '`package.json`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: Dockerfile
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '`docker-compose.yaml`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose.yaml`'
- en: 'Going back to our `docker-compose` file, we can see that in the `my_app` definition,
    we ask to build the current folder (build the image described by the Dockerfile),
    and we specify that the container itself is dependent on another container called
    `db`. This makes Docker take action and connect the two containers, being able
    to reach `db` from `my-app` by name. In order to achieve this, there is an entry
    created in `/etc/hosts` with the IP of `db`, so we `my-app` will be able to resolve
    it. Docker compose is very easy to understand: it is nearly self-explanatory,
    and the fact that it makes use of YAML makes everything so much more readable.
    Now we need to run it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `docker-compose` 文件，我们可以看到在 `my_app` 的定义中，我们要求构建当前文件夹（构建 Dockerfile 描述的镜像），并且我们指定容器本身依赖另一个名为
    `db` 的容器。这使得 Docker 执行操作并连接这两个容器，从而能够通过名称从 `my-app` 访问 `db`。为了实现这一点，`/etc/hosts`
    中创建了一个条目，记录了 `db` 的 IP 地址，这样 `my-app` 就能解析它。Docker Compose 非常容易理解：它几乎是自解释的，并且使用
    YAML 格式使得一切变得更加可读。现在我们需要运行它：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once it finishes, there should be a quite a long output, but there are some
    lines that indicate our success:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，它应该会输出很长的一段内容，但有些行会显示我们的成功：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The highlighted section tells us that `my_app` is able to reach db by IP as
    they are on the same bridge network. Let''s see what happened here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分告诉我们，`my_app` 能通过 IP 访问 db，因为它们位于同一个桥接网络上。我们来看看这里发生了什么：
- en: Docker built the image for the current folder (as specified in `my_app`) from
    the Dockerfile
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 从 Dockerfile 构建了当前文件夹（如 `my_app` 中指定的）的镜像
- en: Docker pulled the `postgres` image from the Docker Hub
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 从 Docker Hub 拉取了 `postgres` 镜像
- en: 'Docker started the images in order: first `db` and second `my_app`, as specified
    in the dependencies'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 按顺序启动了镜像：首先是 `db`，其次是 `my_app`，如依赖关系中所指定的
- en: In this book, we are going to give a special emphasis to orchestration technologies,
    and then we will come back to Docker Compose in [Chapter 5](820e2d41-3917-4d4c-ad80-461fc133740b.xhtml),
    *Infrastructure as Code,* where we will take a deep dive into Docker Swarm, which
    is where compose becomes really helpful.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将特别强调编排技术，接着我们将在[第五章](820e2d41-3917-4d4c-ad80-461fc133740b.xhtml)《基础设施即代码》中回到
    Docker Compose，届时我们将深入探讨 Docker Swarm，这时 Compose 变得非常有用。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we walked through Docker from the internals to the command-line
    interface to operate a Docker host. Now, we have enough knowledge to understand
    the consequences and benefits of running Docker in production. We have not looked
    into how to develop Docker plugins as well as different storage drivers, as unfortunately,
    we have a limited amount of space in this book to introduce the most interesting
    concepts, but we have dived deep enough into Docker to be able to learn more from
    the resources (official documentation, videos, and so on) available to us on the
    Internet.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从内部结构到命令行界面走访了 Docker，学习了如何操作 Docker 主机。现在，我们有足够的知识来理解在生产环境中运行 Docker
    的后果和好处。我们没有讨论如何开发 Docker 插件以及不同的存储驱动，因为不幸的是，本书的篇幅有限，无法介绍所有有趣的概念，但我们已经深入探讨了 Docker，足以通过网络上可用的资源（官方文档、视频等）进一步学习。
- en: 'In the next chapter, we will have a look on how to automate tasks around our
    software: running tests, building images and many other tasks that shouldn''t
    be done manually. This automation is called **continuous integration** because
    allows our team to integrate new features on a seamless way.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究如何围绕我们的软件自动化任务：运行测试、构建镜像以及其他许多不应手动完成的任务。这种自动化被称为 **持续集成**，因为它允许我们的团队以无缝的方式集成新特性。
