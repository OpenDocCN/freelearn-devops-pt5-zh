<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Going Modular with Ansible Roles</h1></div></div></div><p>In the last chapter, you learned about writing a simple playbook with Ansible. You also learned about the concepts of plays which map hosts to tasks. Writing tasks in a single playbook may work fine for a very simple setup. However, if we have multiple applications spanning across number of hosts, this will quickly become unmanageable.</p><p>In this chapter, you will be introduced to the following concepts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What makes a role and what are roles used for?</li><li class="listitem" style="list-style-type: disc">How to create roles to provide abstraction?</li><li class="listitem" style="list-style-type: disc">Organizing content to provide modularity</li><li class="listitem" style="list-style-type: disc">Using include statements</li><li class="listitem" style="list-style-type: disc">Writing simple tasks and handlers</li><li class="listitem" style="list-style-type: disc">Installing packages, managing services, and serving files with Ansible modules</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Understanding roles</h1></div></div></div><p>In real-life scenarios, we <a id="id31" class="indexterm"/>will mostly be configuring web servers, database servers, load balancers, middleware queues, and so on. If you take one step back and look at the big picture, you will realize that you are configuring groups of identical servers in a repeatable fashion.</p><p>To manage such infrastructures in the most efficient way, we need some abstraction which allows us to define what we need to configure in each of these groups, and call them by name. That's exactly what roles do. Ansible roles allow us to configure groups of nodes at the same time, without repeating ourselves. Roles also provide a way to create modular code, which then can <a id="id32" class="indexterm"/>then be shared and reused.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Naming roles</h1></div></div></div><p>A common <a id="id33" class="indexterm"/>practice is to create roles that map to each application or component of your infrastructure that you would like to configure. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Nginx</li><li class="listitem" style="list-style-type: disc">MySQL</li><li class="listitem" style="list-style-type: disc">MongoDB</li><li class="listitem" style="list-style-type: disc">Tomcat</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The directory layout for roles</h1></div></div></div><p>Roles are nothing <a id="id34" class="indexterm"/>but directories laid out in a specific manner. Roles follow predefined directory layout conventions and expect each component to be in the path meant for it.</p><p>The following is an example of a role, called Nginx:</p><div><img src="img/B03800_02_01.jpg" alt="The directory layout for roles"/></div><p>Let's now look at the rules of the game and what each of the components in the preceding diagram is for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each role contains a directory which is named after itself, for example, <code class="literal">Nginx</code>, with <code class="literal">roles/</code> as its parent directory. Each named role directory contains one or more optional subdirectories. The most common subdirectories to be present are tasks, templates, and handlers. Each of these subdirectories typically contain the <code class="literal">main.yml</code> file, which is a default file.</li><li class="listitem" style="list-style-type: disc">Tasks contain the core logic, for example, they will have code specifications to install packages, start services, manage files, and so on. If we consider a role to be a movie, a task would be the protagonist.</li><li class="listitem" style="list-style-type: disc">Tasks alone cannot do everything. Considering our analogy with movies, it's incomplete without the supporting cast. Protagonists have friends, cars, lovers, and <a id="id35" class="indexterm"/>antagonists to complete the story. Similarly, tasks consume data, call for static or dynamic files, trigger actions, and so on. That's where files, handlers, templates, defaults, and <code class="literal">vars</code> come in. Let's look at what these are for.</li><li class="listitem" style="list-style-type: disc">Vars and defaults provide data about your application/role, for example, which port your server should run on, the path for storing the application data, which user to run the service as, and so on. Default variables were introduced in version 1.3 and these allow us to provide sane defaults. These can later be overridden from other places, for example, <code class="literal">vars</code>, <code class="literal">group_vars</code>, and <code class="literal">host_vars</code>. Variables are merged and precedence rules apply. This gives us a lot of flexibility to configure our servers selectively. For example, running the web server on port <code class="literal">80</code> on all hosts except for the ones in the staging environment, which should run it on port <code class="literal">8080</code>.</li><li class="listitem" style="list-style-type: disc">Files and templates subdirectories provide options for managing files. Typically, the files subdirectory is used to copy over static files to destination hosts, for example, some application installers archive static text files, and so on. In addition to static files, frequently you may need to manage files that are are generated on the fly. For example, a configuration file that has parameters such as port, user, and memory, which can be provided dynamically using variables. Generating such files requires a special type of primitive, called templates.</li><li class="listitem" style="list-style-type: disc">Tasks can trigger actions based on the change of a state or a condition. In a movie, the protagonist may chase the antagonist and take revenge based on the provocation or an event. An example event is kidnapping the protagonist's lady love. Similarly, you may need to perform an action on your hosts, for example, restarting a service based on what happened earlier, which could be a change in the state of a configuration file. This trigger-action relationship can be specified using a handler.</li></ul></div><p>Continuing our analogy, many popular movies have sequels and sometimes even prequels. In such cases, one should watch it in a particular order, as the storyline of a sequel depends on something that happened in the previous movie. Similarly, a role can have a dependency on another role. A very common example is, before installing Tomcat, Java should be present on the system. These dependencies are defined in the meta subdirectory of a role.</p><p>Let's get hands-on with this by creating a role for the Nginx application. Let's take a problem statement, try to solve it, and learn about roles in the process.</p><p>Consider the following <a id="id36" class="indexterm"/>scenario. With the onset of the soccer world cup, we need to create a web server to serve up a page on sports news.</p><p>Being a follower of agile methodologies, we will do this in phases. In the first phase, we will just install a web server and serve up a home page. Let's now break this down into the steps we need to take to achieve this:</p><div><ol class="orderedlist arabic"><li class="listitem">Install a web server. In this case, we will use 'Nginx' as it is a lightweight web server.</li><li class="listitem">Manage configuration for the Nginx web server.</li><li class="listitem">Start the web server after installing it.</li><li class="listitem">Copy over an HTML file, which will be served as a home page.</li></ol></div><p>Now that we have identified what steps to take, we also need to map them to the respective module types we will use to achieve each of these:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Nginx = Package module (apt)</li><li class="listitem" style="list-style-type: disc">Configuring Nginx = File module (file)</li><li class="listitem" style="list-style-type: disc">Starting Nginx = Systems module (service)</li><li class="listitem" style="list-style-type: disc">Serve Webpage = Files module (file)</li></ul></div><p>Before we start <a id="id37" class="indexterm"/>writing code, we will start creating a layout to organize our files.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Creating a site-wide playbook, nesting, and using include statements</h1></div></div></div><p>As a best practice, we <a id="id38" class="indexterm"/>will create a top-level file, which will contain the blueprint of <a id="id39" class="indexterm"/>our complete infrastructure. Technically, we can include everything that we need to configure inside just one file. However, that would have two problems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It would quickly <a id="id40" class="indexterm"/>get out of control as we start adding tasks, variables, and handlers to this single file. It would be a nightmare to maintain such code.</li><li class="listitem" style="list-style-type: disc">It would also be difficult to reuse and share such code. One of the advantages of using a tool such as Ansible is its ability to separate data from code. Data is organization-specific, and code is generic. This generic code can then be shared with others. However, if you write everything in a single file, it would be impossible to do so.</li></ul></div><p>To avoid this problem, we will start organizing our code in a modular fashion, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will create roles for each of the applications that we need to configure. In this case, it is Nginx</li><li class="listitem" style="list-style-type: disc">Our web server may need to install more than one application in addition to Nginx, for example, PHP and OpenSSL. To encapsulate all of these, we will create a playbook named <code class="literal">www.yml</code>.</li><li class="listitem" style="list-style-type: disc">The preceding playbook that we created will map hosts with the Nginx role. We may add more roles to it later.</li><li class="listitem" style="list-style-type: disc">We will add this playbook to the top-level playbook, that is, <code class="literal">site.yml</code></li></ul></div><p>The following diagram depicts the preceding steps in a very simple manner:</p><div><img src="img/B03800_02_02.jpg" alt="Creating a site-wide playbook, nesting, and using include statements"/></div><p>Here is our <code class="literal">site.yml</code> file:</p><div><pre class="programlisting">---
# site.yml : This is a sitewide playbook
- include: www.yml</pre></div><p>The preceding <code class="literal">include</code> <a id="id41" class="indexterm"/>directive assists us with modularizing the code. Instead of writing it all in one file, we split the logic and import what is required. In this case, we will include <a id="id42" class="indexterm"/>another playbook, which is called a <strong>nested playbook</strong>.</p><p>The following are some guidelines on what can be included and how:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">include</code> directive can be used to include tasks, handlers, and even other playbooks</li><li class="listitem" style="list-style-type: disc">If you include a playbook inside another like we did in the <code class="literal">site.yml</code> file, you cannot substitute the variables</li><li class="listitem" style="list-style-type: disc">The <code class="literal">include</code> keyword can be used in combination with regular task/handler specifications</li><li class="listitem" style="list-style-type: disc">It's possible to pass parameters with include statements. This is called as <strong>parameterized </strong><a id="id43" class="indexterm"/><strong>include</strong></li></ul></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>
<strong>Roles and auto-includes</strong>
</p><p>Roles have implicit rules to auto include files. So long as you follow the directory layout conventions, you are assured that all your tasks, handlers, and the rest of the files are included automatically. Hence, it's important to create the subdirectories with the exact names as specified by Ansible.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Creating the www playbook</h1></div></div></div><p>We created a site-wide <a id="id44" class="indexterm"/>playbook and used an include statement to call another playbook by the name <code class="literal">www.yml</code>. We will now create this file with one play, which  maps our web server hosts to the Nginx role:</p><div><pre class="programlisting">---
#www.yml : playbook for web servers
- hosts: www
  remote_user: vagrant
  sudo: yes
  roles:
     - nginx</pre></div><p>The above code works as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Run this code on any host that maps to the <code class="literal">[www]</code> group specified in the hosts file.</li><li class="listitem" style="list-style-type: disc">For each directory inside the <code class="literal">roles/nginx/*</code> file, include <code class="literal">roles/nginx/*/main.yml</code> to the play. This includes <code class="literal">tasks</code>, <code class="literal">handlers</code>, <code class="literal">vars</code>, <code class="literal">meta</code>, <code class="literal">default,</code> and so on. This is where the auto include rules apply.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>The default and custom role paths</h2></div></div></div><p>By default, Ansible <a id="id45" class="indexterm"/>looks inside the <code class="literal">roles/</code> subdirectory of the project that we create playbooks for. Being top-class devops engineers, we will follow the best practice to have a centralized, version-controlled repository to store all your roles. We may also end up reusing the roles created by community. Once we do this, we can reuse these roles across multiple projects. In such cases, we will check out the code at one or more locations, for example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/deploy/ansible/roles</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">/deploy/ansible/community/roles</code></li></ul></div><p>For nondefault paths, we <a id="id46" class="indexterm"/>will need to add the <code class="literal">roles_path</code> parameter to <code class="literal">ansible.cfg</code> as shown in the following command:</p><div><pre class="programlisting">
<strong>roles_path = /deploy/ansible/roles:/deploy/ansible/community/roles</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Parameterizing the roles</h2></div></div></div><p>At times, we may need to <a id="id47" class="indexterm"/>override default parameters specified inside vars or the default directory of a role, for example, running web servers on port 8080 instead of 80. In such cases, we can also pass parameters to roles in the preceding playbook, as follows:</p><div><pre class="programlisting">---
#www.yml : playbook for web servers
- hosts: www
  roles:
- { role: nginx, port: 8080 }</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Creating a base role</h1></div></div></div><p>In the previous <a id="id48" class="indexterm"/>chapter, we created a simple playbook with all plays written inside the same file. After discovering new and exciting information about roles, we will start refactoring our code and making it modular.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Refactoring our code – creating a base role</h2></div></div></div><p>We have written two <a id="id49" class="indexterm"/>plays in the <code class="literal">simple_playbook.yml</code> file. We intended to run the first play on all hosts. This play has tasks to create users, install essential packages, and so on:</p><div><img src="img/B03800_02_03.jpg" alt="Refactoring our code – creating a base role"/></div><p>It's a good practice to combine all such essential tasks and create a base role. You can name it as base, common, essential, or whatever you please, but the concept remains the same. We will now move <a id="id50" class="indexterm"/>this code to the base role:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the directory layout for the base role. Since we are only going to specify tasks, we just need one subdirectory inside the base:<div><pre class="programlisting">
<strong>$ mkdir -p roles/base/tasks</strong>
</pre></div></li><li class="listitem">Create the <code class="literal">main.yml</code> file inside <code class="literal">roles/base/tasks</code> to specify tasks for the base role.</li><li class="listitem">Edit the <code class="literal">main.yml</code> file and add the following code:<div><pre class="programlisting">---
# essential tasks. should run on all nodes
 - name: creating devops group
   group: name=devops state=present
 - name: create devops user
   user: name=devops comment="Devops User" uid=2001 group=devops
 - name: install htop package
   action: apt name=htop state=present update_cache=yes</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating an Nginx role</h1></div></div></div><p>We will now create a <a id="id51" class="indexterm"/>separate role for Nginx and move the previous code that we wrote in the <code class="literal">simple_playbook.yml</code> file to it, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the directory layout for the Nginx role:<div><pre class="programlisting">
<strong>$ mkdir roles/nginx</strong>
<strong>$ cd roles/nginx</strong>
<strong>$ mkdir tasks meta files</strong>
<strong>$ cd tasks</strong>
</pre></div></li><li class="listitem">Create the <code class="literal">install.yml</code> file inside <code class="literal">roles/base</code>. Move the Nginx-related tasks to it. It should look like this:<div><pre class="programlisting">---
 - name: add official nginx repository
   apt_repository: repo='deb http://nginx.org/packages/ubuntu/ lucid nginx'
 - name: install nginx web server and ensure its at the latest version
   apt: name=nginx state=latest force=yes</pre></div></li><li class="listitem">We will also create the <code class="literal">service.yml</code> file to manage the state of the Nginx daemon:<div><pre class="programlisting">---
 - name: start nginx service
   service: name=nginx state=started</pre></div></li><li class="listitem">We looked at the <a id="id52" class="indexterm"/><code class="literal">include</code> directive earlier. We will use it to include both the <code class="literal">install.yml</code> and <code class="literal">service.yml</code> files in the <code class="literal">main.yml</code> file, as follows:<div><pre class="programlisting">---
# This is main tasks file for nginx role
 - include: install.yml
- include: service.yml</pre></div></li></ol></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>
<strong>Best Practice</strong>
</p><p>Why are we creating multiple files to hold the code that installs packages and manages services, separately? That's because well-factored roles allow you to selectively enable specific features. For example, at times, you may want to deploy services in multiple phases. In the first phase, you may just want to install and configure applications, and start services only in the second phase of your deployment. In such cases, having modular tasks can help. You can always include them all in the <code class="literal">main.yml</code> file.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Adding role dependencies</h2></div></div></div><p>We have some <a id="id53" class="indexterm"/>essential tasks specified in the base role. We may keep on adding more tasks which are a prerequisite for the applications that follow. In such cases, we would like our Nginx role to be dependent on the base role. We will now specify this dependency inside the meta subdirectory. Let's take a look at the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">main.yml</code> file inside the <code class="literal">roles/nginx/meta/main.yml</code> path.</li><li class="listitem">Add the following code to the <code class="literal">main.yml</code> file inside the <code class="literal">meta</code> directory:<div><pre class="programlisting">---
dependencies:
  - {role: base}</pre></div></li></ol></div><p>The preceding specification will ensure that the base role is always applied before any task in Nginx starts running.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Managing files for Nginx</h2></div></div></div><p>As per our <a id="id54" class="indexterm"/>solution to the scenario, we already have Ansible tasks to install Nginx and to start the service. We still don't have a web page to serve yet, and we did not think about the Nginx site configurations. We don't expect Nginx to magically know about how and where to serve the web page from, do we?</p><p>We need to perform the following steps to serve the HTML page:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a site configuration that lets Nginx know which port to listen to for requests, and what to do when a request comes.</li><li class="listitem">Create some HTML content, which will be served when an HTTP request comes in.</li><li class="listitem">Add code to <code class="literal">tasks/main.yml</code> to copy over these files.</li></ol></div><p>You might have noticed, both steps 1 and 2  require that you create and manage some files on the host, which will run the Nginx web server. You also learned about the file and the subdirectory of a role. You guessed it right. We will use this subdirectory to host our files and have them copied over to all the Nginx hosts with Ansible. So, let's create these files now using the following command:</p><div><pre class="programlisting">
<strong>$ cd roles/nginx/files</strong>
</pre></div><p>Create a <code class="literal">default.configuration</code> file to manage the default Nginx site configurations. This file should contain parameters such as port, server name, and web root configurations, as follows:</p><div><pre class="programlisting">#filename: roles/nginx/files/default.conf
server {
  listen 80;
  server_name localhost;
  location / {
    root /usr/share/nginx/html;
    index index.html;
  }
}</pre></div><p>We will also create an <a id="id55" class="indexterm"/><code class="literal">index.html</code> file, which we will push to all web servers:</p><div><pre class="programlisting">#filename: roles/nginx/files/indx.html
&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Ole Ole Ole &lt;/h1&gt;
    &lt;p&gt; Welcome to FIFA World Cup News Portal&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Now that we have created these files, we will add tasks to copy these over and put them in <code class="literal">roles/nginx/tasks/configure.yml,</code> as follows:</p><div><pre class="programlisting">---
 - name: create default site configurations
   copy: src=default.conf dest=/etc/nginx/conf.d/default.conf mode=0644
 - name: create home page for default site
   copy: src=index.html dest=/usr/share/nginx/html/index.html</pre></div><p>We will also update the <code class="literal">main.yaml</code> file inside tasks to include the newly created file, and add it before the <code class="literal">service.yml</code> file:</p><div><pre class="programlisting">---
# This is the main tasks file for the nginx role
 - include: install.yml
 - include: configure.yml
 - include: service.yml</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Automating events and actions with handlers</h1></div></div></div><p>Let's assume that <a id="id56" class="indexterm"/>we are managing Nginx manually, and that <a id="id57" class="indexterm"/>we have to change the port that Nginx <a id="id58" class="indexterm"/>listens to from the default site to <code class="literal">8080</code>. What would <a id="id59" class="indexterm"/>we do to make this happen? Sure, we would edit the <code class="literal">default.conf</code> file and change the port from 80 to 8080. However, would that be enough? Would that make Nginx listen to port 8080 immediately after editing this file? The answer is no. There is one more step involved. Let's take a look at the following screenshot:</p><div><img src="img/B03800_02_04.jpg" alt="Automating events and actions with handlers"/></div><p>When we change a configuration file, we will typically also restart/reload the service so that it reads our modifications and applies those.</p><p>So far, so good. Now let's come back to our Ansible code. We are going to run this code in an automated fashion on a large number of servers, possibly hundreds. Considering this, it's not feasible for us to log in to each system to restart services after every change. This defeats the purpose of automating the process. Now, how do we ask Ansible to take action when an event occurs? That's where handlers can help.</p><p>You learned that Ansible modules are idempotent. They will enforce a change in state only if there is a configuration drift. When managing with Ansible, we will commit the preceding port change in the <code class="literal">default.conf</code> file inside <code class="literal">roles/nginx/files</code>. If we launch an Ansible run after making this change then, while executing, it will compare the file inside our role with the one on the system, detect the configuration drift, and copy it over to the changed file. With Ansible, this is where we will add a notification that will trigger a handler to run. In this case, we will call a handler to restart the Nginx service.</p><p>Let's now add this handler to <code class="literal">roles/nginx/handlers/main.yml</code>:</p><div><pre class="programlisting">---
- name: restart nginx service
  service: name=nginx state=restarted</pre></div><p>Handlers are similar to <a id="id60" class="indexterm"/>regular tasks. They specify a module's <a id="id61" class="indexterm"/>name, instance, and state. Why do we not add <a id="id62" class="indexterm"/>them with regular tasks then? Well, we only <a id="id63" class="indexterm"/>need to execute handlers,when an event occurs, not every time we run, ansible. And that's the exact reason why we create a separate section for it.</p><p>Now that we have written the handler, we  also need to add a trigger for it. We will do this by adding the <code class="literal">notify</code> directive to <code class="literal">roles/tasks/nginx/configure.yml</code>, as follows: </p><div><img src="img/B03800_02_05.jpg" alt="Automating events and actions with handlers"/></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Even when multiple tasks notify the handler, it will be called only once, toward the end. This will avoid multiple restarts of the same service unnecessarily.</p></div></div><p>By now, our Nginx role layout looks more complete and has files, handlers, tasks, and directories with individual tasks to manage each phase of the Nginx setup. The role layout is as follows:</p><div><img src="img/B03800_02_06.jpg" alt="Automating events and actions with handlers"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Adding pre-tasks and post-tasks to playbooks</h1></div></div></div><p>We would <a id="id64" class="indexterm"/>like to print status messages before and after we begin applying <a id="id65" class="indexterm"/>Nginx. Let's add it to our <code class="literal">www.yml</code> playbook with the <code class="literal">pre_tasks</code> and <code class="literal">post_tasks</code> parameters:</p><div><pre class="programlisting">
<strong>---</strong>
<strong>- hosts: www</strong>
<strong>  remote_user: vagrant</strong>
<strong>  sudo: yes</strong>
<strong>  pre_tasks:</strong>
<strong>     - shell: echo 'I":" Beginning to configure web server..'</strong>
<strong>  roles:</strong>
<strong>     - nginx</strong>
<strong>  post_tasks:</strong>
<strong>     - shell: echo 'I":" Done configuring nginx web server...'</strong>
</pre></div><p>In the preceding example, we only printed some messages using the <code class="literal">echo</code> command. However, we can create tasks using any of the modules available with Ansible, which can run before, or after, applying roles.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Running playbooks with roles</h1></div></div></div><p>Let's now apply <a id="id66" class="indexterm"/>the refactored code to our hosts. We are going to <a id="id67" class="indexterm"/>launch only the site-wide playbook, that is, the <code class="literal">site.yml</code> file and then rely on the include statements and roles to do the magic:</p><div><pre class="programlisting">
<strong>$ ansible-playbook -i customhosts site.yml</strong>
</pre></div><p>Let's take a look at the following screenshot:</p><div><img src="img/B03800_02_07.jpg" alt="Running playbooks with roles"/></div><p>In addition to the output we saw last time, there are some new messages this time. Let's analyze those:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Before and after, roles are applied, pre-tasks and post-tasks get triggered; this prints messages using the shell module.</li><li class="listitem" style="list-style-type: disc">We now have the code to copy to the <code class="literal">config</code> and .<code class="literal">html</code> file for our Nginx web server.</li><li class="listitem" style="list-style-type: disc">We also see that the handler triggers an Nginx service restart. This is due to the change in the <a id="id68" class="indexterm"/>state for the <code class="literal">configuration</code> <a id="id69" class="indexterm"/>file, which triggers the handler.</li></ul></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Did you notice that tasks in the base role also get triggered, even when we have not mentioned the base role in the <code class="literal">www</code> playbook? This is where meta information is useful. Remember we had specified a dependency on the base role inside <code class="literal">meta/main.yml</code> for Nginx? That's what did the trick.</p><p>Dependencies:</p><div><pre class="programlisting">           - { role: base}</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Review questions</h1></div></div></div><p>Do you think you've understood the chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">Roles contain ___ and ___ subdirectories to specify variables/parameters.</li><li class="listitem">How do you specify a dependency on another role?</li><li class="listitem">When we add roles to a play, why is it not required that we use the <code class="literal">include</code> directives? How do the tasks, handlers, and so on, get added to the play automatically?</li><li class="listitem">Why do we have a separate section for handlers if they resemble regular tasks?</li><li class="listitem">Which module can be used to copy over static files to destination hosts?</li><li class="listitem">How do you specify the tasks to be run before applying a role in a playbook?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, you learned how to use roles to provide abstraction and to help modularizing code for reuse. That's exactly what you see community doing. Creating roles, and sharing them with you. You also learned about <code class="literal">include</code> directives, directory layout for roles, and adding role dependencies. We then went on to refactor our code and created a base role, the Nginx role. We also looked at how to manage events and take actions using handlers.</p><p>In the next chapter, we will extend the concepts of roles and start adding dynamic data with variables and templates.</p></div></body></html>