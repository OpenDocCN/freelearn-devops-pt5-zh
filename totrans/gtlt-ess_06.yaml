- en: Chapter 6. Getting Started with Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you know how to add new users to the Gitolite system, as well as how
    to create new repositories or bring existing repositories into Gitolite control.
    It's time to tie those together now and look at *access control*, which is, for
    most sites, the main reason to install Gitolite.
  prefs: []
  type: TYPE_NORMAL
- en: Basic access control examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aspect of access control that first comes to mind, for any Git administrator,
    is the ability to prevent people from accessing repositories. We''ll start with
    some simple examples before describing the syntax. Here''s a very simple set of
    rules for a repository called `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These rules establish what operations Alice, Bob, Carol, and any other Gitolite
    users are allowed to execute against this repository. As you might guess from
    the simple R permission given to Alice (or, to put it another way, the lack of
    a `W` in her permission string), she is only allowed to read the repository, which
    means she can use the `git clone`, `git fetch`, and `git ls-remote` commands,
    but cannot use `git push` in any form.
  prefs: []
  type: TYPE_NORMAL
- en: Bob and Carol are both allowed to push changes to the repository. As before,
    you probably guessed this from the `W` character in each of their permission lines.
    What may not be immediately obvious is the significance of the `+` character in
    Carol's permission string. This extra character allows Carol to *force* a push,
    that is, push a new object to a ref even if the new object is not a descendant
    of the old object. This is called a non-fast forward push in Git parlance, and,
    even in normal Git use (that is, even without an access control system in place),
    requires explicit action on the user's part in order to succeed. If you're not
    familiar with this, please consult man `git-push` and other Git resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `+` character was chosen because it is a reminder of the `+` you have to
    use in the `git push` command to selectively force-push some refs. (Please refer
    to the description of the `refspec` field in the man page for the `git push` command
    for more details). Although we will not encounter this use case in this chapter,
    for the sake of completeness, we should also mention that the `+` character also
    allows a user to *delete* a ref, even though the corresponding syntax in the `git
    push` command does not use a `+` sign.
  prefs: []
  type: TYPE_NORMAL
- en: For a lot of installations, this basic example serves all their needs—namely,
    to distinguish people who are only allowed to read but not to write, and among
    those that are allowed to write, prevent some from dangerously force-pushing (or
    worse, deleting) an important branch or tag.
  prefs: []
  type: TYPE_NORMAL
- en: Basic branch level access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next example will show another very common need: that of restricting some
    people (perhaps junior developers or interns) to being able to push only branches
    in a specific namespace. This is a fairly common situation, where the most important
    branches (such as master, or maybe next, or whatever your branch naming and workflow
    uses), can only be changed by trusted developers, who presumably have reviewed
    the code and found it to be acceptable. Code written by junior developers and/or
    interns is not deemed to be automatically acceptable, and it is often useful to
    *sandbox* them in some way.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interestingly, this particular use case appears to be more about developer trust
    and maturity than about security per se. However, in terms of controlling or preventing
    such behavior, there is no difference between someone accidentally overwriting
    the master branch, and someone doing it with malicious intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of an access control rule set that achieves such a restriction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This allows Carol to read the repository as well as to push to it, but it prevents
    her from pushing anything except branches whose names start with `dev/`. In contrast,
    Bob whose access rule does not specify anything after the permission field, can
    push any branch.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical syntax of the conf file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen a couple of useful, and immediately usable, examples, it
    is time to look at the **lexical** syntax of the `conf/gitolite.conf` file (often
    called, in Gitolite, *the conf file*).
  prefs: []
  type: TYPE_NORMAL
- en: The conf file is a plain text file, whose overall syntax is governed by a few
    simple rules.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite usernames (in our example, `alice`, `bob`, and so on) must start with
    an alphanumeric character, and contain alphanumerics, periods, hyphens, underscores,
    or the `@` sign. If an `@` sign is present, it must be followed by a domain name
    (that is, something that has at least one period in it). This allows e-mail addresses
    to be used as usernames, which is arguably very useful when you have several John
    Smith in your organization!
  prefs: []
  type: TYPE_NORMAL
- en: Repository names must start with an alphanumeric character, and contain alphanumerics,
    periods, hyphens, underscores, or slashes. However, they must not start with a
    slash or end with a slash.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are allowed; the syntax is the same as the shell, perl, and so on.
    Anything following a `#` sign is taken to be a comment and discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuation lines (in the C-style) are not allowed by default. However, by
    editing the `$HOME/.gitolite.rc` file, which we will see in more detail in [Chapter
    7](ch07.html "Chapter 7. Advanced Access Control and Configuration"), *Advanced
    Access Control and Configuration*, you can enable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of access control rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The access control list has a simple structure. Briefly, it is structured like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A conf file has one or more `repo` lines. Each repo line contains the word `repo`,
    followed by one or more repository names or repository-group names (we'll discuss
    groups later in this chapter). These repository or group names must all be on
    the same line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `repo` line is followed by one or more *access rules* that apply to this
    set of repositories or groups. An access rule consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A permission field (for example, R, RW, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more *refexes* (refexes are detailed in the next section, but one example
    refex you have already seen is `dev/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `=` sign to serve as a separator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally a list of users or user-group names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch level access control and refexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will talk about a very important part of Gitolite—specifying who
    can make changes to which branch or tag. As a matter of historical interest, the
    lack of this feature, in what was at that time the most popular tool for Git server
    administration, was the sole motivation for Gitolite being created.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section assumes some familiarity with *regular expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: To understand branch level access control and how to specify them in Gitolite,
    we should first have a quick refresher of related concepts in Git itself, to make
    things easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Git uses the word `ref` to refer to both branches and tags. Branch names are
    usually of the form `refs/heads/something`, while tag names are of the form `refs/tags/something`.
    When a user pushes to a Gitolite managed repository, Gitolite helps you determine
    whether the *refs* being updated are allowed to be updated by this user or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to allow Bob to push the branch called master, you might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When a user pushes to the repository, Git supplies Gitolite with the name of
    the ref being pushed. Gitolite then matches the ref with each of the refexes in
    the access rule lines. If there is a match, and the user is also listed on the
    right side of the `=` sign, then the push is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, due to the fact that branches are far more frequently access controlled
    than tags, Gitolite assumes anything that does not start with `refs/` to be prefixed
    with `refs/heads/`. Thus, you can just say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: and that would be taken as `refs/heads/master`.
  prefs: []
  type: TYPE_NORMAL
- en: To be strictly accurate, the preceding data allows Bob to push any branch with
    a name that starts with `master`. To restrict the rule to just `master`, you should
    actually write the refex as `master$`. In practice, however, this is rarely required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Controlling tags is just as easy. Let us say you want to allow a user to push
    any tag with a name starts with the letter v, followed by a digit, optionally
    followed by anything else. Here''s the rule for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression pattern `[0-9]` represents the notion of any character
    between `0` and `9` inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite anchors this regex at the beginning only, not at the end. In regex
    terms, this means a `^` character is implicitly added at the start, but a `$`
    character is not added at the end. This allows Bob to push tags like `v1`, `v2.2`,
    `v3.4.5`, and so on, but not `new-v1` and `next-v2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus we come to the definition of a *refex*: a refex is a regex (that is, a
    regular expression) that is used to match the ref being pushed.'
  prefs: []
  type: TYPE_NORMAL
- en: Using deny rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the rules we have seen allow you to specify which branches or tags a
    user is allowed to push. However, we often need to be able to specify, for example,
    that a user is allowed to push *all branches except master*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to use what Gitolite calls *deny* rules. Here''s how you
    might implement the above restriction for a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Gitolite checks rules in sequence when attempting to determine whether a branch
    is allowed to be pushed or not. When Bob pushes a branch called `next` (that is,
    `refs/heads/next`) to this repository, the first rule does not match at all, since
    `refs/heads/master` is not a pattern that matches the string `refs/heads/next`.
    Gitolite then checks the next rule. Since this rule does not specify a refex,
    all refs will match, and since the permission field is `RW+`, the push is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: However, when Bob pushes `refs/heads/master`, the ref matches the refex in the
    first rule, and since the rule is a deny rule, the push is denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observant readers will notice that the sequence of the rules is very important
    here. Reversing the order of the two rules we looked at would remove the restriction
    we want to implement. The first rule encountered will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This does not specify a refex and thus matches all refs. As a result, the operation
    is allowed to proceed. In other words, the deny rule is never even checked!
  prefs: []
  type: TYPE_NORMAL
- en: The permission field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now seen examples of the four most common permissions used in access
    rules, so it is a good idea to summarize them.
  prefs: []
  type: TYPE_NORMAL
- en: The `R` permission allows the user to read (clone, fetch) the repository, but
    not push. `RW` allows the user to push, but only if it is a fast-forward push
    or a new branch is being created. Non-fast forward pushes and deletions are not
    allowed. And `RW+` allows non-fast forward pushes and deletions too.
  prefs: []
  type: TYPE_NORMAL
- en: As long as your rule set contains only these three types of rules, it does not
    matter which order they appear in. However, as you saw in the previous section,
    the sequence of rules becomes important when you use the fourth kind of rule—a
    deny rule, denoted by a single minus sign.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While these are the most commonly used permissions, they are not all there are.
    There are a few more permissions which will appear in the section *Types of Write
    Operations* in [Chapter 7](ch07.html "Chapter 7. Advanced Access Control and Configuration"),
    *Advanced Access Control and Configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining user and repo groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gitolite allows you to define groups of users or repositories for convenience.
    The syntax is very simple, and does not distinguish between a user group and a
    repository group. For example, take a look at the deny rule example in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that, instead of just Bob, you had several more users who must be
    prevented from pushing the `master` branch, perhaps because they are all junior
    developers. One way is to add each of their usernames on both the rule lines,
    after Bob''s username, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But this gets cumbersome, and will only get worse if there are more rules to
    be applied to the same group of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'With groups, however, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is far more convenient, and also less error-prone. Even
    more importantly, the group name can often serve as important documentation for
    the ruleset—a future administrator may not know who Bob, Carol, and Dave are,
    and may puzzle over why they were restricted, but the group name, if chosen well,
    makes things very clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use group names for repositories also, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While in this case it may not look as critical, because the group name is being
    used to replace only one occurrence of the repository names, it is still a lot
    cleaner. Also, as with the user group names, the repository group name serves
    as additional documentation of the nature of those repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Working with large groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you need a group which contains several members—far more than can
    fit on one line comfortably to edit. To make this easier (and because Gitolite
    does not, by default, allow continuation lines), Gitolite treats every definition
    of a group as cumulative. This means that if the group was already defined earlier,
    the new members are added to it rather than replacing the existing member list.
    This allows you to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This would have the same effect as the single line definition we saw earlier
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The special @all group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gitolite also has a special, built-in group called @all, which refers to all
    repositories, or all users, depending on where it is used. A common use for this
    is to allow certain privileged users access to all repositories, perhaps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For another example, let us consider a situation where only Adam and Dave are
    allowed to push the `master` branch. Here''s how you might do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have a *deny* rule here, so again, notice that the order of rules is important.
    If we had placed the *deny* rule first, then—because Adam and Dave are implicitly
    members of @all—they would also be denied rights to push the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: The include statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also split up your access rules and group definitions into multiple
    files, and *include* them into the main conf file (`conf/gitolite.conf` in your
    gitolite-admin repository). For example, you can keep all group information (that
    is, which users are members of which groups) in a separate file and include that.
    The syntax is very simple; here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will look for a file called `groups.conf` in the `conf` directory and include
    its contents at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced users may note that this command also accepts wildcards. For example,
    you might have several individual conf files in a subdirectory of `conf` called
    `foss`. If you don''t want to name each of them separately, you can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Rule accumulation and delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gitolite allows you to split up access rules for repositories into multiple
    chunks which are not necessarily contiguous. It will then combine all these chunks
    (in the order they were read) and apply the combined set of rules to the repository
    in question.
  prefs: []
  type: TYPE_NORMAL
- en: There's a very good use for this behavior. Combining groups, that include statement,
    and rule accumulation, makes Gitolite administration easier than it already is.
    Here's an example, with some comments, to give you some idea of what can be done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a repository can appear in any or all of the include files that
    the main conf file pulls in. If we required all the rules for each repository
    to be in one place, it would be impossible to organize your rules in this sort
    of manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now seen most of Gitolite's basic access control features, including various
    types of access rules, the syntax of the conf file, and some convenient features
    that make managing this easier. In the next chapter, we will discuss some advanced
    access control features, such as personal branches and **VREFs**.
  prefs: []
  type: TYPE_NORMAL
