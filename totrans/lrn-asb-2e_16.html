<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-232"><a id="_idTextAnchor716"/>16</h1>
<h1 id="_idParaDest-233"><a id="_idTextAnchor717"/>Introducing Ansible AWX and <a id="_idTextAnchor718"/><a id="_idTextAnchor719"/>Red Hat Ansible Automation Platform</h1>
<p>This chapter will examine<a id="_idIndexMarker924"/> two graphical interfaces<a id="_idIndexMarker925"/> for Ansible: the commercial <strong class="bold">Red Hat Ansible Automation Platform</strong> and the open source <strong class="bold">Ansible AWX</strong> – or to give it its full name, <strong class="bold">Ansible </strong><strong class="bold">Web eXecutable</strong>.</p>
<p>This chapter will focus on the open source Ansible AWX because it is freely available and, outside of the resources required to run the tool, requires no upfront costs or contracts.</p>
<p>We will discuss how to install Ansible AWX and why you would want to use it. After all, we are 16 chapters into our journey with Ansible and haven’t needed to use a graphical interface yet – so why now?</p>
<p>By the end of this chapter, we will have done the following:</p>
<ul>
<li>Discussed Red Hat Ansible Automation Platform versus Ansible AWX</li>
<li>Installed and configured Ansible AWX</li>
<li>Deployed our Microsoft Azure cloud application using Ansible AW<a id="_idTextAnchor720"/>X</li>
</ul>
<h1 id="_idParaDest-234"><a id="_idTextAnchor721"/>Technical requirements</h1>
<p>While we will only deploy Ansible AWX in this chapter, its requirements are complex. Because of this, rather than running it locally, I will provide instructions for deploying a Kubernetes cluster in Microsoft Azure using the AKS service.</p>
<p>If you are following along, you will need access to a Microsoft Azure account and have the Azure CLI installed. For more information, see <a href="B21620_09.xhtml#_idTextAnchor411"><em class="italic">Chapter 9</em></a>, <em class="italic">Moving to </em><em class="italic">the Cloud</em>.</p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor722"/>Red Hat Ansible Automation Platform versus AWX</h1>
<p>Red Hat Ansible Automation Platform<a id="_idIndexMarker926"/> and Ansible AWX are two powerful<a id="_idIndexMarker927"/> tools Red Hat provides for managing and streamlining your Ansible deployments. Both tools offer web-based interfaces that simplify the execution and management of Ansible playbooks, making it easier for users to leverage Ansible’s automation capabilities without requiring extensive command-line knowledge.</p>
<p>Red Hat Ansible<a id="_idIndexMarker928"/> Automation Platform, formerly known as <strong class="bold">Ansible Tower</strong>, is a comprehensive enterprise-grade solution that goes beyond the capabilities of Ansible Tower. It integrates various components to create a cohesive and expansive automation environment. Some key features<a id="_idIndexMarker929"/> of Red Hat Ansible Automation Platform are as follows:</p>
<ul>
<li><strong class="bold">Centralized control</strong>: Red Hat Ansible Automation Platform provides a unified web-based dashboard for defining, scheduling, and monitoring automation jobs from a central location.</li>
<li><strong class="bold">Role-based access control</strong> (<strong class="bold">RBAC</strong>): With granular access, you can ensure that your users have appropriate access to automation resources, enhancing security and control.</li>
<li><strong class="bold">Workflow management</strong>: Create complex workflows that combine multiple playbooks, job templates, and inventory sources, as well as supporting dependencies, conditionals, and approvals.</li>
<li><strong class="bold">Scalability and flexibility</strong>: Automation can be scaled to meet the needs of large enterprises, supporting diverse infrastructures, including cloud platforms, containers, and network devices.</li>
<li><strong class="bold">Content collections</strong>: Access pre-packaged modules and plugins that have been expertly curated to expedite the implementation of automation projects.</li>
<li><strong class="bold">Automation Hub</strong>: This centralized repository hosts certified, partner-supported, and community-driven content. It fosters collaboration and accessibility to high-quality resources.</li>
<li><strong class="bold">Automation analytics</strong>: Utilize sophisticated analytics tools to scrutinize performance, utilization, and various KPIs across different clusters and instances.</li>
<li><strong class="bold">Integration with Red Hat ecosystem</strong>: Seamless integration with other Red Hat products such as Red Hat Insights and Red Hat <a id="_idIndexMarker930"/>Satellite, fostering a cohesive environment.</li>
</ul>
<p>On the other hand, Ansible AWX is the open source upstream project for Red Hat Ansible Automation Platform. It provides many of the platform’s core features but follows a community-driven development model with more frequent releases. While Ansible AWX offers a solid foundation for automation, Red Hat Ansible Automation Platform may need some enterprise-specific features and integrations.</p>
<p>The choice between Red Hat Ansible Automation Platform and Ansible AWX depends on your organization’s needs and requirements. Red Hat Ansible Automation Platform is ideal for enterprises seeking a robust, feature-rich solution with commercial support and seamless integration with the Red Hat ecosystem. It offers advanced features and is designed to handle complex automation needs across diverse environments.</p>
<p>On the other hand, Ansible AWX is a suitable choice for organizations that prefer an open source solution and are comfortable with community-driven support. It provides a solid foundation for automation and benefits from more frequent updates and community contributions.</p>
<p>Both Red Hat Ansible Automation Platform and Ansible AWX allow organizations to automate at scale, reduce manual<a id="_idIndexMarker931"/> efforts, and improve the consistency<a id="_idIndexMarker932"/> and reliability of their IT operations. They provide user-friendly interfaces and enable effective team collaboration, increasing efficiency and improved compliance.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor723"/>Ansible AWX</h1>
<p>To say that installing Ansible AWX<a id="_idIndexMarker933"/> is complicated is an understatement. Since Red Hat first open sourced the project, deploying it has always been difficult.</p>
<p>Luckily, the first release was containerized, and it has slowly transitioned from running in a small number of containers to being able to<a id="_idTextAnchor724"/> run in a Kubernetes cluster and manag<a id="_idTextAnchor725"/>ed by the AWX Operator.</p>
<p class="callout-heading">Information</p>
<p class="callout">A Kubernetes Operator uses custom resources to automate application and component management in Kubernetes clusters. It extends the cluster’s behavior without modifying the Kubernetes code itself. Operators can handle various tasks, such as deployment, backups, upgrades, and service discovery, reducing manual intervention and increasing the system’s reliability.</p>
<p>Let’s start by launching our own Kubernetes<a id="_idIndexMarker934"/> in Microsoft Azure and configuring our local machine so that we can deploy and configure the AWX Operator.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor726"/>Deploying and configuring the Ansible AWX Operator</h2>
<p>The first thing we need<a id="_idIndexMarker935"/> to do is deploy<a id="_idIndexMarker936"/> the Kubernetes cluster. To do this, we will use the Azure CLI to launch an AKS cluster. To start with, we need to set some variables on the command line to define the resource names, which Azure region we would like the cluster to deploy into, and how many compute nodes we require:</p>
<pre class="console">
$ AKSLOCATION=uksouth
$ AKSRG=rg-awx-cluster
$ AKSCLUSTER=aks-awx-cluster
$ AKSNUMNODES=2</pre> <p>Next up, let’s create the Azure Resource Group we will be deploying our cluster into; this will make it easy to remove once we have finished as we need to delete the group and its contents:</p>
<pre class="console">
$ az group create --name $AKSRG --location $AKSLOCATION</pre> <p>With the resource group in place, we can now launch the AKS cluster:</p>
<pre class="console">
$ az aks create \
     --resource-group $AKSRG \
     --name $AKSCLUSTER \
     --node-count $AKSNUMNODES \
     --generate-ssh-keys</pre> <p>This will take around 5 minutes to deploy. If you don’t have the <code>kubectl</code> command installed on your local machine, then you can run the following command to have the Azure CLI install it for you:</p>
<pre class="console">
$ az aks install-cli</pre> <p>Finally, with <code>kubectl</code> installed, you can configure<a id="_idIndexMarker937"/> the credentials and contexts<a id="_idIndexMarker938"/> by running the following command:</p>
<pre class="console">
$ az aks get-credentials --resource-group $AKSRG --name $AKSCLUSTER</pre> <p>With our cluster now launched and available, we must install and configure the AWX Operator using Helm.</p>
<p class="callout-heading">Information</p>
<p class="callout"><strong class="bold">Helm</strong> is a package manager that simplifies Kubernetes<a id="_idIndexMarker939"/> deployment by packaging applications as charts and defining necessary resources and configurations. For more details<a id="_idIndexMarker940"/> and installation instructions, see <a href="https://helm.sh/">https://helm.sh/</a>.</p>
<p>First, we need to enable the AWX repository and pull it down to our local machine:</p>
<pre class="console">
$ helm repo add awx-operator https://ansible.github.io/awx-operator/
$ helm repo update</pre> <p>Now, we need to deploy the AWX Operator to our cluster:</p>
<pre class="console">
$ helm install -n awx --create-namespace awx awx-operator/awx-operator --version 2.12.1</pre> <p>It will take a minute or two to deploy.</p>
<p class="callout-heading">Please note</p>
<p class="callout">You might have noticed that the preceding command specifies an explicit version number because there are some known bugs with the current release, which is a major update from the version we are using.</p>
<p>You can run the following command to check the status of the deployment:</p>
<pre class="console">
$ kubectl get pods -n awx</pre> <p>Once everything is ready, you should see something like the foll<a id="_idTextAnchor727"/>owing screen:</p>
<div><div><img alt="Figure 16.1 – Deploying the AWX Operator" src="img/B21620_16_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – Deploying the AWX Operator</p>
<p>With the AWX Operator deployed<a id="_idIndexMarker941"/> with our cluster, we can request that the operator<a id="_idIndexMarker942"/> now deploy AWX itself. To do this, run the fol<a id="_idTextAnchor728"/>lowing command:</p>
<pre class="console">
$ kubectl apply -f https://raw.githubusercontent.com/PacktPublishing/Learn-Ansible-Second-Edition/main/Chapter16/awx/ansible-awx.yaml</pre> <p>This command simply passes the following YAML configuration to the operator to instruct it how to deploy our AWX installation:</p>
<pre class="source-code">
---
apiVersion: awx.ansible.com/v1beta1
kind: AWX
metadata:
  name: ansible-awx
  namespace: awx
spec:
  service_type: loadbalancer</pre> <p>As you can see, there’s not much to it, so please don’t consider this a production-ready AWX instance. All we are instructing the AWX Operator to do is deploy AWX and expose the service via a load balancer so that we can connect to it.</p>
<p>Now, we wait; our AWX installation<a id="_idIndexMarker943"/> will take 15 to 20 minutes to deploy the application<a id="_idIndexMarker944"/> and bootstrap itself.</p>
<p>You can check the status of the containers and the load balancer service by running the following code:</p>
<pre class="console">
$ kubectl get pods -n awx
$ kubectl get svc ansible-awx-service -n awx</pre> <p>Once the basics have been deployed, you should see something like the following. These are the containers that service the AWX application. As you can see, there are ones for the database, task runner, and th<a id="_idTextAnchor729"/>e web interface:</p>
<div><div><img alt="Figure 16.2 – Checking the status of our AWX deployment" src="img/B21620_16_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – Checking the status of our AWX deployment</p>
<p>Once your deployment looks like the preceding output, the final step is to grab the admin password. To do this, run the following command – the secret will always be named <code>ansible-awx-admin-password</code>:</p>
<pre class="console">
$ kubectl<a id="_idTextAnchor730"/> get secret -n awx ansible-awx-admin-password -o jsonpath="{.data.password}" | base64 –decode</pre> <p>This will grab the base64 encoded secret from the Kubernetes secret store and decode it for you – it should look like this:</p>
<div><div><img alt="Figure 16.3 – Grabbing the admin password" src="img/B21620_16_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Grabbing the admin password</p>
<p>As you may have noticed in the preceding output, there is a <code>%</code> icon at the end – this is not part of the password, and you need everything before that.</p>
<p>Please make a note of the password<a id="_idIndexMarker945"/> and the <code>EXTERNAL-IP</code> value from the previous commands<a id="_idIndexMarker946"/> as this tells you where to go to log in and what credentials to use. In the preceding deployment (which has long since been terminated), these details are as follows:</p>
<ul>
<li><strong class="bold">URL</strong>: http://4.158.66.251/</li>
<li><strong class="bold">Username</strong>: admin</li>
<li><strong class="bold">Password</strong>: h6VBBzcnDTHiBbl7jZOmA30tpsjka8nF</li>
</ul>
<p>When you go to the URL, you should be greeted with a login page that l<a id="_idTextAnchor731"/>ooks like this:</p>
<div><div><img alt="Figure 16.4 – Grabbing the admin password" src="img/B21620_16_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Grabbing the admin password</p>
<p>Once you log in, you will be taken<a id="_idIndexMarker947"/> to your emp<a id="_idTextAnchor732"/>ty AWX<a id="_idIndexMarker948"/> instance:</p>
<div><div><img alt="Figure 16.5 – Grabbing the admin password" src="img/B21620_16_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Grabbing the admin password</p>
<p>Now, let’s set up our playbook.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor733"/>Setting up our playbook</h2>
<p>Before running our playbook, we must import<a id="_idIndexMarker949"/> it into Ansible AWX and configure the supporting credentials, such as our Azure Service Principle. We’ll start with a project.</p>
<h3>Adding a new project</h3>
<p>First, we need to add<a id="_idIndexMarker950"/> a new project, where we tell Ansible AWX about the repository hosting our playbook. As mentioned previously, we will use a GitHub repository that houses the code. To add a new project, click on <strong class="bold">Projects</strong> under <strong class="bold">Resources</strong> in the left menu and then click on the <strong class="bold">Add</strong> button.</p>
<p>Here, you will be asked for several bits of information; enter the following:</p>
<ul>
<li><code>Azure WordPress</code></li>
<li><code>Deploy WordPress </code><code>in Azure</code></li>
<li><code>Default</code></li>
<li><strong class="bold">Execution Environment</strong>: S<a id="_idTextAnchor734"/>elect <strong class="bold">AWX </strong><strong class="bold">EE (latest)</strong></li>
<li><code>GIT</code></li>
</ul>
<p>When you select the <strong class="bold">Source Control Type</strong> value a second section will appear that asks for details<a id="_idIndexMarker951"/> about where your source is hosted:</p>
<ul>
<li><code>https://github.com/PacktPublishing/Learn-Ansible-Second-Edition.git</code></li>
<li><strong class="bold">Source Control Branch/Tag/Commit</strong>: Leave blank</li>
<li><strong class="bold">Source Control Refspec</strong>: Leave blank</li>
<li><strong class="bold">Source Control Credential</strong>: Leave blank</li>
<li><code>Clean</code></li>
</ul>
<p>Once you have entered these details, click <strong class="bold">Save</strong>. Now, if you return to the <strong class="bold">Projects</strong> page, you should see that Ansible has already downloaded the sourc<a id="_idTextAnchor735"/>e for the playbook:</p>
<div><div><img alt="Figure 16.6 – Adding the project and downloading the code from GitHub" src="img/B21620_16_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6 – Adding the project and downloading the code from GitHub</p>
<h3>Adding credentials</h3>
<p>Next, we must tell Ansible AWX<a id="_idIndexMarker952"/> the credentials to use when accessing our Azure environment; to add these, click <strong class="bold">Credentials</strong>. This can also be found under the <strong class="bold">Resources</strong> section of the left-hand menu. Click <strong class="bold">Add</strong> and ente<a id="_idTextAnchor736"/>r the following:</p>
<ul>
<li><code>Azure</code></li>
<li><code>Credentials </code><code>for Azure</code></li>
<li><code>Default</code></li>
<li><strong class="bold">C<a id="_idTextAnchor738"/>redential Type</strong>: Select <strong class="bold">Microsoft Azure </strong><strong class="bold">Resource Manager</strong></li>
</ul>
<p>As before, this will open a separate<a id="_idIndexMarker953"/> section; here, you will need to enter details of the service principle we created in <a href="B21620_15.xhtml#_idTextAnchor641"><em class="italic">Chapter 15</em></a>, <em class="italic">Using Ansible with GitHub Actions and </em><em class="italic">Azure DevOps</em>:</p>
<ul>
<li><code>e80d5ad9-e2c5-4ade-a866-bcfbae2b8aea</code></li>
<li><strong class="bold">Username</strong>: Leave blank</li>
<li><strong class="bold">Password</strong>:<a id="_idTextAnchor740"/> Leave blank</li>
<li><code>appId</code> value that was returned when you created the service principle; in the previous chapter’s example, this was <code>2616e3df-826d-4d9b-9152-3de141465a69</code></li>
<li><code>password</code> value that was returned when you created the service principle; in the previous chapter’s example, this was <code>Y4j8Q~gVO*NoTaREalPa55w0rdpP-pdaw</code></li>
<li><code>tenant</code> ID; in the example from the previous chapter, this was <code>c5df827f-a940-4d7c-b313-426cb3c6b1fe</code></li>
</ul>
<p>Once the form has been filled in, click <strong class="bold">Save</strong>. Once saved, you will notice that the <strong class="bold">Client Secret</strong> value is <a id="_idTextAnchor741"/>marked as <strong class="bold">Encrypted</strong>:</p>
<div><div><img alt="Figure 16.7 – Adding our Service Principle to Ansible AWX" src="img/B21620_16_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.7 – Adding our Service Principle to Ansible AWX</p>
<p>When you save sensitive information<a id="_idIndexMarker954"/> in Ansible AWX, it is encrypted, and you only have the option to <strong class="bold">Replace</strong> or <strong class="bold">Revert</strong> it. At no point can you view this information again.</p>
<p>Next, we need to create a credential that contains the private portion of the SSH key we generated in <a href="B21620_15.xhtml#_idTextAnchor641"><em class="italic">Chapter 15</em></a><em class="italic">, Using Ansible with GitHub Actions and Azure DevOps</em>. To do this click on <strong class="bold">Add</strong> again, but this tim<a id="_idTextAnchor742"/>e, enter the following:</p>
<ul>
<li><code>AzureVM</code></li>
<li><code>Private SSH Key for </code><code>Azure VMs</code></li>
<li><code>Default</code></li>
<li><strong class="bold">Credential Type</strong>: Select <strong class="bold">Machine</strong></li>
</ul>
<p>In the additional information boxes, enter the following information:</p>
<ul>
<li><code>azureadmin</code></li>
<li><strong class="bold">Password</strong>: Leave blank</li>
<li><strong class="bold">SSH Private Key</strong>: Copy and paste the contents of the private key or uplo<a id="_idTextAnchor744"/>ad the private key file</li>
<li><strong class="bold">Remaining options</strong>: Leave blank</li>
</ul>
<p>Once filled in, click <strong class="bold">Save</strong>. Once back on the <strong class="bold">Credentials</strong> screen, click <strong class="bold">Add</strong> once more and enter the following:</p>
<ul>
<li><code>Ansible Galaxy</code></li>
<li><code>Ansible Galaxy creds for </code><code>Default org</code></li>
<li><code>Default</code></li>
<li><strong class="bold">Credential Type</strong>: Select <strong class="bold">Ansible Galaxy/Automation Hub </strong><strong class="bold">API Token</strong></li>
</ul>
<p>Then, enter this information:</p>
<ul>
<li><code>https://galaxy.ansible.com</code></li>
<li><strong class="bold">Remaining options</strong>: Leave blank</li>
</ul>
<p>Again, click <strong class="bold">Save</strong>. Now, it’s time to add our final set of credentials:</p>
<ul>
<li><code>WordPress Vault</code></li>
<li><code>Vault Password for </code><code>WordPress secrets</code></li>
<li><code>Default</code></li>
<li><strong class="bold">Credential Type</strong>: Select <strong class="bold">Vault</strong></li>
</ul>
<p>In the <strong class="bold">Type Details</strong> section, enter the following:</p>
<ul>
<li><code>group_vars/common.yml</code> in the <code>Chapter16</code> playbook. Because of that, you must enter a password of <code>wibble</code> here – if you don’t enter this, the example playbook will fail.</li>
<li><strong class="bold">Vault Identifier</strong>: Leave blank.</li>
</ul>
<p>That was our final<a id="_idIndexMarker955"/> credentials. So, let’s move on to the next configuration step.</p>
<h3>Adding an inventory</h3>
<p>Now that we have all our credentials<a id="_idIndexMarker956"/> in place, we need to recreate the content of the <code>production</code> inventory file within Ansible AWX. As a reminder, the inventory file we have been using looks like this (minus the comments):</p>
<pre class="source-code">
[local]
localhost ansible_connection=local
[vmgroup]
[azure_vms:children]
vmgroup
[azure_vms:vars]
ansible_ssh_user=adminuser
ansible_ssh_private_key_file=~/.ssh/id_rsa
host_key_checking=False</pre> <p>To add the inventory, click on <strong class="bold">Inventories</strong>, which is again<a id="_idIndexMarker957"/> in the left-hand menu. The <strong class="bold">Add</strong> button now brings up a drop-down list; we want to select <strong class="bold">Add inventory</strong> from that list.</p>
<p>In the form that opens, enter the following:</p>
<ul>
<li><code>Azure Inventory</code></li>
<li><code>Azure Inventory</code></li>
<li><code>Default</code></li>
<li><strong class="bold">Instance Groups</strong>: We will add these in a moment</li>
<li><strong class="bold">Labels</strong>: Leave blank</li>
<li><strong class="bold">Variables</strong>: Enter the values listed here:<pre class="source-code">
ansible_ssh_user: "adminuser"
ansible_ssh_private_key_file: "~/.ssh/id_rsa"
host_key_checking: false</pre></li> </ul>
<p>Once entered, click <strong class="bold">Save</strong>; this will create the inventory. Now, we can add the two groups we need. To do this, click <strong class="bold">Groups</strong>, which can be found in the row on the buttons above the de<a id="_idTextAnchor745"/>tails of the inventory:</p>
<div><div><img alt="Figure 16.8 – Adding the inventory to Ansible AWX" src="img/B21620_16_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.8 – Adding the inventory to Ansible AWX</p>
<p>Click <strong class="bold">Add</strong> and enter the following details:</p>
<ul>
<li><code>vmgroup</code></li>
<li><code>vmgroup</code></li>
<li><strong class="bold">Variables</strong>: Leave blank</li>
</ul>
<p>Then, click <strong class="bold">Save</strong>, repeat the process, and add a second group using the following details:</p>
<ul>
<li><code>azure_vms</code></li>
<li><code>azure_vms</code></li>
<li><strong class="bold">Variables</strong>: Leave blank</li>
</ul>
<p>Again, click <strong class="bold">Save</strong>; you should now have two groups listed.</p>
<p>Now that we have our project, inventory, and some credentials<a id="_idIndexMarker958"/> for accessing our Azure environment, we need to add the templates to launch and configure the cluster and terminate it.</p>
<h3>Adding the templates</h3>
<p>Let’s look at adding<a id="_idIndexMarker959"/> the templates.</p>
<p class="callout-heading">Information</p>
<p class="callout">We will pass a runtime variable to our playbook, which will contain the public part of the SSH key – we added the private portion as a credential earlier in this chapter – and will be called <code>ssh_key_public</code>. Please ensure you have the public key when filling out these details.</p>
<p>Click <strong class="bold">Templates</strong> in the left-hand menu and, in the drop-down<a id="_idIndexMarker960"/> menu of the <strong class="bold">Add</strong> button, select <strong class="bold">Job Template</strong>. This is the most extensive form we have encountered; however, parts will be populated automatically when we fill in the detail<a id="_idTextAnchor746"/>s. Let’s make a start:</p>
<ul>
<li><code>L<a id="_idTextAnchor747"/>aunch WordPress</code></li>
<li><code>Launch WordPress </code><code>in Azure</code></li>
<li><strong class="bold">Job Type</strong>: Select <strong class="bold">Run</strong></li>
<li><strong class="bold">Inventory</strong>: Select <strong class="bold">Azure Inventory</strong></li>
<li><strong class="bold">Project</strong>: Select <strong class="bold">Azure WordPress</strong></li>
<li><strong class="bold">Execution Environment</strong>: Select <strong class="bold">AWX </strong><strong class="bold">EE (latest)</strong></li>
<li><strong class="bold">Playbook</strong>: Choose <strong class="bold">Chapter16/site.yml</strong> from the drop-down list</li>
<li><strong class="bold">Credentials</strong>: Select the following:<ul><li><strong class="bold">Machine</strong>: <strong class="bold">AzureVM</strong></li><li><strong class="bold">Microsoft Azure Resource </strong><strong class="bold">Manager</strong>: <strong class="bold">Azure</strong></li><li><strong class="bold">Vault</strong>: <strong class="bold">WordPress Vault</strong></li></ul></li>
<li><code>ssh_key_public</code> variable here; a truncated version of what<a id="_idTextAnchor748"/> to enter is shown here:<pre class="source-code">
---
ssh_key_public: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCGosD5doqnJgOLpkztaDvIZFaCKoChm9yyU6FPaci9fZR60SCXbOu1zeMmyJouFH7xVBv7xw5HBk0FDNLXrssR5B7YHi<a id="_idTextAnchor749"/>ti8= youremail@example.com"</pre></li> <li><strong class="bold">Remaining options</strong>: Leave blank</li>
</ul>
<p>Click <strong class="bold">Save</strong>; you will be taken to the <a id="_idTextAnchor750"/>overview of the template:</p>
<div><div><img alt="Figure 16.9 – The completed template" src="img/B21620_16_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.9 – The completed template</p>
<p>Once added, we need to repeat<a id="_idIndexMarker961"/> this process with the following details for the Playbook that term<a id="_idTextAnchor751"/><a id="_idTextAnchor752"/>inates our deployment:</p>
<ul>
<li><code>Terminate WordPress</code></li>
<li><code>Terminate WordPress </code><code>in Azure</code></li>
<li><strong class="bold">Job Type</strong>: Select <strong class="bold">Run</strong></li>
<li><strong class="bold">Inventory</strong>: Select <strong class="bold">Azure Inventory</strong></li>
<li><strong class="bold">Project</strong>: Select <strong class="bold">Azure WordPress</strong></li>
<li><strong class="bold">Execution Environment</strong>: Select <strong class="bold">AWX </strong><strong class="bold">EE (latest)</strong></li>
<li><strong class="bold">Playbook</strong>: Choose <strong class="bold">Chapter16/destroy.yml</strong> from the drop-down list</li>
<li><strong class="bold">Credentials</strong>: Select the following:<ul><li><strong class="bold">Microsoft Azure Resource </strong><strong class="bold">Manager</strong>: <strong class="bold">Azure</strong></li></ul></li>
<li><strong class="bold">Remaining options</strong>: Leave blank</li>
</ul>
<p>Once you’ve filled in these details, click <strong class="bold">Save</strong>.</p>
<p>We have everything<a id="_idIndexMarker962"/> we need to run our playbooks, so let’s do that.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor753"/>Running our playbooks</h2>
<p>Back on the <strong class="bold">Templates</strong> page, you should<a id="_idIndexMarker963"/> see the two templates<a id="_idTextAnchor754"/> we have configured listed:</p>
<div><div><img alt="Figure 16.10 – Our two templates" src="img/B21620_16_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.10 – Our two templates</p>
<p>To run the playbook from this page, click on the <strong class="bold">Rocket</strong> icon on the <strong class="bold">Launch WordPress</strong> template; this will initiate the playbook run and take you to a job page where you will be able to review the status of the playbook job:</p>
<div><div><img alt="Figure 16.11 – Launching WordPress in Azure using Ansible AWX" src="img/B21620_16_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.11 – Launching WordPress in Azure using Ansible AWX</p>
<p>If everything has worked<a id="_idIndexMarker964"/> as planned, after about 5 minutes, you should get confirmation that the playbook has been completed and that your resources have been launched:</p>
<div><div><img alt="Figure 16.12 – Ansible AWX has finished running the playbook" src="img/B21620_16_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.12 – Ansible AWX has finished running the playbook</p>
<p>From here, you can re-run the launch playbook again, and it should pick up the newly deployed resources as it did when we re-ran the playbook on our local machine.</p>
<p>Given the number of Azure resources<a id="_idIndexMarker965"/> we have launched, before we review the changes to the playbook code to run it in Ansible AWX, we should terminate the WordPress resources. Click on the <strong class="bold">Rocket</strong> icon next to the <strong class="bold">Terminate WordPress</strong> template to tear down the resources we just launched.</p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor755"/>Terminating the Kubernetes cluster</h2>
<p>Before terminating the Azure AKS<a id="_idIndexMarker966"/> resources, I recommend clicking around and exploring the Ansible AWX interface. Once you’ve finished, you can remove the Azure resources and tidy up your local configuration by running the following commands:</p>
<pre class="console">
$ AKSRG=rg-awx-cluster
$ AKSCLUSTER=aks-awx-cluster
$ az aks delete --resource-gro<a id="_idTextAnchor756"/>up $AKSRG --name $AKSCLUSTER
$ az group delete --name $AKSRG
$ kubectl config delete-cluster $AKSCLUSTER
$ kubectl config delete-context $AKSCLUSTER</pre> <p>The cluster will take about 5 minutes to remove. To be safe, please don’t close any windows until<a id="_idIndexMarker967"/> it has finished.</p>
<p class="callout-heading">Information</p>
<p class="callout">As always, please double-check that your cloud resources have been terminated – you don’t want to incur any unexpected costs.</p>
<p>Now that we’ve terminated all the cost-incurring resources, let’s discuss some of the considerations we had to make in our Playbook.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor757"/>Playbook considerations</h2>
<p>While we touched very lightly<a id="_idIndexMarker968"/> on some of the changes that we had to make to our playbook so that it runs on Ansible AWX, let’s do a deeper dive now.</p>
<h3>Changes to the existing playbook</h3>
<p>As we were running the code<a id="_idIndexMarker969"/> locally, to keep the playbook simple, we created a file called <code>secrets.yml</code> and loaded the variables from there. Now that we are running Ansible in a shared environment, we should treat our Ansible execution environment as if it were ephemeral, meaning that we cannot rely on this approach.</p>
<p>I used Ansible Vault to encrypt the passwords and ship them within the code to get around this. To do this, I ran the following commands:</p>
<pre class="console">
$ ansible-vault encrypt_string 'SomeP4ssw0rd4MySQL' --name 'db_password'
$ ansible-vault encrypt_string 'aP455w0rd4W0rDPR355' --name 'wp_password'</pre> <p>When prompted to enter the Vault password, I entered <code>wibble</code> as the password, which we then set the Vault password in Ansible AWX when adding credentials. You can see the results of the preceding command in the <code>group_vars/common.yml</code> file.</p>
<p>Going back to the playbook code when we ran the playbook from our local machine in <a href="B21620_09.xhtml#_idTextAnchor411"><em class="italic">Chapter 9</em></a>, <em class="italic">Moving to the Cloud</em>, the variable that contains the data for the<a id="_idTextAnchor758"/> public SSH key looked like this:</p>
<pre class="source-code">
vm_config:
  key:
    path: "/home/adminuser/.ssh/authorized_ke<a id="_idTextAnchor759"/>ys"
    data: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"</pre> <p>As you can see, we populate the <code>vm_config.key.data</code> variable by reading in the contents of the <code>~/.ssh/id_rsa.pub</code> file. However, when we moved our playbook to Ansible AWX, this file no longer exist<a id="_idTextAnchor760"/>s.</p>
<p>Because of that, we added the <code>ssh_key_public</code> variable, which contains the public portion of the private key we uploaded when adding the machine credential when we configured the template. This launches the resources in Azure. This meant the code needed to be updated to the following:</p>
<pre class="source-code">
vm_config:
  key:
    path: "/home/adminuser/.ssh/authorized_keys"
    data: "{{ ssh_key_public }}"</pre> <p>As far as changes go, there’s nothing too dramatic<a id="_idIndexMarker970"/> and hopefully not unexpected.</p>
<h3>Ansible Galaxy collections</h3>
<p>You may not have noticed, but we didn’t have<a id="_idIndexMarker971"/> to consider the modules that interact with Azure, one of the initial things we covered in <a href="B21620_09.xhtml#_idTextAnchor411"><em class="italic">Chapter 9</em></a>, <em class="italic">Moving to </em><em class="italic">the Cloud</em>.</p>
<p>Ansible AWX does not support these and other collections of modules we need for our playbook to run out of the box, so how did our playbook work without giving an error?</p>
<p>When we first added the project, we configured it to use the GitHub repository that supports this book and contains all the code we have discussed so far. This repository can be found at <a href="https://github.com/packtPublishing/Learn-Ansible-Second-Edition/">https://github.com/packtPublishing/Learn-Ansible-Second-Edition/</a>.</p>
<p>We only instructed Ansible AWX to use the <code>site.yml</code> and <code>destory.yml</code> files from the <code>Chapter16</code> folder, but in the background, Ansible AWX also used the <code>requirements.yml</code> file, which can be found in the <code>collections</code> folder in the repository’s root.</p>
<p>This file contains the following code:</p>
<pre class="source-code">
---
collections:
  - name: "azure.azcollection"
    source: "https://galaxy.ansible.com"
  - name: "community.general"
    source: "https://galaxy.ansible.com"
  - name: "community.mysql"
    source: "https://galaxy.ansible.com"</pre> <p>As you can see, this is letting Ansible AWX<a id="_idIndexMarker972"/> know that it needs to download the <code>azure.azcollection</code>, <code>community.general</code> and <code>community.mysql</code> collections from Ansible Galaxy and, in the background, install their prerequisites.</p>
<p>The only thing we needed to do to get this to work was to create the Ansible Galaxy credential and attach it to our default organization. This means that whenever Ansible AWX comes across a <code>collections/requirements.yml</code> file, it will authenticate against Ansible Galaxy using the credentials provided, which in our case were anonymous as we weren’t pulling a private collection.</p>
<p>We can also do things such as pin collections to<a id="_idTextAnchor761"/> a particular version or add a role:</p>
<pre class="source-code">
collections:
  - name: "azure.azcollection"
    source: "https://galaxy.ansible.com"
    version: 2.0.0
roles:
  - name: "russmckendrick.learnansible_example"
    source: "https://galaxy.ansible.com"</pre> <p>You can also provide different URLs if you are self-hosting an installation of Ansible Galaxy or even provide links to Git repos containing your roles and collections.</p>
<p>This means that Ansible AWX<a id="_idIndexMarker973"/> can be as flexible as running Ansible from your local machine.</p>
<p>Before we finish discussing Ansible AWX, let’s look at the pros <a id="_idTextAnchor762"/>and cons of running it.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor763"/>Ansible AWX’s advantages and disadvantages</h2>
<p>I am sure you will agree from our time with Ansible AWX that it looks like a great tool. However, there are some advantages and disadvantages to running it.</p>
<h3>Open source</h3>
<p>Ansible AWX is an open source <a id="_idIndexMarker974"/>project, which means it is freely available for anyone to use, modify, and contribute to. This can significantly reduce costs compared to proprietary solutions. However, it has limited Enterprise features.</p>
<p>Ansible AWX offers a good range of features. Still, some advanced enterprise-specific capabilities in Red Hat Ansible<a id="_idIndexMarker975"/> Automation Platform, such as advanced reporting, <strong class="bold">service-level agreement</strong> (<strong class="bold">SLA</strong>) management, and more comprehensive integrations, may be needed.</p>
<h3>Community-driven development</h3>
<p>Being open source, Ansible AWX has a strong community of developers and users actively contributing to its development, providing support, and sharing best practices.</p>
<p>However, as an open <a id="_idIndexMarker976"/>source project, Ansible AWX relies on community support rather than official commercial support. The community is generally active and helpful, but there are no guaranteed response times or even that someone will be able to help outside of the commercial Red Hat Ansible Automation Platform offering.</p>
<h3>Frequent updates and improvements</h3>
<p>Ansible AWX follows a more frequent release cycle than Red Hat Automation Platform. This means that you can gain access to new features, bug fixes, and improvements more quickly.</p>
<p>Ansible AWX’s frequent release cycle<a id="_idIndexMarker977"/> means you may need to update more often to access the latest features and bug fixes. Upgrading Ansible AWX can require more effort to ensure compatibility and stability, especially in production environments.</p>
<p>Updates and Ansible AWX have always been challenging; they have always been more of a migration than an in-place update.</p>
<p>Using our quick deployment of Ansible AWX as an example, we would need a way to upgrade it. We would have to deploy an external database server outside of our Kubernetes cluster for a more production-like environment – this would contain and persist all our data and configuration.</p>
<p>To <em class="italic">update</em> Ansible AWX, we would need<a id="_idIndexMarker978"/> to tear down all of the resources in the cluster (minus the database), update the AWX Operator, and then redeploy Ansible AWX running the latest version – this would then connect to our external database and run all of the necessary database migration scripts to update our schema and data to make it compatible with the new version.</p>
<h3>Solid foundation</h3>
<p>Ansible AWX provides robust features for managing and executing Ansible playbooks, making it a solid choice for organizations starting their automation journey or having more straightforward automation requirements.</p>
<h3>Flexibility and customization</h3>
<p>While Ansible AWX integrates <a id="_idIndexMarker979"/>with various tools and systems, it may have a different level of out-of-the-box integrations and certified content than Red Hat Automation Platform, which is designed to work seamlessly with other Red Hat products and has a broader ecosystem of supported integrations.</p>
<p>Ansible AWX may also have limitations<a id="_idIndexMarker980"/> when managing large-scale deployments or complex enterprise environments. Additional setup, configuration, and resources may be required to handle high-volume automation tasks effectively.</p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor764"/>Summary</h1>
<p>This chapter explored Ansible AWX and touched upon Red Hat Automation Platform, two powerful graphical interfaces for managing and streamlining Ansible deployments.</p>
<p>We learned about their differences, the benefits they offer, and how to install and configure Ansible AWX on a Kubernetes cluster in Microsoft Azure. We successfully ran our playbook to launch and terminate WordPress running in Azure using Ansible AWX by setting up a project, credentials, inventory, and templates.</p>
<p>Throughout the process, we discovered the necessary playbook considerations and modifications, such as using Ansible Vault for sensitive information, handling SSH keys, and leveraging Ansible Galaxy collections.</p>
<p>While Ansible AWX offers numerous advantages, including its open source nature, community-driven development, and solid foundation, it is essential to be aware of its potential limitations in enterprise environments and the challenges associated with updating the platform.</p>
<p>The only thing we didn’t discuss was the costs of running the commercially supported enterprise-grade Red Hat Automation Platform. Red Hat does not publicly publish them on its website. You must contact one of its partners or Red Hat directly for details.</p>
<p>In our next and final chapter, we will look at some of the ways you can integrate Ansible into your daily workflows, debug your playbooks as they run, and some real-world examples of how I have used Ansible.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor765"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><strong class="bold">Ansible AWX </strong><strong class="bold">Project</strong>: <a href="https://github.com/ansible/awx">https://github.com/ansible/awx</a></li>
<li><strong class="bold">Ansible AWX </strong><strong class="bold">Operator</strong>: <a href="https://github.com/ansible/awx-operator">https://github.com/ansible/awx-operator</a></li>
<li><strong class="bold">Ansible AWX </strong><strong class="bold">documentation</strong>: <a href="https://ansible.readthedocs.io/projects/awx/en/latest/">https://ansible.readthedocs.io/projects/awx/en/latest/</a></li>
<li><strong class="bold">Red Hat Ansible Automation </strong><strong class="bold">Platform</strong>: <a href="https://www.redhat.com/en/technologies/management/ansible">https://www.redhat.com/en/technologies/management/ansible</a></li>
</ul>
</div>
</body></html>