- en: Chapter 7. Advanced Access Control and Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic access control methods described in the previous chapter are sufficient
    for most sites, and there are many that do not go further than that. However,
    Gitolite has a lot more features waiting for people who need them. We'll go through
    some of these advanced features in this chapter. In each case, we'll attempt to
    describe a practical scenario that demonstrates a need and then explain how the
    feature fulfills that need.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the rc file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of Gitolite's advanced features and configuration options are managed by
    editing the *rc file*. This is a file named `.gitolite.rc`, which is present in
    the home directory of the Gitolite hosting user.
  prefs: []
  type: TYPE_NORMAL
- en: The file is liberally commented and it is generally easy to see where things
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk of the file is within a top-level definition that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you're familiar with Perl, you might realize that this is a Perl hash, but
    it is not necessary to know Perl in order to edit this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file has several simple variables defined, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the Gitolite documentation (or this book) tells you to edit a variable
    in the rc file, it's best to look for such a variable first—most of the important
    ones are already in the file but may be commented out, waiting to be un-commented
    and the value edited as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the variables within the `%RC` block is a list variable called `ENABLE`,
    whose definition looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An example feature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This enables the `info` command.
  prefs: []
  type: TYPE_NORMAL
- en: Again, most features are already listed here, but may be commented out.
  prefs: []
  type: TYPE_NORMAL
- en: Giving users their own branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When there are more than a few developers in a project, it is often necessary
    for them to share code that is still under development, for comments, discussion,
    preliminary testing, and so on. The obvious solution is for each developer to
    push to a branch on the Gitolite server and inform his colleagues of the branch
    name. A branch namespace dedicated to this can be created, giving all developers
    access to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This works fine, but it could lead to a situation where one developer accidentally
    overwrites or deletes another developer's branch if the branch naming within the
    *sandbox* namespace is not strictly controlled.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is required, ideally, is something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: and so on, for each user who should be given access to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is not at all scalable—you'd have to add one line for each user
    if you did this. In fact, it's a step backward because we've suddenly lost all
    the advantages of managing users in groups, since we are forced to use a separate
    rule for each developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This situation is what led to the development of what are called **personal
    branches** in Gitolite. This feature works on a simple idea, and is best described
    with the following example rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is that the word `USER`, surrounded by slashes, stands for the authenticated
    username from the connection information, as long as the user is listed on the
    right-hand side (or a group he/she belongs to is listed). Thus, if the user ID
    `alice` is a member of the `@developers` group, and Alice attempts to access the
    repository, this rule effectively becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This allows Alice to write to her own sandbox branches; that is, branches whose
    names start with `sandbox/alice/`. Note that this does not allow a branch called
    `sandbox/alice`—the sandbox is meant to be a set of branches not just one branch.
  prefs: []
  type: TYPE_NORMAL
- en: Since Gitolite does not allow limiting read access by branch, every user who
    is a member of the `@developers` group has read access to the repository, which
    means they can read each other's development branches, but only write (push to)
    their own sandbox branches.
  prefs: []
  type: TYPE_NORMAL
- en: Types of write operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have restricted ourselves to the `RW` and `RW+` permissions while
    talking about permissions. The former gives users permission to create new branches
    and tags, and make **fast forward** pushes to the branches, while the latter allows
    users to also make non-fast forward pushes and rewrite tags, as well as delete
    branches and tags.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is by far the most common situation, and this syntax serves for the vast
    majority of access control needs. A push to an existing tag, even if the new commit
    is a descendent of the current commit the tag is pointing to, is still considered
    a non-fast forward push. This is because, unlike branches, tags are not *meant*
    to be moved; once written, they're supposed to be fixed and never change.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some situations, you may need to explicitly specify the ability
    to *create* a branch, separating it from that of pushing a new commit to it. Similarly,
    you may want to explicitly specify permission to *delete* a branch or tag, separating
    it from that of pushing a non-fast forward commit; or, you may want to do both.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, Gitolite has an extended syntax for the permissions
    field to let you specify explicit create and/or delete permissions. Using these
    extended permissions in any rule applicable to a repository has the effect of
    limiting the power of the normal `RW` and `RW+` permissions, in terms of creating
    or deleting refs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This extended syntax consists of the following *new permissions*: `RWC`, `RW+C`,
    `RWD`, `RW+D`, `RWCD`, and `RW+CD`. When a rule specifying a permission containing
    a `C` is added to a repository, the `RW` and `RW+` rules for that repository no
    longer permit *creating* a branch or a tag. Similarly, when any rule specifies
    a permission containing a `D`, the `RW+` rules for that repository no longer allow
    *deleting* a ref. For ease of discussion, we can call these the *explicit create*
    and *explicit delete* modes, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful to summarize these rules in a tabular form, for ready reference
    in case you ever need to use these special permission modes. The following table
    shows you the minimum required permission "characters" to allow a given operation,
    in each of the three modes (strictly speaking, there is a fourth mode, where both
    explicit create and explicit delete are used, but that is just a combination of
    the two):'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Default mode | Explicit create mode | Explicit delete mode |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create new branch | `RW` | `RW` and `C` | `RW` |'
  prefs: []
  type: TYPE_TB
- en: '| Create new tag | `RW` | `RW` and `C` | `RW` |'
  prefs: []
  type: TYPE_TB
- en: '| Fast forward push existing branch | `RW` | `RW` | `RW` |'
  prefs: []
  type: TYPE_TB
- en: '| Non-fast forward push a branch | `RW+` | `RW+` | `RW+` |'
  prefs: []
  type: TYPE_TB
- en: '| Overwrite an existing tag | `RW+` | `RW+` | `RW+` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete branch | `RW+` | `RW+` | `RW` and `D` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete tag | `RW+` | `RW+` | `RW` and `D` |'
  prefs: []
  type: TYPE_TB
- en: Allowing Gitweb and Git-daemon access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gitweb** (and, to a lesser extent, **git-daemon**) are popular tools that
    provide alternative, read-only access to Git repositories. Git-daemon provides
    completely unauthenticated access to Git repositories, suitable for open source
    or similar projects. Gitweb displays repositories, their branches, commit history,
    and many more details on a web browser. Gitweb itself does not do any authentication,
    but relies on the web server to authenticate users.'
  prefs: []
  type: TYPE_NORMAL
- en: Gitweb and git-daemon have ways to determine which repositories are allowed
    to be made available to clients. For gitweb, the list of permitted repositories
    is placed in a specific format (at its simplest, one repository name per line)
    in a specific file at a configurable location (see the documentation for gitweb
    for details). On the other hand, git-daemon looks inside each individual repository
    for a file called `git-daemon-export-ok` , to determine if the repository should
    be made accessible to clients. Of course, both tools have other one-time configuration
    that needs to be handled and set up before they can be used. Gitweb, in particular,
    may not even run as the Gitolite hosting user, and the one-time setup will probably
    involve allowing it to read files owned by the Gitolite hosting user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Gitolite cannot help in the one-time configuration of these tools,
    it can certainly help in managing the access list. It does this by designating
    two special Gitolite usernames: `gitweb` and `daemon`. These users do not have
    public keys, so they''re not actual users in the same sense as Adam, Alice, or
    Bob in our examples. However, they determine which repositories are accessible
    by gitweb and git-daemon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is very simple. If you want a repository to be readable by gitweb,
    you give the `gitweb` user *read* access. Similarly, if you want the repository
    to be accessible via git-daemon, you give the `daemon` user *read* access. Here''s
    an example that does both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course, instead of specifying each repository, you can use any repository
    group name that you may have defined, or even the special group name `@all`.
  prefs: []
  type: TYPE_NORMAL
- en: When the gitolite-admin repository is pushed, Gitolite checks each repository
    to see if these special users have been given read access. For each such repository,
    Gitolite adds the name to the projects list file mentioned previously if the `gitweb`
    user can read it, and creates a file called `git-daemon-export-ok` if the `daemon`
    user can. Also, if you previously allowed access and then decided to remove it,
    Gitolite will delete the entry from the projects list file, and/or remove the
    `git-daemon-export-ok` file, as applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Locating the projects list file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned earlier that Gitweb consults a file containing a list of permitted
    repositories, and that Gitolite creates this file. Of course, Gitweb and Gitolite
    must agree on where this file is. Gitolite places it, by default, in `$HOME/projects.list`,
    but this can be changed to any other location if needed; simply add a line like
    the following to the `$HOME/.gitolite.rc` file, substituting whatever path you
    want of course.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntax of the preceding statement includes the trailing comma. This line
    must be placed in the section marked `rc variables used by various features`.
  prefs: []
  type: TYPE_NORMAL
- en: Unix permissions and the umask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gitweb is invoked by your web server (such as Apache), which is almost certainly
    running under a different user ID than your Gitolite hosting user. Depending on
    your OS and your web server, this could be a user called `apache`, `www-data`,
    or something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means you need to make sure that this user can read the files it needs
    (mainly the projects list file, and everything under `$HOME/repositories`). There
    are usually two ways of doing this. The simplest way is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the primary group that your Gitolite hosting user belongs to (usually
    the same as the username). You can find this by running the `id` command after
    logging in to the server as the Gitolite hosting user. On most systems, it is
    the same as the user ID, so for our discussion let's say it is `git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the Unix user ID under which your web server is running. For our discussion,
    let's say it is `apache`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `apache` user to the `git` group using the `usermod` command. (You need
    to run this as root on your server.) The exact syntax may vary depending on your
    OS and OS version. As an example, the command on a Red Hat system is `usermod
    -G git apache`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `UMASK` value in `$HOME/.gitolite.rc` from the default `0077` to
    `0027`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix up existing files manually. This is a one-time operation, required because
    `umask` only affects permissions on newly created files, not existing ones. Log
    in as the Gitolite hosting user and run the command `chmod -R g+rX $HOME/projects.list
    $HOME/repositories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second method to deal with this involves running gitweb as the Gitolite
    hosting user. Most web servers provide mechanisms to run specific programs under
    some other user ID than the user ID under which the web server is running, such
    as the `suexec` feature in the Apache web server. Configuring these features is
    out of scope for this book; please check the documentation of your web server
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Git config values and Gitolite options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're familiar with Git, you probably know the `git config` command, which
    allows you to set repository options. Example of config variables that may be
    useful for server-side (bare) repositories are `core.logAllRefUpdates`, `receive.fsckObjects`,
    and various performance-related config variables. (Please see the man page for
    `git-config` for details)
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitolite aims to allow almost all administration remotely, so it would be unreasonable
    to expect the admin to log on to the server and run the `git` `config` command.
    Therefore, Gitolite allows the admin to specify config settings within the conf
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, before you can use this feature, you need to enable the config keys
    you wish to use in the *rc* file `($HOME/.gitolite.rc`). Look in this file for
    a line that contains the word `GIT_CONFIG_KEYS` and edit the value, which is empty
    by default, to contain a space separated list of the config keys you are planning
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the syntax is `config sectionname.keyname = value`. On the server,
    this is executed as `git config sectionname.keyname value`. Gitolite does *not*
    support any of the other forms of the `git config` command, especially keys with
    multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a git-config key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, once a git `config` key has been created by Gitolite, simply
    removing the line from the conf file will not, on the next push, delete the key
    from the repository config file. This is because you *are* permitted to add keys
    directly on the server if you choose to (or your repository may have inherited
    some useful settings when you migrated it into Gitolite's control). Gitolite has
    no simple way of distinguishing `config` keys you created manually from those
    that were deleted in the conf file; that is, it can be done but it's complicated
    and potentially error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Gitolite requires the following syntax in order to explicitly delete
    a `config` key from the repository config file on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the only way to delete a `config` key using Gitolite.
  prefs: []
  type: TYPE_NORMAL
- en: Substituting the repository name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you need the same config setting for multiple repositories, but you
    only need to vary the repository name itself. The obvious way seems to be to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But, of course, this does not scale at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitolite allows you to do the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Gitolite expands the token `%GL_REPO` into each repository's name when actually
    applying the config lines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget that in the `repo` line, you can have one or more repository groups,
    or a combination of repositories and groups. You can also use `@all` if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding config values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want to add a config value to all the repositories, except one
    or two. For example, consider the `hooks.mailinglist config` variable shown earlier,
    and imagine that, while the setting is correct for most repositories, one specific
    repository needs a completely different mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitolite allows you to do this as follows. First the general setting applicable
    to all repositories is added. Then, specific settings for specific repositories
    are added. Gitolite will ensure that for any repository, the last seen config
    setting will be the one used (and therefore, the order of these statements matters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can even use an empty value for the last line, if you wish that the special
    repository mentioned does not even have the corresponding entry in its config
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Git''s config keys and values, Gitolite also has its own set of
    internal options, which are used to modify its default behavior in some way or
    provide additional information that some feature may need. For example, if you
    use Gitolite''s mirroring feature (discussed in [Chapter 11](ch11.html "Chapter 11. Mirroring"),
    *Mirroring*), you will need to specify, for each repository, which server is the
    master server and which are the slaves. These server names are specified using
    Gitolite options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the mirroring code runs, it interrogates Gitolite for the value of these
    options in order to do its job.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite options behave just like the `config` entries, shown earlier, do in
    terms of later entries overriding earlier values.
  prefs: []
  type: TYPE_NORMAL
- en: Applying deny rules to read access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, when we looked at the `deny` rules, we showed them
    only in the context of a write operation, controlling whether a certain branch
    or tag can be pushed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the deny rules are not examined when checking read access. So something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: will not prevent Bob from at least reading the repository (that is, using `git
    clone` or `git fetch`), even though the deny rule appears first.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is possible to make Gitolite act on deny rules in this case also.
    This is achieved by specifying a Gitolite option called `deny-rules`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now Bob will not even be able to clone the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also important to understand that, for read access, specifying an actual
    branch in the deny rule, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: is the same as not having a branch in the rule. This is because Git (and therefore
    Gitolite) does not distinguish between branches for read access control, so any
    specified refex is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The `deny-rules` option will prevent write access the same way it prevents read
    access. It does not make sense to allow a user to write what they cannot read!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding VREFs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced us to the concept of a *refex*, which is a regular
    expression that is used to match the ref being pushed. This allows us to make
    decisions on allowing or rejecting the push based on the name of the ref (branch
    or tag) being pushed.
  prefs: []
  type: TYPE_NORMAL
- en: However, we might have other criteria for deciding whether to allow or deny
    the push. The most common example is whether specific files have been changed,
    and if they have, to disallow the push.
  prefs: []
  type: TYPE_NORMAL
- en: A *VREF* is a special kind of refex; the "V" stands for "Virtual". This is a
    refex that will not match the ref that Git knows about (which is a branch name
    or a tag name). Rather, it will attempt to match against some other characteristic
    of the commit or series of commits being pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example. Let''s say you are running a project where the build system,
    and in particular the `Makefile`, is a rather critical component and has been
    finely tuned to play nicely with all the environments for which your product is
    built and sold. As a result, you really don''t want anyone but the most experienced
    people messing with that file (and perhaps others related to it). You would, therefore,
    like to prevent your junior developers from being able to push changes to it.
    Here''s how you would do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That is basically all you have to do. First, the ruleset is checked for the
    ref that is being pushed (in this example, we simplified all that by allowing
    all developers—which includes junior developers—to push any branch). Once this
    succeeds, the *VREFs* specified are checked in the order they appear in the list
    of rules.
  prefs: []
  type: TYPE_NORMAL
- en: A VREF rule has a simple structure, consisting of the word `VREF`, followed
    by the name of the VREF (in this case, `NAME`, which is a VREF that checks the
    names of changed files and directories), followed by an argument of some kind.
    The list of changed file names is matched against that argument, and if a match
    is found, it is just as if you were trying to push a branch and the refex matched,
    which is to say the permission in the rule line drives what happens next. In this
    example, that results in the push being denied.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a simple preview of the VREF feature. [Chapter 10](ch10.html
    "Chapter 10. Understanding VREFs"), *Understanding VREFs*, will go into much more
    detail about this powerful feature of Gitolite.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of Gitolite's advanced features, such as
    personal branches, Git config variables, Gitolite options, and so on. The next
    chapter will focus on another very powerful and popular feature of Gitolite, allowing
    your users to create their own repositories without having to add anything new
    to the conf file.
  prefs: []
  type: TYPE_NORMAL
